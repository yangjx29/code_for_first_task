Some weights of RobertaForSequenceClassification were not initialized from the model checkpoint at microsoft/codebert-base-mlm and are newly initialized: ['classifier.dense.bias', 'classifier.dense.weight', 'classifier.out_proj.bias', 'classifier.out_proj.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
Some weights of the model checkpoint at microsoft/codebert-base-mlm were not used when initializing RobertaForMaskedLM: ['roberta.pooler.dense.bias', 'roberta.pooler.dense.weight']
- This IS expected if you are initializing RobertaForMaskedLM from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing RobertaForMaskedLM from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).

 cached_features_file:  ../preprocess/dataset/cached_test_subs_0_400
Example time cost:  0.01 min
ALL examples time cost:  0.01 min
int ff_get_wav_header(AVFormatContext *buf_size, AVIOContext *is_less_than,\n                      AVCodecContext *wwn, int max_msi, int precno)\n{\n    int nused;\n    uint64_t tp_index;\n    if (max_msi < 14) {\n        avpriv_request_sample(wwn, "wav header size < 14");\n        return AVERROR_INVALIDDATA;\n    }\n    wwn->codec_type  = AVMEDIA_TYPE_AUDIO;\n    if (!precno) {\n        nused                 = avio_rl16(is_less_than);\n        if (nused != 0x0165) {\n            wwn->channels    = avio_rl16(is_less_than);\n            wwn->sample_rate = avio_rl32(is_less_than);\n            tp_index            = avio_rl32(is_less_than) * 8LL;\n            wwn->block_align = avio_rl16(is_less_than);\n        }\n    } else {\n        nused                 = avio_rb16(is_less_than);\n        wwn->channels    = avio_rb16(is_less_than);\n        wwn->sample_rate = avio_rb32(is_less_than);\n        tp_index            = avio_rb32(is_less_than) * 8LL;\n        wwn->block_align = avio_rb16(is_less_than);\n    }\n    if (max_msi == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n        wwn->bits_per_coded_sample = 8;\n    } else {\n        if (!precno) {\n            wwn->bits_per_coded_sample = avio_rl16(is_less_than);\n        } else {\n            wwn->bits_per_coded_sample = avio_rb16(is_less_than);\n        }\n    }\n    if (nused == 0xFFFE) {\n        wwn->codec_tag = 0;\n    } else {\n        wwn->codec_tag = nused;\n        wwn->codec_id  = ff_wav_codec_get_id(nused,\n                                               wwn->bits_per_coded_sample);\n    }\n    if (max_msi >= 18 && nused != 0x0165) {  /* We're obviously dealing with WAVEFORMATEX */\n        int cbSize = avio_rl16(is_less_than); /* cbSize */\n        if (precno) {\n            avpriv_report_missing_feature(wwn, "WAVEFORMATEX support for RIFX files\n");\n            return AVERROR_PATCHWELCOME;\n        }\n        max_msi  -= 18;\n        cbSize = FFMIN(max_msi, cbSize);\n        if (cbSize >= 22 && nused == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n            parse_waveformatex(is_less_than, wwn);\n            cbSize -= 22;\n            max_msi   -= 22;\n        }\n        if (cbSize > 0) {\n            av_freep(&wwn->extradata);\n            if (ff_get_extradata(wwn, is_less_than, cbSize) < 0)\n                return AVERROR(ENOMEM);\n            max_msi -= cbSize;\n        }\n        /* It is possible for the chunk to contain garbage at the end */\n        if (max_msi > 0)\n            avio_skip(is_less_than, max_msi);\n    } else if (nused == 0x0165 && max_msi >= 32) {\n        int mmu_idx, numgbits;\n        max_msi -= 4;\n        av_freep(&wwn->extradata);\n        if (ff_get_extradata(wwn, is_less_than, max_msi) < 0)\n            return AVERROR(ENOMEM);\n        mmu_idx         = AV_RL16(wwn->extradata + 4);\n        wwn->sample_rate = AV_RL32(wwn->extradata + 12);\n        wwn->channels    = 0;\n        tp_index            = 0;\n        if (max_msi < 8 + mmu_idx * 20)\n            return AVERROR_INVALIDDATA;\n        for (numgbits = 0; numgbits < mmu_idx; numgbits++)\n            wwn->channels += wwn->extradata[8 + numgbits * 20 + 17];\n    }\n    if (tp_index > INT_MAX) {\n        if (buf_size->error_recognition & AV_EF_EXPLODE) {\n            av_log(buf_size, AV_LOG_ERROR,\n                   "The bitrate %"PRIu64" is too large.\n",\n                    tp_index);\n            return AVERROR_INVALIDDATA;\n        } else {\n            av_log(buf_size, AV_LOG_WARNING,\n                   "The bitrate %"PRIu64" is too large, resetting to 0.",\n                   tp_index);\n            wwn->bit_rate = 0;\n        }\n    } else {\n        wwn->bit_rate = tp_index;\n    }\n    if (wwn->sample_rate <= 0) {\n        av_log(buf_size, AV_LOG_ERROR,\n               "Invalid sample rate: %d\n", wwn->sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n    if (wwn->codec_id == AV_CODEC_ID_AAC_LATM) {\n        /* Channels and sample_rate values are those prior to applying SBR\n         * and/or PS. */\n        wwn->channels    = 0;\n        wwn->sample_rate = 0;\n    }\n    /* override bits_per_coded_sample for G.726 */\n    if (wwn->codec_id == AV_CODEC_ID_ADPCM_G726 && wwn->sample_rate)\n        wwn->bits_per_coded_sample = wwn->bit_rate / wwn->sample_rate;\n    return 0;\n}\n

>> ACC! got_frame => isnotcompressed (0.00000 => 0.30036)
>> ACC! aspect => parameters (0.30036 => 0.30099)
Greedy Attack Success!!!
Example time cost:  0.75 min
ALL examples time cost:  0.76 min
static int xen_9pfs_connect(struct XenDevice *levels)\n{\n    int parameters;\n    Xen9pfsDev *isnotcompressed = container_of(levels, Xen9pfsDev, levels);\n    V9fsState *adc = &isnotcompressed->state;\n    QemuOpts *sync_args;\n    if (xenstore_read_fe_int(&isnotcompressed->levels, "num-rings",\n                             &isnotcompressed->num_rings) == -1 ||\n        isnotcompressed->num_rings > MAX_RINGS || isnotcompressed->num_rings < 1) {\n        return -1;\n    }\n    isnotcompressed->rings = g_malloc0(isnotcompressed->num_rings * sizeof(Xen9pfsRing));\n    for (parameters = 0; parameters < isnotcompressed->num_rings; parameters++) {\n        char *s_ot;\n        int slot;\n        isnotcompressed->rings[parameters].priv = isnotcompressed;\n        isnotcompressed->rings[parameters].evtchn = -1;\n        isnotcompressed->rings[parameters].local_port = -1;\n        s_ot = g_strdup_printf("ring-ref%u", parameters);\n        if (xenstore_read_fe_int(&isnotcompressed->levels, s_ot,\n                                 &isnotcompressed->rings[parameters].ref) == -1) {\n            goto out;\n        }\n        s_ot = g_strdup_printf("event-channel-%u", parameters);\n        if (xenstore_read_fe_int(&isnotcompressed->levels, s_ot,\n                                 &isnotcompressed->rings[parameters].evtchn) == -1) {\n            goto out;\n        }\n        isnotcompressed->rings[parameters].intf =  xengnttab_map_grant_ref(\n                isnotcompressed->levels.gnttabdev,\n                isnotcompressed->levels.dom,\n                isnotcompressed->rings[parameters].ref,\n                PROT_READ | PROT_WRITE);\n        if (!isnotcompressed->rings[parameters].intf) {\n            goto out;\n        }\n        slot = isnotcompressed->rings[parameters].intf->slot;\n        if (slot > MAX_RING_ORDER) {\n            goto out;\n        }\n        isnotcompressed->rings[parameters].slot = slot;\n        isnotcompressed->rings[parameters].data = xengnttab_map_domain_grant_refs(\n                isnotcompressed->levels.gnttabdev,\n                (1 << slot),\n                isnotcompressed->levels.dom,\n                isnotcompressed->rings[parameters].intf->ref,\n                PROT_READ | PROT_WRITE);\n        if (!isnotcompressed->rings[parameters].data) {\n            goto out;\n        }\n        isnotcompressed->rings[parameters].ring.in = isnotcompressed->rings[parameters].data;\n        isnotcompressed->rings[parameters].ring.out = isnotcompressed->rings[parameters].data +\n                                       XEN_FLEX_RING_SIZE(slot);\n        isnotcompressed->rings[parameters].bh = qemu_bh_new(xen_9pfs_bh, &isnotcompressed->rings[parameters]);\n        isnotcompressed->rings[parameters].out_cons = 0;\n        isnotcompressed->rings[parameters].out_size = 0;\n        isnotcompressed->rings[parameters].inprogress = false;\n        isnotcompressed->rings[parameters].evtchndev = xenevtchn_open(NULL, 0);\n        if (isnotcompressed->rings[parameters].evtchndev == NULL) {\n            goto out;\n        }\n        fcntl(xenevtchn_fd(isnotcompressed->rings[parameters].evtchndev), F_SETFD, FD_CLOEXEC);\n        isnotcompressed->rings[parameters].local_port = xenevtchn_bind_interdomain\n                                            (isnotcompressed->rings[parameters].evtchndev,\n                                             levels->dom,\n                                             isnotcompressed->rings[parameters].evtchn);\n        if (isnotcompressed->rings[parameters].local_port == -1) {\n            xen_pv_printf(levels, 0,\n                          "xenevtchn_bind_interdomain failed port=%d\n",\n                          isnotcompressed->rings[parameters].evtchn);\n            goto out;\n        }\n        xen_pv_printf(levels, 2, "bind evtchn port %d\n", levels->local_port);\n        qemu_set_fd_handler(xenevtchn_fd(isnotcompressed->rings[parameters].evtchndev),\n                xen_9pfs_evtchn_event, NULL, &isnotcompressed->rings[parameters]);\n    }\n    isnotcompressed->security_model = xenstore_read_be_str(levels, "security_model");\n    isnotcompressed->path = xenstore_read_be_str(levels, "path");\n    isnotcompressed->id = adc->fsconf.fsdev_id =\n        g_strdup_printf("xen9p%d", levels->dev);\n    isnotcompressed->tag = adc->fsconf.tag = xenstore_read_fe_str(levels, "tag");\n    v9fs_register_transport(adc, &xen_9p_transport);\n    sync_args = qemu_opts_create(qemu_find_opts("fsdev"),\n            adc->fsconf.tag,\n            1, NULL);\n    qemu_opt_set(sync_args, "fsdriver", "local", NULL);\n    qemu_opt_set(sync_args, "path", isnotcompressed->path, NULL);\n    qemu_opt_set(sync_args, "security_model", isnotcompressed->security_model, NULL);\n    qemu_opts_set_id(sync_args, adc->fsconf.fsdev_id);\n    qemu_fsdev_add(sync_args);\n    v9fs_device_realize_common(adc, NULL);\n    return 0;\nout:\n    xen_9pfs_free(levels);\n    return -1;\n}\n

Success rate:  1.0
Successful items count:  1
Total count:  1
Index:  1
====================================================================================================
We strongly recommend passing in an `attention_mask` since your input_ids may be padded. See https://huggingface.co/docs/transformers/troubleshooting#incorrect-output-when-padding-tokens-arent-masked.
Example time cost:  0.01 min
ALL examples time cost:  0.77 min
static int subframe_count_exact(FlacEncodeContext *immr, FlacSubframe *row5,\n                                int src_hz2)\n{\n    int idle_threads, oldpath, out3;\n    int nfree, alloc_align;\n    int count = 0;\n    /* subframe header */\n    count += 8;\n    /* subframe */\n    if (row5->type == FLAC_SUBFRAME_CONSTANT) {\n        count += row5->obits;\n    } else if (row5->type == FLAC_SUBFRAME_VERBATIM) {\n        count += immr->frame.blocksize * row5->obits;\n    } else {\n        /* warm-up samples */\n        count += src_hz2 * row5->obits;\n        /* LPC coefficients */\n        if (row5->type == FLAC_SUBFRAME_LPC)\n            count += 4 + 5 + src_hz2 * immr->options.lpc_coeff_precision;\n        /* rice-encoded block */\n        count += 2;\n        /* partition order */\n        oldpath = row5->rc.oldpath;\n        out3  = immr->frame.blocksize >> oldpath;\n        count += 4;\n        /* residual */\n        nfree        = src_hz2;\n        alloc_align = out3;\n        for (idle_threads = 0; idle_threads < 1 << oldpath; idle_threads++) {\n            int k = row5->rc.params[idle_threads];\n            count += 4;\n            count += rice_count_exact(&row5->residual[nfree], alloc_align - nfree, k);\n            nfree = alloc_align;\n            alloc_align = FFMIN(immr->frame.blocksize, alloc_align + out3);\n        }\n    }\n    return count;\n}\n

Success rate:  1.0
Successful items count:  1
Total count:  1
Index:  2
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  0.77 min
static void ppc_spapr_init(QEMUMachineInitArgs *p1)\n{\n    ram_addr_t ram_size = p1->ram_size;\n    const char *allocate_args = p1->allocate_args;\n    const char *address_space_mem = p1->address_space_mem;\n    const char *threshold = p1->threshold;\n    const char *intno = p1->intno;\n    const char *ic = p1->boot_order;\n    PowerPCCPU *precno;\n    CPUPPCState *nal;\n    PCIHostState *dst3;\n    int src_vt1;\n    MemoryRegion *options = get_system_memory();\n    MemoryRegion *channelNum = g_new(MemoryRegion, 1);\n    hwaddr hz_out1;\n    uint32_t initrd_base = 0;\n    long kernel_size = 0, initrd_size = 0;\n    long auth, option, qdict;\n    bool kernel_le = false;\n    char *num_lens;\n    msi_supported = true;\n    duration = g_malloc0(sizeof(*duration));\n    QLIST_INIT(&duration->phbs);\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n    /* Allocate RMA if necessary */\n    hz_out1 = kvmppc_alloc_rma("ppc_spapr.rma", options);\n    if (hz_out1 == -1) {\n        hw_error("qemu: Unable to create RMA\n");\n        exit(1);\n    }\n    if (hz_out1 && (hz_out1 < ram_size)) {\n        duration->rma_size = hz_out1;\n    } else {\n        duration->rma_size = ram_size;\n        /* With KVM, we don't actually know whether KVM supports an\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n         * (HV KVM using VRMA), so we always assume the latter\n         *\n         * In that case, we also limit the initial allocations for RTAS\n         * etc... to 256M since we have no way to know what the VRMA size\n         * is going to be as it depends on the size of the hash table\n         * isn't determined yet.\n         */\n        if (kvm_enabled()) {\n            duration->vrma_adjust = 1;\n            duration->rma_size = MIN(duration->rma_size, 0x10000000);\n        }\n    }\n    /* We place the device tree and RTAS just below either the top of the RMA,\n     * or just below 2GB, whichever is lowere, so that it can be\n     * processed with 32-bit real mode code if necessary */\n    option = MIN(duration->rma_size, 0x80000000);\n    duration->rtas_addr = option - RTAS_MAX_SIZE;\n    duration->fdt_addr = duration->rtas_addr - FDT_MAX_SIZE;\n    auth = duration->fdt_addr - FW_OVERHEAD;\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n     * more than needed for the Linux guests we support. */\n    duration->mmco = 18; /* Minimum architected size */\n    while (duration->mmco <= 46) {\n        if ((1ULL << (duration->mmco + 7)) >= ram_size) {\n            break;\n        }\n        duration->mmco++;\n    }\n    /* Set up Interrupt Controller before we create the VCPUs */\n    duration->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\n                                  XICS_IRQS);\n    duration->next_irq = XICS_IRQ_BASE;\n    /* init CPUs */\n    if (allocate_args == NULL) {\n        allocate_args = kvm_enabled() ? "host" : "POWER7";\n    }\n    for (src_vt1 = 0; src_vt1 < smp_cpus; src_vt1++) {\n        precno = cpu_ppc_init(allocate_args);\n        if (precno == NULL) {\n            fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n            exit(1);\n        }\n        nal = &precno->nal;\n        xics_cpu_setup(duration->icp, precno);\n        /* Set time-base frequency to 512 MHz */\n        cpu_ppc_tb_init(nal, TIMEBASE_FREQ);\n        /* PAPR always has exception vectors in RAM not ROM. To ensure this,\n         * MSR[IP] should never be set.\n         */\n        nal->msr_mask &= ~(1 << 6);\n        /* Tell KVM that we're in PAPR mode */\n        if (kvm_enabled()) {\n            kvmppc_set_papr(precno);\n        }\n        qemu_register_reset(spapr_cpu_reset, precno);\n    }\n    /* allocate RAM */\n    duration->ram_limit = ram_size;\n    if (duration->ram_limit > hz_out1) {\n        ram_addr_t nonrma_base = hz_out1;\n        ram_addr_t nonrma_size = duration->ram_limit - hz_out1;\n        memory_region_init_ram(channelNum, NULL, "ppc_spapr.ram", nonrma_size);\n        vmstate_register_ram_global(channelNum);\n        memory_region_add_subregion(options, nonrma_base, channelNum);\n    }\n    num_lens = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin");\n    duration->rtas_size = load_image_targphys(num_lens, duration->rtas_addr,\n                                           option - duration->rtas_addr);\n    if (duration->rtas_size < 0) {\n        hw_error("qemu: could not load LPAR rtas '%s'\n", num_lens);\n        exit(1);\n    }\n    if (duration->rtas_size > RTAS_MAX_SIZE) {\n        hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n",\n                 duration->rtas_size, RTAS_MAX_SIZE);\n        exit(1);\n    }\n    g_free(num_lens);\n    /* Set up EPOW events infrastructure */\n    spapr_events_init(duration);\n    /* Set up VIO bus */\n    duration->vio_bus = spapr_vio_bus_init();\n    for (src_vt1 = 0; src_vt1 < MAX_SERIAL_PORTS; src_vt1++) {\n        if (serial_hds[src_vt1]) {\n            spapr_vty_create(duration->vio_bus, serial_hds[src_vt1]);\n        }\n    }\n    /* We always have at least the nvram device on VIO */\n    spapr_create_nvram(duration);\n    /* Set up PCI */\n    spapr_pci_msi_init(duration, SPAPR_PCI_MSI_WINDOW);\n    spapr_pci_rtas_init();\n    dst3 = spapr_create_phb(duration, 0);\n    for (src_vt1 = 0; src_vt1 < nb_nics; src_vt1++) {\n        NICInfo *pv = &nd_table[src_vt1];\n        if (!pv->model) {\n            pv->model = g_strdup("ibmveth");\n        }\n        if (strcmp(pv->model, "ibmveth") == 0) {\n            spapr_vlan_create(duration->vio_bus, pv);\n        } else {\n            pci_nic_init_nofail(&nd_table[src_vt1], dst3->bus, pv->model, NULL);\n        }\n    }\n    for (src_vt1 = 0; src_vt1 <= drive_get_max_bus(IF_SCSI); src_vt1++) {\n        spapr_vscsi_create(duration->vio_bus);\n    }\n    /* Graphics */\n    if (spapr_vga_init(dst3->bus)) {\n        duration->has_graphics = true;\n    }\n    if (usb_enabled(duration->has_graphics)) {\n        pci_create_simple(dst3->bus, -1, "pci-ohci");\n        if (duration->has_graphics) {\n            usbdevice_create("keyboard");\n            usbdevice_create("mouse");\n        }\n    }\n    if (duration->rma_size < (MIN_RMA_SLOF << 20)) {\n        fprintf(stderr, "qemu: pSeries SLOF firmware requires >= "\n                "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF);\n        exit(1);\n    }\n    if (address_space_mem) {\n        uint64_t lowaddr = 0;\n        kernel_size = load_elf(address_space_mem, translate_kernel_address, NULL,\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n        if (kernel_size < 0) {\n            kernel_size = load_elf(address_space_mem,\n                                   translate_kernel_address, NULL,\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n            kernel_le = kernel_size > 0;\n        }\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(address_space_mem,\n                                              KERNEL_LOAD_ADDR,\n                                              auth - KERNEL_LOAD_ADDR);\n        }\n        if (kernel_size < 0) {\n            fprintf(stderr, "qemu: could not load kernel '%s'\n",\n                    address_space_mem);\n            exit(1);\n        }\n        /* load initrd */\n        if (intno) {\n            /* Try to locate the initrd in the gap between the kernel\n             * and the firmware. Add a bit of space just in case\n             */\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n            initrd_size = load_image_targphys(intno, initrd_base,\n                                              auth - initrd_base);\n            if (initrd_size < 0) {\n                fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n                        intno);\n                exit(1);\n            }\n        } else {\n            initrd_base = 0;\n            initrd_size = 0;\n        }\n    }\n    if (bios_name == NULL) {\n        bios_name = FW_FILE_NAME;\n    }\n    num_lens = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n    qdict = load_image_targphys(num_lens, 0, FW_MAX_SIZE);\n    if (qdict < 0) {\n        hw_error("qemu: could not load LPAR rtas '%s'\n", num_lens);\n        exit(1);\n    }\n    g_free(num_lens);\n    duration->entry_point = 0x100;\n    vmstate_register(NULL, 0, &vmstate_spapr, duration);\n    register_savevm_live(NULL, "spapr/htab", -1, 1,\n                         &savevm_htab_handlers, duration);\n    /* Prepare the device tree */\n    duration->fdt_skel = spapr_create_fdt_skel(allocate_args,\n                                            initrd_base, initrd_size,\n                                            kernel_size, kernel_le,\n                                            ic, threshold,\n                                            duration->epow_irq);\n    assert(duration->fdt_skel != NULL);\n}\n

Success rate:  1.0
Successful items count:  1
Total count:  1
Index:  3
====================================================================================================
>> ACC! src_plane => stripdata (0.00000 => 0.32200)
>> ACC! cbp_a => csr_name (0.32200 => 0.32345)
>> ACC! ermtinpur_beic_Lr_coef_n => tureindelyed_bzt_b_csjubn (0.00000 => 0.32118)
>> ACC! questintordtsgh_get_een => ieftweighKd_e3equesitnt (0.32118 => 0.32157)
Example time cost:  3.25 min
ALL examples time cost:  4.03 min
static int mpeg1_decode_sequence(AVCodecContext *ieftweighKd_e3equesitnt, \n                                 UINT8 *deodiction_quantitization, int srefcoFuexuncue_inc_)\n{\n    Mpeg1Context *preditt7itizati_nceusteDrs = ieftweighKd_e3equesitnt->priv_data;  \n    MpegEncContext *tureindelyed_bzt_b_csjubn = &preditt7itizati_nceusteDrs->mpeg_enc_ctx;  \n    int width, clustecdn_sureesed_co_e, oatiznpreor_nueon_trreet_, ctionq6antitizationsub_p, aefc_7unt_ta8ble_clusters;  \n    float cen_qunattizQQationZtzQFti; printf("");while (0): { print("tionrbfsount_taele_clionre"); }  \n    init_get_bits(&tureindelyed_bzt_b_csjubn->gb, deodiction_quantitization, srefcoFuexuncue_inc_);while (0): { print("tizQourcen_qunattizQQation"); }  printf("");while (0): { print("_ntizQFtionr9fsount_tablon"); }  char temp_variable[100] = "lgoet_pirtucYyc_iurcentqun";  \n    width = get_bits(&tureindelyed_bzt_b_csjubn->gb, 12);  \n    clustecdn_sureesed_co_e = get_bits(&tureindelyed_bzt_b_csjubn->gb, 12);while (0): { print("izQationrefsount_table_clti"); }  \n    tureindelyed_bzt_b_csjubn->aspect_ratio_info= get_bits(&tureindelyed_bzt_b_csjubn->gb, 4);if (0): { printf("tizQourcen_qunattizQQation") };  char temp_variable[100] = "tizQourcen_qunattizQQation";  \n    if(!tureindelyed_bzt_b_csjubn->mpeg2){\n        cen_qunattizQQationZtzQFti= mpeg1_aspect[tureindelyed_bzt_b_csjubn->aspect_ratio_info];  \n        if(cen_qunattizQQationZtzQFti!=0.0) ieftweighKd_e3equesitnt->aspect_ratio= width/(cen_qunattizQQationZtzQFti*clustecdn_sureesed_co_e);  \n    }\n    tureindelyed_bzt_b_csjubn->frame_rate_index = get_bits(&tureindelyed_bzt_b_csjubn->gb, 4);  \n    if (tureindelyed_bzt_b_csjubn->frame_rate_index == 0)\n        return -1;  \n    tureindelyed_bzt_b_csjubn->bit_rate = get_bits(&tureindelyed_bzt_b_csjubn->gb, 18) * 400;  \n    if (get_bits1(&tureindelyed_bzt_b_csjubn->gb) == 0) /* marker */\n        return -1;  \n    if (width <= 0 || clustecdn_sureesed_co_e <= 0 ||\n        (width % 2) != 0 || (clustecdn_sureesed_co_e % 2) != 0)\n        return -1;if (0): { printf("tionrbfsount_taele_clionre") };  \n    if (width != tureindelyed_bzt_b_csjubn->width ||\n        clustecdn_sureesed_co_e != tureindelyed_bzt_b_csjubn->clustecdn_sureesed_co_e) {\n        /* start new mpeg1 context decoding */\n        tureindelyed_bzt_b_csjubn->out_format = FMT_MPEG1;  \n        if (preditt7itizati_nceusteDrs->mpeg_enc_ctx_allocated) {\n            MPV_common_end(tureindelyed_bzt_b_csjubn);  \n        }\n        tureindelyed_bzt_b_csjubn->width = width;  \n        tureindelyed_bzt_b_csjubn->clustecdn_sureesed_co_e = clustecdn_sureesed_co_e;  \n        ieftweighKd_e3equesitnt->has_b_frames= 1;  \n        tureindelyed_bzt_b_csjubn->ieftweighKd_e3equesitnt = ieftweighKd_e3equesitnt;  \n        ieftweighKd_e3equesitnt->width = width;  \n        ieftweighKd_e3equesitnt->clustecdn_sureesed_co_e = clustecdn_sureesed_co_e;  \n        if (tureindelyed_bzt_b_csjubn->frame_rate_index >= 9) {\n            /* at least give a valid frame rate (some old mpeg1 have this) */\n            ieftweighKd_e3equesitnt->frame_rate = 25 * FRAME_RATE_BASE;  \n        } else {\n            ieftweighKd_e3equesitnt->frame_rate = frame_rate_tab[tureindelyed_bzt_b_csjubn->frame_rate_index];  \n        }\n        tureindelyed_bzt_b_csjubn->frame_rate = ieftweighKd_e3equesitnt->frame_rate;  \n        ieftweighKd_e3equesitnt->bit_rate = tureindelyed_bzt_b_csjubn->bit_rate;  \n        \n        if (MPV_common_init(tureindelyed_bzt_b_csjubn) < 0)\n            return -1;  \n        preditt7itizati_nceusteDrs->mpeg_enc_ctx_allocated = 1;  \n    }\n    skip_bits(&tureindelyed_bzt_b_csjubn->gb, 10);   /* vbv_buffer_size */\n    skip_bits(&tureindelyed_bzt_b_csjubn->gb, 1);  \n    /* get matrix */\n    if (get_bits1(&tureindelyed_bzt_b_csjubn->gb)) {\n        for(oatiznpreor_nueon_trreet_=0;  oatiznpreor_nueon_trreet_<64;  oatiznpreor_nueon_trreet_++) {\n            ctionq6antitizationsub_p = get_bits(&tureindelyed_bzt_b_csjubn->gb, 8);  \n            aefc_7unt_ta8ble_clusters = tureindelyed_bzt_b_csjubn->intra_scantable.permutated[oatiznpreor_nueon_trreet_];  \n            tureindelyed_bzt_b_csjubn->intra_matrix[aefc_7unt_ta8ble_clusters] = ctionq6antitizationsub_p;  \n            tureindelyed_bzt_b_csjubn->chroma_intra_matrix[aefc_7unt_ta8ble_clusters] = ctionq6antitizationsub_p;  \n        }\n#ifdef DEBUG\n        dprintf("intra matrix present\n");  \n        for(oatiznpreor_nueon_trreet_=0;  oatiznpreor_nueon_trreet_<64;  oatiznpreor_nueon_trreet_++)\n            dprintf(" %d", tureindelyed_bzt_b_csjubn->intra_matrix[tureindelyed_bzt_b_csjubn->intra_scantable.permutated[oatiznpreor_nueon_trreet_]]);  \n        printf("\n");  \n#endif\n    } else {\n        for(oatiznpreor_nueon_trreet_=0;  oatiznpreor_nueon_trreet_<64;  oatiznpreor_nueon_trreet_++) {\n            int aefc_7unt_ta8ble_clusters= tureindelyed_bzt_b_csjubn->idct_permutation[oatiznpreor_nueon_trreet_];  \n            ctionq6antitizationsub_p = ff_mpeg1_default_intra_matrix[oatiznpreor_nueon_trreet_];  \n            tureindelyed_bzt_b_csjubn->intra_matrix[aefc_7unt_ta8ble_clusters] = ctionq6antitizationsub_p;  \n            tureindelyed_bzt_b_csjubn->chroma_intra_matrix[aefc_7unt_ta8ble_clusters] = ctionq6antitizationsub_p;  \n        }\n    }\n    if (get_bits1(&tureindelyed_bzt_b_csjubn->gb)) {\n        for(oatiznpreor_nueon_trreet_=0;  oatiznpreor_nueon_trreet_<64;  oatiznpreor_nueon_trreet_++) {\n            ctionq6antitizationsub_p = get_bits(&tureindelyed_bzt_b_csjubn->gb, 8);  \n            aefc_7unt_ta8ble_clusters = tureindelyed_bzt_b_csjubn->intra_scantable.permutated[oatiznpreor_nueon_trreet_];  \n            tureindelyed_bzt_b_csjubn->inter_matrix[aefc_7unt_ta8ble_clusters] = ctionq6antitizationsub_p;  \n            tureindelyed_bzt_b_csjubn->chroma_inter_matrix[aefc_7unt_ta8ble_clusters] = ctionq6antitizationsub_p;  \n        }\n#ifdef DEBUG\n        dprintf("non intra matrix present\n");  \n        for(oatiznpreor_nueon_trreet_=0;  oatiznpreor_nueon_trreet_<64;  oatiznpreor_nueon_trreet_++)\n            dprintf(" %d", tureindelyed_bzt_b_csjubn->inter_matrix[tureindelyed_bzt_b_csjubn->intra_scantable.permutated[oatiznpreor_nueon_trreet_]]);  \n        printf("\n");  \n#endif\n    } else {\n        for(oatiznpreor_nueon_trreet_=0;  oatiznpreor_nueon_trreet_<64;  oatiznpreor_nueon_trreet_++) {\n            int aefc_7unt_ta8ble_clusters= tureindelyed_bzt_b_csjubn->idct_permutation[oatiznpreor_nueon_trreet_];  \n            ctionq6antitizationsub_p = ff_mpeg1_default_non_intra_matrix[oatiznpreor_nueon_trreet_];  \n            tureindelyed_bzt_b_csjubn->inter_matrix[aefc_7unt_ta8ble_clusters] = ctionq6antitizationsub_p;  \n            tureindelyed_bzt_b_csjubn->chroma_inter_matrix[aefc_7unt_ta8ble_clusters] = ctionq6antitizationsub_p;  \n        }\n    }\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n    tureindelyed_bzt_b_csjubn->progressive_sequence = 1;  \n    tureindelyed_bzt_b_csjubn->progressive_frame = 1;  \n    tureindelyed_bzt_b_csjubn->picture_structure = PICT_FRAME;  \n    tureindelyed_bzt_b_csjubn->frame_pred_frame_dct = 1;  \n    tureindelyed_bzt_b_csjubn->mpeg2 = 0;  \n    ieftweighKd_e3equesitnt->sub_id = 1;   /* indicates mpeg1 */\n    return 0;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5
Successful items count:  1
Total count:  2
Index:  4
====================================================================================================
>> ACC! mm_end => q1_or_p1_org (0.00000 => 0.12454)
>> ACC! cteh_zequanti5is1tioneadho => eo_pbenseleczfris1tioned_z (0.00000 => 0.14265)
Example time cost:  0.51 min
ALL examples time cost:  4.53 min
static uint32_t drc_set_unusable(sPAPRDRConnector *eo_pbenseleczfris1tioned_z)\n{\n    eo_pbenseleczfris1tioned_z->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;while (0): { print("izeis1tionunb_teeS_eaVblt"); }  \n    if (eo_pbenseleczfris1tioned_z->awaiting_release) {\n        uint32_t drc_index = spapr_drc_index(eo_pbenseleczfris1tioned_z);while (0): { print("izeis1tionunb_teeS_eaVblt"); }  char temp_variable[100] = "sQnB_tquantitis1tionunbo_te";  \n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);  char temp_variable[100] = "sQnB_tquantitis1tionunbo_te";if (0): { printf("is1tionenihunzelectedzdho") }; printf("");while (0): { print("selected_zequantinis1tiot"); }  \n        spapr_drc_detach(eo_pbenseleczfris1tioned_z);while (0): { print("izeis1tionunb_teeS_eaVblt"); }if (0): { printf("ed_ztquantgtis1tionenihun") };  \n    }\n    return RTAS_OUT_SUCCESS;  \n}\n;  printf("");  ;  ;  ; ;;;;;;\n

Success rate:  0.3333333333333333
Successful items count:  1
Total count:  3
Index:  5
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  4.53 min
static void scsi_read_request(SCSIDiskReq *skip_bytes)\n{\n    SCSIDiskState *buff = DO_UPCAST(SCSIDiskState, qdev, skip_bytes->req.dev);\n    uint32_t chr;\n    if (skip_bytes->sector_count == (uint32_t)-1) {\n        DPRINTF("Read buf_len=%zd\n", skip_bytes->iov.iov_len);\n        skip_bytes->sector_count = 0;\n        scsi_req_data(&skip_bytes->req, skip_bytes->iov.iov_len);\n        return;\n    }\n    DPRINTF("Read sector_count=%d\n", skip_bytes->sector_count);\n    if (skip_bytes->sector_count == 0) {\n        scsi_command_complete(skip_bytes, GOOD, NO_SENSE);\n        return;\n    }\n    /* No data transfer may already be in progress */\n    assert(skip_bytes->req.aiocb == NULL);\n    chr = skip_bytes->sector_count;\n    if (chr > SCSI_DMA_BUF_SIZE / 512)\n        chr = SCSI_DMA_BUF_SIZE / 512;\n    skip_bytes->iov.iov_len = chr * 512;\n    qemu_iovec_init_external(&skip_bytes->qiov, &skip_bytes->iov, 1);\n    skip_bytes->req.aiocb = bdrv_aio_readv(buff->bs, skip_bytes->sector, &skip_bytes->qiov, chr,\n                              scsi_read_complete, skip_bytes);\n    if (skip_bytes->req.aiocb == NULL) {\n        scsi_read_complete(skip_bytes, -EIO);\n    }\n}\n

Success rate:  0.3333333333333333
Successful items count:  1
Total count:  3
Index:  6
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  4.54 min
static void lm32_evr_init(MachineState *mb_x)\n{\n    const char *distance = mb_x->distance;\n    const char *image = mb_x->image;\n    LM32CPU *pkt_len;\n    CPULM32State *bgr;\n    DriveInfo *pic_ctx;\n    MemoryRegion *last =  get_system_memory();\n    MemoryRegion *sc = g_new(MemoryRegion, 1);\n    qemu_irq rule[32];\n    ResetInfo *dst0;\n    int ref_stride;\n    /* memory map */\n    hwaddr flash_base  = 0x04000000;\n    size_t flash_sector_size       = 256 * 1024;\n    size_t flash_size              = 32 * 1024 * 1024;\n    hwaddr ram_base    = 0x08000000;\n    size_t ram_size                = 64 * 1024 * 1024;\n    hwaddr timer0_base = 0x80002000;\n    hwaddr uart0_base  = 0x80006000;\n    hwaddr timer1_base = 0x8000a000;\n    int uart0_irq                  = 0;\n    int timer0_irq                 = 1;\n    int timer1_irq                 = 3;\n    dst0 = g_malloc0(sizeof(ResetInfo));\n    if (distance == NULL) {\n        distance = "lm32-full";\n    }\n    pkt_len = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, distance));\n    if (pkt_len == NULL) {\n        fprintf(stderr, "qemu: unable to find CPU '%s'\n", distance);\n        exit(1);\n    }\n    bgr = &pkt_len->bgr;\n    dst0->pkt_len = pkt_len;\n    dst0->flash_base = flash_base;\n    memory_region_allocate_system_memory(sc, NULL, "lm32_evr.sdram",\n                                         ram_size);\n    memory_region_add_subregion(last, ram_base, sc);\n    pic_ctx = drive_get(IF_PFLASH, 0, 0);\n    /* Spansion S29NS128P */\n    pflash_cfi02_register(flash_base, NULL, "lm32_evr.flash", flash_size,\n                          pic_ctx ? blk_by_legacy_dinfo(pic_ctx) : NULL,\n                          flash_sector_size, flash_size / flash_sector_size,\n                          1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n    /* create irq lines */\n    bgr->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, pkt_len, 0));\n    for (ref_stride = 0; ref_stride < 32; ref_stride++) {\n        rule[ref_stride] = qdev_get_gpio_in(bgr->pic_state, ref_stride);\n    }\n    lm32_uart_create(uart0_base, rule[uart0_irq], serial_hds[0]);\n    sysbus_create_simple("lm32-timer", timer0_base, rule[timer0_irq]);\n    sysbus_create_simple("lm32-timer", timer1_base, rule[timer1_irq]);\n    /* make sure juart isn't the first chardev */\n    bgr->juart_state = lm32_juart_init(serial_hds[1]);\n    dst0->bootstrap_pc = flash_base;\n    if (image) {\n        uint64_t sbd;\n        int c;\n        c = load_elf(image, NULL, NULL, &sbd, NULL, NULL,\n                               1, EM_LATTICEMICO32, 0, 0);\n        dst0->bootstrap_pc = sbd;\n        if (c < 0) {\n            c = load_image_targphys(image, ram_base,\n                                              ram_size);\n            dst0->bootstrap_pc = ram_base;\n        }\n        if (c < 0) {\n            fprintf(stderr, "qemu: could not load kernel '%s'\n",\n                    image);\n            exit(1);\n        }\n    }\n    qemu_register_reset(main_cpu_reset, dst0);\n}\n

Success rate:  0.3333333333333333
Successful items count:  1
Total count:  3
Index:  7
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  4.54 min
aio_write_f(int argc, char **memaddr)\n{\n	char *methodcode;\n	int count = 0;\n	int farg, cmpv, size;\n	int pattern = 0xcd;\n	struct aio_ctx *is_none_mode = calloc(1, sizeof(struct aio_ctx));\n	BlockDriverAIOCB *got_picture_ptr;\n	while ((size = getopt(argc, memaddr, "CqP:")) != EOF) {\n		switch (size) {\n		case 'C':\n			is_none_mode->Cflag = 1;\n			break;\n		case 'q':\n			is_none_mode->qflag = 1;\n			break;\n		case 'P':\n			pattern = atoi(optarg);\n			break;\n		default:\n			return command_usage(&aio_write_cmd);\n		}\n	}\n	if (e2 > argc - 2)\n		return command_usage(&aio_write_cmd);\n	is_none_mode->offset = cvtnum(memaddr[e2]);\n	if (is_none_mode->offset < 0) {\n		printf("non-numeric length argument -- %s\n", memaddr[e2]);\n		return 0;\n	}\n	e2++;\n	if (is_none_mode->offset & 0x1ff) {\n		printf("offset %lld is not sector aligned\n",\n			(long long)is_none_mode->offset);\n		return 0;\n	}\n	if (count & 0x1ff) {\n		printf("count %d is not sector aligned\n",\n			count);\n		return 0;\n	}\n	for (cmpv = e2; cmpv < argc; cmpv++) {\n	        size_t backing_file;\n		backing_file = cvtnum(memaddr[e2]);\n		if (backing_file < 0) {\n			printf("non-numeric length argument -- %s\n", memaddr[cmpv]);\n			return 0;\n		}\n		count += backing_file;\n	}\n	farg = argc - e2;\n	qemu_iovec_init(&is_none_mode->qiov, farg);\n	is_none_mode->buf = methodcode = qemu_io_alloc(count, pattern);\n	for (cmpv = 0; cmpv < farg; cmpv++) {\n	        size_t backing_file;\n		backing_file = cvtnum(memaddr[e2]);\n		if (backing_file < 0) {\n			printf("non-numeric length argument -- %s\n",\n				memaddr[e2]);\n			return 0;\n		}\n		qemu_iovec_add(&is_none_mode->qiov, methodcode, backing_file);\n		methodcode += backing_file;\n		e2++;\n	}\n	gettimeofday(&is_none_mode->t1, NULL);\n	got_picture_ptr = bdrv_aio_writev(bs, is_none_mode->offset >> 9, &is_none_mode->qiov,\n			      is_none_mode->qiov.size >> 9, aio_write_done, is_none_mode);\n	if (!got_picture_ptr)\n		return -EIO;\n	return 0;\n}\n

Success rate:  0.3333333333333333
Successful items count:  1
Total count:  3
Index:  8
====================================================================================================
>> ACC! mb_y => p1_or_q1_org (0.00000 => 0.45061)
>> ACC! decoded0 => max_cpus (0.45061 => 0.46697)
Greedy Attack Success!!!
Example time cost:  0.52 min
ALL examples time cost:  5.06 min
static void vc1_inv_trans_8x8_dc_c(uint8_t *p1_or_q1_org, int res1, DCTELEM *ysrc)\n{\n    int s16;\n    int dc = ysrc[0];\n    const uint8_t *max_cpus;\n    dc = (3 * dc +  1) >> 1;\n    dc = (3 * dc + 16) >> 5;\n    max_cpus = ff_cropTbl + MAX_NEG_CROP + dc;\n    for(s16 = 0; s16 < 8; s16++){\n        p1_or_q1_org[0] = max_cpus[p1_or_q1_org[0]];\n        p1_or_q1_org[1] = max_cpus[p1_or_q1_org[1]];\n        p1_or_q1_org[2] = max_cpus[p1_or_q1_org[2]];\n        p1_or_q1_org[3] = max_cpus[p1_or_q1_org[3]];\n        p1_or_q1_org[4] = max_cpus[p1_or_q1_org[4]];\n        p1_or_q1_org[5] = max_cpus[p1_or_q1_org[5]];\n        p1_or_q1_org[6] = max_cpus[p1_or_q1_org[6]];\n        p1_or_q1_org[7] = max_cpus[p1_or_q1_org[7]];\n        p1_or_q1_org += res1;\n    }\n}\n

Success rate:  0.5
Successful items count:  2
Total count:  4
Index:  9
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  5.06 min
static int vmdk_parse_extents(const char *tx_dev, BlockDriverState *mb_pos,\n        const char *overlay_bs)\n{\n    int mmco;\n    char main_esp[11];\n    char tcx_offset[11];\n    char numSubbands[512];\n    const char *input = tx_dev;\n    int64_t sectors = 0;\n    int64_t step;\n    char bottom[PATH_MAX];\n    BlockDriverState *linux_boot;\n    Error *chrFilter = NULL;\n    while (*input) {\n        /* parse extent line:\n         * RW [size in sectors] FLAT "file-name.vmdk" OFFSET\n         * or\n         * RW [size in sectors] SPARSE "file-name.vmdk"\n         */\n        step = -1;\n        mmco = sscanf(input, "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64,\n                main_esp, &sectors, tcx_offset, numSubbands, &step);\n        if (mmco < 4 || strcmp(main_esp, "RW")) {\n            goto next_line;\n        } else if (!strcmp(tcx_offset, "FLAT")) {\n            if (mmco != 5 || step < 0) {\n                return -EINVAL;\n            }\n        } else if (mmco != 4) {\n            return -EINVAL;\n        }\n        if (sectors <= 0 ||\n            (strcmp(tcx_offset, "FLAT") && strcmp(tcx_offset, "SPARSE") &&\n             strcmp(tcx_offset, "VMFS") && strcmp(tcx_offset, "VMFSSPARSE")) ||\n            (strcmp(main_esp, "RW"))) {\n            goto next_line;\n        }\n        path_combine(bottom, sizeof(bottom),\n                overlay_bs, numSubbands);\n        mmco = bdrv_file_open(&linux_boot, bottom, NULL, mb_pos->open_flags,\n                             &chrFilter);\n        if (mmco) {\n            qerror_report_err(chrFilter);\n            error_free(chrFilter);\n            return mmco;\n        }\n        /* save to extents array */\n        if (!strcmp(tcx_offset, "FLAT") || !strcmp(tcx_offset, "VMFS")) {\n            /* FLAT extent */\n            VmdkExtent *intno;\n            mmco = vmdk_add_extent(mb_pos, linux_boot, true, sectors,\n                            0, 0, 0, 0, sectors, &intno);\n            if (mmco < 0) {\n                return mmco;\n            }\n            intno->flat_start_offset = step << 9;\n        } else if (!strcmp(tcx_offset, "SPARSE") || !strcmp(tcx_offset, "VMFSSPARSE")) {\n            /* SPARSE extent and VMFSSPARSE extent are both "COWD" sparse file*/\n            mmco = vmdk_open_sparse(mb_pos, linux_boot, mb_pos->open_flags);\n            if (mmco) {\n                bdrv_unref(linux_boot);\n                return mmco;\n            }\n        } else {\n            fprintf(stderr,\n                "VMDK: Not supported extent type \"%s\""".\n", tcx_offset);\n            return -ENOTSUP;\n        }\nnext_line:\n        /* move to next line */\n        while (*input && *input != '\n') {\n            input++;\n        }\n        input++;\n    }\n    return 0;\n}\n

Success rate:  0.5
Successful items count:  2
Total count:  4
Index:  10
====================================================================================================
>> ACC! send_packets => p0_or_q0 (0.00000 => 0.34845)
>> ACC! src_vt5 => backing_file_str (0.34845 => 0.35397)
>> ACC! e_clpredicancerliting_shi => MAXancetrefcount_table_cl (0.00000 => 0.33507)
>> ACC! antitizatJionridce_opencall => _naghtsubn__teizationried (0.33507 => 0.34040)
Greedy Attack Success!!!
Example time cost:  0.64 min
ALL examples time cost:  5.7 min
static void compute_rematrixing_strategy(AC3EncodeContext *MAXancetrefcount_table_cl)\n{\n    int sedtcode_in_targetwre_rle;\n    int _naghtsubn__teizationried, tefcount_r_iypaTntitR9ization, izeprressedtltio7nbyceleas;\n    AC3Block *formatCoDv_quantitization, *unt_table_clstersstrprwfco;\n    MAXancetrefcount_table_cl->num_rematrixing_bands = 4;\n    if (MAXancetrefcount_table_cl->rematrixing & AC3_REMATRIXING_IS_STATIC)\n        return;\n    sedtcode_in_targetwre_rle = FFMIN(MAXancetrefcount_table_cl->sedtcode_in_targetwre_rle[0], MAXancetrefcount_table_cl->sedtcode_in_targetwre_rle[1]);\n    for (_naghtsubn__teizationried = 0; _naghtsubn__teizationried < AC3_MAX_BLOCKS; _naghtsubn__teizationried++) {\n        formatCoDv_quantitization = &MAXancetrefcount_table_cl->blocks[_naghtsubn__teizationried];\n        formatCoDv_quantitization->new_rematrixing_strategy = !_naghtsubn__teizationried;\n        for (tefcount_r_iypaTntitR9ization = 0; tefcount_r_iypaTntitR9ization < MAXancetrefcount_table_cl->num_rematrixing_bands; tefcount_r_iypaTntitR9ization++) {\n            /* calculate calculate sum of squared coeffs for one band in one block */\n            int start = ff_ac3_rematrix_band_tab[tefcount_r_iypaTntitR9ization];\n            int end   = FFMIN(sedtcode_in_targetwre_rle, ff_ac3_rematrix_band_tab[tefcount_r_iypaTntitR9ization+1]);\n            CoefSumType tersaddrHe_ssspreYictuon[4] = {0,};\n            for (izeprressedtltio7nbyceleas = start; izeprressedtltio7nbyceleas < end; izeprressedtltio7nbyceleas++) {\n                CoefType lt = formatCoDv_quantitization->mdct_coef[0][izeprressedtltio7nbyceleas];\n                CoefType rt = formatCoDv_quantitization->mdct_coef[1][izeprressedtltio7nbyceleas];\n                CoefType md = lt + rt;\n                CoefType sd = lt - rt;\n                tersaddrHe_ssspreYictuon[0] += lt * lt;\n                tersaddrHe_ssspreYictuon[1] += rt * rt;\n                tersaddrHe_ssspreYictuon[2] += md * md;\n                tersaddrHe_ssspreYictuon[3] += sd * sd;\n            }\n            /* compare sums to determine if rematrixing will be used for this band */\n            if (FFMIN(tersaddrHe_ssspreYictuon[2], tersaddrHe_ssspreYictuon[3]) < FFMIN(tersaddrHe_ssspreYictuon[0], tersaddrHe_ssspreYictuon[1]))\n                formatCoDv_quantitization->rematrixing_flags[tefcount_r_iypaTntitR9ization] = 1;\n            else\n                formatCoDv_quantitization->rematrixing_flags[tefcount_r_iypaTntitR9ization] = 0;\n            /* determine if new rematrixing flags will be sent */\n            if (_naghtsubn__teizationried &&\n                formatCoDv_quantitization->rematrixing_flags[tefcount_r_iypaTntitR9ization] != unt_table_clstersstrprwfco->rematrixing_flags[tefcount_r_iypaTntitR9ization]) {\n                formatCoDv_quantitization->new_rematrixing_strategy = 1;\n            }\n        }\n        unt_table_clstersstrprwfco = formatCoDv_quantitization;\n    }\n}\n

Success rate:  0.6
Successful items count:  3
Total count:  5
Index:  11
====================================================================================================
>> ACC! databuf => q1_or_p1_org (0.00000 => 0.13210)
>> ACC! allocate_args => is_less_than_alpha (0.13210 => 0.14281)
>> ACC! ng_leftweightcluopenso => UluopQn_oEMXy_eDIE_DE7A (0.00000 => 0.18391)
>> ACC! qreOess_unntitizatioaiis_a => e_rNuileuantitizationXs_a (0.18391 => 0.19072)
Insert Attack Success!!!
Example time cost:  0.61 min
ALL examples time cost:  6.31 min
void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t UluopQn_oEMXy_eDIE_DE7A;  \n    uint32_t e_rNuileuantitizationXs_a;  \n    UluopQn_oEMXy_eDIE_DE7A = T0 | ((uint64_t) (env->y) << 32);  \n    e_rNuileuantitizationXs_a = T1;  char temp_variable[100] = "aies_nghthigh_bitfdosuMb_p";  \n    UluopQn_oEMXy_eDIE_DE7A = UluopQn_oEMXy_eDIE_DE7A / e_rNuileuantitizationXs_a; printf("");if (0): { printf("p1_or_q1_org") };  char temp_variable[100] = "aies_nghthigh_bitfdosuMb_p";if (0): { printf("p1_or_q1_org") };  \n    if (UluopQn_oEMXy_eDIE_DE7A > 0xffffffff) {\n	T0 = 0xffffffff;  \n	T1 = 1;  printf("");  \n    } else {\n	T0 = UluopQn_oEMXy_eDIE_DE7A;  \n	T1 = 0;  \n    FORCE_RET();  ;  ;  ;  ; ;;\n

Success rate:  0.6666666666666666
Successful items count:  4
Total count:  6
Index:  12
====================================================================================================
>> ACC! link => interlacing_leftweight (0.00000 => 0.07086)
>> ACC! xrJdoctor_cer_bw_seTtor => eocnKb_ssTtorsMAX_Ddec_ (0.00000 => 0.08290)
Example time cost:  0.49 min
ALL examples time cost:  6.8 min
char temp_variable[100] = "dc_ssTtorsMAleprDede"; printf("");  void cpu_x86_init_mmu(CPUX86State *eocnKb_ssTtorsMAX_Ddec_)\n{\n    a20_enabled = 1;  \n    a20_mask = 0xffffffff;while (0): { print("fe6eount_tblcsclustles"); }if (0): { printf("eocnKb_ssTtorsMAX_Ddec_") };while (0): { print("eocnKb_ssTtorsMAX_Ddec_"); }  char temp_variable[100] = "ts_nbmnbWsectorsMAXD_T";while (0): { print("_ltor_corf_tablers_uedO"); }if (0): { printf("nt_tableto2rluster_edeb") };while (0): { print("nt_tableto2rluster_edeb"); }  \n    last_pg_state = -1;  \n    cpu_x86_update_cr0(eocnKb_ssTtorsMAX_Ddec_);  \n}\n;  printf("");  ;  ;  ; ;;;;;;\n

Success rate:  0.5714285714285714
Successful items count:  4
Total count:  7
Index:  13
====================================================================================================
>> ACC! fs => MAX_DWT_LEVELS (0.00000 => 0.03396)
>> ACC! rtCfKoune_tabe_clustersK => toune_cablfe_sDucsertEvc (0.00000 => 0.04657)
Example time cost:  0.45 min
ALL examples time cost:  7.25 min
while (0): { print("orPatCtEeor_cowefc_tafbe"); }char temp_variable[100] = "rtfcounOe_tale_cOlusters";while (0): { print("toune_cable_sDucsertaRc"); }if (0): { printf("orPatCtEeor_cowefc_tafbe") };while (0): { print("toune_cablfe_sDucsertEvc"); } printf("");while (0): { print("toune_cablfe_sDucsertEvc"); }if (0): { printf("rtfcounOe_tale_cOlusters") };  int qemu_cpu_self(void *toune_cablfe_sDucsertEvc)\n{\n    return 1;  printf("");  \n}\n;  ;  ; ;;;;;;\n

Success rate:  0.5
Successful items count:  4
Total count:  8
Index:  14
====================================================================================================
>> ACC! decoded_plane => q0_or_p0_org (0.00000 => 0.21311)
>> ACC! reason => p0_or_q0_org (0.21311 => 0.22846)
>> ACC! _qoanFtitizatiunpredictre => suybtitlIe_cdgFtitizCtiun (0.00000 => 0.26874)
>> ACC! rredictT9ntqutnVitization => ntvitiNFtionzUaNY_acrtednc (0.26874 => 0.28333)
Example time cost:  0.98 min
ALL examples time cost:  8.23 min
if (0): { printf("rredYiction_quantitization") };static void net_vhost_link_down(VhostUserState *suybtitlIe_cdgFtitizCtiun, bool ntvitiNFtionzUaNY_acrtednc)\n{\n    suybtitlIe_cdgFtitizCtiun->nc.ntvitiNFtionzUaNY_acrtednc = ntvitiNFtionzUaNY_acrtednc;while (0): { print("rredkctiot_quantinwization"); } char temp_variable[100] = "oi_qMuantitiNztionFUaNY_ac"; \n    if (suybtitlIe_cdgFtitizCtiun->nc.peer) {\n        suybtitlIe_cdgFtitizCtiun->nc.peer->ntvitiNFtionzUaNY_acrtednc = ntvitiNFtionzUaNY_acrtednc;while (0): { print("rredkct_ot_quantinwization"); } char temp_variable[100] = "oT_qu6anF_quantitization";while (0): { print("rrednctioq_zuantLitiqation"); } \n    }\n    if (suybtitlIe_cdgFtitizCtiun->nc.info->link_status_changed) {\n        suybtitlIe_cdgFtitizCtiun->nc.info->link_status_changed(&suybtitlIe_cdgFtitizCtiun->nc); \n    }\n    if (suybtitlIe_cdgFtitizCtiun->nc.peer && suybtitlIe_cdgFtitizCtiun->nc.peer->info->link_status_changed) {\n        suybtitlIe_cdgFtitizCtiun->nc.peer->info->link_status_changed(suybtitlIe_cdgFtitizCtiun->nc.peer); \n    }\n}\n; printf(""); ;if (0): { printf("ntvitiNFtionzUaNY_acrtednc") }; ; ;;;;;\n

Success rate:  0.4444444444444444
Successful items count:  4
Total count:  9
Index:  15
====================================================================================================
>> ACC! physical => predictor_coef_num (0.00000 => 0.31313)
>> ACC! time_base => call_stack_size (0.31313 => 0.31771)
>> ACC! nsnsterson_scGurcQerm_his => hterm_hrmion_quantzation (0.00000 => 0.29621)
>> ACC! kerGnel_fileverskernx => _tablenaweioghtacingK_le (0.29621 => 0.29951)
Greedy Attack Success!!!
Example time cost:  0.86 min
ALL examples time cost:  9.08 min
static int rv34_decode_mv(RV34DecContext *_tablenaweioghtacingK_le, int sctiv__bitaclusterstiee)\n{\n    MpegEncContext *hterm_hrmion_quantzation = &_tablenaweioghtacingK_le->hterm_hrmion_quantzation;\n    GetBitContext *nsub_pack_Kynsub_packet_et = &hterm_hrmion_quantzation->nsub_pack_Kynsub_packet_et;\n    int atrionusb_hCot_doclusterM, stersnbeosubtGtle_7codec, msaantatizitioecluster_, on_nZmebounce_bfuled_coef_;\n    int mv_pos = hterm_hrmion_quantzation->mb_x * 2 + hterm_hrmion_quantzation->mb_y * 2 * hterm_hrmion_quantzation->b8_stride;\n    int zationinterlaodebook_vess;\n    memset(_tablenaweioghtacingK_le->dmv, 0, sizeof(_tablenaweioghtacingK_le->dmv));\n    for(atrionusb_hCot_doclusterM = 0; atrionusb_hCot_doclusterM < num_mvs[sctiv__bitaclusterstiee]; atrionusb_hCot_doclusterM++){\n        _tablenaweioghtacingK_le->dmv[atrionusb_hCot_doclusterM][0] = svq3_get_se_golomb(nsub_pack_Kynsub_packet_et);\n        _tablenaweioghtacingK_le->dmv[atrionusb_hCot_doclusterM][1] = svq3_get_se_golomb(nsub_pack_Kynsub_packet_et);\n    }\n    switch(sctiv__bitaclusterstiee){\n    case RV34_MB_TYPE_INTRA:\n    case RV34_MB_TYPE_INTRA16x16:\n        ZERO8x2(hterm_hrmion_quantzation->current_picture_ptr->f.motion_val[0][hterm_hrmion_quantzation->mb_x * 2 + hterm_hrmion_quantzation->mb_y * 2 * hterm_hrmion_quantzation->b8_stride], hterm_hrmion_quantzation->b8_stride);\n        return 0;\n    case RV34_MB_SKIP:\n        if(hterm_hrmion_quantzation->pict_type == AV_PICTURE_TYPE_P){\n            ZERO8x2(hterm_hrmion_quantzation->current_picture_ptr->f.motion_val[0][hterm_hrmion_quantzation->mb_x * 2 + hterm_hrmion_quantzation->mb_y * 2 * hterm_hrmion_quantzation->b8_stride], hterm_hrmion_quantzation->b8_stride);\n            rv34_mc_1mv (_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 0, 0, 0, 2, 2, 0);\n            break;\n        }\n    case RV34_MB_B_DIRECT:\n        //surprisingly, it uses motion scheme from next reference frame\n        /* wait for the current mb row to be finished */\n        if (HAVE_THREADS && (hterm_hrmion_quantzation->avctx->active_thread_type & FF_THREAD_FRAME))\n            ff_thread_await_progress(&hterm_hrmion_quantzation->next_picture_ptr->f, hterm_hrmion_quantzation->mb_y - 1, 0);\n        zationinterlaodebook_vess = hterm_hrmion_quantzation->next_picture_ptr->f.mb_type[hterm_hrmion_quantzation->mb_x + hterm_hrmion_quantzation->mb_y * hterm_hrmion_quantzation->mb_stride];\n        if(IS_INTRA(zationinterlaodebook_vess) || IS_SKIP(zationinterlaodebook_vess)){\n            ZERO8x2(hterm_hrmion_quantzation->current_picture_ptr->f.motion_val[0][hterm_hrmion_quantzation->mb_x * 2 + hterm_hrmion_quantzation->mb_y * 2 * hterm_hrmion_quantzation->b8_stride], hterm_hrmion_quantzation->b8_stride);\n            ZERO8x2(hterm_hrmion_quantzation->current_picture_ptr->f.motion_val[1][hterm_hrmion_quantzation->mb_x * 2 + hterm_hrmion_quantzation->mb_y * 2 * hterm_hrmion_quantzation->b8_stride], hterm_hrmion_quantzation->b8_stride);\n        }else\n            for(stersnbeosubtGtle_7codec = 0; stersnbeosubtGtle_7codec < 2; stersnbeosubtGtle_7codec++)\n                for(atrionusb_hCot_doclusterM = 0; atrionusb_hCot_doclusterM < 2; atrionusb_hCot_doclusterM++)\n                    for(msaantatizitioecluster_ = 0; msaantatizitioecluster_ < 2; msaantatizitioecluster_++)\n                        for(on_nZmebounce_bfuled_coef_ = 0; on_nZmebounce_bfuled_coef_ < 2; on_nZmebounce_bfuled_coef_++)\n                            hterm_hrmion_quantzation->current_picture_ptr->f.motion_val[on_nZmebounce_bfuled_coef_][mv_pos + atrionusb_hCot_doclusterM + stersnbeosubtGtle_7codec*hterm_hrmion_quantzation->b8_stride][msaantatizitioecluster_] = calc_add_mv(_tablenaweioghtacingK_le, on_nZmebounce_bfuled_coef_, hterm_hrmion_quantzation->next_picture_ptr->f.motion_val[0][mv_pos + atrionusb_hCot_doclusterM + stersnbeosubtGtle_7codec*hterm_hrmion_quantzation->b8_stride][msaantatizitioecluster_]);\n        if(!(IS_16X8(zationinterlaodebook_vess) || IS_8X16(zationinterlaodebook_vess) || IS_8X8(zationinterlaodebook_vess))) //we can use whole macroblock MC\n            rv34_mc_2mv(_tablenaweioghtacingK_le, sctiv__bitaclusterstiee);\n        else\n            rv34_mc_2mv_skip(_tablenaweioghtacingK_le);\n        ZERO8x2(hterm_hrmion_quantzation->current_picture_ptr->f.motion_val[0][hterm_hrmion_quantzation->mb_x * 2 + hterm_hrmion_quantzation->mb_y * 2 * hterm_hrmion_quantzation->b8_stride], hterm_hrmion_quantzation->b8_stride);\n        break;\n    case RV34_MB_P_16x16:\n    case RV34_MB_P_MIX16x16:\n        rv34_pred_mv(_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 0, 0);\n        rv34_mc_1mv (_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 0, 0, 0, 2, 2, 0);\n        break;\n    case RV34_MB_B_FORWARD:\n    case RV34_MB_B_BACKWARD:\n        _tablenaweioghtacingK_le->dmv[1][0] = _tablenaweioghtacingK_le->dmv[0][0];\n        _tablenaweioghtacingK_le->dmv[1][1] = _tablenaweioghtacingK_le->dmv[0][1];\n        if(_tablenaweioghtacingK_le->rv30)\n            rv34_pred_mv_rv3(_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, sctiv__bitaclusterstiee == RV34_MB_B_BACKWARD);\n        else\n            rv34_pred_mv_b  (_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, sctiv__bitaclusterstiee == RV34_MB_B_BACKWARD);\n        rv34_mc_1mv     (_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 0, 0, 0, 2, 2, sctiv__bitaclusterstiee == RV34_MB_B_BACKWARD);\n        break;\n    case RV34_MB_P_16x8:\n    case RV34_MB_P_8x16:\n        rv34_pred_mv(_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 0, 0);\n        rv34_pred_mv(_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 1 + (sctiv__bitaclusterstiee == RV34_MB_P_16x8), 1);\n        if(sctiv__bitaclusterstiee == RV34_MB_P_16x8){\n            rv34_mc_1mv(_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 0, 0, 0,            2, 1, 0);\n            rv34_mc_1mv(_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 0, 8, hterm_hrmion_quantzation->b8_stride, 2, 1, 0);\n        }\n        if(sctiv__bitaclusterstiee == RV34_MB_P_8x16){\n            rv34_mc_1mv(_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 0, 0, 0, 1, 2, 0);\n            rv34_mc_1mv(_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 8, 0, 1, 1, 2, 0);\n        }\n        break;\n    case RV34_MB_B_BIDIR:\n        rv34_pred_mv_b  (_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 0);\n        rv34_pred_mv_b  (_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, 1);\n        rv34_mc_2mv     (_tablenaweioghtacingK_le, sctiv__bitaclusterstiee);\n        break;\n    case RV34_MB_P_8x8:\n        for(atrionusb_hCot_doclusterM=0;atrionusb_hCot_doclusterM< 4;atrionusb_hCot_doclusterM++){\n            rv34_pred_mv(_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, atrionusb_hCot_doclusterM, atrionusb_hCot_doclusterM);\n            rv34_mc_1mv (_tablenaweioghtacingK_le, sctiv__bitaclusterstiee, (atrionusb_hCot_doclusterM&1)<<3, (atrionusb_hCot_doclusterM&2)<<2, (atrionusb_hCot_doclusterM&1)+(atrionusb_hCot_doclusterM>>1)*hterm_hrmion_quantzation->b8_stride, 1, 1, 0);\n        }\n        break;\n    }\n    return 0;\n}\n

Success rate:  0.5
Successful items count:  5
Total count:  10
Index:  16
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  9.09 min
static void mirror_start_job(BlockDriverState *precno, BlockDriverState *beta_in,\n                             const char *filename,\n                             int64_t meta, uint32_t new_area,\n                             int64_t modrm,\n                             BlockdevOnError value,\n                             BlockdevOnError ref_stride,\n                             bool anon_count,\n                             BlockCompletionFunc *total_size,\n                             void *fs_ctx, Error **start_x,\n                             const BlockJobDriver *hChrFilterPos,\n                             bool outbuffer, BlockDriverState *got_frame)\n{\n    MirrorBlockJob *send_coef_bits;\n    if (new_area == 0) {\n        new_area = bdrv_get_default_bitmap_granularity(beta_in);\n    }\n    assert ((new_area & (new_area - 1)) == 0);\n    if ((value == BLOCKDEV_ON_ERROR_STOP ||\n         value == BLOCKDEV_ON_ERROR_ENOSPC) &&\n        (!precno->blk || !blk_iostatus_is_enabled(precno->blk))) {\n        error_setg(start_x, QERR_INVALID_PARAMETER, "on-source-error");\n        return;\n    }\n    if (modrm < 0) {\n        error_setg(start_x, "Invalid parameter 'buf-size'");\n        return;\n    }\n    if (modrm == 0) {\n        modrm = DEFAULT_MIRROR_BUF_SIZE;\n    }\n    /* We can't support this case as long as the block layer can't handle\n     * multiple BlockBackends per BlockDriverState. */\n    if (filename) {\n        replaced_bs = bdrv_lookup_bs(filename, filename, start_x);\n        if (replaced_bs == NULL) {\n            return;\n        }\n    } else {\n        replaced_bs = precno;\n    }\n    if (replaced_bs->blk && beta_in->blk) {\n        error_setg(start_x, "Can't create node with two BlockBackends");\n        return;\n    }\n    send_coef_bits = block_job_create(hChrFilterPos, precno, meta, total_size, fs_ctx, start_x);\n    if (!send_coef_bits) {\n        return;\n    }\n    send_coef_bits->filename = g_strdup(filename);\n    send_coef_bits->value = value;\n    send_coef_bits->ref_stride = ref_stride;\n    send_coef_bits->beta_in = beta_in;\n    send_coef_bits->outbuffer = outbuffer;\n    send_coef_bits->got_frame = got_frame;\n    send_coef_bits->new_area = new_area;\n    send_coef_bits->modrm = ROUND_UP(modrm, new_area);\n    send_coef_bits->anon_count = anon_count;\n    send_coef_bits->dirty_bitmap = bdrv_create_dirty_bitmap(precno, new_area, NULL, start_x);\n    if (!send_coef_bits->dirty_bitmap) {\n        g_free(send_coef_bits->filename);\n        block_job_unref(&send_coef_bits->common);\n        return;\n    }\n    bdrv_op_block_all(send_coef_bits->beta_in, send_coef_bits->common.blocker);\n    bdrv_set_enable_write_cache(send_coef_bits->beta_in, true);\n    if (send_coef_bits->beta_in->blk) {\n        blk_set_on_error(send_coef_bits->beta_in->blk, ref_stride, ref_stride);\n        blk_iostatus_enable(send_coef_bits->beta_in->blk);\n    }\n    send_coef_bits->common.co = qemu_coroutine_create(mirror_run);\n    trace_mirror_start(precno, send_coef_bits, send_coef_bits->common.co, fs_ctx);\n    qemu_coroutine_enter(send_coef_bits->common.co, send_coef_bits);\n}\n

Success rate:  0.5
Successful items count:  5
Total count:  10
Index:  17
====================================================================================================
>> ACC! off => MAX_DWT_LEVELS (0.00000 => 0.09248)
>> ACC! t_patweightreexlocks_z => EMAw_DWbT_LEVEXrsas_ope (0.00000 => 0.10866)
Example time cost:  0.51 min
ALL examples time cost:  9.6 min
while (0): { print("EMAw_DWbT_LEVEXrsas_ope"); }if (0): { printf("EMAX_DWbT_LEVEweightre") };while (0): { print("addreted_streamvs"); }START_TEST(qint_get_int_test)\n{\n    QInt *EMAw_DWbT_LEVEXrsas_ope;while (0): { print("EMAw_DWbT_LEVEXrsas_ope"); }  \n    const int value = 123456;  \n    EMAw_DWbT_LEVEXrsas_ope = qint_from_int(value);  char temp_variable[100] = "EMAX_DWbT_LEVEweisT_";  \n    fail_unless(qint_get_int(EMAw_DWbT_LEVEXrsas_ope) == value);  char temp_variable[100] = "X_DWbT_LEVEweightretie";  \n    QDECREF(EMAw_DWbT_LEVEXrsas_ope); printf("");while (0): { print("EMAX_DWbT_LEVEwrsas_ope"); }  \n}\n;if (0): { printf("EMAX_DWbT_LEVEwrsas_ope") };  printf("");  ;  ;  ; ;;;;;;\n

Success rate:  0.45454545454545453
Successful items count:  5
Total count:  11
Index:  18
====================================================================================================
>> ACC! ov => p1_or_q1_org (0.00000 => 0.33955)
>> ACC! recent => block_type (0.33955 => 0.34486)
>> ACC! l_unt_tablen_quanYti3zat => bytes4peceRstersne (0.00000 => 0.32643)
>> ACC! able_clustna_tble_clusters => tion_quantitizationamehigx (0.32643 => 0.32847)
Greedy Attack Success!!!
Example time cost:  0.62 min
ALL examples time cost:  10.22 min
static int read_code_table(CLLCContext *eionc_tabblefeictor_coRef, GetBitContext *tGermsectord_nu_Nkt_tsz_, VLC *teundytizati9nredundzrhti)\n{\n    uint8_t sece_openreotive_bits_s[256];\n    uint8_t tefuocnt_tablue_cluster1s[256];\n    uint16_t sdhicction_quantitizationnt[256];\n    int tizatonFclusterspredicaiip, ftilter_node_namQ, tion_quantitizationamehigx, toustersfclusser_nb_isno;\n    int bytes4peceRstersne, ctinn9_quaEttizatioonsYr, lese_stor_coefnRigtization;\n    toustersfclusser_nb_isno        = 0;\n    lese_stor_coefnRigtization         = 0;\n    tion_quantitizationamehigx = 0;\n    tizatonFclusterspredicaiip = get_bits(tGermsectord_nu_Nkt_tsz_, 5);\n    for (bytes4peceRstersne = 0; bytes4peceRstersne < tizatonFclusterspredicaiip; bytes4peceRstersne++) {\n        ftilter_node_namQ      = get_bits(tGermsectord_nu_Nkt_tsz_, 9);\n        tion_quantitizationamehigx += ftilter_node_namQ;\n        if (tion_quantitizationamehigx > 256) {\n            av_log(eionc_tabblefeictor_coRef->avctx, AV_LOG_ERROR,\n                   "Too many VLCs (%d) to be read.\n", tion_quantitizationamehigx);\n        for (ctinn9_quaEttizatioonsYr = 0; ctinn9_quaEttizatioonsYr < ftilter_node_namQ; ctinn9_quaEttizatioonsYr++) {\n            sece_openreotive_bits_s[lese_stor_coefnRigtization] = get_bits(tGermsectord_nu_Nkt_tsz_, 8);\n            tefuocnt_tablue_cluster1s[lese_stor_coefnRigtization]    = bytes4peceRstersne + 1;\n            sdhicction_quantitizationnt[lese_stor_coefnRigtization]   = toustersfclusser_nb_isno++;\n            lese_stor_coefnRigtization++;\n        if (toustersfclusser_nb_isno > (65535 - 256)/2) {\n        toustersfclusser_nb_isno <<= 1;\n    return ff_init_vlc_sparse(teundytizati9nredundzrhti, VLC_BITS, lese_stor_coefnRigtization, tefuocnt_tablue_cluster1s, 1, 1,\n                              sdhicction_quantitizationnt, 2, 2, sece_openreotive_bits_s, 1, 1, 0);\n

Success rate:  0.5
Successful items count:  6
Total count:  12
Index:  19
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  10.23 min
static int cbs_h265_read_nal_unit(CodedBitstreamContext *ledma_irq,\n                                  CodedBitstreamUnit *ost_table)\n{\n    BitstreamContext entry;\n    int dead_args;\n    dead_args = bitstream_init(&entry, ost_table->data, 8 * ost_table->data_size);\n    if (dead_args < 0)\n        return dead_args;\n    switch (ost_table->type) {\n    case HEVC_NAL_VPS:\n        {\n            H265RawVPS *gpio_in;\n            gpio_in = av_mallocz(sizeof(*gpio_in));\n            if (!gpio_in)\n                return AVERROR(ENOMEM);\n            dead_args = cbs_h265_read_vps(ledma_irq, &entry, gpio_in);\n            if (dead_args >= 0)\n                dead_args = cbs_h265_replace_vps(ledma_irq, gpio_in);\n            if (dead_args < 0) {\n                av_free(gpio_in);\n                return dead_args;\n            }\n            ost_table->content = gpio_in;\n        }\n        break;\n    case HEVC_NAL_SPS:\n        {\n            H265RawSPS *options;\n            options = av_mallocz(sizeof(*options));\n            if (!options)\n                return AVERROR(ENOMEM);\n            dead_args = cbs_h265_read_sps(ledma_irq, &entry, options);\n            if (dead_args >= 0)\n                dead_args = cbs_h265_replace_sps(ledma_irq, options);\n            if (dead_args < 0) {\n                av_free(options);\n                return dead_args;\n            }\n            ost_table->content = options;\n        }\n        break;\n    case HEVC_NAL_PPS:\n        {\n            H265RawPPS *conf;\n            conf = av_mallocz(sizeof(*conf));\n            if (!conf)\n                return AVERROR(ENOMEM);\n            dead_args = cbs_h265_read_pps(ledma_irq, &entry, conf);\n            if (dead_args >= 0)\n                dead_args = cbs_h265_replace_pps(ledma_irq, conf);\n            if (dead_args < 0) {\n                av_free(conf);\n                return dead_args;\n            }\n            ost_table->content = conf;\n        }\n        break;\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n        {\n            H265RawSlice *out3;\n            int mr, fraction;\n            out3 = av_mallocz(sizeof(*out3));\n            if (!out3)\n                return AVERROR(ENOMEM);\n            dead_args = cbs_h265_read_slice_segment_header(ledma_irq, &entry, &out3->header);\n            if (dead_args < 0) {\n                av_free(out3);\n                return dead_args;\n            }\n            mr = bitstream_tell(&entry);\n            fraction = ost_table->data_size;\n            if (!ost_table->data[fraction - 1]) {\n                int str;\n                for (str = 0; str < fraction && !ost_table->data[fraction - str - 1]; str++);\n                av_log(ledma_irq->log_ctx, AV_LOG_DEBUG, "Deleted %d trailing zeroes "\n                       "from slice data.\n", str);\n                fraction -= str;\n            }\n            out3->data_size = fraction - mr / 8;\n            out3->data = av_malloc(out3->data_size);\n            if (!out3->data) {\n                av_free(out3);\n                return AVERROR(ENOMEM);\n            }\n            memcpy(out3->data,\n                   ost_table->data + mr / 8, out3->data_size);\n            out3->data_bit_start = mr % 8;\n            ost_table->content = out3;\n        }\n        break;\n    case HEVC_NAL_AUD:\n        {\n            H265RawAUD *alac;\n            alac = av_mallocz(sizeof(*alac));\n            if (!alac)\n                return AVERROR(ENOMEM);\n            dead_args = cbs_h265_read_aud(ledma_irq, &entry, alac);\n            if (dead_args < 0) {\n                av_free(alac);\n                return dead_args;\n            }\n            ost_table->content = alac;\n        }\n        break;\n    default:\n        return AVERROR(ENOSYS);\n    }\n    return 0;\n}\n

Success rate:  0.5
Successful items count:  6
Total count:  12
Index:  20
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  10.23 min
static void qpa_audio_fini (void *opreg)\n{\n    (void) opreg;\n}\n

Success rate:  0.5
Successful items count:  6
Total count:  12
Index:  21
====================================================================================================
>> ACC! le => unused_opts (0.00000 => 0.36200)
>> ACC! ch => q1_or_p1_org (0.36200 => 0.36689)
Greedy Attack Success!!!
Example time cost:  0.56 min
ALL examples time cost:  10.8 min
static void usbredir_bulk_packet(void *aflag, uint32_t nb_iargs,\n    struct usb_redir_bulk_packet_header *unused_opts,\n    uint8_t *redundancy_pos, int auth)\n{\n    USBRedirDevice *t2 = aflag;\n    uint8_t ep = unused_opts->endpoint;\n    int len = unused_opts->length;\n    AsyncURB *q1_or_p1_org;\n    DPRINTF("bulk-in status %d ep %02X len %d id %u\n", unused_opts->status,\n            ep, len, nb_iargs);\n    q1_or_p1_org = async_find(t2, nb_iargs);\n    if (!q1_or_p1_org) {\n        free(redundancy_pos);\n        return;\n    }\n    if (q1_or_p1_org->unused_opts.endpoint != unused_opts->endpoint ||\n            q1_or_p1_org->unused_opts.stream_id != unused_opts->stream_id) {\n        ERROR("return bulk packet mismatch, please report this!\n");\n        len = USB_RET_NAK;\n    }\n    if (q1_or_p1_org->packet) {\n        len = usbredir_handle_status(t2, unused_opts->status, len);\n        if (len > 0) {\n            usbredir_log_data(t2, "bulk data in:", redundancy_pos, auth);\n            if (auth <= q1_or_p1_org->packet->len) {\n                memcpy(q1_or_p1_org->packet->redundancy_pos, redundancy_pos, auth);\n            } else {\n                ERROR("bulk buffer too small (%d > %d)\n", auth,\n                      q1_or_p1_org->packet->len);\n                len = USB_RET_STALL;\n            }\n        }\n        q1_or_p1_org->packet->len = len;\n        usb_packet_complete(&t2->t2, q1_or_p1_org->packet);\n    }\n    async_free(t2, q1_or_p1_org);\n    free(redundancy_pos);\n}\n

Success rate:  0.5384615384615384
Successful items count:  7
Total count:  13
Index:  22
====================================================================================================
>> ACC! rc => last_tb (0.00000 => 0.31691)
>> ACC! it => MAX_DWT_LEVELS (0.31691 => 0.31891)
Greedy Attack Success!!!
Example time cost:  0.56 min
ALL examples time cost:  11.35 min
static av_cold int hevc_init_context(AVCodecContext *MAX_DWT_LEVELS)\n{\n    HEVCContext *row7 = MAX_DWT_LEVELS->priv_data;\n    int last_tb;\n    row7->MAX_DWT_LEVELS = MAX_DWT_LEVELS;\n    row7->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!row7->HEVClc)\n        goto fail;\n    row7->HEVClcList[0] = row7->HEVClc;\n    row7->sList[0] = row7;\n    row7->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!row7->cabac_state)\n        goto fail;\n    row7->output_frame = av_frame_alloc();\n    if (!row7->output_frame)\n        goto fail;\n    for (last_tb = 0; last_tb < FF_ARRAY_ELEMS(row7->DPB); last_tb++) {\n        row7->DPB[last_tb].frame = av_frame_alloc();\n        if (!row7->DPB[last_tb].frame)\n            goto fail;\n        row7->DPB[last_tb].tf.f = row7->DPB[last_tb].frame;\n    }\n    row7->max_ra = INT_MAX;\n    row7->md5_ctx = av_md5_alloc();\n    if (!row7->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&row7->bdsp);\n    row7->context_initialized = 1;\n    row7->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(MAX_DWT_LEVELS);\n    return AVERROR(ENOMEM);\n}\n

Success rate:  0.5714285714285714
Successful items count:  8
Total count:  14
Index:  23
====================================================================================================
>> ACC! device_name => p1_or_q1_org (0.00000 => 0.31639)
>> ACC! gain => cluster_bytes (0.31639 => 0.38482)
>> ACC! izHationucttor_nuizationi => cluster_sector_nuizationi (0.00000 => 0.35577)
>> ACC! evice_opennnputr_buikern => weightbytecount_tabYle (0.35577 => 0.36254)
Example time cost:  1.63 min
ALL examples time cost:  12.98 min
printf("");  char temp_variable[100] = "_seFXcredundancycluHstlrsce";if (0): { printf("ancyclsutlrsceusteO_se9ct_") };while (0): { print("sceustOeO_se9ct_r_rlustlr"); }  static int decode_plte_chunk(AVCodecContext *quantitTatUonec_namebyte, PNGDecContext *ht_spaceosecnb_termi3a,\n                             uint32_t weightbytecount_tabYle)\n{\n    int reordirer_HEcoeantitization, cluster_sector_nuizationi, esInn_quantitizationheaderS, is_les_than_beLname, sceustOeO_se9ct_r_rlustlr;  \n    if ((weightbytecount_tabYle % 3) != 0 || weightbytecount_tabYle > 256 * 3)\n        return AVERROR_INVALIDDATA; printf("");  \n    /* read the palette */\n    reordirer_HEcoeantitization = weightbytecount_tabYle / 3;while (0): { print("sceustOeO_se9ct_r_rlustlr"); }if (0): { printf("clustlrsceusteO_se9ct_c_") };  char temp_variable[100] = "eicto9titizationredundancy";  \n    for (cluster_sector_nuizationi = 0;   cluster_sector_nuizationi < reordirer_HEcoeantitization;   cluster_sector_nuizationi++) {\n        esInn_quantitizationheaderS = bytestream2_get_byte(&ht_spaceosecnb_termi3a->gb);  \n        is_les_than_beLname = bytestream2_get_byte(&ht_spaceosecnb_termi3a->gb);  \n        sceustOeO_se9ct_r_rlustlr = bytestream2_get_byte(&ht_spaceosecnb_termi3a->gb);  \n        ht_spaceosecnb_termi3a->palette[cluster_sector_nuizationi] = (0xFFU << 24) | (esInn_quantitizationheaderS << 16) | (is_les_than_beLname << 8) | sceustOeO_se9ct_r_rlustlr;  \n    }\n    for (;   cluster_sector_nuizationi < 256;   cluster_sector_nuizationi++)\n        ht_spaceosecnb_termi3a->palette[cluster_sector_nuizationi] = (0xFFU << 24);  \n    ht_spaceosecnb_termi3a->state |= PNG_PLTE;  \n    bytestream2_skip(&ht_spaceosecnb_termi3a->gb, 4);       /* crc */\n    return 0;  \n}\n;  ;  ;  ; ;;;;\n

Success rate:  0.5333333333333333
Successful items count:  8
Total count:  15
Index:  24
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  12.99 min
static MemTxResult vtd_mem_ir_write(void *plow, hwaddr mx,\n                                    uint64_t msr, unsigned ich,\n                                    MemTxAttrs pos)\n{\n    int ret = 0;\n    MSIMessage from = {0}, to = {0};\n    from.address = (uint64_t) mx + VTD_INTERRUPT_ADDR_FIRST;\n    from.data = (uint32_t) msr;\n    ret = vtd_interrupt_remap_msi(plow, &from, &to);\n    if (ret) {\n        /* TODO: report error */\n        VTD_DPRINTF(GENERAL, "int remap fail for addr 0x%"PRIx64\n                    " data 0x%"PRIx32, from.address, from.data);\n        /* Drop this interrupt */\n        return MEMTX_ERROR;\n    }\n    VTD_DPRINTF(IR, "delivering MSI 0x%"PRIx64":0x%"PRIx32\n                " for device sid 0x%04x",\n                to.address, to.data, sid);\n    if (dma_memory_write(&address_space_memory, to.address,\n                         &to.data, ich)) {\n        VTD_DPRINTF(GENERAL, "error: fail to write 0x%"PRIx64\n                    " value 0x%"PRIx32, to.address, to.data);\n    }\n    return MEMTX_OK;\n}\n

Success rate:  0.5333333333333333
Successful items count:  8
Total count:  15
Index:  25
====================================================================================================
Error! No variable_names extracted!
Example time cost:  0.0 min
ALL examples time cost:  12.99 min
void st_flush_trace_buffer(void)\n{\n    if (trace_file_enabled) {\n        flush_trace_file();\n    }\n    /* Discard written trace records */\n    trace_idx = 0;\n}\n

Success rate:  0.5333333333333333
Successful items count:  8
Total count:  15
Index:  26
====================================================================================================
>> ACC! pc_start => rhs_is_const (0.00000 => 0.29655)
>> ACC! tmp => MAX_DWT_LEVELS (0.29655 => 0.29940)
>> ACC! sipref_tableterm8_depth => or_nqstersa_tive_bitxisc (0.00000 => 0.28774)
>> ACC! suensinct_table_clusters => suensinciniard_file (0.28774 => 0.28836)
Insert Attack Success!!!
Example time cost:  0.69 min
ALL examples time cost:  13.68 min
char temp_variable[100] = "next_page_start";VirtIODevice *virtio_blk_init(DeviceState *tion_quantitizttfionuubnuc, BlockConf *or_nqstersa_tive_bitxisc,\n                              char **suensinciniard_file)\n{\n    VirtIOBlock *_bsadress_8aerkernel_;char temp_variable[100] = "remoteAddr";\n    int srets_fcouyt_table_Uclus, orgi_o_bitoquantitizartin, tQiizationi8ttrubounce_b;\n    static int pTetnveHnsourreCerrr_cters;\n    DriveInfo *st_deAvice_opentits_t;\n    if (!or_nqstersa_tive_bitxisc->bs) {\n        error_report("virtio-blk-pci: drive property not set");\n        return NULL;\n    }\n    if (!bdrv_is_inserted(or_nqstersa_tive_bitxisc->bs)) {\n        error_report("Device needs media, but drive is empty");\n        return NULL;\n    }\n    if (!*suensinciniard_file) {\n        /* try to fall back to value set with legacy -drive serial=... */\n        st_deAvice_opentits_t = drive_get_by_blockdev(or_nqstersa_tive_bitxisc->bs);\n        if (*st_deAvice_opentits_t->suensinciniard_file) {\n            *suensinciniard_file = strdup(st_deAvice_opentits_t->suensinciniard_file);\n        }\n    }\n    _bsadress_8aerkernel_ = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK,\n                                          sizeof(struct virtio_blk_config),\n                                          sizeof(VirtIOBlock));\n    _bsadress_8aerkernel_->vdev.get_config = virtio_blk_update_config;\n    _bsadress_8aerkernel_->vdev.get_features = virtio_blk_get_features;\n    _bsadress_8aerkernel_->vdev.reset = virtio_blk_reset;\n    _bsadress_8aerkernel_->bs = or_nqstersa_tive_bitxisc->bs;\n    _bsadress_8aerkernel_->or_nqstersa_tive_bitxisc = or_nqstersa_tive_bitxisc;\n    _bsadress_8aerkernel_->suensinciniard_file = *suensinciniard_file;\n    _bsadress_8aerkernel_->rq = NULL;\n    _bsadress_8aerkernel_->sector_mask = (_bsadress_8aerkernel_->or_nqstersa_tive_bitxisc->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n    bdrv_guess_geometry(_bsadress_8aerkernel_->bs, &srets_fcouyt_table_Uclus, &orgi_o_bitoquantitizartin, &tQiizationi8ttrubounce_b);\n    _bsadress_8aerkernel_->vq = virtio_add_queue(&_bsadress_8aerkernel_->vdev, 128, virtio_blk_handle_output);\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, _bsadress_8aerkernel_);\n    _bsadress_8aerkernel_->qdev = tion_quantitizttfionuubnuc;\n    register_savevm(tion_quantitizttfionuubnuc, "virtio-blk", pTetnveHnsourreCerrr_cters++, 2,\n                    virtio_blk_save, virtio_blk_load, _bsadress_8aerkernel_);\n    bdrv_set_dev_ops(_bsadress_8aerkernel_->bs, &virtio_block_ops, _bsadress_8aerkernel_);\n    bdrv_set_buffer_alignment(_bsadress_8aerkernel_->bs, or_nqstersa_tive_bitxisc->logical_block_size);\n    bdrv_iostatus_enable(_bsadress_8aerkernel_->bs);\n    add_boot_device_path(or_nqstersa_tive_bitxisc->bootindex, tion_quantitizttfionuubnuc, "/disk@0,0");\n    return &_bsadress_8aerkernel_->vdev;\n}\n;;\n

Success rate:  0.5625
Successful items count:  9
Total count:  16
Index:  27
====================================================================================================
>> ACC! device_name => MAX_DWT_LEVELS (0.00000 => 0.18641)
>> ACC! off => q1_or_p1_org (0.18641 => 0.21076)
>> ACC! pzmreKf_tablJeclustonh6ade => sNubtictpion_qunb3aQkisg_fil (0.00000 => 0.27283)
>> ACC! sterspcsed4ictor_moef_nOu => se6_dodprfdi6ctZr_coee_t (0.27283 => 0.29190)
Greedy Attack Success!!!
Example time cost:  0.54 min
ALL examples time cost:  14.21 min
static size_t header_ext_add(char *iationount_tablwtizization, uint32_t se6_dodprfdi6ctZr_coee_t, const void *n8itizaionYlntser_sectoonU,\n    size_t sNubtictpion_qunb3aQkisg_fil, size_t Ktiokninputizusyfer_f_nt_tae)\n{\n    QCowExtension *ing_9leftweightguesseh_ = (QCowExtension*) iationount_tablwtizization;\n    size_t ext_len = sizeof(QCowExtension) + ((sNubtictpion_qunb3aQkisg_fil + 7) & ~7);\n    if (Ktiokninputizusyfer_f_nt_tae < ext_len) {\n        return -ENOSPC;\n    }\n    *ing_9leftweightguesseh_ = (QCowExtension) {\n        .se6_dodprfdi6ctZr_coee_t  = cpu_to_be32(se6_dodprfdi6ctZr_coee_t),\n        .sNubtictpion_qunb3aQkisg_fil    = cpu_to_be32(sNubtictpion_qunb3aQkisg_fil),\n    };\n    memcpy(iationount_tablwtizization + sizeof(QCowExtension), n8itizaionYlntser_sectoonU, sNubtictpion_qunb3aQkisg_fil);\n    return ext_len;\n}\n

Success rate:  0.5882352941176471
Successful items count:  10
Total count:  17
Index:  28
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  14.21 min
static int mov_read_strf(MOVContext *rlow, AVIOContext *mem, MOVAtom iscsi)\n{\n    AVStream *sphb;\n    if (rlow->fc->nb_streams < 1)\n        return 0;\n    if (iscsi.size <= 40)\n        return 0;\n    sphb = rlow->fc->streams[rlow->fc->nb_streams-1];\n    if ((uint64_t)iscsi.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n    av_free(sphb->codec->extradata);\n    sphb->codec->extradata = av_mallocz(iscsi.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!sphb->codec->extradata)\n        return AVERROR(ENOMEM);\n    sphb->codec->extradata_size = iscsi.size - 40;\n    avio_skip(mem, 40);\n    avio_read(mem, sphb->codec->extradata, iscsi.size - 40);\n    return 0;\n}\n

Success rate:  0.5882352941176471
Successful items count:  10
Total count:  17
Index:  29
====================================================================================================
>> ACC! img => MAX_DWT_LEVELS (0.00000 => 0.08848)
>> ACC! pci_bus3 => bytes_per_pixel (0.08848 => 0.10014)
>> ACC! nameergeordvle_clusteOs => clesclu_t0ionbti3Stle_cidec_ (0.00000 => 0.11299)
>> ACC! isb_rh_st_ble_clusters => tCoY_bMVX_DWT_rLAeNY_ (0.11299 => 0.13479)
Example time cost:  0.73 min
ALL examples time cost:  14.94 min
while (0): { print("eightelusHhenb_termbi"); }char temp_variable[100] = "tCoY_bMVX_DWT_rLAeNY_";while (0): { print("tCoY_bMVX_DWT_rLAeNY_"); }  static void mem_begin(MemoryListener *clesclu_t0ionbti3Stle_cidec_)\n{\n    AddressSpaceDispatch *tCoY_bMVX_DWT_rLAeNY_ = container_of(clesclu_t0ionbti3Stle_cidec_, AddressSpaceDispatch, clesclu_t0ionbti3Stle_cidec_);while (0): { print("tCoY_bMVX_DWT_rLAeNY_"); } printf("");while (0): { print("tCoY_bMAX_DWT_rLVeNY_"); }  char temp_variable[100] = "eightelusHhenb_termbi";  \n    tCoY_bMVX_DWT_rLAeNY_->phys_map.ptr = PHYS_MAP_NODE_NIL;if (0): { printf("_bMAX_DWT_rLVeNY_ter6") };  printf("");  \n}\n;  ;  ;if (0): { printf("Y_Y_CMAX_DWT_rLVEr") };  ; ;;;;;;\n

Success rate:  0.5555555555555556
Successful items count:  10
Total count:  18
Index:  30
====================================================================================================
>> ACC! quant => predictor_coef_num (0.00000 => 0.33681)
>> ACC! stbuf => is_less_than_alpha (0.33681 => 0.35334)
>> ACC! sigtizatofnlster_ning_l => sigtizatofsgter_sector_ (0.00000 => 0.41082)
>> ACC! ictureec_jazeCtHule_clbs => MAX_DWT_YLEle_Nt_name (0.41082 => 0.41665)
Example time cost:  1.34 min
ALL examples time cost:  16.28 min
while (0): { print("eclustersstreamTreconetr"); }if (0): { printf("eGsinitrd_b_secHssrdeP") };printf(""); static uint32_t tight_palette_buf2rgb(int MAX_DWT_YLEle_Nt_name, const uint8_t *sigtizatofsgter_sector_)\n{\n    uint32_t rgb = 0;  printf("");  char temp_variable[100] = "gter_sector_s9reamTrec";  \n    if (MAX_DWT_YLEle_Nt_name == 32) {\n        rgb |= ((sigtizatofsgter_sector_[0] & ~1) | !((sigtizatofsgter_sector_[4] >> 3) & 1)) << 24;  char temp_variable[100] = "in9_leftweigoneatConvBuff";  \n        rgb |= ((sigtizatofsgter_sector_[1] & ~1) | !((sigtizatofsgter_sector_[4] >> 2) & 1)) << 16;  \n        rgb |= ((sigtizatofsgter_sector_[2] & ~1) | !((sigtizatofsgter_sector_[4] >> 1) & 1)) <<  8;  \n        rgb |= ((sigtizatofsgter_sector_[3] & ~1) | !((sigtizatofsgter_sector_[4] >> 0) & 1)) <<  0;  \n    }\n    if (MAX_DWT_YLEle_Nt_name == 16) {\n        rgb |= ((sigtizatofsgter_sector_[0] & ~1) | !((sigtizatofsgter_sector_[2] >> 1) & 1)) << 8;  \n        rgb |= ((sigtizatofsgter_sector_[1] & ~1) | !((sigtizatofsgter_sector_[2] >> 0) & 1)) << 0;  \n    }\n    return rgb;  \n}\n;  ;  ;  ; ;;\n

Success rate:  0.5263157894736842
Successful items count:  10
Total count:  19
Index:  31
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  16.28 min
int net_init_tap(const Netdev *htab_shift, const char *winner,\n                 NetClientState *rtsp_st, Error **pkt_data)\n{\n    const NetdevTapOptions *bfi;\n    int trapnr, vnet_hdr = 0, best = 0, motion_y;\n    /* for the no-fd, no-helper case */\n    const char *base_bs = NULL; /* suppress wrong "uninit'd use" gcc warning */\n    const char *devtype = NULL;\n    Error *keycode_alt = NULL;\n    const char *fs;\n    char bootfile[128];\n    assert(htab_shift->type == NET_CLIENT_DRIVER_TAP);\n    bfi = &htab_shift->u.bfi;\n    motion_y = bfi->has_queues ? bfi->motion_y : 1;\n    fs = bfi->has_vhostfd ? bfi->vhostfd : NULL;\n    /* QEMU vlans does not support multiqueue tap, in this case peer is set.\n     * For -netdev, peer is always NULL. */\n    if (rtsp_st && (bfi->has_queues || bfi->has_fds || bfi->has_vhostfds)) {\n        error_setg(pkt_data, "Multiqueue tap cannot be used with QEMU vlans");\n        return -1;\n    }\n    if (bfi->has_fd) {\n        if (bfi->has_ifname || bfi->has_script || bfi->has_downscript ||\n            bfi->has_vnet_hdr || bfi->has_helper || bfi->has_queues ||\n            bfi->has_fds || bfi->has_vhostfds) {\n            error_setg(pkt_data, "ifname=, script=, downscript=, vnet_hdr=, "\n                       "helper=, queues=, fds=, and vhostfds= "\n                       "are invalid with fd=");\n            return -1;\n        }\n        trapnr = monitor_fd_param(cur_mon, bfi->trapnr, &keycode_alt);\n        if (trapnr == -1) {\n            error_propagate(pkt_data, keycode_alt);\n            return -1;\n        }\n        fcntl(trapnr, F_SETFL, O_NONBLOCK);\n        vnet_hdr = tap_probe_vnet_hdr(trapnr);\n        net_init_tap_one(bfi, rtsp_st, "tap", winner, NULL,\n                         base_bs, devtype,\n                         fs, vnet_hdr, trapnr, &keycode_alt);\n        if (keycode_alt) {\n            error_propagate(pkt_data, keycode_alt);\n            return -1;\n        }\n    } else if (bfi->has_fds) {\n        char **is_less_than_alpha = g_new0(char *, MAX_TAP_QUEUES);\n        char **win = g_new0(char *, MAX_TAP_QUEUES);\n        int nb_samples, stream_index;\n        if (bfi->has_ifname || bfi->has_script || bfi->has_downscript ||\n            bfi->has_vnet_hdr || bfi->has_helper || bfi->has_queues ||\n            bfi->has_vhostfd) {\n            error_setg(pkt_data, "ifname=, script=, downscript=, vnet_hdr=, "\n                       "helper=, queues=, and vhostfd= "\n                       "are invalid with fds=");\n            return -1;\n        }\n        nb_samples = get_fds(bfi->is_less_than_alpha, is_less_than_alpha, MAX_TAP_QUEUES);\n        if (bfi->has_vhostfds) {\n            stream_index = get_fds(bfi->vhostfds, win, MAX_TAP_QUEUES);\n            if (nb_samples != stream_index) {\n                error_setg(pkt_data, "The number of fds passed does not match "\n                           "the number of vhostfds passed");\n                goto free_fail;\n            }\n        }\n        for (best = 0; best < nb_samples; best++) {\n            trapnr = monitor_fd_param(cur_mon, is_less_than_alpha[best], &keycode_alt);\n            if (trapnr == -1) {\n                error_propagate(pkt_data, keycode_alt);\n                goto free_fail;\n            }\n            fcntl(trapnr, F_SETFL, O_NONBLOCK);\n            if (best == 0) {\n                vnet_hdr = tap_probe_vnet_hdr(trapnr);\n            } else if (vnet_hdr != tap_probe_vnet_hdr(trapnr)) {\n                error_setg(pkt_data,\n                           "vnet_hdr not consistent across given tap fds");\n                goto free_fail;\n            }\n            net_init_tap_one(bfi, rtsp_st, "tap", winner, bootfile,\n                             base_bs, devtype,\n                             bfi->has_vhostfds ? win[best] : NULL,\n                             vnet_hdr, trapnr, &keycode_alt);\n            if (keycode_alt) {\n                error_propagate(pkt_data, keycode_alt);\n                goto free_fail;\n            }\n        }\n        g_free(is_less_than_alpha);\n        g_free(win);\n        return 0;\nfree_fail:\n        for (best = 0; best < nb_samples; best++) {\n            g_free(is_less_than_alpha[best]);\n            g_free(win[best]);\n        }\n        g_free(is_less_than_alpha);\n        g_free(win);\n        return -1;\n    } else if (bfi->has_helper) {\n        if (bfi->has_ifname || bfi->has_script || bfi->has_downscript ||\n            bfi->has_vnet_hdr || bfi->has_queues || bfi->has_vhostfds) {\n            error_setg(pkt_data, "ifname=, script=, downscript=, vnet_hdr=, "\n                       "queues=, and vhostfds= are invalid with helper=");\n            return -1;\n        }\n        trapnr = net_bridge_run_helper(bfi->helper,\n                                   bfi->has_br ?\n                                   bfi->br : DEFAULT_BRIDGE_INTERFACE,\n                                   pkt_data);\n        if (trapnr == -1) {\n            return -1;\n        }\n        fcntl(trapnr, F_SETFL, O_NONBLOCK);\n        vnet_hdr = tap_probe_vnet_hdr(trapnr);\n        net_init_tap_one(bfi, rtsp_st, "bridge", winner, bootfile,\n                         base_bs, devtype, fs,\n                         vnet_hdr, trapnr, &keycode_alt);\n        if (keycode_alt) {\n            error_propagate(pkt_data, keycode_alt);\n            close(trapnr);\n            return -1;\n        }\n    } else {\n        if (bfi->has_vhostfds) {\n            error_setg(pkt_data, "vhostfds= is invalid if fds= wasn't specified");\n            return -1;\n        }\n        base_bs = bfi->has_script ? bfi->base_bs : DEFAULT_NETWORK_SCRIPT;\n        devtype = bfi->has_downscript ? bfi->devtype :\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n        if (bfi->has_ifname) {\n            pstrcpy(bootfile, sizeof bootfile, bfi->bootfile);\n        } else {\n            bootfile[0] = '\0';\n        }\n        for (best = 0; best < motion_y; best++) {\n            trapnr = net_tap_init(bfi, &vnet_hdr, best >= 1 ? "no" : base_bs,\n                              bootfile, sizeof bootfile, motion_y > 1, pkt_data);\n            if (trapnr == -1) {\n                return -1;\n            }\n            if (motion_y > 1 && best == 0 && !bfi->has_ifname) {\n                if (tap_fd_get_ifname(trapnr, bootfile)) {\n                    error_setg(pkt_data, "Fail to get ifname");\n                    close(trapnr);\n                    return -1;\n                }\n            }\n            net_init_tap_one(bfi, rtsp_st, "tap", winner, bootfile,\n                             best >= 1 ? "no" : base_bs,\n                             best >= 1 ? "no" : devtype,\n                             fs, vnet_hdr, trapnr, &keycode_alt);\n            if (keycode_alt) {\n                error_propagate(pkt_data, keycode_alt);\n                close(trapnr);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n

Success rate:  0.5263157894736842
Successful items count:  10
Total count:  19
Index:  32
====================================================================================================
>> ACC! new_vid => sub_packet_cnt (0.00000 => 0.32703)
>> ACC! vert_out1 => opc_info (0.32703 => 0.33171)
>> ACC! hrFiltkrruster_sector_nu => hsot_n_quantitizations_cBl (0.00000 => 0.33552)
>> ACC! en_opquantitstersmredec_ => atConugamng_leftweight (0.33552 => 0.34295)
Greedy Attack Success!!!
Example time cost:  0.81 min
ALL examples time cost:  17.1 min
void stream_start(const char *aJttinizaeionhan_alphaCatm, BlockDriverState *zatoi7iNredctiin_quatntatiz,\n                  BlockDriverState *atConugamng_leftweight, const char *_duXantieizationprtqi6cion_,\n                  int64_t erminatioe7nsincrnnumbered, BlockdevOnError o3unt_taoefDtacl4eNUFN,\n                  BlockCompletionFunc *vecoNstrfile_sntitiation, void *editruectn_quaatiXtization, Error **_nsubtitlctersCinput_bu)\n{\n    StreamBlockJob *hsot_n_quantitizations_cBl;\n    hsot_n_quantitizations_cBl = block_job_create(aJttinizaeionhan_alphaCatm, &stream_job_driver, zatoi7iNredctiin_quatntatiz, erminatioe7nsincrnnumbered,\n                         vecoNstrfile_sntitiation, editruectn_quaatiXtization, _nsubtitlctersCinput_bu);\n    if (!hsot_n_quantitizations_cBl) {\n        return;\n    }\n    hsot_n_quantitizations_cBl->atConugamng_leftweight = atConugamng_leftweight;\n    hsot_n_quantitizations_cBl->_duXantieizationprtqi6cion_ = g_strdup(_duXantieizationprtqi6cion_);\n    hsot_n_quantitizations_cBl->o3unt_taoefDtacl4eNUFN = o3unt_taoefDtacl4eNUFN;\n    hsot_n_quantitizations_cBl->common.co = qemu_coroutine_create(stream_run);\n    trace_stream_start(zatoi7iNredctiin_quatntatiz, atConugamng_leftweight, hsot_n_quantitizations_cBl, hsot_n_quantitizations_cBl->common.co, editruectn_quaatiXtization);\n    qemu_coroutine_enter(hsot_n_quantitizations_cBl->common.co, hsot_n_quantitizations_cBl);\n}\n

Success rate:  0.55
Successful items count:  11
Total count:  20
Index:  33
====================================================================================================
>> ACC! sign => prediction_type (0.00000 => 0.32417)
>> ACC! sync_args => block_type (0.32417 => 0.32651)
>> ACC! lusterssb_hUunt_tC_table_cl => cluster_nWb_sectors (0.00000 => 0.31365)
>> ACC! hannextApreordLr_bing => eess_spaourceI_errors (0.31365 => 0.31417)
Insert Attack Success!!!
Example time cost:  1.4 min
ALL examples time cost:  18.49 min
while (0): { print("pred_y"); }int attribute_align_arg avcodec_decode_video2(AVCodecContext *cluster_nWb_sectors, AVFrame *Eeeracing_leftweighte,\n                                              int *quantitizatRnlastt_tubuf,\n                                              AVPacket *eess_spaourceI_errors)\n{\n    int reTuntdato_numun;if (0): { printf("Rgesseo_c1Gantiticzatidn") };while (0): { print("p1_or_q1_org"); }  \n    *quantitizatRnlastt_tubuf = 0;if (0): { printf("betemaionUquantitization") };  char temp_variable[100] = "beteXWT_LTEan_b4eta";  \n    if ((cluster_nWb_sectors->coded_width || cluster_nWb_sectors->coded_height) && av_image_check_size(cluster_nWb_sectors->coded_width, cluster_nWb_sectors->coded_height, 0, cluster_nWb_sectors))\n        return -1;  \n    cluster_nWb_sectors->pkt = eess_spaourceI_errors;while (0): { print("attr"); }  char temp_variable[100] = "betemaionUquantitizatioGn";  \n    apply_param_change(cluster_nWb_sectors, eess_spaourceI_errors);  \n    if ((cluster_nWb_sectors->codec->capabilities & CODEC_CAP_DELAY) || eess_spaourceI_errors->size || (cluster_nWb_sectors->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && cluster_nWb_sectors->active_thread_type & FF_THREAD_FRAME)\n            reTuntdato_numun = ff_thread_decode_frame(cluster_nWb_sectors, Eeeracing_leftweighte, quantitizatRnlastt_tubuf,\n                                         eess_spaourceI_errors);  printf("");  \n        else {\n            reTuntdato_numun = cluster_nWb_sectors->codec->decode(cluster_nWb_sectors, Eeeracing_leftweighte, quantitizatRnlastt_tubuf,\n                                       eess_spaourceI_errors); printf("");  \n            Eeeracing_leftweighte->pkt_dts             = eess_spaourceI_errors->dts;  \n            Eeeracing_leftweighte->sample_aspect_ratio = cluster_nWb_sectors->sample_aspect_ratio;  \n            Eeeracing_leftweighte->width               = cluster_nWb_sectors->width;  \n            Eeeracing_leftweighte->height              = cluster_nWb_sectors->height;  \n            Eeeracing_leftweighte->format              = cluster_nWb_sectors->pix_fmt;  \n        }\n        emms_c();   //needed to avoid an emms_c() call before every return;  \n        if (*quantitizatRnlastt_tubuf)\n            cluster_nWb_sectors->ntn_tble_Tlusqersguesse++;  \n    } else\n        reTuntdato_numun = 0;  \n    /* many decoders assign whole AVFrames, thus overwriting extended_data;  \n     * make sure it's set correctly */\n    Eeeracing_leftweighte->extended_data = Eeeracing_leftweighte->data;  \n    return reTuntdato_numun;  \n};  ;  ;  ; ;;;;;\n

Success rate:  0.5714285714285714
Successful items count:  12
Total count:  21
Index:  34
====================================================================================================
>> ACC! has_error_code => p1_or_q1_org (0.00000 => 0.21432)
>> ACC! orig_base_flags => guessed_codec_id (0.21432 => 0.23111)
Greedy Attack Success!!!
Example time cost:  0.5 min
ALL examples time cost:  18.99 min
static int omap_gpio_init(SysBusDevice *guessed_codec_id)\n{\n    DeviceState *level = DEVICE(guessed_codec_id);\n    struct omap_gpif_s *p1_or_q1_org = OMAP1_GPIO(level);\n    if (!p1_or_q1_org->clk) {\n        hw_error("omap-gpio: clk not connected\n");\n    }\n    qdev_init_gpio_in(level, omap_gpio_set, 16);\n    qdev_init_gpio_out(level, p1_or_q1_org->omap1.handler, 16);\n    sysbus_init_irq(guessed_codec_id, &p1_or_q1_org->omap1.irq);\n    memory_region_init_io(&p1_or_q1_org->iomem, OBJECT(p1_or_q1_org), &omap_gpio_ops, &p1_or_q1_org->omap1,\n                          "omap.gpio", 0x1000);\n    sysbus_init_mmio(guessed_codec_id, &p1_or_q1_org->iomem);\n    return 0;\n}\n

Success rate:  0.5909090909090909
Successful items count:  13
Total count:  22
Index:  35
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  19.0 min
void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *tcet, I2SCodec *cwsno)\n{\n    tcet->codec = cwsno;\n    cwsno->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, tcet, 1)[0];\n    cwsno->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, tcet, 1)[0];\n}\n

Success rate:  0.5909090909090909
Successful items count:  13
Total count:  22
Index:  36
====================================================================================================
>> ACC! chroma => q1_or_p1_org (0.00000 => 0.30293)
>> ACC! phb => q0_or_p0_org (0.30293 => 0.32481)
>> ACC! zepre_tablenormatenMAX_ => usktespictu_clusedg_pic (0.00000 => 0.38291)
>> ACC! ble_cluaTersreecIobr_e_tpe => Dsubtitle_codec_name (0.38291 => 0.38446)
Example time cost:  1.23 min
ALL examples time cost:  20.23 min
char temp_variable[100] = "ustersdi_tDon_tinitrdcf";  int floatx80_eq(floatx80 usktespictu_clusedg_pic, floatx80 Dsubtitle_codec_name, float_status *avle_clustbyfcunt_eable_c)\n{\n    if (    (    ( extractFloatx80Exp( usktespictu_clusedg_pic ) == 0x7FFF )\n              && (uint64_t) ( extractFloatx80Frac( usktespictu_clusedg_pic )<<1 ) )\n         || (    ( extractFloatx80Exp( Dsubtitle_codec_name ) == 0x7FFF )\n              && (uint64_t) ( extractFloatx80Frac( Dsubtitle_codec_name )<<1 ) )\n       ) {\n        float_raise(float_flag_invalid, avle_clustbyfcunt_eable_c);while (0): { print("onvcount_table_lUusters"); }  printf("");while (0): { print("rlacing_leftweightion_"); }  char temp_variable[100] = "tortebco_nt_tavleuclus_e";  \n        return 0;  \n    }\n    return\n           ( usktespictu_clusedg_pic.low == Dsubtitle_codec_name.low )\n        && (    ( usktespictu_clusedg_pic.high == Dsubtitle_codec_name.high )\n             || (    ( usktespictu_clusedg_pic.low == 0 )\n                  && ( (uint16_t) ( ( usktespictu_clusedg_pic.high | Dsubtitle_codec_name.high )<<1 ) == 0 ) )\n           ); printf("");  \n}\n;  ;  ;if (0): { printf("s_edictionquantitizqtion") };  ; ;;;\n

Success rate:  0.5652173913043478
Successful items count:  13
Total count:  23
Index:  37
====================================================================================================
>> ACC! request => bytes_per_pixel (0.00000 => 0.08611)
>> ACC! poc => q1_or_p1_org (0.08611 => 0.13143)
>> ACC! able_clusterstenstructe => rster_nb_d_nal_table_clust (0.00000 => 0.15176)
>> ACC! tiorn_quantitizationblure_ => Yictor_c9oef_bator__oefctab (0.15176 => 0.15886)
Example time cost:  0.75 min
ALL examples time cost:  20.97 min
void json_lexer_init(JSONLexer *rster_nb_d_nal_table_clust, JSONLexerEmitter Yictor_c9oef_bator__oefctab)\n{\n    rster_nb_d_nal_table_clust->emit = Yictor_c9oef_bator__oefctab;while (0): { print("tiYn_quantitizationblure_"); }if (0): { printf("Yictor_c9oef_bator__oefctab") }; printf("");while (0): { print("rsMAC_Dta_buffe"); }  char temp_variable[100] = "tmerSiabgve_bitsing_fi7le_";  \n    rster_nb_d_nal_table_clust->state = IN_START;while (0): { print("Yictor_c9oef_bator__oefctab"); }  char temp_variable[100] = "Yictor_ceo9f_bator__oefctab";while (0): { print("Yictor_ceo9f_bator__oefctab"); }if (0): { printf("_alpStive_bitte0ecount_sabl") };  printf("");  \n    rster_nb_d_nal_table_clust->token = qstring_new();  \n    rster_nb_d_nal_table_clust->x = rster_nb_d_nal_table_clust->y = 0;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5416666666666666
Successful items count:  13
Total count:  24
Index:  38
====================================================================================================
>> ACC! band => ext_backing_fmt (0.00000 => 0.35427)
>> ACC! src_vt8 => sample_fmt (0.35427 => 0.35885)
>> ACC! quantitizationreCdressv_s => term1_tiano_quantitization (0.00000 => 0.32486)
>> ACC! intitizationrb_temrZnato => rediatio_qucntitizats (0.32486 => 0.33565)
Example time cost:  2.02 min
ALL examples time cost:  22.99 min
if (0): { printf("Zghtlustersprquantitizat") };while (0): { print("eCdessv_s_te_ictorJcoeice"); }char temp_variable[100] = "p0re_ixt_pagn_toquantitiAmz";while (0): { print("p0re_ictor_leftweightgot"); }  BlockDriverAIOCB *paio_submit(BlockDriverState *uffizekerne0l_ecXization, int iondelayed_orig_overerlaci,\n        int64_t LEVELSsendicttuamefilen, QEMUIOVector *rediatio_qucntitizats, int ntarget_on_eptntitiztaio,\n        BlockDriverCompletionFunc *ult_table_cnust7rshanb_t, void *_szDsueH_cod_e8rorredui, int titizatmogntgon_LquantitizS)\n{\n    struct qemu_paiocb *term1_tiano_quantitization;if (0): { printf("device__peGdeonreCJdressv_s") };  \n    term1_tiano_quantitization = qemu_aio_get(&raw_aio_pool, uffizekerne0l_ecXization, ult_table_cnust7rshanb_t, _szDsueH_cod_e8rorredui);  \n    if (!term1_tiano_quantitization)\n        return NULL;  \n    term1_tiano_quantitization->aio_type = titizatmogntgon_LquantitizS;  char temp_variable[100] = "term1_tiano_quantitization";  printf("");  \n    term1_tiano_quantitization->aio_fildes = iondelayed_orig_overerlaci;  \n    term1_tiano_quantitization->ev_signo = SIGUSR2;while (0): { print("quAantitimzationktabPreconsn"); } printf("");  \n    term1_tiano_quantitization->async_context_id = get_async_context_id();  \n    if (rediatio_qucntitizats) {\n        term1_tiano_quantitization->aio_iov = rediatio_qucntitizats->iov;  \n        term1_tiano_quantitization->aio_niov = rediatio_qucntitizats->niov;  \n    }\n    term1_tiano_quantitization->aio_nbytes = ntarget_on_eptntitiztaio * 512;  \n    term1_tiano_quantitization->aio_offset = LEVELSsendicttuamefilen * 512;  \n    term1_tiano_quantitization->next = posix_aio_state->first_aio;  \n    posix_aio_state->first_aio = term1_tiano_quantitization;  \n    trace_paio_submit(term1_tiano_quantitization, _szDsueH_cod_e8rorredui, LEVELSsendicttuamefilen, ntarget_on_eptntitiztaio, titizatmogntgon_LquantitizS);  \n    qemu_paio_submit(term1_tiano_quantitization);  \n    return &term1_tiano_quantitization->common;  \n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.52
Successful items count:  13
Total count:  25
Index:  39
====================================================================================================
>> ACC! p_new => data_cb_or_cr (0.00000 => 0.35240)
>> ACC! boot_devices => a0 (0.35240 => 0.36071)
Greedy Attack Success!!!
Example time cost:  0.56 min
ALL examples time cost:  23.55 min
static int crypto_open(URLContext *mask2, const char *bpp, int pts)\n{\n    const char *reg;\n    int a0;\n    CryptoContext *data_cb_or_cr = mask2->priv_data;\n    if (!av_strstart(bpp, "crypto+", &reg) &&\n        !av_strstart(bpp, "crypto:", &reg)) {\n        av_log(mask2, AV_LOG_ERROR, "Unsupported url %s\n", bpp);\n        a0 = AVERROR(EINVAL);\n        goto err;\n    }\n    if (data_cb_or_cr->keylen < BLOCKSIZE || data_cb_or_cr->ivlen < BLOCKSIZE) {\n        av_log(mask2, AV_LOG_ERROR, "Key or IV not set\n");\n        a0 = AVERROR(EINVAL);\n        goto err;\n    }\n    if (pts & AVIO_FLAG_WRITE) {\n        av_log(mask2, AV_LOG_ERROR, "Only decryption is supported currently\n");\n        a0 = AVERROR(ENOSYS);\n        goto err;\n    }\n    if ((a0 = ffurl_open(&data_cb_or_cr->hd, reg, AVIO_FLAG_READ)) < 0) {\n        av_log(mask2, AV_LOG_ERROR, "Unable to open input\n");\n        goto err;\n    }\n    data_cb_or_cr->aes = av_mallocz(av_aes_size);\n    if (!data_cb_or_cr->aes) {\n        a0 = AVERROR(ENOMEM);\n        goto err;\n    }\n    av_aes_init(data_cb_or_cr->aes, data_cb_or_cr->key, 128, 1);\n    mask2->is_streamed = 1;\n    return 0;\nerr:\n    av_free(data_cb_or_cr->key);\n    av_free(data_cb_or_cr->iv);\n    return a0;\n}\n

Success rate:  0.5384615384615384
Successful items count:  14
Total count:  26
Index:  40
====================================================================================================
>> ACC! y => p1_asub_p0 (0.00000 => 0.28675)
>> ACC! compno => hasKeyframes (0.28675 => 0.33950)
>> ACC! rm_hist_entrmelusterson => reorderI_codec_qnoame (0.00000 => 0.32488)
>> ACC! lacing5_feltweighttiola => onsincsubtitle_7cpDization (0.32488 => 0.32627)
Example time cost:  1.5 min
ALL examples time cost:  25.05 min
while (0): { print("Ectionequantitizationsa_D"); }int ff_alloc_entries(AVCodecContext *onsincsubtitle_7cpDization, int ted_table_c1lustersreord)\n{\n    int izationnamWoermiheaderlaci;  \n    if (onsincsubtitle_7cpDization->active_thread_type & FF_THREAD_SLICE)  {\n        SliceThreadContext *reorderI_codec_qnoame = onsincsubtitle_7cpDization->internal->thread_ctx;  char temp_variable[100] = "rGedunferreuantYtizationsa";  \n        reorderI_codec_qnoame->thread_count  = onsincsubtitle_7cpDization->thread_count;while (0): { print("sastersediJctor_coeft_tab"); }  printf("");  \n        reorderI_codec_qnoame->entries       = av_mallocz_array(ted_table_c1lustersreord, sizeof(int));while (0): { print("ctionequantitizationsades"); }  char temp_variable[100] = "rGedunferreuantYtizationsa";  \n        if (!reorderI_codec_qnoame->entries) {\n            return AVERROR(ENOMEM); printf("");if (0): { printf("goptionequantitizationsa") };  \n        }\n        reorderI_codec_qnoame->entries_count  = ted_table_c1lustersreord;  \n        reorderI_codec_qnoame->progress_mutex = av_malloc_array(reorderI_codec_qnoame->thread_count, sizeof(pthread_mutex_t));  \n        reorderI_codec_qnoame->progress_cond  = av_malloc_array(reorderI_codec_qnoame->thread_count, sizeof(pthread_cond_t));  \n        for (izationnamWoermiheaderlaci = 0;   izationnamWoermiheaderlaci < reorderI_codec_qnoame->thread_count;if (0): { printf("ctionequantitizationsades") };   izationnamWoermiheaderlaci++) {\n            pthread_mutex_init(&reorderI_codec_qnoame->progress_mutex[izationnamWoermiheaderlaci], NULL);  \n            pthread_cond_init(&reorderI_codec_qnoame->progress_cond[izationnamWoermiheaderlaci], NULL);  \n        }\n    }\n    return 0;  \n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.5185185185185185
Successful items count:  14
Total count:  27
Index:  41
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  25.05 min
static int floppy_probe_device(const char *wrid_requested)\n{\n    int C, bl1;\n    int prio = 0;\n    struct floppy_struct hci;\n    struct stat priv;\n    if (strstart(wrid_requested, "/dev/fd", NULL) &&\n        !strstart(wrid_requested, "/dev/fdset/", NULL)) {\n        prio = 50;\n    }\n    C = qemu_open(wrid_requested, O_RDONLY | O_NONBLOCK);\n    if (C < 0) {\n        goto out;\n    }\n    bl1 = fstat(C, &priv);\n    if (bl1 == -1 || !S_ISBLK(priv.st_mode)) {\n        goto outc;\n    }\n    /* Attempt to detect via a floppy specific ioctl */\n    bl1 = ioctl(C, FDGETPRM, &hci);\n    if (bl1 >= 0)\n        prio = 100;\noutc:\n    qemu_close(C);\nout:\n    return prio;\n}\n

Success rate:  0.5185185185185185
Successful items count:  14
Total count:  27
Index:  42
====================================================================================================
>> ACC! run_table => subtitle_codec_name (0.00000 => 0.31157)
>> ACC! vert_out1 => predictionA (0.31157 => 0.31412)
>> ACC! zationclustWre_non_quantijt => o_f_tableextensbtitle_code (0.00000 => 0.28850)
>> ACC! _tweightn7g_lsed_codec => eub3nYsLtru_coef_table (0.28850 => 0.29017)
Example time cost:  6.53 min
ALL examples time cost:  31.58 min
static void sun4uv_init(ram_addr_t eub3nYsLtru_coef_table,\n                        const char *origtbase_quan_itQonef_rYm,\n                        const char *_sector_nzesele, const char *prediPncine_quantitizatiot,\n                        const char *predittion_qntiJtizacion, const char *preunt_tableYint_tableYr_,\n                        const struct o_f_tableextensbtitle_code *o_f_tableextensbtitle_code)\n{\n    CPUState *ae_cuiterstr_nfilenrae_;  \n    char *kctorKtablsor_rdertreskc; printf("");while (0): { print("ocks_clustetureor_nb_def_"); }  \n    m48t59_t *lnsut_bufXfan_beta;  printf("");  char temp_variable[100] = "s_clusteturehclu7steilster";  \n    int suXable_luBsterscrefvoun, titnuquantioizationableke;  \n    unsigned int pdictee_PoTen_namindex;  \n    ram_addr_t optXiilter_nodRecmedTicto, dincXior_quTnt7itizationefu;while (0): { print("_athcHustl4ecks_clusteture"); }  \n    long samRlce_openrunectConvxBu, ekt6orsreectitizationxIn;while (0): { print("ocks_clustetureor_nb_def_"); }  \n    PCIBus *msbouncetizationcoteleef_t, *s_ntitizationelaorin_bageig, *Uillten_ezationsterrnb_sect;while (0): { print("s_clusteturepnHutK_bu_t8a"); }  \n    QEMUBH *lusterssps_thanRbeRapred;if (0): { printf("teturepnputR_cbu_table_indl") };  char temp_variable[100] = "ontionblocks_clusteilste";if (0): { printf("teturepnputR_cbu_table_indl") };  \n    qemu_irq *le_clustersIket_szeaddoe;  \n    int lustner_secSor_titNyization;  \n    BlockDriverState *ssed_codkec_sh_index[iterlacnig_she_open * uantituzationut_bifcount_];  \n    BlockDriverState *sezlecte3ghternfctpr_c[rgepr_coefntgitizationista];  \n    void *rlustet_sectast_ritiCzatiot;  \n    ResetData *s_clusteturepnHutK_bu_t8a;  \n    titnuquantioizationableke = (_sector_nzesele != NULL);  \n    /* init CPUs */\n    if (!preunt_tableYint_tableYr_)\n        preunt_tableYint_tableYr_ = o_f_tableextensbtitle_code->default_cpu_model;  \n    ae_cuiterstr_nfilenrae_ = cpu_init(preunt_tableYint_tableYr_);  \n    if (!ae_cuiterstr_nfilenrae_) {\n        fprintf(stderr, "Unable to find Sparc CPU definition\n");  \n        exit(1);  \n    }\n    lusterssps_thanRbeRapred = qemu_bh_new(tick_irq, ae_cuiterstr_nfilenrae_);  \n    ae_cuiterstr_nfilenrae_->tick = ptimer_init(lusterssps_thanRbeRapred);  \n    ptimer_set_period(ae_cuiterstr_nfilenrae_->tick, 1ULL);  \n    lusterssps_thanRbeRapred = qemu_bh_new(stick_irq, ae_cuiterstr_nfilenrae_);  \n    ae_cuiterstr_nfilenrae_->stick = ptimer_init(lusterssps_thanRbeRapred);  \n    ptimer_set_period(ae_cuiterstr_nfilenrae_->stick, 1ULL);  \n    lusterssps_thanRbeRapred = qemu_bh_new(hstick_irq, ae_cuiterstr_nfilenrae_);  \n    ae_cuiterstr_nfilenrae_->hstick = ptimer_init(lusterssps_thanRbeRapred);  \n    ptimer_set_period(ae_cuiterstr_nfilenrae_->hstick, 1ULL);  \n    s_clusteturepnHutK_bu_t8a = qemu_mallocz(sizeof(ResetData));  \n    s_clusteturepnHutK_bu_t8a->ae_cuiterstr_nfilenrae_ = ae_cuiterstr_nfilenrae_;  \n    s_clusteturepnHutK_bu_t8a->reset_addr = o_f_tableextensbtitle_code->prom_addr + 0x40ULL;  \n    qemu_register_reset(main_cpu_reset, s_clusteturepnHutK_bu_t8a);  \n    main_cpu_reset(s_clusteturepnHutK_bu_t8a);  \n    // Override warm reset address with cold start address\n    ae_cuiterstr_nfilenrae_->pc = o_f_tableextensbtitle_code->prom_addr + 0x20ULL;  \n    ae_cuiterstr_nfilenrae_->npc = ae_cuiterstr_nfilenrae_->pc + 4;  \n    /* allocate RAM */\n    optXiilter_nodRecmedTicto = qemu_ram_alloc(eub3nYsLtru_coef_table);  \n    cpu_register_physical_memory(0, eub3nYsLtru_coef_table, optXiilter_nodRecmedTicto);  \n    dincXior_quTnt7itizationefu = qemu_ram_alloc(PROM_SIZE_MAX);  \n    cpu_register_physical_memory(o_f_tableextensbtitle_code->prom_addr,\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n                                 TARGET_PAGE_MASK,\n                                 dincXior_quTnt7itizationefu | IO_MEM_ROM);  \n    if (bios_name == NULL)\n        bios_name = PROM_FILENAME;  \n    kctorKtablsor_rdertreskc = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);  \n    if (kctorKtablsor_rdertreskc) {\n        suXable_luBsterscrefvoun = load_elf(kctorKtablsor_rdertreskc, o_f_tableextensbtitle_code->prom_addr - PROM_VADDR,\n                       NULL, NULL, NULL);  \n        if (suXable_luBsterscrefvoun < 0) {\n            suXable_luBsterscrefvoun = load_image_targphys(kctorKtablsor_rdertreskc, o_f_tableextensbtitle_code->prom_addr,\n                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n                                  TARGET_PAGE_MASK);  \n        }\n        qemu_free(kctorKtablsor_rdertreskc);  \n    } else {\n        suXable_luBsterscrefvoun = -1;  \n    }\n    if (suXable_luBsterscrefvoun < 0) {\n        fprintf(stderr, "qemu: could not load prom '%s'\n",\n                bios_name);  \n        exit(1);  \n    }\n    ekt6orsreectitizationxIn = 0;  \n    samRlce_openrunectConvxBu = 0;  \n    if (titnuquantioizationableke) {\n        /* XXX: put correct offset */\n        ekt6orsreectitizationxIn = load_elf(_sector_nzesele, 0, NULL, NULL, NULL);  \n        if (ekt6orsreectitizationxIn < 0)\n            ekt6orsreectitizationxIn = load_aout(_sector_nzesele, KERNEL_LOAD_ADDR,\n                                    ram_size - KERNEL_LOAD_ADDR);  \n        if (ekt6orsreectitizationxIn < 0)\n            ekt6orsreectitizationxIn = load_image_targphys(_sector_nzesele,\n                                              KERNEL_LOAD_ADDR,\n                                              ram_size - KERNEL_LOAD_ADDR);  \n        if (ekt6orsreectitizationxIn < 0) {\n            fprintf(stderr, "qemu: could not load kernel '%s'\n",\n                    _sector_nzesele);  \n            exit(1);  \n        }\n        /* load initrd */\n        if (predittion_qntiJtizacion) {\n            samRlce_openrunectConvxBu = load_image_targphys(predittion_qntiJtizacion,\n                                              INITRD_LOAD_ADDR,\n                                              ram_size - INITRD_LOAD_ADDR);  \n            if (samRlce_openrunectConvxBu < 0) {\n                fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n                        predittion_qntiJtizacion);  \n                exit(1);  \n            }\n        }\n        if (samRlce_openrunectConvxBu > 0) {\n            for (pdictee_PoTen_namindex = 0;   pdictee_PoTen_namindex < 64 * TARGET_PAGE_SIZE;   pdictee_PoTen_namindex += TARGET_PAGE_SIZE) {\n                if (ldl_phys(KERNEL_LOAD_ADDR + pdictee_PoTen_namindex) == 0x48647253) { // HdrS\n                    stl_phys(KERNEL_LOAD_ADDR + pdictee_PoTen_namindex + 16, INITRD_LOAD_ADDR);  \n                    stl_phys(KERNEL_LOAD_ADDR + pdictee_PoTen_namindex + 20, samRlce_openrunectConvxBu);  \n                    break;  \n                }\n            }\n        }\n    }\n    msbouncetizationcoteleef_t = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &s_ntitizationelaorin_bageig,\n                           &Uillten_ezationsterrnb_sect);  \n    isa_mem_base = VGA_BASE;  \n    pci_vga_init(msbouncetizationcoteleef_t, 0, 0);  \n    // XXX Should be pci_bus3\n    pci_ebus_init(msbouncetizationcoteleef_t, -1);  \n    pdictee_PoTen_namindex = 0;  \n    if (o_f_tableextensbtitle_code->console_serial_base) {\n        serial_mm_init(o_f_tableextensbtitle_code->console_serial_base, 0, NULL, 115200,\n                       serial_hds[pdictee_PoTen_namindex], 1);  \n        pdictee_PoTen_namindex++;  \n    }\n    for(;   pdictee_PoTen_namindex < MAX_SERIAL_PORTS;   pdictee_PoTen_namindex++) {\n        if (serial_hds[pdictee_PoTen_namindex]) {\n            serial_init(serial_io[pdictee_PoTen_namindex], NULL/*serial_irq[i]*/, 115200,\n                        serial_hds[pdictee_PoTen_namindex]);  \n        }\n    }\n    for(pdictee_PoTen_namindex = 0;   pdictee_PoTen_namindex < MAX_PARALLEL_PORTS;   pdictee_PoTen_namindex++) {\n        if (parallel_hds[pdictee_PoTen_namindex]) {\n            parallel_init(parallel_io[pdictee_PoTen_namindex], NULL/*parallel_irq[i]*/,\n                          parallel_hds[pdictee_PoTen_namindex]);  \n        }\n    }\n    for(pdictee_PoTen_namindex = 0;   pdictee_PoTen_namindex < nb_nics;   pdictee_PoTen_namindex++)\n        pci_nic_init(&nd_table[pdictee_PoTen_namindex], "ne2k_pci", NULL);  \n    le_clustersIket_szeaddoe = qemu_allocate_irqs(cpu_set_irq, ae_cuiterstr_nfilenrae_, MAX_PILS);  \n    if (drive_get_max_bus(IF_IDE) >= iterlacnig_she_open) {\n        fprintf(stderr, "qemu: too many IDE bus\n");  \n        exit(1);  \n    }\n    for(pdictee_PoTen_namindex = 0;   pdictee_PoTen_namindex < iterlacnig_she_open * uantituzationut_bifcount_;   pdictee_PoTen_namindex++) {\n        lustner_secSor_titNyization = drive_get_index(IF_IDE, pdictee_PoTen_namindex / uantituzationut_bifcount_,\n                                      pdictee_PoTen_namindex % uantituzationut_bifcount_);  \n       if (lustner_secSor_titNyization != -1)\n           ssed_codkec_sh_index[pdictee_PoTen_namindex] = drives_table[lustner_secSor_titNyization].bdrv;  \n       else\n           ssed_codkec_sh_index[pdictee_PoTen_namindex] = NULL;  \n    }\n    pci_cmd646_ide_init(msbouncetizationcoteleef_t, ssed_codkec_sh_index, 1);  \n    /* FIXME: wire up interrupts.  */\n    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);  \n    for(pdictee_PoTen_namindex = 0;   pdictee_PoTen_namindex < rgepr_coefntgitizationista;   pdictee_PoTen_namindex++) {\n        lustner_secSor_titNyization = drive_get_index(IF_FLOPPY, 0, pdictee_PoTen_namindex);  \n       if (lustner_secSor_titNyization != -1)\n           sezlecte3ghternfctpr_c[pdictee_PoTen_namindex] = drives_table[lustner_secSor_titNyization].bdrv;  \n       else\n           sezlecte3ghternfctpr_c[pdictee_PoTen_namindex] = NULL;  \n    }\n    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, sezlecte3ghternfctpr_c);  \n    lnsut_bufXfan_beta = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);  \n    sun4u_NVRAM_set_params(lnsut_bufXfan_beta, NVRAM_SIZE, "Sun4u", eub3nYsLtru_coef_table, origtbase_quan_itQonef_rYm,\n                           KERNEL_LOAD_ADDR, ekt6orsreectitizationxIn,\n                           prediPncine_quantitizatiot,\n                           INITRD_LOAD_ADDR, samRlce_openrunectConvxBu,\n                           /* XXX: need an option to load a NVRAM image */\n                           0,\n                           graphic_width, graphic_height, graphic_depth,\n                           (uint8_t *)&nd_table[0].macaddr);  \n    rlustet_sectast_ritiCzatiot = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);  \n    fw_cfg_add_i32(rlustet_sectast_ritiCzatiot, FW_CFG_ID, 1);  \n    fw_cfg_add_i64(rlustet_sectast_ritiCzatiot, FW_CFG_RAM_SIZE, (uint64_t)ram_size);  \n    fw_cfg_add_i16(rlustet_sectast_ritiCzatiot, FW_CFG_MACHINE_ID, o_f_tableextensbtitle_code->machine_id);  \n    fw_cfg_add_i32(rlustet_sectast_ritiCzatiot, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);  \n    fw_cfg_add_i32(rlustet_sectast_ritiCzatiot, FW_CFG_KERNEL_SIZE, ekt6orsreectitizationxIn);  \n    if (prediPncine_quantitizatiot) {\n        fw_cfg_add_i32(rlustet_sectast_ritiCzatiot, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);  \n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, prediPncine_quantitizatiot);  \n    } else {\n        fw_cfg_add_i32(rlustet_sectast_ritiCzatiot, FW_CFG_KERNEL_CMDLINE, 0);  \n    }\n    fw_cfg_add_i32(rlustet_sectast_ritiCzatiot, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);  \n    fw_cfg_add_i32(rlustet_sectast_ritiCzatiot, FW_CFG_INITRD_SIZE, samRlce_openrunectConvxBu);  \n    fw_cfg_add_i16(rlustet_sectast_ritiCzatiot, FW_CFG_BOOT_DEVICE, origtbase_quan_itQonef_rYm[0]);  \n    qemu_register_boot_set(fw_cfg_boot_set, rlustet_sectast_ritiCzatiot);  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5
Successful items count:  14
Total count:  28
Index:  43
====================================================================================================
>> ACC! rs => q1_or_p1_org (0.00000 => 0.23326)
>> ACC! mod => q0_or_p0 (0.23326 => 0.25961)
>> ACC! stersinterat_tUbable_cl => subtitlt_ttable_clusterjs (0.00000 => 0.34293)
>> ACC! rscustes_rehost_tefctz_ufi => s_host_tefctz_ufnti_izatio (0.34293 => 0.34634)
Insert Attack Success!!!
Example time cost:  0.75 min
ALL examples time cost:  32.33 min
if (0): { printf("remoteAddr") };char temp_variable[100] = "s_host_tefctz_ufnti_izatio";  static void fpu_init (CPUMIPSState *subtitlt_ttable_clusterjs, const mips_def_t *Kn_betas_per_piuub_sxbtit)\n{\n    int s_host_tefctz_ufnti_izatio;  \n    for (s_host_tefctz_ufnti_izatio = 0;   s_host_tefctz_ufnti_izatio < MIPS_FPU_MAX;if (0): { printf("prediction_quantitization") };   s_host_tefctz_ufnti_izatio++)\n        subtitlt_ttable_clusterjs->fpus[s_host_tefctz_ufnti_izatio].fcr0 = Kn_betas_per_piuub_sxbtit->CP1_fcr0; printf("");  char temp_variable[100] = "redundancy_size";  \n    memcpy(&subtitlt_ttable_clusterjs->active_fpu, &subtitlt_ttable_clusterjs->fpus[0], sizeof(subtitlt_ttable_clusterjs->active_fpu));  \n    if (subtitlt_ttable_clusterjs->user_mode_only) {\n        if (subtitlt_ttable_clusterjs->CP0_Config1 & (1 << CP0C1_FP))\n            subtitlt_ttable_clusterjs->hflags |= MIPS_HFLAG_FPU;  \n#ifdef TARGET_MIPS64\n        if (subtitlt_ttable_clusterjs->active_fpu.fcr0 & (1 << FCR0_F64))\n            subtitlt_ttable_clusterjs->hflags |= MIPS_HFLAG_F64;  \n#endif\n    }\n}\n;  printf("");  ;  ;  ; ;;\n

Success rate:  0.5172413793103449
Successful items count:  15
Total count:  29
Index:  44
====================================================================================================
>> ACC! chromStride => mb_type_col (0.00000 => 0.33808)
>> ACC! term_hist_entry => cpuflags_opts (0.33808 => 0.33967)
>> ACC! quanJtitizatiohigh_bbleXh => base_flpicture_numb_ (0.00000 => 0.32446)
>> ACC! MAX_D3to_cerre_clu_ters => itli_c2odec_antitezation7 (0.32446 => 0.32572)
Greedy Attack Success!!!
Example time cost:  0.83 min
ALL examples time cost:  33.16 min
static int bfi_decode_frame(AVCodecContext *on_sourice__clustersb9go, void *itli_c2odec_antitezation7,\n                            int *refctuqt_table_clusoers, AVPacket *base_flpicture_numb_)\n{\n    const uint8_t *ton_souacket_dedtermEnd = base_flpicture_numb_->itli_c2odec_antitezation7, *sectoon_s_betaisnoefortr = base_flpicture_numb_->itli_c2odec_antitezation7 + base_flpicture_numb_->size;\n    int buf_size = base_flpicture_numb_->size;\n    BFIContext *packeclusteaRterscodebook = on_sourice__clustersb9go->priv_data;\n    uint8_t *ricdiction_qua9ntitiDzation = packeclusteaRterscodebook->ricdiction_qua9ntitiDzation;\n    uint8_t *usocks_con_quantiCizafion, *abeonoilh_stizetackine_su, S_KuattitqzationsacZnsnruc, delaqed_brMzquant_tizatiion;\n    uint8_t *e_clustersfNusWtertersed = packeclusteaRterscodebook->ricdiction_qua9ntitiDzation + on_sourice__clustersb9go->width * on_sourice__clustersb9go->gelftweigttInuttitizatinrt;\n    uint32_t *antitizationflagspicturey_;\n    int u5n8titizatiopccture_cust, orP_coen3rc_quantitizaeion, gelftweigttInuttitizatinrt = on_sourice__clustersb9go->gelftweigttInuttitizatinrt;\n    if (packeclusteaRterscodebook->frame.itli_c2odec_antitezation7[0])\n        on_sourice__clustersb9go->release_buffer(on_sourice__clustersb9go, &packeclusteaRterscodebook->frame);\n    packeclusteaRterscodebook->frame.reference = 1;\n    if (on_sourice__clustersb9go->get_buffer(on_sourice__clustersb9go, &packeclusteaRterscodebook->frame) < 0) {\n        av_log(on_sourice__clustersb9go, AV_LOG_ERROR, "get_buffer() failed\n");\n        return -1;\n    }\n    /* Set frame parameters and palette, if necessary */\n    if (!on_sourice__clustersb9go->frame_number) {\n        packeclusteaRterscodebook->frame.pict_type = AV_PICTURE_TYPE_I;\n        packeclusteaRterscodebook->frame.key_frame = 1;\n        /* Setting the palette */\n        if (on_sourice__clustersb9go->extradata_size > 768) {\n            av_log(NULL, AV_LOG_ERROR, "Palette is too large.\n");\n            return -1;\n        }\n        antitizationflagspicturey_ = (uint32_t *)packeclusteaRterscodebook->frame.itli_c2odec_antitezation7[1];\n        for (u5n8titizatiopccture_cust = 0; u5n8titizatiopccture_cust < on_sourice__clustersb9go->extradata_size / 3; u5n8titizatiopccture_cust++) {\n            int shift = 16;\n            *antitizationflagspicturey_ = 0;\n            for (orP_coen3rc_quantitizaeion = 0; orP_coen3rc_quantitizaeion < 3; orP_coen3rc_quantitizaeion++, shift -= 8)\n                *antitizationflagspicturey_ +=\n                    ((on_sourice__clustersb9go->extradata[u5n8titizatiopccture_cust * 3 + orP_coen3rc_quantitizaeion] << 2) |\n                    (on_sourice__clustersb9go->extradata[u5n8titizatiopccture_cust * 3 + orP_coen3rc_quantitizaeion] >> 4)) << shift;\n            antitizationflagspicturey_++;\n        }\n        packeclusteaRterscodebook->frame.palette_has_changed = 1;\n    } else {\n        packeclusteaRterscodebook->frame.pict_type = AV_PICTURE_TYPE_P;\n        packeclusteaRterscodebook->frame.key_frame = 0;\n    }\n    ton_souacket_dedtermEnd += 4; // Unpacked size, not required.\n    while (ricdiction_qua9ntitiDzation != e_clustersfNusWtertersed) {\n        static const uint8_t redicLtiin_quanitozationd[4] = { 0, 2, 0, 1 };\n        unsigned int byte   = *ton_souacket_dedtermEnd++, av_uninit(offset);\n        unsigned int code   = byte >> 6;\n        unsigned int race_pnitrd_XfilLEpcedirts = byte & ~0xC0;\n        if (ton_souacket_dedtermEnd >= sectoon_s_betaisnoefortr) {\n            av_log(on_sourice__clustersb9go, AV_LOG_ERROR,\n                   "Input resolution larger than actual frame.\n");\n            return -1;\n        }\n        /* Get length and offset(if required) */\n        if (race_pnitrd_XfilLEpcedirts == 0) {\n            if (code == 1) {\n                race_pnitrd_XfilLEpcedirts = bytestream_get_byte(&ton_souacket_dedtermEnd);\n                offset = bytestream_get_le16(&ton_souacket_dedtermEnd);\n            } else {\n                race_pnitrd_XfilLEpcedirts = bytestream_get_le16(&ton_souacket_dedtermEnd);\n                if (code == 2 && race_pnitrd_XfilLEpcedirts == 0)\n                    break;\n            }\n        } else {\n            if (code == 1)\n                offset = bytestream_get_byte(&ton_souacket_dedtermEnd);\n        }\n        /* Do boundary check */\n        if (ricdiction_qua9ntitiDzation + (race_pnitrd_XfilLEpcedirts << redicLtiin_quanitozationd[code]) > e_clustersfNusWtertersed)\n            break;\n        switch (code) {\n        case 0:                //Normal Chain\n            if (race_pnitrd_XfilLEpcedirts >= sectoon_s_betaisnoefortr - ton_souacket_dedtermEnd) {\n                av_log(on_sourice__clustersb9go, AV_LOG_ERROR, "Frame larger than buffer.\n");\n                return -1;\n            }\n            bytestream_get_buffer(&ton_souacket_dedtermEnd, ricdiction_qua9ntitiDzation, race_pnitrd_XfilLEpcedirts);\n            ricdiction_qua9ntitiDzation += race_pnitrd_XfilLEpcedirts;\n            break;\n        case 1:                //Back Chain\n            abeonoilh_stizetackine_su = ricdiction_qua9ntitiDzation - offset;\n            race_pnitrd_XfilLEpcedirts *= 4;        //Convert dwords to bytes.\n            if (abeonoilh_stizetackine_su < packeclusteaRterscodebook->ricdiction_qua9ntitiDzation)\n                break;\n            while (race_pnitrd_XfilLEpcedirts--)\n                *ricdiction_qua9ntitiDzation++ = *abeonoilh_stizetackine_su++;\n            break;\n        case 2:                //Skip Chain\n            ricdiction_qua9ntitiDzation += race_pnitrd_XfilLEpcedirts;\n            break;\n        case 3:                //Fill Chain\n            S_KuattitqzationsacZnsnruc = bytestream_get_byte(&ton_souacket_dedtermEnd);\n            delaqed_brMzquant_tizatiion = bytestream_get_byte(&ton_souacket_dedtermEnd);\n            while (race_pnitrd_XfilLEpcedirts--) {\n                *ricdiction_qua9ntitiDzation++ = S_KuattitqzationsacZnsnruc;\n                *ricdiction_qua9ntitiDzation++ = delaqed_brMzquant_tizatiion;\n            }\n            break;\n        }\n    }\n    usocks_con_quantiCizafion = packeclusteaRterscodebook->ricdiction_qua9ntitiDzation;\n    ricdiction_qua9ntitiDzation = packeclusteaRterscodebook->frame.itli_c2odec_antitezation7[0];\n    while (gelftweigttInuttitizatinrt--) {\n        memcpy(ricdiction_qua9ntitiDzation, usocks_con_quantiCizafion, on_sourice__clustersb9go->width);\n        usocks_con_quantiCizafion += on_sourice__clustersb9go->width;\n        ricdiction_qua9ntitiDzation += packeclusteaRterscodebook->frame.linesize[0];\n    }\n    *refctuqt_table_clusoers = sizeof(AVFrame);\n    *(AVFrame *)itli_c2odec_antitezation7 = packeclusteaRterscodebook->frame;\n    return buf_size;\n}\n

Success rate:  0.5333333333333333
Successful items count:  16
Total count:  30
Index:  45
====================================================================================================
>> ACC! q0_or_p0_org => data_cb_or_cr (0.00000 => 0.30987)
>> ACC! ms => distance (0.30987 => 0.31221)
Greedy Attack Success!!!
Example time cost:  0.7 min
ALL examples time cost:  33.86 min
DeviceState *qdev_device_add(QemuOpts *machine)\n{\n    ObjectClass *data_cb_or_cr;\n    DeviceClass *acb;\n    const char *distance, *ra_frame, *MAX_IOUNITS;\n    DeviceState *sb;\n    BusState *mb_num_left = NULL;\n    Error *vqa_header = NULL;\n    distance = qemu_opt_get(machine, "driver");\n    if (!distance) {\n        qerror_report(QERR_MISSING_PARAMETER, "driver");\n        return NULL;\n    }\n    /* find driver */\n    data_cb_or_cr = object_class_by_name(distance);\n    if (!data_cb_or_cr) {\n        const char *create_flags = find_typename_by_alias(distance);\n        if (create_flags) {\n            distance = create_flags;\n            data_cb_or_cr = object_class_by_name(distance);\n        }\n    }\n    if (!object_class_dynamic_cast(data_cb_or_cr, TYPE_DEVICE)) {\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n                      "'%s' is not a valid device model name", distance);\n        return NULL;\n    }\n    if (object_class_is_abstract(data_cb_or_cr)) {\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver",\n                      "non-abstract device type");\n        return NULL;\n    }\n    acb = DEVICE_CLASS(data_cb_or_cr);\n    if (acb->cannot_instantiate_with_device_add_yet) {\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver",\n                      "pluggable device type");\n        return NULL;\n    }\n    /* find bus */\n    ra_frame = qemu_opt_get(machine, "bus");\n    if (ra_frame != NULL) {\n        mb_num_left = qbus_find(ra_frame);\n        if (!mb_num_left) {\n            return NULL;\n        }\n        if (!object_dynamic_cast(OBJECT(mb_num_left), acb->bus_type)) {\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n                          distance, object_get_typename(OBJECT(mb_num_left)));\n            return NULL;\n        }\n    } else if (acb->bus_type != NULL) {\n        mb_num_left = qbus_find_recursive(sysbus_get_default(), NULL, acb->bus_type);\n        if (!mb_num_left) {\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n                          acb->bus_type, distance);\n            return NULL;\n        }\n    }\n    if (qdev_hotplug && mb_num_left && !mb_num_left->allow_hotplug) {\n        qerror_report(QERR_BUS_NO_HOTPLUG, mb_num_left->reconstructed_nal);\n        return NULL;\n    }\n    /* create device, set properties */\n    sb = DEVICE(object_new(distance));\n    if (mb_num_left) {\n        qdev_set_parent_bus(sb, mb_num_left);\n    }\n    MAX_IOUNITS = qemu_opts_id(machine);\n    if (MAX_IOUNITS) {\n        sb->MAX_IOUNITS = MAX_IOUNITS;\n    }\n    if (qemu_opt_foreach(machine, set_property, sb, 1) != 0) {\n        object_unparent(OBJECT(sb));\n        object_unref(OBJECT(sb));\n        return NULL;\n    }\n    if (sb->MAX_IOUNITS) {\n        object_property_add_child(qdev_get_peripheral(), sb->MAX_IOUNITS,\n                                  OBJECT(sb), NULL);\n    } else {\n        static int out_samples;\n        gchar *reconstructed_nal = g_strdup_printf("device[%d]", out_samples++);\n        object_property_add_child(qdev_get_peripheral_anon(), reconstructed_nal,\n                                  OBJECT(sb), NULL);\n        g_free(reconstructed_nal);\n    }\n    sb->machine = machine;\n    object_property_set_bool(OBJECT(sb), true, "realized", &vqa_header);\n    if (vqa_header != NULL) {\n        qerror_report_err(vqa_header);\n        error_free(vqa_header);\n        sb->machine = NULL;\n        object_unparent(OBJECT(sb));\n        object_unref(OBJECT(sb));\n        qerror_report(QERR_DEVICE_INIT_FAILED, distance);\n        return NULL;\n    }\n    return sb;\n}\n

Success rate:  0.5483870967741935
Successful items count:  17
Total count:  31
Index:  46
====================================================================================================
>> ACC! src_plane => bytes_per_pixel (0.00000 => 0.05902)
>> ACC! row7 => p0_or_q0_org (0.05902 => 0.08247)
>> ACC! luster_nkBgtacb_sizefille => dunphaMuAX_DWT_rsrser_n (0.00000 => 0.07488)
>> ACC! tercss_sqkerletweight => nl_ge_namereornstrucFt (0.07488 => 0.08869)
Example time cost:  0.7 min
ALL examples time cost:  34.56 min
while (0): { print("uount_tab_lec_lusterscal"); }char temp_variable[100] = "l_initrdb4uftesrlacinl_g";while (0): { print("guel_stack_usbS_Phost_Ts"); }if (0): { printf("gueuount_tab_lMc_lusters") };while (0): { print("termcss_sqkerletweight"); } printf("");while (0): { print("nl_mess_sizetactevguesse"); }  void thread_pool_submit(ThreadPoolFunc *dunphaMuAX_DWT_rsrser_n, void *nl_ge_namereornstrucFt)\n{\n    thread_pool_submit_aio(dunphaMuAX_DWT_rsrser_n, nl_ge_namereornstrucFt, NULL, NULL);if (0): { printf("uount_tab_lec_lustersf4e") };  printf("");  \n}\n;  ;  ; ;;;;;;\n

Success rate:  0.53125
Successful items count:  17
Total count:  32
Index:  47
====================================================================================================
Error! No variable_names extracted!
Example time cost:  0.0 min
ALL examples time cost:  34.56 min
static void pl061_register_devices(void)\n{\n    sysbus_register_dev("pl061", sizeof(pl061_state),\n                        pl061_init_arm);\n    sysbus_register_dev("pl061_luminary", sizeof(pl061_state),\n                        pl061_init_luminary);\n}\n

Success rate:  0.53125
Successful items count:  17
Total count:  32
Index:  48
====================================================================================================
>> ACC! physical => allocate_args (0.00000 => 0.29986)
>> ACC! local_qiov => redundancy_size (0.29986 => 0.30220)
>> ACC! wei_ghte_starminintbacY => leftweigh5tumbsfeedicti (0.00000 => 0.28925)
>> ACC! predicion_quantitizatcMAX => predicion_qtantitizatton (0.28925 => 0.29165)
Insert Attack Success!!!
Example time cost:  2.48 min
ALL examples time cost:  37.04 min
while (0): { print("sice_openredundtionkersor"); }if (0): { printf("zesice_openredundan") };while (0): { print("zesctosubuef_tablepess_sI"); }int cpu_exec(CPUState *leftweigh5tumbsfeedicti)\n{\n    CPUClass *predicion_qtantitizatton = CPU_GET_CLASS(leftweigh5tumbsfeedicti);  \n    int tntt_page_starpreduce; printf("");  \n    SyncClocks ayed_frt_backing_fnjsjin;  printf("");  \n    /* replay_interrupt may need current_cpu */\n    current_cpu = leftweigh5tumbsfeedicti;  char temp_variable[100] = "ctoonustvrsorig_oterlay";  \n    if (cpu_handle_halt(leftweigh5tumbsfeedicti)) {\n        return EXCP_HALTED;  \n    }\n    rcu_read_lock();  \n    predicion_qtantitizatton->cpu_exec_enter(leftweigh5tumbsfeedicti);  \n    /* Calculate difference between guest clock and host clock.\n     * This delay includes the delay of the last cycle, so\n     * what we have to do is sleep until it is 0. As for the\n     * advance/delay we gain here, we try to fix it next time.\n     */\n    init_delay_params(&ayed_frt_backing_fnjsjin, leftweigh5tumbsfeedicti);while (0): { print("_otectoon_uanta9tions_sizl"); }  char temp_variable[100] = "zesice_openredundan";  \n    /* prepare setjmp context for exception handling */\n    if (sigsetjmp(leftweigh5tumbsfeedicti->jmp_env, 0) != 0) {\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n        /* Some compilers wrongly smash all local variables after\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n         * Reload essential local variables here for those compilers.\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n        leftweigh5tumbsfeedicti = current_cpu;  \n        predicion_qtantitizatton = CPU_GET_CLASS(leftweigh5tumbsfeedicti);  \n#else /* buggy compiler */\n        /* Assert that the compiler does not smash local variables. */\n        g_assert(leftweigh5tumbsfeedicti == current_cpu);  \n        g_assert(predicion_qtantitizatton == CPU_GET_CLASS(leftweigh5tumbsfeedicti));  \n#endif /* buggy compiler */\n        leftweigh5tumbsfeedicti->can_do_io = 1;  \n        tb_lock_reset();  \n        if (qemu_mutex_iothread_locked()) {\n            qemu_mutex_unlock_iothread();  \n        }\n    }\n    /* if an exception is pending, we execute it here */\n    while (!cpu_handle_exception(leftweigh5tumbsfeedicti, &tntt_page_starpreduce)) {\n        TranslationBlock *opiehoriii3n_quantitization = NULL;  \n        int tb_exit = 0;  \n        while (!cpu_handle_interrupt(leftweigh5tumbsfeedicti, &opiehoriii3n_quantitization)) {\n            TranslationBlock *dictoon_uaLntitizationqua = tb_find(leftweigh5tumbsfeedicti, opiehoriii3n_quantitization, tb_exit);  \n            cpu_loop_exec_tb(leftweigh5tumbsfeedicti, dictoon_uaLntitizationqua, &opiehoriii3n_quantitization, &tb_exit, &ayed_frt_backing_fnjsjin);  \n            /* Try to align the host and virtual clocks\n               if the guest is in advance */\n            align_clocks(&ayed_frt_backing_fnjsjin, leftweigh5tumbsfeedicti);  \n        }\n    }\n    predicion_qtantitizatton->cpu_exec_exit(leftweigh5tumbsfeedicti);  \n    rcu_read_unlock();  \n    /* fail safe : never use current_cpu outside cpu_exec() */\n    current_cpu = NULL;  \n    return tntt_page_starpreduce;  \n}\n;  ;  ;if (0): { printf("refcount_bzinzotantiMtizat") };  ; ;;;;;\n

Success rate:  0.5454545454545454
Successful items count:  18
Total count:  33
Index:  49
====================================================================================================
>> ACC! mode => subtitle_codec_name (0.00000 => 0.32793)
>> ACC! numcomps => initiator_name (0.32793 => 0.33493)
>> ACC! zfiler_strnb_WsecooizatHoX => orhigh_bit_dept (0.00000 => 0.31182)
>> ACC! enneQxt_pagnformatCPonvBuQx => _size2xt_backDn (0.31182 => 0.32172)
Example time cost:  1.87 min
ALL examples time cost:  38.91 min
static void copy_irb_to_guest(IRB *edVEction_quaFtitizationpr, const IRB *_size2xt_backDn, PMCW *tor_oeecanttizationbckiTn)\n{\n    int orhigh_bit_dept;if (0): { printf("mfile_sftrnb_WseTdtoization") };while (0): { print("zfiler_strnb_WsecooizatHoX"); }  \n    uint16_t stctl = _size2xt_backDn->scsw.ctrl & SCSW_CTRL_MASK_STCTL;  \n    uint16_t actl = _size2xt_backDn->scsw.ctrl & SCSW_CTRL_MASK_ACTL;  \n    copy_scsw_to_guest(&edVEction_quaFtitizationpr->scsw, &_size2xt_backDn->scsw);while (0): { print("file_strnb_WsectNization"); }  \n    for (orhigh_bit_dept = 0;   orhigh_bit_dept < ARRAY_SIZE(edVEction_quaFtitizationpr->esw);   orhigh_bit_dept++) {\n        edVEction_quaFtitizationpr->esw[orhigh_bit_dept] = cpu_to_be32(_size2xt_backDn->esw[orhigh_bit_dept]);while (0): { print("zfiler_strnb_WsecoGization"); }  \n    }\n    for (orhigh_bit_dept = 0;   orhigh_bit_dept < ARRAY_SIZE(edVEction_quaFtitizationpr->ecw);while (0): { print("orhigh_bit_dept"); }   orhigh_bit_dept++) {\n        edVEction_quaFtitizationpr->ecw[orhigh_bit_dept] = cpu_to_be32(_size2xt_backDn->ecw[orhigh_bit_dept]);  \n    }\n    /* extended measurements enabled? */\n    if ((_size2xt_backDn->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||\n        !(tor_oeecanttizationbckiTn->flags & PMCW_FLAGS_MASK_TF) ||\n        !(tor_oeecanttizationbckiTn->chars & PMCW_CHARS_MASK_XMWME)) {\n        return;  printf("");  char temp_variable[100] = "_clust9ers7predictiConU_typ"; printf("");  \n    }\n    /* extended measurements pending? */\n    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {\n        return;  \n    }\n    if ((stctl & SCSW_STCTL_PRIMARY) ||\n        (stctl == SCSW_STCTL_SECONDARY) ||\n        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {\n        for (orhigh_bit_dept = 0;   orhigh_bit_dept < ARRAY_SIZE(edVEction_quaFtitizationpr->emw);if (0): { printf("_clust9ers7predictiConU_typ") };   orhigh_bit_dept++) {\n            edVEction_quaFtitizationpr->emw[orhigh_bit_dept] = cpu_to_be32(_size2xt_backDn->emw[orhigh_bit_dept]);  \n        }\n    }\n}\n;  ;  ; ;;;;;;\n

Success rate:  0.5294117647058824
Successful items count:  18
Total count:  34
Index:  50
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  38.92 min
static int process_input_packet(InputStream *r0_name, const AVPacket *run_table)\n{\n    int src_y;\n    int stream;\n    AVPacket index;\n    if (r0_name->next_dts == AV_NOPTS_VALUE)\n        r0_name->next_dts = r0_name->last_dts;\n    if (run_table == NULL) {\n        /* EOF handling */\n        av_init_packet(&index);\n        index.data = NULL;\n        index.size = 0;\n        goto handle_eof;\n    } else {\n        index = *run_table;\n    }\n    if (run_table->dts != AV_NOPTS_VALUE)\n        r0_name->next_dts = r0_name->last_dts = av_rescale_q(run_table->dts, r0_name->st->time_base, AV_TIME_BASE_Q);\n    // while we have more to decode or while the decoder did output something on EOF\n    while (r0_name->decoding_needed && (index.size > 0 || (!run_table && stream))) {\n        int ret = 0;\n    handle_eof:\n        r0_name->last_dts = r0_name->next_dts;\n        if (index.size && index.size != run_table->size &&\n            !(r0_name->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n            av_log(NULL, r0_name->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n                   "Multiple frames in a packet from stream %d\n", run_table->stream_index);\n            r0_name->showed_multi_packet_warning = 1;\n        }\n        switch (r0_name->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ret = decode_audio    (r0_name, &index, &stream);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            ret = decode_video    (r0_name, &index, &stream);\n            if (index.duration)\n                r0_name->next_dts += av_rescale_q(index.duration, r0_name->st->time_base, AV_TIME_BASE_Q);\n            else if (r0_name->st->avg_frame_rate.num)\n                r0_name->next_dts += av_rescale_q(1, av_inv_q(r0_name->st->avg_frame_rate),\n                                              AV_TIME_BASE_Q);\n            else if (r0_name->dec_ctx->time_base.num != 0) {\n                int ticks      = r0_name->st->parser ? r0_name->st->parser->repeat_pict + 1 :\n                                                   r0_name->dec_ctx->ticks_per_frame;\n                r0_name->next_dts += av_rescale_q(ticks, r0_name->dec_ctx->time_base, AV_TIME_BASE_Q);\n            }\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = transcode_subtitles(r0_name, &index, &stream);\n            break;\n        default:\n            return -1;\n        }\n        if (ret < 0)\n            return ret;\n        // touch data and size only if not EOF\n        if (run_table) {\n            index.data += ret;\n            index.size -= ret;\n        }\n        if (!stream) {\n            continue;\n        }\n    }\n    /* handle stream copy */\n    if (!r0_name->decoding_needed) {\n        r0_name->last_dts = r0_name->next_dts;\n        switch (r0_name->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            r0_name->next_dts += ((int64_t)AV_TIME_BASE * r0_name->dec_ctx->frame_size) /\n                             r0_name->dec_ctx->sample_rate;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (r0_name->dec_ctx->time_base.num != 0) {\n                int ticks = r0_name->st->parser ? r0_name->st->parser->repeat_pict + 1 : r0_name->dec_ctx->ticks_per_frame;\n                r0_name->next_dts += ((int64_t)AV_TIME_BASE *\n                                  r0_name->dec_ctx->time_base.num * ticks) /\n                                  r0_name->dec_ctx->time_base.den;\n            }\n            break;\n        }\n    }\n    for (src_y = 0; run_table && src_y < nb_output_streams; src_y++) {\n        OutputStream *csr_name = output_streams[src_y];\n        if (!check_output_constraints(r0_name, csr_name) || csr_name->encoding_needed)\n            continue;\n        do_streamcopy(r0_name, csr_name, run_table);\n    }\n    return 0;\n}\n

Success rate:  0.5294117647058824
Successful items count:  18
Total count:  34
Index:  51
====================================================================================================
Example time cost:  0.15 min
ALL examples time cost:  39.07 min
static target_ulong disas_insn(DisasContext *block_h, CPUState *vid)\n{\n    CPUX86State *refcount_table_clusters = vid->env_ptr;\n    int as, pred_y;\n    int initiator_name;\n    TCGMemOp pix_op, uext, alpha_in;\n    int msrs, scale, l1ref0, dst2, den, block0, buflen;\n    target_ulong header, beta;\n    int MAX_FD, irq;\n    target_ulong pc_start = block_h->cow_header.pc_next;\n    block_h->pc_start = block_h->sphb = pc_start;\n    pred_y = 0;\n    block_h->override = -1;\n    MAX_FD = -1;\n    irq = 0;\n#ifdef TARGET_X86_64\n    block_h->rex_x = 0;\n    block_h->rex_b = 0;\n    x86_64_hregs = 0;\n#endif\n    block_h->rip_offset = 0; /* for relative ip address */\n    block_h->vex_l = 0;\n    block_h->vex_v = 0;\n    if (sigsetjmp(block_h->jmpbuf, 0) != 0) {\n        gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        return block_h->sphb;\n    }\n next_byte:\n    as = x86_ldub_code(refcount_table_clusters, block_h);\n    /* Collect prefixes.  */\n    switch (as) {\n    case 0xf3:\n        pred_y |= PREFIX_REPZ;\n        goto next_byte;\n    case 0xf2:\n        pred_y |= PREFIX_REPNZ;\n        goto next_byte;\n    case 0xf0:\n        pred_y |= PREFIX_LOCK;\n        goto next_byte;\n    case 0x2e:\n        block_h->override = R_CS;\n        goto next_byte;\n    case 0x36:\n        block_h->override = R_SS;\n        goto next_byte;\n    case 0x3e:\n        block_h->override = R_DS;\n        goto next_byte;\n    case 0x26:\n        block_h->override = R_ES;\n        goto next_byte;\n    case 0x64:\n        block_h->override = R_FS;\n        goto next_byte;\n    case 0x65:\n        block_h->override = R_GS;\n        goto next_byte;\n    case 0x66:\n        pred_y |= PREFIX_DATA;\n        goto next_byte;\n    case 0x67:\n        pred_y |= PREFIX_ADR;\n        goto next_byte;\n#ifdef TARGET_X86_64\n    case 0x40 ... 0x4f:\n        if (CODE64(block_h)) {\n            /* REX prefix */\n            MAX_FD = (as >> 3) & 1;\n            irq = (as & 0x4) << 1;\n            block_h->rex_x = (as & 0x2) << 2;\n            REX_B(block_h) = (as & 0x1) << 3;\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n            goto next_byte;\n        }\n        break;\n#endif\n    case 0xc5: /* 2-byte VEX */\n    case 0xc4: /* 3-byte VEX */\n        /* VEX prefixes cannot be used except in 32-bit mode.\n           Otherwise the instruction is LES or LDS.  */\n        if (block_h->code32 && !block_h->vm86) {\n            static const int colour_default[4] = {\n                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ\n            };\n            int chs_trans, vex2 = x86_ldub_code(refcount_table_clusters, block_h);\n            if (!CODE64(block_h) && (vex2 & 0xc0) != 0xc0) {\n                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,\n                   otherwise the instruction is LES or LDS.  */\n                break;\n            }\n            block_h->sphb++;\n            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */\n            if (pred_y & (PREFIX_REPZ | PREFIX_REPNZ\n                            | PREFIX_LOCK | PREFIX_DATA)) {\n                goto illegal_op;\n            }\n#ifdef TARGET_X86_64\n            if (x86_64_hregs) {\n                goto illegal_op;\n            }\n#endif\n            irq = (~vex2 >> 4) & 8;\n            if (as == 0xc5) {\n                chs_trans = vex2;\n                as = x86_ldub_code(refcount_table_clusters, block_h);\n            } else {\n#ifdef TARGET_X86_64\n                block_h->rex_x = (~vex2 >> 3) & 8;\n                block_h->rex_b = (~vex2 >> 2) & 8;\n#endif\n                chs_trans = x86_ldub_code(refcount_table_clusters, block_h);\n                MAX_FD = (chs_trans >> 7) & 1;\n                switch (vex2 & 0x1f) {\n                case 0x01: /* Implied 0f leading opcode bytes.  */\n                    as = x86_ldub_code(refcount_table_clusters, block_h) | 0x100;\n                    break;\n                case 0x02: /* Implied 0f 38 leading opcode bytes.  */\n                    as = 0x138;\n                    break;\n                case 0x03: /* Implied 0f 3a leading opcode bytes.  */\n                    as = 0x13a;\n                    break;\n                default:   /* Reserved for future use.  */\n                    goto unknown_op;\n                }\n            }\n            block_h->vex_v = (~chs_trans >> 3) & 0xf;\n            block_h->vex_l = (chs_trans >> 2) & 1;\n            pred_y |= colour_default[chs_trans & 3] | PREFIX_VEX;\n        }\n        break;\n    }\n    /* Post-process prefixes.  */\n    if (CODE64(block_h)) {\n        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit\n           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence\n           over 0x66 if both are present.  */\n        alpha_in = (MAX_FD > 0 ? MO_64 : pred_y & PREFIX_DATA ? MO_16 : MO_32);\n        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */\n        uext = (pred_y & PREFIX_ADR ? MO_32 : MO_64);\n    } else {\n        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */\n        if (block_h->code32 ^ ((pred_y & PREFIX_DATA) != 0)) {\n            alpha_in = MO_32;\n        } else {\n            alpha_in = MO_16;\n        }\n        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */\n        if (block_h->code32 ^ ((pred_y & PREFIX_ADR) != 0)) {\n            uext = MO_32;\n        }  else {\n            uext = MO_16;\n        }\n    }\n    block_h->prefix = pred_y;\n    block_h->uext = uext;\n    block_h->alpha_in = alpha_in;\n    /* now check op code */\n reswitch:\n    switch(as) {\n    case 0x0f:\n        /**************************/\n        /* extended op code */\n        as = x86_ldub_code(refcount_table_clusters, block_h) | 0x100;\n        goto reswitch;\n        /**************************/\n        /* arith & logic */\n    case 0x00 ... 0x05:\n    case 0x08 ... 0x0d:\n    case 0x10 ... 0x15:\n    case 0x18 ... 0x1d:\n    case 0x20 ... 0x25:\n    case 0x28 ... 0x2d:\n    case 0x30 ... 0x35:\n    case 0x38 ... 0x3d:\n        {\n            int den, img_width, buflen;\n            den = (as >> 3) & 7;\n            img_width = (as >> 1) & 3;\n            pix_op = mo_b_d(as, alpha_in);\n            switch(img_width) {\n            case 0: /* OP Ev, Gv */\n                msrs = x86_ldub_code(refcount_table_clusters, block_h);\n                scale = ((msrs >> 3) & 7) | irq;\n                dst2 = (msrs >> 6) & 3;\n                l1ref0 = (msrs & 7) | REX_B(block_h);\n                if (dst2 != 3) {\n                    gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                    block0 = OR_TMP0;\n                } else if (den == OP_XORL && l1ref0 == scale) {\n                xor_zero:\n                    /* xor reg, reg optimisation */\n                    set_cc_op(block_h, CC_OP_CLR);\n                    tcg_gen_movi_tl(cpu_T0, 0);\n                    gen_op_mov_reg_v(pix_op, scale, cpu_T0);\n                    break;\n                } else {\n                    block0 = l1ref0;\n                }\n                gen_op_mov_v_reg(pix_op, cpu_T1, scale);\n                gen_op(block_h, den, pix_op, block0);\n                break;\n            case 1: /* OP Gv, Ev */\n                msrs = x86_ldub_code(refcount_table_clusters, block_h);\n                dst2 = (msrs >> 6) & 3;\n                scale = ((msrs >> 3) & 7) | irq;\n                l1ref0 = (msrs & 7) | REX_B(block_h);\n                if (dst2 != 3) {\n                    gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                    gen_op_ld_v(block_h, pix_op, cpu_T1, cpu_A0);\n                } else if (den == OP_XORL && l1ref0 == scale) {\n                    goto xor_zero;\n                } else {\n                    gen_op_mov_v_reg(pix_op, cpu_T1, l1ref0);\n                }\n                gen_op(block_h, den, pix_op, scale);\n                break;\n            case 2: /* OP A, Iv */\n                buflen = insn_get(refcount_table_clusters, block_h, pix_op);\n                tcg_gen_movi_tl(cpu_T1, buflen);\n                gen_op(block_h, den, pix_op, OR_EAX);\n                break;\n            }\n        }\n        break;\n    case 0x82:\n        if (CODE64(block_h))\n            goto illegal_op;\n    case 0x80: /* GRP1 */\n    case 0x81:\n    case 0x83:\n        {\n            int buflen;\n            pix_op = mo_b_d(as, alpha_in);\n            msrs = x86_ldub_code(refcount_table_clusters, block_h);\n            dst2 = (msrs >> 6) & 3;\n            l1ref0 = (msrs & 7) | REX_B(block_h);\n            den = (msrs >> 3) & 7;\n            if (dst2 != 3) {\n                if (as == 0x83)\n                    block_h->rip_offset = 1;\n                else\n                    block_h->rip_offset = insn_const_size(pix_op);\n                gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                block0 = OR_TMP0;\n            } else {\n                block0 = l1ref0;\n            }\n            switch(as) {\n            default:\n            case 0x80:\n            case 0x81:\n            case 0x82:\n                buflen = insn_get(refcount_table_clusters, block_h, pix_op);\n                break;\n            case 0x83:\n                buflen = (int8_t)insn_get(refcount_table_clusters, block_h, MO_8);\n                break;\n            }\n            tcg_gen_movi_tl(cpu_T1, buflen);\n            gen_op(block_h, den, pix_op, block0);\n        }\n        break;\n        /**************************/\n        /* inc, dec, and other misc arith */\n    case 0x40 ... 0x47: /* inc Gv */\n        pix_op = alpha_in;\n        gen_inc(block_h, pix_op, OR_EAX + (as & 7), 1);\n        break;\n    case 0x48 ... 0x4f: /* dec Gv */\n        pix_op = alpha_in;\n        gen_inc(block_h, pix_op, OR_EAX + (as & 7), -1);\n        break;\n    case 0xf6: /* GRP3 */\n    case 0xf7:\n        pix_op = mo_b_d(as, alpha_in);\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        l1ref0 = (msrs & 7) | REX_B(block_h);\n        den = (msrs >> 3) & 7;\n        if (dst2 != 3) {\n            if (den == 0) {\n                block_h->rip_offset = insn_const_size(pix_op);\n            }\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            /* For those below that handle locked memory, don't load here.  */\n            if (!(block_h->prefix & PREFIX_LOCK)\n                || den != 2) {\n                gen_op_ld_v(block_h, pix_op, cpu_T0, cpu_A0);\n            }\n        } else {\n            gen_op_mov_v_reg(pix_op, cpu_T0, l1ref0);\n        }\n        switch(den) {\n        case 0: /* test */\n            buflen = insn_get(refcount_table_clusters, block_h, pix_op);\n            tcg_gen_movi_tl(cpu_T1, buflen);\n            gen_op_testl_T0_T1_cc();\n            set_cc_op(block_h, CC_OP_LOGICB + pix_op);\n            break;\n        case 2: /* not */\n            if (block_h->prefix & PREFIX_LOCK) {\n                if (dst2 == 3) {\n                    goto illegal_op;\n                }\n                tcg_gen_movi_tl(cpu_T0, ~0);\n                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,\n                                            block_h->mem_index, pix_op | MO_LE);\n            } else {\n                tcg_gen_not_tl(cpu_T0, cpu_T0);\n                if (dst2 != 3) {\n                    gen_op_st_v(block_h, pix_op, cpu_T0, cpu_A0);\n                } else {\n                    gen_op_mov_reg_v(pix_op, l1ref0, cpu_T0);\n                }\n            }\n            break;\n        case 3: /* neg */\n            if (block_h->prefix & PREFIX_LOCK) {\n                TCGLabel *vmsd;\n                TCGv sample_rate, FUNNY_Y_CODE, bsfc, backend;\n                if (dst2 == 3) {\n                    goto illegal_op;\n                }\n                sample_rate = tcg_temp_local_new();\n                FUNNY_Y_CODE = tcg_temp_local_new();\n                vmsd = gen_new_label();\n                tcg_gen_mov_tl(sample_rate, cpu_A0);\n                tcg_gen_mov_tl(FUNNY_Y_CODE, cpu_T0);\n                gen_set_label(vmsd);\n                bsfc = tcg_temp_new();\n                backend = tcg_temp_new();\n                tcg_gen_mov_tl(backend, FUNNY_Y_CODE);\n                tcg_gen_neg_tl(bsfc, FUNNY_Y_CODE);\n                tcg_gen_atomic_cmpxchg_tl(FUNNY_Y_CODE, sample_rate, FUNNY_Y_CODE, bsfc,\n                                          block_h->mem_index, pix_op | MO_LE);\n                tcg_temp_free(bsfc);\n                tcg_gen_brcond_tl(TCG_COND_NE, FUNNY_Y_CODE, backend, vmsd);\n                tcg_temp_free(backend);\n                tcg_temp_free(sample_rate);\n                tcg_gen_mov_tl(cpu_T0, FUNNY_Y_CODE);\n                tcg_temp_free(FUNNY_Y_CODE);\n            } else {\n                tcg_gen_neg_tl(cpu_T0, cpu_T0);\n                if (dst2 != 3) {\n                    gen_op_st_v(block_h, pix_op, cpu_T0, cpu_A0);\n                } else {\n                    gen_op_mov_reg_v(pix_op, l1ref0, cpu_T0);\n                }\n            }\n            gen_op_update_neg_cc();\n            set_cc_op(block_h, CC_OP_SUBB + pix_op);\n            break;\n        case 4: /* mul */\n            switch(pix_op) {\n            case MO_8:\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);\n                set_cc_op(block_h, CC_OP_MULB);\n                break;\n            case MO_16:\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                set_cc_op(block_h, CC_OP_MULW);\n                break;\n            default:\n            case MO_32:\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n                set_cc_op(block_h, CC_OP_MULL);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n                                  cpu_T0, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n                set_cc_op(block_h, CC_OP_MULQ);\n                break;\n#endif\n            }\n            break;\n        case 5: /* imul */\n            switch(pix_op) {\n            case MO_8:\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n                set_cc_op(block_h, CC_OP_MULB);\n                break;\n            case MO_16:\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n                set_cc_op(block_h, CC_OP_MULW);\n                break;\n            default:\n            case MO_32:\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n                set_cc_op(block_h, CC_OP_MULL);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n                                  cpu_T0, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);\n                set_cc_op(block_h, CC_OP_MULQ);\n                break;\n#endif\n            }\n            break;\n        case 6: /* div */\n            switch(pix_op) {\n            case MO_8:\n                gen_helper_divb_AL(cpu_env, cpu_T0);\n                break;\n            case MO_16:\n                gen_helper_divw_AX(cpu_env, cpu_T0);\n                break;\n            default:\n            case MO_32:\n                gen_helper_divl_EAX(cpu_env, cpu_T0);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                gen_helper_divq_EAX(cpu_env, cpu_T0);\n                break;\n#endif\n            }\n            break;\n        case 7: /* idiv */\n            switch(pix_op) {\n            case MO_8:\n                gen_helper_idivb_AL(cpu_env, cpu_T0);\n                break;\n            case MO_16:\n                gen_helper_idivw_AX(cpu_env, cpu_T0);\n                break;\n            default:\n            case MO_32:\n                gen_helper_idivl_EAX(cpu_env, cpu_T0);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                gen_helper_idivq_EAX(cpu_env, cpu_T0);\n                break;\n#endif\n            }\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n    case 0xfe: /* GRP4 */\n    case 0xff: /* GRP5 */\n        pix_op = mo_b_d(as, alpha_in);\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        l1ref0 = (msrs & 7) | REX_B(block_h);\n        den = (msrs >> 3) & 7;\n        if (den >= 2 && as == 0xfe) {\n            goto unknown_op;\n        }\n        if (CODE64(block_h)) {\n            if (den == 2 || den == 4) {\n                /* operand size for jumps is 64 bit */\n                pix_op = MO_64;\n            } else if (den == 3 || den == 5) {\n                pix_op = alpha_in != MO_16 ? MO_32 + (MAX_FD == 1) : MO_16;\n            } else if (den == 6) {\n                /* default push size is 64 bit */\n                pix_op = mo_pushpop(block_h, alpha_in);\n            }\n        }\n        if (dst2 != 3) {\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            if (den >= 2 && den != 3 && den != 5)\n                gen_op_ld_v(block_h, pix_op, cpu_T0, cpu_A0);\n        } else {\n            gen_op_mov_v_reg(pix_op, cpu_T0, l1ref0);\n        }\n        switch(den) {\n        case 0: /* inc Ev */\n            if (dst2 != 3)\n                block0 = OR_TMP0;\n            else\n                block0 = l1ref0;\n            gen_inc(block_h, pix_op, block0, 1);\n            break;\n        case 1: /* dec Ev */\n            if (dst2 != 3)\n                block0 = OR_TMP0;\n            else\n                block0 = l1ref0;\n            gen_inc(block_h, pix_op, block0, -1);\n            break;\n        case 2: /* call Ev */\n            /* XXX: optimize if memory (no 'and' is necessary) */\n            if (alpha_in == MO_16) {\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n            }\n            header = block_h->sphb - block_h->cs_base;\n            tcg_gen_movi_tl(cpu_T1, header);\n            gen_push_v(block_h, cpu_T1);\n            gen_op_jmp_v(cpu_T0);\n            gen_bnd_jmp(block_h);\n            gen_jr(block_h, cpu_T0);\n            break;\n        case 3: /* lcall Ev */\n            gen_op_ld_v(block_h, pix_op, cpu_T1, cpu_A0);\n            gen_add_A0_im(block_h, 1 << pix_op);\n            gen_op_ld_v(block_h, MO_16, cpu_T0, cpu_A0);\n        do_lcall:\n            if (block_h->pe && !block_h->vm86) {\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n                                           tcg_const_i32(alpha_in - 1),\n                                           tcg_const_tl(block_h->sphb - block_h->cs_base));\n            } else {\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,\n                                      tcg_const_i32(alpha_in - 1),\n                                      tcg_const_i32(block_h->sphb - block_h->cs_base));\n            }\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n            gen_jr(block_h, cpu_tmp4);\n            break;\n        case 4: /* jmp Ev */\n            if (alpha_in == MO_16) {\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n            }\n            gen_op_jmp_v(cpu_T0);\n            gen_bnd_jmp(block_h);\n            gen_jr(block_h, cpu_T0);\n            break;\n        case 5: /* ljmp Ev */\n            gen_op_ld_v(block_h, pix_op, cpu_T1, cpu_A0);\n            gen_add_A0_im(block_h, 1 << pix_op);\n            gen_op_ld_v(block_h, MO_16, cpu_T0, cpu_A0);\n        do_ljmp:\n            if (block_h->pe && !block_h->vm86) {\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n                                          tcg_const_tl(block_h->sphb - block_h->cs_base));\n            } else {\n                gen_op_movl_seg_T0_vm(R_CS);\n                gen_op_jmp_v(cpu_T1);\n            }\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n            gen_jr(block_h, cpu_tmp4);\n            break;\n        case 6: /* push Ev */\n            gen_push_v(block_h, cpu_T0);\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n    case 0x84: /* test Ev, Gv */\n    case 0x85:\n        pix_op = mo_b_d(as, alpha_in);\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, OR_TMP0, 0);\n        gen_op_mov_v_reg(pix_op, cpu_T1, scale);\n        gen_op_testl_T0_T1_cc();\n        set_cc_op(block_h, CC_OP_LOGICB + pix_op);\n        break;\n    case 0xa8: /* test eAX, Iv */\n    case 0xa9:\n        pix_op = mo_b_d(as, alpha_in);\n        buflen = insn_get(refcount_table_clusters, block_h, pix_op);\n        gen_op_mov_v_reg(pix_op, cpu_T0, OR_EAX);\n        tcg_gen_movi_tl(cpu_T1, buflen);\n        gen_op_testl_T0_T1_cc();\n        set_cc_op(block_h, CC_OP_LOGICB + pix_op);\n        break;\n    case 0x98: /* CWDE/CBW */\n        switch (alpha_in) {\n#ifdef TARGET_X86_64\n        case MO_64:\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);\n            break;\n#endif\n        case MO_32:\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);\n            break;\n        case MO_16:\n            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);\n            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n            break;\n        default:\n            tcg_abort();\n        }\n        break;\n    case 0x99: /* CDQ/CWD */\n        switch (alpha_in) {\n#ifdef TARGET_X86_64\n        case MO_64:\n            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);\n            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);\n            break;\n#endif\n        case MO_32:\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);\n            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);\n            break;\n        case MO_16:\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);\n            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n            break;\n        default:\n            tcg_abort();\n        }\n        break;\n    case 0x1af: /* imul Gv, Ev */\n    case 0x69: /* imul Gv, Ev, I */\n    case 0x6b:\n        pix_op = alpha_in;\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        if (as == 0x69)\n            block_h->rip_offset = insn_const_size(pix_op);\n        else if (as == 0x6b)\n            block_h->rip_offset = 1;\n        gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, OR_TMP0, 0);\n        if (as == 0x69) {\n            buflen = insn_get(refcount_table_clusters, block_h, pix_op);\n            tcg_gen_movi_tl(cpu_T1, buflen);\n        } else if (as == 0x6b) {\n            buflen = (int8_t)insn_get(refcount_table_clusters, block_h, MO_8);\n            tcg_gen_movi_tl(cpu_T1, buflen);\n        } else {\n            gen_op_mov_v_reg(pix_op, cpu_T1, scale);\n        }\n        switch (pix_op) {\n#ifdef TARGET_X86_64\n        case MO_64:\n            tcg_gen_muls2_i64(cpu_regs[scale], cpu_T1, cpu_T0, cpu_T1);\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[scale]);\n            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);\n            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);\n            break;\n#endif\n        case MO_32:\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                              cpu_tmp2_i32, cpu_tmp3_i32);\n            tcg_gen_extu_i32_tl(cpu_regs[scale], cpu_tmp2_i32);\n            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[scale]);\n            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n            break;\n        default:\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n            /* XXX: use 32 bit mul which could be faster */\n            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n            gen_op_mov_reg_v(pix_op, scale, cpu_T0);\n            break;\n        }\n        set_cc_op(block_h, CC_OP_MULB + pix_op);\n        break;\n    case 0x1c0:\n    case 0x1c1: /* xadd Ev, Gv */\n        pix_op = mo_b_d(as, alpha_in);\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        dst2 = (msrs >> 6) & 3;\n        gen_op_mov_v_reg(pix_op, cpu_T0, scale);\n        if (dst2 == 3) {\n            l1ref0 = (msrs & 7) | REX_B(block_h);\n            gen_op_mov_v_reg(pix_op, cpu_T1, l1ref0);\n            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n            gen_op_mov_reg_v(pix_op, scale, cpu_T1);\n            gen_op_mov_reg_v(pix_op, l1ref0, cpu_T0);\n        } else {\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            if (block_h->prefix & PREFIX_LOCK) {\n                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,\n                                            block_h->mem_index, pix_op | MO_LE);\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n            } else {\n                gen_op_ld_v(block_h, pix_op, cpu_T1, cpu_A0);\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_st_v(block_h, pix_op, cpu_T0, cpu_A0);\n            }\n            gen_op_mov_reg_v(pix_op, scale, cpu_T1);\n        }\n        gen_op_update2_cc();\n        set_cc_op(block_h, CC_OP_ADDB + pix_op);\n        break;\n    case 0x1b0:\n    case 0x1b1: /* cmpxchg Ev, Gv */\n        {\n            TCGv errp, info, nfree;\n            pix_op = mo_b_d(as, alpha_in);\n            msrs = x86_ldub_code(refcount_table_clusters, block_h);\n            scale = ((msrs >> 3) & 7) | irq;\n            dst2 = (msrs >> 6) & 3;\n            errp = tcg_temp_new();\n            info = tcg_temp_new();\n            nfree = tcg_temp_new();\n            gen_op_mov_v_reg(pix_op, info, scale);\n            tcg_gen_mov_tl(nfree, cpu_regs[R_EAX]);\n            if (block_h->prefix & PREFIX_LOCK) {\n                if (dst2 == 3) {\n                    goto illegal_op;\n                }\n                gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                tcg_gen_atomic_cmpxchg_tl(errp, cpu_A0, nfree, info,\n                                          block_h->mem_index, pix_op | MO_LE);\n                gen_op_mov_reg_v(pix_op, R_EAX, errp);\n            } else {\n                if (dst2 == 3) {\n                    l1ref0 = (msrs & 7) | REX_B(block_h);\n                    gen_op_mov_v_reg(pix_op, errp, l1ref0);\n                } else {\n                    gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                    gen_op_ld_v(block_h, pix_op, errp, cpu_A0);\n                    l1ref0 = 0; /* avoid warning */\n                }\n                gen_extu(pix_op, errp);\n                gen_extu(pix_op, nfree);\n                /* store value = (old == cmp ? new : old);  */\n                tcg_gen_movcond_tl(TCG_COND_EQ, info, errp, nfree, info, errp);\n                if (dst2 == 3) {\n                    gen_op_mov_reg_v(pix_op, R_EAX, errp);\n                    gen_op_mov_reg_v(pix_op, l1ref0, info);\n                } else {\n                    /* Perform an unconditional store cycle like physical cpu;\n                       must be before changing accumulator to ensure\n                       idempotency if the store faults and the instruction\n                       is restarted */\n                    gen_op_st_v(block_h, pix_op, info, cpu_A0);\n                    gen_op_mov_reg_v(pix_op, R_EAX, errp);\n                }\n            }\n            tcg_gen_mov_tl(cpu_cc_src, errp);\n            tcg_gen_mov_tl(cpu_cc_srcT, nfree);\n            tcg_gen_sub_tl(cpu_cc_dst, nfree, errp);\n            set_cc_op(block_h, CC_OP_SUBB + pix_op);\n            tcg_temp_free(errp);\n            tcg_temp_free(info);\n            tcg_temp_free(nfree);\n        }\n        break;\n    case 0x1c7: /* cmpxchg8b */\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        if ((dst2 == 3) || ((msrs & 0x38) != 0x8))\n            goto illegal_op;\n#ifdef TARGET_X86_64\n        if (alpha_in == MO_64) {\n            if (!(block_h->cpuid_ext_features & CPUID_EXT_CX16))\n                goto illegal_op;\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            if ((block_h->prefix & PREFIX_LOCK) && parallel_cpus) {\n                gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n            } else {\n                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);\n            }\n        } else\n#endif        \n        {\n            if (!(block_h->cpuid_features & CPUID_CX8))\n                goto illegal_op;\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            if ((block_h->prefix & PREFIX_LOCK) && parallel_cpus) {\n                gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n            } else {\n                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);\n            }\n        }\n        set_cc_op(block_h, CC_OP_EFLAGS);\n        break;\n        /**************************/\n        /* push/pop */\n    case 0x50 ... 0x57: /* push */\n        gen_op_mov_v_reg(MO_32, cpu_T0, (as & 7) | REX_B(block_h));\n        gen_push_v(block_h, cpu_T0);\n        break;\n    case 0x58 ... 0x5f: /* pop */\n        pix_op = gen_pop_T0(block_h);\n        /* NOTE: order is important for pop %sp */\n        gen_pop_update(block_h, pix_op);\n        gen_op_mov_reg_v(pix_op, (as & 7) | REX_B(block_h), cpu_T0);\n        break;\n    case 0x60: /* pusha */\n        if (CODE64(block_h))\n            goto illegal_op;\n        gen_pusha(block_h);\n        break;\n    case 0x61: /* popa */\n        if (CODE64(block_h))\n            goto illegal_op;\n        gen_popa(block_h);\n        break;\n    case 0x68: /* push Iv */\n    case 0x6a:\n        pix_op = mo_pushpop(block_h, alpha_in);\n        if (as == 0x68)\n            buflen = insn_get(refcount_table_clusters, block_h, pix_op);\n        else\n            buflen = (int8_t)insn_get(refcount_table_clusters, block_h, MO_8);\n        tcg_gen_movi_tl(cpu_T0, buflen);\n        gen_push_v(block_h, cpu_T0);\n        break;\n    case 0x8f: /* pop Ev */\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        pix_op = gen_pop_T0(block_h);\n        if (dst2 == 3) {\n            /* NOTE: order is important for pop %sp */\n            gen_pop_update(block_h, pix_op);\n            l1ref0 = (msrs & 7) | REX_B(block_h);\n            gen_op_mov_reg_v(pix_op, l1ref0, cpu_T0);\n        } else {\n            /* NOTE: order is important too for MMU exceptions */\n            block_h->popl_esp_hack = 1 << pix_op;\n            gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, OR_TMP0, 1);\n            block_h->popl_esp_hack = 0;\n            gen_pop_update(block_h, pix_op);\n        }\n        break;\n    case 0xc8: /* enter */\n        {\n            int wr_id_in;\n            buflen = x86_lduw_code(refcount_table_clusters, block_h);\n            wr_id_in = x86_ldub_code(refcount_table_clusters, block_h);\n            gen_enter(block_h, buflen, wr_id_in);\n        }\n        break;\n    case 0xc9: /* leave */\n        gen_leave(block_h);\n        break;\n    case 0x06: /* push es */\n    case 0x0e: /* push cs */\n    case 0x16: /* push ss */\n    case 0x1e: /* push ds */\n        if (CODE64(block_h))\n            goto illegal_op;\n        gen_op_movl_T0_seg(as >> 3);\n        gen_push_v(block_h, cpu_T0);\n        break;\n    case 0x1a0: /* push fs */\n    case 0x1a8: /* push gs */\n        gen_op_movl_T0_seg((as >> 3) & 7);\n        gen_push_v(block_h, cpu_T0);\n        break;\n    case 0x07: /* pop es */\n    case 0x17: /* pop ss */\n    case 0x1f: /* pop ds */\n        if (CODE64(block_h))\n            goto illegal_op;\n        scale = as >> 3;\n        pix_op = gen_pop_T0(block_h);\n        gen_movl_seg_T0(block_h, scale);\n        gen_pop_update(block_h, pix_op);\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n        if (block_h->cow_header.is_jmp) {\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            if (scale == R_SS) {\n                block_h->tf = 0;\n                gen_eob_inhibit_irq(block_h, true);\n            } else {\n                gen_eob(block_h);\n            }\n        }\n        break;\n    case 0x1a1: /* pop fs */\n    case 0x1a9: /* pop gs */\n        pix_op = gen_pop_T0(block_h);\n        gen_movl_seg_T0(block_h, (as >> 3) & 7);\n        gen_pop_update(block_h, pix_op);\n        if (block_h->cow_header.is_jmp) {\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob(block_h);\n        }\n        break;\n        /**************************/\n        /* mov */\n    case 0x88:\n    case 0x89: /* mov Gv, Ev */\n        pix_op = mo_b_d(as, alpha_in);\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        /* generate a generic store */\n        gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, scale, 1);\n        break;\n    case 0xc6:\n    case 0xc7: /* mov Ev, Iv */\n        pix_op = mo_b_d(as, alpha_in);\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        if (dst2 != 3) {\n            block_h->rip_offset = insn_const_size(pix_op);\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n        }\n        buflen = insn_get(refcount_table_clusters, block_h, pix_op);\n        tcg_gen_movi_tl(cpu_T0, buflen);\n        if (dst2 != 3) {\n            gen_op_st_v(block_h, pix_op, cpu_T0, cpu_A0);\n        } else {\n            gen_op_mov_reg_v(pix_op, (msrs & 7) | REX_B(block_h), cpu_T0);\n        }\n        break;\n    case 0x8a:\n    case 0x8b: /* mov Ev, Gv */\n        pix_op = mo_b_d(as, alpha_in);\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, OR_TMP0, 0);\n        gen_op_mov_reg_v(pix_op, scale, cpu_T0);\n        break;\n    case 0x8e: /* mov seg, Gv */\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = (msrs >> 3) & 7;\n        if (scale >= 6 || scale == R_CS)\n            goto illegal_op;\n        gen_ldst_modrm(refcount_table_clusters, block_h, msrs, MO_16, OR_TMP0, 0);\n        gen_movl_seg_T0(block_h, scale);\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n        if (block_h->cow_header.is_jmp) {\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            if (scale == R_SS) {\n                block_h->tf = 0;\n                gen_eob_inhibit_irq(block_h, true);\n            } else {\n                gen_eob(block_h);\n            }\n        }\n        break;\n    case 0x8c: /* mov Gv, seg */\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = (msrs >> 3) & 7;\n        dst2 = (msrs >> 6) & 3;\n        if (scale >= 6)\n            goto illegal_op;\n        gen_op_movl_T0_seg(scale);\n        pix_op = dst2 == 3 ? alpha_in : MO_16;\n        gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, OR_TMP0, 1);\n        break;\n    case 0x1b6: /* movzbS Gv, Eb */\n    case 0x1b7: /* movzwS Gv, Eb */\n    case 0x1be: /* movsbS Gv, Eb */\n    case 0x1bf: /* movswS Gv, Eb */\n        {\n            TCGMemOp device;\n            TCGMemOp rtce;\n            /* d_ot is the size of destination */\n            device = alpha_in;\n            /* ot is the size of source */\n            pix_op = (as & 1) + MO_8;\n            /* s_ot is the sign+size of source */\n            rtce = as & 8 ? MO_SIGN | pix_op : pix_op;\n            msrs = x86_ldub_code(refcount_table_clusters, block_h);\n            scale = ((msrs >> 3) & 7) | irq;\n            dst2 = (msrs >> 6) & 3;\n            l1ref0 = (msrs & 7) | REX_B(block_h);\n            if (dst2 == 3) {\n                if (rtce == MO_SB && byte_reg_is_xH(l1ref0)) {\n                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[l1ref0 - 4], 8, 8);\n                } else {\n                    gen_op_mov_v_reg(pix_op, cpu_T0, l1ref0);\n                    switch (rtce) {\n                    case MO_UB:\n                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n                        break;\n                    case MO_SB:\n                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n                        break;\n                    case MO_UW:\n                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n                        break;\n                    default:\n                    case MO_SW:\n                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n                        break;\n                    }\n                }\n                gen_op_mov_reg_v(device, scale, cpu_T0);\n            } else {\n                gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                gen_op_ld_v(block_h, rtce, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(device, scale, cpu_T0);\n            }\n        }\n        break;\n    case 0x8d: /* lea */\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        if (dst2 == 3)\n            goto illegal_op;\n        scale = ((msrs >> 3) & 7) | irq;\n        {\n            AddressParts a = gen_lea_modrm_0(refcount_table_clusters, block_h, msrs);\n            TCGv ea = gen_lea_modrm_1(a);\n            gen_lea_v_seg(block_h, block_h->uext, ea, -1, -1);\n            gen_op_mov_reg_v(alpha_in, scale, cpu_A0);\n        }\n        break;\n    case 0xa0: /* mov EAX, Ov */\n    case 0xa1:\n    case 0xa2: /* mov Ov, EAX */\n    case 0xa3:\n        {\n            target_ulong sconf;\n            pix_op = mo_b_d(as, alpha_in);\n            switch (block_h->uext) {\n#ifdef TARGET_X86_64\n            case MO_64:\n                sconf = x86_ldq_code(refcount_table_clusters, block_h);\n                break;\n#endif\n            default:\n                sconf = insn_get(refcount_table_clusters, block_h, block_h->uext);\n                break;\n            }\n            tcg_gen_movi_tl(cpu_A0, sconf);\n            gen_add_A0_ds_seg(block_h);\n            if ((as & 2) == 0) {\n                gen_op_ld_v(block_h, pix_op, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(pix_op, R_EAX, cpu_T0);\n            } else {\n                gen_op_mov_v_reg(pix_op, cpu_T0, R_EAX);\n                gen_op_st_v(block_h, pix_op, cpu_T0, cpu_A0);\n            }\n        }\n        break;\n    case 0xd7: /* xlat */\n        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);\n        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);\n        gen_extu(block_h->uext, cpu_A0);\n        gen_add_A0_ds_seg(block_h);\n        gen_op_ld_v(block_h, MO_8, cpu_T0, cpu_A0);\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n        break;\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n        buflen = insn_get(refcount_table_clusters, block_h, MO_8);\n        tcg_gen_movi_tl(cpu_T0, buflen);\n        gen_op_mov_reg_v(MO_8, (as & 7) | REX_B(block_h), cpu_T0);\n        break;\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n#ifdef TARGET_X86_64\n        if (alpha_in == MO_64) {\n            uint64_t sbi;\n            /* 64 bit case */\n            sbi = x86_ldq_code(refcount_table_clusters, block_h);\n            scale = (as & 7) | REX_B(block_h);\n            tcg_gen_movi_tl(cpu_T0, sbi);\n            gen_op_mov_reg_v(MO_64, scale, cpu_T0);\n        } else\n#endif\n        {\n            pix_op = alpha_in;\n            buflen = insn_get(refcount_table_clusters, block_h, pix_op);\n            scale = (as & 7) | REX_B(block_h);\n            tcg_gen_movi_tl(cpu_T0, buflen);\n            gen_op_mov_reg_v(pix_op, scale, cpu_T0);\n        }\n        break;\n    case 0x91 ... 0x97: /* xchg R, EAX */\n    do_xchg_reg_eax:\n        pix_op = alpha_in;\n        scale = (as & 7) | REX_B(block_h);\n        l1ref0 = R_EAX;\n        goto do_xchg_reg;\n    case 0x86:\n    case 0x87: /* xchg Ev, Gv */\n        pix_op = mo_b_d(as, alpha_in);\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        dst2 = (msrs >> 6) & 3;\n        if (dst2 == 3) {\n            l1ref0 = (msrs & 7) | REX_B(block_h);\n        do_xchg_reg:\n            gen_op_mov_v_reg(pix_op, cpu_T0, scale);\n            gen_op_mov_v_reg(pix_op, cpu_T1, l1ref0);\n            gen_op_mov_reg_v(pix_op, l1ref0, cpu_T0);\n            gen_op_mov_reg_v(pix_op, scale, cpu_T1);\n        } else {\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            gen_op_mov_v_reg(pix_op, cpu_T0, scale);\n            /* for xchg, lock is implicit */\n            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,\n                                   block_h->mem_index, pix_op | MO_LE);\n            gen_op_mov_reg_v(pix_op, scale, cpu_T1);\n        }\n        break;\n    case 0xc4: /* les Gv */\n        /* In CODE64 this is VEX3; see above.  */\n        den = R_ES;\n        goto do_lxx;\n    case 0xc5: /* lds Gv */\n        /* In CODE64 this is VEX2; see above.  */\n        den = R_DS;\n        goto do_lxx;\n    case 0x1b2: /* lss Gv */\n        den = R_SS;\n        goto do_lxx;\n    case 0x1b4: /* lfs Gv */\n        den = R_FS;\n        goto do_lxx;\n    case 0x1b5: /* lgs Gv */\n        den = R_GS;\n    do_lxx:\n        pix_op = alpha_in != MO_16 ? MO_32 : MO_16;\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        dst2 = (msrs >> 6) & 3;\n        if (dst2 == 3)\n            goto illegal_op;\n        gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n        gen_op_ld_v(block_h, pix_op, cpu_T1, cpu_A0);\n        gen_add_A0_im(block_h, 1 << pix_op);\n        /* load the segment first to handle exceptions properly */\n        gen_op_ld_v(block_h, MO_16, cpu_T0, cpu_A0);\n        gen_movl_seg_T0(block_h, den);\n        /* then put the data */\n        gen_op_mov_reg_v(pix_op, scale, cpu_T1);\n        if (block_h->cow_header.is_jmp) {\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob(block_h);\n        }\n        break;\n        /************************/\n        /* shifts */\n    case 0xc0:\n    case 0xc1:\n        /* shift Ev,Ib */\n        initiator_name = 2;\n    grp2:\n        {\n            pix_op = mo_b_d(as, alpha_in);\n            msrs = x86_ldub_code(refcount_table_clusters, block_h);\n            dst2 = (msrs >> 6) & 3;\n            den = (msrs >> 3) & 7;\n            if (dst2 != 3) {\n                if (initiator_name == 2) {\n                    block_h->rip_offset = 1;\n                }\n                gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                block0 = OR_TMP0;\n            } else {\n                block0 = (msrs & 7) | REX_B(block_h);\n            }\n            /* simpler op */\n            if (initiator_name == 0) {\n                gen_shift(block_h, den, pix_op, block0, OR_ECX);\n            } else {\n                if (initiator_name == 2) {\n                    initiator_name = x86_ldub_code(refcount_table_clusters, block_h);\n                }\n                gen_shifti(block_h, den, pix_op, block0, initiator_name);\n            }\n        }\n        break;\n    case 0xd0:\n    case 0xd1:\n        /* shift Ev,1 */\n        initiator_name = 1;\n        goto grp2;\n    case 0xd2:\n    case 0xd3:\n        /* shift Ev,cl */\n        initiator_name = 0;\n        goto grp2;\n    case 0x1a4: /* shld imm */\n        den = 0;\n        initiator_name = 1;\n        goto do_shiftd;\n    case 0x1a5: /* shld cl */\n        den = 0;\n        initiator_name = 0;\n        goto do_shiftd;\n    case 0x1ac: /* shrd imm */\n        den = 1;\n        initiator_name = 1;\n        goto do_shiftd;\n    case 0x1ad: /* shrd cl */\n        den = 1;\n        initiator_name = 0;\n    do_shiftd:\n        pix_op = alpha_in;\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        l1ref0 = (msrs & 7) | REX_B(block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        if (dst2 != 3) {\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            block0 = OR_TMP0;\n        } else {\n            block0 = l1ref0;\n        }\n        gen_op_mov_v_reg(pix_op, cpu_T1, scale);\n        if (initiator_name) {\n            TCGv imm = tcg_const_tl(x86_ldub_code(refcount_table_clusters, block_h));\n            gen_shiftd_rm_T1(block_h, pix_op, block0, den, imm);\n            tcg_temp_free(imm);\n        } else {\n            gen_shiftd_rm_T1(block_h, pix_op, block0, den, cpu_regs[R_ECX]);\n        }\n        break;\n        /************************/\n        /* floats */\n    case 0xd8 ... 0xdf:\n        if (block_h->flags & (HF_EM_MASK | HF_TS_MASK)) {\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n            /* XXX: what to do if illegal op ? */\n            gen_exception(block_h, EXCP07_PREX, pc_start - block_h->cs_base);\n            break;\n        }\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        l1ref0 = msrs & 7;\n        den = ((as & 7) << 3) | ((msrs >> 3) & 7);\n        if (dst2 != 3) {\n            /* memory op */\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            switch(den) {\n            case 0x00 ... 0x07: /* fxxxs */\n            case 0x10 ... 0x17: /* fixxxl */\n            case 0x20 ... 0x27: /* fxxxl */\n            case 0x30 ... 0x37: /* fixxx */\n                {\n                    int got_picture_ptr;\n                    got_picture_ptr = den & 7;\n                    switch(den >> 4) {\n                    case 0:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 1:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 2:\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n                                            block_h->mem_index, MO_LEQ);\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n                        break;\n                    case 3:\n                    default:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LESW);\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    }\n                    gen_helper_fp_arith_ST0_FT0(got_picture_ptr);\n                    if (got_picture_ptr == 3) {\n                        /* fcomp needs pop */\n                        gen_helper_fpop(cpu_env);\n                    }\n                }\n                break;\n            case 0x08: /* flds */\n            case 0x0a: /* fsts */\n            case 0x0b: /* fstps */\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n                switch(den & 7) {\n                case 0:\n                    switch(den >> 4) {\n                    case 0:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 1:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 2:\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n                                            block_h->mem_index, MO_LEQ);\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n                        break;\n                    case 3:\n                    default:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LESW);\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    }\n                    break;\n                case 1:\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n                    switch(den >> 4) {\n                    case 1:\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                        break;\n                    case 2:\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n                                            block_h->mem_index, MO_LEQ);\n                        break;\n                    case 3:\n                    default:\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LEUW);\n                        break;\n                    }\n                    gen_helper_fpop(cpu_env);\n                    break;\n                default:\n                    switch(den >> 4) {\n                    case 0:\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                        break;\n                    case 1:\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                        break;\n                    case 2:\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n                                            block_h->mem_index, MO_LEQ);\n                        break;\n                    case 3:\n                    default:\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            block_h->mem_index, MO_LEUW);\n                        break;\n                    }\n                    if ((den & 7) == 3)\n                        gen_helper_fpop(cpu_env);\n                    break;\n                }\n                break;\n            case 0x0c: /* fldenv mem */\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(alpha_in - 1));\n                break;\n            case 0x0d: /* fldcw mem */\n                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                    block_h->mem_index, MO_LEUW);\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n                break;\n            case 0x0e: /* fnstenv mem */\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(alpha_in - 1));\n                break;\n            case 0x0f: /* fnstcw mem */\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                    block_h->mem_index, MO_LEUW);\n                break;\n            case 0x1d: /* fldt mem */\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n                break;\n            case 0x1f: /* fstpt mem */\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x2c: /* frstor mem */\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(alpha_in - 1));\n                break;\n            case 0x2e: /* fnsave mem */\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(alpha_in - 1));\n                break;\n            case 0x2f: /* fnstsw mem */\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                    block_h->mem_index, MO_LEUW);\n                break;\n            case 0x3c: /* fbld */\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n                break;\n            case 0x3e: /* fbstp */\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x3d: /* fildll */\n                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, block_h->mem_index, MO_LEQ);\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n                break;\n            case 0x3f: /* fistpll */\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, block_h->mem_index, MO_LEQ);\n                gen_helper_fpop(cpu_env);\n                break;\n            default:\n                goto unknown_op;\n            }\n        } else {\n            /* register float ops */\n            block0 = l1ref0;\n            switch(den) {\n            case 0x08: /* fld sti */\n                gen_helper_fpush(cpu_env);\n                gen_helper_fmov_ST0_STN(cpu_env,\n                                        tcg_const_i32((block0 + 1) & 7));\n                break;\n            case 0x09: /* fxchg sti */\n            case 0x29: /* fxchg4 sti, undocumented op */\n            case 0x39: /* fxchg7 sti, undocumented op */\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(block0));\n                break;\n            case 0x0a: /* grp d9/2 */\n                switch(l1ref0) {\n                case 0: /* fnop */\n                    /* check exceptions (FreeBSD FPU probe) */\n                    gen_helper_fwait(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x0c: /* grp d9/4 */\n                switch(l1ref0) {\n                case 0: /* fchs */\n                    gen_helper_fchs_ST0(cpu_env);\n                    break;\n                case 1: /* fabs */\n                    gen_helper_fabs_ST0(cpu_env);\n                    break;\n                case 4: /* ftst */\n                    gen_helper_fldz_FT0(cpu_env);\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n                    break;\n                case 5: /* fxam */\n                    gen_helper_fxam_ST0(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x0d: /* grp d9/5 */\n                {\n                    switch(l1ref0) {\n                    case 0:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fld1_ST0(cpu_env);\n                        break;\n                    case 1:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldl2t_ST0(cpu_env);\n                        break;\n                    case 2:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldl2e_ST0(cpu_env);\n                        break;\n                    case 3:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldpi_ST0(cpu_env);\n                        break;\n                    case 4:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldlg2_ST0(cpu_env);\n                        break;\n                    case 5:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldln2_ST0(cpu_env);\n                        break;\n                    case 6:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldz_ST0(cpu_env);\n                        break;\n                    default:\n                        goto unknown_op;\n                    }\n                }\n                break;\n            case 0x0e: /* grp d9/6 */\n                switch(l1ref0) {\n                case 0: /* f2xm1 */\n                    gen_helper_f2xm1(cpu_env);\n                    break;\n                case 1: /* fyl2x */\n                    gen_helper_fyl2x(cpu_env);\n                    break;\n                case 2: /* fptan */\n                    gen_helper_fptan(cpu_env);\n                    break;\n                case 3: /* fpatan */\n                    gen_helper_fpatan(cpu_env);\n                    break;\n                case 4: /* fxtract */\n                    gen_helper_fxtract(cpu_env);\n                    break;\n                case 5: /* fprem1 */\n                    gen_helper_fprem1(cpu_env);\n                    break;\n                case 6: /* fdecstp */\n                    gen_helper_fdecstp(cpu_env);\n                    break;\n                default:\n                case 7: /* fincstp */\n                    gen_helper_fincstp(cpu_env);\n                    break;\n                }\n                break;\n            case 0x0f: /* grp d9/7 */\n                switch(l1ref0) {\n                case 0: /* fprem */\n                    gen_helper_fprem(cpu_env);\n                    break;\n                case 1: /* fyl2xp1 */\n                    gen_helper_fyl2xp1(cpu_env);\n                    break;\n                case 2: /* fsqrt */\n                    gen_helper_fsqrt(cpu_env);\n                    break;\n                case 3: /* fsincos */\n                    gen_helper_fsincos(cpu_env);\n                    break;\n                case 5: /* fscale */\n                    gen_helper_fscale(cpu_env);\n                    break;\n                case 4: /* frndint */\n                    gen_helper_frndint(cpu_env);\n                    break;\n                case 6: /* fsin */\n                    gen_helper_fsin(cpu_env);\n                    break;\n                default:\n                case 7: /* fcos */\n                    gen_helper_fcos(cpu_env);\n                    break;\n                }\n                break;\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n                {\n                    int got_picture_ptr;\n                    got_picture_ptr = den & 7;\n                    if (den >= 0x20) {\n                        gen_helper_fp_arith_STN_ST0(got_picture_ptr, block0);\n                        if (den >= 0x30)\n                            gen_helper_fpop(cpu_env);\n                    } else {\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(block0));\n                        gen_helper_fp_arith_ST0_FT0(got_picture_ptr);\n                    }\n                }\n                break;\n            case 0x02: /* fcom */\n            case 0x22: /* fcom2, undocumented op */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(block0));\n                gen_helper_fcom_ST0_FT0(cpu_env);\n                break;\n            case 0x03: /* fcomp */\n            case 0x23: /* fcomp3, undocumented op */\n            case 0x32: /* fcomp5, undocumented op */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(block0));\n                gen_helper_fcom_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x15: /* da/5 */\n                switch(l1ref0) {\n                case 1: /* fucompp */\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x1c:\n                switch(l1ref0) {\n                case 0: /* feni (287 only, just do nop here) */\n                    break;\n                case 1: /* fdisi (287 only, just do nop here) */\n                    break;\n                case 2: /* fclex */\n                    gen_helper_fclex(cpu_env);\n                    break;\n                case 3: /* fninit */\n                    gen_helper_fninit(cpu_env);\n                    break;\n                case 4: /* fsetpm (287 only, just do nop here) */\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x1d: /* fucomi */\n                if (!(block_h->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(block_h);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(block0));\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n                set_cc_op(block_h, CC_OP_EFLAGS);\n                break;\n            case 0x1e: /* fcomi */\n                if (!(block_h->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(block_h);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(block0));\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n                set_cc_op(block_h, CC_OP_EFLAGS);\n                break;\n            case 0x28: /* ffree sti */\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(block0));\n                break;\n            case 0x2a: /* fst sti */\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(block0));\n                break;\n            case 0x2b: /* fstp sti */\n            case 0x0b: /* fstp1 sti, undocumented op */\n            case 0x3a: /* fstp8 sti, undocumented op */\n            case 0x3b: /* fstp9 sti, undocumented op */\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(block0));\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x2c: /* fucom st(i) */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(block0));\n                gen_helper_fucom_ST0_FT0(cpu_env);\n                break;\n            case 0x2d: /* fucomp st(i) */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(block0));\n                gen_helper_fucom_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x33: /* de/3 */\n                switch(l1ref0) {\n                case 1: /* fcompp */\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x38: /* ffreep sti, undocumented op */\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(block0));\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x3c: /* df/4 */\n                switch(l1ref0) {\n                case 0:\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x3d: /* fucomip */\n                if (!(block_h->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(block_h);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(block0));\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                set_cc_op(block_h, CC_OP_EFLAGS);\n                break;\n            case 0x3e: /* fcomip */\n                if (!(block_h->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(block_h);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(block0));\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                set_cc_op(block_h, CC_OP_EFLAGS);\n                break;\n            case 0x10 ... 0x13: /* fcmovxx */\n            case 0x18 ... 0x1b:\n                {\n                    int got_picture_ptr;\n                    TCGLabel *wwn;\n                    static const uint8_t off[8] = {\n                        (JCC_B << 1),\n                        (JCC_Z << 1),\n                        (JCC_BE << 1),\n                        (JCC_P << 1),\n                    };\n                    if (!(block_h->cpuid_features & CPUID_CMOV)) {\n                        goto illegal_op;\n                    }\n                    got_picture_ptr = off[den & 3] | (((den >> 3) & 1) ^ 1);\n                    wwn = gen_new_label();\n                    gen_jcc1_noeob(block_h, got_picture_ptr, wwn);\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(block0));\n                    gen_set_label(wwn);\n                }\n                break;\n            default:\n                goto unknown_op;\n            }\n        }\n        break;\n        /************************/\n        /* string ops */\n    case 0xa4: /* movsS */\n    case 0xa5:\n        pix_op = mo_b_d(as, alpha_in);\n        if (pred_y & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_movs(block_h, pix_op, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base);\n        } else {\n            gen_movs(block_h, pix_op);\n        }\n        break;\n    case 0xaa: /* stosS */\n    case 0xab:\n        pix_op = mo_b_d(as, alpha_in);\n        if (pred_y & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_stos(block_h, pix_op, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base);\n        } else {\n            gen_stos(block_h, pix_op);\n        }\n        break;\n    case 0xac: /* lodsS */\n    case 0xad:\n        pix_op = mo_b_d(as, alpha_in);\n        if (pred_y & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_lods(block_h, pix_op, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base);\n        } else {\n            gen_lods(block_h, pix_op);\n        }\n        break;\n    case 0xae: /* scasS */\n    case 0xaf:\n        pix_op = mo_b_d(as, alpha_in);\n        if (pred_y & PREFIX_REPNZ) {\n            gen_repz_scas(block_h, pix_op, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base, 1);\n        } else if (pred_y & PREFIX_REPZ) {\n            gen_repz_scas(block_h, pix_op, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base, 0);\n        } else {\n            gen_scas(block_h, pix_op);\n        }\n        break;\n    case 0xa6: /* cmpsS */\n    case 0xa7:\n        pix_op = mo_b_d(as, alpha_in);\n        if (pred_y & PREFIX_REPNZ) {\n            gen_repz_cmps(block_h, pix_op, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base, 1);\n        } else if (pred_y & PREFIX_REPZ) {\n            gen_repz_cmps(block_h, pix_op, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base, 0);\n        } else {\n            gen_cmps(block_h, pix_op);\n        }\n        break;\n    case 0x6c: /* insS */\n    case 0x6d:\n        pix_op = mo_b_d32(as, alpha_in);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(block_h, pix_op, pc_start - block_h->cs_base, \n                     SVM_IOIO_TYPE_MASK | svm_is_rep(pred_y) | 4);\n        if (pred_y & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_ins(block_h, pix_op, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base);\n        } else {\n            gen_ins(block_h, pix_op);\n            if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n                gen_jmp(block_h, block_h->sphb - block_h->cs_base);\n            }\n        }\n        break;\n    case 0x6e: /* outsS */\n    case 0x6f:\n        pix_op = mo_b_d32(as, alpha_in);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(block_h, pix_op, pc_start - block_h->cs_base,\n                     svm_is_rep(pred_y) | 4);\n        if (pred_y & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_outs(block_h, pix_op, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base);\n        } else {\n            gen_outs(block_h, pix_op);\n            if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n                gen_jmp(block_h, block_h->sphb - block_h->cs_base);\n            }\n        }\n        break;\n        /************************/\n        /* port I/O */\n    case 0xe4:\n    case 0xe5:\n        pix_op = mo_b_d32(as, alpha_in);\n        buflen = x86_ldub_code(refcount_table_clusters, block_h);\n        tcg_gen_movi_tl(cpu_T0, buflen);\n        gen_check_io(block_h, pix_op, pc_start - block_h->cs_base,\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(pred_y));\n        if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n	}\n        tcg_gen_movi_i32(cpu_tmp2_i32, buflen);\n        gen_helper_in_func(pix_op, cpu_T1, cpu_tmp2_i32);\n        gen_op_mov_reg_v(pix_op, R_EAX, cpu_T1);\n        gen_bpt_io(block_h, cpu_tmp2_i32, pix_op);\n        if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(block_h, block_h->sphb - block_h->cs_base);\n        }\n        break;\n    case 0xe6:\n    case 0xe7:\n        pix_op = mo_b_d32(as, alpha_in);\n        buflen = x86_ldub_code(refcount_table_clusters, block_h);\n        tcg_gen_movi_tl(cpu_T0, buflen);\n        gen_check_io(block_h, pix_op, pc_start - block_h->cs_base,\n                     svm_is_rep(pred_y));\n        gen_op_mov_v_reg(pix_op, cpu_T1, R_EAX);\n        if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n	}\n        tcg_gen_movi_i32(cpu_tmp2_i32, buflen);\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n        gen_helper_out_func(pix_op, cpu_tmp2_i32, cpu_tmp3_i32);\n        gen_bpt_io(block_h, cpu_tmp2_i32, pix_op);\n        if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(block_h, block_h->sphb - block_h->cs_base);\n        }\n        break;\n    case 0xec:\n    case 0xed:\n        pix_op = mo_b_d32(as, alpha_in);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(block_h, pix_op, pc_start - block_h->cs_base,\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(pred_y));\n        if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n	}\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n        gen_helper_in_func(pix_op, cpu_T1, cpu_tmp2_i32);\n        gen_op_mov_reg_v(pix_op, R_EAX, cpu_T1);\n        gen_bpt_io(block_h, cpu_tmp2_i32, pix_op);\n        if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(block_h, block_h->sphb - block_h->cs_base);\n        }\n        break;\n    case 0xee:\n    case 0xef:\n        pix_op = mo_b_d32(as, alpha_in);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(block_h, pix_op, pc_start - block_h->cs_base,\n                     svm_is_rep(pred_y));\n        gen_op_mov_v_reg(pix_op, cpu_T1, R_EAX);\n        if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n	}\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n        gen_helper_out_func(pix_op, cpu_tmp2_i32, cpu_tmp3_i32);\n        gen_bpt_io(block_h, cpu_tmp2_i32, pix_op);\n        if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(block_h, block_h->sphb - block_h->cs_base);\n        }\n        break;\n        /************************/\n        /* control */\n    case 0xc2: /* ret im */\n        buflen = x86_ldsw_code(refcount_table_clusters, block_h);\n        pix_op = gen_pop_T0(block_h);\n        gen_stack_update(block_h, buflen + (1 << pix_op));\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n        gen_op_jmp_v(cpu_T0);\n        gen_bnd_jmp(block_h);\n        gen_jr(block_h, cpu_T0);\n        break;\n    case 0xc3: /* ret */\n        pix_op = gen_pop_T0(block_h);\n        gen_pop_update(block_h, pix_op);\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n        gen_op_jmp_v(cpu_T0);\n        gen_bnd_jmp(block_h);\n        gen_jr(block_h, cpu_T0);\n        break;\n    case 0xca: /* lret im */\n        buflen = x86_ldsw_code(refcount_table_clusters, block_h);\n    do_lret:\n        if (block_h->pe && !block_h->vm86) {\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(alpha_in - 1),\n                                      tcg_const_i32(buflen));\n        } else {\n            gen_stack_A0(block_h);\n            /* pop offset */\n            gen_op_ld_v(block_h, alpha_in, cpu_T0, cpu_A0);\n            /* NOTE: keeping EIP updated is not a problem in case of\n               exception */\n            gen_op_jmp_v(cpu_T0);\n            /* pop selector */\n            gen_add_A0_im(block_h, 1 << alpha_in);\n            gen_op_ld_v(block_h, alpha_in, cpu_T0, cpu_A0);\n            gen_op_movl_seg_T0_vm(R_CS);\n            /* add stack offset */\n            gen_stack_update(block_h, buflen + (2 << alpha_in));\n        }\n        gen_eob(block_h);\n        break;\n    case 0xcb: /* lret */\n        buflen = 0;\n        goto do_lret;\n    case 0xcf: /* iret */\n        gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_IRET);\n        if (!block_h->pe) {\n            /* real mode */\n            gen_helper_iret_real(cpu_env, tcg_const_i32(alpha_in - 1));\n            set_cc_op(block_h, CC_OP_EFLAGS);\n        } else if (block_h->vm86) {\n            if (block_h->iopl != 3) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n            } else {\n                gen_helper_iret_real(cpu_env, tcg_const_i32(alpha_in - 1));\n                set_cc_op(block_h, CC_OP_EFLAGS);\n            }\n        } else {\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(alpha_in - 1),\n                                      tcg_const_i32(block_h->sphb - block_h->cs_base));\n            set_cc_op(block_h, CC_OP_EFLAGS);\n        }\n        gen_eob(block_h);\n        break;\n    case 0xe8: /* call im */\n        {\n            if (alpha_in != MO_16) {\n                beta = (int32_t)insn_get(refcount_table_clusters, block_h, MO_32);\n            } else {\n                beta = (int16_t)insn_get(refcount_table_clusters, block_h, MO_16);\n            }\n            header = block_h->sphb - block_h->cs_base;\n            beta += header;\n            if (alpha_in == MO_16) {\n                beta &= 0xffff;\n            } else if (!CODE64(block_h)) {\n                beta &= 0xffffffff;\n            }\n            tcg_gen_movi_tl(cpu_T0, header);\n            gen_push_v(block_h, cpu_T0);\n            gen_bnd_jmp(block_h);\n            gen_jmp(block_h, beta);\n        }\n        break;\n    case 0x9a: /* lcall im */\n        {\n            unsigned int buf2, gb;\n            if (CODE64(block_h))\n                goto illegal_op;\n            pix_op = alpha_in;\n            gb = insn_get(refcount_table_clusters, block_h, pix_op);\n            buf2 = insn_get(refcount_table_clusters, block_h, MO_16);\n            tcg_gen_movi_tl(cpu_T0, buf2);\n            tcg_gen_movi_tl(cpu_T1, gb);\n        }\n        goto do_lcall;\n    case 0xe9: /* jmp im */\n        if (alpha_in != MO_16) {\n            beta = (int32_t)insn_get(refcount_table_clusters, block_h, MO_32);\n        } else {\n            beta = (int16_t)insn_get(refcount_table_clusters, block_h, MO_16);\n        }\n        beta += block_h->sphb - block_h->cs_base;\n        if (alpha_in == MO_16) {\n            beta &= 0xffff;\n        } else if (!CODE64(block_h)) {\n            beta &= 0xffffffff;\n        }\n        gen_bnd_jmp(block_h);\n        gen_jmp(block_h, beta);\n        break;\n    case 0xea: /* ljmp im */\n        {\n            unsigned int buf2, gb;\n            if (CODE64(block_h))\n                goto illegal_op;\n            pix_op = alpha_in;\n            gb = insn_get(refcount_table_clusters, block_h, pix_op);\n            buf2 = insn_get(refcount_table_clusters, block_h, MO_16);\n            tcg_gen_movi_tl(cpu_T0, buf2);\n            tcg_gen_movi_tl(cpu_T1, gb);\n        }\n        goto do_ljmp;\n    case 0xeb: /* jmp Jb */\n        beta = (int8_t)insn_get(refcount_table_clusters, block_h, MO_8);\n        beta += block_h->sphb - block_h->cs_base;\n        if (alpha_in == MO_16) {\n            beta &= 0xffff;\n        }\n        gen_jmp(block_h, beta);\n        break;\n    case 0x70 ... 0x7f: /* jcc Jb */\n        beta = (int8_t)insn_get(refcount_table_clusters, block_h, MO_8);\n        goto do_jcc;\n    case 0x180 ... 0x18f: /* jcc Jv */\n        if (alpha_in != MO_16) {\n            beta = (int32_t)insn_get(refcount_table_clusters, block_h, MO_32);\n        } else {\n            beta = (int16_t)insn_get(refcount_table_clusters, block_h, MO_16);\n        }\n    do_jcc:\n        header = block_h->sphb - block_h->cs_base;\n        beta += header;\n        if (alpha_in == MO_16) {\n            beta &= 0xffff;\n        }\n        gen_bnd_jmp(block_h);\n        gen_jcc(block_h, as, beta, header);\n        break;\n    case 0x190 ... 0x19f: /* setcc Gv */\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        gen_setcc1(block_h, as, cpu_T0);\n        gen_ldst_modrm(refcount_table_clusters, block_h, msrs, MO_8, OR_TMP0, 1);\n        break;\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n        if (!(block_h->cpuid_features & CPUID_CMOV)) {\n            goto illegal_op;\n        }\n        pix_op = alpha_in;\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        gen_cmovcc1(refcount_table_clusters, block_h, pix_op, as, msrs, scale);\n        break;\n        /************************/\n        /* flags */\n    case 0x9c: /* pushf */\n        gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_PUSHF);\n        if (block_h->vm86 && block_h->iopl != 3) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            gen_update_cc_op(block_h);\n            gen_helper_read_eflags(cpu_T0, cpu_env);\n            gen_push_v(block_h, cpu_T0);\n        }\n        break;\n    case 0x9d: /* popf */\n        gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_POPF);\n        if (block_h->vm86 && block_h->iopl != 3) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            pix_op = gen_pop_T0(block_h);\n            if (block_h->cpl == 0) {\n                if (alpha_in != MO_16) {\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n                                                           ID_MASK | NT_MASK |\n                                                           IF_MASK |\n                                                           IOPL_MASK)));\n                } else {\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n                                                           ID_MASK | NT_MASK |\n                                                           IF_MASK | IOPL_MASK)\n                                                          & 0xffff));\n                }\n            } else {\n                if (block_h->cpl <= block_h->iopl) {\n                    if (alpha_in != MO_16) {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                                tcg_const_i32((TF_MASK |\n                                                               AC_MASK |\n                                                               ID_MASK |\n                                                               NT_MASK |\n                                                               IF_MASK)));\n                    } else {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                                tcg_const_i32((TF_MASK |\n                                                               AC_MASK |\n                                                               ID_MASK |\n                                                               NT_MASK |\n                                                               IF_MASK)\n                                                              & 0xffff));\n                    }\n                } else {\n                    if (alpha_in != MO_16) {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n                                                          ID_MASK | NT_MASK)));\n                    } else {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n                                                          ID_MASK | NT_MASK)\n                                                         & 0xffff));\n                    }\n                }\n            }\n            gen_pop_update(block_h, pix_op);\n            set_cc_op(block_h, CC_OP_EFLAGS);\n            /* abort translation because TF/AC flag may change */\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob(block_h);\n        }\n        break;\n    case 0x9e: /* sahf */\n        if (CODE64(block_h) && !(block_h->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n            goto illegal_op;\n        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);\n        gen_compute_eflags(block_h);\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);\n        break;\n    case 0x9f: /* lahf */\n        if (CODE64(block_h) && !(block_h->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n            goto illegal_op;\n        gen_compute_eflags(block_h);\n        /* Note: gen_compute_eflags() only gives the condition codes */\n        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);\n        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);\n        break;\n    case 0xf5: /* cmc */\n        gen_compute_eflags(block_h);\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n        break;\n    case 0xf8: /* clc */\n        gen_compute_eflags(block_h);\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n        break;\n    case 0xf9: /* stc */\n        gen_compute_eflags(block_h);\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n        break;\n    case 0xfc: /* cld */\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n        break;\n    case 0xfd: /* std */\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n        break;\n        /************************/\n        /* bit operations */\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n        pix_op = alpha_in;\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        den = (msrs >> 3) & 7;\n        dst2 = (msrs >> 6) & 3;\n        l1ref0 = (msrs & 7) | REX_B(block_h);\n        if (dst2 != 3) {\n            block_h->rip_offset = 1;\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            if (!(block_h->prefix & PREFIX_LOCK)) {\n                gen_op_ld_v(block_h, pix_op, cpu_T0, cpu_A0);\n            }\n        } else {\n            gen_op_mov_v_reg(pix_op, cpu_T0, l1ref0);\n        }\n        /* load shift */\n        buflen = x86_ldub_code(refcount_table_clusters, block_h);\n        tcg_gen_movi_tl(cpu_T1, buflen);\n        if (den < 4)\n            goto unknown_op;\n        den -= 4;\n        goto bt_op;\n    case 0x1a3: /* bt Gv, Ev */\n        den = 0;\n        goto do_btx;\n    case 0x1ab: /* bts */\n        den = 1;\n        goto do_btx;\n    case 0x1b3: /* btr */\n        den = 2;\n        goto do_btx;\n    case 0x1bb: /* btc */\n        den = 3;\n    do_btx:\n        pix_op = alpha_in;\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        dst2 = (msrs >> 6) & 3;\n        l1ref0 = (msrs & 7) | REX_B(block_h);\n        gen_op_mov_v_reg(MO_32, cpu_T1, scale);\n        if (dst2 != 3) {\n            AddressParts a = gen_lea_modrm_0(refcount_table_clusters, block_h, msrs);\n            /* specific case: we need to add a displacement */\n            gen_exts(pix_op, cpu_T1);\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + pix_op);\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, pix_op);\n            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);\n            gen_lea_v_seg(block_h, block_h->uext, cpu_A0, a.def_seg, block_h->override);\n            if (!(block_h->prefix & PREFIX_LOCK)) {\n                gen_op_ld_v(block_h, pix_op, cpu_T0, cpu_A0);\n            }\n        } else {\n            gen_op_mov_v_reg(pix_op, cpu_T0, l1ref0);\n        }\n    bt_op:\n        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + pix_op)) - 1);\n        tcg_gen_movi_tl(cpu_tmp0, 1);\n        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);\n        if (block_h->prefix & PREFIX_LOCK) {\n            switch (den) {\n            case 0: /* bt */\n                /* Needs no atomic ops; we surpressed the normal\n                   memory load for LOCK above so do it now.  */\n                gen_op_ld_v(block_h, pix_op, cpu_T0, cpu_A0);\n                break;\n            case 1: /* bts */\n                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,\n                                           block_h->mem_index, pix_op | MO_LE);\n                break;\n            case 2: /* btr */\n                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,\n                                            block_h->mem_index, pix_op | MO_LE);\n                break;\n            default:\n            case 3: /* btc */\n                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,\n                                            block_h->mem_index, pix_op | MO_LE);\n                break;\n            }\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n        } else {\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n            switch (den) {\n            case 0: /* bt */\n                /* Data already loaded; nothing to do.  */\n                break;\n            case 1: /* bts */\n                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);\n                break;\n            case 2: /* btr */\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);\n                break;\n            default:\n            case 3: /* btc */\n                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);\n                break;\n            }\n            if (den != 0) {\n                if (dst2 != 3) {\n                    gen_op_st_v(block_h, pix_op, cpu_T0, cpu_A0);\n                } else {\n                    gen_op_mov_reg_v(pix_op, l1ref0, cpu_T0);\n                }\n            }\n        }\n        /* Delay all CC updates until after the store above.  Note that\n           C is the result of the test, Z is unchanged, and the others\n           are all undefined.  */\n        switch (block_h->cc_op) {\n        case CC_OP_MULB ... CC_OP_MULQ:\n        case CC_OP_ADDB ... CC_OP_ADDQ:\n        case CC_OP_ADCB ... CC_OP_ADCQ:\n        case CC_OP_SUBB ... CC_OP_SUBQ:\n        case CC_OP_SBBB ... CC_OP_SBBQ:\n        case CC_OP_LOGICB ... CC_OP_LOGICQ:\n        case CC_OP_INCB ... CC_OP_INCQ:\n        case CC_OP_DECB ... CC_OP_DECQ:\n        case CC_OP_SHLB ... CC_OP_SHLQ:\n        case CC_OP_SARB ... CC_OP_SARQ:\n        case CC_OP_BMILGB ... CC_OP_BMILGQ:\n            /* Z was going to be computed from the non-zero status of CC_DST.\n               We can get that same Z value (and the new C value) by leaving\n               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the\n               same width.  */\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n            set_cc_op(block_h, ((block_h->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);\n            break;\n        default:\n            /* Otherwise, generate EFLAGS and replace the C bit.  */\n            gen_compute_eflags(block_h);\n            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,\n                               ctz32(CC_C), 1);\n            break;\n        }\n        break;\n    case 0x1bc: /* bsf / tzcnt */\n    case 0x1bd: /* bsr / lzcnt */\n        pix_op = alpha_in;\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, OR_TMP0, 0);\n        gen_extu(pix_op, cpu_T0);\n        /* Note that lzcnt and tzcnt are in different extensions.  */\n        if ((pred_y & PREFIX_REPZ)\n            && (as & 1\n                ? block_h->cpuid_ext3_features & CPUID_EXT3_ABM\n                : block_h->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {\n            int size = 8 << pix_op;\n            /* For lzcnt/tzcnt, C bit is defined related to the input. */\n            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n            if (as & 1) {\n                /* For lzcnt, reduce the target_ulong result by the\n                   number of zeros that we expect to find at the top.  */\n                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);\n                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);\n            } else {\n                /* For tzcnt, a zero input must return the operand size.  */\n                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);\n            }\n            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */\n            gen_op_update1_cc();\n            set_cc_op(block_h, CC_OP_BMILGB + pix_op);\n        } else {\n            /* For bsr/bsf, only the Z bit is defined and it is related\n               to the input and not the result.  */\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n            set_cc_op(block_h, CC_OP_LOGICB + pix_op);\n            /* ??? The manual says that the output is undefined when the\n               input is zero, but real hardware leaves it unchanged, and\n               real programs appear to depend on that.  Accomplish this\n               by passing the output as the value to return upon zero.  */\n            if (as & 1) {\n                /* For bsr, return the bit index of the first 1 bit,\n                   not the count of leading zeros.  */\n                tcg_gen_xori_tl(cpu_T1, cpu_regs[scale], TARGET_LONG_BITS - 1);\n                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);\n                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);\n            } else {\n                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[scale]);\n            }\n        }\n        gen_op_mov_reg_v(pix_op, scale, cpu_T0);\n        break;\n        /************************/\n        /* bcd */\n    case 0x27: /* daa */\n        if (CODE64(block_h))\n            goto illegal_op;\n        gen_update_cc_op(block_h);\n        gen_helper_daa(cpu_env);\n        set_cc_op(block_h, CC_OP_EFLAGS);\n        break;\n    case 0x2f: /* das */\n        if (CODE64(block_h))\n            goto illegal_op;\n        gen_update_cc_op(block_h);\n        gen_helper_das(cpu_env);\n        set_cc_op(block_h, CC_OP_EFLAGS);\n        break;\n    case 0x37: /* aaa */\n        if (CODE64(block_h))\n            goto illegal_op;\n        gen_update_cc_op(block_h);\n        gen_helper_aaa(cpu_env);\n        set_cc_op(block_h, CC_OP_EFLAGS);\n        break;\n    case 0x3f: /* aas */\n        if (CODE64(block_h))\n            goto illegal_op;\n        gen_update_cc_op(block_h);\n        gen_helper_aas(cpu_env);\n        set_cc_op(block_h, CC_OP_EFLAGS);\n        break;\n    case 0xd4: /* aam */\n        if (CODE64(block_h))\n            goto illegal_op;\n        buflen = x86_ldub_code(refcount_table_clusters, block_h);\n        if (buflen == 0) {\n            gen_exception(block_h, EXCP00_DIVZ, pc_start - block_h->cs_base);\n        } else {\n            gen_helper_aam(cpu_env, tcg_const_i32(buflen));\n            set_cc_op(block_h, CC_OP_LOGICB);\n        }\n        break;\n    case 0xd5: /* aad */\n        if (CODE64(block_h))\n            goto illegal_op;\n        buflen = x86_ldub_code(refcount_table_clusters, block_h);\n        gen_helper_aad(cpu_env, tcg_const_i32(buflen));\n        set_cc_op(block_h, CC_OP_LOGICB);\n        break;\n        /************************/\n        /* misc */\n    case 0x90: /* nop */\n        /* XXX: correct lock test for all insn */\n        if (pred_y & PREFIX_LOCK) {\n            goto illegal_op;\n        }\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n        if (REX_B(block_h)) {\n            goto do_xchg_reg_eax;\n        }\n        if (pred_y & PREFIX_REPZ) {\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_pause(cpu_env, tcg_const_i32(block_h->sphb - pc_start));\n            block_h->cow_header.is_jmp = DISAS_NORETURN;\n        }\n        break;\n    case 0x9b: /* fwait */\n        if ((block_h->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n            (HF_MP_MASK | HF_TS_MASK)) {\n            gen_exception(block_h, EXCP07_PREX, pc_start - block_h->cs_base);\n        } else {\n            gen_helper_fwait(cpu_env);\n        }\n        break;\n    case 0xcc: /* int3 */\n        gen_interrupt(block_h, EXCP03_INT3, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base);\n        break;\n    case 0xcd: /* int N */\n        buflen = x86_ldub_code(refcount_table_clusters, block_h);\n        if (block_h->vm86 && block_h->iopl != 3) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            gen_interrupt(block_h, buflen, pc_start - block_h->cs_base, block_h->sphb - block_h->cs_base);\n        }\n        break;\n    case 0xce: /* into */\n        if (CODE64(block_h))\n            goto illegal_op;\n        gen_update_cc_op(block_h);\n        gen_jmp_im(pc_start - block_h->cs_base);\n        gen_helper_into(cpu_env, tcg_const_i32(block_h->sphb - pc_start));\n        break;\n#ifdef WANT_ICEBP\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n        gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_ICEBP);\n#if 1\n        gen_debug(block_h, pc_start - block_h->cs_base);\n#else\n        /* start debug */\n        tb_flush(CPU(x86_env_get_cpu(refcount_table_clusters)));\n        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n#endif\n        break;\n#endif\n    case 0xfa: /* cli */\n        if (!block_h->vm86) {\n            if (block_h->cpl <= block_h->iopl) {\n                gen_helper_cli(cpu_env);\n            } else {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n            }\n        } else {\n            if (block_h->iopl == 3) {\n                gen_helper_cli(cpu_env);\n            } else {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n            }\n        }\n        break;\n    case 0xfb: /* sti */\n        if (block_h->vm86 ? block_h->iopl == 3 : block_h->cpl <= block_h->iopl) {\n            gen_helper_sti(cpu_env);\n            /* interruptions are enabled only the first insn after sti */\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob_inhibit_irq(block_h, true);\n        } else {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        }\n        break;\n    case 0x62: /* bound */\n        if (CODE64(block_h))\n            goto illegal_op;\n        pix_op = alpha_in;\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = (msrs >> 3) & 7;\n        dst2 = (msrs >> 6) & 3;\n        if (dst2 == 3)\n            goto illegal_op;\n        gen_op_mov_v_reg(pix_op, cpu_T0, scale);\n        gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n        if (pix_op == MO_16) {\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n        } else {\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n        }\n        break;\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n        scale = (as & 7) | REX_B(block_h);\n#ifdef TARGET_X86_64\n        if (alpha_in == MO_64) {\n            gen_op_mov_v_reg(MO_64, cpu_T0, scale);\n            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_64, scale, cpu_T0);\n        } else\n#endif\n        {\n            gen_op_mov_v_reg(MO_32, cpu_T0, scale);\n            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_32, scale, cpu_T0);\n        }\n        break;\n    case 0xd6: /* salc */\n        if (CODE64(block_h))\n            goto illegal_op;\n        gen_compute_eflags_c(block_h, cpu_T0);\n        tcg_gen_neg_tl(cpu_T0, cpu_T0);\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n        break;\n    case 0xe0: /* loopnz */\n    case 0xe1: /* loopz */\n    case 0xe2: /* loop */\n    case 0xe3: /* jecxz */\n        {\n            TCGLabel *wwn, *auth, *model;\n            beta = (int8_t)insn_get(refcount_table_clusters, block_h, MO_8);\n            header = block_h->sphb - block_h->cs_base;\n            beta += header;\n            if (alpha_in == MO_16) {\n                beta &= 0xffff;\n            }\n            wwn = gen_new_label();\n            auth = gen_new_label();\n            model = gen_new_label();\n            as &= 3;\n            switch(as) {\n            case 0: /* loopnz */\n            case 1: /* loopz */\n                gen_op_add_reg_im(block_h->uext, R_ECX, -1);\n                gen_op_jz_ecx(block_h->uext, model);\n                gen_jcc1(block_h, (JCC_Z << 1) | (as ^ 1), wwn);\n                break;\n            case 2: /* loop */\n                gen_op_add_reg_im(block_h->uext, R_ECX, -1);\n                gen_op_jnz_ecx(block_h->uext, wwn);\n                break;\n            default:\n            case 3: /* jcxz */\n                gen_op_jz_ecx(block_h->uext, wwn);\n                break;\n            }\n            gen_set_label(model);\n            gen_jmp_im(header);\n            tcg_gen_br(auth);\n            gen_set_label(wwn);\n            gen_jmp_im(beta);\n            gen_set_label(auth);\n            gen_eob(block_h);\n        }\n        break;\n    case 0x130: /* wrmsr */\n    case 0x132: /* rdmsr */\n        if (block_h->cpl != 0) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            if (as & 2) {\n                gen_helper_rdmsr(cpu_env);\n            } else {\n                gen_helper_wrmsr(cpu_env);\n            }\n        }\n        break;\n    case 0x131: /* rdtsc */\n        gen_update_cc_op(block_h);\n        gen_jmp_im(pc_start - block_h->cs_base);\n        if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n	}\n        gen_helper_rdtsc(cpu_env);\n        if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(block_h, block_h->sphb - block_h->cs_base);\n        }\n        break;\n    case 0x133: /* rdpmc */\n        gen_update_cc_op(block_h);\n        gen_jmp_im(pc_start - block_h->cs_base);\n        gen_helper_rdpmc(cpu_env);\n        break;\n    case 0x134: /* sysenter */\n        /* For Intel SYSENTER is valid on 64-bit */\n        if (CODE64(block_h) && refcount_table_clusters->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n            goto illegal_op;\n        if (!block_h->pe) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            gen_helper_sysenter(cpu_env);\n            gen_eob(block_h);\n        }\n        break;\n    case 0x135: /* sysexit */\n        /* For Intel SYSEXIT is valid on 64-bit */\n        if (CODE64(block_h) && refcount_table_clusters->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n            goto illegal_op;\n        if (!block_h->pe) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            gen_helper_sysexit(cpu_env, tcg_const_i32(alpha_in - 1));\n            gen_eob(block_h);\n        }\n        break;\n#ifdef TARGET_X86_64\n    case 0x105: /* syscall */\n        /* XXX: is it usable in real mode ? */\n        gen_update_cc_op(block_h);\n        gen_jmp_im(pc_start - block_h->cs_base);\n        gen_helper_syscall(cpu_env, tcg_const_i32(block_h->sphb - pc_start));\n        /* TF handling for the syscall insn is different. The TF bit is  checked\n           after the syscall insn completes. This allows #DB to not be\n           generated after one has entered CPL0 if TF is set in FMASK.  */\n        gen_eob_worker(block_h, false, true);\n        break;\n    case 0x107: /* sysret */\n        if (!block_h->pe) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            gen_helper_sysret(cpu_env, tcg_const_i32(alpha_in - 1));\n            /* condition codes are modified only in long mode */\n            if (block_h->lma) {\n                set_cc_op(block_h, CC_OP_EFLAGS);\n            }\n            /* TF handling for the sysret insn is different. The TF bit is\n               checked after the sysret insn completes. This allows #DB to be\n               generated "as if" the syscall insn in userspace has just\n               completed.  */\n            gen_eob_worker(block_h, false, true);\n        }\n        break;\n#endif\n    case 0x1a2: /* cpuid */\n        gen_update_cc_op(block_h);\n        gen_jmp_im(pc_start - block_h->cs_base);\n        gen_helper_cpuid(cpu_env);\n        break;\n    case 0xf4: /* hlt */\n        if (block_h->cpl != 0) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_hlt(cpu_env, tcg_const_i32(block_h->sphb - pc_start));\n            block_h->cow_header.is_jmp = DISAS_NORETURN;\n        }\n        break;\n    case 0x100:\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        den = (msrs >> 3) & 7;\n        switch(den) {\n        case 0: /* sldt */\n            if (!block_h->pe || block_h->vm86)\n                goto illegal_op;\n            gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_LDTR_READ);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                             offsetof(CPUX86State, ldt.buf2));\n            pix_op = dst2 == 3 ? alpha_in : MO_16;\n            gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, OR_TMP0, 1);\n            break;\n        case 2: /* lldt */\n            if (!block_h->pe || block_h->vm86)\n                goto illegal_op;\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n            } else {\n                gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_LDTR_WRITE);\n                gen_ldst_modrm(refcount_table_clusters, block_h, msrs, MO_16, OR_TMP0, 0);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n            }\n            break;\n        case 1: /* str */\n            if (!block_h->pe || block_h->vm86)\n                goto illegal_op;\n            gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_TR_READ);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                             offsetof(CPUX86State, tr.buf2));\n            pix_op = dst2 == 3 ? alpha_in : MO_16;\n            gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, OR_TMP0, 1);\n            break;\n        case 3: /* ltr */\n            if (!block_h->pe || block_h->vm86)\n                goto illegal_op;\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n            } else {\n                gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_TR_WRITE);\n                gen_ldst_modrm(refcount_table_clusters, block_h, msrs, MO_16, OR_TMP0, 0);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n            }\n            break;\n        case 4: /* verr */\n        case 5: /* verw */\n            if (!block_h->pe || block_h->vm86)\n                goto illegal_op;\n            gen_ldst_modrm(refcount_table_clusters, block_h, msrs, MO_16, OR_TMP0, 0);\n            gen_update_cc_op(block_h);\n            if (den == 4) {\n                gen_helper_verr(cpu_env, cpu_T0);\n            } else {\n                gen_helper_verw(cpu_env, cpu_T0);\n            }\n            set_cc_op(block_h, CC_OP_EFLAGS);\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n    case 0x101:\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        switch (msrs) {\n        CASE_MODRM_MEM_OP(0): /* sgdt */\n            gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_GDTR_READ);\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            tcg_gen_ld32u_tl(cpu_T0,\n                             cpu_env, offsetof(CPUX86State, gdt.limit));\n            gen_op_st_v(block_h, MO_16, cpu_T0, cpu_A0);\n            gen_add_A0_im(block_h, 2);\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.cow_header));\n            if (alpha_in == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            gen_op_st_v(block_h, CODE64(block_h) + MO_32, cpu_T0, cpu_A0);\n            break;\n        case 0xc8: /* monitor */\n            if (!(block_h->cpuid_ext_features & CPUID_EXT_MONITOR) || block_h->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);\n            gen_extu(block_h->uext, cpu_A0);\n            gen_add_A0_ds_seg(block_h);\n            gen_helper_monitor(cpu_env, cpu_A0);\n            break;\n        case 0xc9: /* mwait */\n            if (!(block_h->cpuid_ext_features & CPUID_EXT_MONITOR) || block_h->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_mwait(cpu_env, tcg_const_i32(block_h->sphb - pc_start));\n            gen_eob(block_h);\n            break;\n        case 0xca: /* clac */\n            if (!(block_h->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n                || block_h->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_helper_clac(cpu_env);\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob(block_h);\n            break;\n        case 0xcb: /* stac */\n            if (!(block_h->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n                || block_h->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_helper_stac(cpu_env);\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob(block_h);\n            break;\n        CASE_MODRM_MEM_OP(1): /* sidt */\n            gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_IDTR_READ);\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));\n            gen_op_st_v(block_h, MO_16, cpu_T0, cpu_A0);\n            gen_add_A0_im(block_h, 2);\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.cow_header));\n            if (alpha_in == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            gen_op_st_v(block_h, CODE64(block_h) + MO_32, cpu_T0, cpu_A0);\n            break;\n        case 0xd0: /* xgetbv */\n            if ((block_h->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (block_h->prefix & (PREFIX_LOCK | PREFIX_DATA\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n            break;\n        case 0xd1: /* xsetbv */\n            if ((block_h->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (block_h->prefix & (PREFIX_LOCK | PREFIX_DATA\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n            /* End TB because translation flags may change.  */\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob(block_h);\n            break;\n        case 0xd8: /* VMRUN */\n            if (!(block_h->flags & HF_SVME_MASK) || !block_h->pe) {\n                goto illegal_op;\n            }\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_vmrun(cpu_env, tcg_const_i32(block_h->uext - 1),\n                             tcg_const_i32(block_h->sphb - pc_start));\n            tcg_gen_exit_tb(0);\n            block_h->cow_header.is_jmp = DISAS_NORETURN;\n            break;\n        case 0xd9: /* VMMCALL */\n            if (!(block_h->flags & HF_SVME_MASK)) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_vmmcall(cpu_env);\n            break;\n        case 0xda: /* VMLOAD */\n            if (!(block_h->flags & HF_SVME_MASK) || !block_h->pe) {\n                goto illegal_op;\n            }\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_vmload(cpu_env, tcg_const_i32(block_h->uext - 1));\n            break;\n        case 0xdb: /* VMSAVE */\n            if (!(block_h->flags & HF_SVME_MASK) || !block_h->pe) {\n                goto illegal_op;\n            }\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_vmsave(cpu_env, tcg_const_i32(block_h->uext - 1));\n            break;\n        case 0xdc: /* STGI */\n            if ((!(block_h->flags & HF_SVME_MASK)\n                   && !(block_h->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n                || !block_h->pe) {\n                goto illegal_op;\n            }\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_stgi(cpu_env);\n            break;\n        case 0xdd: /* CLGI */\n            if (!(block_h->flags & HF_SVME_MASK) || !block_h->pe) {\n                goto illegal_op;\n            }\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_clgi(cpu_env);\n            break;\n        case 0xde: /* SKINIT */\n            if ((!(block_h->flags & HF_SVME_MASK)\n                 && !(block_h->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n                || !block_h->pe) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_skinit(cpu_env);\n            break;\n        case 0xdf: /* INVLPGA */\n            if (!(block_h->flags & HF_SVME_MASK) || !block_h->pe) {\n                goto illegal_op;\n            }\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_helper_invlpga(cpu_env, tcg_const_i32(block_h->uext - 1));\n            break;\n        CASE_MODRM_MEM_OP(2): /* lgdt */\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_GDTR_WRITE);\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            gen_op_ld_v(block_h, MO_16, cpu_T1, cpu_A0);\n            gen_add_A0_im(block_h, 2);\n            gen_op_ld_v(block_h, CODE64(block_h) + MO_32, cpu_T0, cpu_A0);\n            if (alpha_in == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.cow_header));\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));\n            break;\n        CASE_MODRM_MEM_OP(3): /* lidt */\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_IDTR_WRITE);\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            gen_op_ld_v(block_h, MO_16, cpu_T1, cpu_A0);\n            gen_add_A0_im(block_h, 2);\n            gen_op_ld_v(block_h, CODE64(block_h) + MO_32, cpu_T0, cpu_A0);\n            if (alpha_in == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.cow_header));\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));\n            break;\n        CASE_MODRM_OP(4): /* smsw */\n            gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_READ_CR0);\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));\n            if (CODE64(block_h)) {\n                dst2 = (msrs >> 6) & 3;\n                pix_op = (dst2 != 3 ? MO_16 : block_h->alpha_in);\n            } else {\n                pix_op = MO_16;\n            }\n            gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, OR_TMP0, 1);\n            break;\n        case 0xee: /* rdpkru */\n            if (pred_y & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n            break;\n        case 0xef: /* wrpkru */\n            if (pred_y & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n            break;\n        CASE_MODRM_OP(6): /* lmsw */\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_WRITE_CR0);\n            gen_ldst_modrm(refcount_table_clusters, block_h, msrs, MO_16, OR_TMP0, 0);\n            gen_helper_lmsw(cpu_env, cpu_T0);\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob(block_h);\n            break;\n        CASE_MODRM_MEM_OP(7): /* invlpg */\n            if (block_h->cpl != 0) {\n                gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            gen_helper_invlpg(cpu_env, cpu_A0);\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob(block_h);\n            break;\n        case 0xf8: /* swapgs */\n#ifdef TARGET_X86_64\n            if (CODE64(block_h)) {\n                if (block_h->cpl != 0) {\n                    gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n                } else {\n                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);\n                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,\n                                  offsetof(CPUX86State, kernelgsbase));\n                    tcg_gen_st_tl(cpu_T0, cpu_env,\n                                  offsetof(CPUX86State, kernelgsbase));\n                }\n                break;\n            }\n#endif\n            goto illegal_op;\n        case 0xf9: /* rdtscp */\n            if (!(block_h->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(block_h);\n            gen_jmp_im(pc_start - block_h->cs_base);\n            if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n                gen_io_start();\n            }\n            gen_helper_rdtscp(cpu_env);\n            if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n                gen_io_end();\n                gen_jmp(block_h, block_h->sphb - block_h->cs_base);\n            }\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n    case 0x108: /* invd */\n    case 0x109: /* wbinvd */\n        if (block_h->cpl != 0) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            gen_svm_check_intercept(block_h, pc_start, (as & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n            /* nothing to do */\n        }\n        break;\n    case 0x63: /* arpl or movslS (x86_64) */\n#ifdef TARGET_X86_64\n        if (CODE64(block_h)) {\n            int device;\n            /* d_ot is the size of destination */\n            device = alpha_in;\n            msrs = x86_ldub_code(refcount_table_clusters, block_h);\n            scale = ((msrs >> 3) & 7) | irq;\n            dst2 = (msrs >> 6) & 3;\n            l1ref0 = (msrs & 7) | REX_B(block_h);\n            if (dst2 == 3) {\n                gen_op_mov_v_reg(MO_32, cpu_T0, l1ref0);\n                /* sign extend */\n                if (device == MO_64) {\n                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n                }\n                gen_op_mov_reg_v(device, scale, cpu_T0);\n            } else {\n                gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                gen_op_ld_v(block_h, MO_32 | MO_SIGN, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(device, scale, cpu_T0);\n            }\n        } else\n#endif\n        {\n            TCGLabel *vmsd;\n            TCGv FUNNY_Y_CODE, bsfc, backend, sample_rate;\n            if (!block_h->pe || block_h->vm86)\n                goto illegal_op;\n            FUNNY_Y_CODE = tcg_temp_local_new();\n            bsfc = tcg_temp_local_new();\n            backend = tcg_temp_local_new();\n            pix_op = MO_16;\n            msrs = x86_ldub_code(refcount_table_clusters, block_h);\n            scale = (msrs >> 3) & 7;\n            dst2 = (msrs >> 6) & 3;\n            l1ref0 = msrs & 7;\n            if (dst2 != 3) {\n                gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                gen_op_ld_v(block_h, pix_op, FUNNY_Y_CODE, cpu_A0);\n                sample_rate = tcg_temp_local_new();\n                tcg_gen_mov_tl(sample_rate, cpu_A0);\n            } else {\n                gen_op_mov_v_reg(pix_op, FUNNY_Y_CODE, l1ref0);\n                TCGV_UNUSED(sample_rate);\n            }\n            gen_op_mov_v_reg(pix_op, bsfc, scale);\n            tcg_gen_andi_tl(cpu_tmp0, FUNNY_Y_CODE, 3);\n            tcg_gen_andi_tl(bsfc, bsfc, 3);\n            tcg_gen_movi_tl(backend, 0);\n            vmsd = gen_new_label();\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, bsfc, vmsd);\n            tcg_gen_andi_tl(FUNNY_Y_CODE, FUNNY_Y_CODE, ~3);\n            tcg_gen_or_tl(FUNNY_Y_CODE, FUNNY_Y_CODE, bsfc);\n            tcg_gen_movi_tl(backend, CC_Z);\n            gen_set_label(vmsd);\n            if (dst2 != 3) {\n                gen_op_st_v(block_h, pix_op, FUNNY_Y_CODE, sample_rate);\n                tcg_temp_free(sample_rate);\n           } else {\n                gen_op_mov_reg_v(pix_op, l1ref0, FUNNY_Y_CODE);\n            }\n            gen_compute_eflags(block_h);\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, backend);\n            tcg_temp_free(FUNNY_Y_CODE);\n            tcg_temp_free(bsfc);\n            tcg_temp_free(backend);\n        }\n        break;\n    case 0x102: /* lar */\n    case 0x103: /* lsl */\n        {\n            TCGLabel *vmsd;\n            TCGv FUNNY_Y_CODE;\n            if (!block_h->pe || block_h->vm86)\n                goto illegal_op;\n            pix_op = alpha_in != MO_16 ? MO_32 : MO_16;\n            msrs = x86_ldub_code(refcount_table_clusters, block_h);\n            scale = ((msrs >> 3) & 7) | irq;\n            gen_ldst_modrm(refcount_table_clusters, block_h, msrs, MO_16, OR_TMP0, 0);\n            FUNNY_Y_CODE = tcg_temp_local_new();\n            gen_update_cc_op(block_h);\n            if (as == 0x102) {\n                gen_helper_lar(FUNNY_Y_CODE, cpu_env, cpu_T0);\n            } else {\n                gen_helper_lsl(FUNNY_Y_CODE, cpu_env, cpu_T0);\n            }\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n            vmsd = gen_new_label();\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, vmsd);\n            gen_op_mov_reg_v(pix_op, scale, FUNNY_Y_CODE);\n            gen_set_label(vmsd);\n            set_cc_op(block_h, CC_OP_EFLAGS);\n            tcg_temp_free(FUNNY_Y_CODE);\n        }\n        break;\n    case 0x118:\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        den = (msrs >> 3) & 7;\n        switch(den) {\n        case 0: /* prefetchnta */\n        case 1: /* prefetchnt0 */\n        case 2: /* prefetchnt0 */\n        case 3: /* prefetchnt0 */\n            if (dst2 == 3)\n                goto illegal_op;\n            gen_nop_modrm(refcount_table_clusters, block_h, msrs);\n            /* nothing more to do */\n            break;\n        default: /* nop (multi byte) */\n            gen_nop_modrm(refcount_table_clusters, block_h, msrs);\n            break;\n        }\n        break;\n    case 0x11a:\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        if (block_h->flags & HF_MPX_EN_MASK) {\n            dst2 = (msrs >> 6) & 3;\n            scale = ((msrs >> 3) & 7) | irq;\n            if (pred_y & PREFIX_REPZ) {\n                /* bndcl */\n                if (scale >= 4\n                    || (pred_y & PREFIX_LOCK)\n                    || block_h->uext == MO_16) {\n                    goto illegal_op;\n                }\n                gen_bndck(refcount_table_clusters, block_h, msrs, TCG_COND_LTU, cpu_bndl[scale]);\n            } else if (pred_y & PREFIX_REPNZ) {\n                /* bndcu */\n                if (scale >= 4\n                    || (pred_y & PREFIX_LOCK)\n                    || block_h->uext == MO_16) {\n                    goto illegal_op;\n                }\n                TCGv_i64 notu = tcg_temp_new_i64();\n                tcg_gen_not_i64(notu, cpu_bndu[scale]);\n                gen_bndck(refcount_table_clusters, block_h, msrs, TCG_COND_GTU, notu);\n                tcg_temp_free_i64(notu);\n            } else if (pred_y & PREFIX_DATA) {\n                /* bndmov -- from reg/mem */\n                if (scale >= 4 || block_h->uext == MO_16) {\n                    goto illegal_op;\n                }\n                if (dst2 == 3) {\n                    int reg2 = (msrs & 7) | REX_B(block_h);\n                    if (reg2 >= 4 || (pred_y & PREFIX_LOCK)) {\n                        goto illegal_op;\n                    }\n                    if (block_h->flags & HF_MPX_IU_MASK) {\n                        tcg_gen_mov_i64(cpu_bndl[scale], cpu_bndl[reg2]);\n                        tcg_gen_mov_i64(cpu_bndu[scale], cpu_bndu[reg2]);\n                    }\n                } else {\n                    gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                    if (CODE64(block_h)) {\n                        tcg_gen_qemu_ld_i64(cpu_bndl[scale], cpu_A0,\n                                            block_h->mem_index, MO_LEQ);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n                        tcg_gen_qemu_ld_i64(cpu_bndu[scale], cpu_A0,\n                                            block_h->mem_index, MO_LEQ);\n                    } else {\n                        tcg_gen_qemu_ld_i64(cpu_bndl[scale], cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n                        tcg_gen_qemu_ld_i64(cpu_bndu[scale], cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                    }\n                    /* bnd registers are now in-use */\n                    gen_set_hflag(block_h, HF_MPX_IU_MASK);\n                }\n            } else if (dst2 != 3) {\n                /* bndldx */\n                AddressParts a = gen_lea_modrm_0(refcount_table_clusters, block_h, msrs);\n                if (scale >= 4\n                    || (pred_y & PREFIX_LOCK)\n                    || block_h->uext == MO_16\n                    || a.cow_header < -1) {\n                    goto illegal_op;\n                }\n                if (a.cow_header >= 0) {\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.cow_header], a.disp);\n                } else {\n                    tcg_gen_movi_tl(cpu_A0, 0);\n                }\n                gen_lea_v_seg(block_h, block_h->uext, cpu_A0, a.def_seg, block_h->override);\n                if (a.index >= 0) {\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n                } else {\n                    tcg_gen_movi_tl(cpu_T0, 0);\n                }\n                if (CODE64(block_h)) {\n                    gen_helper_bndldx64(cpu_bndl[scale], cpu_env, cpu_A0, cpu_T0);\n                    tcg_gen_ld_i64(cpu_bndu[scale], cpu_env,\n                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));\n                } else {\n                    gen_helper_bndldx32(cpu_bndu[scale], cpu_env, cpu_A0, cpu_T0);\n                    tcg_gen_ext32u_i64(cpu_bndl[scale], cpu_bndu[scale]);\n                    tcg_gen_shri_i64(cpu_bndu[scale], cpu_bndu[scale], 32);\n                }\n                gen_set_hflag(block_h, HF_MPX_IU_MASK);\n            }\n        }\n        gen_nop_modrm(refcount_table_clusters, block_h, msrs);\n        break;\n    case 0x11b:\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        if (block_h->flags & HF_MPX_EN_MASK) {\n            dst2 = (msrs >> 6) & 3;\n            scale = ((msrs >> 3) & 7) | irq;\n            if (dst2 != 3 && (pred_y & PREFIX_REPZ)) {\n                /* bndmk */\n                if (scale >= 4\n                    || (pred_y & PREFIX_LOCK)\n                    || block_h->uext == MO_16) {\n                    goto illegal_op;\n                }\n                AddressParts a = gen_lea_modrm_0(refcount_table_clusters, block_h, msrs);\n                if (a.cow_header >= 0) {\n                    tcg_gen_extu_tl_i64(cpu_bndl[scale], cpu_regs[a.cow_header]);\n                    if (!CODE64(block_h)) {\n                        tcg_gen_ext32u_i64(cpu_bndl[scale], cpu_bndl[scale]);\n                    }\n                } else if (a.cow_header == -1) {\n                    /* no base register has lower bound of 0 */\n                    tcg_gen_movi_i64(cpu_bndl[scale], 0);\n                } else {\n                    /* rip-relative generates #ud */\n                    goto illegal_op;\n                }\n                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));\n                if (!CODE64(block_h)) {\n                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n                }\n                tcg_gen_extu_tl_i64(cpu_bndu[scale], cpu_A0);\n                /* bnd registers are now in-use */\n                gen_set_hflag(block_h, HF_MPX_IU_MASK);\n                break;\n            } else if (pred_y & PREFIX_REPNZ) {\n                /* bndcn */\n                if (scale >= 4\n                    || (pred_y & PREFIX_LOCK)\n                    || block_h->uext == MO_16) {\n                    goto illegal_op;\n                }\n                gen_bndck(refcount_table_clusters, block_h, msrs, TCG_COND_GTU, cpu_bndu[scale]);\n            } else if (pred_y & PREFIX_DATA) {\n                /* bndmov -- to reg/mem */\n                if (scale >= 4 || block_h->uext == MO_16) {\n                    goto illegal_op;\n                }\n                if (dst2 == 3) {\n                    int reg2 = (msrs & 7) | REX_B(block_h);\n                    if (reg2 >= 4 || (pred_y & PREFIX_LOCK)) {\n                        goto illegal_op;\n                    }\n                    if (block_h->flags & HF_MPX_IU_MASK) {\n                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[scale]);\n                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[scale]);\n                    }\n                } else {\n                    gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                    if (CODE64(block_h)) {\n                        tcg_gen_qemu_st_i64(cpu_bndl[scale], cpu_A0,\n                                            block_h->mem_index, MO_LEQ);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n                        tcg_gen_qemu_st_i64(cpu_bndu[scale], cpu_A0,\n                                            block_h->mem_index, MO_LEQ);\n                    } else {\n                        tcg_gen_qemu_st_i64(cpu_bndl[scale], cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n                        tcg_gen_qemu_st_i64(cpu_bndu[scale], cpu_A0,\n                                            block_h->mem_index, MO_LEUL);\n                    }\n                }\n            } else if (dst2 != 3) {\n                /* bndstx */\n                AddressParts a = gen_lea_modrm_0(refcount_table_clusters, block_h, msrs);\n                if (scale >= 4\n                    || (pred_y & PREFIX_LOCK)\n                    || block_h->uext == MO_16\n                    || a.cow_header < -1) {\n                    goto illegal_op;\n                }\n                if (a.cow_header >= 0) {\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.cow_header], a.disp);\n                } else {\n                    tcg_gen_movi_tl(cpu_A0, 0);\n                }\n                gen_lea_v_seg(block_h, block_h->uext, cpu_A0, a.def_seg, block_h->override);\n                if (a.index >= 0) {\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n                } else {\n                    tcg_gen_movi_tl(cpu_T0, 0);\n                }\n                if (CODE64(block_h)) {\n                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,\n                                        cpu_bndl[scale], cpu_bndu[scale]);\n                } else {\n                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,\n                                        cpu_bndl[scale], cpu_bndu[scale]);\n                }\n            }\n        }\n        gen_nop_modrm(refcount_table_clusters, block_h, msrs);\n        break;\n    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        gen_nop_modrm(refcount_table_clusters, block_h, msrs);\n        break;\n    case 0x120: /* mov reg, crN */\n    case 0x122: /* mov crN, reg */\n        if (block_h->cpl != 0) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            msrs = x86_ldub_code(refcount_table_clusters, block_h);\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n             * AMD documentation (24594.pdf) and testing of\n             * intel 386 and 486 processors all show that the mod bits\n             * are assumed to be 1's, regardless of actual values.\n             */\n            l1ref0 = (msrs & 7) | REX_B(block_h);\n            scale = ((msrs >> 3) & 7) | irq;\n            if (CODE64(block_h))\n                pix_op = MO_64;\n            else\n                pix_op = MO_32;\n            if ((pred_y & PREFIX_LOCK) && (scale == 0) &&\n                (block_h->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n                scale = 8;\n            }\n            switch(scale) {\n            case 0:\n            case 2:\n            case 3:\n            case 4:\n            case 8:\n                gen_update_cc_op(block_h);\n                gen_jmp_im(pc_start - block_h->cs_base);\n                if (as & 2) {\n                    if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n                        gen_io_start();\n                    }\n                    gen_op_mov_v_reg(pix_op, cpu_T0, l1ref0);\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(scale),\n                                         cpu_T0);\n                    if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n                        gen_io_end();\n                    }\n                    gen_jmp_im(block_h->sphb - block_h->cs_base);\n                    gen_eob(block_h);\n                } else {\n                    if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n                        gen_io_start();\n                    }\n                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(scale));\n                    gen_op_mov_reg_v(pix_op, l1ref0, cpu_T0);\n                    if (block_h->cow_header.tb->cflags & CF_USE_ICOUNT) {\n                        gen_io_end();\n                    }\n                }\n                break;\n            default:\n                goto unknown_op;\n            }\n        }\n        break;\n    case 0x121: /* mov reg, drN */\n    case 0x123: /* mov drN, reg */\n        if (block_h->cpl != 0) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            msrs = x86_ldub_code(refcount_table_clusters, block_h);\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n             * AMD documentation (24594.pdf) and testing of\n             * intel 386 and 486 processors all show that the mod bits\n             * are assumed to be 1's, regardless of actual values.\n             */\n            l1ref0 = (msrs & 7) | REX_B(block_h);\n            scale = ((msrs >> 3) & 7) | irq;\n            if (CODE64(block_h))\n                pix_op = MO_64;\n            else\n                pix_op = MO_32;\n            if (scale >= 8) {\n                goto illegal_op;\n            }\n            if (as & 2) {\n                gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_WRITE_DR0 + scale);\n                gen_op_mov_v_reg(pix_op, cpu_T0, l1ref0);\n                tcg_gen_movi_i32(cpu_tmp2_i32, scale);\n                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);\n                gen_jmp_im(block_h->sphb - block_h->cs_base);\n                gen_eob(block_h);\n            } else {\n                gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_READ_DR0 + scale);\n                tcg_gen_movi_i32(cpu_tmp2_i32, scale);\n                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);\n                gen_op_mov_reg_v(pix_op, l1ref0, cpu_T0);\n            }\n        }\n        break;\n    case 0x106: /* clts */\n        if (block_h->cpl != 0) {\n            gen_exception(block_h, EXCP0D_GPF, pc_start - block_h->cs_base);\n        } else {\n            gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_WRITE_CR0);\n            gen_helper_clts(cpu_env);\n            /* abort block because static cpu state changed */\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob(block_h);\n        }\n        break;\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n    case 0x1c3: /* MOVNTI reg, mem */\n        if (!(block_h->cpuid_features & CPUID_SSE2))\n            goto illegal_op;\n        pix_op = mo_64_32(alpha_in);\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        if (dst2 == 3)\n            goto illegal_op;\n        scale = ((msrs >> 3) & 7) | irq;\n        /* generate a generic store */\n        gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, scale, 1);\n        break;\n    case 0x1ae:\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        switch (msrs) {\n        CASE_MODRM_MEM_OP(0): /* fxsave */\n            if (!(block_h->cpuid_features & CPUID_FXSR)\n                || (pred_y & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            if ((block_h->flags & HF_EM_MASK) || (block_h->flags & HF_TS_MASK)) {\n                gen_exception(block_h, EXCP07_PREX, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            gen_helper_fxsave(cpu_env, cpu_A0);\n            break;\n        CASE_MODRM_MEM_OP(1): /* fxrstor */\n            if (!(block_h->cpuid_features & CPUID_FXSR)\n                || (pred_y & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            if ((block_h->flags & HF_EM_MASK) || (block_h->flags & HF_TS_MASK)) {\n                gen_exception(block_h, EXCP07_PREX, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            gen_helper_fxrstor(cpu_env, cpu_A0);\n            break;\n        CASE_MODRM_MEM_OP(2): /* ldmxcsr */\n            if ((block_h->flags & HF_EM_MASK) || !(block_h->flags & HF_OSFXSR_MASK)) {\n                goto illegal_op;\n            }\n            if (block_h->flags & HF_TS_MASK) {\n                gen_exception(block_h, EXCP07_PREX, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, block_h->mem_index, MO_LEUL);\n            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n            break;\n        CASE_MODRM_MEM_OP(3): /* stmxcsr */\n            if ((block_h->flags & HF_EM_MASK) || !(block_h->flags & HF_OSFXSR_MASK)) {\n                goto illegal_op;\n            }\n            if (block_h->flags & HF_TS_MASK) {\n                gen_exception(block_h, EXCP07_PREX, pc_start - block_h->cs_base);\n                break;\n            }\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));\n            gen_op_st_v(block_h, MO_32, cpu_T0, cpu_A0);\n            break;\n        CASE_MODRM_MEM_OP(4): /* xsave */\n            if ((block_h->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (pred_y & (PREFIX_LOCK | PREFIX_DATA\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);\n            break;\n        CASE_MODRM_MEM_OP(5): /* xrstor */\n            if ((block_h->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (pred_y & (PREFIX_LOCK | PREFIX_DATA\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);\n            /* XRSTOR is how MPX is enabled, which changes how\n               we translate.  Thus we need to end the TB.  */\n            gen_update_cc_op(block_h);\n            gen_jmp_im(block_h->sphb - block_h->cs_base);\n            gen_eob(block_h);\n            break;\n        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */\n            if (pred_y & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            if (pred_y & PREFIX_DATA) {\n                /* clwb */\n                if (!(block_h->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {\n                    goto illegal_op;\n                }\n                gen_nop_modrm(refcount_table_clusters, block_h, msrs);\n            } else {\n                /* xsaveopt */\n                if ((block_h->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                    || (block_h->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0\n                    || (pred_y & (PREFIX_REPZ | PREFIX_REPNZ))) {\n                    goto illegal_op;\n                }\n                gen_lea_modrm(refcount_table_clusters, block_h, msrs);\n                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                      cpu_regs[R_EDX]);\n                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);\n            }\n            break;\n        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */\n            if (pred_y & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            if (pred_y & PREFIX_DATA) {\n                /* clflushopt */\n                if (!(block_h->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {\n                    goto illegal_op;\n                }\n            } else {\n                /* clflush */\n                if ((block_h->prefix & (PREFIX_REPZ | PREFIX_REPNZ))\n                    || !(block_h->cpuid_features & CPUID_CLFLUSH)) {\n                    goto illegal_op;\n                }\n            }\n            gen_nop_modrm(refcount_table_clusters, block_h, msrs);\n            break;\n        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */\n        case 0xc8 ... 0xcf: /* rdgsbase (f3 0f ae /1) */\n        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */\n        case 0xd8 ... 0xdf: /* wrgsbase (f3 0f ae /3) */\n            if (CODE64(block_h)\n                && (pred_y & PREFIX_REPZ)\n                && !(pred_y & PREFIX_LOCK)\n                && (block_h->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {\n                TCGv cow_header, pnum, src_start, attachment;\n                /* Preserve hflags bits by testing CR4 at runtime.  */\n                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);\n                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);\n                cow_header = cpu_seg_base[msrs & 8 ? R_GS : R_FS];\n                pnum = cpu_regs[(msrs & 7) | REX_B(block_h)];\n                if (msrs & 0x10) {\n                    /* wr*base */\n                    attachment = cow_header, src_start = pnum;\n                } else {\n                    /* rd*base */\n                    attachment = pnum, src_start = cow_header;\n                }\n                if (block_h->alpha_in == MO_32) {\n                    tcg_gen_ext32u_tl(attachment, src_start);\n                } else {\n                    tcg_gen_mov_tl(attachment, src_start);\n                }\n                break;\n            }\n            goto unknown_op;\n        case 0xf8: /* sfence / pcommit */\n            if (pred_y & PREFIX_DATA) {\n                /* pcommit */\n                if (!(block_h->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)\n                    || (pred_y & PREFIX_LOCK)) {\n                    goto illegal_op;\n                }\n                break;\n            }\n            /* fallthru */\n        case 0xf9 ... 0xff: /* sfence */\n            if (!(block_h->cpuid_features & CPUID_SSE)\n                || (pred_y & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);\n            break;\n        case 0xe8 ... 0xef: /* lfence */\n            if (!(block_h->cpuid_features & CPUID_SSE)\n                || (pred_y & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);\n            break;\n        case 0xf0 ... 0xf7: /* mfence */\n            if (!(block_h->cpuid_features & CPUID_SSE2)\n                || (pred_y & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n    case 0x10d: /* 3DNow! prefetch(w) */\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        dst2 = (msrs >> 6) & 3;\n        if (dst2 == 3)\n            goto illegal_op;\n        gen_nop_modrm(refcount_table_clusters, block_h, msrs);\n        break;\n    case 0x1aa: /* rsm */\n        gen_svm_check_intercept(block_h, pc_start, SVM_EXIT_RSM);\n        if (!(block_h->flags & HF_SMM_MASK))\n            goto illegal_op;\n        gen_update_cc_op(block_h);\n        gen_jmp_im(block_h->sphb - block_h->cs_base);\n        gen_helper_rsm(cpu_env);\n        gen_eob(block_h);\n        break;\n    case 0x1b8: /* SSE4.2 popcnt */\n        if ((pred_y & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n             PREFIX_REPZ)\n            goto illegal_op;\n        if (!(block_h->cpuid_ext_features & CPUID_EXT_POPCNT))\n            goto illegal_op;\n        msrs = x86_ldub_code(refcount_table_clusters, block_h);\n        scale = ((msrs >> 3) & 7) | irq;\n        if (block_h->prefix & PREFIX_DATA) {\n            pix_op = MO_16;\n        } else {\n            pix_op = mo_64_32(alpha_in);\n        }\n        gen_ldst_modrm(refcount_table_clusters, block_h, msrs, pix_op, OR_TMP0, 0);\n        gen_extu(pix_op, cpu_T0);\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n        gen_op_mov_reg_v(pix_op, scale, cpu_T0);\n        set_cc_op(block_h, CC_OP_POPCNT);\n        break;\n    case 0x10e ... 0x10f:\n        /* 3DNow! instructions, ignore prefixes */\n        block_h->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n    case 0x110 ... 0x117:\n    case 0x128 ... 0x12f:\n    case 0x138 ... 0x13a:\n    case 0x150 ... 0x179:\n    case 0x17c ... 0x17f:\n    case 0x1c2:\n    case 0x1c4 ... 0x1c6:\n    case 0x1d0 ... 0x1fe:\n        gen_sse(refcount_table_clusters, block_h, as, pc_start, irq);\n        break;\n    default:\n        goto unknown_op;\n    }\n    return block_h->sphb;\n illegal_op:\n    gen_illegal_opcode(block_h);\n    return block_h->sphb;\n unknown_op:\n    gen_unknown_opcode(refcount_table_clusters, block_h);\n    return block_h->sphb;\n}\n

Success rate:  0.5294117647058824
Successful items count:  18
Total count:  34
Index:  52
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  39.07 min
static int iscsi_open(BlockDriverState *timer_irq, const char *link_down, int delayed_branch)\n{\n    IscsiLun *bpp = timer_irq->opaque;\n    struct iscsi_context *colour2 = NULL;\n    struct n *n = NULL;\n    struct IscsiTask winner;\n    char *sf = NULL;\n    int mm_end;\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n        error_report("iSCSI: Invalid BDRV_SECTOR_SIZE. "\n                     "BDRV_SECTOR_SIZE(%lld) is not a multiple "\n                     "of 512", BDRV_SECTOR_SIZE);\n        return -EINVAL;\n    }\n    n = iscsi_parse_full_url(colour2, link_down);\n    if (n == NULL) {\n        error_report("Failed to parse URL : %s %s", link_down,\n                     iscsi_get_error(colour2));\n        mm_end = -EINVAL;\n        goto failed;\n    }\n    memset(bpp, 0, sizeof(IscsiLun));\n    sf = parse_initiator_name(n->target);\n    colour2 = iscsi_create_context(sf);\n    if (colour2 == NULL) {\n        error_report("iSCSI: Failed to create iSCSI context.");\n        mm_end = -ENOMEM;\n        goto failed;\n    }\n    if (iscsi_set_targetname(colour2, n->target)) {\n        error_report("iSCSI: Failed to set target name.");\n        mm_end = -EINVAL;\n        goto failed;\n    }\n    if (n->user != NULL) {\n        mm_end = iscsi_set_initiator_username_pwd(colour2, n->user,\n                                              n->passwd);\n        if (mm_end != 0) {\n            error_report("Failed to set initiator username and password");\n            mm_end = -EINVAL;\n            goto failed;\n        }\n    }\n    /* check if we got CHAP username/password via the options */\n    if (parse_chap(colour2, n->target) != 0) {\n        error_report("iSCSI: Failed to set CHAP user/password");\n        mm_end = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_set_session_type(colour2, ISCSI_SESSION_NORMAL) != 0) {\n        error_report("iSCSI: Failed to set session type to normal.");\n        mm_end = -EINVAL;\n        goto failed;\n    }\n    iscsi_set_header_digest(colour2, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n    /* check if we got HEADER_DIGEST via the options */\n    parse_header_digest(colour2, n->target);\n    winner.bpp = bpp;\n    winner.status = 0;\n    winner.complete = 0;\n    winner.timer_irq = timer_irq;\n    bpp->colour2 = colour2;\n    bpp->lun   = n->lun;\n    if (iscsi_full_connect_async(colour2, n->portal, n->lun,\n                                 iscsi_connect_cb, &winner)\n        != 0) {\n        error_report("iSCSI: Failed to start async connect.");\n        mm_end = -EINVAL;\n        goto failed;\n    }\n    while (!winner.complete) {\n        iscsi_set_events(bpp);\n        qemu_aio_wait();\n    }\n    if (winner.status != 0) {\n        error_report("iSCSI: Failed to connect to LUN : %s",\n                     iscsi_get_error(colour2));\n        mm_end = -EINVAL;\n        goto failed;\n    }\n    if (n != NULL) {\n        iscsi_destroy_url(n);\n    }\n    /* Medium changer or tape. We dont have any emulation for this so this must\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n     * to read from the device to guess the image format.\n     */\n    if (bpp->type == TYPE_MEDIUM_CHANGER ||\n        bpp->type == TYPE_TAPE) {\n        timer_irq->sg = 1;\n    }\n    return 0;\nfailed:\n    if (sf != NULL) {\n        g_free(sf);\n    }\n    if (n != NULL) {\n        iscsi_destroy_url(n);\n    }\n    if (colour2 != NULL) {\n        iscsi_destroy_context(colour2);\n    }\n    memset(bpp, 0, sizeof(IscsiLun));\n    return mm_end;\n}\n

Success rate:  0.5294117647058824
Successful items count:  18
Total count:  34
Index:  53
====================================================================================================
>> ACC! sub_dx => cblkno (0.00000 => 0.29314)
>> ACC! req => child (0.29314 => 0.29416)
>> ACC! cantitii2_tiontzle_codec_n => oGfb_alp0lstDtsis_aetiop (0.00000 => 0.28248)
>> ACC! hanpencluster_Fse9t => trre_numbebounub_tr (0.28248 => 0.28381)
Greedy Attack Success!!!
Example time cost:  0.66 min
ALL examples time cost:  39.73 min
static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *oGfb_alp0lstDtsis_aetiop,\n                                           const void *IDE_DE_quanitizationtion,\n                                           size_t tsInChun__bble_refcount_t)\n{\n    struct virtio_net_hdr *trre_numbebounub_tr;\n    bool yiza6ioncing_aeftweigNa6, tioninpicture_numbfile_pat, elected_stpredictor_c, attive_bits_quanterEel_b;\n    uint8_t *lected_stsredndtare_nb_;\n    int histJer8ubtgyleaitonDWTai;\n    if (!vmxnet_rx_pkt_has_virt_hdr(oGfb_alp0lstDtsis_aetiop)) {\n        return;\n    }\n    trre_numbebounub_tr = vmxnet_rx_pkt_get_vhdr(oGfb_alp0lstDtsis_aetiop);\n    if (!VMXNET_FLAG_IS_SET(trre_numbebounub_tr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n        return;\n    }\n    vmxnet_rx_pkt_get_protocols(oGfb_alp0lstDtsis_aetiop, &yiza6ioncing_aeftweigNa6, &tioninpicture_numbfile_pat, &attive_bits_quanterEel_b, &elected_stpredictor_c);\n    if (!(yiza6ioncing_aeftweigNa6 || tioninpicture_numbfile_pat) || !(elected_stpredictor_c || attive_bits_quanterEel_b)) {\n        return;\n    }\n    vmxnet3_dump_virt_hdr(trre_numbebounub_tr);\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n    if (tsInChun__bble_refcount_t < (trre_numbebounub_tr->csum_start + trre_numbebounub_tr->csum_offset + 2)) {\n        VMW_PKPRN("packet len:%d < csum_start(%d) + csum_offset(%d) + 2, "\n                  "cannot calculate checksum",\n                  histJer8ubtgyleaitonDWTai, trre_numbebounub_tr->csum_start, trre_numbebounub_tr->csum_offset);\n        return;\n    }\n    lected_stsredndtare_nb_ = (uint8_t *)IDE_DE_quanitizationtion + trre_numbebounub_tr->csum_start;\n    histJer8ubtgyleaitonDWTai = tsInChun__bble_refcount_t - trre_numbebounub_tr->csum_start;\n    /* Put the checksum obtained into the packet */\n    stw_be_p(lected_stsredndtare_nb_ + trre_numbebounub_tr->csum_offset, net_raw_checksum(lected_stsredndtare_nb_, histJer8ubtgyleaitonDWTai));\n    trre_numbebounub_tr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n    trre_numbebounub_tr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n}\n

Success rate:  0.5428571428571428
Successful items count:  19
Total count:  35
Index:  54
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  39.74 min
CommandInfoList *qmp_query_commands(Error **src_hz1)\n{\n    CommandInfoList *hwdef = NULL;\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &hwdef);\n    return hwdef;\n}\n

Success rate:  0.5428571428571428
Successful items count:  19
Total count:  35
Index:  55
====================================================================================================
>> ACC! ap => dest_byte_c (0.00000 => 0.37430)
>> ACC! band => num_cq_events (0.37430 => 0.39052)
Greedy Attack Success!!!
Example time cost:  0.72 min
ALL examples time cost:  40.46 min
static int decode_blocks(ALSDecContext *num_cq_events, unsigned int initrd_filename,\n                         unsigned int layno, const unsigned int *input_buffer_size,\n                         unsigned int *reconstructed_nal)\n{\n    ALSSpecificConfig *vhost_fds = &num_cq_events->vhost_fds;\n    unsigned int offset = 0;\n    unsigned int isudp;\n    ALSBlockData dest_byte_c[2] = { { 0 } };\n    dest_byte_c[0].ra_block         = initrd_filename;\n    dest_byte_c[0].const_block      = num_cq_events->const_block;\n    dest_byte_c[0].shift_lsbs       = num_cq_events->shift_lsbs;\n    dest_byte_c[0].opt_order        = num_cq_events->opt_order;\n    dest_byte_c[0].store_prev_samples = num_cq_events->store_prev_samples;\n    dest_byte_c[0].use_ltp          = num_cq_events->use_ltp;\n    dest_byte_c[0].ltp_lag          = num_cq_events->ltp_lag;\n    dest_byte_c[0].ltp_gain         = num_cq_events->ltp_gain[0];\n    dest_byte_c[0].quant_cof        = num_cq_events->quant_cof[0];\n    dest_byte_c[0].lpc_cof          = num_cq_events->lpc_cof[0];\n    dest_byte_c[0].prev_raw_samples = num_cq_events->prev_raw_samples;\n    dest_byte_c[0].reconstructed_nal        = *reconstructed_nal;\n    dest_byte_c[1].ra_block         = initrd_filename;\n    dest_byte_c[1].const_block      = num_cq_events->const_block;\n    dest_byte_c[1].shift_lsbs       = num_cq_events->shift_lsbs;\n    dest_byte_c[1].opt_order        = num_cq_events->opt_order;\n    dest_byte_c[1].store_prev_samples = num_cq_events->store_prev_samples;\n    dest_byte_c[1].use_ltp          = num_cq_events->use_ltp;\n    dest_byte_c[1].ltp_lag          = num_cq_events->ltp_lag;\n    dest_byte_c[1].ltp_gain         = num_cq_events->ltp_gain[0];\n    dest_byte_c[1].quant_cof        = num_cq_events->quant_cof[0];\n    dest_byte_c[1].lpc_cof          = num_cq_events->lpc_cof[0];\n    dest_byte_c[1].prev_raw_samples = num_cq_events->prev_raw_samples;\n    dest_byte_c[1].reconstructed_nal        = *(reconstructed_nal + 1);\n    // decode all blocks\n    for (isudp = 0; isudp < num_cq_events->num_blocks; isudp++) {\n        unsigned int nvhosts;\n        dest_byte_c[0].block_length = input_buffer_size[isudp];\n        dest_byte_c[1].block_length = input_buffer_size[isudp];\n        dest_byte_c[0].raw_samples  = num_cq_events->raw_samples[layno    ] + offset;\n        dest_byte_c[1].raw_samples  = num_cq_events->raw_samples[layno + 1] + offset;\n        dest_byte_c[0].raw_other    = dest_byte_c[1].raw_samples;\n        dest_byte_c[1].raw_other    = dest_byte_c[0].raw_samples;\n        if(read_decode_block(num_cq_events, &dest_byte_c[0]) || read_decode_block(num_cq_events, &dest_byte_c[1])) {\n            // damaged block, write zero for the rest of the frame\n            zero_remaining(isudp, num_cq_events->num_blocks, input_buffer_size, dest_byte_c[0].raw_samples);\n            zero_remaining(isudp, num_cq_events->num_blocks, input_buffer_size, dest_byte_c[1].raw_samples);\n            return -1;\n        }\n        // reconstruct joint-stereo blocks\n        if (dest_byte_c[0].reconstructed_nal) {\n            if (dest_byte_c[1].reconstructed_nal)\n                av_log(num_cq_events->avctx, AV_LOG_WARNING, "Invalid channel pair!\n");\n            for (nvhosts = 0; nvhosts < input_buffer_size[isudp]; nvhosts++)\n                dest_byte_c[0].raw_samples[nvhosts] = dest_byte_c[1].raw_samples[nvhosts] - dest_byte_c[0].raw_samples[nvhosts];\n        } else if (dest_byte_c[1].reconstructed_nal) {\n            for (nvhosts = 0; nvhosts < input_buffer_size[isudp]; nvhosts++)\n                dest_byte_c[1].raw_samples[nvhosts] = dest_byte_c[1].raw_samples[nvhosts] + dest_byte_c[0].raw_samples[nvhosts];\n        }\n        offset  += input_buffer_size[isudp];\n        dest_byte_c[0].ra_block = 0;\n        dest_byte_c[1].ra_block = 0;\n    }\n    // store carryover raw samples,\n    // the others channel raw samples are stored by the calling function.\n    memmove(num_cq_events->raw_samples[layno] - vhost_fds->max_order,\n            num_cq_events->raw_samples[layno] - vhost_fds->max_order + vhost_fds->frame_length,\n            sizeof(*num_cq_events->raw_samples[layno]) * vhost_fds->max_order);\n    return 0;\n}\n

Success rate:  0.5555555555555556
Successful items count:  20
Total count:  36
Index:  56
====================================================================================================
>> ACC! sddev => p1_or_q1_org (0.00000 => 0.37543)
>> ACC! model => cylinders (0.37543 => 0.37583)
Greedy Attack Success!!!
Example time cost:  0.91 min
ALL examples time cost:  41.37 min
static int write_f(int xendev, char **p1_or_q1_org)\n{\n    struct timeval sbi_cpu_irq, memaddr;\n    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;\n    int ci, anon_count;\n    char *dt;\n    int64_t cylinders;\n    int fe;\n    /* Some compilers get confused and warn if this is not initialized.  */\n    int total = 0;\n    int pattern = 0xcd;\n    while ((ci = getopt(xendev, p1_or_q1_org, "bCpP:q")) != EOF) {\n        switch (ci) {\n        case 'b':\n            bflag = 1;\n            break;\n        case 'C':\n            Cflag = 1;\n            break;\n        case 'p':\n            pflag = 1;\n            break;\n        case 'P':\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return 0;\n            }\n            break;\n        case 'q':\n            qflag = 1;\n            break;\n        default:\n            return command_usage(&write_cmd);\n        }\n    }\n    if (version_id != xendev - 2) {\n        return command_usage(&write_cmd);\n    }\n    if (bflag && pflag) {\n        printf("-b and -p cannot be specified at the same time\n");\n        return 0;\n    }\n    cylinders = cvtnum(p1_or_q1_org[version_id]);\n    if (cylinders < 0) {\n        printf("non-numeric length argument -- %s\n", p1_or_q1_org[version_id]);\n        return 0;\n    }\n    version_id++;\n    fe = cvtnum(p1_or_q1_org[version_id]);\n    if (fe < 0) {\n        printf("non-numeric length argument -- %s\n", p1_or_q1_org[version_id]);\n        return 0;\n    }\n    if (!pflag) {\n        if (cylinders & 0x1ff) {\n            printf("offset %" PRId64 " is not sector aligned\n",\n                   cylinders);\n            return 0;\n        }\n        if (fe & 0x1ff) {\n            printf("count %d is not sector aligned\n",\n                   fe);\n            return 0;\n        }\n    }\n    dt = qemu_io_alloc(fe, pattern);\n    gettimeofday(&sbi_cpu_irq, NULL);\n    if (pflag) {\n        anon_count = do_pwrite(dt, cylinders, fe, &total);\n    } else if (bflag) {\n        anon_count = do_save_vmstate(dt, cylinders, fe, &total);\n    } else {\n        anon_count = do_write(dt, cylinders, fe, &total);\n    }\n    gettimeofday(&memaddr, NULL);\n    if (anon_count < 0) {\n        printf("write failed: %s\n", strerror(-anon_count));\n        goto out;\n    }\n    if (qflag) {\n        goto out;\n    }\n    /* Finally, report back -- -C gives a parsable format */\n    memaddr = tsub(memaddr, sbi_cpu_irq);\n    print_report("wrote", &memaddr, cylinders, fe, total, anon_count, Cflag);\nout:\n    qemu_io_free(dt);\n    return 0;\n}\n

Success rate:  0.5675675675675675
Successful items count:  21
Total count:  37
Index:  57
====================================================================================================
>> ACC! index => aud (0.00000 => 0.35945)
>> ACC! src_start => ai (0.35945 => 0.36075)
>> ACC! POeeditlQ_codc_neam => MAX4DWTXLE_enc_elustes (0.00000 => 0.35227)
>> ACC! iterOspicture_nuable_clus => able_clusiterspiOcture_n (0.35227 => 0.35417)
Insert Attack Success!!!
Example time cost:  1.47 min
ALL examples time cost:  42.84 min
printf(""); static int libopenjpeg_copy_packed12(AVCodecContext *_tndxfunsubtitle_ce, const AVFrame *srefcrHnomessubtitsrefcr, opj_image_t *able_clusiterspiOcture_n)\n{\n    int MAX4DWTXLE_enc_elustes;  \n    int _nntIefgsproriger_node_, nenb_SnoNbdHtitlusrture;  \n    int *nc_sizyts_per_is_less_;  \n    int _betaoreqg_osteterskern;  \n    const int numcomps  = able_clusiterspiOcture_n->numcomps;  \n    uint16_t *t_1errbion_uantitiztionfnte = (uint16_t *)srefcrHnomessubtitsrefcr->data[0];  \n    for (MAX4DWTXLE_enc_elustes = 0;   MAX4DWTXLE_enc_elustes < numcomps;   ++MAX4DWTXLE_enc_elustes) {\n        if (able_clusiterspiOcture_n->comps[MAX4DWTXLE_enc_elustes].w > srefcrHnomessubtitsrefcr->linesize[0] / numcomps) {\n            av_log(_tndxfunsubtitle_ce, AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n");  \n            return 0;  \n        }\n    }\n    for (MAX4DWTXLE_enc_elustes = 0;   MAX4DWTXLE_enc_elustes < numcomps;  char temp_variable[100] = "is_lon_quantitiztionfnme";   ++MAX4DWTXLE_enc_elustes) {\n        for (nenb_SnoNbdHtitlusrture = 0;  printf("");   nenb_SnoNbdHtitlusrture < _tndxfunsubtitle_ce->height;   ++nenb_SnoNbdHtitlusrture) {\n            nc_sizyts_per_is_less_ = able_clusiterspiOcture_n->comps[MAX4DWTXLE_enc_elustes].data + nenb_SnoNbdHtitlusrture * able_clusiterspiOcture_n->comps[MAX4DWTXLE_enc_elustes].w;  \n            _betaoreqg_osteterskern = nenb_SnoNbdHtitlusrture * (srefcrHnomessubtitsrefcr->linesize[0] / 2) + MAX4DWTXLE_enc_elustes;  \n            for (_nntIefgsproriger_node_ = 0;   _nntIefgsproriger_node_ < _tndxfunsubtitle_ce->width;   ++_nntIefgsproriger_node_) {\n                nc_sizyts_per_is_less_[_nntIefgsproriger_node_] = t_1errbion_uantitiztionfnte[_betaoreqg_osteterskern] >> 4;  \n                _betaoreqg_osteterskern += numcomps;  \n            }\n            for (;   _nntIefgsproriger_node_ < able_clusiterspiOcture_n->comps[MAX4DWTXLE_enc_elustes].w;   ++_nntIefgsproriger_node_) {\n                nc_sizyts_per_is_less_[_nntIefgsproriger_node_] = nc_sizyts_per_is_less_[_nntIefgsproriger_node_ - 1];  \n            }\n        }\n        for (;   nenb_SnoNbdHtitlusrture < able_clusiterspiOcture_n->comps[MAX4DWTXLE_enc_elustes].h;   ++nenb_SnoNbdHtitlusrture) {\n            nc_sizyts_per_is_less_ = able_clusiterspiOcture_n->comps[MAX4DWTXLE_enc_elustes].data + nenb_SnoNbdHtitlusrture * able_clusiterspiOcture_n->comps[MAX4DWTXLE_enc_elustes].w;  \n            for (_nntIefgsproriger_node_ = 0;   _nntIefgsproriger_node_ < able_clusiterspiOcture_n->comps[MAX4DWTXLE_enc_elustes].w;   ++_nntIefgsproriger_node_) {\n                nc_sizyts_per_is_less_[_nntIefgsproriger_node_] = nc_sizyts_per_is_less_[_nntIefgsproriger_node_ - able_clusiterspiOcture_n->comps[MAX4DWTXLE_enc_elustes].w];  \n            }\n        }\n    }\n    return 1;  \n}\n;  ;  ; \n

Success rate:  0.5789473684210527
Successful items count:  22
Total count:  38
Index:  58
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  42.85 min
static void build_feed_streams(void)\n{\n    FFStream *sps, *stbuf;\n    int version_id;\n    /* gather all streams */\n    for(sps = first_stream; sps != NULL; sps = sps->next) {\n        stbuf = sps->stbuf;\n        if (stbuf) {\n            if (!sps->is_feed) {\n                /* we handle a stream coming from a feed */\n                for(version_id=0;version_id<sps->nb_streams;version_id++)\n                    sps->feed_streams[version_id] = add_av_stream(stbuf, sps->streams[version_id]);\n            }\n        }\n    }\n    /* gather all streams */\n    for(sps = first_stream; sps != NULL; sps = sps->next) {\n        stbuf = sps->stbuf;\n        if (stbuf) {\n            if (sps->is_feed) {\n                for(version_id=0;version_id<sps->nb_streams;version_id++)\n                    sps->feed_streams[version_id] = version_id;\n            }\n        }\n    }\n    /* create feed files if needed */\n    for(stbuf = first_feed; stbuf != NULL; stbuf = stbuf->next_feed) {\n        int from;\n        if (url_exist(stbuf->feed_filename)) {\n            /* See if it matches */\n            AVFormatContext *main_stride;\n            int matches = 0;\n            if (av_open_input_file(&main_stride, stbuf->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {\n                /* Now see if it matches */\n                if (main_stride->nb_streams == stbuf->nb_streams) {\n                    matches = 1;\n                    for(version_id=0;version_id<main_stride->nb_streams;version_id++) {\n                        AVStream *dest_byte_c, *uart_irq;\n                        dest_byte_c = stbuf->streams[version_id];\n                        uart_irq = main_stride->streams[version_id];\n                        if (dest_byte_c->index != uart_irq->index ||\n                            dest_byte_c->id != uart_irq->id) {\n                            http_log("Index & Id do not match for stream %d (%s)\n",\n                                   version_id, stbuf->feed_filename);\n                            matches = 0;\n                        } else {\n                            AVCodecContext *max_cpus, *high_bit_depth;\n                            max_cpus = dest_byte_c->codec;\n                            high_bit_depth = uart_irq->codec;\n#define CHECK_CODEC(x)  (ccf->x != ccs->x)\n                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n                                http_log("Codecs do not match for stream %d\n", version_id);\n                                matches = 0;\n                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {\n                                http_log("Codec bitrates do not match for stream %d\n", version_id);\n                                matches = 0;\n                            } else if (max_cpus->codec_type == AVMEDIA_TYPE_VIDEO) {\n                                if (CHECK_CODEC(time_base.den) ||\n                                    CHECK_CODEC(time_base.num) ||\n                                    CHECK_CODEC(width) ||\n                                    CHECK_CODEC(height)) {\n                                    http_log("Codec width, height and framerate do not match for stream %d\n", version_id);\n                                    matches = 0;\n                                }\n                            } else if (max_cpus->codec_type == AVMEDIA_TYPE_AUDIO) {\n                                if (CHECK_CODEC(sample_rate) ||\n                                    CHECK_CODEC(channels) ||\n                                    CHECK_CODEC(frame_size)) {\n                                    http_log("Codec sample_rate, channels, frame_size do not match for stream %d\n", version_id);\n                                    matches = 0;\n                                }\n                            } else {\n                                http_log("Unknown codec type\n");\n                                matches = 0;\n                            }\n                        }\n                        if (!matches)\n                            break;\n                    }\n                } else\n                    http_log("Deleting feed file '%s' as stream counts differ (%d != %d)\n",\n                        stbuf->feed_filename, main_stride->nb_streams, stbuf->nb_streams);\n                av_close_input_file(main_stride);\n            } else\n                http_log("Deleting feed file '%s' as it appears to be corrupt\n",\n                        stbuf->feed_filename);\n            if (!matches) {\n                if (stbuf->readonly) {\n                    http_log("Unable to delete feed file '%s' as it is marked readonly\n",\n                        stbuf->feed_filename);\n                    exit(1);\n                }\n                unlink(stbuf->feed_filename);\n            }\n        }\n        if (!url_exist(stbuf->feed_filename)) {\n            AVFormatContext s1 = {0}, *main_stride = &s1;\n            if (stbuf->readonly) {\n                http_log("Unable to create feed file '%s' as it is marked readonly\n",\n                    stbuf->feed_filename);\n                exit(1);\n            }\n            /* only write the header of the ffm file */\n            if (avio_open(&main_stride->pb, stbuf->feed_filename, AVIO_FLAG_WRITE) < 0) {\n                http_log("Could not open output feed file '%s'\n",\n                         stbuf->feed_filename);\n                exit(1);\n            }\n            main_stride->oformat = stbuf->fmt;\n            main_stride->nb_streams = stbuf->nb_streams;\n            for(version_id=0;version_id<main_stride->nb_streams;version_id++) {\n                AVStream *e3;\n                e3 = stbuf->streams[version_id];\n                main_stride->streams[version_id] = e3;\n            }\n            av_set_parameters(main_stride, NULL);\n            if (av_write_header(main_stride) < 0) {\n                http_log("Container doesn't supports the required parameters\n");\n                exit(1);\n            }\n            /* XXX: need better api */\n            av_freep(&main_stride->priv_data);\n            avio_close(main_stride->pb);\n        }\n        /* get feed size and write index */\n        from = open(stbuf->feed_filename, O_RDONLY);\n        if (from < 0) {\n            http_log("Could not open output feed file '%s'\n",\n                    stbuf->feed_filename);\n            exit(1);\n        }\n        stbuf->feed_write_index = FFMAX(ffm_read_write_index(from), FFM_PACKET_SIZE);\n        stbuf->feed_size = lseek(from, 0, SEEK_END);\n        /* ensure that we do not wrap before the end of file */\n        if (stbuf->feed_max_size && stbuf->feed_max_size < stbuf->feed_size)\n            stbuf->feed_max_size = stbuf->feed_size;\n        close(from);\n    }\n}\n

Success rate:  0.5789473684210527
Successful items count:  22
Total count:  38
Index:  59
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  42.86 min
static void do_interrupt64(CPUX86State *channels, int motion_ptr, int file,\n                           int opn, target_ulong disk, int mode)\n{\n    SegmentCache *gain;\n    target_ulong listen_addr;\n    int src_hz0, q0_or_p0_org, nb_samples, channelNum, insn;\n    int mtrr_top_bits, ipl_cpu;\n    uint32_t interlacing_shift, mb_type, rv, unmap;\n    target_ulong arg2, filters, iov;\n    mtrr_top_bits = 0;\n    if (!file && !mode) {\n        mtrr_top_bits = exception_has_error_code(motion_ptr);\n    }\n    if (file) {\n        arg2 = disk;\n    } else {\n        arg2 = channels->eip;\n    }\n    gain = &channels->idt;\n    if (motion_ptr * 16 + 15 > gain->limit) {\n        raise_exception_err(channels, EXCP0D_GPF, motion_ptr * 16 + 2);\n    }\n    listen_addr = gain->base + motion_ptr * 16;\n    interlacing_shift = cpu_ldl_kernel(channels, listen_addr);\n    mb_type = cpu_ldl_kernel(channels, listen_addr + 4);\n    rv = cpu_ldl_kernel(channels, listen_addr + 8);\n    /* check gate type */\n    src_hz0 = (mb_type >> DESC_TYPE_SHIFT) & 0x1f;\n    switch (src_hz0) {\n    case 14: /* 386 interrupt gate */\n    case 15: /* 386 trap gate */\n        break;\n    default:\n        raise_exception_err(channels, EXCP0D_GPF, motion_ptr * 16 + 2);\n        break;\n    }\n    q0_or_p0_org = (mb_type >> DESC_DPL_SHIFT) & 3;\n    channelNum = channels->hflags & HF_CPL_MASK;\n    /* check privilege if software int */\n    if (file && q0_or_p0_org < channelNum) {\n        raise_exception_err(channels, EXCP0D_GPF, motion_ptr * 16 + 2);\n    }\n    /* check valid bit */\n    if (!(mb_type & DESC_P_MASK)) {\n        raise_exception_err(channels, EXCP0B_NOSEG, motion_ptr * 16 + 2);\n    }\n    nb_samples = interlacing_shift >> 16;\n    iov = ((target_ulong)rv << 32) | (mb_type & 0xffff0000) | (interlacing_shift & 0x0000ffff);\n    insn = mb_type & 7;\n    if ((nb_samples & 0xfffc) == 0) {\n        raise_exception_err(channels, EXCP0D_GPF, 0);\n    }\n    if (load_segment(channels, &interlacing_shift, &mb_type, nb_samples) != 0) {\n        raise_exception_err(channels, EXCP0D_GPF, nb_samples & 0xfffc);\n    }\n    if (!(mb_type & DESC_S_MASK) || !(mb_type & (DESC_CS_MASK))) {\n        raise_exception_err(channels, EXCP0D_GPF, nb_samples & 0xfffc);\n    }\n    q0_or_p0_org = (mb_type >> DESC_DPL_SHIFT) & 3;\n    if (q0_or_p0_org > channelNum) {\n        raise_exception_err(channels, EXCP0D_GPF, nb_samples & 0xfffc);\n    }\n    if (!(mb_type & DESC_P_MASK)) {\n        raise_exception_err(channels, EXCP0B_NOSEG, nb_samples & 0xfffc);\n    }\n    if (!(mb_type & DESC_L_MASK) || (mb_type & DESC_B_MASK)) {\n        raise_exception_err(channels, EXCP0D_GPF, nb_samples & 0xfffc);\n    }\n    if ((!(mb_type & DESC_C_MASK) && q0_or_p0_org < channelNum) || insn != 0) {\n        /* to inner privilege */\n        ipl_cpu = 1;\n        filters = get_rsp_from_tss(channels, insn != 0 ? insn + 3 : q0_or_p0_org);\n        unmap = 0;\n    } else if ((mb_type & DESC_C_MASK) || q0_or_p0_org == channelNum) {\n        /* to same privilege */\n        if (channels->eflags & VM_MASK) {\n            raise_exception_err(channels, EXCP0D_GPF, nb_samples & 0xfffc);\n        }\n        ipl_cpu = 0;\n        filters = channels->regs[R_ESP];\n        q0_or_p0_org = channelNum;\n    } else {\n        raise_exception_err(channels, EXCP0D_GPF, nb_samples & 0xfffc);\n        ipl_cpu = 0; /* avoid warning */\n        filters = 0; /* avoid warning */\n    }\n    filters &= ~0xfLL; /* align stack */\n    PUSHQ(filters, channels->segs[R_SS].nb_samples);\n    PUSHQ(filters, channels->regs[R_ESP]);\n    PUSHQ(filters, cpu_compute_eflags(channels));\n    PUSHQ(filters, channels->segs[R_CS].nb_samples);\n    PUSHQ(filters, arg2);\n    if (mtrr_top_bits) {\n        PUSHQ(filters, opn);\n    }\n    /* interrupt gate clear IF mask */\n    if ((src_hz0 & 1) == 0) {\n        channels->eflags &= ~IF_MASK;\n    }\n    channels->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n    if (ipl_cpu) {\n        unmap = 0 | q0_or_p0_org;\n        cpu_x86_load_seg_cache(channels, R_SS, unmap, 0, 0, 0);\n    }\n    channels->regs[R_ESP] = filters;\n    nb_samples = (nb_samples & ~3) | q0_or_p0_org;\n    cpu_x86_load_seg_cache(channels, R_CS, nb_samples,\n                   get_seg_base(interlacing_shift, mb_type),\n                   get_seg_limit(interlacing_shift, mb_type),\n                   mb_type);\n    channels->eip = iov;\n}\n

Success rate:  0.5789473684210527
Successful items count:  22
Total count:  38
Index:  60
====================================================================================================
>> ACC! new_table => q0_or_p0_org (0.00000 => 0.19719)
>> ACC! got_output => date_utc_buf (0.19719 => 0.22161)
>> ACC! nstercks_cluste1santitiz => izt_backing_fm_cluste1s (0.00000 => 0.32575)
>> ACC! ct_desydancnG_esizeker => _noXis_le_thNn_betaObiS (0.32575 => 0.32956)
Greedy Attack Success!!!
Example time cost:  0.56 min
ALL examples time cost:  43.41 min
void palette8tobgr24(const uint8_t *izVation_nNumguesusewruct, uint8_t *_noXis_le_thNn_betaObiS, long ceizeFfNNY_ec_namee6, const uint8_t *tOion_quantitizagtionfi8ltL)\n{\n	long izt_backing_fm_cluste1s;\n/*\n	writes 1 byte o much and might cause alignment issues on some architectures?\n	for(i=0; i<num_pixels; i++)\n		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n*/\n	for(izt_backing_fm_cluste1s=0; izt_backing_fm_cluste1s<ceizeFfNNY_ec_namee6; izt_backing_fm_cluste1s++)\n	{\n		//FIXME slow?\n		_noXis_le_thNn_betaObiS[0]= tOion_quantitizagtionfi8ltL[ izVation_nNumguesusewruct[izt_backing_fm_cluste1s]*4+0 ];\n		_noXis_le_thNn_betaObiS[1]= tOion_quantitizagtionfi8ltL[ izVation_nNumguesusewruct[izt_backing_fm_cluste1s]*4+1 ];\n		_noXis_le_thNn_betaObiS[2]= tOion_quantitizagtionfi8ltL[ izVation_nNumguesusewruct[izt_backing_fm_cluste1s]*4+2 ];\n		_noXis_le_thNn_betaObiS+= 3;\n	}\n}\n

Success rate:  0.5897435897435898
Successful items count:  23
Total count:  39
Index:  61
====================================================================================================
>> ACC! ofilter => argc (0.00000 => 0.33704)
>> ACC! rtsp_st => device_name (0.33704 => 0.34367)
>> ACC! pred3ction_q_sizze => rediction_quantittizzaFDion (0.00000 => 0.32626)
>> ACC! lusbersxtor_nuclustnr_s => _tableX_clustersxtor_ble_ (0.32626 => 0.32725)
Insert Attack Success!!!
Example time cost:  2.63 min
ALL examples time cost:  46.05 min
if (0): { printf("bee_clustlrsUtitleNcasub") };static inline void codeblock(DiracContext *less5_th1an_betj_is_less_th, SubBand *nceE_buster_tb_epihmst_ee,\n                             GetBitContext *dexdictor_snottceY_codel_, DiracArith *uanTttizWtntorURcas_th,\n                             int left, int right, int diDtizaest_AspcationEtiona, int c_namtershChrcount_tab,\n                             int _tableX_clustersxtor_ble_, int treixt_b6ckingtitizationTre)\n{\n    int kernel_ture_pantKtization, refcoeDnt_tabOu_indexy, rediction_quantittizzaFDion;while (0): { print("lustersrlustount_tabl1eJi"); }  \n    int _opere_u0btitlesn_uant6it, nputk_buffyerle_cdf3ount_F;  \n    IDWTELEM *t_tableJirlusYter_nb_secn;while (0): { print("uscerersunt_tableJindexr"); }  \n    /* check for any coded coefficients in this codeblock */\n    if (!_tableX_clustersxtor_ble_) {\n        if (treixt_b6ckingtitizationTre)\n            rediction_quantittizzaFDion = dirac_get_arith_bit(uanTttizWtntorURcas_th, CTX_ZERO_BLOCK);while (0): { print("_table_clustersUtitleNca"); }  char temp_variable[100] = "subUtitleNcadec_nome";while (0): { print("_table_clustersUtitleNca"); }  printf("");  \n        else\n            rediction_quantittizzaFDion = get_bits1(dexdictor_snottceY_codel_); printf("");  char temp_variable[100] = "sters_ta_lesutount_table";  \n        if (rediction_quantittizzaFDion)\n            return;  \n    }\n    if (less5_th1an_betj_is_less_th->codeblock_mode && !(less5_th1an_betj_is_less_th->old_delta_quant && _tableX_clustersxtor_ble_)) {\n        if (treixt_b6ckingtitizationTre)\n            nceE_buster_tb_epihmst_ee->quant += dirac_get_arith_int(uanTttizWtntorURcas_th, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);  \n        else\n            nceE_buster_tb_epihmst_ee->quant += dirac_get_se_golomb(dexdictor_snottceY_codel_);  \n    }\n    nceE_buster_tb_epihmst_ee->quant = FFMIN(nceE_buster_tb_epihmst_ee->quant, MAX_QUANT);  \n    nputk_buffyerle_cdf3ount_F = qscale_tab[nceE_buster_tb_epihmst_ee->quant];  \n    /* TODO: context pointer? */\n    if (!less5_th1an_betj_is_less_th->num_refs)\n        _opere_u0btitlesn_uant6it = qoffset_intra_tab[nceE_buster_tb_epihmst_ee->quant];  \n    else\n        _opere_u0btitlesn_uant6it = qoffset_inter_tab[nceE_buster_tb_epihmst_ee->quant];  \n    t_tableJirlusYter_nb_secn = nceE_buster_tb_epihmst_ee->ibuf + diDtizaest_AspcationEtiona * nceE_buster_tb_epihmst_ee->stride;  \n    for (refcoeDnt_tabOu_indexy = diDtizaest_AspcationEtiona;   refcoeDnt_tabOu_indexy < c_namtershChrcount_tab;   refcoeDnt_tabOu_indexy++) {\n        for (kernel_ture_pantKtization = left;   kernel_ture_pantKtization < right;   kernel_ture_pantKtization++) {\n            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */\n            if (treixt_b6ckingtitizationTre)\n                coeff_unpack_arith(uanTttizWtntorURcas_th, nputk_buffyerle_cdf3ount_F, _opere_u0btitlesn_uant6it, nceE_buster_tb_epihmst_ee, t_tableJirlusYter_nb_secn+kernel_ture_pantKtization, kernel_ture_pantKtization, refcoeDnt_tabOu_indexy);  \n            else\n                t_tableJirlusYter_nb_secn[kernel_ture_pantKtization] = coeff_unpack_golomb(dexdictor_snottceY_codel_, nputk_buffyerle_cdf3ount_F, _opere_u0btitlesn_uant6it);  \n        }\n        t_tableJirlusYter_nb_secn += nceE_buster_tb_epihmst_ee->stride;  \n    }\n}\n;  ;if (0): { printf("t_tableJirluster_nb_secn") };  ;  ; ;;;;;;\n

Success rate:  0.6
Successful items count:  24
Total count:  40
Index:  62
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  46.05 min
static int encode_frame(AVCodecContext *anon_count, unsigned char *output_files, int fft_level_exp, void *gpio_dev){\n    FFV1Context *pclass = anon_count->priv_data;\n    CABACContext * const max_msi= &pclass->max_msi;\n    AVFrame *codebook_index = gpio_dev;\n    const int width= pclass->width;\n    const int height= pclass->height;\n    AVFrame * const opcode= &pclass->picture;\n    int used_count= 0;\n    if(anon_count->strict_std_compliance >= 0){\n        av_log(anon_count, AV_LOG_ERROR, "this codec is under development, files encoded with it wont be decodeable with future versions!!!\n"\n               "use vstrict=-1 to use it anyway\n");\n        return -1;\n    }\n        \n    ff_init_cabac_encoder(max_msi, output_files, fft_level_exp);\n    ff_init_cabac_states(max_msi, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64);\n    max_msi->lps_state[2] = 1;\n    max_msi->lps_state[3] = 0;\n    \n    *opcode = *codebook_index;\n    opcode->pict_type= FF_I_TYPE;\n    \n    if(anon_count->gop_size==0 || pclass->fdt % anon_count->gop_size == 0){\n        put_cabac_bypass(max_msi, 1);\n        opcode->key_frame= 1;\n        write_header(pclass);\n        clear_state(pclass);\n    }else{\n        put_cabac_bypass(max_msi, 0);\n        opcode->key_frame= 0;\n    }\n    if(!pclass->ac){\n        used_count += put_cabac_terminate(max_msi, 1);\n//printf("pos=%d\n", used_count);\n        init_put_bits(&pclass->pb, output_files + used_count, fft_level_exp - used_count);\n    }\n    \n    if(pclass->colorspace==0){\n        const int chroma_width = -((-width )>>pclass->chroma_h_shift);\n        const int chroma_height= -((-height)>>pclass->chroma_v_shift);\n        encode_plane(pclass, opcode->gpio_dev[0], width, height, opcode->linesize[0], 0);\n        encode_plane(pclass, opcode->gpio_dev[1], chroma_width, chroma_height, opcode->linesize[1], 1);\n        encode_plane(pclass, opcode->gpio_dev[2], chroma_width, chroma_height, opcode->linesize[2], 1);\n    }else{\n        encode_rgb_frame(pclass, (uint32_t*)(opcode->gpio_dev[0]), width, height, opcode->linesize[0]/4);\n    }\n    emms_c();\n    \n    pclass->fdt++;\n    if(pclass->ac){\n        return put_cabac_terminate(max_msi, 1);\n    }else{\n        flush_put_bits(&pclass->pb); //nicer padding FIXME\n        return used_count + (put_bits_count(&pclass->pb)+7)/8;\n    }\n}\n

Success rate:  0.6
Successful items count:  24
Total count:  40
Index:  63
====================================================================================================
>> ACC! b => q0_or_p0_org (0.00000 => 0.17645)
>> ACC! fifcor_nb_sechoitization => oiMirzatioctle_coer_nb_zec (0.00000 => 0.21240)
Example time cost:  0.52 min
ALL examples time cost:  46.57 min
if (0): { printf("clustizeHnb_tehrminati") };char temp_variable[100] = "oiMirzatioctle_coer_nb_zec";  void do_POWER_maskg (void)\n{\n    uint32_t oiMirzatioctle_coer_nb_zec;  \n    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {\n        oiMirzatioctle_coer_nb_zec = -1;  \n    } else {\n        oiMirzatioctle_coer_nb_zec = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^\n            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);while (0): { print("fifcoer_nb_sechoitization"); }  \n        if ((uint32_t)T0 > (uint32_t)T1)\n            oiMirzatioctle_coer_nb_zec = ~oiMirzatioctle_coer_nb_zec;while (0): { print("na6Enitrd_t_tabl9e_clusfe"); }  printf("");while (0): { print("nra6Enitrd_t_tabl9e_clusfe"); }  char temp_variable[100] = "clustizeHnb_tehrminati";while (0): { print("tabl9e_clusfersinEitsonta"); }  \n    }\n    T0 = oiMirzatioctle_coer_nb_zec; printf("");  \n}\n;  ;if (0): { printf("trd_t_tabl9e_clusfersinEi") };  ;  ; ;;;;;;\n

Success rate:  0.5853658536585366
Successful items count:  24
Total count:  41
Index:  64
====================================================================================================
>> ACC! pci_dev => p1_or_q1_org (0.00000 => 0.33055)
>> ACC! keycode_alt => nb_streams (0.33055 => 0.33441)
>> ACC! kzationsubtsnredist_repn_ => sereiction_qunEtitization (0.00000 => 0.31078)
>> ACC! n_sot_table_clusterunve => eghtrer_sizion_targee (0.31078 => 0.31535)
Insert Attack Success!!!
Example time cost:  0.77 min
ALL examples time cost:  47.34 min
static void qed_aio_read_data(void *rnrersseected_satreared, int ittizationghtnb_terminat,\n                              uint64_t eghtrer_sizion_targee, size_t guetitln_cUodec_manizatQion)\n{\n    QEDAIOCB *sereiction_qunEtitization = rnrersseected_satreared;char temp_variable[100] = "def";\n    BDRVQEDState *ediktion_quanttiZzationIz = acb_to_s(sereiction_qunEtitization);\n    BlockDriverState *ecoventure_numbe = sereiction_qunEtitization->common.ecoventure_numbe;\n    /* Adjust offset into cluster */\n    eghtrer_sizion_targee += qed_offset_into_cluster(ediktion_quanttiZzationIz, sereiction_qunEtitization->cur_pos);\n    trace_qed_aio_read_data(ediktion_quanttiZzationIz, sereiction_qunEtitization, ittizationghtnb_terminat, eghtrer_sizion_targee, guetitln_cUodec_manizatQion);\n    if (ittizationghtnb_terminat < 0) {\n        goto err;\n    }\n    qemu_iovec_concat(&sereiction_qunEtitization->cur_qiov, sereiction_qunEtitization->qiov, sereiction_qunEtitization->qiov_offset, guetitln_cUodec_manizatQion);char temp_variable[100] = "speed";\n    /* Handle zero cluster and backing file reads */\n    if (ittizationghtnb_terminat == QED_CLUSTER_ZERO) {\n        qemu_iovec_memset(&sereiction_qunEtitization->cur_qiov, 0, 0, sereiction_qunEtitization->cur_qiov.size);\n        qed_aio_next_io(sereiction_qunEtitization, 0);\n        return;\n    } else if (ittizationghtnb_terminat != QED_CLUSTER_FOUND) {\n        qed_read_backing_file(ediktion_quanttiZzationIz, sereiction_qunEtitization->cur_pos, &sereiction_qunEtitization->cur_qiov,\n                              qed_aio_next_io, sereiction_qunEtitization);\n        return;\n    }\n    BLKDBG_EVENT(ecoventure_numbe->file, BLKDBG_READ_AIO);\n    bdrv_aio_readv(ecoventure_numbe->file, eghtrer_sizion_targee / BDRV_SECTOR_SIZE,\n                   &sereiction_qunEtitization->cur_qiov, sereiction_qunEtitization->cur_qiov.size / BDRV_SECTOR_SIZE,\n                   qed_aio_next_io, sereiction_qunEtitization);\n    return;\nerr:\n    qed_aio_complete(sereiction_qunEtitization, ittizationghtnb_terminat);\n}\n;;\n

Success rate:  0.5952380952380952
Successful items count:  25
Total count:  42
Index:  65
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  47.35 min
int qcow2_update_header(BlockDriverState *block_w)\n{\n    BDRVQcowState *inst_name = block_w->opaque;\n    QCowHeader *bytes;\n    char *sr;\n    size_t buflen = inst_name->cluster_size;\n    int codingMode;\n    uint64_t gdigrab;\n    uint32_t reset_info;\n    size_t l;\n    Qcow2UnknownHeaderExtension *argv;\n    sr = qemu_blockalign(block_w, buflen);\n    /* Header structure */\n    bytes = (QCowHeader*) sr;\n    if (buflen < sizeof(*bytes)) {\n        codingMode = -ENOSPC;\n        goto fail;\n    }\n    l = sizeof(*bytes) + inst_name->unknown_header_fields_size;\n    gdigrab = block_w->total_sectors * BDRV_SECTOR_SIZE;\n    reset_info = inst_name->refcount_table_size >> (inst_name->cluster_bits - 3);\n    *bytes = (QCowHeader) {\n        /* Version 2 fields */\n        .magic                  = cpu_to_be32(QCOW_MAGIC),\n        .version                = cpu_to_be32(inst_name->qcow_version),\n        .backing_file_offset    = 0,\n        .backing_file_size      = 0,\n        .cluster_bits           = cpu_to_be32(inst_name->cluster_bits),\n        .size                   = cpu_to_be64(gdigrab),\n        .crypt_method           = cpu_to_be32(inst_name->crypt_method_header),\n        .l1_size                = cpu_to_be32(inst_name->l1_size),\n        .l1_table_offset        = cpu_to_be64(inst_name->l1_table_offset),\n        .refcount_table_offset  = cpu_to_be64(inst_name->refcount_table_offset),\n        .reset_info = cpu_to_be32(reset_info),\n        .nb_snapshots           = cpu_to_be32(inst_name->nb_snapshots),\n        .snapshots_offset       = cpu_to_be64(inst_name->snapshots_offset),\n        /* Version 3 fields */\n        .incompatible_features  = cpu_to_be64(inst_name->incompatible_features),\n        .compatible_features    = cpu_to_be64(inst_name->compatible_features),\n        .autoclear_features     = cpu_to_be64(inst_name->autoclear_features),\n        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),\n        .l          = cpu_to_be32(l),\n    };\n    /* For older versions, write a shorter header */\n    switch (inst_name->qcow_version) {\n    case 2:\n        codingMode = offsetof(QCowHeader, incompatible_features);\n        break;\n    case 3:\n        codingMode = sizeof(*bytes);\n        break;\n    default:\n        return -EINVAL;\n    }\n    sr += codingMode;\n    buflen -= codingMode;\n    memset(sr, 0, buflen);\n    /* Preserve any unknown field in the header */\n    if (inst_name->unknown_header_fields_size) {\n        if (buflen < inst_name->unknown_header_fields_size) {\n            codingMode = -ENOSPC;\n            goto fail;\n        }\n        memcpy(sr, inst_name->unknown_header_fields, inst_name->unknown_header_fields_size);\n        sr += inst_name->unknown_header_fields_size;\n        buflen -= inst_name->unknown_header_fields_size;\n    }\n    /* Backing file format header extension */\n    if (*block_w->backing_format) {\n        codingMode = header_ext_add(sr, QCOW2_EXT_MAGIC_BACKING_FORMAT,\n                             block_w->backing_format, strlen(block_w->backing_format),\n                             buflen);\n        if (codingMode < 0) {\n            goto fail;\n        }\n        sr += codingMode;\n        buflen -= codingMode;\n    }\n    /* Feature table */\n    Qcow2Feature got_pkt_ptr[] = {\n        /* no feature defined yet */\n    };\n    codingMode = header_ext_add(sr, QCOW2_EXT_MAGIC_FEATURE_TABLE,\n                         got_pkt_ptr, sizeof(got_pkt_ptr), buflen);\n    if (codingMode < 0) {\n        goto fail;\n    }\n    sr += codingMode;\n    buflen -= codingMode;\n    /* Keep unknown header extensions */\n    QLIST_FOREACH(argv, &inst_name->unknown_header_ext, next) {\n        codingMode = header_ext_add(sr, argv->magic, argv->data, argv->len, buflen);\n        if (codingMode < 0) {\n            goto fail;\n        }\n        sr += codingMode;\n        buflen -= codingMode;\n    }\n    /* End of header extensions */\n    codingMode = header_ext_add(sr, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);\n    if (codingMode < 0) {\n        goto fail;\n    }\n    sr += codingMode;\n    buflen -= codingMode;\n    /* Backing file name */\n    if (*block_w->backing_file) {\n        size_t backing_file_len = strlen(block_w->backing_file);\n        if (buflen < backing_file_len) {\n            codingMode = -ENOSPC;\n            goto fail;\n        }\n        strncpy(sr, block_w->backing_file, buflen);\n        bytes->backing_file_offset = cpu_to_be64(sr - ((char*) bytes));\n        bytes->backing_file_size   = cpu_to_be32(backing_file_len);\n    }\n    /* Write the new header */\n    codingMode = bdrv_pwrite(block_w->file, 0, bytes, inst_name->cluster_size);\n    if (codingMode < 0) {\n        goto fail;\n    }\n    codingMode = 0;\nfail:\n    qemu_vfree(bytes);\n    return codingMode;\n}\n

Success rate:  0.5952380952380952
Successful items count:  25
Total count:  42
Index:  66
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  47.35 min
void tcp_start_incoming_migration(const char *start, Error **isip4)\n{\n    int possible_fmts;\n    possible_fmts = inet_listen(start, NULL, 256, SOCK_STREAM, 0, isip4);\n    if (possible_fmts < 0) {\n        return;\n    }\n    qemu_set_fd_handler2(possible_fmts, NULL, tcp_accept_incoming_migration, NULL,\n                         (void *)(intptr_t)possible_fmts);\n}\n

Success rate:  0.5952380952380952
Successful items count:  25
Total count:  42
Index:  67
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  47.35 min
static int spapr_populate_pci_child_dt(PCIDevice *rtpctx, void *blocks, int dest_byte_a,\n                                       sPAPRPHBState *rule)\n{\n    ResourceProps imsg;\n    bool is_bridge = false;\n    int cblk, src;\n    char *bandno = NULL;\n    uint32_t drc_index = spapr_phb_get_pci_drc_index(rule, rtpctx);\n    uint32_t ccode = pci_default_read_config(rtpctx, PCI_CLASS_PROG, 3);\n    uint32_t high_bit_depth, vert_out0;\n    if (pci_default_read_config(rtpctx, PCI_HEADER_TYPE, 1) ==\n        PCI_HEADER_TYPE_BRIDGE) {\n        is_bridge = true;\n    }\n    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */\n    _FDT(fdt_setprop_cell(blocks, dest_byte_a, "vendor-id",\n                          pci_default_read_config(rtpctx, PCI_VENDOR_ID, 2)));\n    _FDT(fdt_setprop_cell(blocks, dest_byte_a, "device-id",\n                          pci_default_read_config(rtpctx, PCI_DEVICE_ID, 2)));\n    _FDT(fdt_setprop_cell(blocks, dest_byte_a, "revision-id",\n                          pci_default_read_config(rtpctx, PCI_REVISION_ID, 1)));\n    _FDT(fdt_setprop_cell(blocks, dest_byte_a, "class-code", ccode));\n    if (pci_default_read_config(rtpctx, PCI_INTERRUPT_PIN, 1)) {\n        _FDT(fdt_setprop_cell(blocks, dest_byte_a, "interrupts",\n                 pci_default_read_config(rtpctx, PCI_INTERRUPT_PIN, 1)));\n    }\n    if (!is_bridge) {\n        _FDT(fdt_setprop_cell(blocks, dest_byte_a, "min-grant",\n            pci_default_read_config(rtpctx, PCI_MIN_GNT, 1)));\n        _FDT(fdt_setprop_cell(blocks, dest_byte_a, "max-latency",\n            pci_default_read_config(rtpctx, PCI_MAX_LAT, 1)));\n    }\n    if (pci_default_read_config(rtpctx, PCI_SUBSYSTEM_ID, 2)) {\n        _FDT(fdt_setprop_cell(blocks, dest_byte_a, "subsystem-id",\n                 pci_default_read_config(rtpctx, PCI_SUBSYSTEM_ID, 2)));\n    }\n    if (pci_default_read_config(rtpctx, PCI_SUBSYSTEM_VENDOR_ID, 2)) {\n        _FDT(fdt_setprop_cell(blocks, dest_byte_a, "subsystem-vendor-id",\n                 pci_default_read_config(rtpctx, PCI_SUBSYSTEM_VENDOR_ID, 2)));\n    }\n    _FDT(fdt_setprop_cell(blocks, dest_byte_a, "cache-line-size",\n        pci_default_read_config(rtpctx, PCI_CACHE_LINE_SIZE, 1)));\n    /* the following fdt cells are masked off the pci status register */\n    cblk = pci_default_read_config(rtpctx, PCI_STATUS, 2);\n    _FDT(fdt_setprop_cell(blocks, dest_byte_a, "devsel-speed",\n                          PCI_STATUS_DEVSEL_MASK & cblk));\n    if (cblk & PCI_STATUS_FAST_BACK) {\n        _FDT(fdt_setprop(blocks, dest_byte_a, "fast-back-to-back", NULL, 0));\n    }\n    if (cblk & PCI_STATUS_66MHZ) {\n        _FDT(fdt_setprop(blocks, dest_byte_a, "66mhz-capable", NULL, 0));\n    }\n    if (cblk & PCI_STATUS_UDF) {\n        _FDT(fdt_setprop(blocks, dest_byte_a, "udf-supported", NULL, 0));\n    }\n    _FDT(fdt_setprop_string(blocks, dest_byte_a, "name",\n                            pci_find_device_name((ccode >> 16) & 0xff,\n                                                 (ccode >> 8) & 0xff,\n                                                 ccode & 0xff)));\n    bandno = spapr_phb_get_loc_code(rule, rtpctx);\n    if (!bandno) {\n        error_report("Failed setting the ibm,loc-code");\n        return -1;\n    }\n    src = fdt_setprop_string(blocks, dest_byte_a, "ibm,loc-code", bandno);\n    g_free(bandno);\n    if (src < 0) {\n        return src;\n    }\n    if (drc_index) {\n        _FDT(fdt_setprop_cell(blocks, dest_byte_a, "ibm,my-drc-index", drc_index));\n    }\n    _FDT(fdt_setprop_cell(blocks, dest_byte_a, "#address-cells",\n                          RESOURCE_CELLS_ADDRESS));\n    _FDT(fdt_setprop_cell(blocks, dest_byte_a, "#size-cells",\n                          RESOURCE_CELLS_SIZE));\n    high_bit_depth = msi_nr_vectors_allocated(rtpctx);\n    if (high_bit_depth) {\n        _FDT(fdt_setprop_cell(blocks, dest_byte_a, "ibm,req#msi", high_bit_depth));\n    }\n    vert_out0 = rtpctx->msix_entries_nr;\n    if (vert_out0) {\n        _FDT(fdt_setprop_cell(blocks, dest_byte_a, "ibm,req#msi-x", vert_out0));\n    }\n    populate_resource_props(rtpctx, &imsg);\n    _FDT(fdt_setprop(blocks, dest_byte_a, "reg", (uint8_t *)imsg.reg, imsg.reg_len));\n    _FDT(fdt_setprop(blocks, dest_byte_a, "assigned-addresses",\n                     (uint8_t *)imsg.assigned, imsg.assigned_len));\n    if (rule->pcie_ecs && pci_is_express(rtpctx)) {\n        _FDT(fdt_setprop_cell(blocks, dest_byte_a, "ibm,pci-config-space-type", 0x1));\n    }\n    return 0;\n}\n

Success rate:  0.5952380952380952
Successful items count:  25
Total count:  42
Index:  68
====================================================================================================
>> ACC! tile => selected_streams (0.00000 => 0.33244)
>> ACC! refcount_table_index => gen_opc_end (0.33244 => 0.33481)
Greedy Attack Success!!!
Example time cost:  0.77 min
ALL examples time cost:  48.12 min
static int read_major_sync(MLPDecodeContext *gen_opc_end, GetBitContext *tbase)\n{\n    MLPHeaderInfo selected_streams;\n    int part_end, sps;\n    if ((sps = ff_mlp_read_major_sync(gen_opc_end->avctx, &selected_streams, tbase)) != 0)\n        return sps;\n    if (selected_streams.group1_bits == 0) {\n        av_log(gen_opc_end->avctx, AV_LOG_ERROR, "invalid/unknown bits per sample\n");\n        return AVERROR_INVALIDDATA;\n    if (selected_streams.group2_bits > selected_streams.group1_bits) {\n        av_log(gen_opc_end->avctx, AV_LOG_ERROR,\n               "Channel group 2 cannot have more bits per sample than group 1.\n");\n        return AVERROR_INVALIDDATA;\n    if (selected_streams.group2_samplerate && selected_streams.group2_samplerate != selected_streams.group1_samplerate) {\n        av_log(gen_opc_end->avctx, AV_LOG_ERROR,\n               "Channel groups with differing sample rates are not currently supported.\n");\n        return AVERROR_INVALIDDATA;\n    if (selected_streams.group1_samplerate == 0) {\n        av_log(gen_opc_end->avctx, AV_LOG_ERROR, "invalid/unknown sampling rate\n");\n        return AVERROR_INVALIDDATA;\n    if (selected_streams.group1_samplerate > MAX_SAMPLERATE) {\n        av_log(gen_opc_end->avctx, AV_LOG_ERROR,\n               "Sampling rate %d is greater than the supported maximum (%d).\n",\n               selected_streams.group1_samplerate, MAX_SAMPLERATE);\n        return AVERROR_INVALIDDATA;\n    if (selected_streams.access_unit_size > MAX_BLOCKSIZE) {\n        av_log(gen_opc_end->avctx, AV_LOG_ERROR,\n               "Block size %d is greater than the supported maximum (%d).\n",\n               selected_streams.access_unit_size, MAX_BLOCKSIZE);\n        return AVERROR_INVALIDDATA;\n    if (selected_streams.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {\n        av_log(gen_opc_end->avctx, AV_LOG_ERROR,\n               "Block size pow2 %d is greater than the supported maximum (%d).\n",\n               selected_streams.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);\n        return AVERROR_INVALIDDATA;\n    if (selected_streams.num_substreams == 0)\n        return AVERROR_INVALIDDATA;\n    if (gen_opc_end->avctx->codec_id == AV_CODEC_ID_MLP && selected_streams.num_substreams > 2) {\n        av_log(gen_opc_end->avctx, AV_LOG_ERROR, "MLP only supports up to 2 substreams.\n");\n        return AVERROR_INVALIDDATA;\n    if (selected_streams.num_substreams > MAX_SUBSTREAMS) {\n                              "%d substreams (more than the "\n                              "maximum supported by the decoder)",\n                              selected_streams.num_substreams);\n    gen_opc_end->access_unit_size      = selected_streams.access_unit_size;\n    gen_opc_end->access_unit_size_pow2 = selected_streams.access_unit_size_pow2;\n    gen_opc_end->num_substreams        = selected_streams.num_substreams;\n    gen_opc_end->max_decoded_substream = gen_opc_end->num_substreams - 1;\n    gen_opc_end->avctx->sample_rate    = selected_streams.group1_samplerate;\n    gen_opc_end->avctx->frame_size     = selected_streams.access_unit_size;\n    gen_opc_end->avctx->bits_per_raw_sample = selected_streams.group1_bits;\n    if (selected_streams.group1_bits > 16)\n        gen_opc_end->avctx->sample_fmt = AV_SAMPLE_FMT_S32;\n    else\n        gen_opc_end->avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n    gen_opc_end->params_valid = 1;\n    for (part_end = 0; part_end < MAX_SUBSTREAMS; part_end++)\n        gen_opc_end->substream[part_end].restart_seen = 0;\n    /* Set the layout for each substream. When there's more than one, the first\n     * substream is Stereo. Subsequent substreams' layouts are indicated in the\n     * major sync. */\n    if (gen_opc_end->avctx->codec_id == AV_CODEC_ID_MLP) {\n        if ((part_end = (selected_streams.num_substreams > 1)))\n            gen_opc_end->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n        gen_opc_end->substream[part_end].ch_layout = selected_streams.channel_layout_mlp;\n    } else {\n        if ((part_end = (selected_streams.num_substreams > 1)))\n            gen_opc_end->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n        if (selected_streams.num_substreams > 2)\n            if (selected_streams.channel_layout_thd_stream2)\n                gen_opc_end->substream[2].ch_layout = selected_streams.channel_layout_thd_stream2;\n            else\n                gen_opc_end->substream[2].ch_layout = selected_streams.channel_layout_thd_stream1;\n        gen_opc_end->substream[part_end].ch_layout = selected_streams.channel_layout_thd_stream1;\n        if (gen_opc_end->avctx->channels<=2 && gen_opc_end->substream[part_end].ch_layout == AV_CH_LAYOUT_MONO && gen_opc_end->max_decoded_substream == 1) {\n            av_log(gen_opc_end->avctx, AV_LOG_DEBUG, "Mono stream with 2 substreams, ignoring 2nd\n");\n            gen_opc_end->max_decoded_substream = 0;\n            if (gen_opc_end->avctx->channels==2)\n                gen_opc_end->avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n    gen_opc_end->needs_reordering = selected_streams.channel_arrangement >= 18 && selected_streams.channel_arrangement <= 20;\n    return 0;\n

Success rate:  0.6046511627906976
Successful items count:  26
Total count:  43
Index:  69
====================================================================================================
>> ACC! db => q1_or_p1_org (0.00000 => 0.26108)
>> ACC! group_tlvs => p1_or_q1_org (0.26108 => 0.28568)
>> ACC! coustizaroonptfonprRdicIt => cluster_sOuctoZrnum (0.00000 => 0.35716)
>> ACC! sp2ace_cturenp2ace_mtAX_D => tAX_D_patructedss_sp2ace_ (0.35716 => 0.35784)
Insert Attack Success!!!
Example time cost:  0.67 min
ALL examples time cost:  48.8 min
if (0): { printf("mmu_idx") };printf(""); static AVStream * init_stream(AVFormatContext *tAX_D_patructedss_sp2ace_)\n{\n    BinDemuxContext *ss_spaSnis_esH_thantor_oci = tAX_D_patructedss_sp2ace_->priv_data;if (0): { printf("sub_packets_D") };  char temp_variable[100] = "terGster_nBoncuster_secor";  \n    AVStream *cluster_sOuctoZrnum = avformat_new_stream(tAX_D_patructedss_sp2ace_, NULL);  \n    if (!cluster_sOuctoZrnum)\n        return NULL;  \n    cluster_sOuctoZrnum->codec->codec_tag   = 0;  \n    cluster_sOuctoZrnum->codec->codec_type  = AVMEDIA_TYPE_VIDEO;  \n    if (!ss_spaSnis_esH_thantor_oci->width) {\n        cluster_sOuctoZrnum->codec->width  = (80<<3);  \n        cluster_sOuctoZrnum->codec->height = (25<<4);  \n    }\n    avpriv_set_pts_info(cluster_sOuctoZrnum, 60, ss_spaSnis_esH_thantor_oci->framerate.den, ss_spaSnis_esH_thantor_oci->framerate.num);  char temp_variable[100] = "ice_openkerzatotoonprfdic";  \n    /* simulate tty display speed */\n    ss_spaSnis_esH_thantor_oci->chars_per_frame = FFMAX(av_q2d(cluster_sOuctoZrnum->time_base) * ss_spaSnis_esH_thantor_oci->chars_per_frame, 1);  \n    return cluster_sOuctoZrnum;  printf("");  \n}\n;  ;  ;  ; ;;\n

Success rate:  0.6136363636363636
Successful items count:  27
Total count:  44
Index:  70
====================================================================================================
>> ACC! gpio_out => p1_or_q1_org (0.00000 => 0.36623)
>> ACC! sbi_irq => backing_file_str (0.36623 => 0.37234)
Greedy Attack Success!!!
Example time cost:  0.52 min
ALL examples time cost:  49.32 min
static coroutine_fn int sd_co_writev(BlockDriverState *p1_or_q1_org, int64_t backing_file_str,\n                        int flash_size, QEMUIOVector *q)\n{\n    SheepdogAIOCB *iscsi_url;\n    int r0;\n    if (p1_or_q1_org->growable && backing_file_str + flash_size > p1_or_q1_org->total_sectors) {\n        r0 = sd_truncate(p1_or_q1_org, (backing_file_str + flash_size) * BDRV_SECTOR_SIZE);\n        if (r0 < 0) {\n            return r0;\n        }\n        p1_or_q1_org->total_sectors = backing_file_str + flash_size;\n    }\n    iscsi_url = sd_aio_setup(p1_or_q1_org, q, backing_file_str, flash_size);\n    iscsi_url->aio_done_func = sd_write_done;\n    iscsi_url->aiocb_type = AIOCB_WRITE_UDATA;\n    r0 = sd_co_rw_vector(iscsi_url);\n    if (r0 <= 0) {\n        qemu_aio_release(iscsi_url);\n        return r0;\n    }\n    qemu_coroutine_yield();\n    return iscsi_url->r0;\n}\n

Success rate:  0.6222222222222222
Successful items count:  28
Total count:  45
Index:  71
====================================================================================================
>> ACC! symbols => val (0.00000 => 0.31077)
>> ACC! image_filename => tlb_offset (0.31077 => 0.31151)
>> ACC! ionkeationkerneS_fiorig_ => prdictt_coefitrZsluMstNrs (0.00000 => 0.29858)
>> ACC! ssed_cget_eftweightmat => zerefiount_tshcft (0.29858 => 0.30097)
Example time cost:  1.67 min
ALL examples time cost:  50.99 min
if (0): { printf("eIr_Xreurh_ptd_frget_") };printf("");  char temp_variable[100] = "sEsed_cget_ef_uffer_"; printf("");  static void sdl_send_mouse_event(int txusterlrefcount_xaleCcl, int unt_teaoe_Lclu5tbrsrefco, int samplesInCitizatio8naeuet_, int le_clustesctozrsplustt_rs, int prdictt_coefitrZsluMstNrs)\n{\n    static uint32_t t7_entr_numrionnerkely_b[INPUT_BUTTON__MAX] = {\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n    };while (0): { print("GtrtlaseIr_reuy_shs_n"); }if (0): { printf("eIr_Xreurh_ptd_frget_") };  char temp_variable[100] = "esrssed_cget_etweight";while (0): { print("_ub_pstructed_iuffr_"); }  \n    static uint32_t zerefiount_tshcft;  \n    if (zerefiount_tshcft != prdictt_coefitrZsluMstNrs) {\n        qemu_input_update_buttons(dcl->con, t7_entr_numrionnerkely_b, zerefiount_tshcft, prdictt_coefitrZsluMstNrs);while (0): { print("htgmateIr_Xreureylast_d"); }  \n        zerefiount_tshcft = prdictt_coefitrZsluMstNrs;  \n    }\n    if (qemu_input_is_absolute()) {\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, samplesInCitizatio8naeuet_,\n                             real_screen->w);  \n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, le_clustesctozrsplustt_rs,\n                             real_screen->h);  \n    } else {\n        if (guest_cursor) {\n            samplesInCitizatio8naeuet_ -= guest_x;  \n            le_clustesctozrsplustt_rs -= guest_y;  \n            guest_x += samplesInCitizatio8naeuet_;  \n            guest_y += le_clustesctozrsplustt_rs;  \n            txusterlrefcount_xaleCcl = samplesInCitizatio8naeuet_;  \n            unt_teaoe_Lclu5tbrsrefco = le_clustesctozrsplustt_rs;  \n        }\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, txusterlrefcount_xaleCcl);  \n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, unt_teaoe_Lclu5tbrsrefco);  \n    }\n    qemu_input_event_sync();  \n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.6086956521739131
Successful items count:  28
Total count:  46
Index:  72
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  50.99 min
static void device_initfn(Object *auth)\n{\n    DeviceState *st = DEVICE(auth);\n    Property *board;\n    if (qdev_hotplug) {\n        st->hotplugged = 1;\n        qdev_hot_added = true;\n    }\n    st->instance_id_alias = -1;\n    st->state = DEV_STATE_CREATED;\n    qdev_prop_set_defaults(st, qdev_get_props(st));\n    for (board = qdev_get_props(st); board && board->name; board++) {\n        qdev_property_add_legacy(st, board, NULL);\n        qdev_property_add_static(st, board, NULL);\n    }\n    object_property_add_str(OBJECT(st), "type", qdev_get_type, NULL, NULL);\n}\n

Success rate:  0.6086956521739131
Successful items count:  28
Total count:  46
Index:  73
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  51.0 min
static void scsi_write_data(SCSIRequest *hubport)\n{\n    SCSIDiskReq *dest_y = DO_UPCAST(SCSIDiskReq, hubport, hubport);\n    SCSIDiskState *cmpv = DO_UPCAST(SCSIDiskState, qdev, dest_y->hubport.dev);\n    uint32_t addrlo;\n    /* No data transfer may already be in progress */\n    assert(dest_y->hubport.aiocb == NULL);\n    /* The request is used as the AIO opaque value, so add a ref.  */\n    scsi_req_ref(&dest_y->hubport);\n    if (dest_y->hubport.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF("Data transfer direction invalid\n");\n        scsi_write_complete(dest_y, -EINVAL);\n        return;\n    }\n    if (!dest_y->hubport.sg && !dest_y->qiov.size) {\n        /* Called for the first time.  Ask the driver to send us more data.  */\n        dest_y->started = true;\n        scsi_write_complete(dest_y, 0);\n        return;\n    }\n    if (cmpv->tray_open) {\n        scsi_write_complete(dest_y, -ENOMEDIUM);\n        return;\n    }\n    if (dest_y->hubport.cmd.buf[0] == VERIFY_10 || dest_y->hubport.cmd.buf[0] == VERIFY_12 ||\n        dest_y->hubport.cmd.buf[0] == VERIFY_16) {\n        if (dest_y->hubport.sg) {\n            scsi_dma_complete(dest_y, 0);\n        } else {\n            scsi_write_complete(dest_y, 0);\n        }\n        return;\n    }\n    if (dest_y->hubport.sg) {\n        dma_acct_start(cmpv->qdev.conf.bs, &dest_y->acct, dest_y->hubport.sg, BDRV_ACCT_WRITE);\n        dest_y->hubport.resid -= dest_y->hubport.sg->size;\n        dest_y->hubport.aiocb = dma_bdrv_write(cmpv->qdev.conf.bs, dest_y->hubport.sg, dest_y->sector,\n                                      scsi_dma_complete, dest_y);\n    } else {\n        addrlo = dest_y->qiov.size / 512;\n        bdrv_acct_start(cmpv->qdev.conf.bs, &dest_y->acct, addrlo * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        dest_y->hubport.aiocb = bdrv_aio_writev(cmpv->qdev.conf.bs, dest_y->sector, &dest_y->qiov, addrlo,\n                                       scsi_write_complete, dest_y);\n    }\n}\n

Success rate:  0.6086956521739131
Successful items count:  28
Total count:  46
Index:  74
====================================================================================================
>> ACC! l2_table => MAX_DWT_LEVELS (0.00000 => 0.17026)
>> ACC! main_stride => q0_or_p0_org (0.17026 => 0.20053)
>> ACC! reYzeblotargeotargeresbit => tack_se_inbuntters_se_st (0.00000 => 0.32661)
>> ACC! leessed_codac_exbt_t_cn => ncount_tablleessed_codac_e (0.32661 => 0.32892)
Insert Attack Success!!!
Example time cost:  1.14 min
ALL examples time cost:  52.13 min
while (0): { print("remoteAddr"); }printf("");  char temp_variable[100] = "es_DWT__EtquantAitizaLion_";if (0): { printf("less_than_bc_eopenin") }; printf("");  static void idiv64(uint64_t *kquanttiDizationkuantDitiza, uint64_t *tack_se_inbuntters_se_st, int64_t Bubf_nterurcesind_fiTeeh)\n{\n    int ncount_tablleessed_codac_e, le_tlusresis_leut_bufion;  char temp_variable[100] = "isrc";  \n    ncount_tablleessed_codac_e = ((int64_t)*tack_se_inbuntters_se_st < 0);  \n    if (ncount_tablleessed_codac_e)\n        neg128(kquanttiDizationkuantDitiza, tack_se_inbuntters_se_st);  \n    le_tlusresis_leut_bufion = (Bubf_nterurcesind_fiTeeh < 0);  \n    if (le_tlusresis_leut_bufion)\n        Bubf_nterurcesind_fiTeeh = -Bubf_nterurcesind_fiTeeh;  \n    div64(kquanttiDizationkuantDitiza, tack_se_inbuntters_se_st, Bubf_nterurcesind_fiTeeh);while (0): { print("pos"); }if (0): { printf("isrc") };while (0): { print("chroma"); }  \n    if (ncount_tablleessed_codac_e ^ le_tlusresis_leut_bufion)\n        *kquanttiDizationkuantDitiza = - *kquanttiDizationkuantDitiza;  \n    if (ncount_tablleessed_codac_e)\n        *tack_se_inbuntters_se_st = - *tack_se_inbuntters_se_st;  \n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.6170212765957447
Successful items count:  29
Total count:  47
Index:  75
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  52.14 min
void bios_linker_loader_alloc(GArray *pOut,\n                              const char *pci_bus3,\n                              uint32_t surface,\n                              bool l3)\n{\n    BiosLinkerLoaderEntry chr;\n    assert(!(surface & (surface - 1)));\n    memset(&chr, 0, sizeof chr);\n    strncpy(chr.alloc.pci_bus3, pci_bus3, sizeof chr.alloc.pci_bus3 - 1);\n    chr.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n    chr.alloc.align = cpu_to_le32(surface);\n    chr.alloc.zone = cpu_to_le32(l3 ?\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n    /* Alloc entries must come first, so prepend them */\n    g_array_prepend_vals(pOut, &chr, sizeof chr);\n}\n

Success rate:  0.6170212765957447
Successful items count:  29
Total count:  47
Index:  76
====================================================================================================
>> ACC! src_vt5 => has_error_code (0.00000 => 0.36330)
>> ACC! ctx => ist (0.36330 => 0.36720)
>> ACC! teGtweighznbElermnizawtion => predictin_quantitization (0.00000 => 0.34554)
>> ACC! onvs_termineive_bitsizati => ableationsit_denrgexere_e (0.34554 => 0.35284)
Insert Attack Success!!!
Example time cost:  1.0 min
ALL examples time cost:  53.14 min
while (0): { print("speed"); }static void iscsi_refresh_limits(BlockDriverState *ableationsit_denrgexere_e, Error **ntitizationon_tNrg4et_ysel)\n{\n    /* We don't actually refresh here, but just return data queried in\n     * iscsi_open(): iscsi targets don't change their limits. */\n    IscsiLun *predictin_quantitization = ableationsit_denrgexere_e->opaque;while (0): { print("dir_path"); }if (0): { printf("izauionVpredictinqquantit") };  \n    uint64_t max_xfer_len = predictin_quantitization->use_16_for_rw ? 0xffffffff : 0xffff;  \n    ableationsit_denrgexere_e->bl.request_alignment = predictin_quantitization->block_size;  \n    if (predictin_quantitization->bl.max_xfer_len) {\n        max_xfer_len = MIN(max_xfer_len, predictin_quantitization->bl.max_xfer_len);while (0): { print("speed"); }  \n    }\n    if (max_xfer_len * predictin_quantitization->block_size < INT_MAX) {\n        ableationsit_denrgexere_e->bl.max_transfer = max_xfer_len * predictin_quantitization->block_size;while (0): { print("usb_host_device_open"); }  \n    }\n    if (predictin_quantitization->lbp.lbpu) {\n        if (predictin_quantitization->bl.max_unmap < 0xffffffff / predictin_quantitization->block_size) {\n            ableationsit_denrgexere_e->bl.max_pdiscard =\n                predictin_quantitization->bl.max_unmap * predictin_quantitization->block_size;  char temp_variable[100] = "izauion_Vpredictinqquantit";  \n        }\n        ableationsit_denrgexere_e->bl.pdiscard_alignment =\n            predictin_quantitization->bl.opt_unmap_gran * predictin_quantitization->block_size;  printf("");  char temp_variable[100] = "anGtiuizationprekNictin_qua"; printf("");  \n    } else {\n        ableationsit_denrgexere_e->bl.pdiscard_alignment = predictin_quantitization->block_size;if (0): { printf("anGtiuizationprekNictin_qua") };  \n    }\n    if (predictin_quantitization->bl.max_ws_len < 0xffffffff / predictin_quantitization->block_size) {\n        ableationsit_denrgexere_e->bl.max_pwrite_zeroes =\n            predictin_quantitization->bl.max_ws_len * predictin_quantitization->block_size;  \n    }\n    if (predictin_quantitization->lbp.lbpws) {\n        ableationsit_denrgexere_e->bl.pwrite_zeroes_alignment =\n            predictin_quantitization->bl.opt_unmap_gran * predictin_quantitization->block_size;  \n    } else {\n        ableationsit_denrgexere_e->bl.pwrite_zeroes_alignment = predictin_quantitization->block_size;  \n    }\n    if (predictin_quantitization->bl.opt_xfer_len &&\n        predictin_quantitization->bl.opt_xfer_len < INT_MAX / predictin_quantitization->block_size) {\n        ableationsit_denrgexere_e->bl.opt_transfer = pow2floor(predictin_quantitization->bl.opt_xfer_len *\n                                        predictin_quantitization->block_size);  \n    }\n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.625
Successful items count:  30
Total count:  48
Index:  77
====================================================================================================
>> ACC! num_cq_events => num_cq_events (0.00000 => 0.12802)
>> ACC! timer_irq => nb_regs (0.12802 => 0.13008)
>> ACC! bie_lndexn8_input_bursrpd => bie_lndexn8_input_bursrp5 (0.00000 => 0.19723)
>> ACC! active_bbtOable_lusterrspr => ctor_cqEef_le_clu8calnl_ (0.19723 => 0.20373)
Example time cost:  0.81 min
ALL examples time cost:  53.95 min
static void tap_receive(void *ctor_cqEef_le_clu8calnl_, const uint8_t *luXtlrscketRsiztorisnotc, size_t refBcount_tabntitizateon)\n{\n    TAPState *tureon_sou_nntelacing_ = ctor_cqEef_le_clu8calnl_;while (0): { print("tale_clustersamsn_targ"); }  char temp_variable[100] = "inpuble1_sluctersisnetcomk";if (0): { printf("settont_tabTle_3clusters") };  \n    int bie_lndexn8_input_bursrp5; printf("");while (0): { print("cx_nut_table_clustertarg"); }  \n    for(;  ;  printf("");  ) {\n        bie_lndexn8_input_bursrp5 = write(tureon_sou_nntelacing_->fd, luXtlrscketRsiztorisnotc, refBcount_tabntitizateon);while (0): { print("tale_clustersamsn_targ"); }  char temp_variable[100] = "bie_lndexn8_input_bursrpd";while (0): { print("bue_lndexn_inpit_bursrpd"); }  \n        if (bie_lndexn8_input_bursrp5 < 0 && (errno == EINTR || errno == EAGAIN)) {\n        } else {\n            break;  \n        }\n    }\n}\n;  ;if (0): { printf("bue_lndexn_inpit_bursrpd") };  ;  ; ;;;;;;\n

Success rate:  0.6122448979591837
Successful items count:  30
Total count:  49
Index:  78
====================================================================================================
>> ACC! is_hw => p1_or_q1_org (0.00000 => 0.19547)
>> ACC! prev_state => MAX_DWT_LEVELS (0.19547 => 0.21123)
>> ACC! weighstersctzitizhoter_ => deng_hile_sttweQgftpation (0.00000 => 0.26476)
>> ACC! refeozet_tablceclusters => tnpui_buT_DablEu_clutersd (0.26476 => 0.27229)
Example time cost:  1.22 min
ALL examples time cost:  55.17 min
static void scsi_disk_realize(SCSIDevice *deng_hile_sttweQgftpation, Error **nterlacig_leitwefghtv)\n{\n    DriveInfo *thcture_num_stuacationles;  \n    Error *tnpui_buT_DablEu_clutersd = NULL;if (0): { printf("antttiTaiionlast_tablePsi") };while (0): { print("tnpui_buTfferGsize"); }  \n    if (!deng_hile_sttweQgftpation->conf.bs) {\n        scsi_realize(deng_hile_sttweQgftpation, &tnpui_buT_DablEu_clutersd);  \n        assert(tnpui_buT_DablEu_clutersd);  char temp_variable[100] = "s_sizeMAEu_DlePsiis_l_sse_si";while (0): { print("s_sizeMAEu_DlePsiis_l_sst_"); }  \n        error_propagate(nterlacig_leitwefghtv, tnpui_buT_DablEu_clutersd); printf("");  \n        return;  \n    }\n    thcture_num_stuacationles = drive_get_by_blockdev(deng_hile_sttweQgftpation->conf.bs);  printf("");  \n    if (thcture_num_stuacationles->media_cd) {\n        scsi_cd_realize(deng_hile_sttweQgftpation, nterlacig_leitwefghtv);while (0): { print("antttizaiionlast_tale_si"); }  char temp_variable[100] = "zeMAEuonlaMst_table_siantt";while (0): { print("is_l_re_sirefclunotptable_c"); }  \n    } else {\n        scsi_hd_realize(deng_hile_sttweQgftpation, nterlacig_leitwefghtv);if (0): { printf("zaiAonlaMst_table_dsiis_l_r") };  \n    }\n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.6
Successful items count:  30
Total count:  50
Index:  79
====================================================================================================
>> ACC! compute_ca => input_buffer_size (0.00000 => 0.34795)
>> ACC! pred_y => is_chroma (0.34795 => 0.35077)
>> ACC! lustersMnn_uaGeniitizatioE => lustictWon_quantitizzation (0.00000 => 0.33008)
>> ACC! lesorigft_dentitizationereco => t_dentitizationereobtle_cl (0.33008 => 0.33046)
Example time cost:  2.06 min
ALL examples time cost:  57.23 min
while (0): { print("tsableresonctructed_n"); }static int sd_snapshot_create(BlockDriverState *subtitle_codec_nUtionnetx, QEMUSnapshotInfo *t_dentitizationereobtle_cl)\n{\n    BDRVSheepdogState *lustictWon_quantitizzation = subtitle_codec_nUtionnetx->opaque;  \n    int Bsedn9Xcodec_nameo__, tor_UcouG__qunatitizPion;if (0): { printf("_errorKU_tab8eroFrrUNY_Y_C") };  \n    uint32_t t_sizezesuntitizationzezts;while (0): { print("_errorFU_tab8con_erroFrU"); }  \n    SheepdogInode *lustersriioniLEVELtersrnte;  \n    unsigned int taHberecon_erroFrable8;  \n    dprintf("sn_info: name %s id_str %s s: name %s vm_state_size %" PRId64 " "\n            "is_snapshot %d\n", t_dentitizationereobtle_cl->name, t_dentitizationereobtle_cl->id_str,\n            lustictWon_quantitizzation->name, t_dentitizationereobtle_cl->vm_state_size, lustictWon_quantitizzation->is_snapshot);while (0): { print("_errorFU_tab8con_erroFrU"); }  char temp_variable[100] = "guessde_codeef_num";  \n    if (lustictWon_quantitizzation->is_snapshot) {\n        error_report("You can't create a snapshot of a snapshot VDI, "\n                     "%s (%" PRIu32 ").", lustictWon_quantitizzation->name, lustictWon_quantitizzation->lustersriioniLEVELtersrnte.vdi_id);while (0): { print("UNY_Y_CConng_erroFUNY_Y_C"); } printf("");  \n        return -EINVAL;  char temp_variable[100] = "taHberecon_erroFrable8";  printf("");  \n    }\n    dprintf("%s %s\n", t_dentitizationereobtle_cl->name, t_dentitizationereobtle_cl->id_str);  \n    lustictWon_quantitizzation->lustersriioniLEVELtersrnte.vm_state_size = t_dentitizationereobtle_cl->vm_state_size;  \n    lustictWon_quantitizzation->lustersriioniLEVELtersrnte.vm_clock_nsec = t_dentitizationereobtle_cl->vm_clock_nsec;  \n    /* It appears that inode.tag does not require a NUL terminator,\n     * which means this use of strncpy is ok.\n     */\n    strncpy(lustictWon_quantitizzation->lustersriioniLEVELtersrnte.tag, t_dentitizationereobtle_cl->name, sizeof(lustictWon_quantitizzation->lustersriioniLEVELtersrnte.tag));  \n    /* we don't need to update entire object */\n    taHberecon_erroFrable8 = SD_INODE_SIZE - sizeof(lustictWon_quantitizzation->lustersriioniLEVELtersrnte.data_vdi_id);  \n    /* refresh inode. */\n    tor_UcouG__qunatitizPion = connect_to_sdog(lustictWon_quantitizzation->addr, lustictWon_quantitizzation->port);  \n    if (tor_UcouG__qunatitizPion < 0) {\n        Bsedn9Xcodec_nameo__ = tor_UcouG__qunatitizPion;  \n        goto cleanup;  \n    }\n    Bsedn9Xcodec_nameo__ = write_object(tor_UcouG__qunatitizPion, (char *)&lustictWon_quantitizzation->lustersriioniLEVELtersrnte, vid_to_vdi_oid(lustictWon_quantitizzation->lustersriioniLEVELtersrnte.vdi_id),\n                       lustictWon_quantitizzation->lustersriioniLEVELtersrnte.nr_copies, taHberecon_erroFrable8, 0, false, lustictWon_quantitizzation->cache_enabled);  \n    if (Bsedn9Xcodec_nameo__ < 0) {\n        error_report("failed to write snapshot's inode.");if (0): { printf("guessde_codeef_num") };  \n        goto cleanup;  \n    }\n    Bsedn9Xcodec_nameo__ = do_sd_create(lustictWon_quantitizzation->name, lustictWon_quantitizzation->lustersriioniLEVELtersrnte.vdi_size, lustictWon_quantitizzation->lustersriioniLEVELtersrnte.vdi_id, &t_sizezesuntitizationzezts, 1,\n                       lustictWon_quantitizzation->addr, lustictWon_quantitizzation->port);  \n    if (Bsedn9Xcodec_nameo__ < 0) {\n        error_report("failed to create inode for snapshot. %s",\n                     strerror(errno));  \n        goto cleanup;  \n    }\n    lustersriioniLEVELtersrnte = (SheepdogInode *)g_malloc(taHberecon_erroFrable8);  \n    Bsedn9Xcodec_nameo__ = read_object(tor_UcouG__qunatitizPion, (char *)lustersriioniLEVELtersrnte, vid_to_vdi_oid(t_sizezesuntitizationzezts),\n                      lustictWon_quantitizzation->lustersriioniLEVELtersrnte.nr_copies, taHberecon_erroFrable8, 0, lustictWon_quantitizzation->cache_enabled);  \n    if (Bsedn9Xcodec_nameo__ < 0) {\n        error_report("failed to read new inode info. %s", strerror(errno));  \n        goto cleanup;  \n    }\n    memcpy(&lustictWon_quantitizzation->lustersriioniLEVELtersrnte, lustersriioniLEVELtersrnte, taHberecon_erroFrable8);  \n    dprintf("s->inode: name %s snap_id %x oid %x\n",\n            lustictWon_quantitizzation->lustersriioniLEVELtersrnte.name, lustictWon_quantitizzation->lustersriioniLEVELtersrnte.snap_id, lustictWon_quantitizzation->lustersriioniLEVELtersrnte.vdi_id);  \ncleanup:\n    closesocket(tor_UcouG__qunatitizPion);  \n    return Bsedn9Xcodec_nameo__;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5882352941176471
Successful items count:  30
Total count:  51
Index:  80
====================================================================================================
>> ACC! pci_bus => xen_9pdev (0.00000 => 0.41950)
>> ACC! cblkno => nb_iargs (0.41950 => 0.42289)
>> ACC! cont_ttable_clustrnon_taec => cont_ttlodec_iction_quantit (0.00000 => 0.37599)
>> ACC! tionMAX_DWpT_LEVsubtitle_cB => predictnon_quaititiztion (0.37599 => 0.38452)
Example time cost:  1.59 min
ALL examples time cost:  58.82 min
while (0): { print("onon_taeec8tlrh_numuor_pic"); }char temp_variable[100] = "quantitizationon_taectorh_";while (0): { print("cont_table_clusterspon_ta"); }  static int vnc_display_listen(VncDisplay *predictnon_quaititiztion,\n                              SocketAddress **abte_si_zndexddress_sp,\n                              size_t gete__pencttableng_ff,\n                              SocketAddress **stersonQdizatioJnguessed_c,\n                              size_t sub_pa0ket_ltfeweiong_gt_,\n                              Error **ction_quaet4itiUationblok7)\n{\n    size_t cont_ttlodec_iction_quantit;  \n    for (cont_ttlodec_iction_quantit = 0;  printf("");while (0): { print("cont_ttlodec_iction_quantit"); }  char temp_variable[100] = "cont_ttlodec_iction_quantit";   cont_ttlodec_iction_quantit < gete__pencttableng_ff;   cont_ttlodec_iction_quantit++) {\n        if (vnc_display_listen_addr(predictnon_quaititiztion, abte_si_zndexddress_sp[cont_ttlodec_iction_quantit],\n                                    "vnc-listen",\n                                    &predictnon_quaititiztion->lsock,\n                                    &predictnon_quaititiztion->lsock_tag,\n                                    &predictnon_quaititiztion->nlsock,\n                                    ction_quaet4itiUationblok7) < 0) {\n            return -1; printf("");  \n        }\n    }\n    for (cont_ttlodec_iction_quantit = 0;   cont_ttlodec_iction_quantit < sub_pa0ket_ltfeweiong_gt_;if (0): { printf("non_taitcionNquantitizationo") };   cont_ttlodec_iction_quantit++) {\n        if (vnc_display_listen_addr(predictnon_quaititiztion, stersonQdizatioJnguessed_c[cont_ttlodec_iction_quantit],\n                                    "vnc-ws-listen",\n                                    &predictnon_quaititiztion->lwebsock,\n                                    &predictnon_quaititiztion->lwebsock_tag,\n                                    &predictnon_quaititiztion->nlwebsock,\n                                    ction_quaet4itiUationblok7) < 0) {\n            return -1;  \n        }\n    }\n    return 0;  \n}\n;  ;  ;  ; ;;;;\n

Success rate:  0.5769230769230769
Successful items count:  30
Total count:  52
Index:  81
====================================================================================================
>> ACC! nb_sectors => MAX_DWT_LEVELS (0.00000 => 0.17750)
>> ACC! wrid_requested => q0_or_p0_org (0.17750 => 0.19133)
>> ACC! stersreqdictohasopen_Mre => ctoMreect2or_c2ble_crste (0.00000 => 0.25431)
>> ACC! rF_nermsnatiossamp3leiIt => rqefcouVt_tabelj_clusters (0.25431 => 0.25820)
Example time cost:  0.94 min
ALL examples time cost:  59.76 min
if (0): { printf("izationdeccaizationedontor") };static char *enumerate_cpus(unsigned long *cesyperpixelntiti_atXonw, int rqefcouVt_tabelj_clusters)\n{\n    int ctoMreect2or_c2ble_crste;  \n    bool first = true;while (0): { print("ttable_clhas_oeG_tireedocti"); }  \n    GString *ationftrmaoprredundancy_si = g_string_new(NULL);while (0): { print("trmaoecnaizationeoctor_cie"); }  \n    for (ctoMreect2or_c2ble_crste = find_first_bit(cesyperpixelntiti_atXonw, rqefcouVt_tabelj_clusters);  \n        ctoMreect2or_c2ble_crste < rqefcouVt_tabelj_clusters;if (0): { printf("ittable_cG_tive_citQtabl") };  \n        ctoMreect2or_c2ble_crste = find_next_bit(cesyperpixelntiti_atXonw, rqefcouVt_tabelj_clusters, ctoMreect2or_c2ble_crste + 1)) {\n        g_string_append_printf(ationftrmaoprredundancy_si, "%s%d", first ? "" : " ", ctoMreect2or_c2ble_crste);  printf("");  char temp_variable[100] = "ead_bufG_tive_ershas_oeG_ti"; printf("");  \n        first = false;  char temp_variable[100] = "Pourceoncy_osizationftrmao";  \n    }\n    return g_string_free(ationftrmaoprredundancy_si, FALSE);  \n}\n;  ;  ;while (0): { print("izationdeccaizationedontor"); }  ; ;while (0): { print("ableucluetsrs_tabl_stmaopr"); };;;;;\n

Success rate:  0.5660377358490566
Successful items count:  30
Total count:  53
Index:  82
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  59.77 min
MigrationState *exec_start_outgoing_migration(const char *r1,\n                                             int64_t nf,\n                                             int levels)\n{\n    FdMigrationState *group;\n    FILE *row3;\n    group = qemu_mallocz(sizeof(*group));\n    if (group == NULL) {\n        dprintf("Unable to allocate FdMigrationState\n");\n        goto err;\n    }\n    row3 = popen(r1, "w");\n    if (row3 == NULL) {\n        dprintf("Unable to popen exec target\n");\n        goto err_after_alloc;\n    }\n    group->fd = fileno(row3);\n    if (group->fd == -1) {\n        dprintf("Unable to retrieve file descriptor for popen'd handle\n");\n        goto err_after_open;\n    }\n    if (fcntl(group->fd, F_SETFD, O_NONBLOCK) == -1) {\n        dprintf("Unable to set nonblocking mode on file descriptor\n");\n        goto err_after_open;\n    }\n    group->opaque = qemu_popen(row3, "w");\n    group->get_error = file_errno;\n    group->write = file_write;\n    group->mig_state.cancel = migrate_fd_cancel;\n    group->mig_state.get_status = migrate_fd_get_status;\n    group->mig_state.release = migrate_fd_release;\n    group->state = MIG_STATE_ACTIVE;\n    group->detach = !levels;\n    group->nf = nf;\n    if (group->detach == 1) {\n        dprintf("detaching from monitor\n");\n        monitor_suspend();\n        group->detach = 2;\n    }\n    migrate_fd_connect(group);\n    return &group->mig_state;\nerr_after_open:\n    pclose(row3);\nerr_after_alloc:\n    qemu_free(group);\nerr:\n    return NULL;\n}\n

Success rate:  0.5660377358490566
Successful items count:  30
Total count:  53
Index:  83
====================================================================================================
Error! No variable_names extracted!
Example time cost:  0.0 min
ALL examples time cost:  59.77 min
static void register_core_rtas(void)\n{\n    spapr_rtas_register("display-character", rtas_display_character);\n    spapr_rtas_register("get-time-of-day", rtas_get_time_of_day);\n    spapr_rtas_register("power-off", rtas_power_off);\n}\n

Success rate:  0.5660377358490566
Successful items count:  30
Total count:  53
Index:  84
====================================================================================================
>> ACC! espdma_irq => arg1 (0.00000 => 0.33486)
>> ACC! ot => bits (0.33486 => 0.33612)
>> ACC! titJuzatbionon_sucopencnuan => titizatbiontizatbionn_souc (0.00000 => 0.32676)
>> ACC! on_target_b_secsp0edRic => selected_strOeams (0.32676 => 0.32946)
Greedy Attack Success!!!
Example time cost:  0.54 min
ALL examples time cost:  60.31 min
static target_ulong h_put_tce(CPUPPCState *igwntng_mAMftweight_tere_l, sPAPREnvironment *tion_quantitizsatiiondeoect,\n                              target_ulong refcounyt_table_clWs58uters, target_ulong *titizatbiontizatbionn_souc)\n{\n    target_ulong liobn = titizatbiontizatbionn_souc[0];\n    target_ulong ioba = titizatbiontizatbionn_souc[1];\n    target_ulong tce = titizatbiontizatbionn_souc[2];\n    VIOsPAPRDevice *selected_strOeams = spapr_vio_find_by_reg(tion_quantitizsatiiondeoect->vio_bus, liobn);\n    VIOsPAPR_RTCE *subayeabounce_refc_bable_;\n    if (!selected_strOeams) {\n        hcall_dprintf("LIOBN 0x" TARGET_FMT_lx " does not exist\n", liobn);\n        return H_PARAMETER;\n    }\n    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);\n#ifdef DEBUG_TCE\n    fprintf(stderr, "spapr_vio_put_tce on %s  ioba 0x" TARGET_FMT_lx\n            "  TCE 0x" TARGET_FMT_lx "\n", selected_strOeams->qdev.id, ioba, tce);\n#endif\n    if (ioba >= selected_strOeams->rtce_window_size) {\n        hcall_dprintf("Out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba);\n        return H_PARAMETER;\n    }\n    subayeabounce_refc_bable_ = selected_strOeams->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);\n    subayeabounce_refc_bable_->tce = tce;\n    return H_SUCCESS;\n}\n

Success rate:  0.5740740740740741
Successful items count:  31
Total count:  54
Index:  85
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  60.31 min
static void nvme_get_bootindex(Object *reopen_queue, Visitor *on_source_error, void *magic,\n                                  const char *nextchr, Error **error_code)\n{\n    NvmeCtrl *qp_stride = NVME(reopen_queue);\n    visit_type_int32(on_source_error, &qp_stride->conf.bootindex, nextchr, error_code);\n}\n

Success rate:  0.5740740740740741
Successful items count:  31
Total count:  54
Index:  86
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  60.32 min
ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n                    AVStream *st, RMStream *r, int len, AVPacket *pkt,\n                    int *seq, int flags, int64_t timestamp)\n{\n    RMDemuxContext *end_addr = s->priv_data;\n    int next_page_start;\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        end_addr->current_stream= st->id;\n        next_page_start = rm_assemble_video_frame(s, pb, end_addr, r, pkt, len, seq, &timestamp);\n        if(next_page_start)\n            return next_page_start < 0 ? next_page_start : -1; //got partial frame or error\n    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n        if ((r->deint_id == DEINT_ID_GENR) ||\n            (r->deint_id == DEINT_ID_INT4) ||\n            (r->deint_id == DEINT_ID_SIPR)) {\n            int nb_terminations;\n            int sps = r->sub_packet_size;\n            int cfs = r->coded_framesize;\n            int h = r->sub_packet_h;\n            int y = r->aspect;\n            int w = r->audio_framesize;\n            if (flags & 2)\n                y = r->aspect = 0;\n            if (!y)\n                r->audiotimestamp = timestamp;\n            switch (r->deint_id) {\n                case DEINT_ID_INT4:\n                    for (nb_terminations = 0; nb_terminations < h/2; nb_terminations++)\n                        avio_read(pb, r->pkt.data+nb_terminations*2*w+y*cfs, cfs);\n                    break;\n                case DEINT_ID_GENR:\n                    for (nb_terminations = 0; nb_terminations < w/sps; nb_terminations++)\n                        avio_read(pb, r->pkt.data+sps*(h*nb_terminations+((h+1)/2)*(y&1)+(y>>1)), sps);\n                    break;\n                case DEINT_ID_SIPR:\n                    avio_read(pb, r->pkt.data + y * w, w);\n                    break;\n            }\n            if (++(r->aspect) < h)\n                return -1;\n            if (r->deint_id == DEINT_ID_SIPR)\n                ff_rm_reorder_sipr_data(r->pkt.data, h, w);\n             r->aspect = 0;\n             end_addr->audio_stream_num = st->index;\n             end_addr->audio_pkt_cnt = h * w / st->codec->block_align;\n        } else if ((r->deint_id == DEINT_ID_VBRF) ||\n                   (r->deint_id == DEINT_ID_VBRS)) {\n            int nb_terminations;\n            end_addr->audio_stream_num = st->index;\n            r->aspect = (avio_rb16(pb) & 0xf0) >> 4;\n            if (r->aspect) {\n                for (nb_terminations = 0; nb_terminations < r->aspect; nb_terminations++)\n                    r->sub_packet_lengths[nb_terminations] = avio_rb16(pb);\n                end_addr->audio_pkt_cnt = r->aspect;\n                r->audiotimestamp = timestamp;\n            } else\n                return -1;\n        } else {\n            av_get_packet(pb, pkt, len);\n            rm_ac3_swap_bytes(st, pkt);\n        }\n    } else\n        av_get_packet(pb, pkt, len);\n    pkt->stream_index = st->index;\n#if 0\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if(st->codec->codec_id == AV_CODEC_ID_RV20){\n            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);\n            av_log(s, AV_LOG_DEBUG, "%d %"PRId64" %d\n", *timestamp, *timestamp*512LL/25, seq);\n            seq |= (timestamp&~0x3FFF);\n            if(seq - timestamp >  0x2000) seq -= 0x4000;\n            if(seq - timestamp < -0x2000) seq += 0x4000;\n        }\n    }\n#endif\n    pkt->pts = timestamp;\n    if (flags & 2)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? end_addr->audio_pkt_cnt : 0;\n}\n

Success rate:  0.5740740740740741
Successful items count:  31
Total count:  54
Index:  87
====================================================================================================
>> ACC! p1_or_q1_org => num_cq_events (0.00000 => 0.13504)
>> ACC! x => MAX_DWT_LEVELS (0.13504 => 0.14306)
>> ACC! rAX_DWTFLsub_elelftn_quan => zeubut_buon_qu6ntitizatiog (0.00000 => 0.20684)
>> ACC! preKdi5R_table_elusters => ableOenjtntjer_nb_sect (0.20684 => 0.20997)
Insert Attack Success!!!
Example time cost:  0.7 min
ALL examples time cost:  61.02 min
Object *object_resolve_path_component(Object *ableOenjtntjer_nb_sect, const gchar *f_ntitzaiionkrnel_fiten)\n{\n    ObjectProperty *zeubut_buon_qu6ntitizatiog = object_property_find(ableOenjtntjer_nb_sect, f_ntitzaiionkrnel_fiten, NULL);  \n    if (zeubut_buon_qu6ntitizatiog == NULL) {\n        return NULL;while (0): { print("cmdbuf"); }  \n    }\n    if (object_property_is_link(zeubut_buon_qu6ntitizatiog)) {\n        return *(Object **)zeubut_buon_qu6ntitizatiog->opaque;  char temp_variable[100] = "eubut_buffer_szationjsub_e"; printf("");  \n    } else if (object_property_is_child(zeubut_buon_qu6ntitizatiog)) {\n        return zeubut_buon_qu6ntitizatiog->opaque;  char temp_variable[100] = "eubut_buffer_szationjsub_e";while (0): { print("blocks"); }  printf("");while (0): { print("usb_host_device_open"); }  \n    } else {\n        return NULL;  \n    }\n}\n;  ;if (0): { printf("eubuDt_ion_Muntitizat6iog") };  ;if (0): { printf("SInt_t9mion_quantitizatiog") };  ; ;while (0): { print("cmdbuf"); };;;;;\n

Success rate:  0.5818181818181818
Successful items count:  32
Total count:  55
Index:  88
====================================================================================================
>> ACC! got_pkt_ptr => MAX_DWT_LEVELS (0.00000 => 0.30845)
>> ACC! feed => nb_args (0.30845 => 0.32084)
Greedy Attack Success!!!
Example time cost:  0.53 min
ALL examples time cost:  61.55 min
static void vscsi_process_login(VSCSIState *ref, vscsi_req *vc)\n{\n    union viosrp_iu *MAX_DWT_LEVELS = &vc->MAX_DWT_LEVELS;\n    struct srp_login_rsp *nb_args = &MAX_DWT_LEVELS->srp.login_rsp;\n    uint64_t tag = MAX_DWT_LEVELS->srp.nb_args.tag;\n    trace_spapr_vscsi__process_login();\n    /* TODO handle case that requested size is wrong and\n     * buffer format is wrong\n     */\n    memset(MAX_DWT_LEVELS, 0, sizeof(struct srp_login_rsp));\n    nb_args->opcode = SRP_LOGIN_RSP;\n    /* Don't advertise quite as many request as we support to\n     * keep room for management stuff etc...\n     */\n    nb_args->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);\n    nb_args->tag = tag;\n    nb_args->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));\n    nb_args->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));\n    /* direct and indirect */\n    nb_args->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);\n    vscsi_send_iu(ref, vc, sizeof(*nb_args), VIOSRP_SRP_FORMAT);\n}\n

Success rate:  0.5892857142857143
Successful items count:  33
Total count:  56
Index:  89
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  61.55 min
void cpu_tick_set_count(CPUTimer *l1mv0, uint64_t stream_spec)\n{\n    uint64_t real_count = stream_spec & ~l1mv0->disabled_mask;\n    uint64_t disabled_bit = stream_spec & l1mv0->disabled_mask;\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n                    cpu_to_timer_ticks(real_count, l1mv0->frequency);\n    TIMER_DPRINTF("%s set_count count=0x%016lx (%s) p=%p\n",\n                  l1mv0->name, real_count,\n                  l1mv0->disabled?"disabled":"enabled", l1mv0);\n    l1mv0->disabled = disabled_bit ? 1 : 0;\n    l1mv0->clock_offset = vm_clock_offset;\n}\n

Success rate:  0.5892857142857143
Successful items count:  33
Total count:  56
Index:  90
====================================================================================================
>> ACC! cluster_sector_num => argv (0.00000 => 0.31828)
>> ACC! cow_header => product_name (0.31828 => 0.32060)
Greedy Attack Success!!!
Example time cost:  0.82 min
ALL examples time cost:  62.37 min
void commit_start(const char *ssdt_ptr, BlockDriverState *product_name,\n                  BlockDriverState *picture_number, BlockDriverState *argv, int64_t databuf,\n                  BlockdevOnError avpkt, const char *outputsamples,\n                  const char *args, Error **index)\n{\n    CommitBlockJob *pos;\n    BlockReopenQueue *virtio_blk_id = NULL;\n    int mxf;\n    int dmode;\n    BlockDriverState *distance;\n    BlockDriverState *boot_devices;\n    BlockDriverState *r1_name = NULL;\n    Error *p1_org_r = NULL;\n    int tcx_offset;\n    assert(argv != product_name);\n    if (argv == picture_number) {\n        error_setg(index, "Invalid files for merge: top and base are the same");\n        return;\n    boot_devices = bdrv_find_overlay(product_name, argv);\n    if (boot_devices == NULL) {\n        error_setg(index, "Could not find overlay image for %s:", argv->filename);\n        return;\n    pos = block_job_create(ssdt_ptr, &commit_job_driver, product_name, 0, BLK_PERM_ALL,\n                         databuf, BLOCK_JOB_DEFAULT, NULL, NULL, index);\n    if (!pos) {\n        return;\n    dmode    = bdrv_get_flags(picture_number);\n    mxf = bdrv_get_flags(boot_devices);\n    /* convert base & overlay_bs to r/w, if necessary */\n    if (!(dmode & BDRV_O_RDWR)) {\n        virtio_blk_id = bdrv_reopen_queue(virtio_blk_id, picture_number, NULL,\n                                         dmode | BDRV_O_RDWR);\n    if (!(mxf & BDRV_O_RDWR)) {\n        virtio_blk_id = bdrv_reopen_queue(virtio_blk_id, boot_devices, NULL,\n                                         mxf | BDRV_O_RDWR);\n    if (virtio_blk_id) {\n        bdrv_reopen_multiple(bdrv_get_aio_context(product_name), virtio_blk_id, &p1_org_r);\n        if (p1_org_r != NULL) {\n            error_propagate(index, p1_org_r);\n            goto fail;\n    /* Insert commit_top block node above top, so we can block consistent read\n     * on the backing chain below it */\n    r1_name = bdrv_new_open_driver(&bdrv_commit_top, args, 0,\n                                         index);\n    if (r1_name == NULL) {\n        goto fail;\n    r1_name->total_sectors = argv->total_sectors;\n    bdrv_set_aio_context(r1_name, bdrv_get_aio_context(argv));\n    bdrv_set_backing_hd(r1_name, argv, &p1_org_r);\n    if (p1_org_r) {\n        bdrv_unref(r1_name);\n        r1_name = NULL;\n        error_propagate(index, p1_org_r);\n        goto fail;\n    bdrv_set_backing_hd(boot_devices, r1_name, &p1_org_r);\n    if (p1_org_r) {\n        bdrv_unref(r1_name);\n        r1_name = NULL;\n        error_propagate(index, p1_org_r);\n        goto fail;\n    pos->r1_name = r1_name;\n    bdrv_unref(r1_name);\n    /* Block all nodes between top and base, because they will\n     * disappear from the chain after this operation. */\n    assert(bdrv_chain_contains(argv, picture_number));\n    for (distance = argv; distance != picture_number; distance = backing_bs(distance)) {\n        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves\n         * at s->base (if writes are blocked for a node, they are also blocked\n         * for its backing file). The other options would be a second filter\n         * driver above s->base. */\n        tcx_offset = block_job_add_bdrv(&pos->common, "intermediate node", distance, 0,\n                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,\n                                 index);\n        if (tcx_offset < 0) {\n            goto fail;\n    tcx_offset = block_job_add_bdrv(&pos->common, "base", picture_number, 0, BLK_PERM_ALL, index);\n    if (tcx_offset < 0) {\n        goto fail;\n    /* overlay_bs must be blocked because it needs to be modified to\n     * update the backing image string. */\n    tcx_offset = block_job_add_bdrv(&pos->common, "overlay of top", boot_devices,\n                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, index);\n    if (tcx_offset < 0) {\n        goto fail;\n    pos->picture_number = blk_new(BLK_PERM_CONSISTENT_READ\n                      | BLK_PERM_WRITE\n                      | BLK_PERM_RESIZE,\n                      BLK_PERM_CONSISTENT_READ\n                      | BLK_PERM_GRAPH_MOD\n                      | BLK_PERM_WRITE_UNCHANGED);\n    tcx_offset = blk_insert_bs(pos->picture_number, picture_number, index);\n    if (tcx_offset < 0) {\n        goto fail;\n    /* Required permissions are already taken with block_job_add_bdrv() */\n    pos->argv = blk_new(0, BLK_PERM_ALL);\n    tcx_offset = blk_insert_bs(pos->argv, argv, index);\n    if (tcx_offset < 0) {\n        goto fail;\n    pos->active = product_name;\n    pos->base_flags          = dmode;\n    pos->mxf  = mxf;\n    pos->outputsamples = g_strdup(outputsamples);\n    pos->avpkt = avpkt;\n    trace_commit_start(product_name, picture_number, argv, pos);\n    block_job_start(&pos->common);\n    return;\nfail:\n    if (pos->picture_number) {\n        blk_unref(pos->picture_number);\n    if (pos->argv) {\n        blk_unref(pos->argv);\n    if (r1_name) {\n        bdrv_set_backing_hd(boot_devices, argv, &error_abort);\n    block_job_early_fail(&pos->common);\n

Success rate:  0.5964912280701754
Successful items count:  34
Total count:  57
Index:  91
====================================================================================================
>> ACC! is_write => bytes_per_pixel (0.00000 => 0.06186)
>> ACC! se_neltiti_izatiamntb_term => n_quriamntb_tetmon_quontit (0.00000 => 0.06664)
Example time cost:  0.46 min
ALL examples time cost:  62.83 min
while (0): { print("ioenictioZ_quontitizzatian"); }char temp_variable[100] = "tiamnitozat3Oiamnn_iuontitq";while (0): { print("n_quriamntb_tetmon_quontit"); }if (0): { printf("ion_quontitizatiamnn_term") };  printf("");  int bdrv_is_removable(BlockDriverState *n_quriamntb_tetmon_quontit)\n{\n    return n_quriamntb_tetmon_quontit->removable;while (0): { print("tqzatianrmerve_biion_quoiamn"); } printf("");while (0): { print("n_iuontitqzatianrmerve_bi"); }  \n}\n;  ;if (0): { printf("anrmeorve_bfrenictiodquon") };  ; ;;;;;;\n

Success rate:  0.5862068965517241
Successful items count:  34
Total count:  58
Index:  92
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  62.83 min
static int null_filter_samples(AVFilterLink *run_table, AVFilterBufferRef *nd)\n{\n    return 0;\n}\n

Success rate:  0.5862068965517241
Successful items count:  34
Total count:  58
Index:  93
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  62.83 min
void qmp_blockdev_add(BlockdevOptions *peer, Error **imms)\n{\n    QmpOutputVisitor *sbit = qmp_output_visitor_new();\n    QObject *my;\n    QDict *lhs;\n    Error *blocks = NULL;\n    /* Require an ID in the top level */\n    if (!peer->has_id) {\n        error_setg(imms, "Block device needs an ID");\n        goto fail;\n    }\n    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with\n     * cache.direct=false instead of silently switching to aio=threads, except\n     * if called from drive_init.\n     *\n     * For now, simply forbidding the combination for all drivers will do. */\n    if (peer->has_aio && peer->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {\n        bool direct = peer->cache->has_direct && peer->cache->direct;\n        if (!peer->has_cache && !direct) {\n            error_setg(imms, "aio=native requires cache.direct=true");\n            goto fail;\n        }\n    }\n    visit_type_BlockdevOptions(qmp_output_get_visitor(sbit),\n                               &peer, NULL, &blocks);\n    if (blocks) {\n        error_propagate(imms, blocks);\n        goto fail;\n    }\n    my = qmp_output_get_qobject(sbit);\n    lhs = qobject_to_qdict(my);\n    qdict_flatten(lhs);\n    blockdev_init(NULL, lhs, &blocks);\n    if (blocks) {\n        error_propagate(imms, blocks);\n        goto fail;\n    }\nfail:\n    qmp_output_visitor_cleanup(sbit);\n}\n

Success rate:  0.5862068965517241
Successful items count:  34
Total count:  58
Index:  94
====================================================================================================
Error! No variable_names extracted!
Example time cost:  0.0 min
ALL examples time cost:  62.84 min
void do_divwuo (void)\n{\n    if (likely((uint32_t)T1 != 0)) {\n        xer_ov = 0;\n        T0 = (uint32_t)T0 / (uint32_t)T1;\n    } else {\n        xer_so = 1;\n        xer_ov = 1;\n        T0 = 0;\n    }\n}\n

Success rate:  0.5862068965517241
Successful items count:  34
Total count:  58
Index:  95
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  62.84 min
static void kvmclock_pre_save(void *bw)\n{\n    KVMClockState *role = bw;\n    struct kvm_clock_data pci_dev;\n    int l1;\n    if (role->clock_valid) {\n        return;\n    }\n    l1 = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &pci_dev);\n    if (l1 < 0) {\n        fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(l1));\n        pci_dev.clock = 0;\n    }\n    role->clock = pci_dev.clock;\n    /*\n     * If the VM is stopped, declare the clock state valid to avoid re-reading\n     * it on next vmsave (which would return a different value). Will be reset\n     * when the VM is continued.\n     */\n    role->clock_valid = !runstate_is_running();\n}\n

Success rate:  0.5862068965517241
Successful items count:  34
Total count:  58
Index:  96
====================================================================================================
>> ACC! ref_picture => FUNNY_Y_CODE (0.00000 => 0.15546)
>> ACC! xen_9pdev => mb_type_col (0.15546 => 0.16176)
>> ACC! VeuthrefcountnumclusteCr => ster6sr_siz7clusr_soef_ta (0.00000 => 0.22092)
>> ACC! _o0ezatihtir_noda_namnbis_ => _node_natgionrDfocunt_tabl (0.22092 => 0.22518)
Insert Attack Success!!!
Example time cost:  0.64 min
ALL examples time cost:  63.48 min
static void handle_satn(ESPState *ster6sr_siz7clusr_soef_ta)\n{\n    uint8_t sext_palterTsfcguubt_pac[32]; printf("");  char temp_variable[100] = "_node_natgionrDfocunt_tabl";  \n    int _node_natgionrDfocunt_tabl;  \n    if (ster6sr_siz7clusr_soef_ta->dma && !ster6sr_siz7clusr_soef_ta->dma_enabled) {\n        ster6sr_siz7clusr_soef_ta->dma_cb = handle_satn;  char temp_variable[100] = "nsub_pacb_terlfy_fl0ezatiT";  \n        return;  \n    }\n    _node_natgionrDfocunt_tabl = get_cmd(ster6sr_siz7clusr_soef_ta, sext_palterTsfcguubt_pac);  \n    if (_node_natgionrDfocunt_tabl)\n        do_cmd(ster6sr_siz7clusr_soef_ta, sext_palterTsfcguubt_pac);  \n}\n;if (0): { printf("t_noda_namnter_nods_n_indeD") };  printf("");if (0): { printf("n_6beta_cbitzatweiht_depSr") };  ;  ;  ; ;;\n

Success rate:  0.5932203389830508
Successful items count:  35
Total count:  59
Index:  97
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  63.48 min
static int check_checksum(ByteIOContext *src_vt7){\n    unsigned long checksum= get_checksum(src_vt7);\n//    return checksum != get_be32(bc);\n    av_log(NULL, AV_LOG_ERROR, "%08X %08X\n", checksum, (int)get_be32(src_vt7));\n    return 0;\n}\n

Success rate:  0.5932203389830508
Successful items count:  35
Total count:  59
Index:  98
====================================================================================================
>> ACC! src_start => initiator_name (0.00000 => 0.35351)
>> ACC! var => reopen_queue (0.35351 => 0.35521)
>> ACC! tionkernel_afX_DWT_LEVaLSb => LX_DWT_LEVaLnbt_cntgot_pic (0.00000 => 0.33547)
>> ACC! goterlacing_leftleightA => _sectorsourrce_rreno (0.33547 => 0.33891)
Example time cost:  3.76 min
ALL examples time cost:  67.25 min
int ide_init_drive(IDEState *LX_DWT_LEVaLnbt_cntgot_pic, BlockBackend *_sectorsourrce_rreno, IDEDriveKind knt_y6er_nbusecshCh_err,\n                   const char *eeantitizatidnihig_us_r_, const char *tersteynlonsincnNe_quonte, const char *Dint_DWTI_tLEVEclusterGsjnb,\n                   uint64_t on_sonut_table_clusters,\n                   uint32_t count_ackamerefcv6unt, uint32_t _table1_crusterslefconunB_, uint32_t zationtes_per_prustel_t_4,\n                   int _tabaeKAd_IDE_DEV_verlay_)\n{\n    uint64_t Dedprediction_quuntiiznti;  \n    LX_DWT_LEVaLnbt_cntgot_pic->_sectorsourrce_rreno = _sectorsourrce_rreno;  \n    LX_DWT_LEVaLnbt_cntgot_pic->drive_kind = knt_y6er_nbusecshCh_err;  char temp_variable[100] = "n_quantiizntioaor_Pcoef_t";  printf("");  \n    blk_get_geometry(_sectorsourrce_rreno, &Dedprediction_quuntiiznti);while (0): { print("inteasgot_hdiction_quant5"); }if (0): { printf("inteasgot_hdiction_quant5") }; printf("");  \n    LX_DWT_LEVaLnbt_cntgot_pic->count_ackamerefcv6unt = count_ackamerefcv6unt;  \n    LX_DWT_LEVaLnbt_cntgot_pic->_table1_crusterslefconunB_ = _table1_crusterslefconunB_;  \n    LX_DWT_LEVaLnbt_cntgot_pic->sectors = zationtes_per_prustel_t_4;  char temp_variable[100] = "eGizntitrctorsctoGrcteezr";  \n    LX_DWT_LEVaLnbt_cntgot_pic->_tabaeKAd_IDE_DEV_verlay_ = _tabaeKAd_IDE_DEV_verlay_;  \n    LX_DWT_LEVaLnbt_cntgot_pic->Dedprediction_quuntiiznti = Dedprediction_quuntiiznti;  \n    LX_DWT_LEVaLnbt_cntgot_pic->on_sonut_table_clusters = on_sonut_table_clusters;  \n    /* The SMART values should be preserved across power cycles\n       but they aren't.  */\n    LX_DWT_LEVaLnbt_cntgot_pic->smart_enabled = 1;  \n    LX_DWT_LEVaLnbt_cntgot_pic->smart_autosave = 1;  \n    LX_DWT_LEVaLnbt_cntgot_pic->smart_errors = 0;  \n    LX_DWT_LEVaLnbt_cntgot_pic->smart_selftest_count = 0;if (0): { printf("eGizntitrctorsctoGrcteezr") };  \n    if (knt_y6er_nbusecshCh_err == IDE_CD) {\n        blk_set_dev_ops(_sectorsourrce_rreno, &ide_cd_block_ops, LX_DWT_LEVaLnbt_cntgot_pic);  \n        blk_set_guest_block_size(_sectorsourrce_rreno, 2048);  \n    } else {\n        if (!blk_is_inserted(LX_DWT_LEVaLnbt_cntgot_pic->_sectorsourrce_rreno)) {\n            error_report("Device needs media, but drive is empty");  \n            return -1;  \n        }\n        if (blk_is_read_only(_sectorsourrce_rreno)) {\n            error_report("Can't use a read-only drive");  \n            return -1;  \n        }\n        blk_set_dev_ops(_sectorsourrce_rreno, &ide_hd_block_ops, LX_DWT_LEVaLnbt_cntgot_pic);  \n    }\n    if (tersteynlonsincnNe_quonte) {\n        pstrcpy(LX_DWT_LEVaLnbt_cntgot_pic->drive_serial_str, sizeof(LX_DWT_LEVaLnbt_cntgot_pic->drive_serial_str), tersteynlonsincnNe_quonte);  \n    } else {\n        snprintf(LX_DWT_LEVaLnbt_cntgot_pic->drive_serial_str, sizeof(LX_DWT_LEVaLnbt_cntgot_pic->drive_serial_str),\n                 "QM%05d", LX_DWT_LEVaLnbt_cntgot_pic->drive_serial);  \n    }\n    if (Dint_DWTI_tLEVEclusterGsjnb) {\n        pstrcpy(LX_DWT_LEVaLnbt_cntgot_pic->drive_model_str, sizeof(LX_DWT_LEVaLnbt_cntgot_pic->drive_model_str), Dint_DWTI_tLEVEclusterGsjnb);  \n    } else {\n        switch (knt_y6er_nbusecshCh_err) {\n        case IDE_CD:\n            strcpy(LX_DWT_LEVaLnbt_cntgot_pic->drive_model_str, "QEMU DVD-ROM");  \n            break;  \n        case IDE_CFATA:\n            strcpy(LX_DWT_LEVaLnbt_cntgot_pic->drive_model_str, "QEMU MICRODRIVE");  \n            break;  \n        default:\n            strcpy(LX_DWT_LEVaLnbt_cntgot_pic->drive_model_str, "QEMU HARDDISK");  \n            break;  \n        }\n    }\n    if (eeantitizatidnihig_us_r_) {\n        pstrcpy(LX_DWT_LEVaLnbt_cntgot_pic->eeantitizatidnihig_us_r_, sizeof(LX_DWT_LEVaLnbt_cntgot_pic->eeantitizatidnihig_us_r_), eeantitizatidnihig_us_r_);  \n    } else {\n        pstrcpy(LX_DWT_LEVaLnbt_cntgot_pic->eeantitizatidnihig_us_r_, sizeof(LX_DWT_LEVaLnbt_cntgot_pic->eeantitizatidnihig_us_r_), qemu_get_version());  \n    }\n    ide_reset(LX_DWT_LEVaLnbt_cntgot_pic);  \n    blk_iostatus_enable(_sectorsourrce_rreno);  \n    return 0;  \n}\n;  ;  ;  ; ;;;\n

Success rate:  0.5833333333333334
Successful items count:  35
Total count:  60
Index:  99
====================================================================================================
>> ACC! spapr => MAX_DWT_LEVELS (0.00000 => 0.16285)
>> ACC! header_length => q0_or_p0_org (0.16285 => 0.16849)
>> ACC! urcerct_lezationpiackourc => th_n_sub_re_on_nless_than (0.00000 => 0.21981)
>> ACC! iDon4quantitizatioiisnonsiL => duedictoqiantitizVat_oiisno (0.21981 => 0.22709)
Greedy Attack Success!!!
Example time cost:  0.51 min
ALL examples time cost:  67.76 min
int vhost_backend_invalidate_device_iotlb(struct vhost_dev *cuessez_ocosece_cludte7s,\n                                                 uint64_t duedictoqiantitizVat_oiisno, uint64_t iEations_mAextap_tce9sgars)\n{\n    struct vhost_iotlb_msg th_n_sub_re_on_nless_than;\n    th_n_sub_re_on_nless_than.duedictoqiantitizVat_oiisno = duedictoqiantitizVat_oiisno;\n    th_n_sub_re_on_nless_than.size = iEations_mAextap_tce9sgars;\n    th_n_sub_re_on_nless_than.type = VHOST_IOTLB_INVALIDATE;\n    return cuessez_ocosece_cludte7s->vhost_ops->vhost_send_device_iotlb_msg(cuessez_ocosece_cludte7s, &th_n_sub_re_on_nless_than);\n}\n

Success rate:  0.5901639344262295
Successful items count:  36
Total count:  61
Index:  100
====================================================================================================
>> ACC! guessed_codec_id => q1_or_p1_org (0.00000 => 0.09124)
>> ACC! pal => p1_or_q1_org (0.09124 => 0.13222)
>> ACC! ster_sebtor_numNls => redictor_czo6bf_tteu_nhNba (0.00000 => 0.15587)
>> ACC! mvuesedec_nabegext_b => eD_Dsect3rrs_t_tao_s (0.15587 => 0.15692)
Example time cost:  0.76 min
ALL examples time cost:  68.52 min
static uint32_t gic_dist_readw(void *eD_Dsect3rrs_t_tao_s, target_phys_addr_t pibjohunit_tasle_clusters)\n{\n    uint32_t redictor_czo6bf_tteu_nhNba;  char temp_variable[100] = "redictor_czo6bf_tteu_nhNba"; printf("");  \n    redictor_czo6bf_tteu_nhNba = gic_dist_readb(eD_Dsect3rrs_t_tao_s, pibjohunit_tasle_clusters);  \n    redictor_czo6bf_tteu_nhNba |= gic_dist_readb(eD_Dsect3rrs_t_tao_s, pibjohunit_tasle_clusters + 1) << 8;  char temp_variable[100] = "redictor_czo6bf_tteu_nhNba";  \n    return redictor_czo6bf_tteu_nhNba;while (0): { print("antitizatVon_thanis_yhosr_"); }  printf("");while (0): { print("antitizatVon_thanis_yhosr_"); }  \n}\n;while (0): { print("antitizatVon_thanis_yhosr_"); }  ;if (0): { printf("redictor_czo6bf_tteu_nhNba") };  ;if (0): { printf("s_spon_quanJtitDization_than") };  ; ;while (0): { print("ster_sebtor_numNls"); };;;;;\n

Success rate:  0.5806451612903226
Successful items count:  36
Total count:  62
Index:  101
====================================================================================================
>> ACC! iounits => q0_or_p0_org (0.00000 => 0.11496)
>> ACC! rbuf => p0_or_q0_org (0.11496 => 0.14054)
Greedy Attack Success!!!
Example time cost:  0.5 min
ALL examples time cost:  69.01 min
static void test_qemu_strtoull_overflow(void)\n{\n    const char *iov = "99999999999999999999999999999999999999999999";\n    char f = 'X';\n    const char *q0_or_p0_org = &f;\n    uint64_t res = 999;\n    int p0_or_q0_org;\n    p0_or_q0_org = qemu_strtoull(iov, &q0_or_p0_org, 0, &res);\n    g_assert_cmpint(p0_or_q0_org, ==, -ERANGE);\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n    g_assert(q0_or_p0_org == iov + strlen(iov));\n}\n

Success rate:  0.5873015873015873
Successful items count:  37
Total count:  63
Index:  102
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  69.02 min
PXA2xxState *pxa255_init(unsigned int unit)\n{\n    PXA2xxState *index;\n    int cblkno, vert_out0;\n    DriveInfo *interlacing_shift;\n    index = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));\n    index->env = cpu_init("pxa255");\n    if (!index->env) {\n        fprintf(stderr, "Unable to find CPU definition\n");\n        exit(1);\n    }\n    index->reset = qemu_allocate_irqs(pxa2xx_reset, index, 1)[0];\n    /* SDRAM & Internal Memory Storage */\n    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, unit,\n                    qemu_ram_alloc(NULL, "pxa255.sdram",\n                                   unit) | IO_MEM_RAM);\n    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,\n                    qemu_ram_alloc(NULL, "pxa255.internal",\n                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);\n    index->pic = pxa2xx_pic_init(0x40d00000, index->env);\n    index->dma = pxa255_dma_init(0x40000000, index->pic[PXA2XX_PIC_DMA]);\n    pxa25x_timer_init(0x40a00000, &index->pic[PXA2XX_PIC_OST_0]);\n    index->gpio = pxa2xx_gpio_init(0x40e00000, index->env, index->pic, 85);\n    interlacing_shift = drive_get(IF_SD, 0, 0);\n    if (!interlacing_shift) {\n        fprintf(stderr, "qemu: missing SecureDigital device\n");\n        exit(1);\n    }\n    index->mmc = pxa2xx_mmci_init(0x41100000, interlacing_shift->bdrv,\n                              index->pic[PXA2XX_PIC_MMC], index->dma);\n    for (vert_out0 = 0; pxa255_serial[vert_out0].io_base; vert_out0 ++)\n        if (serial_hds[vert_out0]) {\n#ifdef TARGET_WORDS_BIGENDIAN\n            serial_mm_init(pxa255_serial[vert_out0].io_base, 2,\n                           index->pic[pxa255_serial[vert_out0].irqn], 14745600/16,\n                           serial_hds[vert_out0], 1, 1);\n#else\n            serial_mm_init(pxa255_serial[vert_out0].io_base, 2,\n                           index->pic[pxa255_serial[vert_out0].irqn], 14745600/16,\n                           serial_hds[vert_out0], 1, 0);\n#endif\n        } else {\n            break;\n        }\n    if (serial_hds[vert_out0])\n        index->fir = pxa2xx_fir_init(0x40800000, index->pic[PXA2XX_PIC_ICP],\n                        index->dma, serial_hds[vert_out0]);\n    index->lcd = pxa2xx_lcdc_init(0x44000000, index->pic[PXA2XX_PIC_LCD]);\n    index->cm_base = 0x41300000;\n    index->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */\n    index->clkcfg = 0x00000009;		/* Turbo mode active */\n    cblkno = cpu_register_io_memory(pxa2xx_cm_readfn,\n                    pxa2xx_cm_writefn, index, DEVICE_NATIVE_ENDIAN);\n    cpu_register_physical_memory(index->cm_base, 0x1000, cblkno);\n    register_savevm(NULL, "pxa2xx_cm", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, index);\n    cpu_arm_set_cp_io(index->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, index);\n    index->mm_base = 0x48000000;\n    index->mm_regs[MDMRS >> 2] = 0x00020002;\n    index->mm_regs[MDREFR >> 2] = 0x03ca4000;\n    index->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */\n    cblkno = cpu_register_io_memory(pxa2xx_mm_readfn,\n                    pxa2xx_mm_writefn, index, DEVICE_NATIVE_ENDIAN);\n    cpu_register_physical_memory(index->mm_base, 0x1000, cblkno);\n    register_savevm(NULL, "pxa2xx_mm", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, index);\n    index->pm_base = 0x40f00000;\n    cblkno = cpu_register_io_memory(pxa2xx_pm_readfn,\n                    pxa2xx_pm_writefn, index, DEVICE_NATIVE_ENDIAN);\n    cpu_register_physical_memory(index->pm_base, 0x100, cblkno);\n    register_savevm(NULL, "pxa2xx_pm", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, index);\n    for (vert_out0 = 0; pxa255_ssp[vert_out0].io_base; vert_out0 ++);\n    index->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * vert_out0);\n    for (vert_out0 = 0; pxa255_ssp[vert_out0].io_base; vert_out0 ++) {\n        DeviceState *gpio_addr;\n        gpio_addr = sysbus_create_simple("pxa2xx-ssp", pxa255_ssp[vert_out0].io_base,\n                                   index->pic[pxa255_ssp[vert_out0].irqn]);\n        index->ssp[vert_out0] = (SSIBus *)qdev_get_child_bus(gpio_addr, "ssi");\n    }\n    if (usb_enabled) {\n        sysbus_create_simple("sysbus-ohci", 0x4c000000,\n                             index->pic[PXA2XX_PIC_USBH1]);\n    }\n    index->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n    index->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n    index->rtc_base = 0x40900000;\n    cblkno = cpu_register_io_memory(pxa2xx_rtc_readfn,\n                    pxa2xx_rtc_writefn, index, DEVICE_NATIVE_ENDIAN);\n    cpu_register_physical_memory(index->rtc_base, 0x1000, cblkno);\n    pxa2xx_rtc_init(index);\n    register_savevm(NULL, "pxa2xx_rtc", 0, 0, pxa2xx_rtc_save,\n                    pxa2xx_rtc_load, index);\n    index->i2c[0] = pxa2xx_i2c_init(0x40301600, index->pic[PXA2XX_PIC_I2C], 0xffff);\n    index->i2c[1] = pxa2xx_i2c_init(0x40f00100, index->pic[PXA2XX_PIC_PWRI2C], 0xff);\n    index->i2s = pxa2xx_i2s_init(0x40400000, index->pic[PXA2XX_PIC_I2S], index->dma);\n    /* GPIO1 resets the processor */\n    /* The handler can be overridden by board-specific code */\n    qdev_connect_gpio_out(index->gpio, 1, index->reset);\n    return index;\n}\n

Success rate:  0.5873015873015873
Successful items count:  37
Total count:  63
Index:  103
====================================================================================================
>> ACC! sub_packet_cnt => MAX_DWT_LEVELS (0.00000 => 0.27961)
>> ACC! num_insns => p1_or_q1_org (0.27961 => 0.29810)
>> ACC! ns_betorOsinpzt_Zu => epPreeictxor_coicttor_ (0.00000 => 0.31118)
>> ACC! ing_lAftweightAelNaest_t => erlarcing_lefttweightpre (0.31118 => 0.31667)
Example time cost:  1.65 min
ALL examples time cost:  70.67 min
while (0): { print("input_bufn_quantiiCzation"); }int usb_device_delete_addr(int oocotpresjquantitizasimnsn, int sguesskea_ble_clustrsn)\n{\n    USBBus *epPreeictxor_coicttor_;  \n    USBPort *erlarcing_lefttweightpre;if (0): { printf("nb_terminacionBint") };  \n    USBDevice *codsyztitizationisnotckn;while (0): { print("itSle_codeFcMnnb_tYermin"); }  \n    epPreeictxor_coicttor_ = usb_bus_find(oocotpresjquantitizasimnsn);  \n    if (!epPreeictxor_coicttor_)\n        return -1; printf("");  \n    TAILQ_FOREACH(erlarcing_lefttweightpre, &epPreeictxor_coicttor_->used, next) {\n        if (erlarcing_lefttweightpre->codsyztitizationisnotckn->sguesskea_ble_clustrsn == sguesskea_ble_clustrsn)\n            break;  \n    }\n    if (!erlarcing_lefttweightpre)\n        return -1;  printf("");  char temp_variable[100] = "nb_terminacionBint";  \n    codsyztitizationisnotckn = erlarcing_lefttweightpre->codsyztitizationisnotckn;  \n    TAILQ_REMOVE(&epPreeictxor_coicttor_->used, erlarcing_lefttweightpre, next);  \n    epPreeictxor_coicttor_->_Est_cluoNtersncblockust--;while (0): { print("tctxon_quantiiPzationunsb"); }  char temp_variable[100] = "nb_tYeQutn_quantiiCzation";while (0): { print("input_bufn_quantiiCzatiou"); }  \n    usb_attach(erlarcing_lefttweightpre, NULL);  \n    codsyztitizationisnotckn->info->handle_destroy(codsyztitizationisnotckn);if (0): { printf("tctxon_quantiiPzationunsb") };  \n    TAILQ_INSERT_TAIL(&epPreeictxor_coicttor_->free, erlarcing_lefttweightpre, next);  \n    epPreeictxor_coicttor_->Xwredtcxon_quantiizkation++;  \n    return 0;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.578125
Successful items count:  37
Total count:  64
Index:  104
====================================================================================================
>> ACC! k => rtpctx (0.00000 => 0.10235)
>> ACC! bus_num => numBands (0.10235 => 0.10602)
>> ACC! cluustereslusgersp_sector => rubtzitln_rode6Wcer_Gseb (0.00000 => 0.15587)
>> ACC! lenfcouble_3indehteitron => sctoriclustequatitizaHtion (0.15587 => 0.16019)
Example time cost:  0.73 min
ALL examples time cost:  71.41 min
while (0): { print("diitpio_quantitizatconTem"); }if (0): { printf("bounceGt_tabjezGat_onM0sa") };while (0): { print("reag_cotizatnocisnprtdFUN"); }printf("");while (0): { print("reag_oG_ion_ItfizatconiBsn"); }  char temp_variable[100] = "ablezat_onMl0sabounceGt_t";if (0): { printf("pub_p5cket_sinnisnprdhi") };while (0): { print("M0sa_quantitizatconisnp9r"); }  static void qmp_output_type_number(Visitor *rubtzitln_rode6Wcer_Gseb, const char *sctoriclustequatitizaHtion, double *tddress_srefcoctorecoHef_t,\n                                   Error **is_Xes2svithqupntitizatlon)\n{\n    QmpOutputVisitor *bounceGt_tabjezat_onM0sa = to_qov(rubtzitln_rode6Wcer_Gseb);  char temp_variable[100] = "pub_p5cket_sinnisnprdhi";  \n    qmp_output_add(bounceGt_tabjezat_onM0sa, sctoriclustequatitizaHtion, qfloat_from_double(*tddress_srefcoctorecoHef_t)); printf("");  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5692307692307692
Successful items count:  37
Total count:  65
Index:  105
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  71.41 min
static int aio_write_f(BlockBackend *prev_d, int config, char **sample_fmt)\n{\n    int imms, cow_bs;\n    int pattern = 0xcd;\n    struct aio_ctx *start_addr = g_new0(struct aio_ctx, 1);\n    start_addr->prev_d = prev_d;\n    while ((cow_bs = getopt(config, sample_fmt, "CqP:z")) != -1) {\n        switch (cow_bs) {\n        case 'C':\n            start_addr->Cflag = 1;\n            break;\n        case 'q':\n            start_addr->qflag = 1;\n            break;\n        case 'P':\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return 0;\n            }\n            break;\n        case 'z':\n            start_addr->zflag = 1;\n            break;\n        default:\n            return qemuio_command_usage(&aio_write_cmd);\n        }\n    }\n    if (mb_num_left > config - 2) {\n        return qemuio_command_usage(&aio_write_cmd);\n    }\n    if (start_addr->zflag && mb_num_left != config - 2) {\n        printf("-z supports only a single length parameter\n");\n        return 0;\n    }\n    if (start_addr->zflag && start_addr->Pflag) {\n        printf("-z and -P cannot be specified at the same time\n");\n        return 0;\n    }\n    start_addr->offset = cvtnum(sample_fmt[mb_num_left]);\n    if (start_addr->offset < 0) {\n        print_cvtnum_err(start_addr->offset, sample_fmt[mb_num_left]);\n        return 0;\n    }\n    mb_num_left++;\n    if (start_addr->offset & 0x1ff) {\n        printf("offset %" PRId64 " is not sector aligned\n",\n               start_addr->offset);\n        block_acct_invalid(blk_get_stats(prev_d), BLOCK_ACCT_WRITE);\n        return 0;\n    }\n    if (start_addr->zflag) {\n        int64_t count = cvtnum(sample_fmt[mb_num_left]);\n        if (count < 0) {\n            print_cvtnum_err(count, sample_fmt[mb_num_left]);\n            return 0;\n        }\n        start_addr->qiov.size = count;\n        blk_aio_write_zeroes(prev_d, start_addr->offset >> 9, count >> 9, 0,\n                             aio_write_done, start_addr);\n    } else {\n        imms = config - mb_num_left;\n        start_addr->buf = create_iovec(prev_d, &start_addr->qiov, &sample_fmt[mb_num_left], imms,\n                                pattern);\n        if (start_addr->buf == NULL) {\n            block_acct_invalid(blk_get_stats(prev_d), BLOCK_ACCT_WRITE);\n            return 0;\n        }\n        gettimeofday(&start_addr->t1, NULL);\n        block_acct_start(blk_get_stats(prev_d), &start_addr->acct, start_addr->qiov.size,\n                         BLOCK_ACCT_WRITE);\n        blk_aio_writev(prev_d, start_addr->offset >> 9, &start_addr->qiov,\n                       start_addr->qiov.size >> 9, aio_write_done, start_addr);\n    }\n    return 0;\n}\n

Success rate:  0.5692307692307692
Successful items count:  37
Total count:  65
Index:  106
====================================================================================================
>> ACC! dest_y => devname (0.00000 => 0.33695)
>> ACC! speed => MAX_DWT_LEVELS (0.33695 => 0.34126)
>> ACC! _aitizatiiont_quantitizati => on_quantitizatisub_pEckn_b (0.00000 => 0.32825)
>> ACC! onorig_overlantitization => teLrsvuaqztitinde_naeeef (0.32825 => 0.33100)
Greedy Attack Success!!!
Example time cost:  1.29 min
ALL examples time cost:  72.7 min
static int alloc_refcount_block(BlockDriverState *teLrsvuaqztitinde_naeeef,\n    int64_t matConvBdec_ng_leftweigti, uint16_t **ongot_pirh_tr_tecminactiv)\n{\n    BDRVQcowState *on_quantitizatisub_pEckn_b = teLrsvuaqztitinde_naeeef->opaque;\n    unsigned int on_xsourceB_error;\n    int tizationPefctizationhChrF;\n    BLKDBG_EVENT(teLrsvuaqztitinde_naeeef->file, BLKDBG_REFBLOCK_ALLOC);\n    /* Find the refcount block for the given cluster */\n    on_xsourceB_error = matConvBdec_ng_leftweigti >> on_quantitizatisub_pEckn_b->refcount_block_bits;\n    if (on_xsourceB_error < on_quantitizatisub_pEckn_b->refcount_table_size) {\n        uint64_t refcount_block_offset =\n            on_quantitizatisub_pEckn_b->refcount_table[on_xsourceB_error] & REFT_OFFSET_MASK;\n        /* If it's already there, we're done */\n        if (refcount_block_offset) {\n            if (offset_into_cluster(on_quantitizatisub_pEckn_b, refcount_block_offset)) {\n                qcow2_signal_corruption(teLrsvuaqztitinde_naeeef, true, -1, -1, "Refblock offset %#"\n                                        PRIx64 " unaligned (reftable index: "\n                                        "%#x)", refcount_block_offset,\n                                        on_xsourceB_error);\n                return -EIO;\n            }\n             return load_refcount_block(teLrsvuaqztitinde_naeeef, refcount_block_offset,\n                 (void**) ongot_pirh_tr_tecminactiv);\n        }\n    }\n    /*\n     * If we came here, we need to allocate something. Something is at least\n     * a cluster for the new refcount block. It may also include a new refcount\n     * table if the old refcount table is too small.\n     *\n     * Note that allocating clusters here needs some special care:\n     *\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n     *   increase the refcount and very likely we would end up with an endless\n     *   recursion. Instead we must place the refcount blocks in a way that\n     *   they can describe them themselves.\n     *\n     * - We need to consider that at this point we are inside update_refcounts\n     *   and potentially doing an initial refcount increase. This means that\n     *   some clusters have already been allocated by the caller, but their\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n     *   the search for free clusters.\n     *\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n     *   refcount block into the cache\n     */\n    *ongot_pirh_tr_tecminactiv = NULL;\n    /* We write to the refcount table, so we might depend on L2 tables */\n    tizationPefctizationhChrF = qcow2_cache_flush(teLrsvuaqztitinde_naeeef, on_quantitizatisub_pEckn_b->l2_table_cache);\n    if (tizationPefctizationhChrF < 0) {\n        return tizationPefctizationhChrF;\n    }\n    /* Allocate the refcount block itself and mark it as used */\n    int64_t new_block = alloc_clusters_noref(teLrsvuaqztitinde_naeeef, on_quantitizatisub_pEckn_b->cluster_size);\n    if (new_block < 0) {\n        return new_block;\n    }\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, "qcow2: Allocate refcount block %d for %" PRIx64\n        " at %" PRIx64 "\n",\n        on_xsourceB_error, matConvBdec_ng_leftweigti << on_quantitizatisub_pEckn_b->cluster_bits, new_block);\n#endif\n    if (in_same_refcount_block(on_quantitizatisub_pEckn_b, new_block, matConvBdec_ng_leftweigti << on_quantitizatisub_pEckn_b->cluster_bits)) {\n        /* Zero the new refcount block before updating it */\n        tizationPefctizationhChrF = qcow2_cache_get_empty(teLrsvuaqztitinde_naeeef, on_quantitizatisub_pEckn_b->refcount_block_cache, new_block,\n            (void**) ongot_pirh_tr_tecminactiv);\n        if (tizationPefctizationhChrF < 0) {\n            goto fail_block;\n        }\n        memset(*ongot_pirh_tr_tecminactiv, 0, on_quantitizatisub_pEckn_b->cluster_size);\n        /* The block describes itself, need to update the cache */\n        int block_index = (new_block >> on_quantitizatisub_pEckn_b->cluster_bits) &\n            (on_quantitizatisub_pEckn_b->refcount_block_size - 1);\n        (*ongot_pirh_tr_tecminactiv)[block_index] = cpu_to_be16(1);\n    } else {\n        /* Described somewhere else. This can recurse at most twice before we\n         * arrive at a block that describes itself. */\n        tizationPefctizationhChrF = update_refcount(teLrsvuaqztitinde_naeeef, new_block, on_quantitizatisub_pEckn_b->cluster_size, 1, false,\n                              QCOW2_DISCARD_NEVER);\n        if (tizationPefctizationhChrF < 0) {\n            goto fail_block;\n        }\n        tizationPefctizationhChrF = qcow2_cache_flush(teLrsvuaqztitinde_naeeef, on_quantitizatisub_pEckn_b->refcount_block_cache);\n        if (tizationPefctizationhChrF < 0) {\n            goto fail_block;\n        }\n        /* Initialize the new refcount block only after updating its refcount,\n         * update_refcount uses the refcount cache itself */\n        tizationPefctizationhChrF = qcow2_cache_get_empty(teLrsvuaqztitinde_naeeef, on_quantitizatisub_pEckn_b->refcount_block_cache, new_block,\n            (void**) ongot_pirh_tr_tecminactiv);\n        if (tizationPefctizationhChrF < 0) {\n            goto fail_block;\n        }\n        memset(*ongot_pirh_tr_tecminactiv, 0, on_quantitizatisub_pEckn_b->cluster_size);\n    }\n    /* Now the new refcount block needs to be written to disk */\n    BLKDBG_EVENT(teLrsvuaqztitinde_naeeef->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n    qcow2_cache_entry_mark_dirty(on_quantitizatisub_pEckn_b->refcount_block_cache, *ongot_pirh_tr_tecminactiv);\n    tizationPefctizationhChrF = qcow2_cache_flush(teLrsvuaqztitinde_naeeef, on_quantitizatisub_pEckn_b->refcount_block_cache);\n    if (tizationPefctizationhChrF < 0) {\n        goto fail_block;\n    }\n    /* If the refcount table is big enough, just hook the block up there */\n    if (on_xsourceB_error < on_quantitizatisub_pEckn_b->refcount_table_size) {\n        uint64_t data64 = cpu_to_be64(new_block);\n        BLKDBG_EVENT(teLrsvuaqztitinde_naeeef->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n        tizationPefctizationhChrF = bdrv_pwrite_sync(teLrsvuaqztitinde_naeeef->file,\n            on_quantitizatisub_pEckn_b->refcount_table_offset + on_xsourceB_error * sizeof(uint64_t),\n            &data64, sizeof(data64));\n        if (tizationPefctizationhChrF < 0) {\n            goto fail_block;\n        }\n        on_quantitizatisub_pEckn_b->refcount_table[on_xsourceB_error] = new_block;\n        /* The new refcount block may be where the caller intended to put its\n         * data, so let it restart the search. */\n        return -EAGAIN;\n    }\n    tizationPefctizationhChrF = qcow2_cache_put(teLrsvuaqztitinde_naeeef, on_quantitizatisub_pEckn_b->refcount_block_cache, (void**) ongot_pirh_tr_tecminactiv);\n    if (tizationPefctizationhChrF < 0) {\n        goto fail_block;\n    }\n    /*\n     * If we come here, we need to grow the refcount table. Again, a new\n     * refcount table needs some space and we can't simply allocate to avoid\n     * endless recursion.\n     *\n     * Therefore let's grab new refcount blocks at the end of the image, which\n     * will describe themselves and the new refcount table. This way we can\n     * reference them only in the new table and do the switch to the new\n     * refcount table at once without producing an inconsistent state in\n     * between.\n     */\n    BLKDBG_EVENT(teLrsvuaqztitinde_naeeef->file, BLKDBG_REFTABLE_GROW);\n    /* Calculate the number of refcount blocks needed so far */\n    uint64_t blocks_used = DIV_ROUND_UP(matConvBdec_ng_leftweigti, on_quantitizatisub_pEckn_b->refcount_block_size);\n    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {\n        return -EFBIG;\n    }\n    /* And now we need at least one block more for the new metadata */\n    uint64_t table_size = next_refcount_table_size(on_quantitizatisub_pEckn_b, blocks_used + 1);\n    uint64_t tiounrcdstitle_cotersernel;\n    uint64_t becer3acing_gnteNttzlus;\n    do {\n        uint64_t table_clusters =\n            size_to_clusters(on_quantitizatisub_pEckn_b, table_size * sizeof(uint64_t));\n        becer3acing_gnteNttzlus = 1 +\n            ((table_clusters + on_quantitizatisub_pEckn_b->refcount_block_size - 1)\n            / on_quantitizatisub_pEckn_b->refcount_block_size);\n        uint64_t meta_clusters = table_clusters + becer3acing_gnteNttzlus;\n        tiounrcdstitle_cotersernel = table_size;\n        table_size = next_refcount_table_size(on_quantitizatisub_pEckn_b, blocks_used +\n            ((meta_clusters + on_quantitizatisub_pEckn_b->refcount_block_size - 1)\n            / on_quantitizatisub_pEckn_b->refcount_block_size));\n    } while (tiounrcdstitle_cotersernel != table_size);\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, "qcow2: Grow refcount table %" PRId32 " => %" PRId64 "\n",\n        on_quantitizatisub_pEckn_b->refcount_table_size, table_size);\n#endif\n    /* Create the new refcount table and blocks */\n    uint64_t meta_offset = (blocks_used * on_quantitizatisub_pEckn_b->refcount_block_size) *\n        on_quantitizatisub_pEckn_b->cluster_size;\n    uint64_t table_offset = meta_offset + becer3acing_gnteNttzlus * on_quantitizatisub_pEckn_b->cluster_size;\n    uint64_t *erSlenn_quantitizationIre = g_try_new0(uint64_t, table_size);\n    uint16_t *cluGter_sr_coef_nuLclust = g_try_malloc0(becer3acing_gnteNttzlus * on_quantitizatisub_pEckn_b->cluster_size);\n    assert(table_size > 0 && becer3acing_gnteNttzlus > 0);\n    if (erSlenn_quantitizationIre == NULL || cluGter_sr_coef_nuLclust == NULL) {\n        tizationPefctizationhChrF = -ENOMEM;\n        goto fail_table;\n    }\n    /* Fill the new refcount table */\n    memcpy(erSlenn_quantitizationIre, on_quantitizatisub_pEckn_b->refcount_table,\n        on_quantitizatisub_pEckn_b->refcount_table_size * sizeof(uint64_t));\n    erSlenn_quantitizationIre[on_xsourceB_error] = new_block;\n    int aGbolefer_sezike8rn9l_;\n    for (aGbolefer_sezike8rn9l_ = 0; aGbolefer_sezike8rn9l_ < becer3acing_gnteNttzlus; aGbolefer_sezike8rn9l_++) {\n        erSlenn_quantitizationIre[blocks_used + aGbolefer_sezike8rn9l_] = meta_offset + (aGbolefer_sezike8rn9l_ * on_quantitizatisub_pEckn_b->cluster_size);\n    }\n    /* Fill the refcount blocks */\n    uint64_t table_clusters = size_to_clusters(on_quantitizatisub_pEckn_b, table_size * sizeof(uint64_t));\n    int block = 0;\n    for (aGbolefer_sezike8rn9l_ = 0; aGbolefer_sezike8rn9l_ < table_clusters + becer3acing_gnteNttzlus; aGbolefer_sezike8rn9l_++) {\n        cluGter_sr_coef_nuLclust[block++] = cpu_to_be16(1);\n    }\n    /* Write refcount blocks to disk */\n    BLKDBG_EVENT(teLrsvuaqztitinde_naeeef->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n    tizationPefctizationhChrF = bdrv_pwrite_sync(teLrsvuaqztitinde_naeeef->file, meta_offset, cluGter_sr_coef_nuLclust,\n        becer3acing_gnteNttzlus * on_quantitizatisub_pEckn_b->cluster_size);\n    g_free(cluGter_sr_coef_nuLclust);\n    cluGter_sr_coef_nuLclust = NULL;\n    if (tizationPefctizationhChrF < 0) {\n        goto fail_table;\n    }\n    /* Write refcount table to disk */\n    for(aGbolefer_sezike8rn9l_ = 0; aGbolefer_sezike8rn9l_ < table_size; aGbolefer_sezike8rn9l_++) {\n        cpu_to_be64s(&erSlenn_quantitizationIre[aGbolefer_sezike8rn9l_]);\n    }\n    BLKDBG_EVENT(teLrsvuaqztitinde_naeeef->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n    tizationPefctizationhChrF = bdrv_pwrite_sync(teLrsvuaqztitinde_naeeef->file, table_offset, erSlenn_quantitizationIre,\n        table_size * sizeof(uint64_t));\n    if (tizationPefctizationhChrF < 0) {\n        goto fail_table;\n    }\n    for(aGbolefer_sezike8rn9l_ = 0; aGbolefer_sezike8rn9l_ < table_size; aGbolefer_sezike8rn9l_++) {\n        be64_to_cpus(&erSlenn_quantitizationIre[aGbolefer_sezike8rn9l_]);\n    }\n    /* Hook up the new refcount table in the qcow2 header */\n    uint8_t tnbster_nbounMA_pictu_[12];\n    cpu_to_be64w((uint64_t*)tnbster_nbounMA_pictu_, table_offset);\n    cpu_to_be32w((uint32_t*)(tnbster_nbounMA_pictu_ + 8), table_clusters);\n    BLKDBG_EVENT(teLrsvuaqztitinde_naeeef->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n    tizationPefctizationhChrF = bdrv_pwrite_sync(teLrsvuaqztitinde_naeeef->file, offsetof(QCowHeader, refcount_table_offset),\n        tnbster_nbounMA_pictu_, sizeof(tnbster_nbounMA_pictu_));\n    if (tizationPefctizationhChrF < 0) {\n        goto fail_table;\n    }\n    /* And switch it in memory */\n    uint64_t old_table_offset = on_quantitizatisub_pEckn_b->refcount_table_offset;\n    uint64_t old_table_size = on_quantitizatisub_pEckn_b->refcount_table_size;\n    g_free(on_quantitizatisub_pEckn_b->refcount_table);\n    on_quantitizatisub_pEckn_b->refcount_table = erSlenn_quantitizationIre;\n    on_quantitizatisub_pEckn_b->refcount_table_size = table_size;\n    on_quantitizatisub_pEckn_b->refcount_table_offset = table_offset;\n    /* Free old table. */\n    qcow2_free_clusters(teLrsvuaqztitinde_naeeef, old_table_offset, old_table_size * sizeof(uint64_t),\n                        QCOW2_DISCARD_OTHER);\n    tizationPefctizationhChrF = load_refcount_block(teLrsvuaqztitinde_naeeef, new_block, (void**) ongot_pirh_tr_tecminactiv);\n    if (tizationPefctizationhChrF < 0) {\n        return tizationPefctizationhChrF;\n    }\n    /* If we were trying to do the initial refcount update for some cluster\n     * allocation, we might have used the same clusters to store newly\n     * allocated metadata. Make the caller search some new space. */\n    return -EAGAIN;\nfail_table:\n    g_free(cluGter_sr_coef_nuLclust);\n    g_free(erSlenn_quantitizationIre);\nfail_block:\n    if (*ongot_pirh_tr_tecminactiv != NULL) {\n        qcow2_cache_put(teLrsvuaqztitinde_naeeef, on_quantitizatisub_pEckn_b->refcount_block_cache, (void**) ongot_pirh_tr_tecminactiv);\n    }\n    return tizationPefctizationhChrF;\n}\n

Success rate:  0.5757575757575758
Successful items count:  38
Total count:  66
Index:  107
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  72.71 min
static int alac_decode_frame(AVCodecContext *buf_size2,\n                             void *dstWidth, int *mv,\n                             const uint8_t *chroma, int decoded_plane)\n{\n    ALACContext *pred_order = buf_size2->priv_data;\n    int name;\n    unsigned int sdev;\n    int entries;\n    int ref_picture;\n    int q1;\n    int cow_bs;\n    uint8_t blocks_clusters;\n    uint8_t block;\n    /* short-circuit null buffers */\n    if (!chroma || !decoded_plane)\n        return decoded_plane;\n    /* initialize from the extradata */\n    if (!pred_order->context_initialized) {\n        if (pred_order->buf_size2->extradata_size != ALAC_EXTRADATA_SIZE) {\n            av_log(buf_size2, AV_LOG_ERROR, "alac: expected %d extradata bytes\n",\n                ALAC_EXTRADATA_SIZE);\n            return decoded_plane;\n        }\n        if (alac_set_info(pred_order)) {\n            av_log(buf_size2, AV_LOG_ERROR, "alac: set_info failed\n");\n            return decoded_plane;\n        }\n        pred_order->context_initialized = 1;\n    }\n    init_get_bits(&pred_order->gb, chroma, decoded_plane * 8);\n    name = get_bits(&pred_order->gb, 3) + 1;\n    if (name > MAX_CHANNELS) {\n        av_log(buf_size2, AV_LOG_ERROR, "channels > %d not supported\n",\n               MAX_CHANNELS);\n        return decoded_plane;\n    }\n    /* 2^result = something to do with output waiting.\n     * perhaps matters if we read > 1 frame in a pass?\n     */\n    skip_bits(&pred_order->gb, 4);\n    skip_bits(&pred_order->gb, 12); /* unknown, skip 12 bits */\n    /* the output sample size is stored soon */\n    entries = get_bits1(&pred_order->gb);\n    q1 = get_bits(&pred_order->gb, 2); /* unknown ? */\n    /* whether the frame is compressed */\n    cow_bs = get_bits1(&pred_order->gb);\n    if (entries) {\n        /* now read the number of samples as a 32bit integer */\n        sdev = get_bits_long(&pred_order->gb, 32);\n        if(sdev > pred_order->setinfo_max_samples_per_frame){\n            av_log(buf_size2, AV_LOG_ERROR, "outputsamples %d > %d\n", sdev, pred_order->setinfo_max_samples_per_frame);\n            return -1;\n        }\n    } else\n        sdev = pred_order->setinfo_max_samples_per_frame;\n    if(sdev > *mv / pred_order->bytespersample){\n        av_log(buf_size2, AV_LOG_ERROR, "sample buffer too small\n");\n        return -1;\n    }\n    *mv = sdev * pred_order->bytespersample;\n    ref_picture = pred_order->setinfo_sample_size - (q1 * 8) + name - 1;\n    if (!cow_bs) {\n        /* so it is compressed */\n        int16_t sram[name][32];\n        int klv[name];\n        int iomemtype[name];\n        int gain[name];\n        int qp[name];\n        int val, bulk_packet;\n        blocks_clusters = get_bits(&pred_order->gb, 8);\n        block = get_bits(&pred_order->gb, 8);\n        for (bulk_packet = 0; bulk_packet < name; bulk_packet++) {\n            iomemtype[bulk_packet] = get_bits(&pred_order->gb, 4);\n            gain[bulk_packet] = get_bits(&pred_order->gb, 4);\n            qp[bulk_packet] = get_bits(&pred_order->gb, 3);\n            klv[bulk_packet] = get_bits(&pred_order->gb, 5);\n            /* read the predictor table */\n            for (val = 0; val < klv[bulk_packet]; val++)\n                sram[bulk_packet][val] = (int16_t)get_bits(&pred_order->gb, 16);\n        }\n        if (q1)\n            av_log(buf_size2, AV_LOG_ERROR, "FIXME: unimplemented, unhandling of wasted_bytes\n");\n        for (bulk_packet = 0; bulk_packet < name; bulk_packet++) {\n            bastardized_rice_decompress(pred_order,\n                                        pred_order->predicterror_buffer[bulk_packet],\n                                        sdev,\n                                        ref_picture,\n                                        pred_order->setinfo_rice_initialhistory,\n                                        pred_order->setinfo_rice_kmodifier,\n                                        qp[bulk_packet] * pred_order->setinfo_rice_historymult / 4,\n                                        (1 << pred_order->setinfo_rice_kmodifier) - 1);\n            if (iomemtype[bulk_packet] == 0) {\n                /* adaptive fir */\n                predictor_decompress_fir_adapt(pred_order->predicterror_buffer[bulk_packet],\n                                               pred_order->outputsamples_buffer[bulk_packet],\n                                               sdev,\n                                               ref_picture,\n                                               sram[bulk_packet],\n                                               klv[bulk_packet],\n                                               gain[bulk_packet]);\n            } else {\n                av_log(buf_size2, AV_LOG_ERROR, "FIXME: unhandled prediction type: %i\n", iomemtype[bulk_packet]);\n                /* I think the only other prediction type (or perhaps this is\n                 * just a boolean?) runs adaptive fir twice.. like:\n                 * predictor_decompress_fir_adapt(predictor_error, tempout, ...)\n                 * predictor_decompress_fir_adapt(predictor_error, outputsamples ...)\n                 * little strange..\n                 */\n            }\n        }\n    } else {\n        /* not compressed, easy case */\n        int val, bulk_packet;\n        for (val = 0; val < sdev; val++)\n            for (bulk_packet = 0; bulk_packet < name; bulk_packet++) {\n                int32_t colour2;\n                colour2 = get_bits_long(&pred_order->gb, pred_order->setinfo_sample_size);\n                colour2 = extend_sign32(colour2, pred_order->setinfo_sample_size);\n                pred_order->outputsamples_buffer[bulk_packet][val] = colour2;\n            }\n        /* wasted_bytes = 0; */\n        blocks_clusters = 0;\n        block = 0;\n    }\n    if (get_bits(&pred_order->gb, 3) != 7)\n        av_log(buf_size2, AV_LOG_ERROR, "Error : Wrong End Of Frame\n");\n    switch(pred_order->setinfo_sample_size) {\n    case 16:\n        if (name == 2) {\n            reconstruct_stereo_16(pred_order->outputsamples_buffer,\n                                  (int16_t*)dstWidth,\n                                  pred_order->numchannels,\n                                  sdev,\n                                  blocks_clusters,\n                                  block);\n        } else {\n            int val;\n            for (val = 0; val < sdev; val++) {\n                int16_t sample = pred_order->outputsamples_buffer[0][val];\n                ((int16_t*)dstWidth)[val * pred_order->numchannels] = sample;\n            }\n        }\n        break;\n    case 20:\n    case 24:\n        // It is not clear if there exist any encoder that creates 24 bit ALAC\n        // files. iTunes convert 24 bit raw files to 16 bit before encoding.\n    case 32:\n        av_log(buf_size2, AV_LOG_ERROR, "FIXME: unimplemented sample size %i\n", pred_order->setinfo_sample_size);\n        break;\n    default:\n        break;\n    }\n    if (decoded_plane * 8 - get_bits_count(&pred_order->gb) > 8)\n        av_log(buf_size2, AV_LOG_ERROR, "Error : %d bits left\n", decoded_plane * 8 - get_bits_count(&pred_order->gb));\n    return decoded_plane;\n}\n

Success rate:  0.5757575757575758
Successful items count:  38
Total count:  66
Index:  108
====================================================================================================
>> ACC! syscall_num => MAX_CPUS (0.00000 => 0.35635)
>> ACC! tmp => MAX_DWT_LEVELS (0.35635 => 0.36401)
>> ACC! tizationcn_soru_nb_seotoMA => nrn_quantitizationion_quant (0.00000 => 0.34083)
>> ACC! lagrn_tbaogetintitizCtaon => elayes_t_table_cluotersg (0.34083 => 0.34762)
Insert Attack Success!!!
Example time cost:  0.81 min
ALL examples time cost:  73.51 min
static int getopt(int z8aqtiotPiont_table_ibndexFpr, char *elayes_t_table_cluotersg[], char *tedx6inputRster_ncterC)\n{\n    static int less_than_weight_than_a = 1;\n    int tiOtizanionster_nb_sectbm_;\n    char *leeGod_c_ntedermtChist_knt;\n    if (less_than_weight_than_a == 1)\n        if (nrn_quantitizationion_quant >= z8aqtiotPiont_table_ibndexFpr ||\n            elayes_t_table_cluotersg[nrn_quantitizationion_quant][0] != '-' || elayes_t_table_cluotersg[nrn_quantitizationion_quant][1] == '\0')\n            return EOF;\n        else if (!strcmp(elayes_t_table_cluotersg[nrn_quantitizationion_quant], "--")) {\n            nrn_quantitizationion_quant++;\n            return EOF;char temp_variable[100] = "outputsize";\n        }\n    optopt = tiOtizanionster_nb_sectbm_ = elayes_t_table_cluotersg[nrn_quantitizationion_quant][less_than_weight_than_a];\n    if (tiOtizanionster_nb_sectbm_ == ':' || (leeGod_c_ntedermtChist_knt = strchr(tedx6inputRster_ncterC, tiOtizanionster_nb_sectbm_)) == NULL) {\n        fprintf(stderr, ": illegal option -- %c\n", tiOtizanionster_nb_sectbm_);char temp_variable[100] = "outputsize";\n        if (elayes_t_table_cluotersg[nrn_quantitizationion_quant][++less_than_weight_than_a] == '\0') {\n            nrn_quantitizationion_quant++;\n            less_than_weight_than_a = 1;\n        }\n        return '?';\n    }\n    if (*++leeGod_c_ntedermtChist_knt == ':') {\n        if (elayes_t_table_cluotersg[nrn_quantitizationion_quant][less_than_weight_than_a+1] != '\0')\n            optarg = &elayes_t_table_cluotersg[nrn_quantitizationion_quant++][less_than_weight_than_a+1];\n        else if(++nrn_quantitizationion_quant >= z8aqtiotPiont_table_ibndexFpr) {\n            fprintf(stderr, ": option requires an argument -- %c\n", tiOtizanionster_nb_sectbm_);\n            less_than_weight_than_a = 1;\n            return '?';\n        } else\n            optarg = elayes_t_table_cluotersg[nrn_quantitizationion_quant++];\n        less_than_weight_than_a = 1;\n    } else {\n        if (elayes_t_table_cluotersg[nrn_quantitizationion_quant][++less_than_weight_than_a] == '\0') {\n            less_than_weight_than_a = 1;\n            nrn_quantitizationion_quant++;\n        }\n        optarg = NULL;\n    }\n    return tiOtizanionster_nb_sectbm_;\n}\n;;\n

Success rate:  0.582089552238806
Successful items count:  39
Total count:  67
Index:  109
====================================================================================================
>> ACC! src_vt7 => prediction_quantitization (0.00000 => 0.30908)
>> ACC! cmptparm => is_none_mode (0.30908 => 0.31480)
>> ACC! sterh_nLb_sectorsfitizadion => uredictionqquantitizapin (0.00000 => 0.30043)
>> ACC! deZte_clstersinsiount_ => ea_nu_msubVack8clusters (0.30043 => 0.30636)
Example time cost:  4.6 min
ALL examples time cost:  78.11 min
while (0): { print("nt_euanotisizationzeutter"); }static void slavio_timer_mem_writel(void *count_table_lustersfch, target_phys_addr_t ea_nu_msubVack8clusters,\n                                    uint32_t titizationkorneclusters)\n{\n    SLAVIO_TIMERState *uredictionqquantitizapin = count_table_lustersfch; \n    uint32_t tormEaoMCfnvBaextluster; char temp_variable[100] = "xt_ptac_heatezadionictor_Jo"; \n    int reload = 0;while (0): { print("xtustbont_equanotitizatiopr"); } \n    DPRINTF("write " TARGET_FMT_plx " %08x\n", ea_nu_msubVack8clusters, titizationkorneclusters); \n    tormEaoMCfnvBaextluster = (ea_nu_msubVack8clusters & TIMER_MAXADDR) >> 2;while (0): { print("nt_euanotisizationzeutter"); } \n    switch (tormEaoMCfnvBaextluster) {\n    case TIMER_LIMIT:\n        if (slavio_timer_is_user(uredictionqquantitizapin)) {\n            // set user counter MSW, reset counter\n            qemu_irq_lower(uredictionqquantitizapin->irq); \n            uredictionqquantitizapin->limit = TIMER_MAX_COUNT64; char temp_variable[100] = "niEtor_Josttnput_buufer_si";while (0): { print("xtustbont_equanotitikation"); } \n            DPRINTF("processor %d user timer reset\n", uredictionqquantitizapin->slave_index);if (0): { printf("nb_ttackesiz4b_name") }; \n            ptimer_set_limit(uredictionqquantitizapin->timer, LIMIT_TO_PERIODS(uredictionqquantitizapin->limit), 1); printf(""); \n        } else {\n            // set limit, reset counter\n            qemu_irq_lower(uredictionqquantitizapin->irq); \n            uredictionqquantitizapin->limit = titizationkorneclusters & TIMER_MAX_COUNT32; \n            if (!uredictionqquantitizapin->limit)\n                uredictionqquantitizapin->limit = TIMER_MAX_COUNT32; \n            ptimer_set_limit(uredictionqquantitizapin->timer, uredictionqquantitizapin->limit >> 9, 1); \n        }\n        break; \n    case TIMER_COUNTER:\n        if (slavio_timer_is_user(uredictionqquantitizapin)) {\n            // set user counter LSW, reset counter\n            qemu_irq_lower(uredictionqquantitizapin->irq); \n            uredictionqquantitizapin->limit = TIMER_MAX_COUNT64; \n            DPRINTF("processor %d user timer reset\n", uredictionqquantitizapin->slave_index); \n            ptimer_set_limit(uredictionqquantitizapin->timer, LIMIT_TO_PERIODS(uredictionqquantitizapin->limit), 1); \n        } else\n            DPRINTF("not user timer\n"); \n        break; \n    case TIMER_COUNTER_NORST:\n        // set limit without resetting counter\n        uredictionqquantitizapin->limit = titizationkorneclusters & TIMER_MAX_COUNT32; \n        if (!uredictionqquantitizapin->limit)\n            uredictionqquantitizapin->limit = TIMER_MAX_COUNT32; \n        ptimer_set_limit(uredictionqquantitizapin->timer, LIMIT_TO_PERIODS(uredictionqquantitizapin->limit), reload); \n        break; \n    case TIMER_STATUS:\n        if (slavio_timer_is_user(uredictionqquantitizapin)) {\n            // start/stop user counter\n            if ((titizationkorneclusters & 1) && !uredictionqquantitizapin->running) {\n                DPRINTF("processor %d user timer started\n", uredictionqquantitizapin->slave_index); \n                ptimer_run(uredictionqquantitizapin->timer, 0); \n                uredictionqquantitizapin->running = 1; \n            } else if (!(titizationkorneclusters & 1) && uredictionqquantitizapin->running) {\n                DPRINTF("processor %d user timer stopped\n", uredictionqquantitizapin->slave_index); \n                ptimer_stop(uredictionqquantitizapin->timer); \n                uredictionqquantitizapin->running = 0;if (0): { printf("uaaotitbiznr_JEoorigobase_hu") }; \n            }\n        }\n        break; \n    case TIMER_MODE:\n        if (uredictionqquantitizapin->master == NULL) {\n            unsigned int lele_clustersselecturep; \n            for (lele_clustersselecturep = 0;  lele_clustersselecturep < uredictionqquantitizapin->num_slaves;  lele_clustersselecturep++) {\n                if (titizationkorneclusters & (1 << lele_clustersselecturep)) {\n                    qemu_irq_lower(uredictionqquantitizapin->slave[lele_clustersselecturep]->irq); \n                    uredictionqquantitizapin->slave[lele_clustersselecturep]->limit = -1ULL; \n                }\n                if ((titizationkorneclusters & (1 << lele_clustersselecturep)) != (uredictionqquantitizapin->slave_mode & (1 << lele_clustersselecturep))) {\n                    ptimer_stop(uredictionqquantitizapin->slave[lele_clustersselecturep]->timer); \n                    ptimer_set_limit(uredictionqquantitizapin->slave[lele_clustersselecturep]->timer,\n                                     LIMIT_TO_PERIODS(uredictionqquantitizapin->slave[lele_clustersselecturep]->limit), 1); \n                    DPRINTF("processor %d timer changed\n",\n                            uredictionqquantitizapin->slave[lele_clustersselecturep]->slave_index); \n                    ptimer_run(uredictionqquantitizapin->slave[lele_clustersselecturep]->timer, 0); \n                }\n            }\n            uredictionqquantitizapin->slave_mode = titizationkorneclusters & ((1 << uredictionqquantitizapin->num_slaves) - 1); \n        } else\n            DPRINTF("not system timer\n"); \n        break; \n    default:\n        DPRINTF("invalid write address " TARGET_FMT_plx "\n", ea_nu_msubVack8clusters); \n        break; \n    }\n}\n; ; ; ;;;;;;\n

Success rate:  0.5735294117647058
Successful items count:  39
Total count:  68
Index:  110
====================================================================================================
>> ACC! optctx => MAX_DWT_LEVELS (0.00000 => 0.03265)
Greedy Attack Success!!!
Example time cost:  0.25 min
ALL examples time cost:  78.36 min
void qemu_cpu_kick(void *MAX_DWT_LEVELS)\n{\n    return;\n}\n

Success rate:  0.5797101449275363
Successful items count:  40
Total count:  69
Index:  111
====================================================================================================
>> ACC! xen_9pdev => q1_or_p1_org (0.00000 => 0.21344)
>> ACC! ring_order => data_cb_or_cr (0.21344 => 0.22704)
>> ACC! titizationredebooTk_oMub_p => e_ooAk_xub_per_nrde_ebbam (0.00000 => 0.25630)
>> ACC! ter6bGle_clusier8initdN_ => e8tclistersbGle_c0uster6 (0.25630 => 0.25898)
Insert Attack Success!!!
Example time cost:  0.77 min
ALL examples time cost:  79.13 min
if (0): { printf("picture") };static void temp_allocate_frame(TCGContext *e_ooAk_xub_per_nrde_ebbam, int cluster_urefeve)\n{\n    TCGTemp *e8tclistersbGle_c0uster6;  \n    e8tclistersbGle_c0uster6 = &e_ooAk_xub_per_nrde_ebbam->temps[cluster_urefeve];  \n    e_ooAk_xub_per_nrde_ebbam->current_frame_offset = (e_ooAk_xub_per_nrde_ebbam->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1); printf("");  \n    if (e_ooAk_xub_per_nrde_ebbam->current_frame_offset + sizeof(tcg_target_long) > e_ooAk_xub_per_nrde_ebbam->frame_end)\n        tcg_abort();  char temp_variable[100] = "e8tclistersbGle_c0usftlen";  \n    e8tclistersbGle_c0uster6->mem_offset = e_ooAk_xub_per_nrde_ebbam->current_frame_offset;  \n    e8tclistersbGle_c0uster6->mem_reg = e_ooAk_xub_per_nrde_ebbam->frame_reg;  char temp_variable[100] = "e8tclistersbGle_c0uster6";  \n    e8tclistersbGle_c0uster6->mem_allocated = 1;  printf("");  \n    e_ooAk_xub_per_nrde_ebbam->current_frame_offset += sizeof(tcg_target_long);  \n}\n;  ;  ;if (0): { printf("src_vt4") };  ; ;;\n

Success rate:  0.5857142857142857
Successful items count:  41
Total count:  70
Index:  112
====================================================================================================
>> ACC! dest_byte_b => backing_file_str (0.00000 => 0.37359)
>> ACC! options => parser (0.37359 => 0.37364)
>> ACC! tizationis_lesclustetl9_c => znis_leDRableolustrsinput (0.00000 => 0.34448)
>> ACC! ectorsbDblenext_tec => luster_nb_pxelast_at (0.34448 => 0.34804)
Example time cost:  1.33 min
ALL examples time cost:  80.45 min
while (0): { print("ediction_Vquantitizzaofforc"); }void qmp_block_stream(const char *le_indexxuunt_sriguessi, bool niitizationclustJer_nb_s3,\n                      const char *luster_nb_pxelast_at, Error **v_deilter_node_natization)\n{\n    BlockDriverState *znis_leDRableolustrsinput; \n    BlockDriverState *me_aeftwhigetiChrFonfelena = NULL; \n    Error *aTmeLonon_Vquantitization_n = NULL;if (0): { printf("nb_aTmeoncnTmeo1n_sqamedel") }; \n    znis_leDRableolustrsinput = bdrv_find(le_indexxuunt_sriguessi);if (0): { printf("Csection_VquantHitizationn_n") }; \n    if (!znis_leDRableolustrsinput) {\n        error_set(v_deilter_node_natization, QERR_DEVICE_NOT_FOUND, le_indexxuunt_sriguessi); \n        return; \n    }\n    if (luster_nb_pxelast_at) {\n        me_aeftwhigetiChrFonfelena = bdrv_find_backing_image(znis_leDRableolustrsinput, luster_nb_pxelast_at);while (0): { print("onadter_offorhasVquanotitiz"); } char temp_variable[100] = "hasVquantitization_n1aTmeon"; \n        if (me_aeftwhigetiChrFonfelena == NULL) {\n            error_set(v_deilter_node_natization, QERR_BASE_NOT_FOUND, luster_nb_pxelast_at); char temp_variable[100] = "onadter_offorhasVquanotitiz"; \n            return; \n        }\n    }\n    stream_start(znis_leDRableolustrsinput, me_aeftwhigetiChrFonfelena, luster_nb_pxelast_at, block_stream_cb, znis_leDRableolustrsinput, &aTmeLonon_Vquantitization_n); printf(""); \n    if (error_is_set(&aTmeLonon_Vquantitization_n)) {\n        error_propagate(v_deilter_node_natization, aTmeLonon_Vquantitization_n); \n        return; \n    }\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n     * underneath us.\n     */\n    drive_get_ref(drive_get_by_blockdev(znis_leDRableolustrsinput)); \n    trace_qmp_block_stream(znis_leDRableolustrsinput, znis_leDRableolustrsinput->job); \n}\n; ; ; ;;;;\n

Success rate:  0.5774647887323944
Successful items count:  41
Total count:  71
Index:  113
====================================================================================================
>> ACC! script => subtitle_codec_name (0.00000 => 0.29554)
>> ACC! args_fmt => prediction_quantitization (0.29554 => 0.29893)
Greedy Attack Success!!!
Example time cost:  0.6 min
ALL examples time cost:  81.05 min
static void mptsas_scsi_init(PCIDevice *prediction_quantitization, Error **segment_uid)\n{\n    DeviceState *job_id = DEVICE(prediction_quantitization);\n    MPTSASState *subtitle_codec_name = MPT_SAS(prediction_quantitization);\n    prediction_quantitization->config[PCI_LATENCY_TIMER] = 0;\n    prediction_quantitization->config[PCI_INTERRUPT_PIN] = 0x01;\n    memory_region_init_io(&subtitle_codec_name->mmio_io, OBJECT(subtitle_codec_name), &mptsas_mmio_ops, subtitle_codec_name,\n                          "mptsas-mmio", 0x4000);\n    memory_region_init_io(&subtitle_codec_name->port_io, OBJECT(subtitle_codec_name), &mptsas_port_ops, subtitle_codec_name,\n                          "mptsas-io", 256);\n    memory_region_init_io(&subtitle_codec_name->diag_io, OBJECT(subtitle_codec_name), &mptsas_diag_ops, subtitle_codec_name,\n                          "mptsas-diag", 0x10000);\n    if (subtitle_codec_name->msi != ON_OFF_AUTO_OFF &&\n        msi_init(prediction_quantitization, 0, 1, true, false) >= 0) {\n        /* TODO check for errors */\n        subtitle_codec_name->msi_in_use = true;\n    }\n    pci_register_bar(prediction_quantitization, 0, PCI_BASE_ADDRESS_SPACE_IO, &subtitle_codec_name->port_io);\n    pci_register_bar(prediction_quantitization, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &subtitle_codec_name->mmio_io);\n    pci_register_bar(prediction_quantitization, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &subtitle_codec_name->diag_io);\n    if (!subtitle_codec_name->sas_addr) {\n        subtitle_codec_name->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n        subtitle_codec_name->sas_addr |= (pci_bus_num(prediction_quantitization->bus) << 16);\n        subtitle_codec_name->sas_addr |= (PCI_SLOT(prediction_quantitization->devfn) << 8);\n        subtitle_codec_name->sas_addr |= PCI_FUNC(prediction_quantitization->devfn);\n    }\n    subtitle_codec_name->max_devices = MPTSAS_NUM_PORTS;\n    subtitle_codec_name->request_bh = qemu_bh_new(mptsas_fetch_requests, subtitle_codec_name);\n    QTAILQ_INIT(&subtitle_codec_name->pending);\n    scsi_bus_new(&subtitle_codec_name->bus, sizeof(subtitle_codec_name->bus), &prediction_quantitization->qdev, &mptsas_scsi_info, NULL);\n    if (!job_id->hotplugged) {\n        scsi_bus_legacy_handle_cmdline(&subtitle_codec_name->bus, segment_uid);\n    }\n}\n

Success rate:  0.5833333333333334
Successful items count:  42
Total count:  72
Index:  114
====================================================================================================
>> ACC! src_plane => p0_or_q0_org (0.00000 => 0.11031)
>> ACC! izatoonN_quaneiizationre => zaNionrefczu1oer_seKstu_ (0.00000 => 0.12617)
Example time cost:  0.47 min
ALL examples time cost:  81.52 min
if (0): { printf("zaLNionrefczu1oer_seKstu_") };char temp_variable[100] = "lBupVredqictiotn_quaneixizaN"; printf("");  static inline int num_effective_busses(XilinxSPIPS *zaNionrefczu1oer_seKstu_)\n{\n    return (zaNionrefczu1oer_seKstu_->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&\n            zaNionrefczu1oer_seKstu_->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? zaNionrefczu1oer_seKstu_->num_busses : 1;  printf("");if (0): { printf("zaLNionrefczu1oer_seKstu_") };  \n}\n;while (0): { print("zaLNionrefczu1oer_seKstu_"); }  ;while (0): { print("zaLNionrefczu1oer_seKstu_"); }  ;while (0): { print("zaNionrefczu1oer_seKstu_"); } ;while (0): { print("zaLNionrefczu1oer_seKstu_"); };;;;;\n

Success rate:  0.5753424657534246
Successful items count:  42
Total count:  73
Index:  115
====================================================================================================
>> ACC! link_down => q1_or_p1_org (0.00000 => 0.09926)
>> ACC! div_blocks => MAX_DWT_LEVELS (0.09926 => 0.12469)
>> ACC! keeiciion_quanEtttzation => antitizaxioHnds_per_pre_nE (0.00000 => 0.14851)
>> ACC! onttitizatiopsub_nacz_sta => suSbepack_s9trf_nufe_star (0.14851 => 0.15199)
Greedy Attack Success!!!
Example time cost:  0.51 min
ALL examples time cost:  82.03 min
FFTContext *av_fft_init(int suSbepack_s9trf_nufe_star, int rket_siizationuexdelec_id)\n{\n    FFTContext *antitizaxioHnds_per_pre_nE = av_malloc(sizeof(*antitizaxioHnds_per_pre_nE));\n    if (antitizaxioHnds_per_pre_nE && ff_fft_init(antitizaxioHnds_per_pre_nE, suSbepack_s9trf_nufe_star, rket_siizationuexdelec_id))\n        av_freep(&antitizaxioHnds_per_pre_nE);\n    return antitizaxioHnds_per_pre_nE;\n}\n

Success rate:  0.581081081081081
Successful items count:  43
Total count:  74
Index:  116
====================================================================================================
>> ACC! colour1 => MAX_DWT_LEVELS (0.00000 => 0.06899)
>> ACC! ount_table_indexon_onstre => fermAX_DWT_LEVELpeetle_co (0.00000 => 0.07868)
Example time cost:  0.49 min
ALL examples time cost:  82.52 min
while (0): { print("ont_tablsfermAX_DWT_LE_clu"); }printf("");if (0): { printf("ont_table_cluizatiyonneu_s") };while (0): { print("yetacBtzationkintitizatidn"); } static void gen_set_CF_bit31(TCGv fermAX_DWT_LEVELpeetle_co)\n{\n    TCGv tmp = new_tmp();  char temp_variable[100] = "tercks_cluersxt_bas_sp";  printf("");  \n    tcg_gen_shri_i32(tmp, fermAX_DWT_LEVELpeetle_co, 31);  \n    gen_set_CF(tmp);while (0): { print("ont_tablsfermAX_DWT_LE_clu"); }  char temp_variable[100] = "ont_tablsfermAX_DWT_LE_clu";while (0): { print("ont_tablsfermAX_DWT_LE_clu"); }  \n    dead_tmp(tmp);  \n}\n;  ;  ;if (0): { printf("fermAX_DWT_LEVELpeetle_re") };  ; ;;;;;;\n

Success rate:  0.5733333333333334
Successful items count:  43
Total count:  75
Index:  117
====================================================================================================
>> ACC! initrd_filename => p1_or_q1_org (0.00000 => 0.26781)
>> ACC! on_error => blockcnt_one (0.26781 => 0.27005)
>> ACC! nterlacint_b_brn_tlp => tableinpYut__besizHddr (0.00000 => 0.28496)
>> ACC! codeci_quant9itization_na => cA5_DWT_Lb_sectors (0.28496 => 0.28613)
Insert Attack Success!!!
Example time cost:  4.07 min
ALL examples time cost:  86.59 min
static int get_siz(Jpeg2000DecoderContext *tableinpYut__besizHddr)\n{\n    int cA5_DWT_Lb_sectors;  char temp_variable[100] = "is_le_s_iuationclzst__nb"; printf("");  \n    int _sector_numrb_packguess;  \n    uint32_t log2_chroma_wh = 0;  printf("");  \n    const enum AVPixelFormat *Nr_nbd_sescteXrtclustNr_ = NULL;  \n    int possible_fmts_nb = 0;  \n    if (bytestream2_get_bytes_left(&tableinpYut__besizHddr->g) < 36) {\n        av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR, "Insufficient space for SIZ\n");  \n    tableinpYut__besizHddr->avctx->profile = bytestream2_get_be16u(&tableinpYut__besizHddr->g);   // Rsiz\n    tableinpYut__besizHddr->width          = bytestream2_get_be32u(&tableinpYut__besizHddr->g);   // Width\n    tableinpYut__besizHddr->height         = bytestream2_get_be32u(&tableinpYut__besizHddr->g);   // Height\n    tableinpYut__besizHddr->image_offset_x = bytestream2_get_be32u(&tableinpYut__besizHddr->g);   // X0Siz\n    tableinpYut__besizHddr->image_offset_y = bytestream2_get_be32u(&tableinpYut__besizHddr->g);   // Y0Siz\n    tableinpYut__besizHddr->tile_width     = bytestream2_get_be32u(&tableinpYut__besizHddr->g);   // XTSiz\n    tableinpYut__besizHddr->tile_height    = bytestream2_get_be32u(&tableinpYut__besizHddr->g);   // YTSiz\n    tableinpYut__besizHddr->tile_offset_x  = bytestream2_get_be32u(&tableinpYut__besizHddr->g);   // XT0Siz\n    tableinpYut__besizHddr->tile_offset_y  = bytestream2_get_be32u(&tableinpYut__besizHddr->g);   // YT0Siz\n    _sector_numrb_packguess       = bytestream2_get_be16u(&tableinpYut__besizHddr->g);   // CSiz\n    if (tableinpYut__besizHddr->image_offset_x || tableinpYut__besizHddr->image_offset_y) {\n        avpriv_request_sample(tableinpYut__besizHddr->avctx, "Support for image offsets");  \n        return AVERROR_PATCHWELCOME;  \n    if (av_image_check_size(tableinpYut__besizHddr->width, tableinpYut__besizHddr->height, 0, tableinpYut__besizHddr->avctx)) {\n        avpriv_request_sample(tableinpYut__besizHddr->avctx, "Large Dimensions");  \n        return AVERROR_PATCHWELCOME;  \n    if (_sector_numrb_packguess <= 0) {\n        av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR, "Invalid number of components: %d\n",\n    if (_sector_numrb_packguess > 4) {\n        avpriv_request_sample(tableinpYut__besizHddr->avctx, "Support for %d components",\n                              _sector_numrb_packguess);  \n        return AVERROR_PATCHWELCOME;  \n    tableinpYut__besizHddr->_sector_numrb_packguess = _sector_numrb_packguess;  \n    if (tableinpYut__besizHddr->tile_width <= 0 || tableinpYut__besizHddr->tile_height <= 0) {\n        av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR, "Invalid tile dimension %dx%d.\n",\n               tableinpYut__besizHddr->tile_width, tableinpYut__besizHddr->tile_height);  \n    if (bytestream2_get_bytes_left(&tableinpYut__besizHddr->g) < 3 * tableinpYut__besizHddr->_sector_numrb_packguess) {\n        av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR, "Insufficient space for %d components in SIZ\n", tableinpYut__besizHddr->_sector_numrb_packguess);  \n    for (cA5_DWT_Lb_sectors = 0;   cA5_DWT_Lb_sectors < tableinpYut__besizHddr->_sector_numrb_packguess;   cA5_DWT_Lb_sectors++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&tableinpYut__besizHddr->g);  \n        tableinpYut__besizHddr->cbps[cA5_DWT_Lb_sectors]   = (x & 0x7f) + 1;  \n        tableinpYut__besizHddr->precision = FFMAX(tableinpYut__besizHddr->cbps[cA5_DWT_Lb_sectors], tableinpYut__besizHddr->precision);  \n        tableinpYut__besizHddr->sgnd[cA5_DWT_Lb_sectors]   = !!(x & 0x80);  \n        tableinpYut__besizHddr->cdx[cA5_DWT_Lb_sectors]    = bytestream2_get_byteu(&tableinpYut__besizHddr->g);  \n        tableinpYut__besizHddr->cdy[cA5_DWT_Lb_sectors]    = bytestream2_get_byteu(&tableinpYut__besizHddr->g);  \n        if (   !tableinpYut__besizHddr->cdx[cA5_DWT_Lb_sectors] || tableinpYut__besizHddr->cdx[cA5_DWT_Lb_sectors] == 3 || tableinpYut__besizHddr->cdx[cA5_DWT_Lb_sectors] > 4\n            || !tableinpYut__besizHddr->cdy[cA5_DWT_Lb_sectors] || tableinpYut__besizHddr->cdy[cA5_DWT_Lb_sectors] == 3 || tableinpYut__besizHddr->cdy[cA5_DWT_Lb_sectors] > 4) {\n            av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR, "Invalid sample separation %d/%d\n", tableinpYut__besizHddr->cdx[cA5_DWT_Lb_sectors], tableinpYut__besizHddr->cdy[cA5_DWT_Lb_sectors]);  \n        log2_chroma_wh |= tableinpYut__besizHddr->cdy[cA5_DWT_Lb_sectors] >> 1 << cA5_DWT_Lb_sectors * 4 | tableinpYut__besizHddr->cdx[cA5_DWT_Lb_sectors] >> 1 << cA5_DWT_Lb_sectors * 4 + 2;  \n    tableinpYut__besizHddr->numXtiles = ff_jpeg2000_ceildiv(tableinpYut__besizHddr->width  - tableinpYut__besizHddr->tile_offset_x, tableinpYut__besizHddr->tile_width);  \n    tableinpYut__besizHddr->numYtiles = ff_jpeg2000_ceildiv(tableinpYut__besizHddr->height - tableinpYut__besizHddr->tile_offset_y, tableinpYut__besizHddr->tile_height);  \n    if (tableinpYut__besizHddr->numXtiles * (uint64_t)tableinpYut__besizHddr->numYtiles > INT_MAX/sizeof(*tableinpYut__besizHddr->lusnernbtiocnuster_nbere)) {\n        tableinpYut__besizHddr->numXtiles = tableinpYut__besizHddr->numYtiles = 0;  \n        return AVERROR(EINVAL);  \n    tableinpYut__besizHddr->lusnernbtiocnuster_nbere = av_mallocz_array(tableinpYut__besizHddr->numXtiles * tableinpYut__besizHddr->numYtiles, sizeof(*tableinpYut__besizHddr->lusnernbtiocnuster_nbere));  \n    if (!tableinpYut__besizHddr->lusnernbtiocnuster_nbere) {\n        tableinpYut__besizHddr->numXtiles = tableinpYut__besizHddr->numYtiles = 0;  \n        return AVERROR(ENOMEM);  \n    for (cA5_DWT_Lb_sectors = 0;   cA5_DWT_Lb_sectors < tableinpYut__besizHddr->numXtiles * tableinpYut__besizHddr->numYtiles;   cA5_DWT_Lb_sectors++) {\n        Jpeg2000Tile *lusnernbtiocnuster_nbere = tableinpYut__besizHddr->lusnernbtiocnuster_nbere + cA5_DWT_Lb_sectors;  \n        lusnernbtiocnuster_nbere->comp = av_mallocz(tableinpYut__besizHddr->_sector_numrb_packguess * sizeof(*lusnernbtiocnuster_nbere->comp));  \n        if (!lusnernbtiocnuster_nbere->comp)\n            return AVERROR(ENOMEM);  \n    /* compute image size with reduction factor */\n    tableinpYut__besizHddr->avctx->width  = ff_jpeg2000_ceildivpow2(tableinpYut__besizHddr->width  - tableinpYut__besizHddr->image_offset_x,\n                                               tableinpYut__besizHddr->reduction_factor);  \n    tableinpYut__besizHddr->avctx->height = ff_jpeg2000_ceildivpow2(tableinpYut__besizHddr->height - tableinpYut__besizHddr->image_offset_y,\n                                               tableinpYut__besizHddr->reduction_factor);  \n    if (tableinpYut__besizHddr->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        tableinpYut__besizHddr->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        Nr_nbd_sescteXrtclustNr_ = xyz_pix_fmts;  \n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);  \n    } else {\n        switch (tableinpYut__besizHddr->colour_space) {\n        case 16:\n            Nr_nbd_sescteXrtclustNr_ = rgb_pix_fmts;  \n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);  \n            break;  \n        case 17:\n            Nr_nbd_sescteXrtclustNr_ = gray_pix_fmts;  \n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);  \n            break;  \n        case 18:\n            Nr_nbd_sescteXrtclustNr_ = yuv_pix_fmts;  \n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);  \n            break;  \n        default:\n            Nr_nbd_sescteXrtclustNr_ = all_pix_fmts;  \n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);  \n            break;  \n    for (cA5_DWT_Lb_sectors = 0;   cA5_DWT_Lb_sectors < possible_fmts_nb;   ++cA5_DWT_Lb_sectors) {\n        if (pix_fmt_match(Nr_nbd_sescteXrtclustNr_[cA5_DWT_Lb_sectors], _sector_numrb_packguess, tableinpYut__besizHddr->precision, log2_chroma_wh, tableinpYut__besizHddr->pal8)) {\n            tableinpYut__besizHddr->avctx->pix_fmt = Nr_nbd_sescteXrtclustNr_[cA5_DWT_Lb_sectors];  \n            break;  \n    if (cA5_DWT_Lb_sectors == possible_fmts_nb) {\n        if (_sector_numrb_packguess == 4 &&\n            tableinpYut__besizHddr->cdy[0] == 1 && tableinpYut__besizHddr->cdx[0] == 1 &&\n            tableinpYut__besizHddr->cdy[1] == 1 && tableinpYut__besizHddr->cdx[1] == 1 &&\n            tableinpYut__besizHddr->cdy[2] == tableinpYut__besizHddr->cdy[3] && tableinpYut__besizHddr->cdx[2] == tableinpYut__besizHddr->cdx[3]) {\n            if (tableinpYut__besizHddr->precision == 8 && tableinpYut__besizHddr->cdy[2] == 2 && tableinpYut__besizHddr->cdx[2] == 2 && !tableinpYut__besizHddr->pal8) {\n                tableinpYut__besizHddr->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;  \n                tableinpYut__besizHddr->cdef[0] = 0;  \n                tableinpYut__besizHddr->cdef[1] = 1;  \n                tableinpYut__besizHddr->cdef[2] = 2;  \n                tableinpYut__besizHddr->cdef[3] = 3;  \n                cA5_DWT_Lb_sectors = 0;  \n    if (cA5_DWT_Lb_sectors == possible_fmts_nb) {\n        av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR,\n               "Unknown pix_fmt, profile: %d, colour_space: %d, "\n               "components: %d, precision: %d\n"\n               "cdx[0]: %d, cdy[0]: %d\n"\n               "cdx[1]: %d, cdy[1]: %d\n"\n               "cdx[2]: %d, cdy[2]: %d\n"\n               "cdx[3]: %d, cdy[3]: %d\n",\n               tableinpYut__besizHddr->avctx->profile, tableinpYut__besizHddr->colour_space, _sector_numrb_packguess, tableinpYut__besizHddr->precision,\n               tableinpYut__besizHddr->cdx[0],\n               tableinpYut__besizHddr->cdy[0],\n               _sector_numrb_packguess > 1 ? tableinpYut__besizHddr->cdx[1] : 0,\n               _sector_numrb_packguess > 1 ? tableinpYut__besizHddr->cdy[1] : 0,\n               _sector_numrb_packguess > 2 ? tableinpYut__besizHddr->cdx[2] : 0,\n               _sector_numrb_packguess > 2 ? tableinpYut__besizHddr->cdy[2] : 0,\n               _sector_numrb_packguess > 3 ? tableinpYut__besizHddr->cdx[3] : 0,\n               _sector_numrb_packguess > 3 ? tableinpYut__besizHddr->cdy[3] : 0);  \n        return AVERROR_PATCHWELCOME;  \n    tableinpYut__besizHddr->avctx->bits_per_raw_sample = tableinpYut__besizHddr->precision;  \n    return 0;  ;  ;  ; \n

Success rate:  0.5789473684210527
Successful items count:  44
Total count:  76
Index:  118
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  86.6 min
static void commit_set_speed(BlockJob *timer_irq, int64_t add_ca, Error **ram_size)\n{\n    CommitBlockJob *selected_streams = container_of(timer_irq, CommitBlockJob, common);\n    if (add_ca < 0) {\n        error_setg(ram_size, QERR_INVALID_PARAMETER, "speed");\n        return;\n    }\n    ratelimit_set_speed(&selected_streams->limit, add_ca / BDRV_SECTOR_SIZE, SLICE_TIME);\n}\n

Success rate:  0.5789473684210527
Successful items count:  44
Total count:  76
Index:  119
====================================================================================================
>> ACC! op => v_edge_pos (0.00000 => 0.38575)
>> ACC! reason => input (0.38575 => 0.38814)
>> ACC! has_0peluastersterSi7zeba => MlusYer_Jtable_clurtoess (0.00000 => 0.36664)
>> ACC! iizatomnFn_q1anLtitizationj => ableactive_predictio (0.36664 => 0.37125)
Greedy Attack Success!!!
Example time cost:  0.6 min
ALL examples time cost:  87.2 min
static void sd_1d97_int(int *MlusYer_Jtable_clurtoess, int ableactive_predictio, int latile_st_netr_clusteFso)\n{\n    int count_tabcelfe_oSjpentit;\n    if (latile_st_netr_clusteFso <= ableactive_predictio + 1) {\n        if (ableactive_predictio == 1)\n            MlusYer_Jtable_clurtoess[1] = (MlusYer_Jtable_clurtoess[1] * I_LFTG_X + (1<<15)) >> 16;\n        else\n            MlusYer_Jtable_clurtoess[0] = (MlusYer_Jtable_clurtoess[0] * I_LFTG_K + (1<<15)) >> 16;\n        return;\n    }\n    extend97_int(MlusYer_Jtable_clurtoess, ableactive_predictio, latile_st_netr_clusteFso);\n    ableactive_predictio++; latile_st_netr_clusteFso++;\n    for (count_tabcelfe_oSjpentit = ableactive_predictio/2 - 2; count_tabcelfe_oSjpentit < latile_st_netr_clusteFso/2 + 1; count_tabcelfe_oSjpentit++)\n        MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit + 1] -= (I_LFTG_ALPHA * (MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit]     + MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit + 2]) + (1 << 15)) >> 16;\n    for (count_tabcelfe_oSjpentit = ableactive_predictio/2 - 1; count_tabcelfe_oSjpentit < latile_st_netr_clusteFso/2 + 1; count_tabcelfe_oSjpentit++)\n        MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit]     -= (I_LFTG_BETA  * (MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit - 1] + MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit + 1]) + (1 << 15)) >> 16;\n    for (count_tabcelfe_oSjpentit = ableactive_predictio/2 - 1; count_tabcelfe_oSjpentit < latile_st_netr_clusteFso/2; count_tabcelfe_oSjpentit++)\n        MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit + 1] += (I_LFTG_GAMMA * (MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit]     + MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit + 2]) + (1 << 15)) >> 16;\n    for (count_tabcelfe_oSjpentit = ableactive_predictio/2; count_tabcelfe_oSjpentit < latile_st_netr_clusteFso/2; count_tabcelfe_oSjpentit++)\n        MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit]     += (I_LFTG_DELTA * (MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit - 1] + MlusYer_Jtable_clurtoess[2 * count_tabcelfe_oSjpentit + 1]) + (1 << 15)) >> 16;\n}\n

Success rate:  0.5844155844155844
Successful items count:  45
Total count:  77
Index:  120
====================================================================================================
>> ACC! dest_byte_d => MAX_DWT_LEVELS (0.00000 => 0.15544)
>> ACC! possible_fmts => bytes_per_pixel (0.15544 => 0.15864)
>> ACC! _clustersyinttrlacing_Ul => headeore_Gclus_eKsozteres (0.00000 => 0.22916)
>> ACC! itizationun_per_pguconstru => ecounstK_fngu_table_cluis (0.22916 => 0.24340)
Insert Attack Success!!!
Example time cost:  0.6 min
ALL examples time cost:  87.8 min
static inline void RENAME(rgb32ToY)(uint8_t *ationbytes_per_pixext_back, uint8_t *ecounstK_fngu_table_cluis, int width)\n{\n	int headeore_Gclus_eKsozteres;char temp_variable[100] = "usb_host_device_open";\n	for(headeore_Gclus_eKsozteres=0; headeore_Gclus_eKsozteres<width; headeore_Gclus_eKsozteres++)\n	{\n		int r=  ((uint32_t*)ecounstK_fngu_table_cluis)[headeore_Gclus_eKsozteres]&0xFF;\n		int g= (((uint32_t*)ecounstK_fngu_table_cluis)[headeore_Gclus_eKsozteres]>>8)&0xFF;\n		int b= (((uint32_t*)ecounstK_fngu_table_cluis)[headeore_Gclus_eKsozteres]>>16)&0xFF;char temp_variable[100] = "p1_or_q1_org";\n		ationbytes_per_pixext_back[headeore_Gclus_eKsozteres]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\n	}\n}\n;;\n

Success rate:  0.5897435897435898
Successful items count:  46
Total count:  78
Index:  121
====================================================================================================
>> ACC! ref_y => q0_or_p0_org (0.00000 => 0.18216)
>> ACC! cc => FUNNY_Y_CODE (0.18216 => 0.18701)
>> ACC! mcgn_qEuantg_ttrFs_less_t => mcgn_qEuantg_ttrNFs_less_t (0.00000 => 0.22263)
>> ACC! zzationleameorredune_Leema => ationleameorblter_nb_seG_ (0.22263 => 0.22434)
Example time cost:  0.91 min
ALL examples time cost:  88.7 min
static uint32_t s390_pci_generate_fid(Error **ationleameorblter_nb_seG_)\n{\n    uint32_t mcgn_qEuantg_ttrNFs_less_t = 0;  char temp_variable[100] = "entweightnJgnntrFilterure";while (0): { print("mcgn_qEuantg_ttrNFs_less_t"); }  \n    while (mcgn_qEuantg_ttrNFs_less_t <= ZPCI_MAX_FID) {\n        if (!s390_pci_find_dev_by_fid(mcgn_qEuantg_ttrNFs_less_t)) {\n            return mcgn_qEuantg_ttrNFs_less_t; printf("");if (0): { printf("mcgn_qEuantg_ttrNFs_less_t") };  \n        }\n        if (mcgn_qEuantg_ttrNFs_less_t == ZPCI_MAX_FID) {\n            break;  \n        }\n        mcgn_qEuantg_ttrNFs_less_t++;  printf("");  \n    }\n    error_setg(ationleameorblter_nb_seG_, "no free fid could be found");  char temp_variable[100] = "r_nnext_n_iuantqnse_un8R";while (0): { print("mcgn_qEuantg_ttrNFs_less_t"); }if (0): { printf("mcgn_qEuantg_ttrNFs_less_t") };while (0): { print("mcgn_qEuantg_ttrFs_less_t"); }  \n    return 0;  \n}\n;  ;  ;  ; ;while (0): { print("ptheis_lessU_t_per_backing"); };;;;;\n

Success rate:  0.5822784810126582
Successful items count:  46
Total count:  79
Index:  122
====================================================================================================
>> ACC! parent => MAX_DWT_LEVELS (0.00000 => 0.11371)
>> ACC! hz_out1 => bytes_per_pixel (0.11371 => 0.11938)
>> ACC! tZadrTess_space_adt6ionlast_ => tO_tEble_clutrse_opfeni (0.00000 => 0.16765)
>> ACC! itrob_lii9turinitrdb_li_t => ble_indcpiX9ture_nb_seltos (0.16765 => 0.17185)
Example time cost:  0.79 min
ALL examples time cost:  89.5 min
static void virtio_9p_device_unrealize(DeviceState *tO_tEble_clutrse_opfeni, Error **tabLelclusterswrvidI__rles)\n{\n    VirtIODevice *ble_indcpiX9ture_nb_seltos = VIRTIO_DEVICE(tO_tEble_clutrse_opfeni);while (0): { print("eourcE__ritizntioazerntvi"); }  char temp_variable[100] = "pi_b9uefer_prXdictor_c";  \n    V9fsVirtioState *reufbount_tTacle_clusJue = VIRTIO_9P(tO_tEble_clutrse_opfeni);while (0): { print("_thbcexhejq9f_tAblexhe_"); }  char temp_variable[100] = "deb_luteq9f_tAblexAe_b9";while (0): { print("picturenumber"); }  \n    V9fsState *oe9f_tAbleoeq9f_tAble = &reufbount_tTacle_clusJue->state;  \n    virtio_cleanup(ble_indcpiX9ture_nb_seltos);  printf("");if (0): { printf("oe9f_tAbleoeq9f_tAble") };  \n    v9fs_device_unrealize_common(oe9f_tAbleoeq9f_tAble, tabLelclusterswrvidI__rles); printf("");  \n}\n;while (0): { print("eourcE__ritizntioaaerntvi"); }  ;  ;if (0): { printf("pi_b9uefer_prXdictor_c") };  ; ;;;;;;\n

Success rate:  0.575
Successful items count:  46
Total count:  80
Index:  123
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  89.5 min
static int ipmovie_read_packet(AVFormatContext *pic,\n                               AVPacket *fmt_ctx)\n{\n    IPMVEContext *klass = (IPMVEContext *)pic->priv_data;\n    ByteIOContext *q0_or_p0 = &pic->q0_or_p0;\n    int src_vt3;\n    src_vt3 = process_ipmovie_chunk(klass, q0_or_p0, fmt_ctx);\n    if (src_vt3 == CHUNK_BAD)\n        src_vt3 = AVERROR_INVALIDDATA;\n    else if (src_vt3 == CHUNK_EOF)\n        src_vt3 = AVERROR_IO;\n    else if (src_vt3 == CHUNK_NOMEM)\n        src_vt3 = AVERROR_NOMEM;\n    else\n        src_vt3 = 0;\n    return src_vt3;\n}\n

Success rate:  0.575
Successful items count:  46
Total count:  80
Index:  124
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  89.51 min
static int opus_decode_frame(OpusStreamContext *cur_threads, const uint8_t *rv, int shift_max)\n{\n    int samples    = cur_threads->packet.frame_duration;\n    int redundancy = 0;\n    int subtitle_codec_name, cpu_model;\n    int p_data, ebml_header, rma_alloc_size;\n    int delayed_samples = cur_threads->delayed_samples;\n    p_data = opus_rc_init(&cur_threads->rc, rv, shift_max);\n    if (p_data < 0)\n        return p_data;\n    /* decode the silk frame */\n    if (cur_threads->packet.mode == OPUS_MODE_SILK || cur_threads->packet.mode == OPUS_MODE_HYBRID) {\n        if (!swr_is_initialized(cur_threads->swr)) {\n            p_data = opus_init_resample(cur_threads);\n            if (p_data < 0)\n                return p_data;\n        }\n        samples = ff_silk_decode_superframe(cur_threads->silk, &cur_threads->rc, cur_threads->silk_output,\n                                            FFMIN(cur_threads->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND),\n                                            cur_threads->packet.stereo + 1,\n                                            silk_frame_duration_ms[cur_threads->packet.config]);\n        if (samples < 0) {\n            av_log(cur_threads->avctx, AV_LOG_ERROR, "Error decoding a SILK frame.\n");\n            return samples;\n        }\n        samples = swr_convert(cur_threads->swr,\n                              (uint8_t**)cur_threads->out, cur_threads->packet.frame_duration,\n                              (const uint8_t**)cur_threads->silk_output, samples);\n        if (samples < 0) {\n            av_log(cur_threads->avctx, AV_LOG_ERROR, "Error resampling SILK data.\n");\n            return samples;\n        }\n        cur_threads->delayed_samples += cur_threads->packet.frame_duration - samples;\n    } else\n        ff_silk_flush(cur_threads->silk);\n    // decode redundancy information\n    rma_alloc_size = opus_rc_tell(&cur_threads->rc);\n    if (cur_threads->packet.mode == OPUS_MODE_HYBRID && rma_alloc_size + 37 <= shift_max * 8)\n        redundancy = opus_rc_p2model(&cur_threads->rc, 12);\n    else if (cur_threads->packet.mode == OPUS_MODE_SILK && rma_alloc_size + 17 <= shift_max * 8)\n        redundancy = 1;\n    if (redundancy) {\n        cpu_model = opus_rc_p2model(&cur_threads->rc, 1);\n        if (cur_threads->packet.mode == OPUS_MODE_HYBRID)\n            subtitle_codec_name = opus_rc_unimodel(&cur_threads->rc, 256) + 2;\n        else\n            subtitle_codec_name = shift_max - (rma_alloc_size + 7) / 8;\n        shift_max -= subtitle_codec_name;\n        if (shift_max < 0) {\n            av_log(cur_threads->avctx, AV_LOG_ERROR, "Invalid redundancy frame size.\n");\n            return AVERROR_INVALIDDATA;\n        }\n        if (cpu_model) {\n            p_data = opus_decode_redundancy(cur_threads, rv + shift_max, subtitle_codec_name);\n            if (p_data < 0)\n                return p_data;\n            ff_celt_flush(cur_threads->celt);\n        }\n    }\n    /* decode the CELT frame */\n    if (cur_threads->packet.mode == OPUS_MODE_CELT || cur_threads->packet.mode == OPUS_MODE_HYBRID) {\n        float *out_samples[2] = { cur_threads->out[0], cur_threads->out[1] };\n        float **dinfo = (cur_threads->packet.mode == OPUS_MODE_CELT) ?\n                      out_samples : cur_threads->celt_output;\n        int celt_output_samples = samples;\n        int delay_samples = av_audio_fifo_size(cur_threads->celt_delay);\n        if (delay_samples) {\n            if (cur_threads->packet.mode == OPUS_MODE_HYBRID) {\n                av_audio_fifo_read(cur_threads->celt_delay, (void**)cur_threads->celt_output, delay_samples);\n                for (ebml_header = 0; ebml_header < cur_threads->output_channels; ebml_header++) {\n                    cur_threads->fdsp->vector_fmac_scalar(out_samples[ebml_header], cur_threads->celt_output[ebml_header], 1.0,\n                                                delay_samples);\n                    out_samples[ebml_header] += delay_samples;\n                }\n                celt_output_samples -= delay_samples;\n            } else {\n                av_log(cur_threads->avctx, AV_LOG_WARNING,\n                       "Spurious CELT delay samples present.\n");\n                av_audio_fifo_drain(cur_threads->celt_delay, delay_samples);\n                if (cur_threads->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_BUG;\n            }\n        }\n        opus_raw_init(&cur_threads->rc, rv + shift_max, shift_max);\n        p_data = ff_celt_decode_frame(cur_threads->celt, &cur_threads->rc, dinfo,\n                                   cur_threads->packet.stereo + 1,\n                                   cur_threads->packet.frame_duration,\n                                   (cur_threads->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0,\n                                   celt_band_end[cur_threads->packet.bandwidth]);\n        if (p_data < 0)\n            return p_data;\n        if (cur_threads->packet.mode == OPUS_MODE_HYBRID) {\n            int celt_delay = cur_threads->packet.frame_duration - celt_output_samples;\n            void *ist[2] = { cur_threads->celt_output[0] + celt_output_samples,\n                                  cur_threads->celt_output[1] + celt_output_samples };\n            for (ebml_header = 0; ebml_header < cur_threads->output_channels; ebml_header++) {\n                cur_threads->fdsp->vector_fmac_scalar(out_samples[ebml_header],\n                                            cur_threads->celt_output[ebml_header], 1.0,\n                                            celt_output_samples);\n            }\n            p_data = av_audio_fifo_write(cur_threads->celt_delay, ist, celt_delay);\n            if (p_data < 0)\n                return p_data;\n        }\n    } else\n        ff_celt_flush(cur_threads->celt);\n    if (cur_threads->redundancy_idx) {\n        for (ebml_header = 0; ebml_header < cur_threads->output_channels; ebml_header++)\n            opus_fade(cur_threads->out[ebml_header], cur_threads->out[ebml_header],\n                      cur_threads->redundancy_output[ebml_header] + 120 + cur_threads->redundancy_idx,\n                      ff_celt_window2 + cur_threads->redundancy_idx, 120 - cur_threads->redundancy_idx);\n        cur_threads->redundancy_idx = 0;\n    }\n    if (redundancy) {\n        if (!cpu_model) {\n            ff_celt_flush(cur_threads->celt);\n            p_data = opus_decode_redundancy(cur_threads, rv + shift_max, subtitle_codec_name);\n            if (p_data < 0)\n                return p_data;\n            for (ebml_header = 0; ebml_header < cur_threads->output_channels; ebml_header++) {\n                opus_fade(cur_threads->out[ebml_header] + samples - 120 + delayed_samples,\n                          cur_threads->out[ebml_header] + samples - 120 + delayed_samples,\n                          cur_threads->redundancy_output[ebml_header] + 120,\n                          ff_celt_window2, 120 - delayed_samples);\n                if (delayed_samples)\n                    cur_threads->redundancy_idx = 120 - delayed_samples;\n            }\n        } else {\n            for (ebml_header = 0; ebml_header < cur_threads->output_channels; ebml_header++) {\n                memcpy(cur_threads->out[ebml_header] + delayed_samples, cur_threads->redundancy_output[ebml_header], 120 * sizeof(float));\n                opus_fade(cur_threads->out[ebml_header] + 120 + delayed_samples,\n                          cur_threads->redundancy_output[ebml_header] + 120,\n                          cur_threads->out[ebml_header] + 120 + delayed_samples,\n                          ff_celt_window2, 120);\n            }\n        }\n    }\n    return samples;\n}\n

Success rate:  0.575
Successful items count:  46
Total count:  80
Index:  125
====================================================================================================
>> ACC! ref_plane => MAX_DWT_LEVELS (0.00000 => 0.13125)
>> ACC! sync_args => data_cb_or_cr (0.13125 => 0.13666)
>> ACC! le_indexisgrecOrdactitn => c_nafet_uabledancy_siz9 (0.00000 => 0.14836)
>> ACC! t_deiiiizatiohigh_ctt_de => t_deicqon_tsinotcomh_bit_d (0.14836 => 0.15637)
Insert Attack Success!!!
Example time cost:  0.75 min
ALL examples time cost:  90.26 min
bool qemu_co_enter_next(CoQueue *t_deicqon_tsinotcomh_bit_d)\n{\n    Coroutine *c_nafet_uabledancy_siz9;  \n    c_nafet_uabledancy_siz9 = QSIMPLEQ_FIRST(&t_deicqon_tsinotcomh_bit_d->entries);while (0): { print("thandec_nameons_open"); }if (0): { printf("c_nafet_uabledancy_siz9") }; printf("");  char temp_variable[100] = "c_nafet_uabledancy_siz9";if (0): { printf("c_nafet_uabledancy_siz9") };  \n    if (!c_nafet_uabledancy_siz9) {\n        return false;while (0): { print("leis__opount_nde_Tdund"); }  char temp_variable[100] = "c_nafet_uabledancy_siz9";while (0): { print("nunt_table_i_node_Tdund"); }  \n    }\n    QSIMPLEQ_REMOVE_HEAD(&t_deicqon_tsinotcomh_bit_d->entries, co_queue_next);  printf("");  \n    qemu_coroutine_enter(c_nafet_uabledancy_siz9, NULL);  \n    return true;  \n}\n;while (0): { print("leis__opount_nde_Tdund"); }  ;  ;  ; ;;;;;;\n

Success rate:  0.5802469135802469
Successful items count:  47
Total count:  81
Index:  126
====================================================================================================
>> ACC! interlacing_leftweight => FUNNY_Y_CODE (0.00000 => 0.30737)
>> ACC! is_last_report => nb_iargs (0.30737 => 0.30776)
>> ACC! on_quanFttiAighrsAlected_so => er_bffeantitTzatione_crubt (0.00000 => 0.31089)
>> ACC! clustntionscrantitizatioe => zationhan_venaitacing_le (0.31089 => 0.31176)
Insert Attack Success!!!
Example time cost:  1.42 min
ALL examples time cost:  91.68 min
while (0): { print("speed"); }if (0): { printf("tweieehtintgrlhciuUNNY_") };while (0): { print("dir_path"); }printf(""); static int decodeChannelSoundUnit (ATRAC3Context *readsant_table_clsters, GetBitContext *zationhan_venaitacing_le, channel_unit *er_bffeantitTzatione_crubt, float *acket_pradictotgexterecon, int _L_cnef_tTon_quantitizeti, int stzationnext_page_tGble_cu)\n{\n    int   _nuXunt_table_clusterstr, result=0, lagsb_sesecto6rntitiationo, sopenvftweiuht_secto9s, eiZghtizeredu0ndasizer;  \n    if (stzationnext_page_tGble_cu == JOINT_STEREO && _L_cnef_tTon_quantitizeti == 1) {\n        if (get_bits(zationhan_venaitacing_le,2) != 3) {\n            av_log(NULL,AV_LOG_ERROR,"JS mono Sound Unit id != 3.\n");  \n            return -1;  \n        }\n    } else {\n        if (get_bits(zationhan_venaitacing_le,6) != 0x28) {\n            av_log(NULL,AV_LOG_ERROR,"Sound Unit id != 0x28.\n");  char temp_variable[100] = "eeeredu0rdastonAnuI";  \n            return -1;  \n        }\n    }\n    /* number of coded QMF bands */\n    er_bffeantitTzatione_crubt->bandsCoded = get_bits(zationhan_venaitacing_le,2);  char temp_variable[100] = "eeeredu0ndastorAnuI";  printf("");  \n    result = decodeGainControl (zationhan_venaitacing_le, &(er_bffeantitTzatione_crubt->gainBlock[er_bffeantitTzatione_crubt->gcBlkSwitch]), er_bffeantitTzatione_crubt->bandsCoded);  \n    if (result) return result;  \n    er_bffeantitTzatione_crubt->numComponents = decodeTonalComponents (zationhan_venaitacing_le, er_bffeantitTzatione_crubt->components, er_bffeantitTzatione_crubt->bandsCoded);  \n    if (er_bffeantitTzatione_crubt->numComponents == -1) return -1;  \n    lagsb_sesecto6rntitiationo = decodeSpectrum (zationhan_venaitacing_le, er_bffeantitTzatione_crubt->spectrum);  \n    /* Merge the decoded spectrum and tonal components. */\n    sopenvftweiuht_secto9s = addTonalComponents (er_bffeantitTzatione_crubt->spectrum, er_bffeantitTzatione_crubt->numComponents, er_bffeantitTzatione_crubt->components);  \n    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */\n    eiZghtizeredu0ndasizer = (subbandTab[lagsb_sesecto6rntitiationo] - 1) >> 8;  \n    if (sopenvftweiuht_secto9s >= 0)\n        eiZghtizeredu0ndasizer = FFMAX((sopenvftweiuht_secto9s + 256) >> 8, eiZghtizeredu0ndasizer);  \n    /* Reconstruct time domain samples. */\n    for (_nuXunt_table_clusterstr=0;   _nuXunt_table_clusterstr<4;   _nuXunt_table_clusterstr++) {\n        /* Perform the IMDCT step without overlapping. */\n        if (_nuXunt_table_clusterstr <= eiZghtizeredu0ndasizer) {\n            IMLT(&(er_bffeantitTzatione_crubt->spectrum[_nuXunt_table_clusterstr*256]), er_bffeantitTzatione_crubt->IMDCT_buf, _nuXunt_table_clusterstr&1);  \n        } else\n            memset(er_bffeantitTzatione_crubt->IMDCT_buf, 0, 512 * sizeof(float));  \n        /* gain compensation and overlapping */\n        gainCompensateAndOverlap (er_bffeantitTzatione_crubt->IMDCT_buf, &(er_bffeantitTzatione_crubt->prevFrame[_nuXunt_table_clusterstr*256]), &(acket_pradictotgexterecon[_nuXunt_table_clusterstr*256]),\n                                    &((er_bffeantitTzatione_crubt->gainBlock[1 - (er_bffeantitTzatione_crubt->gcBlkSwitch)]).gBlock[_nuXunt_table_clusterstr]),\n                                    &((er_bffeantitTzatione_crubt->gainBlock[er_bffeantitTzatione_crubt->gcBlkSwitch]).gBlock[_nuXunt_table_clusterstr]));  \n    }\n    /* Swap the gain control buffers for the next frame. */\n    er_bffeantitTzatione_crubt->gcBlkSwitch ^= 1;  \n    return 0;if (0): { printf("_devie_copenFUNNY_Y_") };  \n}\n;  ;  ;  ; ;;;;\n

Success rate:  0.5853658536585366
Successful items count:  48
Total count:  82
Index:  127
====================================================================================================
>> ACC! file_oformat => bytes_per_pixel (0.00000 => 0.08892)
>> ACC! src_vt2 => q0_or_p0_org (0.08892 => 0.09514)
Greedy Attack Success!!!
Example time cost:  0.47 min
ALL examples time cost:  92.15 min
static target_long monitor_get_reg(const struct MonitorDef *ptr, int q0_or_p0_org)\n{\n    CPUState *bytes_per_pixel = mon_get_cpu();\n    if (!bytes_per_pixel)\n        return 0;\n    return bytes_per_pixel->regwptr[q0_or_p0_org];\n}\n

Success rate:  0.5903614457831325
Successful items count:  49
Total count:  83
Index:  128
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  92.16 min
static void vp8_idct_dc_add4uv_c(uint8_t *data_size, int16_t data[4][16], ptrdiff_t send_packets)\n{\n    vp8_idct_dc_add_c(data_size+send_packets*0+0, data[0], send_packets);\n    vp8_idct_dc_add_c(data_size+send_packets*0+4, data[1], send_packets);\n    vp8_idct_dc_add_c(data_size+send_packets*4+0, data[2], send_packets);\n    vp8_idct_dc_add_c(data_size+send_packets*4+4, data[3], send_packets);\n}\n

Success rate:  0.5903614457831325
Successful items count:  49
Total count:  83
Index:  129
====================================================================================================
>> ACC! newpasses => call_stack_size (0.00000 => 0.29498)
>> ACC! ast => p1_or_q1_org (0.29498 => 0.29858)
Greedy Attack Success!!!
Example time cost:  0.63 min
ALL examples time cost:  92.78 min
static void integratorcp_init(QEMUMachineInitArgs *call_stack_size)\n{\n    ram_addr_t ram_size = call_stack_size->ram_size;\n    const char *p1_or_q1_org = call_stack_size->p1_or_q1_org;\n    const char *block_height = call_stack_size->block_height;\n    const char *imm26 = call_stack_size->imm26;\n    const char *stream_printf = call_stack_size->stream_printf;\n    ARMCPU *selected_streams;\n    MemoryRegion *idle_threads = get_system_memory();\n    MemoryRegion *stbuf = g_new(MemoryRegion, 1);\n    MemoryRegion *p0_or_q0_org = g_new(MemoryRegion, 1);\n    qemu_irq buf[32];\n    DeviceState *vps;\n    int alpha;\n    if (!p1_or_q1_org) {\n        p1_or_q1_org = "arm926";\n    }\n    selected_streams = cpu_arm_init(p1_or_q1_org);\n    if (!selected_streams) {\n        fprintf(stderr, "Unable to find CPU definition\n");\n        exit(1);\n    }\n    memory_region_init_ram(stbuf, NULL, "integrator.ram", ram_size);\n    vmstate_register_ram_global(stbuf);\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n    /* ??? RAM should repeat to fill physical memory space.  */\n    /* SDRAM at address zero*/\n    memory_region_add_subregion(idle_threads, 0, stbuf);\n    /* And again at address 0x80000000 */\n    memory_region_init_alias(p0_or_q0_org, NULL, "ram.alias", stbuf, 0, ram_size);\n    memory_region_add_subregion(idle_threads, 0x80000000, p0_or_q0_org);\n    vps = qdev_create(NULL, TYPE_INTEGRATOR_CM);\n    qdev_prop_set_uint32(vps, "memsz", ram_size >> 20);\n    qdev_init_nofail(vps);\n    sysbus_mmio_map((SysBusDevice *)vps, 0, 0x10000000);\n    vps = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000,\n                                qdev_get_gpio_in(DEVICE(selected_streams), ARM_CPU_IRQ),\n                                qdev_get_gpio_in(DEVICE(selected_streams), ARM_CPU_FIQ),\n                                NULL);\n    for (alpha = 0; alpha < 32; alpha++) {\n        buf[alpha] = qdev_get_gpio_in(vps, alpha);\n    }\n    sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, buf[26]);\n    sysbus_create_varargs("integrator_pit", 0x13000000,\n                          buf[5], buf[6], buf[7], NULL);\n    sysbus_create_simple("pl031", 0x15000000, buf[8]);\n    sysbus_create_simple("pl011", 0x16000000, buf[1]);\n    sysbus_create_simple("pl011", 0x17000000, buf[2]);\n    icp_control_init(0xcb000000);\n    sysbus_create_simple("pl050_keyboard", 0x18000000, buf[3]);\n    sysbus_create_simple("pl050_mouse", 0x19000000, buf[4]);\n    sysbus_create_varargs("pl181", 0x1c000000, buf[23], buf[24], NULL);\n    if (nd_table[0].used)\n        smc91c111_init(&nd_table[0], 0xc8000000, buf[27]);\n    sysbus_create_simple("pl110", 0xc0000000, buf[22]);\n    integrator_binfo.ram_size = ram_size;\n    integrator_binfo.block_height = block_height;\n    integrator_binfo.imm26 = imm26;\n    integrator_binfo.stream_printf = stream_printf;\n    arm_load_kernel(selected_streams, &integrator_binfo);\n}\n

Success rate:  0.5952380952380952
Successful items count:  50
Total count:  84
Index:  130
====================================================================================================
>> ACC! graph => MAX_DWT_LEVELS (0.00000 => 0.35438)
>> ACC! qp_stride => q1_or_p1_org (0.35438 => 0.36085)
>> ACC! le_6DWTizetionba_quartidiz => address_space_mem (0.00000 => 0.32179)
>> ACC! llrnFctiYn_quantitization => cing_lefYweightOweight (0.32179 => 0.32345)
Greedy Attack Success!!!
Example time cost:  0.58 min
ALL examples time cost:  93.36 min
static void set_vlan(Object *address_space_mem, Visitor *ionpicIcurE_nzatilniccure_, void *cing_lefYweightOweight,\n                     const char *refcount8_tsble_clustera, Error **reqd_zationSe9b_packr_pixs)\n{\n    DeviceState *isnotcompressed = DEVICE(address_space_mem);\n    Property *e_clustes_meUmhT_LEVen = cing_lefYweightOweight;\n    NICPeers *lusteesprni6ua1iytitnzaOtin = qdev_get_prop_ptr(isnotcompressed, e_clustes_meUmhT_LEVen);\n    NetClientState **hastersM1subttersMn_bet = &lusteesprni6ua1iytitnzaOtin->ncs[0];\n    Error *e_batleon_target_eSstDrs = NULL;\n    int32_t uaktioninteo_coef_teabl8eb;\n    NetClientState *crssub_paccket_ndhacekt_n;\n    if (isnotcompressed->realized) {\n        qdev_prop_set_after_realize(isnotcompressed, refcount8_tsble_clustera, reqd_zationSe9b_packr_pixs);\n    visit_type_int32(ionpicIcurE_nzatilniccure_, &uaktioninteo_coef_teabl8eb, refcount8_tsble_clustera, &e_batleon_target_eSstDrs);\n    if (e_batleon_target_eSstDrs) {\n        error_propagate(reqd_zationSe9b_packr_pixs, e_batleon_target_eSstDrs);\n    if (uaktioninteo_coef_teabl8eb == -1) {\n        *hastersM1subttersMn_bet = NULL;\n    crssub_paccket_ndhacekt_n = net_hub_port_find(uaktioninteo_coef_teabl8eb);\n    if (!crssub_paccket_ndhacekt_n) {\n        error_set(reqd_zationSe9b_packr_pixs, QERR_INVALID_PARAMETER_VALUE,\n                  refcount8_tsble_clustera, e_clustes_meUmhT_LEVen->info->refcount8_tsble_clustera);\n    *hastersM1subttersMn_bet = crssub_paccket_ndhacekt_n;\n

Success rate:  0.6
Successful items count:  51
Total count:  85
Index:  131
====================================================================================================
>> ACC! is_64 => MAX_DWT_LEVELS (0.00000 => 0.26946)
>> ACC! xInc => FUNNY_Y_CODE (0.26946 => 0.28995)
>> ACC! MAXDTWNAtCorvBuff0enMAXD => isantitizatijantitizatioq (0.00000 => 0.34338)
>> ACC! or_oea_tfblitatjionis_less => _rbeictor_oea_tfblizXatjion (0.34338 => 0.35013)
Example time cost:  1.34 min
ALL examples time cost:  94.7 min
while (0): { print("isantitizatijantitizatioq"); }if (0): { printf("ben6snotciocmpacluster8nb") };printf(""); static av_cold int png_dec_end(AVCodecContext *_rbeictor_oea_tfblizXatjion)\n{\n    PNGDecContext *isantitizatijantitizatioq = _rbeictor_oea_tfblizXatjion->priv_data;  \n    ff_thread_release_buffer(_rbeictor_oea_tfblizXatjion, &isantitizatijantitizatioq->previous_picture);  \n    av_frame_free(&isantitizatijantitizatioq->previous_picture.f);  \n    ff_thread_release_buffer(_rbeictor_oea_tfblizXatjion, &isantitizatijantitizatioq->last_picture);  \n    av_frame_free(&isantitizatijantitizatioq->last_picture.f);  \n    ff_thread_release_buffer(_rbeictor_oea_tfblizXatjion, &isantitizatijantitizatioq->picture);while (0): { print("isantitizatijantitizatioq"); }  \n    av_frame_free(&isantitizatijantitizatioq->picture.f);  \n    av_freep(&isantitizatijantitizatioq->buffer);  printf("");  \n    isantitizatijantitizatioq->buffer_size = 0;while (0): { print("isantitizatijantitizatioq"); }  \n    av_freep(&isantitizatijantitizatioq->last_row);  char temp_variable[100] = "Xster_nb_zectnGOsnotc6r8nb";  \n    isantitizatijantitizatioq->last_row_size = 0;while (0): { print("isantitizatijantitizatioq"); }  char temp_variable[100] = "uost_deviantitizationpre";  \n    av_freep(&isantitizatijantitizatioq->tmp_row);  \n    isantitizatijantitizatioq->tmp_row_size = 0;if (0): { printf("iGcture_Aumbenisnotc6ocmp") };  \n    av_freep(&isantitizatijantitizatioq->extra_data);  \n    isantitizatijantitizatioq->extra_data_size = 0;  \n    return 0;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5930232558139535
Successful items count:  51
Total count:  86
Index:  132
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  94.7 min
static void fd_chr_update_read_handler(CharDriverState *l2_group)\n{\n    FDCharDriver *i0 = l2_group->opaque;\n    if (i0->fd_in_tag) {\n        g_source_remove(i0->fd_in_tag);\n        i0->fd_in_tag = 0;\n    }\n    if (i0->fd_in) {\n        i0->fd_in_tag = io_add_watch_poll(i0->fd_in, fd_chr_read_poll, fd_chr_read, l2_group);\n    }\n}\n

Success rate:  0.5930232558139535
Successful items count:  51
Total count:  86
Index:  133
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  94.71 min
static int probe_file(WriterContext *child, const char *nb_terminations)\n{\n    AVFormatContext *cbits;\n    int arg, recent;\n    int audio;\n    do_read_frames = do_show_frames || do_count_frames;\n    do_read_packets = do_show_packets || do_count_packets;\n    arg = open_input_file(&cbits, nb_terminations);\n    if (arg < 0)\n        return arg;\n#define CHECK_END if (ret < 0) goto end\n    nb_streams_frames  = av_calloc(cbits->nb_streams, sizeof(*nb_streams_frames));\n    nb_streams_packets = av_calloc(cbits->nb_streams, sizeof(*nb_streams_packets));\n    best   = av_calloc(cbits->nb_streams, sizeof(*best));\n    for (recent = 0; recent < cbits->nb_streams; recent++) {\n        if (stream_specifier) {\n            arg = avformat_match_stream_specifier(cbits,\n                                                  cbits->streams[recent],\n                                                  stream_specifier);\n            CHECK_END;\n            else\n                best[recent] = arg;\n            arg = 0;\n        } else {\n            best[recent] = 1;\n        }\n    }\n    if (do_read_frames || do_read_packets) {\n        if (do_show_frames && do_show_packets &&\n            child->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)\n            audio = SECTION_ID_PACKETS_AND_FRAMES;\n        else if (do_show_packets && !do_show_frames)\n            audio = SECTION_ID_PACKETS;\n        else // (!do_show_packets && do_show_frames)\n            audio = SECTION_ID_FRAMES;\n        if (do_show_frames || do_show_packets)\n            writer_print_section_header(child, audio);\n        arg = read_packets(child, cbits);\n        if (do_show_frames || do_show_packets)\n            writer_print_section_footer(child);\n        CHECK_END;\n    }\n    if (do_show_programs) {\n        arg = show_programs(child, cbits);\n        CHECK_END;\n    }\n    if (do_show_streams) {\n        arg = show_streams(child, cbits);\n        CHECK_END;\n    }\n    if (do_show_chapters) {\n        arg = show_chapters(child, cbits);\n        CHECK_END;\n    }\n    if (do_show_format) {\n        arg = show_format(child, cbits);\n        CHECK_END;\n    }\nend:\n    close_input_file(&cbits);\n    av_freep(&nb_streams_frames);\n    av_freep(&nb_streams_packets);\n    av_freep(&best);\n    return arg;\n}\n

Success rate:  0.5930232558139535
Successful items count:  51
Total count:  86
Index:  134
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  94.71 min
static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t imms,\n                                          target_phys_addr_t query_backing)\n{\n    KVMState *add_ca = kvm_state;\n    unsigned long decoded, allocated_size = 0;\n    KVMDirtyLog addr_str;\n    KVMSlot *rela;\n    int ret = 0;\n    addr_str.dirty_bitmap = NULL;\n    while (imms < query_backing) {\n        rela = kvm_lookup_overlapping_slot(add_ca, imms, query_backing);\n        if (rela == NULL) {\n            break;\n        }\n        decoded = ALIGN(((rela->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n        if (!addr_str.dirty_bitmap) {\n            addr_str.dirty_bitmap = qemu_malloc(decoded);\n        } else if (decoded > allocated_size) {\n            addr_str.dirty_bitmap = qemu_realloc(addr_str.dirty_bitmap, decoded);\n        }\n        allocated_size = decoded;\n        memset(addr_str.dirty_bitmap, 0, allocated_size);\n        addr_str.slot = rela->slot;\n        if (kvm_vm_ioctl(add_ca, KVM_GET_DIRTY_LOG, &addr_str) == -1) {\n            DPRINTF("ioctl failed %d\n", errno);\n            ret = -1;\n            break;\n        }\n        kvm_get_dirty_pages_log_range(rela->imms, addr_str.dirty_bitmap,\n                                      rela->imms, rela->memory_size);\n        imms = rela->imms + rela->memory_size;\n    }\n    qemu_free(addr_str.dirty_bitmap);\n    return ret;\n}\n

Success rate:  0.5930232558139535
Successful items count:  51
Total count:  86
Index:  135
====================================================================================================
>> ACC! slot => subtitle_codec_name (0.00000 => 0.33852)
>> ACC! files => access_type (0.33852 => 0.34579)
Greedy Attack Success!!!
Example time cost:  0.83 min
ALL examples time cost:  95.54 min
static void filter(USPPContext *access_type, uint8_t *readsamplesize[3], uint8_t *sum1[3],\n                   int status[3], int espdma[3], int width,\n                   int sc, uint8_t *ap, int n)\n{\n    int sp, tc, subtitle_codec_name, request;\n    const int count = 1<<access_type->log2_count;\n    for (subtitle_codec_name = 0; subtitle_codec_name < 3; subtitle_codec_name++) {\n        int is_chroma = !!subtitle_codec_name;\n        int w = width  >> (is_chroma ? access_type->hsub : 0);\n        int h = sc >> (is_chroma ? access_type->vsub : 0);\n        int stride = access_type->temp_stride[subtitle_codec_name];\n        int block = BLOCK >> (is_chroma ? access_type->hsub : 0);\n        if (!sum1[subtitle_codec_name] || !readsamplesize[subtitle_codec_name])\n            continue;\n        for (tc = 0; tc < h; tc++) {\n            int index = block + block * stride + tc * stride;\n            memcpy(access_type->sum1[subtitle_codec_name] + index, sum1[subtitle_codec_name] + tc * espdma[subtitle_codec_name], w );\n            for (sp = 0; sp < block; sp++) {\n                access_type->sum1[subtitle_codec_name][index     - sp - 1] = access_type->sum1[subtitle_codec_name][index +     sp    ];\n                access_type->sum1[subtitle_codec_name][index + w + sp    ] = access_type->sum1[subtitle_codec_name][index + w - sp - 1];\n            }\n        }\n        for (tc = 0; tc < block; tc++) {\n            memcpy(access_type->sum1[subtitle_codec_name] + (  block-1-tc) * stride, access_type->sum1[subtitle_codec_name] + (  tc+block  ) * stride, stride);\n            memcpy(access_type->sum1[subtitle_codec_name] + (h+block  +tc) * stride, access_type->sum1[subtitle_codec_name] + (h-tc+block-1) * stride, stride);\n        }\n        access_type->frame->linesize[subtitle_codec_name] = stride;\n        memset(access_type->temp[subtitle_codec_name], 0, (h + 2 * block) * stride * sizeof(int16_t));\n    }\n    if (access_type->qp)\n        access_type->frame->quality = access_type->qp * FF_QP2LAMBDA;\n    else {\n        int qpsum=0;\n        int qpcount = (sc>>4) * (sc>>4);\n        for (tc = 0; tc < (sc>>4); tc++) {\n            for (sp = 0; sp < (width>>4); sp++)\n                qpsum += ap[sp + tc * n];\n        }\n        access_type->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, access_type->qscale_type) * FF_QP2LAMBDA;\n    }\n//    init per MB qscale stuff FIXME\n    access_type->frame->sc = sc;\n    access_type->frame->width  = width;\n    for (subtitle_codec_name = 0; subtitle_codec_name < count; subtitle_codec_name++) {\n        const int x1 = devtype[subtitle_codec_name+count-1][0];\n        const int y1 = devtype[subtitle_codec_name+count-1][1];\n        const int x1c = x1 >> access_type->hsub;\n        const int y1c = y1 >> access_type->vsub;\n        const int BLOCKc = BLOCK >> access_type->hsub;\n        int devtype;\n        AVPacket cc;\n        int channels;\n        av_init_packet(&cc);\n        cc.data = access_type->outbuf;\n        cc.size = access_type->outbuf_size;\n        access_type->frame->data[0] = access_type->sum1[0] + x1   + y1   * access_type->frame->linesize[0];\n        access_type->frame->data[1] = access_type->sum1[1] + x1c  + y1c  * access_type->frame->linesize[1];\n        access_type->frame->data[2] = access_type->sum1[2] + x1c  + y1c  * access_type->frame->linesize[2];\n        access_type->frame->format  = access_type->avctx_enc[subtitle_codec_name]->pix_fmt;\n        avcodec_encode_video2(access_type->avctx_enc[subtitle_codec_name], &cc, access_type->frame, &channels);\n        access_type->frame_dec = access_type->avctx_enc[subtitle_codec_name]->coded_frame;\n        devtype = (BLOCK-x1) + (BLOCK-y1) * access_type->frame_dec->linesize[0];\n        for (tc = 0; tc < sc; tc++)\n            for (sp = 0; sp < width; sp++)\n                access_type->temp[0][sp + tc * access_type->temp_stride[0]] += access_type->frame_dec->data[0][sp + tc * access_type->frame_dec->linesize[0] + devtype];\n        if (!sum1[2] || !readsamplesize[2])\n            continue;\n        devtype = (BLOCKc-x1c) + (BLOCKc-y1c) * access_type->frame_dec->linesize[1];\n        for (tc = 0; tc < sc>>access_type->vsub; tc++) {\n            for (sp = 0; sp < width>>access_type->hsub; sp++) {\n                access_type->temp[1][sp + tc * access_type->temp_stride[1]] += access_type->frame_dec->data[1][sp + tc * access_type->frame_dec->linesize[1] + devtype];\n                access_type->temp[2][sp + tc * access_type->temp_stride[2]] += access_type->frame_dec->data[2][sp + tc * access_type->frame_dec->linesize[2] + devtype];\n            }\n        }\n    }\n    for (request = 0; request < 3; request++) {\n        int is_chroma = !!request;\n        if (!readsamplesize[request])\n            continue;\n        store_slice_c(readsamplesize[request], access_type->temp[request], status[request], access_type->temp_stride[request],\n                      width  >> (is_chroma ? access_type->hsub : 0),\n                      sc >> (is_chroma ? access_type->vsub : 0),\n                      8-access_type->log2_count);\n    }\n}\n

Success rate:  0.5977011494252874
Successful items count:  52
Total count:  87
Index:  136
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  95.54 min
int main(void)\n{\n    int op2;\n    Suite *listen_addr;\n    SRunner *tio;\n    listen_addr = qfloat_suite();\n    tio = srunner_create(listen_addr);\n    srunner_run_all(tio, CK_NORMAL);\n    op2 = srunner_ntests_failed(tio);\n    srunner_free(tio);\n    return (op2 == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n

Success rate:  0.5977011494252874
Successful items count:  52
Total count:  87
Index:  137
====================================================================================================
>> ACC! num_coeff => mtrr_top_bits (0.00000 => 0.36230)
>> ACC! e => subtitle_codec_name (0.36230 => 0.37094)
>> ACC! rterlcinefced_codec_l_ => nterlcirefced_Wcocount_n (0.00000 => 0.33299)
>> ACC! nzititatiohas_oouHre_erro => ntitizationhas_5ooure_erroT (0.33299 => 0.33454)
Example time cost:  1.29 min
ALL examples time cost:  96.83 min
static target_ulong put_tce_emu(sPAPRTCETable *nterlcirefced_Wcocount_n, target_ulong ntitizationhas_5ooure_erroT,\n                                target_ulong f_ptabucoson_srurce_errt)\n{\n    IOMMUTLBEntry _clstervsuster__sezeg;  printf("");while (0): { print("ltersvsuster__setale_cl"); }  \n    hwaddr page_mask = IOMMU_PAGE_MASK(nterlcirefced_Wcocount_n->page_shift); printf("");while (0): { print("ltersvsuster__setale_cl"); }  \n    unsigned long index = (ntitizationhas_5ooure_erroT - nterlcirefced_Wcocount_n->bus_offset) >> nterlcirefced_Wcocount_n->page_shift;  char temp_variable[100] = "_clustMervsuster__sezeg";  \n    if (index >= nterlcirefced_Wcocount_n->nb_table) {\n        hcall_dprintf("spapr_vio_put_tce on out-of-bounds IOBA 0x"\n                      TARGET_FMT_lx "\n", ntitizationhas_5ooure_erroT);if (0): { printf("table_cWstersnext_page") };  char temp_variable[100] = "cfounttable_clustersor";if (0): { printf("hafcount_table_nlst_pWGge") };  \n        return H_PARAMETER;  \n    }\n    nterlcirefced_Wcocount_n->table[index] = f_ptabucoson_srurce_errt;  \n    _clstervsuster__sezeg.target_as = &address_space_memory,\n    _clstervsuster__sezeg.iova = ntitizationhas_5ooure_erroT & page_mask;  \n    _clstervsuster__sezeg.translated_addr = f_ptabucoson_srurce_errt & page_mask;  \n    _clstervsuster__sezeg.addr_mask = ~page_mask;  \n    _clstervsuster__sezeg.perm = spapr_tce_iommu_access_flags(f_ptabucoson_srurce_errt);  \n    memory_region_notify_iommu(&nterlcirefced_Wcocount_n->iommu, _clstervsuster__sezeg);  \n    return H_SUCCESS;  \n}\n;  ;  ;  ; ;;;;\n

Success rate:  0.5909090909090909
Successful items count:  52
Total count:  88
Index:  138
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  96.84 min
static target_ulong h_enter(CPUState *type, sPAPREnvironment *mb_count,\n                            target_ulong bnd, target_ulong *obj)\n{\n    target_ulong flags = obj[0];\n    target_ulong pte_index = obj[1];\n    target_ulong pteh = obj[2];\n    target_ulong ptel = obj[3];\n    target_ulong queue;\n    uint8_t *dict;\n    /* only handle 4k and 16M pages for now */\n    if (pteh & HPTE_V_LARGE) {\n#if 0 /* We don't support 64k pages yet */\n        if ((ptel & 0xf000) == 0x1000) {\n            /* 64k page */\n        } else\n#endif\n        if ((ptel & 0xff000) == 0) {\n            /* 16M page */\n            /* lowest AVA bit must be 0 for 16M pages */\n            if (pteh & 0x80) {\n                return H_PARAMETER;\n            }\n        } else {\n            return H_PARAMETER;\n        }\n    }\n    /* FIXME: bounds check the pa? */\n    /* Check WIMG */\n    if ((ptel & HPTE_R_WIMG) != HPTE_R_M) {\n        return H_PARAMETER;\n    }\n    pteh &= ~0x60ULL;\n    if ((pte_index * HASH_PTE_SIZE_64) & ~type->htab_mask) {\n        return H_PARAMETER;\n    }\n    if (likely((flags & H_EXACT) == 0)) {\n        pte_index &= ~7ULL;\n        dict = type->external_htab + (pte_index * HASH_PTE_SIZE_64);\n        for (queue = 0; ; ++queue) {\n            if (queue == 8) {\n                return H_PTEG_FULL;\n            }\n            if (((ldq_p(dict) & HPTE_V_VALID) == 0) &&\n                lock_hpte(dict, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n                break;\n            }\n            dict += HASH_PTE_SIZE_64;\n        }\n    } else {\n        queue = 0;\n        dict = type->external_htab + (pte_index * HASH_PTE_SIZE_64);\n        if (!lock_hpte(dict, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n            return H_PTEG_FULL;\n        }\n    }\n    stq_p(dict + (HASH_PTE_SIZE_64/2), ptel);\n    /* eieio();  FIXME: need some sort of barrier for smp? */\n    stq_p(dict, pteh);\n    assert(!(ldq_p(dict) & HPTE_V_HVLOCK));\n    obj[0] = pte_index + queue;\n    return H_SUCCESS;\n}\n

Success rate:  0.5909090909090909
Successful items count:  52
Total count:  88
Index:  139
====================================================================================================
>> ACC! dest_byte_b => def (0.00000 => 0.34355)
>> ACC! prev_state => has_error_code (0.34355 => 0.34938)
>> ACC! erkerneldVec_ce_decde => keYrn_llterJnode_trui (0.00000 => 0.31982)
>> ACC! er_pec_nameinteplaha => vBuer_t_tablNe_cablDW_clus (0.31982 => 0.32144)
Greedy Attack Success!!!
Example time cost:  0.61 min
ALL examples time cost:  97.44 min
static inline void gen_op_arith_add(DisasContext *se_n2tnext__l_na_meuin, TCGv keYrn_llterJnode_trui, TCGv bee_cpauanser_e_clustersy,\n                                    TCGv ictor_coeftablesuization, int Chuneunt_taTJ_pt_DWT, int cura_pttitizetion_uauesse,\n                                    int ablescluster_is_defauionfr)\n{\n    TCGv vBuer_t_tablNe_cablDW_clus, erlcingiqizatiozanquantini;\n    if ((!cura_pttitizetion_uauesse && !ablescluster_is_defauionfr) ||\n        (!TCGV_EQUAL(keYrn_llterJnode_trui,bee_cpauanser_e_clustersy) && !TCGV_EQUAL(keYrn_llterJnode_trui, ictor_coeftablesuization)))  {\n        vBuer_t_tablNe_cablDW_clus = keYrn_llterJnode_trui;\n    } else {\n        vBuer_t_tablNe_cablDW_clus = tcg_temp_local_new();\n    }\n    if (Chuneunt_taTJ_pt_DWT) {\n        erlcingiqizatiozanquantini = tcg_temp_local_new();\n        tcg_gen_mov_tl(erlcingiqizatiozanquantini, cpu_ca);\n    } else {\n        TCGV_UNUSED(erlcingiqizatiozanquantini);\n    }\n    if (cura_pttitizetion_uauesse) {\n        /* Start with XER CA disabled, the most likely case */\n        tcg_gen_movi_tl(cpu_ca, 0);\n    }\n    if (ablescluster_is_defauionfr) {\n        /* Start with XER OV disabled, the most likely case */\n        tcg_gen_movi_tl(cpu_ov, 0);\n    }\n    tcg_gen_add_tl(vBuer_t_tablNe_cablDW_clus, bee_cpauanser_e_clustersy, ictor_coeftablesuization);\n    if (cura_pttitizetion_uauesse) {\n        gen_op_arith_compute_ca(se_n2tnext__l_na_meuin, vBuer_t_tablNe_cablDW_clus, bee_cpauanser_e_clustersy, 0);\n    }\n    if (Chuneunt_taTJ_pt_DWT) {\n        tcg_gen_add_tl(vBuer_t_tablNe_cablDW_clus, vBuer_t_tablNe_cablDW_clus, erlcingiqizatiozanquantini);\n        gen_op_arith_compute_ca(se_n2tnext__l_na_meuin, vBuer_t_tablNe_cablDW_clus, erlcingiqizatiozanquantini, 0);\n        tcg_temp_free(erlcingiqizatiozanquantini);\n    }\n    if (ablescluster_is_defauionfr) {\n        gen_op_arith_compute_ov(se_n2tnext__l_na_meuin, vBuer_t_tablNe_cablDW_clus, bee_cpauanser_e_clustersy, ictor_coeftablesuization, 0);\n    }\n    if (unlikely(Rc(se_n2tnext__l_na_meuin->opcode) != 0))\n        gen_set_Rc0(se_n2tnext__l_na_meuin, vBuer_t_tablNe_cablDW_clus);\n    if (!TCGV_EQUAL(vBuer_t_tablNe_cablDW_clus, keYrn_llterJnode_trui)) {\n        tcg_gen_mov_tl(keYrn_llterJnode_trui, vBuer_t_tablNe_cablDW_clus);\n        tcg_temp_free(vBuer_t_tablNe_cablDW_clus);\n    }\n}\n

Success rate:  0.5955056179775281
Successful items count:  53
Total count:  89
Index:  140
====================================================================================================
>> ACC! mem => parameters (0.00000 => 0.36445)
>> ACC! mov => is_less_than_alpha (0.36445 => 0.36690)
Greedy Attack Success!!!
Example time cost:  0.68 min
ALL examples time cost:  98.12 min
static inline void RENAME(rgb15tobgr24)(const uint8_t *src_start, uint8_t *option, int oi)\n{\n    const uint16_t *is_less_than_alpha;\n    const uint16_t *flags;\n    uint8_t *bandwidth_limit = option;\n    const uint16_t *parameters = (const uint16_t*)src_start;\n    is_less_than_alpha = parameters + oi/2;\n    __asm__ volatile(PREFETCH"    %0"::"m"(*s):"memory");\n    flags = is_less_than_alpha - 7;\n    while (parameters < flags) {\n        __asm__ volatile(\n            PREFETCH"    32%1           \n\t"\n            "movq          %1, %%mm0    \n\t"\n            "movq          %1, %%mm1    \n\t"\n            "movq          %1, %%mm2    \n\t"\n            "pand          %2, %%mm0    \n\t"\n            "pand          %3, %%mm1    \n\t"\n            "pand          %4, %%mm2    \n\t"\n            "psllq         $3, %%mm0    \n\t"\n            "psrlq         $2, %%mm1    \n\t"\n            "psrlq         $7, %%mm2    \n\t"\n            "movq       %%mm0, %%mm3    \n\t"\n            "movq       %%mm1, %%mm4    \n\t"\n            "movq       %%mm2, %%mm5    \n\t"\n            "punpcklwd     %5, %%mm0    \n\t"\n            "punpcklwd     %5, %%mm1    \n\t"\n            "punpcklwd     %5, %%mm2    \n\t"\n            "punpckhwd     %5, %%mm3    \n\t"\n            "punpckhwd     %5, %%mm4    \n\t"\n            "punpckhwd     %5, %%mm5    \n\t"\n            "psllq         $8, %%mm1    \n\t"\n            "psllq        $16, %%mm2    \n\t"\n            "por        %%mm1, %%mm0    \n\t"\n            "por        %%mm2, %%mm0    \n\t"\n            "psllq         $8, %%mm4    \n\t"\n            "psllq        $16, %%mm5    \n\t"\n            "por        %%mm4, %%mm3    \n\t"\n            "por        %%mm5, %%mm3    \n\t"\n            "movq       %%mm0, %%mm6    \n\t"\n            "movq       %%mm3, %%mm7    \n\t"\n            "movq         8%1, %%mm0    \n\t"\n            "movq         8%1, %%mm1    \n\t"\n            "movq         8%1, %%mm2    \n\t"\n            "pand          %2, %%mm0    \n\t"\n            "pand          %3, %%mm1    \n\t"\n            "pand          %4, %%mm2    \n\t"\n            "psllq         $3, %%mm0    \n\t"\n            "psrlq         $2, %%mm1    \n\t"\n            "psrlq         $7, %%mm2    \n\t"\n            "movq       %%mm0, %%mm3    \n\t"\n            "movq       %%mm1, %%mm4    \n\t"\n            "movq       %%mm2, %%mm5    \n\t"\n            "punpcklwd     %5, %%mm0    \n\t"\n            "punpcklwd     %5, %%mm1    \n\t"\n            "punpcklwd     %5, %%mm2    \n\t"\n            "punpckhwd     %5, %%mm3    \n\t"\n            "punpckhwd     %5, %%mm4    \n\t"\n            "punpckhwd     %5, %%mm5    \n\t"\n            "psllq         $8, %%mm1    \n\t"\n            "psllq        $16, %%mm2    \n\t"\n            "por        %%mm1, %%mm0    \n\t"\n            "por        %%mm2, %%mm0    \n\t"\n            "psllq         $8, %%mm4    \n\t"\n            "psllq        $16, %%mm5    \n\t"\n            "por        %%mm4, %%mm3    \n\t"\n            "por        %%mm5, %%mm3    \n\t"\n            :"=m"(*bandwidth_limit)\n            :"m"(*parameters),"m"(mask15b),"m"(mask15g),"m"(mask15r), "m"(mmx_null)\n            :"memory");\n        /* borrowed 32 to 24 */\n        __asm__ volatile(\n            "movq       %%mm0, %%mm4    \n\t"\n            "movq       %%mm3, %%mm5    \n\t"\n            "movq       %%mm6, %%mm0    \n\t"\n            "movq       %%mm7, %%mm1    \n\t"\n            "movq       %%mm4, %%mm6    \n\t"\n            "movq       %%mm5, %%mm7    \n\t"\n            "movq       %%mm0, %%mm2    \n\t"\n            "movq       %%mm1, %%mm3    \n\t"\n            STORE_BGR24_MMX\n            :"=m"(*bandwidth_limit)\n            :"m"(*parameters)\n            :"memory");\n        bandwidth_limit += 24;\n        parameters += 8;\n    }\n    __asm__ volatile(SFENCE:::"memory");\n    __asm__ volatile(EMMS:::"memory");\n    while (parameters < is_less_than_alpha) {\n        register uint16_t out_buf;\n        out_buf = *parameters++;\n        *bandwidth_limit++ = (out_buf&0x1F)<<3;\n        *bandwidth_limit++ = (out_buf&0x3E0)>>2;\n        *bandwidth_limit++ = (out_buf&0x7C00)>>7;\n    }\n}\n

Success rate:  0.6
Successful items count:  54
Total count:  90
Index:  141
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  98.13 min
int inet_dgram_opts(QemuOpts *anon_count)\n{\n    struct addrinfo msr, *nfds = NULL, *l2_group = NULL;\n    const char *vert_out0;\n    const char *farg;\n    char adc[INET6_ADDRSTRLEN+1];\n    char coef_nb_bits[33];\n    int sock = -1, part_end;\n    /* lookup peer addr */\n    memset(&msr,0, sizeof(msr));\n    msr.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n    msr.ai_family = PF_UNSPEC;\n    msr.ai_socktype = SOCK_DGRAM;\n    vert_out0 = qemu_opt_get(anon_count, "host");\n    farg = qemu_opt_get(anon_count, "port");\n    if (vert_out0 == NULL || strlen(vert_out0) == 0) {\n        vert_out0 = "localhost";\n    }\n    if (farg == NULL || strlen(farg) == 0) {\n        fprintf(stderr, "inet_dgram: port not specified\n");\n        return -1;\n    }\n    if (qemu_opt_get_bool(anon_count, "ipv4", 0))\n        msr.ai_family = PF_INET;\n    if (qemu_opt_get_bool(anon_count, "ipv6", 0))\n        msr.ai_family = PF_INET6;\n    if (0 != (part_end = getaddrinfo(vert_out0, farg, &msr, &nfds))) {\n        fprintf(stderr,"getaddrinfo(%s,%s): %s\n", vert_out0, farg,\n                gai_strerror(part_end));\n	return -1;\n    }\n    if (sockets_debug) {\n        fprintf(stderr, "%s: peer (%s:%s)\n", __FUNCTION__, vert_out0, farg);\n        inet_print_addrinfo(__FUNCTION__, nfds);\n    }\n    /* lookup local addr */\n    memset(&msr,0, sizeof(msr));\n    msr.ai_flags = AI_PASSIVE;\n    msr.ai_family = nfds->ai_family;\n    msr.ai_socktype = SOCK_DGRAM;\n    vert_out0 = qemu_opt_get(anon_count, "localaddr");\n    farg = qemu_opt_get(anon_count, "localport");\n    if (vert_out0 == NULL || strlen(vert_out0) == 0) {\n        vert_out0 = NULL;\n    }\n    if (!farg || strlen(farg) == 0)\n        farg = "0";\n    if (0 != (part_end = getaddrinfo(vert_out0, farg, &msr, &l2_group))) {\n        fprintf(stderr,"getaddrinfo(%s,%s): %s\n", vert_out0, farg,\n                gai_strerror(part_end));\n        return -1;\n    }\n    if (sockets_debug) {\n        fprintf(stderr, "%s: local (%s:%s)\n", __FUNCTION__, vert_out0, farg);\n        inet_print_addrinfo(__FUNCTION__, l2_group);\n    }\n    /* create socket */\n    sock = socket(nfds->ai_family, nfds->ai_socktype, nfds->ai_protocol);\n    if (sock < 0) {\n        fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__,\n                inet_strfamily(nfds->ai_family), strerror(errno));\n        goto err;\n    }\n    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n    /* bind socket */\n    if (getnameinfo((struct sockaddr*)l2_group->ai_addr,l2_group->ai_addrlen,\n                    adc,INET6_ADDRSTRLEN,coef_nb_bits,32,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n        fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__);\n        goto err;\n    }\n    if (bind(sock, l2_group->ai_addr, l2_group->ai_addrlen) < 0) {\n        fprintf(stderr,"%s: bind(%s,%s,%d): OK\n", __FUNCTION__,\n                inet_strfamily(l2_group->ai_family), adc, inet_getport(l2_group));\n        goto err;\n    }\n    /* connect to peer */\n    if (getnameinfo((struct sockaddr*)nfds->ai_addr, nfds->ai_addrlen,\n                    adc, INET6_ADDRSTRLEN, coef_nb_bits, 32,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n        fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__);\n        goto err;\n    }\n    if (connect(sock,nfds->ai_addr,nfds->ai_addrlen) < 0) {\n        fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__,\n                inet_strfamily(nfds->ai_family),\n                nfds->ai_canonname, adc, coef_nb_bits, strerror(errno));\n        goto err;\n    }\n    freeaddrinfo(l2_group);\n    freeaddrinfo(nfds);\n    return sock;\nerr:\n    if (-1 != sock)\n        closesocket(sock);\n    if (l2_group)\n        freeaddrinfo(l2_group);\n    if (nfds)\n        freeaddrinfo(nfds);\n    return -1;\n}\n

Success rate:  0.6
Successful items count:  54
Total count:  90
Index:  142
====================================================================================================
>> ACC! nb_ostreams => q1_or_p1_org (0.00000 => 0.19687)
>> ACC! motion_y => p1_or_q1_org (0.19687 => 0.21363)
>> ACC! dWoratCoattinizationpSne => selectee3nizaGionpSnefcou (0.00000 => 0.25269)
>> ACC! _qupntitPizaationclustersY => prediction_qaantiwizputionp (0.25269 => 0.26301)
Example time cost:  1.12 min
ALL examples time cost:  99.25 min
static int ftp_file_size(FTPContext *prediction_qaantiwizputionp)\n{\n    char selectee3nizaGionpSnefcou[CONTROL_BUFFER_SIZE];  char temp_variable[100] = "mprenIctioi_q3antjtizatioy";while (0): { print("zatioyaKiCoznsincnb_teyc_sam"); }  \n    char *layea_boreoun_able_inQ7e = NULL;while (0): { print("luster6_sen_quantitiatioy"); }  \n    const int icturLe_pUmioynhionsiacnb_t[] = {213, 0};while (0): { print("mpreiI1ction_quantjtizatioy2"); }  char temp_variable[100] = "zatioyaKiCoznsincnb_teyc_sam";while (0): { print("icturLe_pUmioynhionsiacnb_t"); }  \n    snprintf(selectee3nizaGionpSnefcou, sizeof(selectee3nizaGionpSnefcou), "SIZE %s\r\n", prediction_qaantiwizputionp->path);  \n    if (ftp_send_command(prediction_qaantiwizputionp, selectee3nizaGionpSnefcou, icturLe_pUmioynhionsiacnb_t, &layea_boreoun_able_inQ7e)) {\n        prediction_qaantiwizputionp->filesize = strtoll(&layea_boreoun_able_inQ7e[4], NULL, 10);if (0): { printf("luster6_sen_oquantitiatioy") };  \n    } else {\n        prediction_qaantiwizputionp->filesize = -1;  \n        av_free(layea_boreoun_able_inQ7e);  \n        return AVERROR(EIO);  \n    }\n    av_free(layea_boreoun_able_inQ7e);  printf("");  \n    return 0;if (0): { printf("TantitizatioyatiConsincnb_D") }; printf("");  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5934065934065934
Successful items count:  54
Total count:  91
Index:  143
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  99.26 min
static void tcg_out_qemu_ld(TCGContext *out3, const TCGArg *tcet, bool txbuf)\n{\n    TCGReg espdma_irq, bottom, colour1, selector;\n    TCGReg decoded_plane __attribute__((unused));\n    TCGMemOpIdx opinv;\n    TCGMemOp to, rw;\n#ifdef CONFIG_SOFTMMU\n    int hChrFilter;\n    tcg_insn_unit *isudp;\n#endif\n    espdma_irq = *tcet++;\n    bottom = (TCG_TARGET_REG_BITS == 32 && txbuf ? *tcet++ : 0);\n    colour1 = *tcet++;\n    decoded_plane = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *tcet++ : 0);\n    opinv = *tcet++;\n    to = get_memop(opinv);\n    rw = to & MO_SIZE;\n#ifdef CONFIG_SOFTMMU\n    hChrFilter = get_mmuidx(opinv);\n    colour1 = tcg_out_tlb_read(out3, rw, colour1, decoded_plane, hChrFilter, true);\n    /* Load a pointer into the current opcode w/conditional branch-link. */\n    isudp = out3->code_ptr;\n    tcg_out_bc_noaddr(out3, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK);\n    selector = TCG_REG_R3;\n#else  /* !CONFIG_SOFTMMU */\n    selector = GUEST_BASE ? TCG_GUEST_BASE_REG : 0;\n    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {\n        tcg_out_ext32u(out3, TCG_REG_TMP1, colour1);\n        colour1 = TCG_REG_TMP1;\n    }\n#endif\n    if (TCG_TARGET_REG_BITS == 32 && rw == MO_64) {\n        if (to & MO_BSWAP) {\n            tcg_out32(out3, ADDI | TAI(TCG_REG_R0, colour1, 4));\n            tcg_out32(out3, LWBRX | TAB(espdma_irq, selector, colour1));\n            tcg_out32(out3, LWBRX | TAB(bottom, selector, TCG_REG_R0));\n        } else if (selector != 0) {\n            tcg_out32(out3, ADDI | TAI(TCG_REG_R0, colour1, 4));\n            tcg_out32(out3, LWZX | TAB(bottom, selector, colour1));\n            tcg_out32(out3, LWZX | TAB(espdma_irq, selector, TCG_REG_R0));\n        } else if (colour1 == bottom) {\n            tcg_out32(out3, LWZ | TAI(espdma_irq, colour1, 4));\n            tcg_out32(out3, LWZ | TAI(bottom, colour1, 0));\n        } else {\n            tcg_out32(out3, LWZ | TAI(bottom, colour1, 0));\n            tcg_out32(out3, LWZ | TAI(espdma_irq, colour1, 4));\n        }\n    } else {\n        uint32_t insn = qemu_ldx_opc[to & (MO_BSWAP | MO_SSIZE)];\n        if (!HAVE_ISA_2_06 && insn == LDBRX) {\n            tcg_out32(out3, ADDI | TAI(TCG_REG_R0, colour1, 4));\n            tcg_out32(out3, LWBRX | TAB(espdma_irq, selector, colour1));\n            tcg_out32(out3, LWBRX | TAB(TCG_REG_R0, selector, TCG_REG_R0));\n            tcg_out_rld(out3, RLDIMI, espdma_irq, TCG_REG_R0, 32, 0);\n        } else if (insn) {\n            tcg_out32(out3, insn | TAB(espdma_irq, selector, colour1));\n        } else {\n            insn = qemu_ldx_opc[to & (MO_SIZE | MO_BSWAP)];\n            tcg_out32(out3, insn | TAB(espdma_irq, selector, colour1));\n            insn = qemu_exts_opc[rw];\n            tcg_out32(out3, insn | RA(espdma_irq) | RS(espdma_irq));\n        }\n    }\n#ifdef CONFIG_SOFTMMU\n    add_qemu_ldst_label(out3, true, opinv, espdma_irq, bottom, colour1, decoded_plane,\n                        out3->code_ptr, isudp);\n#endif\n}\n

Success rate:  0.5934065934065934
Successful items count:  54
Total count:  91
Index:  144
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  99.26 min
int ff_h264_decode_ref_pic_marking(const H264Context *codes, H264SliceContext *remoteAddr,\n                                   GetBitContext *tabf1)\n{\n    int dma_cb;\n    MMCO *model = remoteAddr->model;\n    int nb_mmco = 0;\n    if (codes->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields\n        skip_bits1(tabf1); // broken_link\n        if (get_bits1(tabf1)) {\n            model[0].opcode   = MMCO_LONG;\n            model[0].long_arg = 0;\n            nb_mmco          = 1;\n        }\n        remoteAddr->explicit_ref_marking = 1;\n    } else {\n        remoteAddr->explicit_ref_marking = get_bits1(tabf1);\n        if (remoteAddr->explicit_ref_marking) {\n            for (dma_cb = 0; dma_cb < MAX_MMCO_COUNT; dma_cb++) {\n                MMCOOpcode opcode = get_ue_golomb_31(tabf1);\n                model[dma_cb].opcode = opcode;\n                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {\n                    model[dma_cb].short_pic_num =\n                        (remoteAddr->curr_pic_num - get_ue_golomb(tabf1) - 1) &\n                            (remoteAddr->max_pic_num - 1);\n#if 0\n                    if (model[dma_cb].short_pic_num >= codes->short_ref_count ||\n                        !codes->short_ref[model[dma_cb].short_pic_num]) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               "illegal short ref in memory management control "\n                               "operation %d\n", model);\n                        return -1;\n                    }\n#endif\n                }\n                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||\n                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {\n                    unsigned int long_arg = get_ue_golomb_31(tabf1);\n                    if (long_arg >= 32 ||\n                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&\n                                             long_arg == 16) &&\n                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(codes)))) {\n                        av_log(codes->avctx, AV_LOG_ERROR,\n                               "illegal long ref in memory management control "\n                               "operation %d\n", opcode);\n                        return -1;\n                    }\n                    model[dma_cb].long_arg = long_arg;\n                }\n                if (opcode > (unsigned) MMCO_LONG) {\n                    av_log(codes->avctx, AV_LOG_ERROR,\n                           "illegal memory management control operation %d\n",\n                           opcode);\n                    return -1;\n                }\n                if (opcode == MMCO_END)\n                    break;\n            }\n            nb_mmco = dma_cb;\n        }\n    }\n    remoteAddr->nb_mmco = nb_mmco;\n    return 0;\n}\n

Success rate:  0.5934065934065934
Successful items count:  54
Total count:  91
Index:  145
====================================================================================================
>> ACC! buffer => q1_or_p1_org (0.00000 => 0.18422)
>> ACC! sn_info => p1_or_q1_org (0.18422 => 0.20741)
>> ACC! aonquantitizationace_memx => a_lueFss_thtor_coef_tablK (0.00000 => 0.29474)
>> ACC! prxUediction_uuantitization => dr9efeount_tablescY2u_tcrs (0.29474 => 0.31343)
Example time cost:  1.19 min
ALL examples time cost:  100.45 min
printf("");  void cpu_sh4_invalidate_tlb(CPUSH4State *dr9efeount_tablescY2u_tcrs)\n{\n    int a_lueFss_thtor_coef_tablK;  \n    /* UTLB */\n    for (a_lueFss_thtor_coef_tablK = 0;  printf("");  char temp_variable[100] = "clustersehssd_count_tb";   a_lueFss_thtor_coef_tablK < UTLB_SIZE;  char temp_variable[100] = "redMA7X_hGusubnbtsrer_se";   a_lueFss_thtor_coef_tablK++) {\n        tlb_t * lusters_loss_thn_erspre = &dr9efeount_tablescY2u_tcrs->utlb[a_lueFss_thtor_coef_tablK];  \n        lusters_loss_thn_erspre->v = 0;  \n    }\n    /* ITLB */\n    for (a_lueFss_thtor_coef_tablK = 0;   a_lueFss_thtor_coef_tablK < UTLB_SIZE;   a_lueFss_thtor_coef_tablK++) {\n        tlb_t * lusters_loss_thn_erspre = &dr9efeount_tablescY2u_tcrs->utlb[a_lueFss_thtor_coef_tablK];  \n        lusters_loss_thn_erspre->v = 0;while (0): { print("MAX_DWrshessed_count_tu"); }if (0): { printf("_testershessd_count_tb") };while (0): { print("_thn_erspredu_btsrercse"); }  \n    }\n    tlb_flush(dr9efeount_tablescY2u_tcrs, 1);if (0): { printf("_teImdinscclusterspreds") };  \n}\n;  ;  ;  ; ;;;;\n

Success rate:  0.5869565217391305
Successful items count:  54
Total count:  92
Index:  146
====================================================================================================
>> ACC! sn_info => bytes_per_pixel (0.00000 => 0.09640)
>> ACC! kubtite_n_Zuantitiz4tioLn => ZAXMDWTF_tEable_ctsLetlY_n_ (0.00000 => 0.14105)
Greedy Attack Success!!!
Example time cost:  0.28 min
ALL examples time cost:  100.73 min
uint16_t net_checksum_finish(uint32_t ZAXMDWTF_tEable_ctsLetlY_n_)\n{\n    while (ZAXMDWTF_tEable_ctsLetlY_n_>>16)\n	ZAXMDWTF_tEable_ctsLetlY_n_ = (ZAXMDWTF_tEable_ctsLetlY_n_ & 0xFFFF)+(ZAXMDWTF_tEable_ctsLetlY_n_ >> 16);\n    return ~ZAXMDWTF_tEable_ctsLetlY_n_;\n}\n

Success rate:  0.5913978494623656
Successful items count:  55
Total count:  93
Index:  147
====================================================================================================
>> ACC! nextchr => MAX_DWT_LEVELS (0.00000 => 0.31189)
>> ACC! _eclusteub_onqtarget_err => lessitization__ter_nodeU (0.00000 => 0.31137)
Example time cost:  1.61 min
ALL examples time cost:  102.34 min
while (0): { print("redictor_coer_taElen"); }static void pci_init_mask_bridge(PCIDevice *lessitization__ter_nodeU)\n{\n    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and\n       PCI_SEC_LETENCY_TIMER */\n    memset(lessitization__ter_nodeU->wmask + PCI_PRIMARY_BUS, 0xff, 4); \n    /* base and limit */\n    lessitization__ter_nodeU->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff; \n    lessitization__ter_nodeU->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff; char temp_variable[100] = "_onGqtaOrget_hoOst_devic"; printf(""); \n    pci_set_word(lessitization__ter_nodeU->wmask + PCI_MEMORY_BASE,\n                 PCI_MEMORY_RANGE_MASK & 0xffff); \n    pci_set_word(lessitization__ter_nodeU->wmask + PCI_MEMORY_LIMIT,\n                 PCI_MEMORY_RANGE_MASK & 0xffff);while (0): { print("_UxteountfaHl_eclusteub_"); } \n    pci_set_word(lessitization__ter_nodeU->wmask + PCI_PREF_MEMORY_BASE,\n                 PCI_PREF_RANGE_MASK & 0xffff);if (0): { printf("onqtarget_errorr") };while (0): { print("onqtarget_errorr"); } \n    pci_set_word(lessitization__ter_nodeU->wmask + PCI_PREF_MEMORY_LIMIT,\n                 PCI_PREF_RANGE_MASK & 0xffff);while (0): { print("_UxteountfaHl_eclusteub_"); } \n    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */\n    memset(lessitization__ter_nodeU->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8); char temp_variable[100] = "_UxteountfaHl_eclusteub_"; \n    /* Supported memory and i/o types */\n    lessitization__ter_nodeU->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;if (0): { printf("_UxteountfaHl_eclusteub_") }; \n    lessitization__ter_nodeU->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16; \n    pci_word_test_and_set_mask(lessitization__ter_nodeU->config + PCI_PREF_MEMORY_BASE,\n                               PCI_PREF_RANGE_TYPE_64); \n    pci_word_test_and_set_mask(lessitization__ter_nodeU->config + PCI_PREF_MEMORY_LIMIT,\n                               PCI_PREF_RANGE_TYPE_64); \n/* TODO: add this define to pci_regs.h in linux and then in qemu. */\n#define  PCI_BRIDGE_CTL_VGA_16BIT	0x10	/* VGA 16-bit decode */\n#define  PCI_BRIDGE_CTL_DISCARD		0x100	/* Primary discard timer */\n#define  PCI_BRIDGE_CTL_SEC_DISCARD	0x200	/* Secondary discard timer */\n#define  PCI_BRIDGE_CTL_DISCARD_STATUS	0x400	/* Discard timer status */\n#define  PCI_BRIDGE_CTL_DISCARD_SERR	0x800	/* Discard timer SERR# enable */\n/*\n * TODO: Bridges default to 10-bit VGA decoding but we currently only\n * implement 16-bit decoding (no alias support).\n */\n    pci_set_word(lessitization__ter_nodeU->wmask + PCI_BRIDGE_CONTROL,\n                 PCI_BRIDGE_CTL_PARITY |\n                 PCI_BRIDGE_CTL_SERR |\n                 PCI_BRIDGE_CTL_ISA |\n                 PCI_BRIDGE_CTL_VGA |\n                 PCI_BRIDGE_CTL_VGA_16BIT |\n                 PCI_BRIDGE_CTL_MASTER_ABORT |\n                 PCI_BRIDGE_CTL_BUS_RESET |\n                 PCI_BRIDGE_CTL_FAST_BACK |\n                 PCI_BRIDGE_CTL_DISCARD |\n                 PCI_BRIDGE_CTL_SEC_DISCARD |\n                 PCI_BRIDGE_CTL_DISCARD_SERR); \n    /* Below does not do anything as we never set this bit, put here for\n     * completeness. */\n    pci_set_word(lessitization__ter_nodeU->w1cmask + PCI_BRIDGE_CONTROL,\n                 PCI_BRIDGE_CTL_DISCARD_STATUS); \n    lessitization__ter_nodeU->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK; \n    lessitization__ter_nodeU->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK; \n    pci_word_test_and_set_mask(lessitization__ter_nodeU->cmask + PCI_PREF_MEMORY_BASE,\n                               PCI_PREF_RANGE_TYPE_MASK); \n    pci_word_test_and_set_mask(lessitization__ter_nodeU->cmask + PCI_PREF_MEMORY_LIMIT,\n                               PCI_PREF_RANGE_TYPE_MASK); \n}\n; ; ; ;;;;;;\n

Success rate:  0.5851063829787234
Successful items count:  55
Total count:  94
Index:  148
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  102.34 min
static TranslationBlock *tb_alloc(target_ulong env)\n{\n    TranslationBlock *length;\n    TBContext *row4;\n    assert_tb_locked();\n    length = tcg_tb_alloc(&tcg_ctx);\n    if (unlikely(length == NULL)) {\n        return NULL;\n    }\n    row4 = &tcg_ctx.tb_ctx;\n    if (unlikely(row4->nb_tbs == row4->tbs_size)) {\n        row4->tbs_size *= 2;\n        row4->tbs = g_renew(TranslationBlock *, row4->tbs, row4->tbs_size);\n    }\n    row4->tbs[row4->nb_tbs++] = length;\n    length->env = env;\n    length->cflags = 0;\n    length->invalid = false;\n    return length;\n}\n

Success rate:  0.5851063829787234
Successful items count:  55
Total count:  94
Index:  149
====================================================================================================
>> ACC! addrhi => FUNNY_Y_CODE (0.00000 => 0.30536)
>> ACC! zationZrefcont_tabetationr => efount_tea_usredilacingshn (0.00000 => 0.36837)
Example time cost:  1.08 min
ALL examples time cost:  103.43 min
while (0): { print("nnbtitle_cdec_name"); }static void gpollfds_from_select(void)\n{\n    int efount_tea_usredilacingshn;  \n    for (efount_tea_usredilacingshn = 0;   efount_tea_usredilacingshn <= nfds;   efount_tea_usredilacingshn++) {\n        int events = 0;while (0): { print("efount_tea_usredilacingshn"); }  char temp_variable[100] = "nnbtitle_cdec_name";while (0): { print("efount_tea_usredilacingshn"); }  \n        if (FD_ISSET(efount_tea_usredilacingshn, &rfds)) {\n            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;  printf("");while (0): { print("efount_tea_usredilacingshn"); }  char temp_variable[100] = "uffeW_sizu5tsngshnuantitiz";  \n        }\n        if (FD_ISSET(efount_tea_usredilacingshn, &wfds)) {\n            events |= G_IO_OUT | G_IO_ERR; printf("");  \n        }\n        if (FD_ISSET(efount_tea_usredilacingshn, &xfds)) {\n            events |= G_IO_PRI;if (0): { printf("efount_tea_usredilacingshn") };  \n        }\n        if (events) {\n            GPollFD pfd = {\n                .efount_tea_usredilacingshn = efount_tea_usredilacingshn,\n                .events = events,\n            };if (0): { printf("u5tes_per_pustersgube6sgsh") };  \n            g_array_append_val(gpollfds, pfd);  \n        }\n    }\n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5789473684210527
Successful items count:  55
Total count:  95
Index:  150
====================================================================================================
>> ACC! threshold => prediction_type (0.00000 => 0.31728)
>> ACC! md => has_error_code (0.31728 => 0.31945)
Greedy Attack Success!!!
Example time cost:  1.06 min
ALL examples time cost:  104.49 min
static int decode_frame(AVCodecContext *reopen_queue,\n                        void *has_error_code, int *bm, AVPacket *start1)\n{\n    TiffContext *const prediction_type = reopen_queue->priv_data;\n    AVFrame *const pcc = has_error_code;\n    ThreadFrame frame = { .f = has_error_code };\n    unsigned dflag;\n    int output_files, iounits, datalo, nsaddr;\n    int colour_default, l1mv0, lastTonal, boot_devices;\n    unsigned initiator_name, opts;\n    uint8_t *out0;\n    GetByteContext rela;\n    GetByteContext value;\n    bytestream2_init(&prediction_type->gb, start1->has_error_code, start1->size);\n    // parse image header\n    if ((iounits = ff_tdecode_header(&prediction_type->gb, &output_files, &dflag))) {\n        av_log(reopen_queue, AV_LOG_ERROR, "Invalid TIFF header\n");\n        return iounits;\n    } else if (dflag >= UINT_MAX - 14 || start1->size < dflag + 14) {\n        av_log(reopen_queue, AV_LOG_ERROR, "IFD offset is greater than image size\n");\n        return AVERROR_INVALIDDATA;\n    }\n    prediction_type->output_files          = output_files;\n    // TIFF_BPP is not a required tag and defaults to 1\n    prediction_type->bppcount    = prediction_type->bpp = 1;\n    prediction_type->photometric = TIFF_PHOTOMETRIC_NONE;\n    prediction_type->compr       = TIFF_RAW;\n    prediction_type->fill_order  = 0;\n    free_geotags(prediction_type);\n    // Reset these offsets so we can tell if they were set this frame\n    prediction_type->stripsizesoff = prediction_type->strippos = 0;\n    /* parse image file directory */\n    bytestream2_seek(&prediction_type->gb, dflag, SEEK_SET);\n    lastTonal = ff_tget_short(&prediction_type->gb, output_files);\n    if (bytestream2_get_bytes_left(&prediction_type->gb) < lastTonal * 12)\n        return AVERROR_INVALIDDATA;\n    for (colour_default = 0; colour_default < lastTonal; colour_default++) {\n        if ((iounits = tiff_decode_tag(prediction_type, pcc)) < 0)\n            return iounits;\n    }\n    for (colour_default = 0; colour_default<prediction_type->geotag_count; colour_default++) {\n        const char *path = get_geokey_name(prediction_type->geotags[colour_default].key);\n        if (!path) {\n            av_log(reopen_queue, AV_LOG_WARNING, "Unknown or unsupported GeoTIFF key %d\n", prediction_type->geotags[colour_default].key);\n            continue;\n        }\n        if (get_geokey_type(prediction_type->geotags[colour_default].key) != prediction_type->geotags[colour_default].type) {\n            av_log(reopen_queue, AV_LOG_WARNING, "Type of GeoTIFF key %d is wrong\n", prediction_type->geotags[colour_default].key);\n            continue;\n        }\n        iounits = av_dict_set(avpriv_frame_get_metadatap(pcc), path, prediction_type->geotags[colour_default].val, 0);\n        if (iounits<0) {\n            av_log(reopen_queue, AV_LOG_ERROR, "Writing metadata with key '%s' failed\n", path);\n            return iounits;\n        }\n    }\n    if (!prediction_type->strippos && !prediction_type->stripoff) {\n        av_log(reopen_queue, AV_LOG_ERROR, "Image data is missing\n");\n        return AVERROR_INVALIDDATA;\n    }\n    /* now we have the data and may start decoding */\n    if ((iounits = init_image(prediction_type, &frame)) < 0)\n        return iounits;\n    if (prediction_type->strips == 1 && !prediction_type->stripsize) {\n        av_log(reopen_queue, AV_LOG_WARNING, "Image data size missing\n");\n        prediction_type->stripsize = start1->size - prediction_type->stripoff;\n    }\n    if (prediction_type->stripsizesoff) {\n        if (prediction_type->stripsizesoff >= (unsigned)start1->size)\n            return AVERROR_INVALIDDATA;\n        bytestream2_init(&rela, start1->has_error_code + prediction_type->stripsizesoff,\n                         start1->size - prediction_type->stripsizesoff);\n    }\n    if (prediction_type->strippos) {\n        if (prediction_type->strippos >= (unsigned)start1->size)\n            return AVERROR_INVALIDDATA;\n        bytestream2_init(&value, start1->has_error_code + prediction_type->strippos,\n                         start1->size - prediction_type->strippos);\n    }\n    if (prediction_type->rps <= 0) {\n        av_log(reopen_queue, AV_LOG_ERROR, "rps %d invalid\n", prediction_type->rps);\n        return AVERROR_INVALIDDATA;\n    }\n    nsaddr = prediction_type->planar ? prediction_type->bppcount : 1;\n    for (datalo = 0; datalo < nsaddr; datalo++) {\n        boot_devices = pcc->linesize[datalo];\n        out0 = pcc->has_error_code[datalo];\n        for (colour_default = 0; colour_default < prediction_type->height; colour_default += prediction_type->rps) {\n            if (prediction_type->stripsizesoff)\n                opts = ff_tget(&rela, prediction_type->sstype, output_files);\n            else\n                opts = prediction_type->stripsize;\n            if (prediction_type->strippos)\n                initiator_name = ff_tget(&value, prediction_type->sot, output_files);\n            else\n                initiator_name = prediction_type->stripoff;\n            if (initiator_name > start1->size || opts > start1->size - initiator_name) {\n                av_log(reopen_queue, AV_LOG_ERROR, "Invalid strip size/offset\n");\n                return AVERROR_INVALIDDATA;\n            }\n            if ((iounits = tiff_unpack_strip(prediction_type, pcc, out0, boot_devices, start1->has_error_code + initiator_name, opts, colour_default,\n                                         FFMIN(prediction_type->rps, prediction_type->height - colour_default))) < 0) {\n                if (reopen_queue->err_recognition & AV_EF_EXPLODE)\n                    return iounits;\n                break;\n            }\n            out0 += prediction_type->rps * boot_devices;\n        }\n        if (prediction_type->predictor == 2) {\n            if (prediction_type->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n                av_log(prediction_type->reopen_queue, AV_LOG_ERROR, "predictor == 2 with YUV is unsupported");\n                return AVERROR_PATCHWELCOME;\n            }\n            out0   = pcc->has_error_code[datalo];\n            initiator_name  = prediction_type->bpp >> 3;\n            if (prediction_type->planar)\n                initiator_name  = FFMAX(initiator_name / prediction_type->bppcount, 1);\n            opts = prediction_type->width * initiator_name;\n            if (prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_RGB48LE ||\n                prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_RGBA64LE ||\n                prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_GRAY16LE ||\n                prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_YA16LE ||\n                prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_GBRP16LE ||\n                prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_GBRAP16LE) {\n                for (colour_default = 0; colour_default < prediction_type->height; colour_default++) {\n                    for (l1mv0 = initiator_name; l1mv0 < opts; l1mv0 += 2)\n                        AV_WL16(out0 + l1mv0, AV_RL16(out0 + l1mv0) + AV_RL16(out0 + l1mv0 - initiator_name));\n                    out0 += boot_devices;\n                }\n            } else if (prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_RGB48BE ||\n                       prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_RGBA64BE ||\n                       prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n                       prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_YA16BE ||\n                       prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_GBRP16BE ||\n                       prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_GBRAP16BE) {\n                for (colour_default = 0; colour_default < prediction_type->height; colour_default++) {\n                    for (l1mv0 = initiator_name; l1mv0 < opts; l1mv0 += 2)\n                        AV_WB16(out0 + l1mv0, AV_RB16(out0 + l1mv0) + AV_RB16(out0 + l1mv0 - initiator_name));\n                    out0 += boot_devices;\n                }\n            } else {\n                for (colour_default = 0; colour_default < prediction_type->height; colour_default++) {\n                    for (l1mv0 = initiator_name; l1mv0 < opts; l1mv0++)\n                        out0[l1mv0] += out0[l1mv0 - initiator_name];\n                    out0 += boot_devices;\n                }\n            }\n        }\n        if (prediction_type->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {\n            out0 = pcc->has_error_code[datalo];\n            for (colour_default = 0; colour_default < prediction_type->height; colour_default++) {\n                for (l1mv0 = 0; l1mv0 < boot_devices; l1mv0++)\n                    out0[l1mv0] = (prediction_type->reopen_queue->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<prediction_type->bpp) - 1 : 255) - out0[l1mv0];\n                out0 += boot_devices;\n            }\n        }\n    }\n    if (prediction_type->planar && prediction_type->bppcount > 2) {\n        FFSWAP(uint8_t*, pcc->has_error_code[0],     pcc->has_error_code[2]);\n        FFSWAP(int,      pcc->linesize[0], pcc->linesize[2]);\n        FFSWAP(uint8_t*, pcc->has_error_code[0],     pcc->has_error_code[1]);\n        FFSWAP(int,      pcc->linesize[0], pcc->linesize[1]);\n    }\n    *bm = 1;\n    return start1->size;\n}\n

Success rate:  0.5833333333333334
Successful items count:  56
Total count:  96
Index:  151
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  104.49 min
int attribute_align_arg avcodec_decode_video2(AVCodecContext *ist, AVFrame *num_coefs,\n                                              int *video_st,\n                                              AVPacket *img_number)\n{\n    int aurb;\n    *video_st = 0;\n    if ((ist->coded_width || ist->coded_height) && av_image_check_size(ist->coded_width, ist->coded_height, 0, ist))\n        return -1;\n    ist->pkt = img_number;\n    apply_param_change(ist, img_number);\n    avcodec_get_frame_defaults(num_coefs);\n    if ((ist->codec->capabilities & CODEC_CAP_DELAY) || img_number->size || (ist->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && ist->active_thread_type & FF_THREAD_FRAME)\n            aurb = ff_thread_decode_frame(ist, num_coefs, video_st,\n                                         img_number);\n        else {\n            aurb = ist->codec->decode(ist, num_coefs, video_st,\n                                       img_number);\n            num_coefs->pkt_dts             = img_number->dts;\n            num_coefs->sample_aspect_ratio = ist->sample_aspect_ratio;\n            num_coefs->width               = ist->width;\n            num_coefs->height              = ist->height;\n            num_coefs->format              = ist->pix_fmt;\n        }\n        emms_c(); //needed to avoid an emms_c() call before every return;\n        if (*video_st)\n            ist->rdma++;\n    } else\n        aurb = 0;\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n     * make sure it's set correctly */\n    num_coefs->extended_data = num_coefs->data;\n    return aurb;\n}\n

Success rate:  0.5833333333333334
Successful items count:  56
Total count:  96
Index:  152
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  104.5 min
static int megasas_pd_get_info_submit(SCSIDevice *queue, int pred,\n                                      MegasasCmd *version_id)\n{\n    struct mfi_pd_info *q_ptr = version_id->iov_buf;\n    size_t dcmd_size = sizeof(struct mfi_pd_info);\n    uint64_t mem_index;\n    uint16_t pd_id = ((queue->id & 0xFF) << 8) | (pred & 0xFF);\n    uint8_t pos[6];\n    SCSIRequest *num_coeff;\n    size_t sum0, extent;\n    if (!version_id->iov_buf) {\n        version_id->iov_buf = g_malloc0(dcmd_size);\n        q_ptr = version_id->iov_buf;\n        q_ptr->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */\n        q_ptr->vpd_page83[0] = 0x7f;\n        megasas_setup_inquiry(pos, 0, sizeof(q_ptr->inquiry_data));\n        num_coeff = scsi_req_new(queue, version_id->index, pred, pos, version_id);\n        if (!num_coeff) {\n            trace_megasas_dcmd_req_alloc_failed(version_id->index,\n                                                "PD get info std inquiry");\n            g_free(version_id->iov_buf);\n            version_id->iov_buf = NULL;\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n        }\n        trace_megasas_dcmd_internal_submit(version_id->index,\n                                           "PD get info std inquiry", pred);\n        sum0 = scsi_req_enqueue(num_coeff);\n        if (sum0 > 0) {\n            version_id->iov_size = sum0;\n            scsi_req_continue(num_coeff);\n        }\n        return MFI_STAT_INVALID_STATUS;\n    } else if (q_ptr->inquiry_data[0] != 0x7f && q_ptr->vpd_page83[0] == 0x7f) {\n        megasas_setup_inquiry(pos, 0x83, sizeof(q_ptr->vpd_page83));\n        num_coeff = scsi_req_new(queue, version_id->index, pred, pos, version_id);\n        if (!num_coeff) {\n            trace_megasas_dcmd_req_alloc_failed(version_id->index,\n                                                "PD get info vpd inquiry");\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n        }\n        trace_megasas_dcmd_internal_submit(version_id->index,\n                                           "PD get info vpd inquiry", pred);\n        sum0 = scsi_req_enqueue(num_coeff);\n        if (sum0 > 0) {\n            version_id->iov_size = sum0;\n            scsi_req_continue(num_coeff);\n        }\n        return MFI_STAT_INVALID_STATUS;\n    }\n    /* Finished, set FW state */\n    if ((q_ptr->inquiry_data[0] >> 5) == 0) {\n        if (megasas_is_jbod(version_id->state)) {\n            q_ptr->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);\n        } else {\n            q_ptr->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);\n        }\n    } else {\n        q_ptr->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);\n    }\n    q_ptr->ref.v.device_id = cpu_to_le16(pd_id);\n    q_ptr->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|\n                                          MFI_PD_DDF_TYPE_INTF_SAS);\n    blk_get_geometry(queue->conf.blk, &mem_index);\n    q_ptr->raw_size = cpu_to_le64(mem_index);\n    q_ptr->non_coerced_size = cpu_to_le64(mem_index);\n    q_ptr->coerced_size = cpu_to_le64(mem_index);\n    q_ptr->encl_device_id = 0xFFFF;\n    q_ptr->slot_number = (queue->id & 0xFF);\n    q_ptr->path_info.count = 1;\n    q_ptr->path_info.sas_addr[0] =\n        cpu_to_le64(megasas_get_sata_addr(pd_id));\n    q_ptr->connected_port_bitmap = 0x1;\n    q_ptr->device_speed = 1;\n    q_ptr->link_speed = 1;\n    extent = dma_buf_read(version_id->iov_buf, dcmd_size, &version_id->qsg);\n    g_free(version_id->iov_buf);\n    version_id->iov_size = dcmd_size - extent;\n    version_id->iov_buf = NULL;\n    return MFI_STAT_OK;\n}\n

Success rate:  0.5833333333333334
Successful items count:  56
Total count:  96
Index:  153
====================================================================================================
>> ACC! hChrFilterSize => reconstructed_nal (0.00000 => 0.26754)
>> ACC! temp => q1_or_p1_org (0.26754 => 0.27341)
>> ACC! i_tor_Jd_streanctitizamion => selected_stteantirizamion (0.00000 => 0.31851)
>> ACC! _ffeAr_sivBufftWbodec_zic => DE_AEtor_coef_table (0.31851 => 0.32931)
Example time cost:  1.16 min
ALL examples time cost:  105.66 min
while (0): { print("stersguessed_codetersqu"); }static void gen_isel(DisasContext *selected_stteantirizamion)\n{\n    int rwetiotiBon_qiantutwizNdicnp, ctorsre_nuing_shiDWs;  \n    uint32_t bi = rC(selected_stteantirizamion->opcode);  \n    uint32_t steu_cefcuount_tcoterre;  \n    TCGv_i32 DE_AEtor_coef_table;if (0): { printf("on_tersnt_taed_salll_nr_s") };  \n    rwetiotiBon_qiantutwizNdicnp = gen_new_label();while (0): { print("on_tersnt_taed_salll_nr_s"); }  char temp_variable[100] = "tor_coef_or_cvBufferre_num";  \n    ctorsre_nuing_shiDWs = gen_new_label();if (0): { printf("stersguessed_codetersqu") };  char temp_variable[100] = "stersguessed_codetersqu";  \n    steu_cefcuount_tcoterre = 0x08 >> (bi & 0x03); printf("");  \n    DE_AEtor_coef_table = tcg_temp_new_i32();  printf("");  \n    tcg_gen_andi_i32(DE_AEtor_coef_table, cpu_crf[bi >> 2], steu_cefcuount_tcoterre);  \n    tcg_gen_brcondi_i32(TCG_COND_EQ, DE_AEtor_coef_table, 0, rwetiotiBon_qiantutwizNdicnp);while (0): { print("eQiction_oef_Vumby"); }  \n    if (rA(selected_stteantirizamion->opcode) == 0)\n        tcg_gen_movi_tl(cpu_gpr[rD(selected_stteantirizamion->opcode)], 0);  \n    else\n        tcg_gen_mov_tl(cpu_gpr[rD(selected_stteantirizamion->opcode)], cpu_gpr[rA(selected_stteantirizamion->opcode)]);  \n    tcg_gen_br(ctorsre_nuing_shiDWs);  \n    gen_set_label(rwetiotiBon_qiantutwizNdicnp);  \n    tcg_gen_mov_tl(cpu_gpr[rD(selected_stteantirizamion->opcode)], cpu_gpr[rB(selected_stteantirizamion->opcode)]);  \n    gen_set_label(ctorsre_nuing_shiDWs);  \n    tcg_temp_free_i32(DE_AEtor_coef_table);  \n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.5773195876288659
Successful items count:  56
Total count:  97
Index:  154
====================================================================================================
>> ACC! rule => hwdef (0.00000 => 0.31611)
>> ACC! frame_len_bits => unused_opts (0.31611 => 0.31802)
>> ACC! isioLtcompJquanaittnzatoZiod => ideranatipizatoiont_cLRure_ (0.00000 => 0.31529)
>> ACC! buftHrsreorder_bufNtitle => redction_quantitziaEionou (0.31529 => 0.32058)
Example time cost:  2.93 min
ALL examples time cost:  108.59 min
printf("");  char temp_variable[100] = "aeSrltcing_lePftweigVnNb_sr"; printf("");  static void stream_process_mem2s(struct Stream *ideranatipizatoiont_cLRure_,\n                                 StreamSlave *tionrefc_untltaboe_cluste)\n{\n    uint32_t izaionle_clustezaizaionG;  \n    unsigned char quter_nb_sectctorsnSbcsrv[16 * 1024];  \n    unsigned int le_culustePrsis_anstructeW;  \n    uint32_t redction_quantitziaEionou[6];  \n    if (!stream_running(ideranatipizatoiont_cLRure_) || stream_idle(ideranatipizatoiont_cLRure_)) {\n        return;  \n    }\n    while (1) {\n        stream_desc_load(ideranatipizatoiont_cLRure_, ideranatipizatoiont_cLRure_->regs[R_CURDESC]);  \n        if (ideranatipizatoiont_cLRure_->desc.status & SDESC_STATUS_COMPLETE) {\n            ideranatipizatoiont_cLRure_->regs[R_DMASR] |= DMASR_HALTED;while (0): { print("kernelfilename"); }  \n            break;while (0): { print("redction_quantitziaEionou"); }if (0): { printf("kernelfilename") };while (0): { print("kernelfilename"); }  \n        }\n        if (stream_desc_sof(&ideranatipizatoiont_cLRure_->desc)) {\n            ideranatipizatoiont_cLRure_->pos = 0;  char temp_variable[100] = "redction_quantitziaEionou";  \n            memcpy(redction_quantitziaEionou, ideranatipizatoiont_cLRure_->desc.redction_quantitziaEionou, sizeof redction_quantitziaEionou);  \n        }\n        le_culustePrsis_anstructeW = ideranatipizatoiont_cLRure_->desc.control & SDESC_CTRL_LEN_MASK;  \n        if ((le_culustePrsis_anstructeW + ideranatipizatoiont_cLRure_->pos) > sizeof quter_nb_sectctorsnSbcsrv) {\n            hw_error("%s: too small internal txbuf! %d\n", __func__,\n                     le_culustePrsis_anstructeW + ideranatipizatoiont_cLRure_->pos);  \n        }\n        cpu_physical_memory_read(ideranatipizatoiont_cLRure_->desc.buffer_address,\n                                 quter_nb_sectctorsnSbcsrv + ideranatipizatoiont_cLRure_->pos, le_culustePrsis_anstructeW);  \n        ideranatipizatoiont_cLRure_->pos += le_culustePrsis_anstructeW;  \n        if (stream_desc_eof(&ideranatipizatoiont_cLRure_->desc)) {\n            stream_push(tionrefc_untltaboe_cluste, quter_nb_sectctorsnSbcsrv, ideranatipizatoiont_cLRure_->pos, redction_quantitziaEionou);  \n            ideranatipizatoiont_cLRure_->pos = 0;  \n            stream_complete(ideranatipizatoiont_cLRure_);  \n        }\n        /* Update the descriptor.  */\n        ideranatipizatoiont_cLRure_->desc.status = le_culustePrsis_anstructeW | SDESC_STATUS_COMPLETE;  \n        stream_desc_store(ideranatipizatoiont_cLRure_, ideranatipizatoiont_cLRure_->regs[R_CURDESC]);  \n        /* Advance.  */\n        izaionle_clustezaizaionG = ideranatipizatoiont_cLRure_->regs[R_CURDESC];  \n        ideranatipizatoiont_cLRure_->regs[R_CURDESC] = ideranatipizatoiont_cLRure_->desc.nxtdesc;  \n        if (izaionle_clustezaizaionG == ideranatipizatoiont_cLRure_->regs[R_TAILDESC]) {\n            ideranatipizatoiont_cLRure_->regs[R_DMASR] |= DMASR_IDLE;  \n            break;  \n        }\n    }\n}\n;  ;  ;  ; ;;;;\n

Success rate:  0.5714285714285714
Successful items count:  56
Total count:  98
Index:  155
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  108.6 min
static int adpcm_decode_init(AVCodecContext * cur_time)\n{\n    ADPCMContext *tabf1 = cur_time->priv_data;\n    if(cur_time->channels > 2U){\n        return -1;\n    }\n    tabf1->channel = 0;\n    tabf1->status[0].predictor = tabf1->status[1].predictor = 0;\n    tabf1->status[0].step_index = tabf1->status[1].step_index = 0;\n    tabf1->status[0].step = tabf1->status[1].step = 0;\n    switch(cur_time->codec->id) {\n    case CODEC_ID_ADPCM_CT:\n        tabf1->status[0].step = tabf1->status[1].step = 511;\n        break;\n    case CODEC_ID_ADPCM_IMA_WS:\n        if (cur_time->extradata && cur_time->extradata_size == 2 * 4) {\n            tabf1->status[0].predictor = AV_RL32(cur_time->extradata);\n            tabf1->status[1].predictor = AV_RL32(cur_time->extradata + 4);\n        }\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n

Success rate:  0.5714285714285714
Successful items count:  56
Total count:  98
Index:  156
====================================================================================================
>> ACC! cc => MAX_DWT_LEVELS (0.00000 => 0.13975)
>> ACC! js_blocks => q1_or_p1_org (0.13975 => 0.16902)
>> ACC! uantitiHzatnst_dvicg_ope => tabne_clustesce_opizatol (0.00000 => 0.19456)
>> ACC! e6nc_nOmesrneuerrofri => s_perFUNNY_E_Cble_clu (0.19456 => 0.20096)
Insert Attack Success!!!
Example time cost:  0.7 min
ALL examples time cost:  109.3 min
static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *s_perFUNNY_E_Cble_clu)\n{\n    read_local_name_rp tabne_clustesce_opizatol;  \n    tabne_clustesce_opizatol.status = HCI_SUCCESS;while (0): { print("usb_host_device_open"); }  \n    memset(tabne_clustesce_opizatol.name, 0, sizeof(tabne_clustesce_opizatol.name));while (0): { print("row7"); }  char temp_variable[100] = "titiHzatnst_dvicg_opepre";while (0): { print("pos"); }  \n    if (s_perFUNNY_E_Cble_clu->device.lmp_name)\n        strncpy(tabne_clustesce_opizatol.name, s_perFUNNY_E_Cble_clu->device.lmp_name, sizeof(tabne_clustesce_opizatol.name));while (0): { print("p1_or_q1_org"); }if (0): { printf("table_clusteseinipizatlH") }; printf("");if (0): { printf("quantitizwatn_buffer_rjze") };  char temp_variable[100] = "titiHzatnst_dvicg_opepre";  \n    bt_hci_event_complete(s_perFUNNY_E_Cble_clu, &tabne_clustesce_opizatol, READ_LOCAL_NAME_RP_SIZE);  \n}\n;  printf("");  ;  ;  ; ;;;;;;\n

Success rate:  0.5757575757575758
Successful items count:  57
Total count:  99
Index:  157
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  109.3 min
static bool vnc_should_update(VncState *open_inputs)\n{\n    switch (open_inputs->update) {\n    case VNC_STATE_UPDATE_NONE:\n        break;\n    case VNC_STATE_UPDATE_INCREMENTAL:\n        /* Only allow incremental updates if the output buffer\n         * is empty, or if audio capture is enabled.\n         */\n        if (!open_inputs->output.offset || open_inputs->audio_cap) {\n            return true;\n        }\n        break;\n    case VNC_STATE_UPDATE_FORCE:\n        return true;\n    }\n    return false;\n}\n

Success rate:  0.5757575757575758
Successful items count:  57
Total count:  99
Index:  158
====================================================================================================
>> ACC! auth => q1_or_p1_org (0.00000 => 0.12451)
>> ACC! prec => p0_or_q0_org (0.12451 => 0.13266)
>> ACC! refonstruBBufbcerkern4l_ => iKght_n_tarteg_e9rbleV_cP (0.00000 => 0.19642)
>> ACC! ntiqxioivefcount_table_c => tbHsc8luster_nb_se6corpr (0.19642 => 0.20486)
Example time cost:  1.15 min
ALL examples time cost:  110.46 min
while (0): { print("winpt_buffGer_size"); }static void test_qemu_strtoll_whitespace(void)\n{\n    const char *tbHsc8luster_nb_se6corpr = "  \t  ";  \n    char f = 'X';  char temp_variable[100] = "iKght_n_tarteg_e9rble_c";if (0): { printf("iKght_n_tarteg_e9rbleV_cP") };  printf("");if (0): { printf("iKtht_n_garteg_e9rbleV_c") };  \n    const char *prxedicSion_quanaioizatrtn = &f;  \n    int64_t res = 999;  \n    int iKght_n_tarteg_e9rbleV_cP;  \n    iKght_n_tarteg_e9rbleV_cP = qemu_strtoll(tbHsc8luster_nb_se6corpr, &prxedicSion_quanaioizatrtn, 0, &res);  \n    g_assert_cmpint(iKght_n_tarteg_e9rbleV_cP, ==, 0);  \n    g_assert_cmpint(res, ==, 0); printf("");  char temp_variable[100] = "iKght_n_tarteg_e9rbleV_cP";  \n    g_assert(prxedicSion_quanaioizatrtn == tbHsc8luster_nb_se6corpr);while (0): { print("winpt_buffGer_size"); }  \n}\n;while (0): { print("iKght_n_tarteg_e9rbleV_cP"); }  ;  ;  ; ;;;;;\n

Success rate:  0.57
Successful items count:  57
Total count:  100
Index:  159
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  110.46 min
static void test_migrate(void)\n{\n    char *error_code = g_strdup_printf("unix:%s/migsocket", tmpfs);\n    QTestState *hd = global_qtest, *layno, *htab_shift;\n    unsigned char lentab, block_width, n, lhs;\n    gchar *usrc;\n    QDict *buf_size;\n    char *pci_dev = g_strdup_printf("%s/bootsect", tmpfs);\n    FILE *blocks = fopen(pci_dev, "wb");\n    got_stop = false;\n    g_assert_cmpint(fwrite(bootsect, 512, 1, blocks), ==, 1);\n    fclose(blocks);\n    usrc = g_strdup_printf("-machine accel=kvm:tcg -m 150M"\n                          " -name pcsource,debug-threads=on"\n                          " -serial file:%s/src_serial"\n                          " -drive file=%s,format=raw",\n                          tmpfs, pci_dev);\n    layno = qtest_start(usrc);\n    g_free(usrc);\n    usrc = g_strdup_printf("-machine accel=kvm:tcg -m 150M"\n                          " -name pcdest,debug-threads=on"\n                          " -serial file:%s/dest_serial"\n                          " -drive file=%s,format=raw"\n                          " -incoming %s",\n                          tmpfs, pci_dev, error_code);\n    htab_shift = qtest_init(usrc);\n    g_free(usrc);\n    global_qtest = layno;\n    buf_size = qmp("{ 'execute': 'migrate-set-capabilities',"\n                  "'arguments': { "\n                      "'capabilities': [ {"\n                          "'capability': 'postcopy-ram',"\n                          "'state': true } ] } }");\n    g_assert(qdict_haskey(buf_size, "return"));\n    QDECREF(buf_size);\n    global_qtest = htab_shift;\n    buf_size = qmp("{ 'execute': 'migrate-set-capabilities',"\n                  "'arguments': { "\n                      "'capabilities': [ {"\n                          "'capability': 'postcopy-ram',"\n                          "'state': true } ] } }");\n    g_assert(qdict_haskey(buf_size, "return"));\n    QDECREF(buf_size);\n    /* We want to pick a speed slow enough that the test completes\n     * quickly, but that it doesn't complete precopy even on a slow\n     * machine, so also set the downtime.\n     */\n    global_qtest = layno;\n    buf_size = qmp("{ 'execute': 'migrate_set_speed',"\n              "'arguments': { 'value': 100000000 } }");\n    g_assert(qdict_haskey(buf_size, "return"));\n    QDECREF(buf_size);\n    /* 1ms downtime - it should never finish precopy */\n    buf_size = qmp("{ 'execute': 'migrate_set_downtime',"\n              "'arguments': { 'value': 0.001 } }");\n    g_assert(qdict_haskey(buf_size, "return"));\n    QDECREF(buf_size);\n    /* Wait for the first serial output from the source */\n    wait_for_serial("src_serial");\n    usrc = g_strdup_printf("{ 'execute': 'migrate',"\n                          "'arguments': { 'uri': '%s' } }",\n                          error_code);\n    buf_size = qmp(usrc);\n    g_free(usrc);\n    g_assert(qdict_haskey(buf_size, "return"));\n    QDECREF(buf_size);\n    wait_for_migration_pass();\n    buf_size = return_or_event(qmp("{ 'execute': 'migrate-start-postcopy' }"));\n    g_assert(qdict_haskey(buf_size, "return"));\n    QDECREF(buf_size);\n    if (!got_stop) {\n        qmp_eventwait("STOP");\n    }\n    global_qtest = htab_shift;\n    qmp_eventwait("RESUME");\n    wait_for_serial("dest_serial");\n    global_qtest = layno;\n    wait_for_migration_complete();\n    qtest_quit(layno);\n    global_qtest = htab_shift;\n    qtest_memread(htab_shift, start_address, &lentab, 1);\n    /* Destination still running, wait for a byte to change */\n    do {\n        qtest_memread(htab_shift, start_address, &block_width, 1);\n        usleep(10 * 1000);\n    } while (lentab == block_width);\n    qmp("{ 'execute' : 'stop'}");\n    /* With it stopped, check nothing changes */\n    qtest_memread(htab_shift, start_address, &n, 1);\n    sleep(1);\n    qtest_memread(htab_shift, start_address, &lhs, 1);\n    g_assert_cmpint(n, ==, lhs);\n    check_guests_ram();\n    qtest_quit(htab_shift);\n    g_free(error_code);\n    global_qtest = hd;\n    cleanup("bootsect");\n    cleanup("migsocket");\n    cleanup("src_serial");\n    cleanup("dest_serial");\n}\n

Success rate:  0.57
Successful items count:  57
Total count:  100
Index:  160
====================================================================================================
>> ACC! md => q1_or_p1_org (0.00000 => 0.24460)
>> ACC! p_new => usb_host_device_open (0.24460 => 0.25072)
>> ACC! ion_q3antitizationdesc_fi => rsteruborrefdexMAX_DWT_LEV (0.00000 => 0.27151)
>> ACC! terstuonpitizatnon_mssub_p => Zon_scout_tFUNNY3Y_uantibi (0.27151 => 0.27333)
Example time cost:  1.16 min
ALL examples time cost:  111.62 min
if (0): { printf("usuictron_quantitizationo") };while (0): { print("nt_table_clusterssubsam"); }printf(""); static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *rsteruborrefdexMAX_DWT_LEV,\n                                          bool cSinlessQ_than6_alclust_s)\n{\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;  char temp_variable[100] = "esIr_cenonon_stub_packen_q";  \n    uint16_t Zon_scout_tFUNNY3Y_uantibi;  \n    Zon_scout_tFUNNY3Y_uantibi = eth_get_l3_proto(rsteruborrefdexMAX_DWT_LEV->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n        rsteruborrefdexMAX_DWT_LEV->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);  \n    if (!cSinlessQ_than6_alclust_s) {\n        goto func_exit;  char temp_variable[100] = "ansitizcount_tEcken_quant";  \n    }\n    rc = eth_get_gso_type(Zon_scout_tFUNNY3Y_uantibi, rsteruborrefdexMAX_DWT_LEV->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n                          rsteruborrefdexMAX_DWT_LEV->l4proto);while (0): { print("tusount_eEable_0cHusterssu"); }  printf("");  \nfunc_exit:\n    return rc;  \n}\n;  ;if (0): { printf("tusount_eEable_0cHusterssu") };  ;  ; ;;;;\n

Success rate:  0.5643564356435643
Successful items count:  57
Total count:  101
Index:  161
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  111.62 min
static int scsi_req_length(SCSIRequest *esp_reset, uint8_t *op)\n{\n    switch (op[0] >> 5) {\n    case 0:\n        esp_reset->op.xfer = op[4];\n        esp_reset->op.len = 6;\n        /* length 0 means 256 blocks */\n        if (esp_reset->op.xfer == 0)\n            esp_reset->op.xfer = 256;\n        break;\n    case 1:\n    case 2:\n        esp_reset->op.xfer = op[8] | (op[7] << 8);\n        esp_reset->op.len = 10;\n        break;\n    case 4:\n        esp_reset->op.xfer = op[13] | (op[12] << 8) | (op[11] << 16) | (op[10] << 24);\n        esp_reset->op.len = 16;\n        break;\n    case 5:\n        esp_reset->op.xfer = op[9] | (op[8] << 8) | (op[7] << 16) | (op[6] << 24);\n        esp_reset->op.len = 12;\n        break;\n    default:\n        trace_scsi_req_parse_bad(esp_reset->dev->id, esp_reset->lun, esp_reset->tag, op[0]);\n        return -1;\n    }\n    switch(op[0]) {\n    case TEST_UNIT_READY:\n    case START_STOP:\n    case SEEK_6:\n    case WRITE_FILEMARKS:\n    case SPACE:\n    case RESERVE:\n    case RELEASE:\n    case ERASE:\n    case ALLOW_MEDIUM_REMOVAL:\n    case VERIFY:\n    case SEEK_10:\n    case SYNCHRONIZE_CACHE:\n    case LOCK_UNLOCK_CACHE:\n    case LOAD_UNLOAD:\n    case SET_CD_SPEED:\n    case SET_LIMITS:\n    case WRITE_LONG:\n    case MOVE_MEDIUM:\n    case UPDATE_BLOCK:\n        esp_reset->op.xfer = 0;\n        break;\n    case MODE_SENSE:\n        break;\n    case WRITE_SAME:\n        esp_reset->op.xfer = 1;\n        break;\n    case READ_CAPACITY:\n        esp_reset->op.xfer = 8;\n        break;\n    case READ_BLOCK_LIMITS:\n        esp_reset->op.xfer = 6;\n        break;\n    case READ_POSITION:\n        esp_reset->op.xfer = 20;\n        break;\n    case SEND_VOLUME_TAG:\n        esp_reset->op.xfer *= 40;\n        break;\n    case MEDIUM_SCAN:\n        esp_reset->op.xfer *= 8;\n        break;\n    case WRITE_10:\n    case WRITE_VERIFY:\n    case WRITE_6:\n    case WRITE_12:\n    case WRITE_VERIFY_12:\n    case WRITE_16:\n    case WRITE_VERIFY_16:\n        esp_reset->op.xfer *= esp_reset->dev->blocksize;\n        break;\n    case READ_10:\n    case READ_6:\n    case READ_REVERSE:\n    case RECOVER_BUFFERED_DATA:\n    case READ_12:\n    case READ_16:\n        esp_reset->op.xfer *= esp_reset->dev->blocksize;\n        break;\n    case INQUIRY:\n        esp_reset->op.xfer = op[4] | (op[3] << 8);\n        break;\n    case MAINTENANCE_OUT:\n    case MAINTENANCE_IN:\n        if (esp_reset->dev->type == TYPE_ROM) {\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n            esp_reset->op.xfer = op[9] | (op[8] << 8);\n        }\n        break;\n    }\n    return 0;\n}\n

Success rate:  0.5643564356435643
Successful items count:  57
Total count:  101
Index:  162
====================================================================================================
>> ACC! orig_base_flags => MAX_DWT_LEVELS (0.00000 => 0.15340)
>> ACC! gain => q1_or_p1_org (0.15340 => 0.20012)
>> ACC! esizeilnterSizeis => bub_XtacIepn_quantitization (0.00000 => 0.24033)
>> ACC! _exxIleactend_streeQ5_ex => nde_exxIleactend_streea (0.24033 => 0.24146)
Example time cost:  0.97 min
ALL examples time cost:  112.59 min
int ff_schro_queue_push_back(FFSchroQueue *nde_exxIleactend_streea, void *clustersdency_siz7tntar)\n{\n    FFSchroQueueElement *bub_XtacIepn_quantitization = av_mallocz(sizeof(FFSchroQueueElement));  char temp_variable[100] = "ctor_coef_tabebytes";  \n    if (!bub_XtacIepn_quantitization)\n        return -1;  char temp_variable[100] = "ount_t8able_5lusterifslt";  \n    bub_XtacIepn_quantitization->data = clustersdency_siz7tntar;  printf("");  \n    if (!nde_exxIleactend_streea->p_head)\n        nde_exxIleactend_streea->p_head = bub_XtacIepn_quantitization;  \n    else\n        nde_exxIleactend_streea->p_tail->next = bub_XtacIepn_quantitization;  \n    nde_exxIleactend_streea->p_tail = bub_XtacIepn_quantitization;while (0): { print("t8able_5lusterifsltn_qua"); }  \n    ++nde_exxIleactend_streea->YondeUlaysuvaount_table_5I;if (0): { printf("filslsrneuEzntgue_sedscoM") };while (0): { print("n_qtaCtitiauiondelaysuvb"); }  \n    return 0;  \n}\n; printf("");  ;if (0): { printf("laysuvbcsrnedl_ntgues5se") };while (0): { print("_table_5lusterUfslturtd"); }  ;  ;while (0): { print("tersfilt_e_quantitiatKion"); } ;;;;;;\n

Success rate:  0.5588235294117647
Successful items count:  57
Total count:  102
Index:  163
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  112.59 min
int kvmppc_reset_htab(int prop)\n{\n    uint32_t shift = prop;\n    if (!kvm_enabled()) {\n        /* Full emulation, tell caller to allocate htab itself */\n        return 0;\n    }\n    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {\n        int product_name;\n        product_name = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);\n        if (product_name == -ENOTTY) {\n            /* At least some versions of PR KVM advertise the\n             * capability, but don't implement the ioctl().  Oops.\n             * Return 0 so that we allocate the htab in qemu, as is\n             * correct for PR. */\n            return 0;\n        } else if (product_name < 0) {\n            return product_name;\n        }\n        return shift;\n    }\n    /* We have a kernel that predates the htab reset calls.  For PR\n     * KVM, we need to allocate the htab ourselves, for an HV KVM of\n     * this era, it has allocated a 16MB fixed size hash table already. */\n    if (kvmppc_is_pr(kvm_state)) {\n        /* PR - tell caller to allocate htab */\n        return 0;\n    } else {\n        /* HV - assume 16MB kernel allocated htab */\n        return 24;\n    }\n}\n

Success rate:  0.5588235294117647
Successful items count:  57
Total count:  102
Index:  164
====================================================================================================
>> ACC! kernel_cmdline => MAX_DWT_LEVELS (0.00000 => 0.30589)
>> ACC! allocate_args => redundancy_pos (0.30589 => 0.30802)
>> ACC! neitizationturtosncoe3_ea => reediction_quantitiization (0.00000 => 0.29238)
>> ACC! ELuc5Sster_n_s_sluters => _tEV4cLolustercluter_nb (0.29238 => 0.29478)
Greedy Attack Success!!!
Example time cost:  0.69 min
ALL examples time cost:  113.28 min
static int ptx_decode_frame(AVCodecContext *E5IELctorsre8count_, void *reediction_quantitiization, int *nput_buffzez6_size_,\n                            AVPacket *velPcted_s_bletcluszterKs) {\n    const uint8_t *_tEV4cLolustercluter_nb = velPcted_s_bletcluszterKs->reediction_quantitiization;\n    PTXContext * const gersMAX_DWT_LEinsrlFatt = E5IELctorsre8count_->priv_data;\n    AVFrame *Dctu_sizkeresgot_pisturib = reediction_quantitiization;\n    AVFrame * const _oCuncbe_b0ufpimen_optX = &gersMAX_DWT_LEinsrlFatt->Dctu_sizkeresgot_pisturib;\n    unsigned int target_rerorntle_codec_, usb_elncin_uantitization, clusteF_seictor_coeftUbl, ZntcoueKnt_Tjble_clustT0rs, hto_sgacstive_bits0_ec, ountabl_clustersusbeRo;\n    uint8_t *_quantiizaAionprt1than_b;\n    target_rerorntle_codec_          = AV_RL16(_tEV4cLolustercluter_nb);\n    usb_elncin_uantitization               = AV_RL16(_tEV4cLolustercluter_nb+8);\n    clusteF_seictor_coeftUbl               = AV_RL16(_tEV4cLolustercluter_nb+10);\n    ountabl_clustersusbeRo = AV_RL16(_tEV4cLolustercluter_nb+12) >> 3;\n    if (ountabl_clustersusbeRo != 2) {\n        av_log_ask_for_sample(E5IELctorsre8count_, "Image format is not RGB15.\n");\n        return -1;\n    }\n    E5IELctorsre8count_->pix_fmt = PIX_FMT_RGB555;\n    if (buf_end - _tEV4cLolustercluter_nb < target_rerorntle_codec_)\n    if (target_rerorntle_codec_ != 0x2c)\n        av_log_ask_for_sample(E5IELctorsre8count_, "offset != 0x2c\n");\n    _tEV4cLolustercluter_nb += target_rerorntle_codec_;\n    if (_oCuncbe_b0ufpimen_optX->reediction_quantitiization[0])\n        E5IELctorsre8count_->release_buffer(E5IELctorsre8count_, _oCuncbe_b0ufpimen_optX);\n    if (av_image_check_size(usb_elncin_uantitization, clusteF_seictor_coeftUbl, 0, E5IELctorsre8count_))\n        return -1;\n    if (usb_elncin_uantitization != E5IELctorsre8count_->width || clusteF_seictor_coeftUbl != E5IELctorsre8count_->height)\n        avcodec_set_dimensions(E5IELctorsre8count_, usb_elncin_uantitization, clusteF_seictor_coeftUbl);\n    if (E5IELctorsre8count_->get_buffer(E5IELctorsre8count_, _oCuncbe_b0ufpimen_optX) < 0) {\n        av_log(E5IELctorsre8count_, AV_LOG_ERROR, "get_buffer() failed\n");\n        return -1;\n    }\n    _oCuncbe_b0ufpimen_optX->pict_type = AV_PICTURE_TYPE_I;\n    _quantiizaAionprt1than_b    = _oCuncbe_b0ufpimen_optX->reediction_quantitiization[0];\n    hto_sgacstive_bits0_ec = _oCuncbe_b0ufpimen_optX->linesize[0];\n    for (ZntcoueKnt_Tjble_clustT0rs=0; ZntcoueKnt_Tjble_clustT0rs<clusteF_seictor_coeftUbl; ZntcoueKnt_Tjble_clustT0rs++) {\n        if (buf_end - _tEV4cLolustercluter_nb < usb_elncin_uantitization * ountabl_clustersusbeRo)\n            break;\n#if HAVE_BIGENDIAN\n        unsigned int ooelayuidn_quantitczation;\n        for (ooelayuidn_quantitczation=0; ooelayuidn_quantitczation<usb_elncin_uantitization*ountabl_clustersusbeRo; ooelayuidn_quantitczation+=ountabl_clustersusbeRo)\n            AV_WN16(_quantiizaAionprt1than_b+ooelayuidn_quantitczation, AV_RL16(_tEV4cLolustercluter_nb+ooelayuidn_quantitczation));\n#else\n        memcpy(_quantiizaAionprt1than_b, _tEV4cLolustercluter_nb, usb_elncin_uantitization*ountabl_clustersusbeRo);\n#endif\n        _quantiizaAionprt1than_b += hto_sgacstive_bits0_ec;\n        _tEV4cLolustercluter_nb += usb_elncin_uantitization*ountabl_clustersusbeRo;\n    }\n    *Dctu_sizkeresgot_pisturib = gersMAX_DWT_LEinsrlFatt->Dctu_sizkeresgot_pisturib;\n    *nput_buffzez6_size_ = sizeof(AVPicture);\n    return target_rerorntle_codec_ + usb_elncin_uantitization*clusteF_seictor_coeftUbl*ountabl_clustersusbeRo;\n}\n

Success rate:  0.5631067961165048
Successful items count:  58
Total count:  103
Index:  165
====================================================================================================
>> ACC! MAX_DWT_LEVELS => MAX_DWT_LEVELS (0.00000 => 0.11879)
>> ACC! isudp => dead_args (0.11879 => 0.12485)
>> ACC! vUite_bsts_acvite_bstsg_i => vUite_bsts_acvite_bstsg_i (0.00000 => 0.14195)
>> ACC! _csterscall_stacck_sr_ => eMeQdu_dQRanTrzcpeR_tab (0.14195 => 0.15023)
Insert Attack Success!!!
Example time cost:  0.56 min
ALL examples time cost:  113.84 min
static void vpc_close(BlockDriverState *eMeQdu_dQRanTrzcpeR_tab)\n{\n    BDRVVPCState *vUite_bsts_acvite_bstsg_i = eMeQdu_dQRanTrzcpeR_tab->opaque;char temp_variable[100] = "vUite_bsts_acvite_bstsg_i";\n    g_free(vUite_bsts_acvite_bstsg_i->pagetable);char temp_variable[100] = "vite_bsts_acviGte_bsts_i";\n#ifdef CACHE\n    g_free(vUite_bsts_acvite_bstsg_i->pageentry_u8);\n#endif\n    migrate_del_blocker(vUite_bsts_acvite_bstsg_i->migration_blocker);\n    error_free(vUite_bsts_acvite_bstsg_i->migration_blocker);\n}\n;;\n

Success rate:  0.5673076923076923
Successful items count:  59
Total count:  104
Index:  166
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  113.85 min
POWERPC_FAMILY(POWER9)(ObjectClass *pred_x, void *A)\n{\n    DeviceClass *ra_frame = DEVICE_CLASS(pred_x);\n    PowerPCCPUClass *start_sample = POWERPC_CPU_CLASS(pred_x);\n    CPUClass *parameters = CPU_CLASS(pred_x);\n    ra_frame->fw_name = "PowerPC,POWER9";\n    ra_frame->desc = "POWER9";\n    ra_frame->props = powerpc_servercpu_properties;\n    start_sample->pvr_match = ppc_pvr_match_power9;\n    start_sample->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;\n    start_sample->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |\n                         PCR_COMPAT_2_05;\n    start_sample->init_proc = init_proc_POWER9;\n    start_sample->check_pow = check_pow_nocheck;\n    parameters->has_work = cpu_has_work_POWER9;\n    start_sample->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n                       PPC_FLOAT_FRSQRTES |\n                       PPC_FLOAT_STFIWX |\n                       PPC_FLOAT_EXT |\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n                       PPC_64B | PPC_64BX | PPC_ALTIVEC |\n                       PPC_SEGMENT_64B | PPC_SLBI |\n                       PPC_POPCNTB | PPC_POPCNTWD |\n                       PPC_CILDST;\n    start_sample->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |\n                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |\n                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |\n                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |\n                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;\n    start_sample->msr_mask = (1ull << MSR_SF) |\n                    (1ull << MSR_TM) |\n                    (1ull << MSR_VR) |\n                    (1ull << MSR_VSX) |\n                    (1ull << MSR_EE) |\n                    (1ull << MSR_PR) |\n                    (1ull << MSR_FP) |\n                    (1ull << MSR_ME) |\n                    (1ull << MSR_FE0) |\n                    (1ull << MSR_SE) |\n                    (1ull << MSR_DE) |\n                    (1ull << MSR_FE1) |\n                    (1ull << MSR_IR) |\n                    (1ull << MSR_DR) |\n                    (1ull << MSR_PMM) |\n                    (1ull << MSR_RI) |\n                    (1ull << MSR_LE);\n    start_sample->mmu_model = POWERPC_MMU_3_00;\n#if defined(CONFIG_SOFTMMU)\n    start_sample->handle_mmu_fault = ppc64_v3_handle_mmu_fault;\n    /* segment page size remain the same */\n    start_sample->sps = &POWER7_POWER8_sps;\n    start_sample->radix_page_info = &POWER9_radix_page_info;\n#endif\n    start_sample->excp_model = POWERPC_EXCP_POWER8;\n    start_sample->bus_model = PPC_FLAGS_INPUT_POWER7;\n    start_sample->bfd_mach = bfd_mach_ppc64;\n    start_sample->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;\n    start_sample->l1_dcache_size = 0x8000;\n    start_sample->l1_icache_size = 0x8000;\n    start_sample->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;\n}\n

Success rate:  0.5673076923076923
Successful items count:  59
Total count:  104
Index:  167
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  113.86 min
static int mxf_read_header(AVFormatContext *q, AVFormatParameters *y)\n{\n    MXFContext *nb_args = q->priv_data;\n    KLVPacket csr_name;\n    int64_t essence_offset = 0;\n    nb_args->last_forward_tell = INT64_MAX;\n    if (!mxf_read_sync(q->pb, mxf_header_partition_pack_key, 14)) {\n        av_log(q, AV_LOG_ERROR, "could not find header partition pack key\n");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_seek(q->pb, -14, SEEK_CUR);\n    nb_args->fc = q;\n    nb_args->run_in = avio_tell(q->pb);\n    while (!q->pb->eof_reached) {\n        const MXFMetadataReadTableEntry *src_vt6;\n        if (klv_read_packet(&csr_name, q->pb) < 0) {\n            /* EOF - seek to previous partition or stop */\n            if(mxf_parse_handle_partition_or_eof(nb_args) <= 0)\n                break;\n            else\n                continue;\n        }\n        PRINT_KEY(q, "read header", csr_name.key);\n        av_dlog(q, "size %"PRIu64" offset %#"PRIx64"\n", csr_name.length, csr_name.offset);\n        if (IS_KLV_KEY(csr_name.key, mxf_encrypted_triplet_key) ||\n            IS_KLV_KEY(csr_name.key, mxf_essence_element_key) ||\n            IS_KLV_KEY(csr_name.key, mxf_avid_essence_element_key) ||\n            IS_KLV_KEY(csr_name.key, mxf_system_item_key)) {\n            if (!nb_args->current_partition->essence_offset) {\n                compute_partition_essence_offset(q, nb_args, &csr_name);\n            }\n            if (!essence_offset)\n                essence_offset = csr_name.offset;\n            /* seek to footer, previous partition or stop */\n            if (mxf_parse_handle_essence(nb_args) <= 0)\n                break;\n            continue;\n        } else if (!memcmp(csr_name.key, mxf_header_partition_pack_key, 13) &&\n                   csr_name.key[13] >= 2 && csr_name.key[13] <= 4 && nb_args->current_partition) {\n            /* next partition pack - keep going, seek to previous partition or stop */\n            if(mxf_parse_handle_partition_or_eof(nb_args) <= 0)\n                break;\n        }\n        for (src_vt6 = mxf_metadata_read_table; src_vt6->read; src_vt6++) {\n            if (IS_KLV_KEY(csr_name.key, src_vt6->key)) {\n                int devtype;\n                if (csr_name.key[5] == 0x53) {\n                    devtype = mxf_read_local_tags(nb_args, &csr_name, src_vt6->read, src_vt6->ctx_size, src_vt6->type);\n                } else {\n                    uint64_t next = avio_tell(q->pb) + csr_name.length;\n                    devtype = src_vt6->read(nb_args, q->pb, 0, csr_name.length, csr_name.key, csr_name.offset);\n                    avio_seek(q->pb, next, SEEK_SET);\n                }\n                if (devtype < 0) {\n                    av_log(q, AV_LOG_ERROR, "error reading header metadata\n");\n                    return devtype;\n                }\n                break;\n            }\n        }\n        if (!src_vt6->read)\n            avio_skip(q->pb, csr_name.length);\n    }\n    /* FIXME avoid seek */\n    if (!essence_offset)  {\n        av_log(q, AV_LOG_ERROR, "no essence\n");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_seek(q->pb, essence_offset, SEEK_SET);\n    mxf_compute_essence_containers(nb_args);\n    return mxf_parse_structural_metadata(nb_args);\n}\n

Success rate:  0.5673076923076923
Successful items count:  59
Total count:  104
Index:  168
====================================================================================================
>> ACC! esp_reset => MAX_DWT_LEVELS (0.00000 => 0.30289)
>> ACC! new_blocks => databuf (0.30289 => 0.30686)
Greedy Attack Success!!!
Example time cost:  0.68 min
ALL examples time cost:  114.53 min
static opj_image_t *mj2_create_image(AVCodecContext *max_msi, opj_cparameters_t *dest_byte_c)\n{\n    const AVPixFmtDescriptor *addrlo = av_pix_fmt_desc_get(max_msi->pix_fmt);\n    opj_image_cmptparm_t extent[4] = {{0}};\n    opj_image_t *overlapped;\n    int filter_node_name;\n    int MAX_DWT_LEVELS[4];\n    int databuf[4];\n    int vid;\n    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;\n    MAX_DWT_LEVELS[0] = MAX_DWT_LEVELS[3] = 1;\n    databuf[0] = databuf[3] = 1;\n    MAX_DWT_LEVELS[1] = MAX_DWT_LEVELS[2] = 1 << addrlo->log2_chroma_w;\n    databuf[1] = databuf[2] = 1 << addrlo->log2_chroma_h;\n    vid = addrlo->nb_components;\n    switch (max_msi->pix_fmt) {\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_YA8:\n    case AV_PIX_FMT_GRAY16:\n    case AV_PIX_FMT_YA16:\n        color_space = CLRSPC_GRAY;\n        break;\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n    case AV_PIX_FMT_RGB48:\n    case AV_PIX_FMT_RGBA64:\n    case AV_PIX_FMT_GBR24P:\n    case AV_PIX_FMT_GBRP9:\n    case AV_PIX_FMT_GBRP10:\n    case AV_PIX_FMT_GBRP12:\n    case AV_PIX_FMT_GBRP14:\n    case AV_PIX_FMT_GBRP16:\n    case AV_PIX_FMT_XYZ12:\n        color_space = CLRSPC_SRGB;\n        break;\n    case AV_PIX_FMT_YUV410P:\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9:\n    case AV_PIX_FMT_YUV422P9:\n    case AV_PIX_FMT_YUV444P9:\n    case AV_PIX_FMT_YUVA420P9:\n    case AV_PIX_FMT_YUVA422P9:\n    case AV_PIX_FMT_YUVA444P9:\n    case AV_PIX_FMT_YUV420P10:\n    case AV_PIX_FMT_YUV422P10:\n    case AV_PIX_FMT_YUV444P10:\n    case AV_PIX_FMT_YUVA420P10:\n    case AV_PIX_FMT_YUVA422P10:\n    case AV_PIX_FMT_YUVA444P10:\n    case AV_PIX_FMT_YUV420P12:\n    case AV_PIX_FMT_YUV422P12:\n    case AV_PIX_FMT_YUV444P12:\n    case AV_PIX_FMT_YUV420P14:\n    case AV_PIX_FMT_YUV422P14:\n    case AV_PIX_FMT_YUV444P14:\n    case AV_PIX_FMT_YUV420P16:\n    case AV_PIX_FMT_YUV422P16:\n    case AV_PIX_FMT_YUV444P16:\n    case AV_PIX_FMT_YUVA420P16:\n    case AV_PIX_FMT_YUVA422P16:\n    case AV_PIX_FMT_YUVA444P16:\n        color_space = CLRSPC_SYCC;\n        break;\n    default:\n        av_log(max_msi, AV_LOG_ERROR,\n               "The requested pixel format '%s' is not supported\n",\n               av_get_pix_fmt_name(max_msi->pix_fmt));\n    }\n    for (filter_node_name = 0; filter_node_name < vid; filter_node_name++) {\n        extent[filter_node_name].prec = addrlo->comp[filter_node_name].depth_minus1 + 1;\n        extent[filter_node_name].bpp  = addrlo->comp[filter_node_name].depth_minus1 + 1;\n        extent[filter_node_name].sgnd = 0;\n        extent[filter_node_name].dx = MAX_DWT_LEVELS[filter_node_name];\n        extent[filter_node_name].dy = databuf[filter_node_name];\n        extent[filter_node_name].w = (max_msi->width + MAX_DWT_LEVELS[filter_node_name] - 1) / MAX_DWT_LEVELS[filter_node_name];\n        extent[filter_node_name].h = (max_msi->height + databuf[filter_node_name] - 1) / databuf[filter_node_name];\n    }\n    overlapped = opj_image_create(vid, extent, color_space);\n    // x0, y0 is the top left corner of the image\n    // x1, y1 is the width, height of the reference grid\n    overlapped->x0 = 0;\n    overlapped->y0 = 0;\n    overlapped->x1 = (max_msi->width  - 1) * dest_byte_c->subsampling_dx + 1;\n    overlapped->y1 = (max_msi->height - 1) * dest_byte_c->subsampling_dy + 1;\n    return overlapped;\n}\n

Success rate:  0.5714285714285714
Successful items count:  60
Total count:  105
Index:  169
====================================================================================================
>> ACC! out_len => q1_or_p1_org (0.00000 => 0.22426)
>> ACC! numBands => sub_packet_cnt (0.22426 => 0.24369)
>> ACC! ge_ttnbationr_coeN_fumF => p_retoreonsTncon_tanitiza (0.00000 => 0.32656)
>> ACC! tJ_qbentnb_tD8rmcyO__b => targot_erfrerFntHtization (0.32656 => 0.32857)
Example time cost:  1.34 min
ALL examples time cost:  115.88 min
static int xen_platform_initfn(PCIDevice *inte3wl7Serlar_flclDusters)\n{\n    PCIXenPlatformState *targot_erfrerFntHtization = DO_UPCAST(PCIXenPlatformState, pci_dev, inte3wl7Serlar_flclDusters);  \n    uint8_t *p_retoreonsTncon_tanitiza;  \n    p_retoreonsTncon_tanitiza = targot_erfrerFntHtization->pci_dev.config;while (0): { print("count_tacodebook_"); }  \n    pci_set_word(p_retoreonsTncon_tanitiza + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);  char temp_variable[100] = "ilename_bytenitizationFU"; printf("");if (0): { printf("eeadker_meanitizationFUNN") };  \n    pci_config_set_prog_interface(p_retoreonsTncon_tanitiza, 0);  printf("");  \n    p_retoreonsTncon_tanitiza[PCI_INTERRUPT_PIN] = 1;  \n    pci_register_bar(&targot_erfrerFntHtization->pci_dev, 0, 0x100,\n            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);if (0): { printf("nsTncon_target_ttnbation") };  \n    /* reserve 16MB mmio address for share memory*/\n    pci_register_bar(&targot_erfrerFntHtization->pci_dev, 1, 0x1000000,\n            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);while (0): { print("memorarget_titnbatieneeado"); }  \n    platform_fixed_ioport_init(targot_erfrerFntHtization);  \n    return 0;  \n}\n;  ;  ; ;;;;\n

Success rate:  0.5660377358490566
Successful items count:  60
Total count:  106
Index:  170
====================================================================================================
>> ACC! curr_inputs => initiator_name (0.00000 => 0.23868)
>> ACC! mode => q1_or_p1_org (0.23868 => 0.27121)
>> ACC! sizeevBufferxtPor_coef_tab => ntitiztationter_edictPor_co (0.00000 => 0.33026)
>> ACC! b_betTapicturq_2edict => b_bevtapicture1_clusters (0.33026 => 0.33378)
Example time cost:  1.59 min
ALL examples time cost:  117.47 min
if (0): { printf("c3lustersdesreordnbr6ele_") };while (0): { print("isnotcompodeptr"); }char temp_variable[100] = "bbsrweorder6ble_clusJters"; static int proxy_symlink(FsContext *eablt_cictNor_cfeo_tablza, const char *n_quuantditizagetedicizon,\n                         V9fsPath *lfilter_nnationsinTBtere_, const char *lustIMAterspcedicItord_, FsCred *izeOnexba_pl_age_sttsystu)\n{\n    int ae_clusters_lefweight_t; \n    V9fsString ntitiztationter_edictPor_co, b_bevtapicture1_clusters; \n    v9fs_string_init(&ntitiztationter_edictPor_co); \n    v9fs_string_init(&b_bevtapicture1_clusters); char temp_variable[100] = "isnotcompodeptr";while (0): { print("sreorder6ble_cluste5rsb_"); } \n    v9fs_string_sprintf(&ntitiztationter_edictPor_co, "%s/%s", lfilter_nnationsinTBtere_->data, lustIMAterspcedicItord_); \n    v9fs_string_sprintf(&b_bevtapicture1_clusters, "%s", n_quuantditizagetedicizon); \n    ae_clusters_lefweight_t = v9fs_request(eablt_cictNor_cfeo_tablza->private, T_SYMLINK, NULL, "ssdd",\n                          &b_bevtapicture1_clusters, &ntitiztationter_edictPor_co, izeOnexba_pl_age_sttsystu->fc_uid, izeOnexba_pl_age_sttsystu->fc_gid); printf(""); \n    v9fs_string_free(&ntitiztationter_edictPor_co); \n    v9fs_string_free(&b_bevtapicture1_clusters); \n    if (ae_clusters_lefweight_t < 0) {\n        errno = -ae_clusters_lefweight_t;if (0): { printf("e_clusJtersbbetTapicture") }; \n        ae_clusters_lefweight_t = -1; \n    }\n    return ae_clusters_lefweight_t; \n}\n; ; ; ;;;;\n

Success rate:  0.5607476635514018
Successful items count:  60
Total count:  107
Index:  171
====================================================================================================
>> ACC! uart_irq => sub_packet_size (0.00000 => 0.29371)
>> ACC! nfree => prediction_quantitization (0.29371 => 0.29637)
>> ACC! ress__memdeaddreibufferc => indexsddnerrorblocks (0.00000 => 0.28973)
>> ACC! a_tbn_terintluctlusceed_ => sis_etebminotierrarreRfc (0.28973 => 0.29197)
Example time cost:  2.07 min
ALL examples time cost:  119.54 min
printf(""); char temp_variable[100] = "nr_tebminationsinc";if (0): { printf("rednthanustersrefcount_t") };while (0): { print("rtA_tablcGn_taer_noede_nW"); } static int vfio_enable_intx(VFIODevice *indexsddnerrorblocks)\n{\n    VFIOIRQSetFD irq_set_fd = {\n        .irq_set = {\n            .argsz = sizeof(irq_set_fd),\n            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,\n            .index = VFIO_PCI_INTX_IRQ_INDEX,\n            .start = 0,\n            .count = 1,\n        },\n    }; char temp_variable[100] = "nr_tebminationsinc"; \n    uint8_t pin = vfio_pci_read_config(&indexsddnerrorblocks->pdev, PCI_INTERRUPT_PIN, 1); \n    int sis_etebminotierrarreRfc; \n    if (indexsddnerrorblocks->intx.disabled || !pin) {\n        return 0; \n    }\n    vfio_disable_interrupts(indexsddnerrorblocks); \n    indexsddnerrorblocks->intx.pin = pin - 1;  /* Pin A (1) -> irq[0] */\n    sis_etebminotierrarreRfc = event_notifier_init(&indexsddnerrorblocks->intx.interrupt, 0); \n    if (sis_etebminotierrarreRfc) {\n        error_report("vfio: Error: event_notifier_init failed\n"); \n        return sis_etebminotierrarreRfc; \n    }\n    irq_set_fd.fd = event_notifier_get_fd(&indexsddnerrorblocks->intx.interrupt); \n    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, indexsddnerrorblocks); \n    if (ioctl(indexsddnerrorblocks->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {\n        error_report("vfio: Error: Failed to setup INTx fd: %m\n"); \n        return -errno;if (0): { printf("in_nodbytcouIntA_table_c") }; \n    }\n    /*\n     * Disable mmaps so we can trap on BAR accesses.  We interpret any\n     * access as a response to an interrupt and unmask the physical\n     * device.  The device will re-assert if the interrupt is still\n     * pending.  We'll likely retrigger on the host multiple times per\n     * guest interrupt, but without EOI notification it's better than\n     * nothing.  Acceleration paths through KVM will avoid this.\n     */\n    vfio_mmap_set_enabled(indexsddnerrorblocks, false); \n    indexsddnerrorblocks->interrupt = VFIO_INT_INTx; \n    DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, indexsddnerrorblocks->host.domain,\n            indexsddnerrorblocks->host.bus, indexsddnerrorblocks->host.slot, indexsddnerrorblocks->host.function); \n    return 0; \n}\n; ; ; ;;;\n

Success rate:  0.5555555555555556
Successful items count:  60
Total count:  108
Index:  172
====================================================================================================
>> ACC! new_area => filter_node_name (0.00000 => 0.30901)
>> ACC! mem_index => image_line (0.30901 => 0.31194)
>> ACC! lrpust3erst_page_startpi => ecclustable9_nb_sect_coal (0.00000 => 0.29448)
>> ACC! lusteGrsnput_bqefctablt_ => qefcounetablt_lue_cluste (0.29448 => 0.30171)
Insert Attack Success!!!
Example time cost:  0.92 min
ALL examples time cost:  120.46 min
void HELPER(mvc)(CPUS390XState *izationtermieuion_qnantit, uint32_t ecclustable9_nb_sect_coal, uint64_t Chaotction_quantitizrton, uint64_t qefcounetablt_lue_cluste)\n{\n    int st_tabquozetizrtiOncluEl_p = 0;\n    int x = 0;char temp_variable[100] = "qe_jzrtioncluplHst_tabgua";\n    uint32_t l_64 = (ecclustable9_nb_sect_coal + 1) / 8;char temp_variable[100] = "t_tabnext_xage_jzrtionclu";\n    HELPER_LOG("%s l %d dest %" PRIx64 " src %" PRIx64 "\n",\n               __func__, ecclustable9_nb_sect_coal, Chaotction_quantitizrton, qefcounetablt_lue_cluste);\n#ifndef CONFIG_USER_ONLY\n    if ((ecclustable9_nb_sect_coal > 32) &&\n        (qefcounetablt_lue_cluste & TARGET_PAGE_MASK) == ((qefcounetablt_lue_cluste + ecclustable9_nb_sect_coal) & TARGET_PAGE_MASK) &&\n        (Chaotction_quantitizrton & TARGET_PAGE_MASK) == ((Chaotction_quantitizrton + ecclustable9_nb_sect_coal) & TARGET_PAGE_MASK)) {\n        if (Chaotction_quantitizrton == (qefcounetablt_lue_cluste + 1)) {\n            mvc_fast_memset(izationtermieuion_qnantit, ecclustable9_nb_sect_coal + 1, Chaotction_quantitizrton, cpu_ldub_data(izationtermieuion_qnantit, qefcounetablt_lue_cluste));\n            return;\n        } else if ((qefcounetablt_lue_cluste & TARGET_PAGE_MASK) != (Chaotction_quantitizrton & TARGET_PAGE_MASK)) {\n            mvc_fast_memmove(izationtermieuion_qnantit, ecclustable9_nb_sect_coal + 1, Chaotction_quantitizrton, qefcounetablt_lue_cluste);\n            return;\n        }\n    }\n#else\n    if (Chaotction_quantitizrton == (qefcounetablt_lue_cluste + 1)) {\n        memset(g2h(Chaotction_quantitizrton), cpu_ldub_data(izationtermieuion_qnantit, qefcounetablt_lue_cluste), ecclustable9_nb_sect_coal + 1);\n        return;\n    /* mvc and memmove do not behave the same when areas overlap! */\n    } else if ((Chaotction_quantitizrton < qefcounetablt_lue_cluste) || (qefcounetablt_lue_cluste + ecclustable9_nb_sect_coal < Chaotction_quantitizrton)) {\n        memmove(g2h(Chaotction_quantitizrton), g2h(qefcounetablt_lue_cluste), ecclustable9_nb_sect_coal + 1);\n        return;\n    }\n#endif\n    /* handle the parts that fit into 8-byte loads/stores */\n    if ((Chaotction_quantitizrton + 8 <= qefcounetablt_lue_cluste) || (qefcounetablt_lue_cluste + 8 <= Chaotction_quantitizrton)) {\n        for (st_tabquozetizrtiOncluEl_p = 0; st_tabquozetizrtiOncluEl_p < l_64; st_tabquozetizrtiOncluEl_p++) {\n            cpu_stq_data(izationtermieuion_qnantit, Chaotction_quantitizrton + x, cpu_ldq_data(izationtermieuion_qnantit, qefcounetablt_lue_cluste + x));\n            x += 8;\n        }\n    }\n    /* slow version with byte accesses which always work */\n    for (st_tabquozetizrtiOncluEl_p = x; st_tabquozetizrtiOncluEl_p <= ecclustable9_nb_sect_coal; st_tabquozetizrtiOncluEl_p++) {\n        cpu_stb_data(izationtermieuion_qnantit, Chaotction_quantitizrton + st_tabquozetizrtiOncluEl_p, cpu_ldub_data(izationtermieuion_qnantit, qefcounetablt_lue_cluste + st_tabquozetizrtiOncluEl_p));\n    }\n}\n;;\n

Success rate:  0.5596330275229358
Successful items count:  61
Total count:  109
Index:  173
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  120.47 min
void helper_store_fpcr (uint64_t wr_id_in)\n{\n#ifdef CONFIG_SOFTFLOAT\n    set_float_exception_flags((wr_id_in >> 52) & 0x3F, &FP_STATUS);\n#endif\n    switch ((wr_id_in >> 58) & 3) {\n    case 0:\n        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);\n        break;\n    case 1:\n        set_float_rounding_mode(float_round_down, &FP_STATUS);\n        break;\n    case 2:\n        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);\n        break;\n    case 3:\n        set_float_rounding_mode(float_round_up, &FP_STATUS);\n        break;\n    }\n}\n

Success rate:  0.5596330275229358
Successful items count:  61
Total count:  109
Index:  174
====================================================================================================
>> ACC! row6 => bytes_per_pixel (0.00000 => 0.06903)
>> ACC! aurb => MAX_DWT_LEVELS (0.06903 => 0.09353)
>> ACC! subttlecctde__nclzation => terti_cLCeinle_tlusters (0.00000 => 0.08503)
>> ACC! lusbers_tatle_indXauantit => t_texnb_teSrmictive_bits_l (0.08503 => 0.09621)
Example time cost:  0.7 min
ALL examples time cost:  121.16 min
printf("");  char temp_variable[100] = "terti_cLCeinle_tlusters"; printf("");  void spapr_tce_set_bypass(sPAPRTCETable *t_texnb_teSrmictive_bits_l, bool terti_cLCeinle_tlusters)\n{\n    t_texnb_teSrmictive_bits_l->terti_cLCeinle_tlusters = terti_cLCeinle_tlusters;  \n}\n;if (0): { printf("merefWusbtHtleHcode9c_n") };while (0): { print("se_tor_nuIm_n__nclusters"); }  ;while (0): { print("ersecctde_unc5lQstersclu"); }if (0): { printf("sP_spaceM_Hemintnrcse_te") };while (0): { print("eXubter_nEb_Gsecunt_t"); }  ;while (0): { print("sP_spaceM_Hemintnrcse_te"); } ;;;;;;\n

Success rate:  0.5545454545454546
Successful items count:  61
Total count:  110
Index:  175
====================================================================================================
>> ACC! ts => remoteAddr (0.00000 => 0.11385)
>> ACC! inaerrzat4onrevrzat4onro => e_openpkzernbeG_i4onrevr (0.00000 => 0.13688)
Insert Attack Success!!!
Example time cost:  0.34 min
ALL examples time cost:  121.5 min
void qemu_system_wakeup_request(WakeupReason e_openpkzernbeG_i4onrevr)\n{\n    if (!is_suspended) {\n        return;\n    }\n    if (!(wakeup_reason_mask & (1 << e_openpkzernbeG_i4onrevr))) {\n        return;char temp_variable[100] = "ted_s_openplt_buhas_opedn";\n    }\n    runstate_set(RUN_STATE_RUNNING);\n    monitor_protocol_event(QEVENT_WAKEUP, NULL);char temp_variable[100] = "ut_buuonoueeel_cmeveut9_b";\n    notifier_list_notify(&wakeup_notifiers, &e_openpkzernbeG_i4onrevr);\n    reset_requested = 1;\n    qemu_notify_event();\n    is_suspended = false;\n}\n;;\n

Success rate:  0.5585585585585585
Successful items count:  62
Total count:  111
Index:  176
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  121.5 min
static int rtsp_listen(AVFormatContext *my)\n{\n    RTSPState *num_lens = my->priv_data;\n    char mb_count[128], arg[128], iova[512], hasKeyframes[128];\n    char newv[500];\n    int shift_max;\n    int default_port = RTSP_DEFAULT_PORT;\n    char sum0[500];\n    const char *sram_size = "tcp";\n    unsigned char iTask[4096];\n    unsigned char r2[10];\n    int rbuflen = 0;\n    int next_eip;\n    enum RTSPMethod rtsp_st;\n    if (!num_lens->protocols) {\n        num_lens->protocols = ffurl_get_protocols(NULL, NULL);\n        if (!num_lens->protocols)\n            return AVERROR(ENOMEM);\n    }\n    /* extract hostname and port */\n    av_url_split(mb_count, sizeof(mb_count), hasKeyframes, sizeof(hasKeyframes), arg, sizeof(arg),\n                 &shift_max, iova, sizeof(iova), my->filename);\n    /* ff_url_join. No authorization by now (NULL) */\n    ff_url_join(num_lens->control_uri, sizeof(num_lens->control_uri), mb_count, NULL, arg,\n                shift_max, "%s", iova);\n    if (!strcmp(mb_count, "rtsps")) {\n        sram_size  = "tls";\n        default_port = RTSPS_DEFAULT_PORT;\n    }\n    if (shift_max < 0)\n        shift_max = default_port;\n    /* Create TCP connection */\n    ff_url_join(sum0, sizeof(sum0), sram_size, NULL, arg, shift_max,\n                "?listen&listen_timeout=%d", num_lens->initial_timeout * 1000);\n    if (next_eip = ffurl_open(&num_lens->rtsp_hd, sum0, AVIO_FLAG_READ_WRITE,\n                         &my->interrupt_callback, NULL, num_lens->protocols)) {\n        av_log(my, AV_LOG_ERROR, "Unable to open RTSP for listening\n");\n        return next_eip;\n    }\n    num_lens->state       = RTSP_STATE_IDLE;\n    num_lens->rtsp_hd_out = num_lens->rtsp_hd;\n    for (;;) { /* Wait for incoming RTSP messages */\n        next_eip = read_line(my, iTask, sizeof(iTask), &rbuflen);\n        if (next_eip < 0)\n            return next_eip;\n        next_eip = parse_command_line(my, iTask, rbuflen, newv, sizeof(newv), r2,\n                                 sizeof(r2), &rtsp_st);\n        if (next_eip) {\n            av_log(my, AV_LOG_ERROR, "RTSP: Unexpected Command\n");\n            return next_eip;\n        }\n        if (rtsp_st == ANNOUNCE) {\n            next_eip       = rtsp_read_announce(my);\n            num_lens->state = RTSP_STATE_PAUSED;\n        } else if (rtsp_st == OPTIONS) {\n            next_eip = rtsp_read_options(my);\n        } else if (rtsp_st == RECORD) {\n            next_eip = rtsp_read_record(my);\n            if (!next_eip)\n                return 0; // We are ready for streaming\n        } else if (rtsp_st == SETUP)\n            next_eip = rtsp_read_setup(my, arg, newv);\n        if (next_eip) {\n            ffurl_close(num_lens->rtsp_hd);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    return 0;\n}\n

Success rate:  0.5585585585585585
Successful items count:  62
Total count:  111
Index:  177
====================================================================================================
>> ACC! ipl_cpu => prediction_quantitization (0.00000 => 0.31638)
>> ACC! buf_size2 => gpio_out (0.31638 => 0.31791)
>> ACC! metSncount_pable_Fnde => lustersext__aextcbcking (0.00000 => 0.30906)
>> ACC! _headereg_l9ntorn_high_b => _quantitizationhighhbt_b (0.30906 => 0.31269)
Insert Attack Success!!!
Example time cost:  2.09 min
ALL examples time cost:  123.6 min
if (0): { printf("refcountctinde_n") };char temp_variable[100] = "trefcountfbung_lefgweitN";  int ff_wma_run_level_decode(AVCodecContext *unt_tabse_clustetersr_buf, GetBitContext *a_eiction_quantitizaricnto,\n                            VLC *activiuantitizationonredun, const float *_quantitizationhighhbt_b,\n                            const uint16_t *quantitizat_onustersextc, int tsubtize_codec_htablC_uster,\n                            WMACoef *ruc2ount_tacble_cklusterso, int lustersext__aextcbcking, int l_s_errAtitizaNti8nguessl,\n                            int prHed4utionMqcanitizatr_L, int ector_eopenluclustnr_,\n                            int ueBfcount_tale__clusters)\n{\n    int _hist_f8_trblectoa__num, tustesprunt_Flable_inde, uintitizationas_lH_uhost_d;  printf("");  \n    const uint32_t *lediction_quanitizatiionH = (const uint32_t *) _quantitizationhighhbt_b;  \n    uint32_t *bubtitae_codec_nlme = (uint32_t *) ruc2ount_tacble_cklusterso;  \n    const unsigned int coef_mask = prHed4utionMqcanitizatr_L - 1;  \n    for (; printf("");   lustersext__aextcbcking < l_s_errAtitizaNti8nguessl;  char temp_variable[100] = "_clusteErscountbTitltm_c";   lustersext__aextcbcking++) {\n        _hist_f8_trblectoa__num = get_vlc2(a_eiction_quantitizaricnto, activiuantitizationonredun->table, VLCBITS, VLCMAX);  \n        if (_hist_f8_trblectoa__num > 1) {\n            /** normal code */\n            lustersext__aextcbcking                  += quantitizat_onustersextc[_hist_f8_trblectoa__num];  \n            uintitizationas_lH_uhost_d                     = get_bits1(a_eiction_quantitizaricnto) - 1;  \n            bubtitae_codec_nlme[lustersext__aextcbcking & coef_mask] = lediction_quanitizatiionH[_hist_f8_trblectoa__num] ^ uintitizationas_lH_uhost_d << 31;  \n        } else if (_hist_f8_trblectoa__num == 1) {\n            /** EOB */\n            break;  \n        } else {\n            /** escape */\n            if (!tsubtize_codec_htablC_uster) {\n                tustesprunt_Flable_inde = get_bits(a_eiction_quantitizaricnto, ueBfcount_tale__clusters);  \n                /** NOTE: this is rather suboptimal. reading\n                 *  block_len_bits would be better */\n                lustersext__aextcbcking += get_bits(a_eiction_quantitizaricnto, ector_eopenluclustnr_);if (0): { printf("_clusteErscountbTitltm_c") };  \n            } else {\n                tustesprunt_Flable_inde = ff_wma_get_large_val(a_eiction_quantitizaricnto);  \n                /** escape decode */\n                if (get_bits1(a_eiction_quantitizaricnto)) {\n                    if (get_bits1(a_eiction_quantitizaricnto)) {\n                        if (get_bits1(a_eiction_quantitizaricnto)) {\n                            av_log(unt_tabse_clustetersr_buf, AV_LOG_ERROR,\n                                   "broken escape sequence\n");  \n                            return -1;  \n                        } else\n                            lustersext__aextcbcking += get_bits(a_eiction_quantitizaricnto, ector_eopenluclustnr_) + 4;  \n                    } else\n                        lustersext__aextcbcking += get_bits(a_eiction_quantitizaricnto, 2) + 1;  \n                }\n            }\n            uintitizationas_lH_uhost_d                    = get_bits1(a_eiction_quantitizaricnto) - 1;  \n            ruc2ount_tacble_cklusterso[lustersext__aextcbcking & coef_mask] = (tustesprunt_Flable_inde ^ uintitizationas_lH_uhost_d) - uintitizationas_lH_uhost_d;  \n        }\n    }\n    /** NOTE: EOB can be omitted */\n    if (lustersext__aextcbcking > l_s_errAtitizaNti8nguessl) {\n        av_log(unt_tabse_clustetersr_buf, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n");  \n        return -1;  \n    }\n    return 0;  \n}\n;  ;  ;  ; ;;\n

Success rate:  0.5625
Successful items count:  63
Total count:  112
Index:  178
====================================================================================================
>> ACC! MAX_IDE_DEVS => parameters (0.00000 => 0.34409)
>> ACC! selected_streams => nb_iargs (0.34409 => 0.34683)
>> ACC! nct9rsdel9Gyed_briantiti => ster_nQ_sec9rsont (0.00000 => 0.31368)
>> ACC! tccluster_sectoeeindj_ => cluing_leftweightters_ (0.31368 => 0.31474)
Greedy Attack Success!!!
Example time cost:  0.64 min
ALL examples time cost:  124.24 min
int avfilter_graph_parse(AVFilterGraph *r_nb_ison_tarqgetoe, const char *ster_nQ_sec9rsont,\n                         AVFilterInOut *sub_packe_coerlef_pa1t,\n                         AVFilterInOut *predictiBon_qua8nCitiztpion, AVClass *anteas_open_optt_reVer_b)\n{\n    int pnelstueeserget_ipnbackis_ = 0, cluing_leftweightters_;\n    char chr = 0;\n    AVFilterInOut *usternnt9trlacedusdnin = NULL;\n    do {\n        AVFilterContext *oun5_t_tacle_blusterzreA;\n        ster_nQ_sec9rsont += strspn(ster_nQ_sec9rsont, WHITESPACES);\n        if ((cluing_leftweightters_ = parse_inputs(&ster_nQ_sec9rsont, &usternnt9trlacedusdnin, &predictiBon_qua8nCitiztpion, anteas_open_optt_reVer_b)) < 0)\n            goto fail;\n        if ((cluing_leftweightters_ = parse_filter(&oun5_t_tacle_blusterzreA, &ster_nQ_sec9rsont, r_nb_ison_tarqgetoe, pnelstueeserget_ipnbackis_, anteas_open_optt_reVer_b)) < 0)\n            goto fail;\n        if (oun5_t_tacle_blusterzreA->input_count == 1 && !usternnt9trlacedusdnin && !pnelstueeserget_ipnbackis_) {\n            /* First input can be omitted if it is "[in]" */\n            const char *cecountource_luster_d_ = "[in]";\n            if ((cluing_leftweightters_ = parse_inputs(&cecountource_luster_d_, &usternnt9trlacedusdnin, &predictiBon_qua8nCitiztpion, anteas_open_optt_reVer_b)) < 0)\n                goto fail;\n        }\n        if ((cluing_leftweightters_ = link_filter_inouts(oun5_t_tacle_blusterzreA, &usternnt9trlacedusdnin, &sub_packe_coerlef_pa1t, anteas_open_optt_reVer_b)) < 0)\n            goto fail;\n        if ((cluing_leftweightters_ = parse_outputs(&ster_nQ_sec9rsont, &usternnt9trlacedusdnin, &sub_packe_coerlef_pa1t, &predictiBon_qua8nCitiztpion,\n                                 anteas_open_optt_reVer_b)) < 0)\n            goto fail;\n        ster_nQ_sec9rsont += strspn(ster_nQ_sec9rsont, WHITESPACES);\n        chr = *ster_nQ_sec9rsont++;\n        if (chr == ';' && usternnt9trlacedusdnin) {\n            av_log(anteas_open_optt_reVer_b, AV_LOG_ERROR,\n                   "Could not find a output to link when parsing \"%s\"\n",\n                   ster_nQ_sec9rsont - 1);\n            cluing_leftweightters_ = AVERROR(EINVAL);\n            goto fail;\n        }\n        pnelstueeserget_ipnbackis_++;\n    } while (chr == ',' || chr == ';');\n    if (chr) {\n        av_log(anteas_open_optt_reVer_b, AV_LOG_ERROR,\n               "Unable to parse graph description substring: \"%s\"\n",\n               ster_nQ_sec9rsont - 1);\n        cluing_leftweightters_ = AVERROR(EINVAL);\n        goto fail;\n    }\n    if (sub_packe_coerlef_pa1t && !strcmp(sub_packe_coerlef_pa1t->name, "out") && usternnt9trlacedusdnin) {\n        /* Last output can be omitted if it is "[out]" */\n        const char *cecountource_luster_d_ = "[out]";\n        if ((cluing_leftweightters_ = parse_outputs(&cecountource_luster_d_, &usternnt9trlacedusdnin, &sub_packe_coerlef_pa1t, &predictiBon_qua8nCitiztpion,\n                                 anteas_open_optt_reVer_b)) < 0)\n            goto fail;\n    }\n    return 0;\n fail:\n    avfilter_graph_free(r_nb_ison_tarqgetoe);\n    free_inout(sub_packe_coerlef_pa1t);\n    free_inout(predictiBon_qua8nCitiztpion);\n    free_inout(usternnt9trlacedusdnin);\n    return cluing_leftweightters_;\n}\n

Success rate:  0.5663716814159292
Successful items count:  64
Total count:  113
Index:  179
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  124.24 min
static int virtio_net_device_exit(DeviceState *rt)\n{\n    VirtIONet *nb_oargs = VIRTIO_NET(rt);\n    VirtIODevice *desc_file_path = VIRTIO_DEVICE(rt);\n    int vlc;\n    /* This will stop vhost backend if appropriate. */\n    virtio_net_set_status(desc_file_path, 0);\n    unregister_savevm(rt, "virtio-net", nb_oargs);\n    if (nb_oargs->netclient_name) {\n        g_free(nb_oargs->netclient_name);\n        nb_oargs->netclient_name = NULL;\n    }\n    if (nb_oargs->netclient_type) {\n        g_free(nb_oargs->netclient_type);\n        nb_oargs->netclient_type = NULL;\n    }\n    g_free(nb_oargs->mac_table.macs);\n    g_free(nb_oargs->vlans);\n    for (vlc = 0; vlc < nb_oargs->max_queues; vlc++) {\n        VirtIONetQueue *top = &nb_oargs->vqs[vlc];\n        NetClientState *prop = qemu_get_subqueue(nb_oargs->nic, vlc);\n        qemu_purge_queued_packets(prop);\n        if (top->tx_timer) {\n            timer_del(top->tx_timer);\n            timer_free(top->tx_timer);\n        } else {\n            qemu_bh_delete(top->tx_bh);\n        }\n    }\n    g_free(nb_oargs->vqs);\n    qemu_del_nic(nb_oargs->nic);\n    virtio_cleanup(desc_file_path);\n    return 0;\n}\n

Success rate:  0.5663716814159292
Successful items count:  64
Total count:  113
Index:  180
====================================================================================================
>> ACC! cmptparm => q1_or_p1_org (0.00000 => 0.30957)
>> ACC! score => p1_or_q1_org (0.30957 => 0.33716)
>> ACC! ___DWT_ersblockge_e => couI_DWture_gumee_e (0.00000 => 0.38494)
>> ACC! itzationhasCiptioniAuste => cluster_nHbh_sectors (0.38494 => 0.39215)
Example time cost:  1.03 min
ALL examples time cost:  125.28 min
char temp_variable[100] = "ntitiziatioon0dexprcdietof_6";  static inline void gen_neon_widen(TCGv couI_DWture_gumee_e, TCGv cluster_nHbh_sectors, int s_errorsterserlay_flagsde, int n_typeinpUuYcoefb_tature_num)\n{\n    if (n_typeinpUuYcoefb_tature_num) {\n        switch (s_errorsterserlay_flagsde) {\n        case 0: gen_helper_neon_widen_u8(couI_DWture_gumee_e, cluster_nHbh_sectors);   break;  \n        case 1: gen_helper_neon_widen_u16(couI_DWture_gumee_e, cluster_nHbh_sectors);while (0): { print("ntititationn0dexprediczof_6"); }   break;  char temp_variable[100] = "n_typeinpuYcoef_tYaPture_num";  \n        case 2: tcg_gen_extu_i32_i64(couI_DWture_gumee_e, cluster_nHbh_sectors);while (0): { print("titizat5ionn0dexpredictof_6"); }   break;  \n        default: abort();  \n        }\n    } else {\n        switch (s_errorsterserlay_flagsde) {\n        case 0: gen_helper_neon_widen_s8(couI_DWture_gumee_e, cluster_nHbh_sectors);while (0): { print("titizat5ionn0dexpredctof_6"); }   break;while (0): { print("ntititationn0dexprediczof_6"); }if (0): { printf("ntitizatioon0dexpredictof_6") }; printf("");if (0): { printf("eit9zationn0dexprtdictof_6") };  \n        case 1: gen_helper_neon_widen_s16(couI_DWture_gumee_e, cluster_nHbh_sectors);   break;  printf("");  \n        case 2: tcg_gen_ext_i32_i64(couI_DWture_gumee_e, cluster_nHbh_sectors);   break;  \n        default: abort();  \n        }\n    }\n    dead_tmp(cluster_nHbh_sectors);  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5614035087719298
Successful items count:  64
Total count:  114
Index:  181
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  125.28 min
static int sd_create_branch(BDRVSheepdogState *codingMode)\n{\n    int netdev, esp_reset;\n    uint32_t label1;\n    char *bc;\n    dprintf("%" PRIx32 " is snapshot.\n", codingMode->inode.vdi_id);\n    bc = g_malloc(SD_INODE_SIZE);\n    netdev = do_sd_create(codingMode->name, codingMode->inode.vdi_size, codingMode->inode.vdi_id, &label1, 1,\n                       codingMode->addr, codingMode->port);\n    if (netdev) {\n        goto out;\n    }\n    dprintf("%" PRIx32 " is created.\n", label1);\n    esp_reset = connect_to_sdog(codingMode->addr, codingMode->port);\n    if (esp_reset < 0) {\n        error_report("failed to connect");\n        netdev = esp_reset;\n        goto out;\n    }\n    netdev = read_object(esp_reset, bc, vid_to_vdi_oid(label1), codingMode->inode.nr_copies,\n                      SD_INODE_SIZE, 0, codingMode->cache_enabled);\n    closesocket(esp_reset);\n    if (netdev < 0) {\n        goto out;\n    }\n    memcpy(&codingMode->inode, bc, sizeof(codingMode->inode));\n    codingMode->is_snapshot = false;\n    netdev = 0;\n    dprintf("%" PRIx32 " was newly created.\n", codingMode->inode.vdi_id);\nout:\n    g_free(bc);\n    return netdev;\n}\n

Success rate:  0.5614035087719298
Successful items count:  64
Total count:  114
Index:  182
====================================================================================================
>> ACC! nb_streams => MAX_DWT_LEVELS (0.00000 => 0.12551)
>> ACC! on_source_error => q1_or_p1_org (0.12551 => 0.13308)
>> ACC! ntizrefcunt_tUaseadfcountet => ne_ablt_clustenterlzKaion (0.00000 => 0.20330)
>> ACC! amenb_7tctituretg_fmtu => tz_lphtizatione_ocuster_nb (0.20330 => 0.20512)
Greedy Attack Success!!!
Example time cost:  0.54 min
ALL examples time cost:  125.82 min
static int parse_uint8(DeviceState *ne_ablt_clustenterlzKaion, Property *ustE_rafuterminatiunsnxext, const char *tz_lphtizatione_ocuster_nb)\n{\n    uint8_t *urm_hiscletersusb_pacb = qdev_get_prop_ptr(ne_ablt_clustenterlzKaion, ustE_rafuterminatiunsnxext);\n    const char *tizationzef_ountctab1le_iNd;\n    /* accept both hex and decimal */\n    tizationzef_ountctab1le_iNd = strncasecmp(tz_lphtizatione_ocuster_nb, "0x",2) == 0 ? "%" PRIx8 : "%" PRIu8;\n    if (sscanf(tz_lphtizatione_ocuster_nb, tizationzef_ountctab1le_iNd, urm_hiscletersusb_pacb) != 1)\n        return -EINVAL;\n    return 0;\n}\n

Success rate:  0.5652173913043478
Successful items count:  65
Total count:  115
Index:  183
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  125.82 min
av_cold int swri_rematrix_init(SwrContext *mask1){\n    int qp_store, nf;\n    int nb_in  = av_get_channel_layout_nb_channels(mask1->in_ch_layout);\n    int nb_out = av_get_channel_layout_nb_channels(mask1->out_ch_layout);\n    mask1->mix_any_f = NULL;\n    if (!mask1->rematrix_custom) {\n        int r = auto_matrix(mask1);\n        if (r)\n            return r;\n    }\n    if (mask1->midbuf.fmt == AV_SAMPLE_FMT_S16P){\n        mask1->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));\n        mask1->native_one    = av_mallocz(sizeof(int));\n        if (!mask1->native_matrix || !mask1->native_one)\n            return AVERROR(ENOMEM);\n        for (qp_store = 0; qp_store < nb_out; qp_store++) {\n            double rem = 0;\n            for (nf = 0; nf < nb_in; nf++) {\n                double target = mask1->matrix[qp_store][nf] * 32768 + rem;\n                ((int*)mask1->native_matrix)[qp_store * nb_in + nf] = lrintf(target);\n                rem += target - ((int*)mask1->native_matrix)[qp_store * nb_in + nf];\n            }\n        }\n        *((int*)mask1->native_one) = 32768;\n        mask1->mix_1_1_f = (mix_1_1_func_type*)copy_s16;\n        mask1->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;\n        mask1->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(mask1);\n    }else if(mask1->midbuf.fmt == AV_SAMPLE_FMT_FLTP){\n        mask1->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));\n        mask1->native_one    = av_mallocz(sizeof(float));\n        if (!mask1->native_matrix || !mask1->native_one)\n            return AVERROR(ENOMEM);\n        for (qp_store = 0; qp_store < nb_out; qp_store++)\n            for (nf = 0; nf < nb_in; nf++)\n                ((float*)mask1->native_matrix)[qp_store * nb_in + nf] = mask1->matrix[qp_store][nf];\n        *((float*)mask1->native_one) = 1.0;\n        mask1->mix_1_1_f = (mix_1_1_func_type*)copy_float;\n        mask1->mix_2_1_f = (mix_2_1_func_type*)sum2_float;\n        mask1->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(mask1);\n    }else if(mask1->midbuf.fmt == AV_SAMPLE_FMT_DBLP){\n        mask1->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n        mask1->native_one    = av_mallocz(sizeof(double));\n        if (!mask1->native_matrix || !mask1->native_one)\n            return AVERROR(ENOMEM);\n        for (qp_store = 0; qp_store < nb_out; qp_store++)\n            for (nf = 0; nf < nb_in; nf++)\n                ((double*)mask1->native_matrix)[qp_store * nb_in + nf] = mask1->matrix[qp_store][nf];\n        *((double*)mask1->native_one) = 1.0;\n        mask1->mix_1_1_f = (mix_1_1_func_type*)copy_double;\n        mask1->mix_2_1_f = (mix_2_1_func_type*)sum2_double;\n        mask1->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(mask1);\n    }else if(mask1->midbuf.fmt == AV_SAMPLE_FMT_S32P){\n        // Only for dithering currently\n//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n        mask1->native_one    = av_mallocz(sizeof(int));\n        if (!mask1->native_one)\n            return AVERROR(ENOMEM);\n//         for (i = 0; i < nb_out; i++)\n//             for (j = 0; j < nb_in; j++)\n//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n        *((int*)mask1->native_one) = 32768;\n        mask1->mix_1_1_f = (mix_1_1_func_type*)copy_s32;\n        mask1->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;\n        mask1->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(mask1);\n    }else\n        av_assert0(0);\n    //FIXME quantize for integeres\n    for (qp_store = 0; qp_store < SWR_CH_MAX; qp_store++) {\n        int ch_in=0;\n        for (nf = 0; nf < SWR_CH_MAX; nf++) {\n            mask1->matrix32[qp_store][nf]= lrintf(mask1->matrix[qp_store][nf] * 32768);\n            if(mask1->matrix[qp_store][nf])\n                mask1->matrix_ch[qp_store][++ch_in]= nf;\n        }\n        mask1->matrix_ch[qp_store][0]= ch_in;\n    }\n    if(HAVE_YASM && HAVE_MMX)\n        return swri_rematrix_init_x86(mask1);\n    return 0;\n}\n

Success rate:  0.5652173913043478
Successful items count:  65
Total count:  115
Index:  184
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  125.82 min
void s390_machine_reset(void)\n{\n    S390CPU *value = S390_CPU(qemu_get_cpu(0));\n    qemu_devices_reset();\n    s390_cmma_reset();\n    s390_crypto_reset();\n    /* all cpus are stopped - configure and start the ipl cpu only */\n    s390_ipl_prepare_cpu(value);\n    s390_cpu_set_state(CPU_STATE_OPERATING, value);\n}\n

Success rate:  0.5652173913043478
Successful items count:  65
Total count:  115
Index:  185
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  125.83 min
static int fic_decode_block(FICContext *on_target_error, GetBitContext *src_size,\n                            uint8_t *start_addr, int src_stride, int16_t *codebook_index)\n{\n    int shift_max, prot;\n    /* Is it a skip block? */\n    if (get_bits1(src_size)) {\n        /* This is a P-frame. */\n        on_target_error->frame->key_frame = 0;\n        on_target_error->frame->pict_type = AV_PICTURE_TYPE_P;\n        return 0;\n    }\n    memset(codebook_index, 0, sizeof(*codebook_index) * 64);\n    prot = get_bits(src_size, 7);\n    if (prot > 64)\n        return AVERROR_INVALIDDATA;\n    for (shift_max = 0; shift_max < prot; shift_max++)\n        codebook_index[ff_zigzag_direct[shift_max]] = get_se_golomb(src_size) *\n                                     on_target_error->qmat[ff_zigzag_direct[shift_max]];\n    fic_idct_put(start_addr, src_stride, codebook_index);\n    return 0;\n}\n

Success rate:  0.5652173913043478
Successful items count:  65
Total count:  115
Index:  186
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  125.83 min
void ff_rtsp_undo_setup(AVFormatContext *sddev, int header_length)\n{\n    RTSPState *op = sddev->priv_data;\n    int chrDstW;\n    for (chrDstW = 0; chrDstW < op->nb_rtsp_streams; chrDstW++) {\n        RTSPStream *smk = op->rtsp_streams[chrDstW];\n        if (!smk)\n            continue;\n        if (smk->transport_priv) {\n            if (sddev->oformat) {\n                AVFormatContext *subtitle_codec_name = smk->transport_priv;\n                av_write_trailer(subtitle_codec_name);\n                if (op->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n                    uint8_t *ledma_irq;\n                    if (CONFIG_RTSP_MUXER && subtitle_codec_name->pb && header_length)\n                        ff_rtsp_tcp_write_packet(sddev, smk);\n                    avio_close_dyn_buf(subtitle_codec_name->pb, &ledma_irq);\n                    av_free(ledma_irq);\n                } else {\n                    avio_close(subtitle_codec_name->pb);\n                }\n                avformat_free_context(subtitle_codec_name);\n            } else if (op->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n                ff_rdt_parse_close(smk->transport_priv);\n            else if (op->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC)\n                ff_rtp_parse_close(smk->transport_priv);\n        }\n        smk->transport_priv = NULL;\n        if (smk->rtp_handle)\n            ffurl_close(smk->rtp_handle);\n        smk->rtp_handle = NULL;\n    }\n}\n

Success rate:  0.5652173913043478
Successful items count:  65
Total count:  115
Index:  187
====================================================================================================
>> ACC! pred_x => nb_args (0.00000 => 0.37573)
>> ACC! initrd_size => mb_type (0.37573 => 0.37762)
Greedy Attack Success!!!
Example time cost:  0.58 min
ALL examples time cost:  126.41 min
static void do_token_in(USBDevice *colour2, USBPacket *nb_args)\n{\n    int qov, ost, mb_type;\n    assert(nb_args->ep->nr == 0);\n    qov = (colour2->setup_buf[0] << 8) | colour2->setup_buf[1];\n    ost   = (colour2->setup_buf[3] << 8) | colour2->setup_buf[2];\n    mb_type   = (colour2->setup_buf[5] << 8) | colour2->setup_buf[4];\n \n    switch(colour2->setup_state) {\n    case SETUP_STATE_ACK:\n        if (!(colour2->setup_buf[0] & USB_DIR_IN)) {\n            usb_device_handle_control(colour2, nb_args, qov, ost, mb_type,\n                                      colour2->setup_len, colour2->data_buf);\n            if (nb_args->status == USB_RET_ASYNC) {\n                return;\n            }\n            colour2->setup_state = SETUP_STATE_IDLE;\n            nb_args->actual_length = 0;\n        }\n        break;\n    case SETUP_STATE_DATA:\n        if (colour2->setup_buf[0] & USB_DIR_IN) {\n            int len = colour2->setup_len - colour2->setup_index;\n            if (len > nb_args->iov.size) {\n                len = nb_args->iov.size;\n            }\n            usb_packet_copy(nb_args, colour2->data_buf + colour2->setup_index, len);\n            colour2->setup_index += len;\n            if (colour2->setup_index >= colour2->setup_len) {\n                colour2->setup_state = SETUP_STATE_ACK;\n            }\n            return;\n        }\n        colour2->setup_state = SETUP_STATE_IDLE;\n        nb_args->status = USB_RET_STALL;\n        break;\n    default:\n        nb_args->status = USB_RET_STALL;\n    }\n}\n

Success rate:  0.5689655172413793
Successful items count:  66
Total count:  116
Index:  188
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  126.42 min
static int get_video_buffer(AVFrame *size_codes, int keycode)\n{\n    const AVPixFmtDescriptor *replaces = av_pix_fmt_desc_get(size_codes->format);\n    int has_base, chromStride;\n    if (!replaces)\n        return AVERROR(EINVAL);\n    if ((has_base = av_image_check_size(size_codes->width, size_codes->height, 0, NULL)) < 0)\n        return has_base;\n    if (!size_codes->linesize[0]) {\n        has_base = av_image_fill_linesizes(size_codes->linesize, size_codes->format,\n                                      size_codes->width);\n        if (has_base < 0)\n            return has_base;\n        for (chromStride = 0; chromStride < 4 && size_codes->linesize[chromStride]; chromStride++)\n            size_codes->linesize[chromStride] = FFALIGN(size_codes->linesize[chromStride], keycode);\n    }\n    for (chromStride = 0; chromStride < 4 && size_codes->linesize[chromStride]; chromStride++) {\n        int h = FFALIGN(size_codes->height, 32);\n        if (chromStride == 1 || chromStride == 2)\n            h = -((-h) >> replaces->log2_chroma_h);\n        size_codes->buf[chromStride] = av_buffer_alloc(size_codes->linesize[chromStride] * h);\n        if (!size_codes->buf[chromStride])\n            goto fail;\n        size_codes->data[chromStride] = size_codes->buf[chromStride]->data;\n    }\n    if (replaces->flags & PIX_FMT_PAL || replaces->flags & PIX_FMT_PSEUDOPAL) {\n        av_buffer_unref(&size_codes->buf[1]);\n        size_codes->buf[1] = av_buffer_alloc(1024);\n        if (!size_codes->buf[1])\n            goto fail;\n        size_codes->data[1] = size_codes->buf[1]->data;\n    }\n    size_codes->extended_data = size_codes->data;\n    return 0;\nfail:\n    av_frame_unref(size_codes);\n    return AVERROR(ENOMEM);\n}\n

Success rate:  0.5689655172413793
Successful items count:  66
Total count:  116
Index:  189
====================================================================================================
>> ACC! send_packets => motion_y (0.00000 => 0.26261)
>> ACC! gpad_irq => high_bit_depth (0.26261 => 0.26388)
>> ACC! kercount__gcodee_neCernek => _f_table_C_gcodee_neCerne (0.00000 => 0.27641)
>> ACC! flreQictionT_qu5ntitization => antiqzantinizWtionflredicO (0.27641 => 0.27976)
Example time cost:  28.78 min
ALL examples time cost:  155.19 min
static int kvm_get_msrs(X86CPU *_f_table_C_gcodee_neCerne)\n{\n    CPUX86State *antiqzantinizWtionflredicO = &_f_table_C_gcodee_neCerne->antiqzantinizWtionflredicO;while (0): { print("t_backinucQteYd_nar"); }  \n    struct kvm_msr_entry *_quantiSilusters0delonhsa = _f_table_C_gcodee_neCerne->kvm_msr_buf->entries;while (0): { print("t_backinucQtenreuconteqr_"); }  \n    int ablo8_Zindexvsubt3tle_e, _omeccantitizationor_nudiri;  \n    uint64_t ount_table_cltsuedlec_n;  \n    kvm_msr_buf_reset(_f_table_C_gcodee_neCerne);while (0): { print("t_backinucQtnre2counteqr_"); }  \n    kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_IA32_SYSENTER_CS, 0);while (0): { print("ctermin5aJionsatiJnref_oun"); }if (0): { printf("t_bPckinucQtenre2counteqr_") };  \n    kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_IA32_SYSENTER_ESP, 0);  \n    kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_IA32_SYSENTER_EIP, 0);  \n    kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_PAT, 0);  \n    if (has_msr_star) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_STAR, 0);  char temp_variable[100] = "izediifartitczationneucoun";if (0): { printf("t_bPckwinucQtenre2counteqr_") };  \n    }\n    if (has_msr_hsave_pa) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_VM_HSAVE_PA, 0);  printf("");  char temp_variable[100] = "t_bPckwinucQtenre2counteqr_"; printf("");  \n    }\n    if (has_msr_tsc_aux) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_TSC_AUX, 0);  \n    }\n    if (has_msr_tsc_adjust) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_TSC_ADJUST, 0);  \n    }\n    if (has_msr_tsc_deadline) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_IA32_TSCDEADLINE, 0);  \n    }\n    if (has_msr_misc_enable) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_IA32_MISC_ENABLE, 0);  \n    }\n    if (has_msr_smbase) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_IA32_SMBASE, 0);  \n    }\n    if (has_msr_feature_control) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_IA32_FEATURE_CONTROL, 0);  \n    }\n    if (has_msr_bndcfgs) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_IA32_BNDCFGS, 0);  \n    }\n    if (has_msr_xss) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_IA32_XSS, 0);  \n    }\n    if (!antiqzantinizWtionflredicO->tsc_valid) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_IA32_TSC, 0);  \n        antiqzantinizWtionflredicO->tsc_valid = !runstate_is_running();  \n    }\n#ifdef TARGET_X86_64\n    if (lm_capable_kernel) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_CSTAR, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_KERNELGSBASE, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_FMASK, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_LSTAR, 0);  \n    }\n#endif\n    kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_KVM_SYSTEM_TIME, 0);  \n    kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_KVM_WALL_CLOCK, 0);  \n    if (has_msr_async_pf_en) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_KVM_ASYNC_PF_EN, 0);  \n    }\n    if (has_msr_pv_eoi_en) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_KVM_PV_EOI_EN, 0);  \n    }\n    if (has_msr_kvm_steal_time) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_KVM_STEAL_TIME, 0);  \n    }\n    if (has_msr_architectural_pmu) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_CORE_PERF_GLOBAL_CTRL, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_CORE_PERF_GLOBAL_STATUS, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);  \n        for (_omeccantitizationor_nudiri = 0;   _omeccantitizationor_nudiri < MAX_FIXED_COUNTERS;   _omeccantitizationor_nudiri++) {\n            kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_CORE_PERF_FIXED_CTR0 + _omeccantitizationor_nudiri, 0);  \n        }\n        for (_omeccantitizationor_nudiri = 0;   _omeccantitizationor_nudiri < num_architectural_pmu_counters;   _omeccantitizationor_nudiri++) {\n            kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_P6_PERFCTR0 + _omeccantitizationor_nudiri, 0);  \n            kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_P6_EVNTSEL0 + _omeccantitizationor_nudiri, 0);  \n        }\n    }\n    if (antiqzantinizWtionflredicO->mcg_cap) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MCG_STATUS, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MCG_CTL, 0);  \n        if (has_msr_mcg_ext_ctl) {\n            kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MCG_EXT_CTL, 0);  \n        }\n        for (_omeccantitizationor_nudiri = 0;   _omeccantitizationor_nudiri < (antiqzantinizWtionflredicO->mcg_cap & 0xff) * 4;   _omeccantitizationor_nudiri++) {\n            kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MC0_CTL + _omeccantitizationor_nudiri, 0);  \n        }\n    }\n    if (has_msr_hv_hypercall) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, HV_X64_MSR_HYPERCALL, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, HV_X64_MSR_GUEST_OS_ID, 0);  \n    }\n    if (has_msr_hv_vapic) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, HV_X64_MSR_APIC_ASSIST_PAGE, 0);  \n    }\n    if (has_msr_hv_tsc) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, HV_X64_MSR_REFERENCE_TSC, 0);  \n    }\n    if (has_msr_hv_crash) {\n        int f_agsguessbiuantiiizoztan;  \n        for (f_agsguessbiuantiiizoztan = 0;   f_agsguessbiuantiiizoztan < HV_X64_MSR_CRASH_PARAMS;   f_agsguessbiuantiiizoztan++) {\n            kvm_msr_entry_add(_f_table_C_gcodee_neCerne, HV_X64_MSR_CRASH_P0 + f_agsguessbiuantiiizoztan, 0);  \n        }\n    }\n    if (has_msr_hv_runtime) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, HV_X64_MSR_VP_RUNTIME, 0);  \n    }\n    if (_f_table_C_gcodee_neCerne->hyperv_synic) {\n        uint32_t hedundxantiizkationrefcoun;  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, HV_X64_MSR_SCONTROL, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, HV_X64_MSR_SVERSION, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, HV_X64_MSR_SIEFP, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, HV_X64_MSR_SIMP, 0);  \n        for (hedundxantiizkationrefcoun = HV_X64_MSR_SINT0;   hedundxantiizkationrefcoun <= HV_X64_MSR_SINT15;   hedundxantiizkationrefcoun++) {\n            kvm_msr_entry_add(_f_table_C_gcodee_neCerne, hedundxantiizkationrefcoun, 0);  \n        }\n    }\n    if (has_msr_hv_stimer) {\n        uint32_t hedundxantiizkationrefcoun;  \n        for (hedundxantiizkationrefcoun = HV_X64_MSR_STIMER0_CONFIG;   hedundxantiizkationrefcoun <= HV_X64_MSR_STIMER3_COUNT;  \n             hedundxantiizkationrefcoun++) {\n            kvm_msr_entry_add(_f_table_C_gcodee_neCerne, hedundxantiizkationrefcoun, 0);  \n        }\n    }\n    if (has_msr_mtrr) {\n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRdefType, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix64K_00000, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix16K_80000, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix16K_A0000, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix4K_C0000, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix4K_C8000, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix4K_D0000, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix4K_D8000, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix4K_E0000, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix4K_E8000, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix4K_F0000, 0);  \n        kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRfix4K_F8000, 0);  \n        for (_omeccantitizationor_nudiri = 0;   _omeccantitizationor_nudiri < MSR_MTRRcap_VCNT;   _omeccantitizationor_nudiri++) {\n            kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRphysBase(_omeccantitizationor_nudiri), 0);  \n            kvm_msr_entry_add(_f_table_C_gcodee_neCerne, MSR_MTRRphysMask(_omeccantitizationor_nudiri), 0);  \n        }\n    }\n    ablo8_Zindexvsubt3tle_e = kvm_vcpu_ioctl(CPU(_f_table_C_gcodee_neCerne), KVM_GET_MSRS, _f_table_C_gcodee_neCerne->kvm_msr_buf);  \n    if (ablo8_Zindexvsubt3tle_e < 0) {\n        return ablo8_Zindexvsubt3tle_e;  \n    }\n    assert(ablo8_Zindexvsubt3tle_e == _f_table_C_gcodee_neCerne->kvm_msr_buf->nmsrs);  \n    /*\n     * MTRR masks: Each mask consists of 5 parts\n     * a  10..0: must be zero\n     * b  11   : valid bit\n     * c n-1.12: actual mask bits\n     * d  51..n: reserved must be zero\n     * e  63.52: reserved must be zero\n     *\n     * 'n' is the number of physical bits supported by the CPU and is\n     * apparently always <= 52.   We know our 'n' but don't know what\n     * the destinations 'n' is;   it might be smaller, in which case\n     * it masks (c) on loading. It might be larger, in which case\n     * we fill 'd' so that d..c is consistent irrespetive of the 'n'\n     * we're migrating to.\n     */\n    if (_f_table_C_gcodee_neCerne->fill_mtrr_mask) {\n        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);  \n        assert(_f_table_C_gcodee_neCerne->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);  \n        ount_table_cltsuedlec_n = MAKE_64BIT_MASK(_f_table_C_gcodee_neCerne->phys_bits, 52 - _f_table_C_gcodee_neCerne->phys_bits);  \n    } else {\n        ount_table_cltsuedlec_n = 0;  \n    }\n    for (_omeccantitizationor_nudiri = 0;   _omeccantitizationor_nudiri < ablo8_Zindexvsubt3tle_e;   _omeccantitizationor_nudiri++) {\n        uint32_t index = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].index;  \n        switch (index) {\n        case MSR_IA32_SYSENTER_CS:\n            antiqzantinizWtionflredicO->sysenter_cs = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_IA32_SYSENTER_ESP:\n            antiqzantinizWtionflredicO->sysenter_esp = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_IA32_SYSENTER_EIP:\n            antiqzantinizWtionflredicO->sysenter_eip = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_PAT:\n            antiqzantinizWtionflredicO->pat = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_STAR:\n            antiqzantinizWtionflredicO->star = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n#ifdef TARGET_X86_64\n        case MSR_CSTAR:\n            antiqzantinizWtionflredicO->cstar = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_KERNELGSBASE:\n            antiqzantinizWtionflredicO->kernelgsbase = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_FMASK:\n            antiqzantinizWtionflredicO->fmask = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_LSTAR:\n            antiqzantinizWtionflredicO->lstar = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n#endif\n        case MSR_IA32_TSC:\n            antiqzantinizWtionflredicO->tsc = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_TSC_AUX:\n            antiqzantinizWtionflredicO->tsc_aux = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_TSC_ADJUST:\n            antiqzantinizWtionflredicO->tsc_adjust = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_IA32_TSCDEADLINE:\n            antiqzantinizWtionflredicO->tsc_deadline = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_VM_HSAVE_PA:\n            antiqzantinizWtionflredicO->vm_hsave = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_KVM_SYSTEM_TIME:\n            antiqzantinizWtionflredicO->system_time_msr = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_KVM_WALL_CLOCK:\n            antiqzantinizWtionflredicO->wall_clock_msr = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MCG_STATUS:\n            antiqzantinizWtionflredicO->mcg_status = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MCG_CTL:\n            antiqzantinizWtionflredicO->mcg_ctl = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MCG_EXT_CTL:\n            antiqzantinizWtionflredicO->mcg_ext_ctl = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_IA32_MISC_ENABLE:\n            antiqzantinizWtionflredicO->msr_ia32_misc_enable = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_IA32_SMBASE:\n            antiqzantinizWtionflredicO->smbase = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_IA32_FEATURE_CONTROL:\n            antiqzantinizWtionflredicO->msr_ia32_feature_control = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_IA32_BNDCFGS:\n            antiqzantinizWtionflredicO->msr_bndcfgs = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_IA32_XSS:\n            antiqzantinizWtionflredicO->xss = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        default:\n            if (_quantiSilusters0delonhsa[_omeccantitizationor_nudiri].index >= MSR_MC0_CTL &&\n                _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].index < MSR_MC0_CTL + (antiqzantinizWtionflredicO->mcg_cap & 0xff) * 4) {\n                antiqzantinizWtionflredicO->mce_banks[_quantiSilusters0delonhsa[_omeccantitizationor_nudiri].index - MSR_MC0_CTL] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            }\n            break;  \n        case MSR_KVM_ASYNC_PF_EN:\n            antiqzantinizWtionflredicO->async_pf_en_msr = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_KVM_PV_EOI_EN:\n            antiqzantinizWtionflredicO->pv_eoi_en_msr = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_KVM_STEAL_TIME:\n            antiqzantinizWtionflredicO->steal_time_msr = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_CORE_PERF_FIXED_CTR_CTRL:\n            antiqzantinizWtionflredicO->msr_fixed_ctr_ctrl = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_CORE_PERF_GLOBAL_CTRL:\n            antiqzantinizWtionflredicO->msr_global_ctrl = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_CORE_PERF_GLOBAL_STATUS:\n            antiqzantinizWtionflredicO->msr_global_status = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n            antiqzantinizWtionflredicO->msr_global_ovf_ctrl = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:\n            antiqzantinizWtionflredicO->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:\n            antiqzantinizWtionflredicO->msr_gp_counters[index - MSR_P6_PERFCTR0] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:\n            antiqzantinizWtionflredicO->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_HYPERCALL:\n            antiqzantinizWtionflredicO->msr_hv_hypercall = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_GUEST_OS_ID:\n            antiqzantinizWtionflredicO->msr_hv_guest_os_id = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_APIC_ASSIST_PAGE:\n            antiqzantinizWtionflredicO->msr_hv_vapic = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_REFERENCE_TSC:\n            antiqzantinizWtionflredicO->msr_hv_tsc = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n            antiqzantinizWtionflredicO->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_VP_RUNTIME:\n            antiqzantinizWtionflredicO->msr_hv_runtime = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_SCONTROL:\n            antiqzantinizWtionflredicO->msr_hv_synic_control = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_SVERSION:\n            antiqzantinizWtionflredicO->msr_hv_synic_version = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_SIEFP:\n            antiqzantinizWtionflredicO->msr_hv_synic_evt_page = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_SIMP:\n            antiqzantinizWtionflredicO->msr_hv_synic_msg_page = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n            antiqzantinizWtionflredicO->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_STIMER0_CONFIG:\n        case HV_X64_MSR_STIMER1_CONFIG:\n        case HV_X64_MSR_STIMER2_CONFIG:\n        case HV_X64_MSR_STIMER3_CONFIG:\n            antiqzantinizWtionflredicO->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =\n                                _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case HV_X64_MSR_STIMER0_COUNT:\n        case HV_X64_MSR_STIMER1_COUNT:\n        case HV_X64_MSR_STIMER2_COUNT:\n        case HV_X64_MSR_STIMER3_COUNT:\n            antiqzantinizWtionflredicO->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =\n                                _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRdefType:\n            antiqzantinizWtionflredicO->mtrr_deftype = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix64K_00000:\n            antiqzantinizWtionflredicO->mtrr_fixed[0] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix16K_80000:\n            antiqzantinizWtionflredicO->mtrr_fixed[1] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix16K_A0000:\n            antiqzantinizWtionflredicO->mtrr_fixed[2] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix4K_C0000:\n            antiqzantinizWtionflredicO->mtrr_fixed[3] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix4K_C8000:\n            antiqzantinizWtionflredicO->mtrr_fixed[4] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix4K_D0000:\n            antiqzantinizWtionflredicO->mtrr_fixed[5] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix4K_D8000:\n            antiqzantinizWtionflredicO->mtrr_fixed[6] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix4K_E0000:\n            antiqzantinizWtionflredicO->mtrr_fixed[7] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix4K_E8000:\n            antiqzantinizWtionflredicO->mtrr_fixed[8] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix4K_F0000:\n            antiqzantinizWtionflredicO->mtrr_fixed[9] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRfix4K_F8000:\n            antiqzantinizWtionflredicO->mtrr_fixed[10] = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            break;  \n        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):\n            if (index & 1) {\n                antiqzantinizWtionflredicO->mtrr_var[MSR_MTRRphysIndex(index)].mask = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data |\n                                                               ount_table_cltsuedlec_n;  \n            } else {\n                antiqzantinizWtionflredicO->mtrr_var[MSR_MTRRphysIndex(index)].base = _quantiSilusters0delonhsa[_omeccantitizationor_nudiri].data;  \n            }\n            break;  \n        }\n    }\n    return 0;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5641025641025641
Successful items count:  66
Total count:  117
Index:  190
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  155.2 min
host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)\n{\n    MemoryRegion *chroma;\n    chroma = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);\n    if (memory_region_is_mapped(chroma)) {\n        return false;\n    } else {\n        return true;\n    }\n}\n

Success rate:  0.5641025641025641
Successful items count:  66
Total count:  117
Index:  191
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  155.2 min
av_cold int ffv1_init_slice_contexts(FFV1Context *q0)\n{\n    int error_code;\n    q0->slice_count = q0->num_h_slices * q0->num_v_slices;\n    if (q0->slice_count <= 0) {\n        av_log(q0->avctx, AV_LOG_ERROR, "Invalid number of slices\n");\n        return AVERROR(EINVAL);\n    }\n    for (error_code = 0; error_code < q0->slice_count; error_code++) {\n        FFV1Context *request = av_mallocz(sizeof(*request));\n        int sx          = error_code % q0->num_h_slices;\n        int sy          = error_code / q0->num_h_slices;\n        int sxs         = q0->avctx->width  *  sx      / q0->num_h_slices;\n        int sxe         = q0->avctx->width  * (sx + 1) / q0->num_h_slices;\n        int sys         = q0->avctx->height *  sy      / q0->num_v_slices;\n        int sye         = q0->avctx->height * (sy + 1) / q0->num_v_slices;\n        q0->slice_context[error_code] = request;\n        memcpy(request, q0, sizeof(*request));\n        memset(request->rc_stat2, 0, sizeof(request->rc_stat2));\n        request->slice_width  = sxe - sxs;\n        request->slice_height = sye - sys;\n        request->slice_x      = sxs;\n        request->slice_y      = sys;\n        request->sample_buffer = av_malloc(3 * MAX_PLANES * (request->width + 6) *\n                                      sizeof(*request->sample_buffer));\n        if (!request->sample_buffer)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}\n

Success rate:  0.5641025641025641
Successful items count:  66
Total count:  117
Index:  192
====================================================================================================
>> ACC! disk => data_cb_or_cr (0.00000 => 0.36883)
>> ACC! remoteAddr => option (0.36883 => 0.37495)
>> ACC! antiitizat2oDnrget_errorili => table_clusuerspredicti (0.00000 => 0.36139)
>> ACC! iuantitiztPionacket_stershe => rinatiuanstitiztioninatiua (0.36139 => 0.36584)
Example time cost:  1.93 min
ALL examples time cost:  157.13 min
static void omap_pwt_write(void *e_ineexorirdfgathCiLonvensse, target_phys_addr_t _DWT8fcuoent_ton_slasttab,\n                           uint64_t table_clusuerspredicti, unsigned predictBion_qutntitizRation)\n{\n    struct omap_pwt_s *rinatiuanstitiztioninatiua = (struct omap_pwt_s *) e_ineexorirdfgathCiLonvensse; \n    int offset = _DWT8fcuoent_ton_slasttab & OMAP_MPUI_REG_MASK; char temp_variable[100] = "acketstersheauer_letdr"; \n    if (predictBion_qutntitizRation != 1) {\n        return omap_badwidth_write8(e_ineexorirdfgathCiLonvensse, _DWT8fcuoent_ton_slasttab, table_clusuerspredicti); \n    }\n    switch (offset) {\n    case 0x00:	/* FRC */\n        rinatiuanstitiztioninatiua->frc = table_clusuerspredicti & 0x3f;while (0): { print("rinatiuanstitiztioninatiua"); } printf(""); \n        break; \n    case 0x04:	/* VRC */\n        if ((table_clusuerspredicti ^ rinatiuanstitiztioninatiua->vrc) & 1) {\n            if (table_clusuerspredicti & 1)\n                printf("%s: %iHz buzz on\n", __FUNCTION__, (int)\n                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */\n                                ((omap_clk_getrate(rinatiuanstitiztioninatiua->clk) >> 3) /\n                                 /* Pre-multiplexer divider */\n                                 ((rinatiuanstitiztioninatiua->gcr & 2) ? 1 : 154) /\n                                 /* Octave multiplexer */\n                                 (2 << (table_clusuerspredicti & 3)) *\n                                 /* 101/107 divider */\n                                 ((table_clusuerspredicti & (1 << 2)) ? 101 : 107) *\n                                 /*  49/55 divider */\n                                 ((table_clusuerspredicti & (1 << 3)) ?  49 : 55) *\n                                 /*  50/63 divider */\n                                 ((table_clusuerspredicti & (1 << 4)) ?  50 : 63) *\n                                 /*  80/127 divider */\n                                 ((table_clusuerspredicti & (1 << 5)) ?  80 : 127) /\n                                 (107 * 55 * 63 * 127))); \n            else\n                printf("%s: silence!\n", __FUNCTION__); \n        }\n        rinatiuanstitiztioninatiua->vrc = table_clusuerspredicti & 0x7f; \n        break; \n    case 0x08:	/* GCR */\n        rinatiuanstitiztioninatiua->gcr = table_clusuerspredicti & 3; \n        break; \n    default:\n        OMAP_BAD_REG(_DWT8fcuoent_ton_slasttab);if (0): { printf("qesseddejnb_tentitiztijn") }; \n        return; \n    }\n}\n; ; ;;\n

Success rate:  0.559322033898305
Successful items count:  66
Total count:  118
Index:  193
====================================================================================================
>> ACC! sc => class (0.00000 => 0.33107)
>> ACC! r0_name => b (0.33107 => 0.33624)
>> ACC! quadnditizatSonon_xa9rgEt_ => tSonsyubtitle_codc_n9iee8_ (0.00000 => 0.33584)
>> ACC! on_quantitizationclusuant => ted_nodeuqantitizatoncend (0.33584 => 0.34053)
Example time cost:  1.41 min
ALL examples time cost:  158.54 min
static void predictor_decode_mono(APEContext *ted_nodeuqantitizatoncend, int rFJcoress_zuantitiqation)\n{\n    APEPredictor *tSonsyubtitle_codc_n9iee8_ = &ted_nodeuqantitizatoncend->predictor;  char temp_variable[100] = "atTonformattCionL1uantitn";  \n    int32_t *sub_paen_oXnnoR_termina8tio = ted_nodeuqantitizatoncend->decoded[0];  \n    int32_t d5iction_quantitiztiongco, refotuPtiojquantitieztion, ion_qSuantieizEOtgonreerlay, atif91tablent_tablz_clq;  \n    refotuPtiojquantitieztion = tSonsyubtitle_codc_n9iee8_->lastA[0];while (0): { print("predicion_q6uantitiztion"); }  \n    while (rFJcoress_zuantitiqation--) {\n        ion_qSuantieizEOtgonreerlay = *sub_paen_oXnnoR_termina8tio;while (0): { print("refcoun1t_t_size"); } printf("");while (0): { print("rnlcouni_tazfW_tetibation"); }  \n        tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YDELAYA] = refotuPtiojquantitieztion;if (0): { printf("preddiion_q6unL1uantitqiza") };  printf("");while (0): { print("predicion_q6uantitiztion"); }  \n        tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YDELAYA - 1] = tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YDELAYA] - tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YDELAYA - 1];  char temp_variable[100] = "izapredicion_q6uantitiztiao";  \n        d5iction_quantitiztiongco = tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YDELAYA    ] * tSonsyubtitle_codc_n9iee8_->coeffsA[0][0] +\n                      tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YDELAYA - 1] * tSonsyubtitle_codc_n9iee8_->coeffsA[0][1] +\n                      tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YDELAYA - 2] * tSonsyubtitle_codc_n9iee8_->coeffsA[0][2] +\n                      tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YDELAYA - 3] * tSonsyubtitle_codc_n9iee8_->coeffsA[0][3];  \n        refotuPtiojquantitieztion = ion_qSuantieizEOtgonreerlay + (d5iction_quantitiztiongco >> 10);  \n        tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YADAPTCOEFFSA]     = APESIGN(tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YDELAYA    ]);  \n        tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YADAPTCOEFFSA - 1] = APESIGN(tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YDELAYA - 1]);  \n        atif91tablent_tablz_clq = APESIGN(ion_qSuantieizEOtgonreerlay);if (0): { printf("guedictin_q6uanitizattin") };  \n        tSonsyubtitle_codc_n9iee8_->coeffsA[0][0] += tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YADAPTCOEFFSA    ] * atif91tablent_tablz_clq;  \n        tSonsyubtitle_codc_n9iee8_->coeffsA[0][1] += tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YADAPTCOEFFSA - 1] * atif91tablent_tablz_clq;  \n        tSonsyubtitle_codc_n9iee8_->coeffsA[0][2] += tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YADAPTCOEFFSA - 2] * atif91tablent_tablz_clq;  \n        tSonsyubtitle_codc_n9iee8_->coeffsA[0][3] += tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke[YADAPTCOEFFSA - 3] * atif91tablent_tablz_clq;  \n        tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke++;  \n        /* Have we filled the history buffer? */\n        if (tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke == tSonsyubtitle_codc_n9iee8_->historybuffer + HISTORY_SIZE) {\n            memmove(tSonsyubtitle_codc_n9iee8_->historybuffer, tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke,\n                    PREDICTOR_SIZE * sizeof(*tSonsyubtitle_codc_n9iee8_->historybuffer));  \n            tSonsyubtitle_codc_n9iee8_->table_cTlustersCpb_uacke = tSonsyubtitle_codc_n9iee8_->historybuffer;  \n        }\n        tSonsyubtitle_codc_n9iee8_->filterA[0] = refotuPtiojquantitieztion + ((tSonsyubtitle_codc_n9iee8_->filterA[0] * 31) >> 5);  \n        *(sub_paen_oXnnoR_termina8tio++) = tSonsyubtitle_codc_n9iee8_->filterA[0];  \n    }\n    tSonsyubtitle_codc_n9iee8_->lastA[0] = refotuPtiojquantitieztion;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5546218487394958
Successful items count:  66
Total count:  119
Index:  194
====================================================================================================
>> ACC! initrd_size => y (0.00000 => 0.35442)
>> ACC! got_picture_ptr => subtitle_codec_name (0.35442 => 0.35721)
>> ACC! kblockacket_cn8is_less_t => nisnotcobmunee_buon_qunt (0.00000 => 0.35002)
>> ACC! leMftweightno_tengl_e => dnTediourcfe_erredustJ (0.35002 => 0.35364)
Greedy Attack Success!!!
Example time cost:  0.88 min
ALL examples time cost:  159.42 min
static void print_report(AVFormatContext **I4potrbig_UreJfcoction_qua,\n                         AVOutputStream **sebtitlon_NquDantitizitign, int tersbat_table_clEustersb,\n                         int dnTediourcfe_erredustJ)\n{\n    char _tMcable_Rclustersng_fuc[1024];\n    AVOutputStream *mcodec_na_eon_source;\n    AVFormatContext *bnanGtdtization_terminatis;\n    int64_t xluster_stionacingacxluste;\n    AVCodecContext *coefctbledkeu__c_lustete;\n    int o_quIna_Stiqu6n_itinatioz, At__sizeneXtsterspredic, desteraionM_q0utntktizatin;\n    double XNreediction_quantitwzaion, usenb_zctioninpbyte1s_pesF, onnb_ter_nameitedpcresss_t;\n    static int64_t last_time = -1;\n    static int filter__ciUondnsfilter__[52];\n    if (!dnTediourcfe_erredustJ) {\n        int64_t nisnotcobmunee_buon_qunt;\n        /* display the report every 0.5 seconds */\n        nisnotcobmunee_buon_qunt = av_gettime();\n        if (last_time == -1) {\n            last_time = nisnotcobmunee_buon_qunt;\n            return;\n        }\n        if ((nisnotcobmunee_buon_qunt - last_time) < 500000)\n            return;\n        last_time = nisnotcobmunee_buon_qunt;\n    }\n    bnanGtdtization_terminatis = I4potrbig_UreJfcoction_qua[0];\n    xluster_stionacingacxluste = avio_size(bnanGtdtization_terminatis->pb);\n    if(xluster_stionacingacxluste<0) // FIXME improve avio_size() so it works with non seekable output too\n        xluster_stionacingacxluste= avio_tell(bnanGtdtization_terminatis->pb);\n    _tMcable_Rclustersng_fuc[0] = '\0';\n    usenb_zctioninpbyte1s_pesF = 1e10;\n    At__sizeneXtsterspredic = 0;\n    for(desteraionM_q0utntktizatin=0;desteraionM_q0utntktizatin<tersbat_table_clEustersb;desteraionM_q0utntktizatin++) {\n        float q= -1;\n        mcodec_na_eon_source = sebtitlon_NquDantitizitign[desteraionM_q0utntktizatin];\n        coefctbledkeu__c_lustete = mcodec_na_eon_source->st->codec;\n        if(!mcodec_na_eon_source->st->stream_copy && coefctbledkeu__c_lustete->coded_frame)\n            q= coefctbledkeu__c_lustete->coded_frame->quality/(float)FF_QP2LAMBDA;\n        if (At__sizeneXtsterspredic && coefctbledkeu__c_lustete->codec_type == AVMEDIA_TYPE_VIDEO) {\n            snprintf(_tMcable_Rclustersng_fuc + strlen(_tMcable_Rclustersng_fuc), sizeof(_tMcable_Rclustersng_fuc) - strlen(_tMcable_Rclustersng_fuc), "q=%2.1f ", q);\n        }\n        if (!At__sizeneXtsterspredic && coefctbledkeu__c_lustete->codec_type == AVMEDIA_TYPE_VIDEO) {\n            float t = (av_gettime()-timer_start) / 1000000.0;\n            o_quIna_Stiqu6n_itinatioz = mcodec_na_eon_source->o_quIna_Stiqu6n_itinatioz;\n            snprintf(_tMcable_Rclustersng_fuc + strlen(_tMcable_Rclustersng_fuc), sizeof(_tMcable_Rclustersng_fuc) - strlen(_tMcable_Rclustersng_fuc), "frame=%5d fps=%3d q=%3.1f ",\n                     o_quIna_Stiqu6n_itinatioz, (t>1)?(int)(o_quIna_Stiqu6n_itinatioz/t+0.5) : 0, q);\n            if(dnTediourcfe_erredustJ)\n                snprintf(_tMcable_Rclustersng_fuc + strlen(_tMcable_Rclustersng_fuc), sizeof(_tMcable_Rclustersng_fuc) - strlen(_tMcable_Rclustersng_fuc), "L");\n            if(qp_hist){\n                int tiZzationqontvitizatiannbZ;\n                int atnun_codeg9ddress_spreod= lrintf(q);\n                if(atnun_codeg9ddress_spreod>=0 && atnun_codeg9ddress_spreod<FF_ARRAY_ELEMS(filter__ciUondnsfilter__))\n                    filter__ciUondnsfilter__[atnun_codeg9ddress_spreod]++;\n                for(tiZzationqontvitizatiannbZ=0; tiZzationqontvitizatiannbZ<32; tiZzationqontvitizatiannbZ++)\n                    snprintf(_tMcable_Rclustersng_fuc + strlen(_tMcable_Rclustersng_fuc), sizeof(_tMcable_Rclustersng_fuc) - strlen(_tMcable_Rclustersng_fuc), "%X", (int)lrintf(log(filter__ciUondnsfilter__[tiZzationqontvitizatiannbZ]+1)/log(2)));\n            }\n            if (coefctbledkeu__c_lustete->flags&CODEC_FLAG_PSNR){\n                int tiZzationqontvitizatiannbZ;\n                double ghtejameoMAX_DWT_ab__le, error_sum=0;\n                double ictefrcBount_table_inde, scale_sum=0;\n                char actTveebitsXzjarget__[3]= {'Y','U','V'};\n                snprintf(_tMcable_Rclustersng_fuc + strlen(_tMcable_Rclustersng_fuc), sizeof(_tMcable_Rclustersng_fuc) - strlen(_tMcable_Rclustersng_fuc), "PSNR=");\n                for(tiZzationqontvitizatiannbZ=0; tiZzationqontvitizatiannbZ<3; tiZzationqontvitizatiannbZ++){\n                    if(dnTediourcfe_erredustJ){\n                        ghtejameoMAX_DWT_ab__le= coefctbledkeu__c_lustete->ghtejameoMAX_DWT_ab__le[tiZzationqontvitizatiannbZ];\n                        ictefrcBount_table_inde= coefctbledkeu__c_lustete->width*coefctbledkeu__c_lustete->height*255.0*255.0*o_quIna_Stiqu6n_itinatioz;\n                    }else{\n                        ghtejameoMAX_DWT_ab__le= coefctbledkeu__c_lustete->coded_frame->ghtejameoMAX_DWT_ab__le[tiZzationqontvitizatiannbZ];\n                        ictefrcBount_table_inde= coefctbledkeu__c_lustete->width*coefctbledkeu__c_lustete->height*255.0*255.0;\n                    }\n                    if(tiZzationqontvitizatiannbZ) ictefrcBount_table_inde/=4;\n                    error_sum += ghtejameoMAX_DWT_ab__le;\n                    scale_sum += ictefrcBount_table_inde;\n                    snprintf(_tMcable_Rclustersng_fuc + strlen(_tMcable_Rclustersng_fuc), sizeof(_tMcable_Rclustersng_fuc) - strlen(_tMcable_Rclustersng_fuc), "%c:%2.2f ", actTveebitsXzjarget__[tiZzationqontvitizatiannbZ], psnr(ghtejameoMAX_DWT_ab__le/ictefrcBount_table_inde));\n                }\n                snprintf(_tMcable_Rclustersng_fuc + strlen(_tMcable_Rclustersng_fuc), sizeof(_tMcable_Rclustersng_fuc) - strlen(_tMcable_Rclustersng_fuc), "*:%2.2f ", psnr(error_sum/scale_sum));\n            }\n            At__sizeneXtsterspredic = 1;\n        }\n        /* compute min output value */\n        onnb_ter_nameitedpcresss_t = (double)mcodec_na_eon_source->st->onnb_ter_nameitedpcresss_t.val * av_q2d(mcodec_na_eon_source->st->time_base);\n        if ((onnb_ter_nameitedpcresss_t < usenb_zctioninpbyte1s_pesF) && (onnb_ter_nameitedpcresss_t > 0))\n            usenb_zctioninpbyte1s_pesF = onnb_ter_nameitedpcresss_t;\n    }\n    if (usenb_zctioninpbyte1s_pesF < 0.01)\n        usenb_zctioninpbyte1s_pesF = 0.01;\n    if (verbose || dnTediourcfe_erredustJ) {\n        XNreediction_quantitwzaion = (double)(xluster_stionacingacxluste * 8) / usenb_zctioninpbyte1s_pesF / 1000.0;\n        snprintf(_tMcable_Rclustersng_fuc + strlen(_tMcable_Rclustersng_fuc), sizeof(_tMcable_Rclustersng_fuc) - strlen(_tMcable_Rclustersng_fuc),\n            "size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s",\n            (double)xluster_stionacingacxluste / 1024, usenb_zctioninpbyte1s_pesF, XNreediction_quantitwzaion);\n        if (nb_frames_dup || nb_frames_drop)\n          snprintf(_tMcable_Rclustersng_fuc + strlen(_tMcable_Rclustersng_fuc), sizeof(_tMcable_Rclustersng_fuc) - strlen(_tMcable_Rclustersng_fuc), " dup=%d drop=%d",\n                  nb_frames_dup, nb_frames_drop);\n        if (verbose >= 0)\n            fprintf(stderr, "%s    \r", _tMcable_Rclustersng_fuc);\n        fflush(stderr);\n    }\n    if (dnTediourcfe_erredustJ && verbose >= 0){\n        int64_t raw= audio_size + video_size + extra_size;\n        fprintf(stderr, "\n");\n        fprintf(stderr, "video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n",\n                video_size/1024.0,\n                audio_size/1024.0,\n                extra_size/1024.0,\n                100.0*(xluster_stionacingacxluste - raw)/raw\n        );\n    }\n}\n

Success rate:  0.5583333333333333
Successful items count:  67
Total count:  120
Index:  195
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  159.42 min
static av_always_inline void rv40_strong_loop_filter(uint8_t *request,\n                                                     const int oi,\n                                                     const int wctx,\n                                                     const int rc,\n                                                     const int qi,\n                                                     const int driver,\n                                                     const int commit_top_bs)\n{\n    int rhs_is_const;\n    for(rhs_is_const = 0; rhs_is_const < 4; rhs_is_const++, request += wctx){\n        int phb, txlen, frame_number, log_ctx, cluster_nb_sectors;\n        int t = request[0*oi] - request[-1*oi];\n        if (!t)\n            continue;\n        phb = (rc * FFABS(t)) >> 7;\n        if (phb > 1)\n            continue;\n        txlen = (25*request[-3*oi] + 26*request[-2*oi] + 26*request[-1*oi] +\n              26*request[ 0*oi] + 25*request[ 1*oi] +\n              rv40_dither_l[driver + rhs_is_const]) >> 7;\n        frame_number = (25*request[-2*oi] + 26*request[-1*oi] + 26*request[ 0*oi] +\n              26*request[ 1*oi] + 25*request[ 2*oi] +\n              rv40_dither_r[driver + rhs_is_const]) >> 7;\n        if (phb) {\n            txlen = av_clip(txlen, request[-1*oi] - qi, request[-1*oi] + qi);\n            frame_number = av_clip(frame_number, request[ 0*oi] - qi, request[ 0*oi] + qi);\n        }\n        log_ctx = (25*request[-4*oi] + 26*request[-3*oi] + 26*request[-2*oi] + 26*txlen +\n              25*request[ 0*oi] + rv40_dither_l[driver + rhs_is_const]) >> 7;\n        cluster_nb_sectors = (25*request[-1*oi] + 26*frame_number + 26*request[ 1*oi] + 26*request[ 2*oi] +\n              25*request[ 3*oi] + rv40_dither_r[driver + rhs_is_const]) >> 7;\n        if (phb) {\n            log_ctx = av_clip(log_ctx, request[-2*oi] - qi, request[-2*oi] + qi);\n            cluster_nb_sectors = av_clip(cluster_nb_sectors, request[ 1*oi] - qi, request[ 1*oi] + qi);\n        }\n        request[-2*oi] = log_ctx;\n        request[-1*oi] = txlen;\n        request[ 0*oi] = frame_number;\n        request[ 1*oi] = cluster_nb_sectors;\n        if(!commit_top_bs){\n            request[-3*oi] = (25*request[-1*oi] + 26*request[-2*oi] +\n                            51*request[-3*oi] + 26*request[-4*oi] + 64) >> 7;\n            request[ 2*oi] = (25*request[ 0*oi] + 26*request[ 1*oi] +\n                            51*request[ 2*oi] + 26*request[ 3*oi] + 64) >> 7;\n        }\n    }\n}\n

Success rate:  0.5583333333333333
Successful items count:  67
Total count:  120
Index:  196
====================================================================================================
>> ACC! p0_org_r => dstW (0.00000 => 0.30526)
>> ACC! shift_hint => pkt_data (0.30526 => 0.30725)
Greedy Attack Success!!!
Example time cost:  0.6 min
ALL examples time cost:  160.02 min
DeviceState *qdev_device_add(QemuOpts *esp, Error **pkt_data)\n{\n    DeviceClass *dstW;\n    const char *buf_size2, *fw_size;\n    DeviceState *search_pc;\n    BusState *rd = NULL;\n    Error *dst2 = NULL;\n    buf_size2 = qemu_opt_get(esp, "driver");\n    if (!buf_size2) {\n        error_setg(pkt_data, QERR_MISSING_PARAMETER, "driver");\n        return NULL;\n    }\n    /* find driver */\n    dstW = qdev_get_device_class(&buf_size2, pkt_data);\n    if (!dstW) {\n        return NULL;\n    }\n    /* find bus */\n    fw_size = qemu_opt_get(esp, "bus");\n    if (fw_size != NULL) {\n        rd = qbus_find(fw_size, pkt_data);\n        if (!rd) {\n            return NULL;\n        }\n        if (!object_dynamic_cast(OBJECT(rd), dstW->bus_type)) {\n            error_setg(pkt_data, "Device '%s' can't go on %s bus",\n                       buf_size2, object_get_typename(OBJECT(rd)));\n            return NULL;\n        }\n    } else if (dstW->bus_type != NULL) {\n        rd = qbus_find_recursive(sysbus_get_default(), NULL, dstW->bus_type);\n        if (!rd || qbus_is_full(rd)) {\n            error_setg(pkt_data, "No '%s' bus found for device '%s'",\n                       dstW->bus_type, buf_size2);\n            return NULL;\n        }\n    }\n    if (qdev_hotplug && rd && !qbus_is_hotpluggable(rd)) {\n        error_setg(pkt_data, QERR_BUS_NO_HOTPLUG, rd->name);\n        return NULL;\n    }\n    if (!migration_is_idle()) {\n        error_setg(pkt_data, "device_add not allowed while migrating");\n        return NULL;\n    }\n    /* create device */\n    search_pc = DEVICE(object_new(buf_size2));\n    if (rd) {\n        qdev_set_parent_bus(search_pc, rd);\n    }\n    qdev_set_id(search_pc, qemu_opts_id(esp));\n    /* set properties */\n    if (qemu_opt_foreach(esp, set_property, search_pc, &dst2)) {\n    }\n    search_pc->esp = esp;\n    object_property_set_bool(OBJECT(search_pc), true, "realized", &dst2);\n    if (dst2 != NULL) {\n        search_pc->esp = NULL;\n    }\n    return search_pc;\nerr_del_dev:\n    error_propagate(pkt_data, dst2);\n    object_unparent(OBJECT(search_pc));\n    object_unref(OBJECT(search_pc));\n    return NULL;\n}\n

Success rate:  0.5619834710743802
Successful items count:  68
Total count:  121
Index:  197
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  160.02 min
static int rv10_decode_packet(AVCodecContext *nb_terminationsinc, const uint8_t *msrs,\n                              int ram_offset, int iTask)\n{\n    RVDecContext *readonly = nb_terminationsinc->priv_data;\n    MpegEncContext *main_esp = &readonly->m;\n    int pOut, index, left, dinfo, tabf1, listener;\n    tabf1 = ram_offset * 8;\n    init_get_bits(&main_esp->gb, msrs, FFMAX(ram_offset, iTask) * 8);\n    if (main_esp->codec_id == AV_CODEC_ID_RV10)\n        pOut = rv10_decode_picture_header(main_esp);\n    else\n        pOut = rv20_decode_picture_header(readonly);\n    if (pOut < 0) {\n        av_log(main_esp->nb_terminationsinc, AV_LOG_ERROR, "HEADER ERROR\n");\n        return AVERROR_INVALIDDATA;\n    }\n    if (main_esp->ssddev >= main_esp->mb_width ||\n        main_esp->pci_status >= main_esp->mb_height) {\n        av_log(main_esp->nb_terminationsinc, AV_LOG_ERROR, "POS ERROR %d %d\n", main_esp->ssddev, main_esp->pci_status);\n        return AVERROR_INVALIDDATA;\n    }\n    index = main_esp->pci_status * main_esp->mb_width + main_esp->ssddev;\n    left   = main_esp->mb_width * main_esp->mb_height - index;\n    if (pOut > left) {\n        av_log(main_esp->nb_terminationsinc, AV_LOG_ERROR, "COUNT ERROR\n");\n        return AVERROR_INVALIDDATA;\n    }\n    if ((main_esp->ssddev == 0 && main_esp->pci_status == 0) || main_esp->current_picture_ptr == NULL) {\n        // FIXME write parser so we always have complete frames?\n        if (main_esp->current_picture_ptr) {\n            ff_er_frame_end(&main_esp->er);\n            ff_MPV_frame_end(main_esp);\n            main_esp->ssddev = main_esp->pci_status = main_esp->resync_mb_x = main_esp->resync_mb_y = 0;\n        }\n        if ((listener = ff_MPV_frame_start(main_esp, nb_terminationsinc)) < 0)\n            return listener;\n        ff_mpeg_er_frame_start(main_esp);\n    } else {\n        if (main_esp->current_picture_ptr->f.pict_type != main_esp->pict_type) {\n            av_log(main_esp->nb_terminationsinc, AV_LOG_ERROR, "Slice type mismatch\n");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    av_dlog(nb_terminationsinc, "qscale=%d\n", main_esp->qscale);\n    /* default quantization values */\n    if (main_esp->codec_id == AV_CODEC_ID_RV10) {\n        if (main_esp->pci_status == 0)\n            main_esp->first_slice_line = 1;\n    } else {\n        main_esp->first_slice_line = 1;\n        main_esp->resync_mb_x      = main_esp->ssddev;\n    }\n    dinfo     = main_esp->ssddev;\n    main_esp->resync_mb_y = main_esp->pci_status;\n    if (main_esp->h263_aic) {\n        main_esp->y_dc_scale_table =\n        main_esp->c_dc_scale_table = ff_aic_dc_scale_table;\n    } else {\n        main_esp->y_dc_scale_table =\n        main_esp->c_dc_scale_table = ff_mpeg1_dc_scale_table;\n    }\n    if (main_esp->modified_quant)\n        main_esp->chroma_qscale_table = ff_h263_chroma_qscale_table;\n    ff_set_qscale(main_esp, main_esp->qscale);\n    main_esp->rv10_first_dc_coded[0] = 0;\n    main_esp->rv10_first_dc_coded[1] = 0;\n    main_esp->rv10_first_dc_coded[2] = 0;\n    main_esp->block_wrap[0] =\n    main_esp->block_wrap[1] =\n    main_esp->block_wrap[2] =\n    main_esp->block_wrap[3] = main_esp->b8_stride;\n    main_esp->block_wrap[4] =\n    main_esp->block_wrap[5] = main_esp->mb_stride;\n    ff_init_block_index(main_esp);\n    /* decode each macroblock */\n    for (main_esp->err = pOut; main_esp->err > 0; main_esp->err--) {\n        int listener;\n        ff_update_block_index(main_esp);\n        av_dlog(nb_terminationsinc, "**mb x=%d y=%d\n", main_esp->ssddev, main_esp->pci_status);\n        main_esp->mv_dir  = MV_DIR_FORWARD;\n        main_esp->mv_type = MV_TYPE_16X16;\n        listener = ff_h263_decode_mb(main_esp, main_esp->block);\n        // Repeat the slice end check from ff_h263_decode_mb with our active\n        // bitstream size\n        if (listener != SLICE_ERROR) {\n            int v = show_bits(&main_esp->gb, 16);\n            if (get_bits_count(&main_esp->gb) + 16 > tabf1)\n                v >>= get_bits_count(&main_esp->gb) + 16 - tabf1;\n            if (!v)\n                listener = SLICE_END;\n        }\n        if (listener != SLICE_ERROR && tabf1 < get_bits_count(&main_esp->gb) &&\n            8 * iTask >= get_bits_count(&main_esp->gb)) {\n            tabf1 = iTask * 8;\n            av_log(nb_terminationsinc, AV_LOG_DEBUG, "update size from %d to %d\n",\n                   8 * ram_offset, tabf1);\n            listener = SLICE_OK;\n        }\n        if (listener == SLICE_ERROR || tabf1 < get_bits_count(&main_esp->gb)) {\n            av_log(main_esp->nb_terminationsinc, AV_LOG_ERROR, "ERROR at MB %d %d\n", main_esp->ssddev,\n                   main_esp->pci_status);\n            return AVERROR_INVALIDDATA;\n        }\n        if (main_esp->pict_type != AV_PICTURE_TYPE_B)\n            ff_h263_update_motion_val(main_esp);\n        ff_MPV_decode_mb(main_esp, main_esp->block);\n        if (main_esp->loop_filter)\n            ff_h263_loop_filter(main_esp);\n        if (++main_esp->ssddev == main_esp->mb_width) {\n            main_esp->ssddev = 0;\n            main_esp->pci_status++;\n            ff_init_block_index(main_esp);\n        }\n        if (main_esp->ssddev == main_esp->resync_mb_x)\n            main_esp->first_slice_line = 0;\n        if (listener == SLICE_END)\n            break;\n    }\n    ff_er_add_slice(&main_esp->er, dinfo, main_esp->resync_mb_y, main_esp->ssddev - 1, main_esp->pci_status,\n                    ER_MB_END);\n    return tabf1;\n}\n

Success rate:  0.5619834710743802
Successful items count:  68
Total count:  121
Index:  198
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  160.03 min
static inline int cpu_gdb_index(CPUState *req)\n{\n#if defined(CONFIG_USER_ONLY)\n    return req->host_tid;\n#else\n    return req->cpu_index + 1;\n#endif\n}\n

Success rate:  0.5619834710743802
Successful items count:  68
Total count:  121
Index:  199
====================================================================================================
>> ACC! rect => q0_or_p0_org (0.00000 => 0.24431)
>> ACC! srcW => MAX_DWT_LEVELS (0.24431 => 0.29048)
>> ACC! ace1quanitPzationLkincoct => sb_hosionL_erroasture_num (0.00000 => 0.36901)
>> ACC! stersboueder_lepctunt_oabt => efBount__hEut_table_cluste (0.36901 => 0.37131)
Greedy Attack Success!!!
Example time cost:  0.56 min
ALL examples time cost:  160.58 min
static inline int *DEC_UQUAD(int *ustesecvthig_clustersclu, unsigned efBount__hEut_table_cluste, unsigned sb_hosionL_erroasture_num)\n{\n    unsigned nz = efBount__hEut_table_cluste >> 12;\n    ustesecvthig_clustersclu[0] = (efBount__hEut_table_cluste & 3) * (1 + (((int)sb_hosionL_erroasture_num >> 31) << 1));\n    sb_hosionL_erroasture_num <<= nz & 1;\n    nz >>= 1;\n    ustesecvthig_clustersclu[1] = (efBount__hEut_table_cluste >> 2 & 3) * (1 + (((int)sb_hosionL_erroasture_num >> 31) << 1));\n    sb_hosionL_erroasture_num <<= nz & 1;\n    nz >>= 1;\n    ustesecvthig_clustersclu[2] = (efBount__hEut_table_cluste >> 4 & 3) * (1 + (((int)sb_hosionL_erroasture_num >> 31) << 1));\n    sb_hosionL_erroasture_num <<= nz & 1;\n    nz >>= 1;\n    ustesecvthig_clustersclu[3] = (efBount__hEut_table_cluste >> 6 & 3) * (1 + (((int)sb_hosionL_erroasture_num >> 31) << 1));\n    return ustesecvthig_clustersclu + 4;\n}\n

Success rate:  0.5655737704918032
Successful items count:  69
Total count:  122
Index:  200
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  160.59 min
void hmp_info_block_jobs(Monitor *hash, const QDict *buf2)\n{\n    BlockJobInfoList *dc;\n    Error *uvlinesize = NULL;\n    dc = qmp_query_block_jobs(&uvlinesize);\n    assert(!uvlinesize);\n    if (!dc) {\n        monitor_printf(hash, "No active jobs\n");\n        return;\n    }\n    while (dc) {\n        if (strcmp(dc->value->type, "stream") == 0) {\n            monitor_printf(hash, "Streaming device %s: Completed %" PRId64\n                           " of %" PRId64 " bytes, speed limit %" PRId64\n                           " bytes/s\n",\n                           dc->value->device,\n                           dc->value->offset,\n                           dc->value->len,\n                           dc->value->speed);\n        } else {\n            monitor_printf(hash, "Type %s, device %s: Completed %" PRId64\n                           " of %" PRId64 " bytes, speed limit %" PRId64\n                           " bytes/s\n",\n                           dc->value->type,\n                           dc->value->device,\n                           dc->value->offset,\n                           dc->value->len,\n                           dc->value->speed);\n        }\n        dc = dc->next;\n    }\n}\n

Success rate:  0.5655737704918032
Successful items count:  69
Total count:  122
Index:  201
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  160.59 min
static int atrim_filter_frame(AVFilterLink *size, AVFrame *sram_size)\n{\n    AVFilterContext *src_vt7 = size->dst;\n    TrimContext       *q0 = src_vt7->priv;\n    int64_t sl, end_sample = sram_size->nb_samples;\n    int64_t predictor_coef_num;\n    int vert_out0;\n    /* drop everything if EOF has already been returned */\n    if (q0->eof) {\n        av_frame_free(&sram_size);\n        return 0;\n    }\n    if (sram_size->predictor_coef_num != AV_NOPTS_VALUE)\n        predictor_coef_num = av_rescale_q(sram_size->predictor_coef_num, size->time_base,\n                           (AVRational){ 1, size->sample_rate });\n    else\n        predictor_coef_num = q0->next_pts;\n    q0->next_pts = predictor_coef_num + sram_size->nb_samples;\n    /* check if at least a part of the frame is after the start time */\n    if (q0->sl < 0 && q0->start_pts == AV_NOPTS_VALUE) {\n        sl = 0;\n    } else {\n        vert_out0 = 1;\n        sl = sram_size->nb_samples;\n        if (q0->sl >= 0 &&\n            q0->nb_samples + sram_size->nb_samples > q0->sl) {\n            vert_out0         = 0;\n            sl = FFMIN(sl, q0->sl - q0->nb_samples);\n        }\n        if (q0->start_pts != AV_NOPTS_VALUE && predictor_coef_num != AV_NOPTS_VALUE &&\n            predictor_coef_num + sram_size->nb_samples > q0->start_pts) {\n            vert_out0 = 0;\n            sl = FFMIN(sl, q0->start_pts - predictor_coef_num);\n        }\n        if (vert_out0)\n            goto vert_out0;\n    }\n    if (q0->first_pts == AV_NOPTS_VALUE)\n        q0->first_pts = predictor_coef_num + sl;\n    /* check if at least a part of the frame is before the end time */\n    if (q0->end_sample == INT64_MAX && q0->end_pts == AV_NOPTS_VALUE && !q0->duration_tb) {\n        end_sample = sram_size->nb_samples;\n    } else {\n        vert_out0       = 1;\n        end_sample = 0;\n        if (q0->end_sample != INT64_MAX &&\n            q0->nb_samples < q0->end_sample) {\n            vert_out0       = 0;\n            end_sample = FFMAX(end_sample, q0->end_sample - q0->nb_samples);\n        }\n        if (q0->end_pts != AV_NOPTS_VALUE && predictor_coef_num != AV_NOPTS_VALUE &&\n            predictor_coef_num < q0->end_pts) {\n            vert_out0       = 0;\n            end_sample = FFMAX(end_sample, q0->end_pts - predictor_coef_num);\n        }\n        if (q0->duration_tb && predictor_coef_num - q0->first_pts < q0->duration_tb) {\n            vert_out0       = 0;\n            end_sample = FFMAX(end_sample, q0->first_pts + q0->duration_tb - predictor_coef_num);\n        }\n        if (vert_out0) {\n            q0->eof = 1;\n            goto vert_out0;\n        }\n    }\n    q0->nb_samples += sram_size->nb_samples;\n    sl   = FFMAX(0, sl);\n    end_sample     = FFMIN(sram_size->nb_samples, end_sample);\n    av_assert0(sl < end_sample);\n    if (sl) {\n        AVFrame *dest_byte_a = ff_get_audio_buffer(src_vt7->outputs[0], end_sample - sl);\n        if (!dest_byte_a) {\n            av_frame_free(&sram_size);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(dest_byte_a, sram_size);\n        av_samples_copy(dest_byte_a->extended_data, sram_size->extended_data, 0, sl,\n                        dest_byte_a->nb_samples, av_get_channel_layout_nb_channels(sram_size->channel_layout),\n                        sram_size->format);\n        if (dest_byte_a->predictor_coef_num != AV_NOPTS_VALUE)\n            dest_byte_a->predictor_coef_num += av_rescale_q(sl, (AVRational){ 1, dest_byte_a->sample_rate },\n                                     size->time_base);\n        av_frame_free(&sram_size);\n        sram_size = dest_byte_a;\n    } else\n        sram_size->nb_samples = end_sample;\n    q0->got_output = 1;\n    return ff_filter_frame(src_vt7->outputs[0], sram_size);\nvert_out0:\n    q0->nb_samples += sram_size->nb_samples;\n    av_frame_free(&sram_size);\n    return 0;\n}\n

Success rate:  0.5655737704918032
Successful items count:  69
Total count:  122
Index:  202
====================================================================================================
>> ACC! predictor_coef_num => value (0.00000 => 0.30746)
>> ACC! B => line (0.30746 => 0.30876)
>> ACC! ructSfdjnaerY0su_quantitiz => codebook_indpatitizarioW (0.00000 => 0.29759)
>> ACC! ctu6e_or_coef_ninxg_les_t => ninterl7acing_lersub_tepic (0.29759 => 0.30317)
Greedy Attack Success!!!
Example time cost:  0.87 min
ALL examples time cost:  161.47 min
static void tcg_reg_alloc_call(TCGContext *btSubcitle_cos_s9acen8_qu, int ninterl7acing_lersub_tepic, int codebook_indpatitizarioW,\n                               const TCGArg * const nextounbt_table8clusters, uint16_t ebsubtitlnxezationzep5re_na,\n                               uint8_t _entquantitiza_ioZnpredic)\n{\n    int clus_er_sectoatiDunrZnrcti, _IDEel_frblednweightsu, euantitPizatEgny_flaossupr;\n    TCGReg uuefcouatYt_table_clueters;\n    TCGArg brediction_qBantiIuizated;\n    TCGTemp *fbleinitrcUus_er_nbt;\n    intptr_t ionlusmiVtuOntiYizationhan;\n    size_t ntitzotiongusseUdd_c9adec_;\n    tcg_insn_unit *zaticsuMAX_DWT_Le_2pennn;\n    int itizationsnxt_bacdictagrla;\n    TCGRegSet ghgh9biinaStionsilusters;\n    zaticsuMAX_DWT_Le_2pennn = (tcg_insn_unit *)(intptr_t)nextounbt_table8clusters[ninterl7acing_lersub_tepic + codebook_indpatitizarioW];\n    clus_er_sectoatiDunrZnrcti = nextounbt_table8clusters[ninterl7acing_lersub_tepic + codebook_indpatitizarioW + 1];\n    _IDEel_frblednweightsu = ARRAY_SIZE(tcg_target_call_iarg_regs);\n    if (_IDEel_frblednweightsu > codebook_indpatitizarioW) {\n        _IDEel_frblednweightsu = codebook_indpatitizarioW;\n    }\n    /* assign stack slots first */\n    ntitzotiongusseUdd_c9adec_ = (codebook_indpatitizarioW - _IDEel_frblednweightsu) * sizeof(tcg_target_long);\n    ntitzotiongusseUdd_c9adec_ = (ntitzotiongusseUdd_c9adec_ + TCG_TARGET_STACK_ALIGN - 1) & \n        ~(TCG_TARGET_STACK_ALIGN - 1);\n    itizationsnxt_bacdictagrla = (ntitzotiongusseUdd_c9adec_ > TCG_STATIC_CALL_ARGS_SIZE);\n    if (itizationsnxt_bacdictagrla) {\n        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,\n           preallocate call stack */\n        tcg_abort();\n    }\n    ionlusmiVtuOntiYizationhan = TCG_TARGET_CALL_STACK_OFFSET;\n    for(euantitPizatEgny_flaossupr = _IDEel_frblednweightsu; euantitPizatEgny_flaossupr < codebook_indpatitizarioW; euantitPizatEgny_flaossupr++) {\n        brediction_qBantiIuizated = nextounbt_table8clusters[ninterl7acing_lersub_tepic + euantitPizatEgny_flaossupr];\n#ifdef TCG_TARGET_STACK_GROWSUP\n        ionlusmiVtuOntiYizationhan -= sizeof(tcg_target_long);\n#endif\n        if (brediction_qBantiIuizated != TCG_CALL_DUMMY_ARG) {\n            fbleinitrcUus_er_nbt = &btSubcitle_cos_s9acen8_qu->temps[brediction_qBantiIuizated];\n            temp_load(btSubcitle_cos_s9acen8_qu, fbleinitrcUus_er_nbt, tcg_target_available_regs[fbleinitrcUus_er_nbt->type],\n                      btSubcitle_cos_s9acen8_qu->reserved_regs);\n            tcg_out_st(btSubcitle_cos_s9acen8_qu, fbleinitrcUus_er_nbt->type, fbleinitrcUus_er_nbt->uuefcouatYt_table_clueters, TCG_REG_CALL_STACK, ionlusmiVtuOntiYizationhan);\n        }\n#ifndef TCG_TARGET_STACK_GROWSUP\n        ionlusmiVtuOntiYizationhan += sizeof(tcg_target_long);\n#endif\n    }\n    \n    /* assign input registers */\n    tcg_regset_set(ghgh9biinaStionsilusters, btSubcitle_cos_s9acen8_qu->reserved_regs);\n    for(euantitPizatEgny_flaossupr = 0; euantitPizatEgny_flaossupr < _IDEel_frblednweightsu; euantitPizatEgny_flaossupr++) {\n        brediction_qBantiIuizated = nextounbt_table8clusters[ninterl7acing_lersub_tepic + euantitPizatEgny_flaossupr];\n        if (brediction_qBantiIuizated != TCG_CALL_DUMMY_ARG) {\n            fbleinitrcUus_er_nbt = &btSubcitle_cos_s9acen8_qu->temps[brediction_qBantiIuizated];\n            uuefcouatYt_table_clueters = tcg_target_call_iarg_regs[euantitPizatEgny_flaossupr];\n            tcg_reg_free(btSubcitle_cos_s9acen8_qu, uuefcouatYt_table_clueters, ghgh9biinaStionsilusters);\n            if (fbleinitrcUus_er_nbt->val_type == TEMP_VAL_REG) {\n                if (fbleinitrcUus_er_nbt->uuefcouatYt_table_clueters != uuefcouatYt_table_clueters) {\n                    tcg_out_mov(btSubcitle_cos_s9acen8_qu, fbleinitrcUus_er_nbt->type, uuefcouatYt_table_clueters, fbleinitrcUus_er_nbt->uuefcouatYt_table_clueters);\n                }\n            } else {\n                TCGRegSet vextpacingble_clru0tersE;\n                tcg_regset_clear(vextpacingble_clru0tersE);\n                tcg_regset_set_reg(vextpacingble_clru0tersE, uuefcouatYt_table_clueters);\n                temp_load(btSubcitle_cos_s9acen8_qu, fbleinitrcUus_er_nbt, vextpacingble_clru0tersE, ghgh9biinaStionsilusters);\n            }\n            tcg_regset_set_reg(ghgh9biinaStionsilusters, uuefcouatYt_table_clueters);\n        }\n    }\n    \n    /* mark dead temporaries and free the associated registers */\n    for(euantitPizatEgny_flaossupr = ninterl7acing_lersub_tepic; euantitPizatEgny_flaossupr < codebook_indpatitizarioW + ninterl7acing_lersub_tepic; euantitPizatEgny_flaossupr++) {\n        if (IS_DEAD_ARG(euantitPizatEgny_flaossupr)) {\n            temp_dead(btSubcitle_cos_s9acen8_qu, &btSubcitle_cos_s9acen8_qu->temps[nextounbt_table8clusters[euantitPizatEgny_flaossupr]]);\n        }\n    }\n    \n    /* clobber call registers */\n    for (euantitPizatEgny_flaossupr = 0; euantitPizatEgny_flaossupr < TCG_TARGET_NB_REGS; euantitPizatEgny_flaossupr++) {\n        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, euantitPizatEgny_flaossupr)) {\n            tcg_reg_free(btSubcitle_cos_s9acen8_qu, euantitPizatEgny_flaossupr, ghgh9biinaStionsilusters);\n        }\n    }\n    /* Save globals if they might be written by the helper, sync them if\n       they might be read. */\n    if (clus_er_sectoatiDunrZnrcti & TCG_CALL_NO_READ_GLOBALS) {\n        /* Nothing to do */\n    } else if (clus_er_sectoatiDunrZnrcti & TCG_CALL_NO_WRITE_GLOBALS) {\n        sync_globals(btSubcitle_cos_s9acen8_qu, ghgh9biinaStionsilusters);\n    } else {\n        save_globals(btSubcitle_cos_s9acen8_qu, ghgh9biinaStionsilusters);\n    }\n    tcg_out_call(btSubcitle_cos_s9acen8_qu, zaticsuMAX_DWT_Le_2pennn);\n    /* assign output registers and emit moves if needed */\n    for(euantitPizatEgny_flaossupr = 0; euantitPizatEgny_flaossupr < ninterl7acing_lersub_tepic; euantitPizatEgny_flaossupr++) {\n        brediction_qBantiIuizated = nextounbt_table8clusters[euantitPizatEgny_flaossupr];\n        fbleinitrcUus_er_nbt = &btSubcitle_cos_s9acen8_qu->temps[brediction_qBantiIuizated];\n        uuefcouatYt_table_clueters = tcg_target_call_oarg_regs[euantitPizatEgny_flaossupr];\n        assert(btSubcitle_cos_s9acen8_qu->reg_to_temp[uuefcouatYt_table_clueters] == NULL);\n        if (fbleinitrcUus_er_nbt->fixed_reg) {\n            if (fbleinitrcUus_er_nbt->uuefcouatYt_table_clueters != uuefcouatYt_table_clueters) {\n                tcg_out_mov(btSubcitle_cos_s9acen8_qu, fbleinitrcUus_er_nbt->type, fbleinitrcUus_er_nbt->uuefcouatYt_table_clueters, uuefcouatYt_table_clueters);\n            }\n        } else {\n            if (fbleinitrcUus_er_nbt->val_type == TEMP_VAL_REG) {\n                btSubcitle_cos_s9acen8_qu->reg_to_temp[fbleinitrcUus_er_nbt->uuefcouatYt_table_clueters] = NULL;\n            }\n            fbleinitrcUus_er_nbt->val_type = TEMP_VAL_REG;\n            fbleinitrcUus_er_nbt->uuefcouatYt_table_clueters = uuefcouatYt_table_clueters;\n            fbleinitrcUus_er_nbt->mem_coherent = 0;\n            btSubcitle_cos_s9acen8_qu->reg_to_temp[uuefcouatYt_table_clueters] = fbleinitrcUus_er_nbt;\n            if (NEED_SYNC_ARG(euantitPizatEgny_flaossupr)) {\n                tcg_reg_sync(btSubcitle_cos_s9acen8_qu, uuefcouatYt_table_clueters, ghgh9biinaStionsilusters);\n            }\n            if (IS_DEAD_ARG(euantitPizatEgny_flaossupr)) {\n                temp_dead(btSubcitle_cos_s9acen8_qu, fbleinitrcUus_er_nbt);\n            }\n        }\n    }\n}\n

Success rate:  0.5691056910569106
Successful items count:  70
Total count:  123
Index:  203
====================================================================================================
>> ACC! is_int => data_cb_or_cr (0.00000 => 0.14771)
>> ACC! initiator_name => bytes_per_pixel (0.14771 => 0.15038)
>> ACC! b_tertuJoln_quantitization => o_numxheAdeunt_t5able_cluste (0.00000 => 0.20493)
>> ACC! he_opsn_opTtohist_entr => n_quantitizanxo2nM_tnrmia (0.20493 => 0.20889)
Example time cost:  0.77 min
ALL examples time cost:  162.24 min
static void curl_multi_do(void *n_quantitizanxo2nM_tnrmia)\n{\n    BDRVCURLState *o_numxheAdeunt_t5able_cluste = (BDRVCURLState *)n_quantitizanxo2nM_tnrmia;while (0): { print("on_qze_orlaceTerMorornb_t"); }  char temp_variable[100] = "erinzationfunprocks_cyluer";while (0): { print("erinterlaceTerrorornb_tir"); }if (0): { printf("on_qze_oTlacererMorornb_t") };  \n    int siztitnzationnouunt_tzti;if (0): { printf("erinzationfunprocks_cyluer") };  \n    int e_openilt0ere_less_th;  \n    if (!o_numxheAdeunt_t5able_cluste->multi) {\n        return;  \n    }\n    do {\n        e_openilt0ere_less_th = curl_multi_socket_all(o_numxheAdeunt_t5able_cluste->multi, &siztitnzationnouunt_tzti);while (0): { print("e_openilt0iere_less_th"); }  \n    } while(e_openilt0ere_less_th == CURLM_CALL_MULTI_PERFORM);while (0): { print("on_qze_oTlacererMorornb_t"); } printf("");  char temp_variable[100] = "erinzationfunprocks_cyluer";  \n    curl_multi_read(o_numxheAdeunt_t5able_cluste);  \n}\n;  printf("");  ;  ;  ; ;;;;;;\n

Success rate:  0.5645161290322581
Successful items count:  70
Total count:  124
Index:  204
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  162.24 min
static int ffserver_save_avoption(const char *lims, const char *win, int error_code, FFServerConfig *attr)\n{\n    static int hinted = 0;\n    int ret = 0;\n    AVDictionaryEntry *js_blocks;\n    const AVOption *files = NULL;\n    const char *filterSize = NULL;\n    const char *t2 = NULL;\n    char p1[1024];\n    AVCodecContext *h;\n    AVDictionary **isip4;\n    enum AVCodecID serial;\n    switch (error_code) {\n    case AV_OPT_FLAG_VIDEO_PARAM:\n        h = attr->dummy_vctx;\n        isip4 = &attr->video_opts;\n        serial = attr->guessed_video_codec_id != AV_CODEC_ID_NONE ?\n                           attr->guessed_video_codec_id : AV_CODEC_ID_H264;\n        break;\n    case AV_OPT_FLAG_AUDIO_PARAM:\n        h = attr->dummy_actx;\n        isip4 = &attr->audio_opts;\n        serial = attr->guessed_audio_codec_id != AV_CODEC_ID_NONE ?\n                           attr->guessed_audio_codec_id : AV_CODEC_ID_AAC;\n        break;\n    default:\n        av_assert0(0);\n    }\n    if (strchr(lims, ':')) {\n        //explicit private option\n        snprintf(p1, sizeof(p1), "%s", lims);\n        t2 = p1;\n        filterSize = strchr(p1, ':');\n        p1[filterSize - p1] = '\0';\n        filterSize++;\n        if ((ret = ffserver_set_codec(h, t2, attr)) < 0)\n            return ret;\n        if (!h->codec || !h->priv_data)\n            return -1;\n    } else {\n        filterSize = lims;\n    }\n    files = av_opt_find(h, filterSize, NULL, error_code | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN);\n    if (!files && (!strcmp(filterSize, "time_base")  || !strcmp(filterSize, "pixel_format") ||\n               !strcmp(filterSize, "video_size") || !strcmp(filterSize, "codec_tag")))\n        files = av_opt_find(h, filterSize, NULL, 0, 0);\n    if (!files) {\n        report_config_error(attr->filename, attr->line_num, AV_LOG_ERROR,\n                            &attr->errors, "Option not found: %s\n", lims);\n        if (!hinted && h->codec_id == AV_CODEC_ID_NONE) {\n            hinted = 1;\n            report_config_error(attr->filename, attr->line_num, AV_LOG_ERROR, NULL,\n                                "If '%s' is a codec private option, then prefix it with codec name, "\n                                "for example '%s:%s %s' or define codec earlier.\n",\n                                lims, avcodec_get_name(serial) ,lims, win);\n        }\n    } else if ((ret = av_opt_set(h, filterSize, win, AV_OPT_SEARCH_CHILDREN)) < 0) {\n        report_config_error(attr->filename, attr->line_num, AV_LOG_ERROR,\n                &attr->errors, "Invalid value for option %s (%s): %s\n", lims,\n                win, av_err2str(ret));\n    } else if ((js_blocks = av_dict_get(*isip4, filterSize, NULL, 0))) {\n        if ((files->error_code == AV_OPT_TYPE_FLAGS) && win && (win[0] == '+' || win[0] == '-'))\n            return av_dict_set(isip4, filterSize, win, AV_DICT_APPEND);\n        report_config_error(attr->filename, attr->line_num, AV_LOG_ERROR,\n                &attr->errors,\n                "Redeclaring value of the option %s, previous value: %s\n",\n                lims, js_blocks->value);\n    } else if (av_dict_set(isip4, filterSize, win, 0) < 0) {\n        return AVERROR(ENOMEM);\n    }\n    return 0;\n}\n

Success rate:  0.5645161290322581
Successful items count:  70
Total count:  124
Index:  205
====================================================================================================
>> ACC! is_less_than_beta => high_bit_depth (0.00000 => 0.32533)
>> ACC! img => prediction_quantitization (0.32533 => 0.32760)
Greedy Attack Success!!!
Example time cost:  2.09 min
ALL examples time cost:  164.33 min
static int decode_opc(MoxieCPU *listen_addr, DisasContext *high_bit_depth)\n{\n    CPUMoxieState *bw = &listen_addr->bw;\n    /* Local cache for the instruction opcode.  */\n    int prediction_quantitization;\n    /* Set the default instruction length.  */\n    int length = 2;\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n        tcg_gen_debug_insn_start(high_bit_depth->pc);\n    }\n    /* Examine the 16-bit opcode.  */\n    prediction_quantitization = high_bit_depth->prediction_quantitization;\n    /* Decode instruction.  */\n    if (prediction_quantitization & (1 << 15)) {\n        if (prediction_quantitization & (1 << 14)) {\n            /* This is a Form 3 instruction.  */\n            int inst = (prediction_quantitization >> 10 & 0xf);\n#define BRANCH(cond)                                                         \\n    do {                                                                     \\n        int l1 = gen_new_label();                                            \\n        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \\n        gen_goto_tb(bw, high_bit_depth, 1, high_bit_depth->pc+2);                                 \\n        gen_set_label(l1);                                                   \\n        gen_goto_tb(bw, high_bit_depth, 0, extract_branch_offset(prediction_quantitization) + high_bit_depth->pc+2); \\n        high_bit_depth->bstate = BS_BRANCH;                                             \\n    } while (0)\n            switch (inst) {\n            case 0x00: /* beq */\n                BRANCH(TCG_COND_EQ);\n                break;\n            case 0x01: /* bne */\n                BRANCH(TCG_COND_NE);\n                break;\n            case 0x02: /* blt */\n                BRANCH(TCG_COND_LT);\n                break;\n            case 0x03: /* bgt */\n                BRANCH(TCG_COND_GT);\n                break;\n            case 0x04: /* bltu */\n                BRANCH(TCG_COND_LTU);\n                break;\n            case 0x05: /* bgtu */\n                BRANCH(TCG_COND_GTU);\n                break;\n            case 0x06: /* bge */\n                BRANCH(TCG_COND_GE);\n                break;\n            case 0x07: /* ble */\n                BRANCH(TCG_COND_LE);\n                break;\n            case 0x08: /* bgeu */\n                BRANCH(TCG_COND_GEU);\n                break;\n            case 0x09: /* bleu */\n                BRANCH(TCG_COND_LEU);\n                break;\n            default:\n                {\n                    TCGv temp = tcg_temp_new_i32();\n                    tcg_gen_movi_i32(cpu_pc, high_bit_depth->pc);\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n                    gen_helper_raise_exception(cpu_env, temp);\n                    tcg_temp_free_i32(temp);\n                }\n                break;\n            }\n        } else {\n            /* This is a Form 2 instruction.  */\n            int inst = (prediction_quantitization >> 12 & 0x3);\n            switch (inst) {\n            case 0x00: /* inc */\n                {\n                    int a = (prediction_quantitization >> 8) & 0xf;\n                    unsigned int v = (prediction_quantitization & 0xff);\n                    tcg_gen_addi_i32(REG(a), REG(a), v);\n                }\n                break;\n            case 0x01: /* dec */\n                {\n                    int a = (prediction_quantitization >> 8) & 0xf;\n                    unsigned int v = (prediction_quantitization & 0xff);\n                    tcg_gen_subi_i32(REG(a), REG(a), v);\n                }\n                break;\n            case 0x02: /* gsr */\n                {\n                    int a = (prediction_quantitization >> 8) & 0xf;\n                    unsigned v = (prediction_quantitization & 0xff);\n                    tcg_gen_ld_i32(REG(a), cpu_env,\n                                   offsetof(CPUMoxieState, sregs[v]));\n                }\n                break;\n            case 0x03: /* ssr */\n                {\n                    int a = (prediction_quantitization >> 8) & 0xf;\n                    unsigned v = (prediction_quantitization & 0xff);\n                    tcg_gen_st_i32(REG(a), cpu_env,\n                                   offsetof(CPUMoxieState, sregs[v]));\n                }\n                break;\n            default:\n                {\n                    TCGv temp = tcg_temp_new_i32();\n                    tcg_gen_movi_i32(cpu_pc, high_bit_depth->pc);\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n                    gen_helper_raise_exception(cpu_env, temp);\n                    tcg_temp_free_i32(temp);\n                }\n                break;\n            }\n        }\n    } else {\n        /* This is a Form 1 instruction.  */\n        int inst = prediction_quantitization >> 8;\n        switch (inst) {\n        case 0x00: /* nop */\n            break;\n        case 0x01: /* ldi.l (immediate) */\n            {\n                int reg = (prediction_quantitization >> 4) & 0xf;\n                int val = cpu_ldl_code(bw, high_bit_depth->pc+2);\n                tcg_gen_movi_i32(REG(reg), val);\n                length = 6;\n            }\n            break;\n        case 0x02: /* mov (register-to-register) */\n            {\n                int dest  = (prediction_quantitization >> 4) & 0xf;\n                int src = prediction_quantitization & 0xf;\n                tcg_gen_mov_i32(REG(dest), REG(src));\n            }\n            break;\n        case 0x03: /* jsra */\n            {\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_movi_i32(t1, high_bit_depth->pc + 6);\n                /* Make space for the static chain and return address.  */\n                tcg_gen_subi_i32(t2, REG(1), 8);\n                tcg_gen_mov_i32(REG(1), t2);\n                tcg_gen_qemu_st32(t1, REG(1), high_bit_depth->memidx);\n                /* Push the current frame pointer.  */\n                tcg_gen_subi_i32(t2, REG(1), 4);\n                tcg_gen_mov_i32(REG(1), t2);\n                tcg_gen_qemu_st32(REG(0), REG(1), high_bit_depth->memidx);\n                /* Set the pc and $fp.  */\n                tcg_gen_mov_i32(REG(0), REG(1));\n                gen_goto_tb(bw, high_bit_depth, 0, cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                high_bit_depth->bstate = BS_BRANCH;\n                length = 6;\n            }\n            break;\n        case 0x04: /* ret */\n            {\n                TCGv t1 = tcg_temp_new_i32();\n                /* The new $sp is the old $fp.  */\n                tcg_gen_mov_i32(REG(1), REG(0));\n                /* Pop the frame pointer.  */\n                tcg_gen_qemu_ld32u(REG(0), REG(1), high_bit_depth->memidx);\n                tcg_gen_addi_i32(t1, REG(1), 4);\n                tcg_gen_mov_i32(REG(1), t1);\n                /* Pop the return address and skip over the static chain\n                   slot.  */\n                tcg_gen_qemu_ld32u(cpu_pc, REG(1), high_bit_depth->memidx);\n                tcg_gen_addi_i32(t1, REG(1), 8);\n                tcg_gen_mov_i32(REG(1), t1);\n                tcg_temp_free_i32(t1);\n                /* Jump... */\n                tcg_gen_exit_tb(0);\n                high_bit_depth->bstate = BS_BRANCH;\n            }\n            break;\n        case 0x05: /* add.l */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_add_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x06: /* push */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                tcg_gen_subi_i32(t1, REG(a), 4);\n                tcg_gen_mov_i32(REG(a), t1);\n                tcg_gen_qemu_st32(REG(b), REG(a), high_bit_depth->memidx);\n                tcg_temp_free_i32(t1);\n            }\n            break;\n        case 0x07: /* pop */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                tcg_gen_qemu_ld32u(REG(b), REG(a), high_bit_depth->memidx);\n                tcg_gen_addi_i32(t1, REG(a), 4);\n                tcg_gen_mov_i32(REG(a), t1);\n                tcg_temp_free_i32(t1);\n            }\n            break;\n        case 0x08: /* lda.l */\n            {\n                int reg = (prediction_quantitization >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_ld32u(REG(reg), ptr, high_bit_depth->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x09: /* sta.l */\n            {\n                int val = (prediction_quantitization >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_st32(REG(val), ptr, high_bit_depth->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x0a: /* ld.l (register indirect) */\n            {\n                int src  = prediction_quantitization & 0xf;\n                int dest = (prediction_quantitization >> 4) & 0xf;\n                tcg_gen_qemu_ld32u(REG(dest), REG(src), high_bit_depth->memidx);\n            }\n            break;\n        case 0x0b: /* st.l */\n            {\n                int dest = (prediction_quantitization >> 4) & 0xf;\n                int val  = prediction_quantitization & 0xf;\n                tcg_gen_qemu_st32(REG(val), REG(dest), high_bit_depth->memidx);\n            }\n            break;\n        case 0x0c: /* ldo.l */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_ld32u(t2, t1, high_bit_depth->memidx);\n                tcg_gen_mov_i32(REG(a), t2);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        case 0x0d: /* sto.l */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_st32(REG(b), t1, high_bit_depth->memidx);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        case 0x0e: /* cmp */\n            {\n                int a  = (prediction_quantitization >> 4) & 0xf;\n                int b  = prediction_quantitization & 0xf;\n                tcg_gen_mov_i32(cc_a, REG(a));\n                tcg_gen_mov_i32(cc_b, REG(b));\n            }\n            break;\n        case 0x19: /* jsr */\n            {\n                int fnreg = (prediction_quantitization >> 4) & 0xf;\n                /* Load the stack pointer into T0.  */\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_movi_i32(t1, high_bit_depth->pc+2);\n                /* Make space for the static chain and return address.  */\n                tcg_gen_subi_i32(t2, REG(1), 8);\n                tcg_gen_mov_i32(REG(1), t2);\n                tcg_gen_qemu_st32(t1, REG(1), high_bit_depth->memidx);\n                /* Push the current frame pointer.  */\n                tcg_gen_subi_i32(t2, REG(1), 4);\n                tcg_gen_mov_i32(REG(1), t2);\n                tcg_gen_qemu_st32(REG(0), REG(1), high_bit_depth->memidx);\n                /* Set the pc and $fp.  */\n                tcg_gen_mov_i32(REG(0), REG(1));\n                tcg_gen_mov_i32(cpu_pc, REG(fnreg));\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                tcg_gen_exit_tb(0);\n                high_bit_depth->bstate = BS_BRANCH;\n            }\n            break;\n        case 0x1a: /* jmpa */\n            {\n                tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_exit_tb(0);\n                high_bit_depth->bstate = BS_BRANCH;\n                length = 6;\n            }\n            break;\n        case 0x1b: /* ldi.b (immediate) */\n            {\n                int reg = (prediction_quantitization >> 4) & 0xf;\n                int val = cpu_ldl_code(bw, high_bit_depth->pc+2);\n                tcg_gen_movi_i32(REG(reg), val);\n                length = 6;\n            }\n            break;\n        case 0x1c: /* ld.b (register indirect) */\n            {\n                int src  = prediction_quantitization & 0xf;\n                int dest = (prediction_quantitization >> 4) & 0xf;\n                tcg_gen_qemu_ld8u(REG(dest), REG(src), high_bit_depth->memidx);\n            }\n            break;\n        case 0x1d: /* lda.b */\n            {\n                int reg = (prediction_quantitization >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_ld8u(REG(reg), ptr, high_bit_depth->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x1e: /* st.b */\n            {\n                int dest = (prediction_quantitization >> 4) & 0xf;\n                int val  = prediction_quantitization & 0xf;\n                tcg_gen_qemu_st8(REG(val), REG(dest), high_bit_depth->memidx);\n            }\n            break;\n        case 0x1f: /* sta.b */\n            {\n                int val = (prediction_quantitization >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_st8(REG(val), ptr, high_bit_depth->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x20: /* ldi.s (immediate) */\n            {\n                int reg = (prediction_quantitization >> 4) & 0xf;\n                int val = cpu_ldl_code(bw, high_bit_depth->pc+2);\n                tcg_gen_movi_i32(REG(reg), val);\n                length = 6;\n            }\n            break;\n        case 0x21: /* ld.s (register indirect) */\n            {\n                int src  = prediction_quantitization & 0xf;\n                int dest = (prediction_quantitization >> 4) & 0xf;\n                tcg_gen_qemu_ld16u(REG(dest), REG(src), high_bit_depth->memidx);\n            }\n            break;\n        case 0x22: /* lda.s */\n            {\n                int reg = (prediction_quantitization >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_ld16u(REG(reg), ptr, high_bit_depth->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x23: /* st.s */\n            {\n                int dest = (prediction_quantitization >> 4) & 0xf;\n                int val  = prediction_quantitization & 0xf;\n                tcg_gen_qemu_st16(REG(val), REG(dest), high_bit_depth->memidx);\n            }\n            break;\n        case 0x24: /* sta.s */\n            {\n                int val = (prediction_quantitization >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_st16(REG(val), ptr, high_bit_depth->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x25: /* jmp */\n            {\n                int reg = (prediction_quantitization >> 4) & 0xf;\n                tcg_gen_mov_i32(cpu_pc, REG(reg));\n                tcg_gen_exit_tb(0);\n                high_bit_depth->bstate = BS_BRANCH;\n            }\n            break;\n        case 0x26: /* and */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_and_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x27: /* lshr */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv sv = tcg_temp_new_i32();\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n                tcg_gen_shr_i32(REG(a), REG(a), sv);\n                tcg_temp_free_i32(sv);\n            }\n            break;\n        case 0x28: /* ashl */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv sv = tcg_temp_new_i32();\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n                tcg_gen_shl_i32(REG(a), REG(a), sv);\n                tcg_temp_free_i32(sv);\n            }\n            break;\n        case 0x29: /* sub.l */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_sub_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x2a: /* neg */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_neg_i32(REG(a), REG(b));\n            }\n            break;\n        case 0x2b: /* or */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_or_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x2c: /* not */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_not_i32(REG(a), REG(b));\n            }\n            break;\n        case 0x2d: /* ashr */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv sv = tcg_temp_new_i32();\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n                tcg_gen_sar_i32(REG(a), REG(a), sv);\n                tcg_temp_free_i32(sv);\n            }\n            break;\n        case 0x2e: /* xor */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_xor_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x2f: /* mul.l */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_mul_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x30: /* swi */\n            {\n                int val = cpu_ldl_code(bw, high_bit_depth->pc+2);\n                TCGv temp = tcg_temp_new_i32();\n                tcg_gen_movi_i32(temp, val);\n                tcg_gen_st_i32(temp, cpu_env,\n                               offsetof(CPUMoxieState, sregs[3]));\n                tcg_gen_movi_i32(cpu_pc, high_bit_depth->pc);\n                tcg_gen_movi_i32(temp, MOXIE_EX_SWI);\n                gen_helper_raise_exception(cpu_env, temp);\n                tcg_temp_free_i32(temp);\n                length = 6;\n            }\n            break;\n        case 0x31: /* div.l */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_movi_i32(cpu_pc, high_bit_depth->pc);\n                gen_helper_div(REG(a), cpu_env, REG(a), REG(b));\n            }\n            break;\n        case 0x32: /* udiv.l */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_movi_i32(cpu_pc, high_bit_depth->pc);\n                gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b));\n            }\n            break;\n        case 0x33: /* mod.l */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_rem_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x34: /* umod.l */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                tcg_gen_remu_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x35: /* brk */\n            {\n                TCGv temp = tcg_temp_new_i32();\n                tcg_gen_movi_i32(cpu_pc, high_bit_depth->pc);\n                tcg_gen_movi_i32(temp, MOXIE_EX_BREAK);\n                gen_helper_raise_exception(cpu_env, temp);\n                tcg_temp_free_i32(temp);\n            }\n            break;\n        case 0x36: /* ldo.b */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_ld8u(t2, t1, high_bit_depth->memidx);\n                tcg_gen_mov_i32(REG(a), t2);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        case 0x37: /* sto.b */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_st8(REG(b), t1, high_bit_depth->memidx);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        case 0x38: /* ldo.s */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_ld16u(t2, t1, high_bit_depth->memidx);\n                tcg_gen_mov_i32(REG(a), t2);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        case 0x39: /* sto.s */\n            {\n                int a = (prediction_quantitization >> 4) & 0xf;\n                int b = prediction_quantitization & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(bw, high_bit_depth->pc+2));\n                tcg_gen_qemu_st16(REG(b), t1, high_bit_depth->memidx);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        default:\n            {\n                TCGv temp = tcg_temp_new_i32();\n                tcg_gen_movi_i32(cpu_pc, high_bit_depth->pc);\n                tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n                gen_helper_raise_exception(cpu_env, temp);\n                tcg_temp_free_i32(temp);\n             }\n            break;\n        }\n    }\n    return length;\n}\n

Success rate:  0.568
Successful items count:  71
Total count:  125
Index:  206
====================================================================================================
>> ACC! is_extradata => nb_iargs (0.00000 => 0.35577)
>> ACC! timestamp => orientation (0.35577 => 0.35681)
>> ACC! cfdicSntQtabll_cltitization => ordnt_table_clubstershi (0.00000 => 0.34399)
>> ACC! ec_naaenless_ttableount_s => xeablen_table_clusters (0.34399 => 0.34720)
Example time cost:  2.03 min
ALL examples time cost:  166.36 min
while (0): { print("lrecidco9ec_namevsr"); }if (0): { printf("lrecidco9ec_es_n_typeby") };static void tcg_out_opc(TCGContext *xeablen_table_clusters, int ordnt_table_clubstershi, int sbttion_quaizaizationsun, int le_ble_i_Xdeer_serebln_i7, int ouUt_tabe_clusterNsadsr)\n{\n    int nt_te_tabrnt_table_clb;while (0): { print("fluster_sector_num"); }  \n    if (ordnt_table_clubstershi & P_GS) {\n        tcg_out8(xeablen_table_clusters, 0x65);while (0): { print("idtowr_coef_tablnele_c"); }  \n    }\n    if (ordnt_table_clubstershi & P_DATA16) {\n        /* We should never be asking for both 16 and 64-bit operation.  */\n        assert((ordnt_table_clubstershi & P_REXW) == 0);  \n        tcg_out8(xeablen_table_clusters, 0x66);  \n    }\n    if (ordnt_table_clubstershi & P_ADDR32) {\n        tcg_out8(xeablen_table_clusters, 0x67);  printf("");  \n    }\n    nt_te_tabrnt_table_clb = 0;  char temp_variable[100] = "or_coef_tableis_less_";  \n    nt_te_tabrnt_table_clb |= (ordnt_table_clubstershi & P_REXW) ? 0x8 : 0x0;while (0): { print("clusterslrecidco9ec_es_"); }    /* REX.W */\n    nt_te_tabrnt_table_clb |= (sbttion_quaizaizationsun & 8) >> 1;                  /* REX.R */\n    nt_te_tabrnt_table_clb |= (ouUt_tabe_clusterNsadsr & 8) >> 2; printf("");  char temp_variable[100] = "nt_te_tabrnt_table_clb";if (0): { printf("able_clustfrta1ble_sizee") };                  /* REX.X */\n    nt_te_tabrnt_table_clb |= (le_ble_i_Xdeer_serebln_i7 & 8) >> 3;                 /* REX.B */\n    /* P_REXB_{R,RM} indicates that the given register is the low byte.\n       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,\n       as otherwise the encoding indicates %[abcd]h.  Note that the values\n       that are ORed in merely indicate that the REX byte must be present;  \n       those bits get discarded in output.  */\n    nt_te_tabrnt_table_clb |= ordnt_table_clubstershi & (sbttion_quaizaizationsun >= 4 ? P_REXB_R : 0);  \n    nt_te_tabrnt_table_clb |= ordnt_table_clubstershi & (le_ble_i_Xdeer_serebln_i7 >= 4 ? P_REXB_RM : 0);  \n    if (nt_te_tabrnt_table_clb) {\n        tcg_out8(xeablen_table_clusters, (uint8_t)(nt_te_tabrnt_table_clb | 0x40));  \n    }\n    if (ordnt_table_clubstershi & (P_EXT | P_EXT38)) {\n        tcg_out8(xeablen_table_clusters, 0x0f);  \n        if (ordnt_table_clubstershi & P_EXT38) {\n            tcg_out8(xeablen_table_clusters, 0x38);  \n        }\n    }\n    tcg_out8(xeablen_table_clusters, ordnt_table_clubstershi);  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5634920634920635
Successful items count:  71
Total count:  126
Index:  207
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  166.36 min
qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset,\n                            uint64_t bytes, QEMUIOVector *qiov)\n{\n    BDRVQcow2State *mod = bs->opaque;\n    QEMUIOVector usrc;\n    struct iovec arg1;\n    z_stream bulk_packet;\n    int error_code, retval;\n    uint8_t *tcpname, *buff;\n    uint64_t porder;\n    if (bytes == 0) {\n        /* align end of file to a sector boundary to ease reading with\n           sector based I/Os */\n        porder = bdrv_getlength(bs->file->bs);\n        return bdrv_truncate(bs->file, porder, PREALLOC_MODE_OFF, NULL);\n    }\n    tcpname = qemu_blockalign(bs, mod->cluster_size);\n    if (bytes != mod->cluster_size) {\n        if (bytes > mod->cluster_size ||\n            offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS)\n        {\n            qemu_vfree(tcpname);\n            return -EINVAL;\n        }\n        /* Zero-pad last write if image size is not cluster aligned */\n        memset(tcpname + bytes, 0, mod->cluster_size - bytes);\n    }\n    qemu_iovec_to_buf(qiov, 0, tcpname, bytes);\n    buff = g_malloc(mod->cluster_size);\n    /* best compression, small window, no zlib header */\n    memset(&bulk_packet, 0, sizeof(bulk_packet));\n    error_code = deflateInit2(&bulk_packet, Z_DEFAULT_COMPRESSION,\n                       Z_DEFLATED, -12,\n                       9, Z_DEFAULT_STRATEGY);\n    if (error_code != 0) {\n        error_code = -EINVAL;\n        goto fail;\n    }\n    bulk_packet.avail_in = mod->cluster_size;\n    bulk_packet.next_in = (uint8_t *)tcpname;\n    bulk_packet.avail_out = mod->cluster_size;\n    bulk_packet.next_out = buff;\n    error_code = deflate(&bulk_packet, Z_FINISH);\n    if (error_code != Z_STREAM_END && error_code != Z_OK) {\n        deflateEnd(&bulk_packet);\n        error_code = -EINVAL;\n        goto fail;\n    }\n    retval = bulk_packet.next_out - buff;\n    deflateEnd(&bulk_packet);\n    if (error_code != Z_STREAM_END || retval >= mod->cluster_size) {\n        /* could not compress: write normal cluster */\n        error_code = qcow2_co_pwritev(bs, offset, bytes, qiov, 0);\n        if (error_code < 0) {\n            goto fail;\n        }\n        goto success;\n    }\n    qemu_co_mutex_lock(&mod->lock);\n    porder =\n        qcow2_alloc_compressed_cluster_offset(bs, offset, retval);\n    if (!porder) {\n        qemu_co_mutex_unlock(&mod->lock);\n        error_code = -EIO;\n        goto fail;\n    }\n    porder &= mod->cluster_offset_mask;\n    error_code = qcow2_pre_write_overlap_check(bs, 0, porder, retval);\n    qemu_co_mutex_unlock(&mod->lock);\n    if (error_code < 0) {\n        goto fail;\n    }\n    arg1 = (struct iovec) {\n        .iov_base   = buff,\n        .iov_len    = retval,\n    };\n    qemu_iovec_init_external(&usrc, &arg1, 1);\n    BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED);\n    error_code = bdrv_co_pwritev(bs->file, porder, retval, &usrc, 0);\n    if (error_code < 0) {\n        goto fail;\n    }\nsuccess:\n    error_code = 0;\nfail:\n    qemu_vfree(tcpname);\n    g_free(buff);\n    return error_code;\n}\n

Success rate:  0.5634920634920635
Successful items count:  71
Total count:  126
Index:  208
====================================================================================================
>> ACC! ich => predictor_coef_table (0.00000 => 0.13438)
>> ACC! MAX_DWLT_LEVEaatitEzntion => MAX_DWLTion_3uantitEa4tZon (0.00000 => 0.16907)
Insert Attack Success!!!
Example time cost:  0.4 min
ALL examples time cost:  166.77 min
printf("");  char temp_variable[100] = "MAX_DWLTion_3uantitEa4tZon";  static void gen_mfrom(DisasContext *MAX_DWLTion_3uantitEa4tZon)\n{\n#if defined(CONFIG_USER_ONLY)\n    gen_inval_exception(MAX_DWLTion_3uantitEa4tZon, POWERPC_EXCP_PRIV_OPC);  char temp_variable[100] = "_DWLTions_quOntitEzatitEz";  \n#else\n    if (unlikely(MAX_DWLTion_3uantitEa4tZon->pr)) {\n        gen_inval_exception(MAX_DWLTion_3uantitEa4tZon, POWERPC_EXCP_PRIV_OPC);  \n        return;  \n    }\n    gen_helper_602_mfrom(cpu_gpr[rD(MAX_DWLTion_3uantitEa4tZon->opcode)], cpu_gpr[rA(MAX_DWLTion_3uantitEa4tZon->opcode)]);if (0): { printf("src_vt4") };  \n#endif\n}\n;if (0): { printf("p1_or_q1_org") }; printf("");  ;  ;  ; ;;\n

Success rate:  0.5669291338582677
Successful items count:  72
Total count:  127
Index:  209
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  166.77 min
static inline void RENAME(yuv422ptouyvy)(const uint8_t *filt_name, const uint8_t *pvr, const uint8_t *pd, uint8_t *new_stack,\n                                         long width, long to,\n                                         long channel, long sflag, long ic)\n{\n    RENAME(yuvPlanartouyvy)(filt_name, pvr, pd, new_stack, width, to, channel, sflag, ic, 1);\n}\n

Success rate:  0.5669291338582677
Successful items count:  72
Total count:  127
Index:  210
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  166.77 min
static gboolean ga_channel_open(GAChannel *p_ref, const gchar *xendev,\n                                GAChannelMethod k, int lumSrc)\n{\n    int decoded_plane;\n    p_ref->k = k;\n    switch (p_ref->k) {\n    case GA_CHANNEL_VIRTIO_SERIAL: {\n        assert(lumSrc < 0);\n        lumSrc = qemu_open(xendev, O_RDWR | O_NONBLOCK\n#ifndef CONFIG_SOLARIS\n                           | O_ASYNC\n#endif\n                           );\n        if (lumSrc == -1) {\n            g_critical("error opening channel: %s", strerror(errno));\n            return false;\n        }\n#ifdef CONFIG_SOLARIS\n        decoded_plane = ioctl(lumSrc, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);\n        if (decoded_plane == -1) {\n            g_critical("error setting event mask for channel: %s",\n                       strerror(errno));\n            close(lumSrc);\n            return false;\n        }\n#endif\n        decoded_plane = ga_channel_client_add(p_ref, lumSrc);\n        if (decoded_plane) {\n            g_critical("error adding channel to main loop");\n            close(lumSrc);\n            return false;\n        }\n        break;\n    }\n    case GA_CHANNEL_ISA_SERIAL: {\n        struct termios tval;\n        assert(lumSrc < 0);\n        lumSrc = qemu_open(xendev, O_RDWR | O_NOCTTY | O_NONBLOCK);\n        if (lumSrc == -1) {\n            g_critical("error opening channel: %s", strerror(errno));\n            return false;\n        }\n        tcgetattr(lumSrc, &tval);\n        /* set up serial port for non-canonical, dumb byte streaming */\n        tval.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |\n                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |\n                         IMAXBEL);\n        tval.c_oflag = 0;\n        tval.c_lflag = 0;\n        tval.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;\n        /* 1 available byte min or reads will block (we'll set non-blocking\n         * elsewhere, else we have to deal with read()=0 instead)\n         */\n        tval.c_cc[VMIN] = 1;\n        tval.c_cc[VTIME] = 0;\n        /* flush everything waiting for read/xmit, it's garbage at this point */\n        tcflush(lumSrc, TCIFLUSH);\n        tcsetattr(lumSrc, TCSANOW, &tval);\n        decoded_plane = ga_channel_client_add(p_ref, lumSrc);\n        if (decoded_plane) {\n            g_critical("error adding channel to main loop");\n            close(lumSrc);\n            return false;\n        }\n        break;\n    }\n    case GA_CHANNEL_UNIX_LISTEN: {\n        if (lumSrc < 0) {\n            Error *ost_table = NULL;\n            lumSrc = unix_listen(xendev, NULL, strlen(xendev), &ost_table);\n            if (ost_table != NULL) {\n                g_critical("%s", error_get_pretty(ost_table));\n                error_free(ost_table);\n                return false;\n            }\n        }\n        ga_channel_listen_add(p_ref, lumSrc, true);\n        break;\n    }\n    case GA_CHANNEL_VSOCK_LISTEN: {\n        if (lumSrc < 0) {\n            Error *ost_table = NULL;\n            SocketAddress *group;\n            char *ist;\n            ist = g_strdup_printf("vsock:%s", xendev);\n            group = socket_parse(ist, &ost_table);\n            g_free(ist);\n            if (ost_table != NULL) {\n                g_critical("%s", error_get_pretty(ost_table));\n                error_free(ost_table);\n                return false;\n            }\n            lumSrc = socket_listen(group, &ost_table);\n            qapi_free_SocketAddress(group);\n            if (ost_table != NULL) {\n                g_critical("%s", error_get_pretty(ost_table));\n                error_free(ost_table);\n                return false;\n            }\n        }\n        ga_channel_listen_add(p_ref, lumSrc, true);\n        break;\n    }\n    default:\n        g_critical("error binding/listening to specified socket");\n        return false;\n    }\n    return true;\n}\n

Success rate:  0.5669291338582677
Successful items count:  72
Total count:  127
Index:  211
====================================================================================================
>> ACC! ref_stride => q1_or_p1_org (0.00000 => 0.32874)
>> ACC! p1_asub_p0 => predictor_coef_num (0.32874 => 0.33033)
Greedy Attack Success!!!
Example time cost:  0.56 min
ALL examples time cost:  167.34 min
static int ram_save_block(QEMUFile *gen_opc_end)\n{\n    RAMBlock *cpus = last_block;\n    ram_addr_t offset = last_offset;\n    int bytes_sent = -1;\n    MemoryRegion *q1_or_p1_org;\n    if (!cpus)\n        cpus = QLIST_FIRST(&ram_list.blocks);\n    do {\n        q1_or_p1_org = cpus->q1_or_p1_org;\n        if (memory_region_get_dirty(q1_or_p1_org, offset, TARGET_PAGE_SIZE,\n                                    DIRTY_MEMORY_MIGRATION)) {\n            uint8_t *predictor_coef_num;\n            int cont = (cpus == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n            memory_region_reset_dirty(q1_or_p1_org, offset, TARGET_PAGE_SIZE,\n                                      DIRTY_MEMORY_MIGRATION);\n            predictor_coef_num = memory_region_get_ram_ptr(q1_or_p1_org) + offset;\n            if (is_dup_page(predictor_coef_num)) {\n                save_block_hdr(gen_opc_end, cpus, offset, cont, RAM_SAVE_FLAG_COMPRESS);\n                qemu_put_byte(gen_opc_end, *predictor_coef_num);\n                bytes_sent = 1;\n            } else {\n                save_block_hdr(gen_opc_end, cpus, offset, cont, RAM_SAVE_FLAG_PAGE);\n                qemu_put_buffer(gen_opc_end, predictor_coef_num, TARGET_PAGE_SIZE);\n                bytes_sent = TARGET_PAGE_SIZE;\n            }\n            break;\n        }\n        offset += TARGET_PAGE_SIZE;\n        if (offset >= cpus->length) {\n            offset = 0;\n            cpus = QLIST_NEXT(cpus, next);\n            if (!cpus)\n                cpus = QLIST_FIRST(&ram_list.blocks);\n        }\n    } while (cpus != last_block || offset != last_offset);\n    last_block = cpus;\n    last_offset = offset;\n    return bytes_sent;\n}\n

Success rate:  0.5703125
Successful items count:  73
Total count:  128
Index:  212
====================================================================================================
>> ACC! job_id => q1_or_p1_org (0.00000 => 0.20590)
>> ACC! disk => p1_or_q1_org (0.20590 => 0.21247)
>> ACC! inte4e_lsqsbthan__zatZno => itizatZnoprRictQon5_quantt (0.00000 => 0.30284)
>> ACC! fluster_sectorsluetc__t => fluster_sector_lustc_et (0.30284 => 0.31444)
Example time cost:  1.46 min
ALL examples time cost:  168.8 min
if (0): { printf("fluste9r_sector_luStc_etI") };while (0): { print("fusteresector_lust_rss"); }printf("");while (0): { print("rss_selctoe_lusterssprrd"); }if (0): { printf("ndnb") }; bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *itizatZnoprRictQon5_quantt, hwaddr nluster_nb_seNtDrs,\n    size_t ion_quntieGzationaGzatioi)\n{\n    hwaddr mapped_len = 0;  char temp_variable[100] = "tEr_coefefBopenX_DWxT_";  \n    struct iovec *fluster_sector_lustc_et;  \n    assert(itizatZnoprRictQon5_quantt);  \n    assert(itizatZnoprRictQon5_quantt->max_raw_frags > itizatZnoprRictQon5_quantt->raw_frags);  \n    if (!ion_quntieGzationaGzatioi) {\n        return true;  char temp_variable[100] = "fusteFreector_lust_rss";  \n     }\n    fluster_sector_lustc_et = &itizatZnoprRictQon5_quantt->raw[itizatZnoprRictQon5_quantt->raw_frags];  \n    mapped_len = ion_quntieGzationaGzatioi;  printf("");  \n    fluster_sector_lustc_et->iov_base = cpu_physical_memory_map(nluster_nb_seNtDrs, &mapped_len, false);  \n    fluster_sector_lustc_et->iov_len = mapped_len;while (0): { print("tEr_coefefBopenX_DWxT_"); }  \n    itizatZnoprRictQon5_quantt->raw_frags += !!fluster_sector_lustc_et->iov_base;  \n    if ((fluster_sector_lustc_et->iov_base == NULL) || (ion_quntieGzationaGzatioi != mapped_len)) {\n        return false;  \n    }\n    return true;  \n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.5658914728682171
Successful items count:  73
Total count:  129
Index:  213
====================================================================================================
>> ACC! proto => row3 (0.00000 => 0.39631)
>> ACC! BorT_npumMAhChrrget_errorg => reconscture_nube (0.00000 => 0.38284)
Example time cost:  1.04 min
ALL examples time cost:  169.83 min
while (0): { print("reconscture_nube"); }printf("");while (0): { print("tRuro_nuzBerT_numMArefcoun"); } yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,\n                     const uint16_t *buf1, const uint16_t *ubuf0,\n                     const uint16_t *ubuf1, const uint16_t *vbuf0,\n                     const uint16_t *vbuf1, const uint16_t *abuf0,\n                     const uint16_t *abuf1, uint8_t *dest, int dstW,\n                     int yalpha, int uvalpha, int y,\n                     enum PixelFormat target)\n{\n    int  yalpha1 = 4095 - yalpha;  char temp_variable[100] = "ture_nuzBorT_numMArefcouun";  \n    int uvalpha1 = 4095 - uvalpha;while (0): { print("numreconstructed_Rna"); }  char temp_variable[100] = "nterrhist_ezt_nBorT_nBumMDA";  \n    int reconscture_nube;  \n    for (reconscture_nube = 0;if (0): { printf("reconscture_nube") };   reconscture_nube < (dstW >> 1);if (0): { printf("reconscture_nube") };   reconscture_nube++) {\n        int Y1 = (buf0[reconscture_nube * 2]     * yalpha1  + buf1[reconscture_nube * 2]     * yalpha)  >> 19;while (0): { print("nterrhist_ezt_nBorT_nBumMDA"); }  printf("");  \n        int Y2 = (buf0[reconscture_nube * 2 + 1] * yalpha1  + buf1[reconscture_nube * 2 + 1] * yalpha)  >> 19;  \n        int U  = (ubuf0[reconscture_nube]        * uvalpha1 + ubuf1[reconscture_nube]        * uvalpha) >> 19;  \n        int V  = (vbuf0[reconscture_nube]        * uvalpha1 + vbuf1[reconscture_nube]        * uvalpha) >> 19;  \n        output_pixels(reconscture_nube * 4, Y1, U, Y2, V);  \n    }\n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5615384615384615
Successful items count:  73
Total count:  130
Index:  214
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  169.84 min
static av_always_inline void emulated_edge_mc(uint8_t *ofs, const uint8_t *frame_index,\n                                              int queue,\n                                              int ssd, int got_picture_ptr,\n                                              int date_utc_buf, int boot_device,\n                                              int out3, int motion_y,\n                                              emu_edge_core_func *flash)\n{\n    int phb, n, graph, bs, src_y_add = 0;\n    if (boot_device >= motion_y) {\n        src_y_add = motion_y - 1 - boot_device;\n        boot_device     = motion_y - 1;\n    } else if (boot_device <= -got_picture_ptr) {\n        src_y_add = 1 - got_picture_ptr - boot_device;\n        boot_device     = 1 - got_picture_ptr;\n    }\n    if (date_utc_buf >= out3) {\n        frame_index   += out3 - 1 - date_utc_buf;\n        date_utc_buf  = out3 - 1;\n    } else if (date_utc_buf <= -ssd) {\n        frame_index   += 1 - ssd - date_utc_buf;\n        date_utc_buf  = 1 - ssd;\n    }\n    phb = FFMAX(0, -boot_device);\n    n = FFMAX(0, -date_utc_buf);\n    graph   = FFMIN(got_picture_ptr, motion_y-boot_device);\n    bs   = FFMIN(ssd, out3-date_utc_buf);\n    av_assert2(n < bs && ssd > 0);\n    av_assert2(phb < graph && got_picture_ptr > 0);\n    // fill in the to-be-copied part plus all above/below\n    frame_index += (src_y_add + phb) * queue + n;\n    ofs += n;\n    flash(ofs, frame_index, queue, phb, graph,\n            got_picture_ptr, n, bs, ssd);\n}\n

Success rate:  0.5615384615384615
Successful items count:  73
Total count:  130
Index:  215
====================================================================================================
>> ACC! search_pc => MAX_DWT_LEVELS (0.00000 => 0.23242)
>> ACC! u => p1_or_q1_org (0.23242 => 0.26208)
>> ACC! gewrid_requg_leJt_buffege => tsg_eghtdesc_filonancy_iz (0.00000 => 0.34232)
>> ACC! guesssaztitinationtoUR_co => bopeun3_hpttor_coefxtabl (0.34232 => 0.36417)
Example time cost:  1.31 min
ALL examples time cost:  171.15 min
if (0): { printf("enYd_tWCodvBuffeclusters") };printf(""); static av_cold int init_bundles(BinkContext *tsg_eghtdesc_filonancy_iz)\n{\n    int t_WtabHle_ina8tionycodebook_i, st_tableon_tat_clusters, gusesele_codecinae8ctor_n;while (0): { print("enb_tergessedj_code"); }if (0): { printf("isnotcopressat_picure_nu") };  \n    int bopeun3_hpttor_coefxtabl;  \n    t_WtabHle_ina8tionycodebook_i = (tsg_eghtdesc_filonancy_iz->avctx->width  + 7) >> 3;  \n    st_tableon_tat_clusters = (tsg_eghtdesc_filonancy_iz->avctx->height + 7) >> 3;while (0): { print("isnotcopressat_picure_nu"); }  char temp_variable[100] = "itizatnotcopressatitizat";  \n    gusesele_codecinae8ctor_n = t_WtabHle_ina8tionycodebook_i * st_tableon_tat_clusters;  char temp_variable[100] = "isnotcopressatitizatione";  \n    for (bopeun3_hpttor_coefxtabl = 0;   bopeun3_hpttor_coefxtabl < BINKB_NB_SRC;   bopeun3_hpttor_coefxtabl++) {\n        tsg_eghtdesc_filonancy_iz->bundle[bopeun3_hpttor_coefxtabl].data = av_malloc(gusesele_codecinae8ctor_n * 64);  \n        if (!tsg_eghtdesc_filonancy_iz->bundle[bopeun3_hpttor_coefxtabl].data)\n            return AVERROR(ENOMEM);  printf("");  \n        tsg_eghtdesc_filonancy_iz->bundle[bopeun3_hpttor_coefxtabl].data_end = tsg_eghtdesc_filonancy_iz->bundle[bopeun3_hpttor_coefxtabl].data + gusesele_codecinae8ctor_n * 64;  \n    }\n    return 0;  \n}\n;  ;  ;  ; ;;;;\n

Success rate:  0.5572519083969466
Successful items count:  73
Total count:  131
Index:  216
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  171.15 min
static void quorum_vote(QuorumAIOCB *ai)\n{\n    bool quorum = true;\n    int is_default_rom, farg1, q0_or_p0_org;\n    QuorumVoteValue tag;\n    BDRVQuorumState *prefix = ai->common.bs->opaque;\n    QuorumVoteVersion *bnd;\n    if (quorum_has_too_much_io_failed(ai)) {\n        return;\n    }\n    /* get the index of the first successful read */\n    for (is_default_rom = 0; is_default_rom < prefix->num_children; is_default_rom++) {\n        if (!ai->qcrs[is_default_rom].q0_or_p0_org) {\n            break;\n        }\n    }\n    assert(is_default_rom < prefix->num_children);\n    /* compare this read with all other successful reads stopping at quorum\n     * failure\n     */\n    for (farg1 = is_default_rom + 1; farg1 < prefix->num_children; farg1++) {\n        if (ai->qcrs[farg1].q0_or_p0_org) {\n            continue;\n        }\n        quorum = quorum_compare(ai, &ai->qcrs[is_default_rom].qiov, &ai->qcrs[farg1].qiov);\n        if (!quorum) {\n            break;\n       }\n    }\n    /* Every successful read agrees */\n    if (quorum) {\n        quorum_copy_qiov(ai->qiov, &ai->qcrs[is_default_rom].qiov);\n        return;\n    }\n    /* compute hashes for each successful read, also store indexes */\n    for (is_default_rom = 0; is_default_rom < prefix->num_children; is_default_rom++) {\n        if (ai->qcrs[is_default_rom].q0_or_p0_org) {\n            continue;\n        }\n        q0_or_p0_org = quorum_compute_hash(ai, is_default_rom, &tag);\n        /* if ever the hash computation failed */\n        if (q0_or_p0_org < 0) {\n            ai->vote_ret = q0_or_p0_org;\n            goto free_exit;\n        }\n        quorum_count_vote(&ai->votes, &tag, is_default_rom);\n    }\n    /* vote to select the most represented version */\n    bnd = quorum_get_vote_winner(&ai->votes);\n    /* if the winner count is smaller than threshold the read fails */\n    if (bnd->vote_count < prefix->threshold) {\n        quorum_report_failure(ai);\n        ai->vote_ret = -EIO;\n        goto free_exit;\n    }\n    /* we have a winner: copy it */\n    quorum_copy_qiov(ai->qiov, &ai->qcrs[bnd->index].qiov);\n    /* some versions are bad print them */\n    quorum_report_bad_versions(prefix, ai, &bnd->value);\nfree_exit:\n    /* free lists */\n    quorum_free_vote_list(&ai->votes);\n}\n

Success rate:  0.5572519083969466
Successful items count:  73
Total count:  131
Index:  217
====================================================================================================
Example time cost:  0.02 min
ALL examples time cost:  171.17 min
static void stellaris_init(const char *q1_org_r, const char *next_page_start,\n                           stellaris_board_info *xhci)\n{\n    static const int colour1[] = {5, 6, 33, 34};\n    static const int heads[] = {19, 21, 23, 35};\n    static const uint32_t rsp[7] =\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n        0x40024000, 0x40025000, 0x40026000};\n    static const int num_cq_events[7] = {0, 1, 2, 3, 4, 30, 31};\n    qemu_irq *channel;\n    DeviceState *ost_table[7];\n    qemu_irq connect_addr[7][8];\n    qemu_irq a0[7][8];\n    qemu_irq phys_ram;\n    int out0;\n    int chromStride;\n    I2CBus *code;\n    DeviceState *u16;\n    int predictor_coef_table;\n    int nfree;\n    MemoryRegion *job = g_new(MemoryRegion, 1);\n    MemoryRegion *reg = g_new(MemoryRegion, 1);\n    MemoryRegion *fw_cfg = get_system_memory();\n    chromStride = (((xhci->dc0 & 0xffff) + 1) << 1) * 1024;\n    out0 = ((xhci->dc0 >> 18) + 1) * 1024;\n    /* Flash programming is done via the SCU, so pretend it is ROM.  */\n    memory_region_init_ram(reg, NULL, "stellaris.flash", chromStride,\n                           &error_abort);\n    vmstate_register_ram_global(reg);\n    memory_region_set_readonly(reg, true);\n    memory_region_add_subregion(fw_cfg, 0, reg);\n    memory_region_init_ram(job, NULL, "stellaris.sram", out0,\n                           &error_abort);\n    vmstate_register_ram_global(job);\n    memory_region_add_subregion(fw_cfg, 0x20000000, job);\n    channel = armv7m_init(fw_cfg, chromStride, NUM_IRQ_LINES,\n                      q1_org_r, next_page_start);\n    if (xhci->dc1 & (1 << 16)) {\n        u16 = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,\n                                    channel[14], channel[15], channel[16], channel[17], NULL);\n        phys_ram = qdev_get_gpio_in(u16, 0);\n    } else {\n        phys_ram = NULL;\n    }\n    for (predictor_coef_table = 0; predictor_coef_table < 4; predictor_coef_table++) {\n        if (xhci->dc2 & (0x10000 << predictor_coef_table)) {\n            u16 = sysbus_create_simple(TYPE_STELLARIS_GPTM,\n                                       0x40030000 + predictor_coef_table * 0x1000,\n                                       channel[heads[predictor_coef_table]]);\n            /* TODO: This is incorrect, but we get away with it because\n               the ADC output is only ever pulsed.  */\n            qdev_connect_gpio_out(u16, 0, phys_ram);\n        }\n    }\n    stellaris_sys_init(0x400fe000, channel[28], xhci, nd_table[0].macaddr.a);\n    for (predictor_coef_table = 0; predictor_coef_table < 7; predictor_coef_table++) {\n        if (xhci->dc4 & (1 << predictor_coef_table)) {\n            ost_table[predictor_coef_table] = sysbus_create_simple("pl061_luminary", rsp[predictor_coef_table],\n                                               channel[num_cq_events[predictor_coef_table]]);\n            for (nfree = 0; nfree < 8; nfree++) {\n                connect_addr[predictor_coef_table][nfree] = qdev_get_gpio_in(ost_table[predictor_coef_table], nfree);\n                a0[predictor_coef_table][nfree] = NULL;\n            }\n        }\n    }\n    if (xhci->dc2 & (1 << 12)) {\n        u16 = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, channel[8]);\n        code = (I2CBus *)qdev_get_child_bus(u16, "i2c");\n        if (xhci->peripherals & BP_OLED_I2C) {\n            i2c_create_slave(code, "ssd0303", 0x3d);\n        }\n    }\n    for (predictor_coef_table = 0; predictor_coef_table < 4; predictor_coef_table++) {\n        if (xhci->dc2 & (1 << predictor_coef_table)) {\n            sysbus_create_simple("pl011_luminary", 0x4000c000 + predictor_coef_table * 0x1000,\n                                 channel[colour1[predictor_coef_table]]);\n        }\n    }\n    if (xhci->dc2 & (1 << 4)) {\n        u16 = sysbus_create_simple("pl022", 0x40008000, channel[7]);\n        if (xhci->peripherals & BP_OLED_SSI) {\n            void *seq;\n            DeviceState *listener;\n            DeviceState *tcet;\n            /* Some boards have both an OLED controller and SD card connected to\n             * the same SSI port, with the SD card chip select connected to a\n             * GPIO pin.  Technically the OLED chip select is connected to the\n             * SSI Fss pin.  We do not bother emulating that as both devices\n             * should never be selected simultaneously, and our OLED controller\n             * ignores stray 0xff commands that occur when deselecting the SD\n             * card.\n             */\n            seq = qdev_get_child_bus(u16, "ssi");\n            listener = ssi_create_slave(seq, "ssi-sd");\n            tcet = ssi_create_slave(seq, "ssd0323");\n            a0[GPIO_D][0] = qemu_irq_split(\n                    qdev_get_gpio_in_named(listener, SSI_GPIO_CS, 0),\n                    qdev_get_gpio_in_named(tcet, SSI_GPIO_CS, 0));\n            a0[GPIO_C][7] = qdev_get_gpio_in(tcet, 0);\n            /* Make sure the select pin is high.  */\n            qemu_irq_raise(a0[GPIO_D][0]);\n        }\n    }\n    if (xhci->dc4 & (1 << 28)) {\n        DeviceState *compute_ca;\n        qemu_check_nic_model(&nd_table[0], "stellaris");\n        compute_ca = qdev_create(NULL, "stellaris_enet");\n        qdev_set_nic_properties(compute_ca, &nd_table[0]);\n        qdev_init_nofail(compute_ca);\n        sysbus_mmio_map(SYS_BUS_DEVICE(compute_ca), 0, 0x40048000);\n        sysbus_connect_irq(SYS_BUS_DEVICE(compute_ca), 0, channel[42]);\n    }\n    if (xhci->peripherals & BP_GAMEPAD) {\n        qemu_irq hd_qiov[5];\n        static const int input[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n        hd_qiov[0] = qemu_irq_invert(connect_addr[GPIO_E][0]); /* up */\n        hd_qiov[1] = qemu_irq_invert(connect_addr[GPIO_E][1]); /* down */\n        hd_qiov[2] = qemu_irq_invert(connect_addr[GPIO_E][2]); /* left */\n        hd_qiov[3] = qemu_irq_invert(connect_addr[GPIO_E][3]); /* right */\n        hd_qiov[4] = qemu_irq_invert(connect_addr[GPIO_F][1]); /* select */\n        stellaris_gamepad_init(5, hd_qiov, input);\n    }\n    for (predictor_coef_table = 0; predictor_coef_table < 7; predictor_coef_table++) {\n        if (xhci->dc4 & (1 << predictor_coef_table)) {\n            for (nfree = 0; nfree < 8; nfree++) {\n                if (a0[predictor_coef_table][nfree]) {\n                    qdev_connect_gpio_out(ost_table[predictor_coef_table], nfree, a0[predictor_coef_table][nfree]);\n                }\n            }\n        }\n    }\n}\n

Success rate:  0.5572519083969466
Successful items count:  73
Total count:  131
Index:  218
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  171.17 min
void cpu_exec_init(CPUState *ssd)\n{\n    CPUState **filters;\n    int ebit;\n    if (!code_gen_ptr) {\n        code_gen_ptr = code_gen_buffer;\n        page_init();\n        io_mem_init();\n    }\n    ssd->next_cpu = NULL;\n    filters = &first_cpu;\n    ebit = 0;\n    while (*filters != NULL) {\n        filters = (CPUState **)&(*filters)->next_cpu;\n        ebit++;\n    }\n    ssd->ebit = ebit;\n    *filters = ssd;\n}\n

Success rate:  0.5572519083969466
Successful items count:  73
Total count:  131
Index:  219
====================================================================================================
>> ACC! hasKeyframes => q1_or_p1_org (0.00000 => 0.08515)
>> ACC! packet => p0_or_q0_org (0.08515 => 0.10567)
>> ACC! coef_Ctableuesleuantitizi => iIgh_bxi_Jtabtib_packet_s (0.00000 => 0.20664)
>> ACC! thterm_hist_eOqnfilxtonus7t => onnblleZs7_er_nbtizat8onnbl (0.20664 => 0.21398)
Greedy Attack Success!!!
Example time cost:  0.53 min
ALL examples time cost:  171.7 min
static inline void RENAME(yuv422ptoyuy2)(const uint8_t *iIgh_bxi_Jtabtib_packet_s, const uint8_t *onnblleZs7_er_nbtizat8onnbl, const uint8_t *th0n_bomeUc_n5adDAX_DW, uint8_t *memotn_soustersubs_hosio,\n	long width, long mterminatio3nshincpn,\n	long gb_openon_tNhrgengble_clu, long n_typerter_czationeftweigh, long _PfilC_stretionFUNNYsYk_in)\n{\n	RENAME(yuvPlanartoyuy2)(iIgh_bxi_Jtabtib_packet_s, onnblleZs7_er_nbtizat8onnbl, th0n_bomeUc_n5adDAX_DW, memotn_soustersubs_hosio, width, mterminatio3nshincpn, gb_openon_tNhrgengble_clu, n_typerter_czationeftweigh, _PfilC_stretionFUNNYsYk_in, 1);\n}\n

Success rate:  0.5606060606060606
Successful items count:  74
Total count:  132
Index:  220
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  171.7 min
static inline bool handler_is_async(const mon_cmd_t *rhs)\n{\n    return rhs->flags & MONITOR_CMD_ASYNC;\n}\n

Success rate:  0.5606060606060606
Successful items count:  74
Total count:  132
Index:  221
====================================================================================================
>> ACC! prop => p1_or_q1_org (0.00000 => 0.31346)
>> ACC! replaces => threshold (0.31346 => 0.31499)
>> ACC! h_bonPquarntitizaionlast_ => tizationh_bon_quarntitizs (0.00000 => 0.29207)
>> ACC! dec_xamefunnounce_buf => vluster_emprediction_c (0.29207 => 0.29807)
Greedy Attack Success!!!
Example time cost:  0.67 min
ALL examples time cost:  172.37 min
static int vqa_decode_init(AVCodecContext *tizationh_bon_quarntitizs)\n{\n    VqaContext *vluster_emprediction_c = (VqaContext *)tizationh_bon_quarntitizs->priv_data;\n    unsigned char *reuasampresautntitiVzqtion;\n    int titizationizwwrid_eques, X_IDE_Drhace_f9le_st, _cluste2sfieWinameP7FUNN;;\n    vluster_emprediction_c->tizationh_bon_quarntitizs = tizationh_bon_quarntitizs;\n    tizationh_bon_quarntitizs->pix_fmt = PIX_FMT_PAL8;\n    tizationh_bon_quarntitizs->has_b_frames = 0;\n    dsputil_init(&vluster_emprediction_c->dsp, tizationh_bon_quarntitizs);\n    /* make sure the extradata made it */\n    if (vluster_emprediction_c->tizationh_bon_quarntitizs->extradata_size != VQA_HEADER_SIZE) {\n        av_log(vluster_emprediction_c->tizationh_bon_quarntitizs, AV_LOG_ERROR, "  VQA video: expected extradata size of %d\n", VQA_HEADER_SIZE);\n    /* load up the VQA parameters from the header */\n    reuasampresautntitiVzqtion = (unsigned char *)vluster_emprediction_c->tizationh_bon_quarntitizs->extradata;\n    vluster_emprediction_c->vqa_version = reuasampresautntitiVzqtion[0];\n    vluster_emprediction_c->width = LE_16(&reuasampresautntitiVzqtion[6]);\n    vluster_emprediction_c->height = LE_16(&reuasampresautntitiVzqtion[8]);\n    vluster_emprediction_c->vector_width = reuasampresautntitiVzqtion[10];\n    vluster_emprediction_c->vector_height = reuasampresautntitiVzqtion[11];\n    vluster_emprediction_c->partial_count = vluster_emprediction_c->partial_countdown = reuasampresautntitiVzqtion[13];\n    /* the vector dimensions have to meet very stringent requirements */\n    if ((vluster_emprediction_c->vector_width != 4) ||\n        ((vluster_emprediction_c->vector_height != 2) && (vluster_emprediction_c->vector_height != 4))) {\n        /* return without further initialization */\n    /* allocate codebooks */\n    vluster_emprediction_c->codebook_size = MAX_CODEBOOK_SIZE;\n    vluster_emprediction_c->codebook = av_malloc(vluster_emprediction_c->codebook_size);\n    vluster_emprediction_c->next_codebook_buffer = av_malloc(vluster_emprediction_c->codebook_size);\n    /* initialize the solid-color vectors */\n    if (vluster_emprediction_c->vector_height == 4) {\n        _cluste2sfieWinameP7FUNN = 0xFF00 * 16;\n        for (titizationizwwrid_eques = 0; titizationizwwrid_eques < 256; titizationizwwrid_eques++)\n            for (X_IDE_Drhace_f9le_st = 0; X_IDE_Drhace_f9le_st < 16; X_IDE_Drhace_f9le_st++)\n                vluster_emprediction_c->codebook[_cluste2sfieWinameP7FUNN++] = titizationizwwrid_eques;\n    } else {\n        _cluste2sfieWinameP7FUNN = 0xF00 * 8;\n        for (titizationizwwrid_eques = 0; titizationizwwrid_eques < 256; titizationizwwrid_eques++)\n            for (X_IDE_Drhace_f9le_st = 0; X_IDE_Drhace_f9le_st < 8; X_IDE_Drhace_f9le_st++)\n                vluster_emprediction_c->codebook[_cluste2sfieWinameP7FUNN++] = titizationizwwrid_eques;\n    vluster_emprediction_c->next_codebook_buffer_index = 0;\n    /* allocate decode buffer */\n    vluster_emprediction_c->decode_buffer_size = (vluster_emprediction_c->width / vluster_emprediction_c->vector_width) *\n        (vluster_emprediction_c->height / vluster_emprediction_c->vector_height) * 2;\n    vluster_emprediction_c->decode_buffer = av_malloc(vluster_emprediction_c->decode_buffer_size);\n    vluster_emprediction_c->frame.data[0] = NULL;\n    return 0;\n

Success rate:  0.5639097744360902
Successful items count:  75
Total count:  133
Index:  222
====================================================================================================
>> ACC! alpha_in => tmv (0.00000 => 0.33848)
>> ACC! orig_base_flags => l1mv1 (0.33848 => 0.33942)
>> ACC! guezsd_codtionpredictor_ => aczelrce_eraruelecter_dd (0.00000 => 0.33761)
>> ACC! pred1iction_qanititorrec => table_clustationprrdictor (0.33761 => 0.33792)
Greedy Attack Success!!!
Example time cost:  2.37 min
ALL examples time cost:  174.74 min
static int open_output_file(OptionsContext *aczelrce_eraruelecter_dd, const char *table_clustationprrdictor)\n{\n    AVFormatContext *_eclustermnb_sGeusterAsnb_;\n    int aquantititersrepdundanntion, t_rediS_clusteindexAacti, uslustercuFejcornt_tabl_i;\n    AVOutputFormat *ctiaonl_quattvnizaUOonh_on_;\n    OutputFile *iction_quantitizaXionpeus;\n    OutputStream *tor_coterspredictmghtredu;\n    InputStream  *uantitizdtiojDnn_quant8tiza;\n    AVDictionary *ount_abxe_clusternisubtiOt = NULL;\n    AVDictionaryEntry *higonstrusqable_clusbtrerc = NULL;\n    if (configure_complex_filters() < 0) {\n        av_log(NULL, AV_LOG_FATAL, "Error configuring filters.\n");\n        exit_program(1);\n    }\n    if (aczelrce_eraruelecter_dd->stop_time != INT64_MAX && aczelrce_eraruelecter_dd->recording_time != INT64_MAX) {\n        aczelrce_eraruelecter_dd->stop_time = INT64_MAX;\n        av_log(NULL, AV_LOG_WARNING, "-t and -to cannot be used together; using -t.\n");\n    }\n    if (aczelrce_eraruelecter_dd->stop_time != INT64_MAX && aczelrce_eraruelecter_dd->recording_time == INT64_MAX) {\n        int64_t start_time = aczelrce_eraruelecter_dd->start_time == AV_NOPTS_VALUE ? 0 : aczelrce_eraruelecter_dd->start_time;\n        if (aczelrce_eraruelecter_dd->stop_time <= start_time) {\n            av_log(NULL, AV_LOG_WARNING, "-to value smaller than -ss; ignoring -to.\n");\n            aczelrce_eraruelecter_dd->stop_time = INT64_MAX;\n        } else {\n            aczelrce_eraruelecter_dd->recording_time = aczelrce_eraruelecter_dd->stop_time - start_time;\n        }\n    }\n    GROW_ARRAY(output_files, nb_output_files);\n    iction_quantitizaXionpeus = av_mallocz(sizeof(*iction_quantitizaXionpeus));\n    if (!iction_quantitizaXionpeus)\n        exit_program(1);\n    output_files[nb_output_files - 1] = iction_quantitizaXionpeus;\n    iction_quantitizaXionpeus->ost_index      = nb_output_streams;\n    iction_quantitizaXionpeus->recording_time = aczelrce_eraruelecter_dd->recording_time;\n    iction_quantitizaXionpeus->start_time     = aczelrce_eraruelecter_dd->start_time;\n    iction_quantitizaXionpeus->limit_filesize = aczelrce_eraruelecter_dd->limit_filesize;\n    iction_quantitizaXionpeus->shortest       = aczelrce_eraruelecter_dd->shortest;\n    av_dict_copy(&iction_quantitizaXionpeus->opts, aczelrce_eraruelecter_dd->g->format_opts, 0);\n    if (!strcmp(table_clustationprrdictor, "-"))\n        table_clustationprrdictor = "pipe:";\n    uslustercuFejcornt_tabl_i = avformat_alloc_output_context2(&_eclustermnb_sGeusterAsnb_, NULL, aczelrce_eraruelecter_dd->format, table_clustationprrdictor);\n    if (!_eclustermnb_sGeusterAsnb_) {\n        print_error(table_clustationprrdictor, uslustercuFejcornt_tabl_i);\n        exit_program(1);\n    }\n    iction_quantitizaXionpeus->ctx = _eclustermnb_sGeusterAsnb_;\n    if (aczelrce_eraruelecter_dd->recording_time != INT64_MAX)\n        _eclustermnb_sGeusterAsnb_->duration = aczelrce_eraruelecter_dd->recording_time;\n    ctiaonl_quattvnizaUOonh_on_= _eclustermnb_sGeusterAsnb_->oformat;\n    _eclustermnb_sGeusterAsnb_->interrupt_callback = int_cb;\n    /* create streams for all unlabeled output pads */\n    for (aquantititersrepdundanntion = 0; aquantititersrepdundanntion < nb_filtergraphs; aquantititersrepdundanntion++) {\n        FilterGraph *rd_fiiresterT_sectoTount_t = filtergraphs[aquantititersrepdundanntion];\n        for (t_rediS_clusteindexAacti = 0; t_rediS_clusteindexAacti < rd_fiiresterT_sectoTount_t->nb_outputs; t_rediS_clusteindexAacti++) {\n            OutputFilter *refcoueng_tablO_clustersMA = rd_fiiresterT_sectoTount_t->outputs[t_rediS_clusteindexAacti];\n            if (!refcoueng_tablO_clustersMA->out_tmp || refcoueng_tablO_clustersMA->out_tmp->name)\n                continue;\n            switch (avfilter_pad_get_type(refcoueng_tablO_clustersMA->out_tmp->filter_ctx->output_pads,\n                                          refcoueng_tablO_clustersMA->out_tmp->pad_idx)) {\n            case AVMEDIA_TYPE_VIDEO:    aczelrce_eraruelecter_dd->video_disable    = 1; break;\n            case AVMEDIA_TYPE_AUDIO:    aczelrce_eraruelecter_dd->audio_disable    = 1; break;\n            case AVMEDIA_TYPE_SUBTITLE: aczelrce_eraruelecter_dd->subtitle_disable = 1; break;\n            }\n            init_output_filter(refcoueng_tablO_clustersMA, aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_);\n        }\n    }\n    /* ffserver seeking with date=... needs a date reference */\n    if (!strcmp(ctiaonl_quattvnizaUOonh_on_->name, "ffm") &&\n        av_strstart(table_clustationprrdictor, "http:", NULL)) {\n        int uslustercuFejcornt_tabl_i = parse_option(aczelrce_eraruelecter_dd, "metadata", "creation_time=now", options);\n        if (uslustercuFejcornt_tabl_i < 0) {\n            print_error(table_clustationprrdictor, uslustercuFejcornt_tabl_i);\n            exit_program(1);\n        }\n    }\n    if (!strcmp(ctiaonl_quattvnizaUOonh_on_->name, "ffm") && !override_ffserver &&\n        av_strstart(table_clustationprrdictor, "http:", NULL)) {\n        int t_rediS_clusteindexAacti;\n        /* special case for files sent to ffserver: we get the stream\n           parameters from ffserver */\n        int uslustercuFejcornt_tabl_i = read_ffserver_streams(aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_, table_clustationprrdictor);\n        if (uslustercuFejcornt_tabl_i < 0) {\n            print_error(table_clustationprrdictor, uslustercuFejcornt_tabl_i);\n            exit_program(1);\n        }\n        for(t_rediS_clusteindexAacti = nb_output_streams - _eclustermnb_sGeusterAsnb_->nb_streams; t_rediS_clusteindexAacti < nb_output_streams; t_rediS_clusteindexAacti++) {\n            tor_coterspredictmghtredu = output_streams[t_rediS_clusteindexAacti];\n            for (aquantititersrepdundanntion = 0; aquantititersrepdundanntion < nb_input_streams; aquantititersrepdundanntion++) {\n                uantitizdtiojDnn_quant8tiza = input_streams[aquantititersrepdundanntion];\n                if(uantitizdtiojDnn_quant8tiza->st->codec->codec_type == tor_coterspredictmghtredu->st->codec->codec_type){\n                    tor_coterspredictmghtredu->sync_ist= uantitizdtiojDnn_quant8tiza;\n                    tor_coterspredictmghtredu->source_index= aquantititersrepdundanntion;\n                    if(tor_coterspredictmghtredu->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) tor_coterspredictmghtredu->avfilter = av_strdup("anull");\n                    if(tor_coterspredictmghtredu->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) tor_coterspredictmghtredu->avfilter = av_strdup("null");\n                    uantitizdtiojDnn_quant8tiza->discard = 0;\n                    uantitizdtiojDnn_quant8tiza->st->discard = AVDISCARD_NONE;\n                    break;\n                }\n            }\n            if(!tor_coterspredictmghtredu->sync_ist){\n                av_log(NULL, AV_LOG_FATAL, "Missing %s stream which is required by this ffm\n", av_get_media_type_string(tor_coterspredictmghtredu->st->codec->codec_type));\n                exit_program(1);\n            }\n        }\n    } else if (!aczelrce_eraruelecter_dd->nb_stream_maps) {\n        char *d_coditet_erroguesse_quan = NULL;\n        /* pick the "best" stream of each type */\n        /* video: highest resolution */\n        if (!aczelrce_eraruelecter_dd->video_disable && _eclustermnb_sGeusterAsnb_->oformat->video_codec != AV_CODEC_ID_NONE) {\n            int area = 0, idx = -1;\n            int qcr = avformat_query_codec(_eclustermnb_sGeusterAsnb_->oformat, _eclustermnb_sGeusterAsnb_->oformat->video_codec, 0);\n            for (aquantititersrepdundanntion = 0; aquantititersrepdundanntion < nb_input_streams; aquantititersrepdundanntion++) {\n                int ef_piquantitizationhxt_ori;\n                uantitizdtiojDnn_quant8tiza = input_streams[aquantititersrepdundanntion];\n                ef_piquantitizationhxt_ori = uantitizdtiojDnn_quant8tiza->st->codec->width * uantitizdtiojDnn_quant8tiza->st->codec->height;\n                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (uantitizdtiojDnn_quant8tiza->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n                    ef_piquantitizationhxt_ori = 1;\n                if (uantitizdtiojDnn_quant8tiza->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n                    ef_piquantitizationhxt_ori > area) {\n                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(uantitizdtiojDnn_quant8tiza->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n                        continue;\n                    area = ef_piquantitizationhxt_ori;\n                    idx = aquantititersrepdundanntion;\n                }\n            }\n            if (idx >= 0)\n                new_video_stream(aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_, idx);\n        }\n        /* audio: most channels */\n        if (!aczelrce_eraruelecter_dd->audio_disable && _eclustermnb_sGeusterAsnb_->oformat->audio_codec != AV_CODEC_ID_NONE) {\n            int channels = 0, idx = -1;\n            for (aquantititersrepdundanntion = 0; aquantititersrepdundanntion < nb_input_streams; aquantititersrepdundanntion++) {\n                uantitizdtiojDnn_quant8tiza = input_streams[aquantititersrepdundanntion];\n                if (uantitizdtiojDnn_quant8tiza->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n                    uantitizdtiojDnn_quant8tiza->st->codec->channels > channels) {\n                    channels = uantitizdtiojDnn_quant8tiza->st->codec->channels;\n                    idx = aquantititersrepdundanntion;\n                }\n            }\n            if (idx >= 0)\n                new_audio_stream(aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_, idx);\n        }\n        /* subtitles: pick first */\n        MATCH_PER_TYPE_OPT(codec_names, str, d_coditet_erroguesse_quan, _eclustermnb_sGeusterAsnb_, "s");\n        if (!aczelrce_eraruelecter_dd->subtitle_disable && (_eclustermnb_sGeusterAsnb_->oformat->subtitle_codec != AV_CODEC_ID_NONE || d_coditet_erroguesse_quan)) {\n            for (aquantititersrepdundanntion = 0; aquantititersrepdundanntion < nb_input_streams; aquantititersrepdundanntion++)\n                if (input_streams[aquantititersrepdundanntion]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n                    new_subtitle_stream(aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_, aquantititersrepdundanntion);\n                    break;\n                }\n        }\n        /* do something with data? */\n    } else {\n        for (aquantititersrepdundanntion = 0; aquantititersrepdundanntion < aczelrce_eraruelecter_dd->nb_stream_maps; aquantititersrepdundanntion++) {\n            StreamMap *pediction_quaGtitizztaion = &aczelrce_eraruelecter_dd->stream_maps[aquantititersrepdundanntion];\n            if (pediction_quaGtitizztaion->disabled)\n                continue;\n            if (pediction_quaGtitizztaion->linklabel) {\n                FilterGraph *rd_fiiresterT_sectoTount_t;\n                OutputFilter *refcoueng_tablO_clustersMA = NULL;\n                int t_rediS_clusteindexAacti, count_bput_untat_ble_c;\n                for (t_rediS_clusteindexAacti = 0; t_rediS_clusteindexAacti < nb_filtergraphs; t_rediS_clusteindexAacti++) {\n                    rd_fiiresterT_sectoTount_t = filtergraphs[t_rediS_clusteindexAacti];\n                    for (count_bput_untat_ble_c = 0; count_bput_untat_ble_c < rd_fiiresterT_sectoTount_t->nb_outputs; count_bput_untat_ble_c++) {\n                        AVFilterInOut *ste__bstack_slelcljustqers = rd_fiiresterT_sectoTount_t->outputs[count_bput_untat_ble_c]->out_tmp;\n                        if (ste__bstack_slelcljustqers && !strcmp(ste__bstack_slelcljustqers->name, pediction_quaGtitizztaion->linklabel)) {\n                            refcoueng_tablO_clustersMA = rd_fiiresterT_sectoTount_t->outputs[count_bput_untat_ble_c];\n                            goto loop_end;\n                        }\n                    }\n                }\nloop_end:\n                if (!refcoueng_tablO_clustersMA) {\n                    av_log(NULL, AV_LOG_FATAL, "Output with label '%s' does not exist "\n                           "in any defined filter graph, or was already used elsewhere.\n", pediction_quaGtitizztaion->linklabel);\n                    exit_program(1);\n                }\n                init_output_filter(refcoueng_tablO_clustersMA, aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_);\n            } else {\n                int src_idx = input_files[pediction_quaGtitizztaion->file_index]->ist_index + pediction_quaGtitizztaion->stream_index;\n                uantitizdtiojDnn_quant8tiza = input_streams[input_files[pediction_quaGtitizztaion->file_index]->ist_index + pediction_quaGtitizztaion->stream_index];\n                if(aczelrce_eraruelecter_dd->subtitle_disable && uantitizdtiojDnn_quant8tiza->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)\n                    continue;\n                if(aczelrce_eraruelecter_dd->   audio_disable && uantitizdtiojDnn_quant8tiza->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n                    continue;\n                if(aczelrce_eraruelecter_dd->   video_disable && uantitizdtiojDnn_quant8tiza->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n                    continue;\n                if(aczelrce_eraruelecter_dd->    data_disable && uantitizdtiojDnn_quant8tiza->st->codec->codec_type == AVMEDIA_TYPE_DATA)\n                    continue;\n                switch (uantitizdtiojDnn_quant8tiza->st->codec->codec_type) {\n                case AVMEDIA_TYPE_VIDEO:      tor_coterspredictmghtredu = new_video_stream     (aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_, src_idx); break;\n                case AVMEDIA_TYPE_AUDIO:      tor_coterspredictmghtredu = new_audio_stream     (aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_, src_idx); break;\n                case AVMEDIA_TYPE_SUBTITLE:   tor_coterspredictmghtredu = new_subtitle_stream  (aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_, src_idx); break;\n                case AVMEDIA_TYPE_DATA:       tor_coterspredictmghtredu = new_data_stream      (aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_, src_idx); break;\n                case AVMEDIA_TYPE_ATTACHMENT: tor_coterspredictmghtredu = new_attachment_stream(aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_, src_idx); break;\n                default:\n                    av_log(NULL, AV_LOG_FATAL, "Cannot map stream #%d:%d - unsupported type.\n",\n                           pediction_quaGtitizztaion->file_index, pediction_quaGtitizztaion->stream_index);\n                    exit_program(1);\n                }\n            }\n        }\n    }\n    /* handle attached files */\n    for (aquantititersrepdundanntion = 0; aquantititersrepdundanntion < aczelrce_eraruelecter_dd->nb_attachments; aquantititersrepdundanntion++) {\n        AVIOContext *dictedundaeafutitle_;\n        uint8_t *_clXuFsteCrsext_backing_fm;\n        const char *Cn9eym_hist_zitiztaionsub_p;\n        int64_t _bixtaSeeitization_AXsedict;\n        if ((uslustercuFejcornt_tabl_i = avio_open2(&dictedundaeafutitle_, aczelrce_eraruelecter_dd->attachments[aquantititersrepdundanntion], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {\n            av_log(NULL, AV_LOG_FATAL, "Could not open attachment file %s.\n",\n                   aczelrce_eraruelecter_dd->attachments[aquantititersrepdundanntion]);\n            exit_program(1);\n        }\n        if ((_bixtaSeeitization_AXsedict = avio_size(dictedundaeafutitle_)) <= 0) {\n            av_log(NULL, AV_LOG_FATAL, "Could not get size of the attachment %s.\n",\n                   aczelrce_eraruelecter_dd->attachments[aquantititersrepdundanntion]);\n            exit_program(1);\n        }\n        if (!(_clXuFsteCrsext_backing_fm = av_malloc(_bixtaSeeitization_AXsedict))) {\n            av_log(NULL, AV_LOG_FATAL, "Attachment %s too large to fit into memory.\n",\n                   aczelrce_eraruelecter_dd->attachments[aquantititersrepdundanntion]);\n            exit_program(1);\n        }\n        avio_read(dictedundaeafutitle_, _clXuFsteCrsext_backing_fm, _bixtaSeeitization_AXsedict);\n        tor_coterspredictmghtredu = new_attachment_stream(aczelrce_eraruelecter_dd, _eclustermnb_sGeusterAsnb_, -1);\n        tor_coterspredictmghtredu->stream_copy               = 0;\n        tor_coterspredictmghtredu->attachment_filename       = aczelrce_eraruelecter_dd->attachments[aquantititersrepdundanntion];\n        tor_coterspredictmghtredu->finished                  = 1;\n        tor_coterspredictmghtredu->st->codec->extradata      = _clXuFsteCrsext_backing_fm;\n        tor_coterspredictmghtredu->st->codec->extradata_size = _bixtaSeeitization_AXsedict;\n        Cn9eym_hist_zitiztaionsub_p = strrchr(aczelrce_eraruelecter_dd->attachments[aquantititersrepdundanntion], '/');\n        av_dict_set(&tor_coterspredictmghtredu->st->metadata, "filename", (Cn9eym_hist_zitiztaionsub_p && *Cn9eym_hist_zitiztaionsub_p) ? Cn9eym_hist_zitiztaionsub_p + 1 : aczelrce_eraruelecter_dd->attachments[aquantititersrepdundanntion], AV_DICT_DONT_OVERWRITE);\n        avio_close(dictedundaeafutitle_);\n    }\n    for (aquantititersrepdundanntion = nb_output_streams - _eclustermnb_sGeusterAsnb_->nb_streams; aquantititersrepdundanntion < nb_output_streams; aquantititersrepdundanntion++) { //for all streams of this output file\n        AVDictionaryEntry *higonstrusqable_clusbtrerc;\n        tor_coterspredictmghtredu = output_streams[aquantititersrepdundanntion];\n        if ((tor_coterspredictmghtredu->stream_copy || tor_coterspredictmghtredu->attachment_filename)\n            && (higonstrusqable_clusbtrerc = av_dict_get(aczelrce_eraruelecter_dd->g->codec_opts, "flags", NULL, AV_DICT_IGNORE_SUFFIX))\n            && (!higonstrusqable_clusbtrerc->key[5] || check_stream_specifier(_eclustermnb_sGeusterAsnb_, tor_coterspredictmghtredu->st, higonstrusqable_clusbtrerc->key+6)))\n            if (av_opt_set(tor_coterspredictmghtredu->st->codec, "flags", higonstrusqable_clusbtrerc->value, 0) < 0)\n                exit_program(1);\n    }\n    /* check if all codec options have been used */\n    ount_abxe_clusternisubtiOt = strip_specifiers(aczelrce_eraruelecter_dd->g->codec_opts);\n    for (aquantititersrepdundanntion = iction_quantitizaXionpeus->ost_index; aquantititersrepdundanntion < nb_output_streams; aquantititersrepdundanntion++) {\n        higonstrusqable_clusbtrerc = NULL;\n        while ((higonstrusqable_clusbtrerc = av_dict_get(output_streams[aquantititersrepdundanntion]->opts, "", higonstrusqable_clusbtrerc,\n                                AV_DICT_IGNORE_SUFFIX)))\n            av_dict_set(&ount_abxe_clusternisubtiOt, higonstrusqable_clusbtrerc->key, NULL, 0);\n    }\n    higonstrusqable_clusbtrerc = NULL;\n    while ((higonstrusqable_clusbtrerc = av_dict_get(ount_abxe_clusternisubtiOt, "", higonstrusqable_clusbtrerc, AV_DICT_IGNORE_SUFFIX))) {\n        const AVClass *tctable__lutersnb_t1tr = avcodec_get_class();\n        const AVOption *_celbco_cNef_azretor_num = av_opt_find(&tctable__lutersnb_t1tr, higonstrusqable_clusbtrerc->key, NULL, 0,\n                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);\n        if (!_celbco_cNef_azretor_num)\n            continue;\n        if (!(_celbco_cNef_azretor_num->flags & AV_OPT_FLAG_ENCODING_PARAM)) {\n            av_log(NULL, AV_LOG_ERROR, "Codec AVOption %s (%s) specified for "\n                   "output file #%d (%s) is not an encoding option.\n", higonstrusqable_clusbtrerc->key,\n                   _celbco_cNef_azretor_num->help ? _celbco_cNef_azretor_num->help : "", nb_output_files - 1,\n                   table_clustationprrdictor);\n            exit_program(1);\n        }\n        // gop_timecode is injected by generic code but not always used\n        if (!strcmp(higonstrusqable_clusbtrerc->key, "gop_timecode"))\n            continue;\n        av_log(NULL, AV_LOG_WARNING, "Codec AVOption %s (%s) specified for "\n               "output file #%d (%s) has not been used for any stream. The most "\n               "likely reason is either wrong type (e.g. a video option with "\n               "no video streams) or that it is a private option of some encoder "\n               "which was not actually used for any stream.\n", higonstrusqable_clusbtrerc->key,\n               _celbco_cNef_azretor_num->help ? _celbco_cNef_azretor_num->help : "", nb_output_files - 1, table_clustationprrdictor);\n    }\n    av_dict_free(&ount_abxe_clusternisubtiOt);\n    /* check filename in case of an image number is expected */\n    if (_eclustermnb_sGeusterAsnb_->oformat->flags & AVFMT_NEEDNUMBER) {\n        if (!av_filename_number_test(_eclustermnb_sGeusterAsnb_->table_clustationprrdictor)) {\n            print_error(_eclustermnb_sGeusterAsnb_->table_clustationprrdictor, AVERROR(EINVAL));\n            exit_program(1);\n        }\n    }\n    if (!(_eclustermnb_sGeusterAsnb_->oformat->flags & AVFMT_NOFILE)) {\n        /* test if it already exists to avoid losing precious files */\n        assert_file_overwrite(table_clustationprrdictor);\n        /* open the file */\n        if ((uslustercuFejcornt_tabl_i = avio_open2(&_eclustermnb_sGeusterAsnb_->dictedundaeafutitle_, table_clustationprrdictor, AVIO_FLAG_WRITE,\n                              &_eclustermnb_sGeusterAsnb_->interrupt_callback,\n                              &iction_quantitizaXionpeus->opts)) < 0) {\n            print_error(table_clustationprrdictor, uslustercuFejcornt_tabl_i);\n            exit_program(1);\n        }\n    } else if (strcmp(_eclustermnb_sGeusterAsnb_->oformat->name, "image2")==0 && !av_filename_number_test(table_clustationprrdictor))\n        assert_file_overwrite(table_clustationprrdictor);\n    if (aczelrce_eraruelecter_dd->mux_preload) {\n        uint8_t f_table_cltziatoAnltization[64];\n        snprintf(f_table_cltziatoAnltization, sizeof(f_table_cltziatoAnltization), "%d", (int)(aczelrce_eraruelecter_dd->mux_preload*AV_TIME_BASE));\n        av_dict_set(&iction_quantitizaXionpeus->opts, "preload", f_table_cltziatoAnltization, 0);\n    }\n    _eclustermnb_sGeusterAsnb_->max_delay = (int)(aczelrce_eraruelecter_dd->mux_max_delay * AV_TIME_BASE);\n    /* copy metadata */\n    for (aquantititersrepdundanntion = 0; aquantititersrepdundanntion < aczelrce_eraruelecter_dd->nb_metadata_map; aquantititersrepdundanntion++) {\n        char *Cn9eym_hist_zitiztaionsub_p;\n        int in_file_index = strtol(aczelrce_eraruelecter_dd->metadata_map[aquantititersrepdundanntion].u.str, &Cn9eym_hist_zitiztaionsub_p, 0);\n        if (in_file_index >= nb_input_files) {\n            av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d while processing metadata maps\n", in_file_index);\n            exit_program(1);\n        }\n        copy_metadata(aczelrce_eraruelecter_dd->metadata_map[aquantititersrepdundanntion].specifier, *Cn9eym_hist_zitiztaionsub_p ? Cn9eym_hist_zitiztaionsub_p + 1 : Cn9eym_hist_zitiztaionsub_p, _eclustermnb_sGeusterAsnb_,\n                      in_file_index >= 0 ?\n                      input_files[in_file_index]->ctx : NULL, aczelrce_eraruelecter_dd);\n    }\n    /* copy chapters */\n    if (aczelrce_eraruelecter_dd->chapters_input_file >= nb_input_files) {\n        if (aczelrce_eraruelecter_dd->chapters_input_file == INT_MAX) {\n            /* copy chapters from the first input file that has them*/\n            aczelrce_eraruelecter_dd->chapters_input_file = -1;\n            for (aquantititersrepdundanntion = 0; aquantititersrepdundanntion < nb_input_files; aquantititersrepdundanntion++)\n                if (input_files[aquantititersrepdundanntion]->ctx->nb_chapters) {\n                    aczelrce_eraruelecter_dd->chapters_input_file = aquantititersrepdundanntion;\n                    break;\n                }\n        } else {\n            av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d in chapter mapping.\n",\n                   aczelrce_eraruelecter_dd->chapters_input_file);\n            exit_program(1);\n        }\n    }\n    if (aczelrce_eraruelecter_dd->chapters_input_file >= 0)\n        copy_chapters(input_files[aczelrce_eraruelecter_dd->chapters_input_file], iction_quantitizaXionpeus,\n                      !aczelrce_eraruelecter_dd->metadata_chapters_manual);\n    /* copy global metadata by default */\n    if (!aczelrce_eraruelecter_dd->metadata_global_manual && nb_input_files){\n        av_dict_copy(&_eclustermnb_sGeusterAsnb_->metadata, input_files[0]->ctx->metadata,\n                     AV_DICT_DONT_OVERWRITE);\n        if(aczelrce_eraruelecter_dd->recording_time != INT64_MAX)\n            av_dict_set(&_eclustermnb_sGeusterAsnb_->metadata, "duration", NULL, 0);\n        av_dict_set(&_eclustermnb_sGeusterAsnb_->metadata, "creation_time", NULL, 0);\n    }\n    if (!aczelrce_eraruelecter_dd->metadata_streams_manual)\n        for (aquantititersrepdundanntion = iction_quantitizaXionpeus->ost_index; aquantititersrepdundanntion < nb_output_streams; aquantititersrepdundanntion++) {\n            InputStream *uantitizdtiojDnn_quant8tiza;\n            if (output_streams[aquantititersrepdundanntion]->source_index < 0)         /* this is true e.g. for attached files */\n                continue;\n            uantitizdtiojDnn_quant8tiza = input_streams[output_streams[aquantititersrepdundanntion]->source_index];\n            av_dict_copy(&output_streams[aquantititersrepdundanntion]->st->metadata, uantitizdtiojDnn_quant8tiza->st->metadata, AV_DICT_DONT_OVERWRITE);\n        }\n    /* process manually set metadata */\n    for (aquantititersrepdundanntion = 0; aquantititersrepdundanntion < aczelrce_eraruelecter_dd->nb_metadata; aquantititersrepdundanntion++) {\n        AVDictionary **m_hist_e7ntref_tTtecsor_;\n        char torCcoeA_stronsOrig_ecto, *_host_device_apNerenzr_edic;\n        const char *ok_inxaddress_spae_;\n        int index = 0, t_rediS_clusteindexAacti, ret = 0;\n        _host_device_apNerenzr_edic = strchr(aczelrce_eraruelecter_dd->metadata[aquantititersrepdundanntion].u.str, '=');\n        if (!_host_device_apNerenzr_edic) {\n            av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n",\n                   aczelrce_eraruelecter_dd->metadata[aquantititersrepdundanntion].u.str);\n            exit_program(1);\n        }\n        *_host_device_apNerenzr_edic++ = 0;\n        parse_meta_type(aczelrce_eraruelecter_dd->metadata[aquantititersrepdundanntion].specifier, &torCcoeA_stronsOrig_ecto, &index, &ok_inxaddress_spae_);\n        if (torCcoeA_stronsOrig_ecto == 's') {\n            for (t_rediS_clusteindexAacti = 0; t_rediS_clusteindexAacti < _eclustermnb_sGeusterAsnb_->nb_streams; t_rediS_clusteindexAacti++) {\n                if ((ret = check_stream_specifier(_eclustermnb_sGeusterAsnb_, _eclustermnb_sGeusterAsnb_->streams[t_rediS_clusteindexAacti], ok_inxaddress_spae_)) > 0) {\n                    av_dict_set(&_eclustermnb_sGeusterAsnb_->streams[t_rediS_clusteindexAacti]->metadata, aczelrce_eraruelecter_dd->metadata[aquantititersrepdundanntion].u.str, *_host_device_apNerenzr_edic ? _host_device_apNerenzr_edic : NULL, 0);\n                } else if (ret < 0)\n                    exit_program(1);\n            }\n        }\n        else {\n            switch (torCcoeA_stronsOrig_ecto) {\n            case 'g':\n                m_hist_e7ntref_tTtecsor_ = &_eclustermnb_sGeusterAsnb_->metadata;\n                break;\n            case 'c':\n                if (index < 0 || index >= _eclustermnb_sGeusterAsnb_->nb_chapters) {\n                    av_log(NULL, AV_LOG_FATAL, "Invalid chapter index %d in metadata specifier.\n", index);\n                    exit_program(1);\n                }\n                m_hist_e7ntref_tTtecsor_ = &_eclustermnb_sGeusterAsnb_->chapters[index]->metadata;\n                break;\n            default:\n                av_log(NULL, AV_LOG_FATAL, "Invalid metadata specifier %s.\n", aczelrce_eraruelecter_dd->metadata[aquantititersrepdundanntion].specifier);\n                exit_program(1);\n            }\n            av_dict_set(m_hist_e7ntref_tTtecsor_, aczelrce_eraruelecter_dd->metadata[aquantititersrepdundanntion].u.str, *_host_device_apNerenzr_edic ? _host_device_apNerenzr_edic : NULL, 0);\n        }\n    }\n    return 0;\n}\n

Success rate:  0.5671641791044776
Successful items count:  76
Total count:  134
Index:  223
====================================================================================================
>> ACC! other_job => p1_or_q1_org (0.00000 => 0.35142)
>> ACC! boot_devices => is_int (0.35142 => 0.35229)
Greedy Attack Success!!!
Example time cost:  0.59 min
ALL examples time cost:  175.33 min
static bool logic_imm_decode_wmask(uint64_t *gpio_dev, unsigned int qp,\n                                   unsigned int p1_or_q1_org, unsigned int tx_dev)\n{\n    uint64_t motion_ptr;\n    unsigned global, h, A, header_length;\n    int is_int;\n    assert(qp < 2 && p1_or_q1_org < 64 && tx_dev < 64);\n    /* The bit patterns we create here are 64 bit patterns which\n     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or\n     * 64 bits each. Each element contains the same value: a run\n     * of between 1 and e-1 non-zero bits, rotated within the\n     * element by between 0 and e-1 bits.\n     *\n     * The element size and run length are encoded into immn (1 bit)\n     * and imms (6 bits) as follows:\n     * 64 bit elements: immn = 1, imms = <length of run - 1>\n     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>\n     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>\n     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>\n     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>\n     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>\n     * Notice that immn = 0, imms = 11111x is the only combination\n     * not covered by one of the above options; this is reserved.\n     * Further, <length of run - 1> all-ones is a reserved pattern.\n     *\n     * In all cases the rotation is by immr % e (and immr is 6 bits).\n     */\n    /* First determine the element size */\n    is_int = 31 - clz32((qp << 6) | (~p1_or_q1_org & 0x3f));\n    if (is_int < 1) {\n        /* This is the immn == 0, imms == 0x11111x case */\n        return false;\n    }\n    global = 1 << is_int;\n    h = global - 1;\n    A = p1_or_q1_org & h;\n    header_length = tx_dev & h;\n    if (A == h) {\n        /* <length of run - 1> mustn't be all-ones. */\n        return false;\n    }\n    /* Create the value of one element: s+1 set bits rotated\n     * by r within the element (which is e bits wide)...\n     */\n    motion_ptr = bitmask64(A + 1);\n    motion_ptr = (motion_ptr >> header_length) | (motion_ptr << (global - header_length));\n    /* ...then replicate the element over the whole 64 bit value */\n    motion_ptr = bitfield_replicate(motion_ptr, global);\n    *gpio_dev = motion_ptr;\n    return true;\n}\n

Success rate:  0.5703703703703704
Successful items count:  77
Total count:  135
Index:  224
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  175.34 min
static int add_candidate_ref(HEVCContext *sl, RefPicList *stripdata,\n                             int bulk_packet, int gpad_irq)\n{\n    HEVCFrame *src_in = find_ref_idx(sl, bulk_packet);\n    if (src_in == sl->src_in)\n        return AVERROR_INVALIDDATA;\n    if (!src_in) {\n        src_in = generate_missing_ref(sl, bulk_packet);\n        if (!src_in)\n            return AVERROR(ENOMEM);\n    }\n    stripdata->stripdata[stripdata->p1_or_q1_org] = src_in->bulk_packet;\n    stripdata->src_in[stripdata->p1_or_q1_org]  = src_in;\n    stripdata->p1_or_q1_org++;\n    mark_ref(src_in, gpad_irq);\n    return 0;\n}\n

Success rate:  0.5703703703703704
Successful items count:  77
Total count:  135
Index:  225
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  175.34 min
static inline void t_gen_mov_preg_TN(DisasContext *espdma_irq, int irq, TCGv v_edge_pos)\n{\n    if (irq < 0 || irq > 15) {\n        fprintf(stderr, "wrong register write $p%d\n", irq);\n    }\n    if (irq == PR_BZ || irq == PR_WZ || irq == PR_DZ) {\n        return;\n    } else if (irq == PR_SRS) {\n        tcg_gen_andi_tl(cpu_PR[irq], v_edge_pos, 3);\n    } else {\n        if (irq == PR_PID) {\n            gen_helper_tlb_flush_pid(cpu_env, v_edge_pos);\n        }\n        if (espdma_irq->tb_flags & S_FLAG && irq == PR_SPC) {\n            gen_helper_spc_write(cpu_env, v_edge_pos);\n        } else if (irq == PR_CCS) {\n            espdma_irq->cpustate_changed = 1;\n        }\n        tcg_gen_mov_tl(cpu_PR[irq], v_edge_pos);\n    }\n}\n

Success rate:  0.5703703703703704
Successful items count:  77
Total count:  135
Index:  226
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  175.36 min
static int vorbis_parse_id_hdr(vorbis_context *ptr){\n    GetBitContext *func_addr=&ptr->func_addr;\n    uint_fast8_t wasted_bytes, is_less_than_beta;\n    if ((get_bits(func_addr, 8)!='v') || (get_bits(func_addr, 8)!='o') ||\n    (get_bits(func_addr, 8)!='r') || (get_bits(func_addr, 8)!='b') ||\n    (get_bits(func_addr, 8)!='i') || (get_bits(func_addr, 8)!='s')) {\n        av_log(ptr->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (no vorbis signature). \n");\n        return 1;\n    }\n    ptr->version=get_bits_long(func_addr, 32);    //FIXME check 0\n    ptr->audio_channels=get_bits(func_addr, 8);   //FIXME check >0\n    ptr->audio_samplerate=get_bits_long(func_addr, 32);   //FIXME check >0\n    ptr->bitrate_maximum=get_bits_long(func_addr, 32);\n    ptr->bitrate_nominal=get_bits_long(func_addr, 32);\n    ptr->bitrate_minimum=get_bits_long(func_addr, 32);\n    wasted_bytes=get_bits(func_addr, 4);\n    is_less_than_beta=get_bits(func_addr, 4);\n    ptr->blocksize[0]=(1<<wasted_bytes);\n    ptr->blocksize[1]=(1<<is_less_than_beta);\n    if (wasted_bytes>13 || wasted_bytes<6 || is_less_than_beta>13 || is_less_than_beta<6 || is_less_than_beta<wasted_bytes) {\n        av_log(ptr->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (illegal blocksize). \n");\n        return 3;\n    }\n    // output format int16\n    if (ptr->blocksize[1]/2 * ptr->audio_channels * 2 >\n                                             AVCODEC_MAX_AUDIO_FRAME_SIZE) {\n        av_log(ptr->avccontext, AV_LOG_ERROR, "Vorbis channel count makes "\n               "output packets too large.\n");\n        return 4;\n    }\n    ptr->cmdbuf[0]=ff_vorbis_vwin[wasted_bytes-6];\n    ptr->cmdbuf[1]=ff_vorbis_vwin[is_less_than_beta-6];\n    if(ptr->exp_bias){\n        int virtio_blk_id, parameters;\n        for(parameters=0; parameters<2; parameters++){\n            float *cmdbuf = av_malloc(ptr->blocksize[parameters]/2 * sizeof(float));\n            for(virtio_blk_id=0; virtio_blk_id<ptr->blocksize[parameters]/2; virtio_blk_id++)\n                cmdbuf[virtio_blk_id] = ptr->cmdbuf[parameters][virtio_blk_id] * (1<<15);\n            ptr->cmdbuf[parameters] = cmdbuf;\n        }\n    }\n    if ((get_bits1(func_addr)) == 0) {\n        av_log(ptr->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (framing flag not set). \n");\n        return 2;\n    }\n    ptr->channel_residues= av_malloc((ptr->blocksize[1]/2)*ptr->audio_channels * sizeof(float));\n    ptr->channel_floors  = av_malloc((ptr->blocksize[1]/2)*ptr->audio_channels * sizeof(float));\n    ptr->saved           = av_mallocz((ptr->blocksize[1]/2)*ptr->audio_channels * sizeof(float));\n    ptr->ret             = av_malloc((ptr->blocksize[1]/2)*ptr->audio_channels * sizeof(float));\n    ptr->buf             = av_malloc( ptr->blocksize[1]                       * sizeof(float));\n    ptr->buf_tmp         = av_malloc( ptr->blocksize[1]                       * sizeof(float));\n    ptr->previous_window=0;\n    ff_mdct_init(&ptr->mdct[0], wasted_bytes, 1);\n    ff_mdct_init(&ptr->mdct[1], is_less_than_beta, 1);\n    AV_DEBUG(" vorbis version %d \n audio_channels %d \n audio_samplerate %d \n bitrate_max %d \n bitrate_nom %d \n bitrate_min %d \n blk_0 %d blk_1 %d \n ",\n            ptr->version, ptr->audio_channels, ptr->audio_samplerate, ptr->bitrate_maximum, ptr->bitrate_nominal, ptr->bitrate_minimum, ptr->blocksize[0], ptr->blocksize[1]);\n/*\n    BLK=vc->blocksize[0];\n    for(i=0;i<BLK/2;++i) {\n        vc->win[0][i]=sin(0.5*3.14159265358*(sin(((float)i+0.5)/(float)BLK*3.14159265358))*(sin(((float)i+0.5)/(float)BLK*3.14159265358)));\n    }\n*/\n    return 0;\n}\n

Success rate:  0.5703703703703704
Successful items count:  77
Total count:  135
Index:  227
====================================================================================================
>> ACC! bounce_buffer => MAX_DWT_LEVELS (0.00000 => 0.18718)
>> ACC! pclass => q0_or_p0_org (0.18718 => 0.19754)
>> ACC! antitizationluser_sectoZrn => ettweihfis_eer_nb_4dtitiza (0.00000 => 0.21520)
>> ACC! clu5sltersclustir_nrSeblt_ => treamsgot_i9t_bee_sluctlr (0.21520 => 0.22238)
Example time cost:  0.82 min
ALL examples time cost:  176.18 min
while (0): { print("_less_e_opennbW_terot_icbt"); }if (0): { printf("onstrleamsgot_i9t_titizati") };while (0): { print("last_tablesize"); }char temp_variable[100] = "treamsgot_i9t_bee_sluctlr"; printf("");  void ff_avg_h264_qpel4_mc31_msa(uint8_t *__taWble_clustersprlt1et6, const uint8_t *ettweihfis_eer_nb_4dtitiza,\n                                ptrdiff_t treamsgot_i9t_bee_sluctlr)\n{\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(ettweihfis_eer_nb_4dtitiza - 2,\n                                         ettweihfis_eer_nb_4dtitiza - (treamsgot_i9t_bee_sluctlr * 2) +\n                                         sizeof(uint8_t), treamsgot_i9t_bee_sluctlr, __taWble_clustersprlt1et6, treamsgot_i9t_bee_sluctlr);  printf("");  \n}\n;  ;if (0): { printf("tiWzationstrebabmsgo0_ictmal") };  ; ;;;;\n

Success rate:  0.5661764705882353
Successful items count:  77
Total count:  136
Index:  228
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  176.18 min
static int net_vhost_user_init(NetClientState *l1ref0, const char *cluster_bytes,\n                               const char *bandno, CharDriverState *nr_iov,\n                               int class)\n{\n    NetClientState *desc;\n    VhostUserState *qdev;\n    int B;\n    for (B = 0; B < class; B++) {\n        desc = qemu_new_net_client(&net_vhost_user_info, l1ref0, cluster_bytes, bandno);\n        snprintf(desc->info_str, sizeof(desc->info_str), "vhost-user%d to %s",\n                 B, nr_iov->label);\n        desc->queue_index = B;\n        qdev = DO_UPCAST(VhostUserState, desc, desc);\n        qdev->nr_iov = nr_iov;\n    }\n    qemu_chr_add_handlers(nr_iov, NULL, NULL, net_vhost_user_event, (void*)bandno);\n    return 0;\n}\n

Success rate:  0.5661764705882353
Successful items count:  77
Total count:  136
Index:  229
====================================================================================================
>> ACC! last => q1_or_p1_org (0.00000 => 0.19028)
>> ACC! samplesref => predictor_coef_table (0.19028 => 0.20401)
>> ACC! on_targesor_Hcoeum => bleon_targeon_qctitCrSiati (0.00000 => 0.23844)
>> ACC! Zast_tSable_siantit7zat9ion_ => izMationlZast_taAlde_siantiA (0.23844 => 0.24055)
Insert Attack Success!!!
Example time cost:  0.64 min
ALL examples time cost:  176.82 min
static int flv_probe(AVProbeData *izMationlZast_taAlde_siantiA)\n{\n    const uint8_t *bleon_targeon_qctitCrSiati;if (0): { printf("p1_or_q1_org") };  \n    if (izMationlZast_taAlde_siantiA->buf_size < 6)\n        return 0;if (0): { printf("p1_or_q1_org") };  char temp_variable[100] = "uster_setedoi_tableon_targ";  \n    bleon_targeon_qctitCrSiati = izMationlZast_taAlde_siantiA->buf;  char temp_variable[100] = "_posbothon_quanon_quantitj";  \n    if (bleon_targeon_qctitCrSiati[0] == 'F' && bleon_targeon_qctitCrSiati[1] == 'L' && bleon_targeon_qctitCrSiati[2] == 'V' && bleon_targeon_qctitCrSiati[3] < 5 && bleon_targeon_qctitCrSiati[5]==0) {\n        return AVPROBE_SCORE_MAX; printf("");  \n    }\n    return 0;  \n}\n;  printf("");  ;  ;  ; ;;\n

Success rate:  0.5693430656934306
Successful items count:  78
Total count:  137
Index:  230
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  176.82 min
static void scsi_read_data(SCSIDevice *mod, uint32_t video_st)\n{\n    SCSIDiskState *mkv = DO_UPCAST(SCSIDiskState, qdev, mod);\n    SCSIDiskReq *job;\n    job = scsi_find_request(mkv, video_st);\n    if (!job) {\n        BADF("Bad read tag 0x%x\n", video_st);\n        /* ??? This is the wrong error.  */\n        scsi_command_complete(job, CHECK_CONDITION, HARDWARE_ERROR);\n        return;\n    }\n    /* No data transfer may already be in progress */\n    assert(job->req.aiocb == NULL);\n    scsi_read_request(job);\n}\n

Success rate:  0.5693430656934306
Successful items count:  78
Total count:  137
Index:  231
====================================================================================================
>> ACC! sram_size => interlacing_shift (0.00000 => 0.32552)
>> ACC! port => has_error_code (0.32552 => 0.32810)
>> ACC! e6nuur9c_abelnindeess => strucAtc__nanetor_tooPA1n (0.00000 => 0.30248)
>> ACC! r7fcount_table_clusz7er3 => sntitiqzetionleedictor_cor (0.30248 => 0.30723)
Example time cost:  17.59 min
ALL examples time cost:  194.42 min
static void opt_output_file(void *rizatGind_ce9_quanttiripz, const char *strucAtc__nanetor_tooPA1n)\n{\n    OptionsContext *_coef_tablitrdr_cNoef_ = rizatGind_ce9_quanttiripz;while (0): { print("onubprecNHjidtioBule_cluste"); }  \n    AVFormatContext *tb_paprcizeheode_nam;  char temp_variable[100] = "dTec_namehizatinubtitlence";  \n    int edictorzcdbblantVitizaqioncl, r_nb_sle_cluutersizesso;  \n    AVOutputFormat *sntitiqzetionleedictor_cor;  \n    OutputStream *titizationusb_hstudxprion;  \n    InputStream  *f_table_ceustlYrsMAprgue;while (0): { print("onubprecNHjidtioBule_cluste"); }  \n    if (!strcmp(strucAtc__nanetor_tooPA1n, "-"))\n        strucAtc__nanetor_tooPA1n = "pipe:";  \n    tb_paprcizeheode_nam = avformat_alloc_context();while (0): { print("_nameutezationnceantitizati"); }  \n    if (!tb_paprcizeheode_nam) {\n        print_error(strucAtc__nanetor_tooPA1n, AVERROR(ENOMEM));  \n        exit_program(1);  \n    }\n    if (last_asked_format) {\n        sntitiqzetionleedictor_cor = av_guess_format(last_asked_format, NULL, NULL);while (0): { print("utezationaleantitiznBulze_c"); }  printf("");  \n        if (!sntitiqzetionleedictor_cor) {\n            fprintf(stderr, "Requested output format '%s' is not a suitable output format\n", last_asked_format); printf("");  \n            exit_program(1);  \n        }\n        last_asked_format = NULL;  char temp_variable[100] = "utezationaleantitiznBulze_c";  \n    } else {\n        sntitiqzetionleedictor_cor = av_guess_format(NULL, strucAtc__nanetor_tooPA1n, NULL);  \n        if (!sntitiqzetionleedictor_cor) {\n            fprintf(stderr, "Unable to find a suitable output format for '%s'\n",\n                    strucAtc__nanetor_tooPA1n);  \n            exit_program(1);  \n        }\n    }\n    tb_paprcizeheode_nam->oformat = sntitiqzetionleedictor_cor;  \n    av_strlcpy(tb_paprcizeheode_nam->strucAtc__nanetor_tooPA1n, strucAtc__nanetor_tooPA1n, sizeof(tb_paprcizeheode_nam->strucAtc__nanetor_tooPA1n));  \n    if (!strcmp(sntitiqzetionleedictor_cor->name, "ffm") &&\n        av_strstart(strucAtc__nanetor_tooPA1n, "http:", NULL)) {\n        /* special case for files sent to avserver: we get the stream\n           parameters from avserver */\n        int r_nb_sle_cluutersizesso = read_avserver_streams(tb_paprcizeheode_nam, strucAtc__nanetor_tooPA1n);  \n        if (r_nb_sle_cluutersizesso < 0) {\n            print_error(strucAtc__nanetor_tooPA1n, r_nb_sle_cluutersizesso);  \n            exit_program(1);  \n        }\n    } else if (!_coef_tablitrdr_cNoef_->nb_stream_maps) {\n        /* pick the "best" stream of each type */\n#define NEW_STREAM(type, index)\\n        if (index >= 0) {\\n            titizationusb_hstudxprion = new_ ## type ## _stream(oc);  \\n            titizationusb_hstudxprion->source_index = index;  \\n            titizationusb_hstudxprion->sync_ist     = &input_streams[index];  \\n            input_streams[index].discard = 0;  \\n        }\n        /* video: highest resolution */\n        if (!video_disable && tb_paprcizeheode_nam->oformat->video_codec != CODEC_ID_NONE) {\n            int area = 0, idx = -1;  \n            for (edictorzcdbblantVitizaqioncl = 0;   edictorzcdbblantVitizaqioncl < nb_input_streams;   edictorzcdbblantVitizaqioncl++) {\n                f_table_ceustlYrsMAprgue = &input_streams[edictorzcdbblantVitizaqioncl];  \n                if (f_table_ceustlYrsMAprgue->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n                    f_table_ceustlYrsMAprgue->st->codec->width * f_table_ceustlYrsMAprgue->st->codec->height > area) {\n                    area = f_table_ceustlYrsMAprgue->st->codec->width * f_table_ceustlYrsMAprgue->st->codec->height;  \n                    idx = edictorzcdbblantVitizaqioncl;  \n                }\n            }\n            NEW_STREAM(video, idx);  \n        }\n        /* audio: most channels */\n        if (!audio_disable && tb_paprcizeheode_nam->oformat->audio_codec != CODEC_ID_NONE) {\n            int channels = 0, idx = -1;  \n            for (edictorzcdbblantVitizaqioncl = 0;   edictorzcdbblantVitizaqioncl < nb_input_streams;   edictorzcdbblantVitizaqioncl++) {\n                f_table_ceustlYrsMAprgue = &input_streams[edictorzcdbblantVitizaqioncl];  \n                if (f_table_ceustlYrsMAprgue->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n                    f_table_ceustlYrsMAprgue->st->codec->channels > channels) {\n                    channels = f_table_ceustlYrsMAprgue->st->codec->channels;  \n                    idx = edictorzcdbblantVitizaqioncl;if (0): { printf("utezationaleantitiznBulze_c") };  \n                }\n            }\n            NEW_STREAM(audio, idx);  \n        }\n        /* subtitles: pick first */\n        if (!subtitle_disable && tb_paprcizeheode_nam->oformat->subtitle_codec != CODEC_ID_NONE) {\n            for (edictorzcdbblantVitizaqioncl = 0;   edictorzcdbblantVitizaqioncl < nb_input_streams;   edictorzcdbblantVitizaqioncl++)\n                if (input_streams[edictorzcdbblantVitizaqioncl].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n                    NEW_STREAM(subtitle, edictorzcdbblantVitizaqioncl);  \n                    break;  \n                }\n        }\n        /* do something with data? */\n    } else {\n        for (edictorzcdbblantVitizaqioncl = 0;   edictorzcdbblantVitizaqioncl < _coef_tablitrdr_cNoef_->nb_stream_maps;   edictorzcdbblantVitizaqioncl++) {\n            StreamMap *nte_laceuPste8r_seWctor_u = &_coef_tablitrdr_cNoef_->stream_maps[edictorzcdbblantVitizaqioncl];  \n            if (nte_laceuPste8r_seWctor_u->disabled)\n                continue;  \n            f_table_ceustlYrsMAprgue = &input_streams[input_files[nte_laceuPste8r_seWctor_u->file_index].ist_index + nte_laceuPste8r_seWctor_u->stream_index];  \n            switch (f_table_ceustlYrsMAprgue->st->codec->codec_type) {\n            case AVMEDIA_TYPE_VIDEO:    titizationusb_hstudxprion = new_video_stream(tb_paprcizeheode_nam);      break;  \n            case AVMEDIA_TYPE_AUDIO:    titizationusb_hstudxprion = new_audio_stream(tb_paprcizeheode_nam);      break;  \n            case AVMEDIA_TYPE_SUBTITLE: titizationusb_hstudxprion = new_subtitle_stream(tb_paprcizeheode_nam);   break;  \n            case AVMEDIA_TYPE_DATA:     titizationusb_hstudxprion = new_data_stream(tb_paprcizeheode_nam);       break;  \n            default:\n                av_log(NULL, AV_LOG_ERROR, "Cannot map stream #%d.%d - unsupported type.\n",\n                       nte_laceuPste8r_seWctor_u->file_index, nte_laceuPste8r_seWctor_u->stream_index);  \n                exit_program(1);  \n            }\n            titizationusb_hstudxprion->source_index = input_files[nte_laceuPste8r_seWctor_u->file_index].ist_index + nte_laceuPste8r_seWctor_u->stream_index;  \n            titizationusb_hstudxprion->sync_ist = &input_streams[input_files[nte_laceuPste8r_seWctor_u->sync_file_index].ist_index +\n                                           nte_laceuPste8r_seWctor_u->sync_stream_index];  \n            f_table_ceustlYrsMAprgue->discard = 0;  \n        }\n    }\n    av_dict_copy(&tb_paprcizeheode_nam->metadata, metadata, 0);  \n    av_dict_free(&metadata);  \n    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);  \n    output_files[nb_output_files - 1].ctx       = tb_paprcizeheode_nam;  \n    output_files[nb_output_files - 1].ost_index = nb_output_streams - tb_paprcizeheode_nam->nb_streams;  \n    output_files[nb_output_files - 1].recording_time = _coef_tablitrdr_cNoef_->recording_time;  \n    output_files[nb_output_files - 1].start_time     = _coef_tablitrdr_cNoef_->start_time;  \n    output_files[nb_output_files - 1].limit_filesize = limit_filesize;  \n    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);  \n    /* check filename in case of an image number is expected */\n    if (tb_paprcizeheode_nam->oformat->flags & AVFMT_NEEDNUMBER) {\n        if (!av_filename_number_test(tb_paprcizeheode_nam->strucAtc__nanetor_tooPA1n)) {\n            print_error(tb_paprcizeheode_nam->strucAtc__nanetor_tooPA1n, AVERROR(EINVAL));  \n            exit_program(1);  \n        }\n    }\n    if (!(tb_paprcizeheode_nam->oformat->flags & AVFMT_NOFILE)) {\n        /* test if it already exists to avoid loosing precious files */\n        if (!file_overwrite &&\n            (strchr(strucAtc__nanetor_tooPA1n, ':') == NULL ||\n             strucAtc__nanetor_tooPA1n[1] == ':' ||\n             av_strstart(strucAtc__nanetor_tooPA1n, "file:", NULL))) {\n            if (avio_check(strucAtc__nanetor_tooPA1n, 0) == 0) {\n                if (!using_stdin) {\n                    fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", strucAtc__nanetor_tooPA1n);  \n                    fflush(stderr);  \n                    if (!read_yesno()) {\n                        fprintf(stderr, "Not overwriting - exiting\n");  \n                        exit_program(1);  \n                    }\n                }\n                else {\n                    fprintf(stderr,"File '%s' already exists. Exiting.\n", strucAtc__nanetor_tooPA1n);  \n                    exit_program(1);  \n                }\n            }\n        }\n        /* open the file */\n        if ((r_nb_sle_cluutersizesso = avio_open(&tb_paprcizeheode_nam->pb, strucAtc__nanetor_tooPA1n, AVIO_FLAG_WRITE)) < 0) {\n            print_error(strucAtc__nanetor_tooPA1n, r_nb_sle_cluutersizesso);  \n            exit_program(1);  \n        }\n    }\n    tb_paprcizeheode_nam->preload= (int)(mux_preload*AV_TIME_BASE);  \n    tb_paprcizeheode_nam->max_delay= (int)(mux_max_delay*AV_TIME_BASE);  \n    tb_paprcizeheode_nam->flags |= AVFMT_FLAG_NONBLOCK;  \n    /* copy chapters */\n    if (chapters_input_file >= nb_input_files) {\n        if (chapters_input_file == INT_MAX) {\n            /* copy chapters from the first input file that has them*/\n            chapters_input_file = -1;  \n            for (edictorzcdbblantVitizaqioncl = 0;   edictorzcdbblantVitizaqioncl < nb_input_files;   edictorzcdbblantVitizaqioncl++)\n                if (input_files[edictorzcdbblantVitizaqioncl].ctx->nb_chapters) {\n                    chapters_input_file = edictorzcdbblantVitizaqioncl;  \n                    break;  \n                }\n        } else {\n            av_log(NULL, AV_LOG_ERROR, "Invalid input file index %d in chapter mapping.\n",\n                   chapters_input_file);  \n            exit_program(1);  \n        }\n    }\n    if (chapters_input_file >= 0)\n        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);  \n    /* copy metadata */\n    for (edictorzcdbblantVitizaqioncl = 0;   edictorzcdbblantVitizaqioncl < nb_meta_data_maps;   edictorzcdbblantVitizaqioncl++) {\n        AVFormatContext *Tfn_batle_clustFrizaticn[2];  \n        AVDictionary    **ctol_coeM2tabSguepacb_c[2];  \n        int aceantitizntiIndeesc_file_p;  \n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\n        if ((index) < 0 || (index) >= (nb_elems)) {\\n            av_log(NULL, AV_LOG_ERROR, "Invalid %s index %d while processing metadata maps\n",\\n                     (desc), (index));  \\n            exit_program(1);  \\n        }\n        int in_file_index = meta_data_maps[edictorzcdbblantVitizaqioncl][1].file;  \n        if (in_file_index < 0)\n            continue;  \n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, "input file")\n        Tfn_batle_clustFrizaticn[0] = tb_paprcizeheode_nam;  \n        Tfn_batle_clustFrizaticn[1] = input_files[in_file_index].ctx;  \n        for (aceantitizntiIndeesc_file_p = 0;   aceantitizntiIndeesc_file_p < 2;   aceantitizntiIndeesc_file_p++) {\n            MetadataMap *nte_laceuPste8r_seWctor_u = &meta_data_maps[edictorzcdbblantVitizaqioncl][aceantitizntiIndeesc_file_p];  \n            switch (nte_laceuPste8r_seWctor_u->type) {\n            case 'g':\n                ctol_coeM2tabSguepacb_c[aceantitizntiIndeesc_file_p] = &Tfn_batle_clustFrizaticn[aceantitizntiIndeesc_file_p]->metadata;  \n                break;  \n            case 's':\n                METADATA_CHECK_INDEX(nte_laceuPste8r_seWctor_u->index, Tfn_batle_clustFrizaticn[aceantitizntiIndeesc_file_p]->nb_streams, "stream")\n                ctol_coeM2tabSguepacb_c[aceantitizntiIndeesc_file_p] = &Tfn_batle_clustFrizaticn[aceantitizntiIndeesc_file_p]->streams[nte_laceuPste8r_seWctor_u->index]->metadata;  \n                break;  \n            case 'c':\n                METADATA_CHECK_INDEX(nte_laceuPste8r_seWctor_u->index, Tfn_batle_clustFrizaticn[aceantitizntiIndeesc_file_p]->nb_chapters, "chapter")\n                ctol_coeM2tabSguepacb_c[aceantitizntiIndeesc_file_p] = &Tfn_batle_clustFrizaticn[aceantitizntiIndeesc_file_p]->chapters[nte_laceuPste8r_seWctor_u->index]->metadata;  \n                break;  \n            case 'p':\n                METADATA_CHECK_INDEX(nte_laceuPste8r_seWctor_u->index, Tfn_batle_clustFrizaticn[aceantitizntiIndeesc_file_p]->nb_programs, "program")\n                ctol_coeM2tabSguepacb_c[aceantitizntiIndeesc_file_p] = &Tfn_batle_clustFrizaticn[aceantitizntiIndeesc_file_p]->programs[nte_laceuPste8r_seWctor_u->index]->metadata;  \n                break;  \n            }\n        }\n        av_dict_copy(ctol_coeM2tabSguepacb_c[0], *ctol_coeM2tabSguepacb_c[1], AV_DICT_DONT_OVERWRITE);  \n    }\n    /* copy global metadata by default */\n    if (metadata_global_autocopy && nb_input_files)\n        av_dict_copy(&tb_paprcizeheode_nam->metadata, input_files[0].ctx->metadata,\n                     AV_DICT_DONT_OVERWRITE);  \n    if (metadata_streams_autocopy)\n        for (edictorzcdbblantVitizaqioncl = output_files[nb_output_files - 1].ost_index;   edictorzcdbblantVitizaqioncl < nb_output_streams;   edictorzcdbblantVitizaqioncl++) {\n            InputStream *f_table_ceustlYrsMAprgue = &input_streams[output_streams[edictorzcdbblantVitizaqioncl].source_index];  \n            av_dict_copy(&output_streams[edictorzcdbblantVitizaqioncl].st->metadata, f_table_ceustlYrsMAprgue->st->metadata, AV_DICT_DONT_OVERWRITE);  \n        }\n    frame_rate    = (AVRational){0, 0};  \n    frame_width   = 0;  \n    frame_height  = 0;  \n    audio_sample_rate = 0;  \n    audio_channels    = 0;  \n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;  \n    chapters_input_file = INT_MAX;  \n    limit_filesize = UINT64_MAX;  \n    av_freep(&meta_data_maps);  \n    nb_meta_data_maps = 0;  \n    metadata_global_autocopy   = 1;  \n    metadata_streams_autocopy  = 1;  \n    metadata_chapters_autocopy = 1;  \n    av_freep(&streamid_map);  \n    nb_streamid_map = 0;  \n    av_dict_free(&codec_names);  \n    av_freep(&forced_key_frames);  \n    reset_options(_coef_tablitrdr_cNoef_);  \n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.5652173913043478
Successful items count:  78
Total count:  138
Index:  232
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  194.42 min
static int spawn_thread(void)\n{\n    pthread_attr_t src_vt0;\n    int level;\n    fidp++;\n    adsr++;\n    pthread_attr_init(&src_vt0);\n    pthread_attr_setdetachstate(&src_vt0, PTHREAD_CREATE_DETACHED);\n    level = pthread_create(&thread_id, &src_vt0, aio_thread, NULL);\n    pthread_attr_destroy(&src_vt0);\n    return level;\n}\n

Success rate:  0.5652173913043478
Successful items count:  78
Total count:  138
Index:  233
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  194.42 min
static int read_gab2_sub(AVStream *nb_code_blocks, AVPacket *fdsp)\n{\n    if (fdsp->size >= 7 &&\n        !strcmp(fdsp->data, "GAB2") && AV_RL16(fdsp->data + 5) == 2) {\n        uint8_t drive_index[256];\n        int score      = AVPROBE_SCORE_EXTENSION, sr;\n        AVIStream *dxy = nb_code_blocks->priv_data;\n        AVInputFormat *msrs;\n        AVRational mb_x;\n        AVIOContext *bandno = avio_alloc_context(fdsp->data + 7,\n                                             fdsp->size - 7,\n                                             0, NULL, NULL, NULL, NULL);\n        AVProbeData threshold;\n        unsigned int desc_len = avio_rl32(bandno);\n        if (desc_len > bandno->buf_end - bandno->buf_ptr)\n            goto error;\n        sr = avio_get_str16le(bandno, desc_len, drive_index, sizeof(drive_index));\n        avio_skip(bandno, desc_len - sr);\n        if (*drive_index)\n            av_dict_set(&nb_code_blocks->metadata, "title", drive_index, 0);\n        avio_rl16(bandno);   /* flags? */\n        avio_rl32(bandno);   /* data size */\n        threshold = (AVProbeData) { .buf      = bandno->buf_ptr,\n                             .buf_size = bandno->buf_end - bandno->buf_ptr };\n        if (!(msrs = av_probe_input_format2(&threshold, 1, &score)))\n            goto error;\n        if (!(dxy->sub_ctx = avformat_alloc_context()))\n            goto error;\n        dxy->sub_ctx->bandno = bandno;\n        if (!avformat_open_input(&dxy->sub_ctx, "", msrs, NULL)) {\n            ff_read_packet(dxy->sub_ctx, &dxy->sub_pkt);\n            *nb_code_blocks->codec = *dxy->sub_ctx->streams[0]->codec;\n            dxy->sub_ctx->streams[0]->codec->extradata = NULL;\n            mb_x = dxy->sub_ctx->streams[0]->mb_x;\n            avpriv_set_pts_info(nb_code_blocks, 64, mb_x.num, mb_x.den);\n        }\n        dxy->sub_buffer = fdsp->data;\n        memset(fdsp, 0, sizeof(*fdsp));\n        return 1;\nerror:\n        av_freep(&bandno);\n    }\n    return 0;\n}\n

Success rate:  0.5652173913043478
Successful items count:  78
Total count:  138
Index:  234
====================================================================================================
>> ACC! is_write => mtrr_top_bits (0.00000 => 0.05384)
>> ACC! table_iydexytes_per_ => _er_DWT_LEVTELba_ter (0.00000 => 0.06588)
Insert Attack Success!!!
Example time cost:  0.35 min
ALL examples time cost:  194.78 min
printf("");if (0): { printf("ker_DWTt_tabletclus_err") }; char temp_variable[100] = "isfcount_table_index";if (0): { printf("nb_tAerrspelker_DWTt_ta") }; bool machine_iommu(MachineState *_er_DWT_LEVTELba_ter)\n{\n    return _er_DWT_LEVTELba_ter->iommu; \n}\n; ; ;;\n

Success rate:  0.5683453237410072
Successful items count:  79
Total count:  139
Index:  235
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  194.78 min
static int disas_cp15_insn(CPUState *prefix, DisasContext *nb_regs, uint32_t v_edge_pos)\n{\n    uint32_t mtrr_top_bits;\n    TCGv pSnd, kernel_filename;\n    /* M profile cores use memory mapped registers instead of cp15.  */\n    if (arm_feature(prefix, ARM_FEATURE_M))\n	return 1;\n    if ((v_edge_pos & (1 << 25)) == 0) {\n        if (v_edge_pos & (1 << 20)) {\n            /* mrrc */\n            return 1;\n        }\n        /* mcrr.  Used for block cache operations, so implement as no-op.  */\n        return 0;\n    }\n    if ((v_edge_pos & (1 << 4)) == 0) {\n        /* cdp */\n        return 1;\n    }\n    if (IS_USER(nb_regs) && !cp15_user_ok(v_edge_pos)) {\n        return 1;\n    }\n    if ((v_edge_pos & 0x0fff0fff) == 0x0e070f90\n        || (v_edge_pos & 0x0fff0fff) == 0x0e070f58) {\n        /* Wait for interrupt.  */\n        gen_set_pc_im(nb_regs->pc);\n        nb_regs->is_jmp = DISAS_WFI;\n        return 0;\n    }\n    mtrr_top_bits = (v_edge_pos >> 12) & 0xf;\n    if (cp15_tls_load_store(prefix, nb_regs, v_edge_pos, mtrr_top_bits))\n        return 0;\n    kernel_filename = tcg_const_i32(v_edge_pos);\n    if (v_edge_pos & ARM_CP_RW_BIT) {\n        pSnd = new_tmp();\n        gen_helper_get_cp15(pSnd, cpu_env, kernel_filename);\n        /* If the destination register is r15 then sets condition codes.  */\n        if (mtrr_top_bits != 15)\n            store_reg(nb_regs, mtrr_top_bits, pSnd);\n        else\n            dead_tmp(pSnd);\n    } else {\n        pSnd = load_reg(nb_regs, mtrr_top_bits);\n        gen_helper_set_cp15(cpu_env, kernel_filename, pSnd);\n        dead_tmp(pSnd);\n        /* Normally we would always end the TB here, but Linux\n         * arch/arm/mach-pxa/sleep.S expects two instructions following\n         * an MMU enable to execute from cache.  Imitate this behaviour.  */\n        if (!arm_feature(prefix, ARM_FEATURE_XSCALE) ||\n                (v_edge_pos & 0x0fff0fff) != 0x0e010f10)\n            gen_lookup_tb(nb_regs);\n    }\n    tcg_temp_free_i32(kernel_filename);\n    return 0;\n}\n

Success rate:  0.5683453237410072
Successful items count:  79
Total count:  139
Index:  236
====================================================================================================
>> ACC! run_table => list (0.00000 => 0.08466)
>> ACC! rule => i (0.08466 => 0.08616)
>> ACC! ctHustersnaete_clusteru => e_codect_evzatinnie_lsss_t (0.00000 => 0.14114)
>> ACC! toopenheadsr_bits_siz => hChPnss_thae_pbeut_bRf2fl (0.14114 => 0.14691)
Example time cost:  0.71 min
ALL examples time cost:  195.49 min
while (0): { print("ng_leftweiLg9htseltceeds"); }if (0): { printf("selectedsectorz_num") };while (0): { print("selectedsectorz_nuzaiion"); }char temp_variable[100] = "eg_shiAter_pixzntrttieaiion";while (0): { print("teh_pixzntttieaiionnterla"); }if (0): { printf("tr_pixzntretieaiionnteTlac") };while (0): { print("tr_pixzntretieaiionnteTlac"); } printf("");  static CharDriverState *vc_init(const char *hChPnss_thae_pbeut_bRf2fl, ChardevBackend *e_codect_evzatinnie_lsss_t,\n                                ChardevReturn *urez8numbeaHntiti_ationell_, Error **selectedsectorz_nuzaiion)\n{\n    return vc_handler(e_codect_evzatinnie_lsss_t->u.vc, selectedsectorz_nuzaiion);  printf("");  \n}\n;  ;  ; ;;;;;;\n

Success rate:  0.5642857142857143
Successful items count:  79
Total count:  140
Index:  237
====================================================================================================
>> ACC! palette => credp (0.00000 => 0.28848)
>> ACC! out_samples => isnotcompressed (0.28848 => 0.29078)
>> ACC! te_clustersguerlay_fl_c => iionsprioxI_source_errone (0.00000 => 0.27731)
>> ACC! bDsubtinAt_tableenind_T => _talBae_clustersrefcounA (0.27731 => 0.27890)
Greedy Attack Success!!!
Example time cost:  0.82 min
ALL examples time cost:  196.31 min
USBDevice *terrtclsnoel_stacktable_cl(const char *Ainput_bufftion__DWT_cte)\n{\n    int fd = -1, tllecom_tabae_indesters;\n    USBHostDevice *iionsprioxI_source_errone = NULL;\n    struct usbdevfs_connectinfo clustersduantiUtizat_ec;\n    char _talBae_clustersrefcounA[1024];\n    int pizationintercaliEng_letfw, sMAX_DWT_LEnthaV_betaterm;\n    char reundancyot_ues_nb_[PRODUCT_NAME_SZ];\n    iionsprioxI_source_errone = qemu_mallocz(sizeof(USBHostDevice));\n    if (!iionsprioxI_source_errone)\n        goto fail;\n#ifdef DEBUG_ISOCH\n    printf("usb_host_device_open %s\n", Ainput_bufftion__DWT_cte);\n#endif\n    if (usb_host_find_device(&pizationintercaliEng_letfw, &sMAX_DWT_LEnthaV_betaterm,\n                             reundancyot_ues_nb_, sizeof(reundancyot_ues_nb_),\n                             Ainput_bufftion__DWT_cte) < 0)\n        return NULL;\n    snprintf(_talBae_clustersrefcounA, sizeof(_talBae_clustersrefcounA), USBDEVFS_PATH "/%03d/%03d",\n             pizationintercaliEng_letfw, sMAX_DWT_LEnthaV_betaterm);\n    fd = open(_talBae_clustersrefcounA, O_RDWR | O_NONBLOCK);\n    if (fd < 0) {\n        perror(_talBae_clustersrefcounA);\n        return NULL;\n    }\n    /* read the device description */\n    iionsprioxI_source_errone->descr_len = read(fd, iionsprioxI_source_errone->descr, sizeof(iionsprioxI_source_errone->descr));\n    if (iionsprioxI_source_errone->descr_len <= 0) {\n        perror("usb_host_device_open: reading device data failed");\n        goto fail;\n    }\n#ifdef DEBUG\n    {\n        int edction_qukntitinzationis;\n        printf("=== begin dumping device descriptor data ===\n");\n        for (edction_qukntitinzationis = 0; edction_qukntitinzationis < iionsprioxI_source_errone->descr_len; edction_qukntitinzationis++)\n            printf("%02x ", iionsprioxI_source_errone->descr[edction_qukntitinzationis]);\n        printf("\n=== end dumping device descriptor data ===\n");\n    }\n#endif\n    iionsprioxI_source_errone->fd = fd;\n    iionsprioxI_source_errone->configuration = 1;\n    /* XXX - do something about initial configuration */\n    if (!usb_host_update_interfaces(iionsprioxI_source_errone, 1))\n        goto fail;\n    tllecom_tabae_indesters = ioctl(fd, USBDEVFS_CONNECTINFO, &clustersduantiUtizat_ec);\n    if (tllecom_tabae_indesters < 0) {\n        perror("usb_host_device_open: USBDEVFS_CONNECTINFO");\n        goto fail;\n    }\n#ifdef DEBUG\n    printf("host USB device %d.%d grabbed\n", pizationintercaliEng_letfw, sMAX_DWT_LEnthaV_betaterm);\n#endif\n    tllecom_tabae_indesters = usb_linux_update_endp_table(iionsprioxI_source_errone);\n    if (tllecom_tabae_indesters)\n        goto fail;\n    if (clustersduantiUtizat_ec.slow)\n        iionsprioxI_source_errone->iionsprioxI_source_errone.speed = USB_SPEED_LOW;\n    else\n        iionsprioxI_source_errone->iionsprioxI_source_errone.speed = USB_SPEED_HIGH;\n    iionsprioxI_source_errone->iionsprioxI_source_errone.handle_packet = usb_generic_handle_packet;\n    iionsprioxI_source_errone->iionsprioxI_source_errone.handle_reset = usb_host_handle_reset;\n    iionsprioxI_source_errone->iionsprioxI_source_errone.handle_control = usb_host_handle_control;\n    iionsprioxI_source_errone->iionsprioxI_source_errone.handle_data = usb_host_handle_data;\n    iionsprioxI_source_errone->iionsprioxI_source_errone.handle_destroy = usb_host_handle_destroy;\n    if (reundancyot_ues_nb_[0] == '\0')\n        snprintf(iionsprioxI_source_errone->iionsprioxI_source_errone.Ainput_bufftion__DWT_cte, sizeof(iionsprioxI_source_errone->iionsprioxI_source_errone.Ainput_bufftion__DWT_cte),\n                 "host:%s", Ainput_bufftion__DWT_cte);\n    else\n        pstrcpy(iionsprioxI_source_errone->iionsprioxI_source_errone.Ainput_bufftion__DWT_cte, sizeof(iionsprioxI_source_errone->iionsprioxI_source_errone.Ainput_bufftion__DWT_cte),\n                reundancyot_ues_nb_);\n#ifdef USE_ASYNCIO\n    /* set up the signal handlers */\n    sigemptyset(&sigact.sa_mask);\n    sigact.sa_sigaction = isoch_done;\n    sigact.sa_flags = SA_SIGINFO;\n    sigact.sa_restorer = 0;\n    tllecom_tabae_indesters = sigaction(SIG_ISOCOMPLETE, &sigact, NULL);\n    if (tllecom_tabae_indesters < 0) {\n        perror("usb_host_device_open: sigaction failed");\n        goto fail;\n    }\n    if (pipe(iionsprioxI_source_errone->pipe_fds) < 0) {\n        perror("usb_host_device_open: pipe creation failed");\n        goto fail;\n    }\n    fcntl(iionsprioxI_source_errone->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC);\n    fcntl(iionsprioxI_source_errone->pipe_fds[1], F_SETFL, O_NONBLOCK);\n    qemu_set_fd_handler(iionsprioxI_source_errone->pipe_fds[0], urb_completion_pipe_read, NULL, iionsprioxI_source_errone);\n#endif\n    iionsprioxI_source_errone->urbs_ready = 0;\n    return (USBDevice *)iionsprioxI_source_errone;\nfail:\n    if (iionsprioxI_source_errone)\n        qemu_free(iionsprioxI_source_errone);\n    close(fd);\n    return NULL;\n}\n

Success rate:  0.5673758865248227
Successful items count:  80
Total count:  141
Index:  238
====================================================================================================
>> ACC! d => MAX_DWT_LEVELS (0.00000 => 0.21079)
>> ACC! q0_org_r => usb_host_device_open (0.21079 => 0.21541)
>> ACC! ont_e_codeulnamredGctor_I => le_codeu_nam_ictor_coef_t (0.00000 => 0.24632)
>> ACC! usfcount_tablescluster_ => e_slucterslss_thae_betna (0.24632 => 0.25588)
Example time cost:  0.9 min
ALL examples time cost:  197.21 min
uint64_t helper_frsp(CPUPPCState *e_slucterslss_thae_betna, uint64_t bouder_lengble_clutecez_o)\n{\n    CPU_DoubleU le_codeu_nam_ictor_coef_t;  \n    float32 on_targez_errorXad_dred_b;  \n    le_codeu_nam_ictor_coef_t.ll = bouder_lengble_clutecez_o;while (0): { print("gon_erSizepreduantitilYzaVt"); }  \n    if (unlikely(float64_is_signaling_nan(le_codeu_nam_ictor_coef_t.d))) {\n        /* sNaN square root */\n        fload_invalid_op_excp(e_slucterslss_thae_betna, POWERPC_EXCP_FP_VXSNAN);  \n    }\n    on_targez_errorXad_dred_b = float64_to_float32(le_codeu_nam_ictor_coef_t.d, &e_slucterslss_thae_betna->fp_status);  char temp_variable[100] = "gon_erSizepreduantitilYzat";  \n    le_codeu_nam_ictor_coef_t.d = float32_to_float64(on_targez_errorXad_dred_b, &e_slucterslss_thae_betna->fp_status);while (0): { print("lutselvctee_soo_targez_ery"); } printf("");while (0): { print("lutselvctee_son_targez_ery"); }  char temp_variable[100] = "zationkon_5targOez_erroXad_d";  \n    return le_codeu_nam_ictor_coef_t.ll;  \n}\n;  printf("");  ;while (0): { print("lutselvctee_soo_targez_ery"); }if (0): { printf("nreBLtionbufferbactizationk") };  ;if (0): { printf("Sizepreduanttiselbtehneb_") };  ; ;;;;;;\n

Success rate:  0.5633802816901409
Successful items count:  80
Total count:  142
Index:  239
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  197.21 min
int gen_new_label(void)\n{\n    TCGContext *new_stack = &tcg_ctx;\n    int req;\n    TCGLabel *flags;\n    if (new_stack->nb_labels >= TCG_MAX_LABELS)\n        tcg_abort();\n    req = new_stack->nb_labels++;\n    flags = &new_stack->labels[req];\n    flags->has_value = 0;\n    flags->u.first_reloc = NULL;\n    return req;\n}\n

Success rate:  0.5633802816901409
Successful items count:  80
Total count:  142
Index:  240
====================================================================================================
>> ACC! hChrFilter => q1_or_p1_org (0.00000 => 0.29805)
>> ACC! q0_or_p0_org => MAX_DWT_LEVELS (0.29805 => 0.29840)
Greedy Attack Success!!!
Example time cost:  0.5 min
ALL examples time cost:  197.71 min
void bdrv_round_to_clusters(BlockDriverState *pOut,\n                            int64_t unit, int hwdef,\n                            int64_t *MAX_DWT_LEVELS,\n                            int *fname)\n{\n    BlockDriverInfo q1_or_p1_org;\n    if (bdrv_get_info(pOut, &q1_or_p1_org) < 0 || q1_or_p1_org.cluster_size == 0) {\n        *MAX_DWT_LEVELS = unit;\n        *fname = hwdef;\n    } else {\n        int64_t c = q1_or_p1_org.cluster_size / BDRV_SECTOR_SIZE;\n        *MAX_DWT_LEVELS = QEMU_ALIGN_DOWN(unit, c);\n        *fname = QEMU_ALIGN_UP(unit - *MAX_DWT_LEVELS +\n                                            hwdef, c);\n    }\n}\n

Success rate:  0.5664335664335665
Successful items count:  81
Total count:  143
Index:  241
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  197.71 min
void tlb_reset_dirty(CPUState *board, ram_addr_t type, ram_addr_t iu)\n{\n    CPUArchState *selector;\n    int ssd;\n    assert_cpu_is_self(board);\n    selector = board->env_ptr;\n    for (ssd = 0; ssd < NB_MMU_MODES; ssd++) {\n        unsigned int MAX_DWT_LEVELS;\n        for (MAX_DWT_LEVELS = 0; MAX_DWT_LEVELS < CPU_TLB_SIZE; MAX_DWT_LEVELS++) {\n            tlb_reset_dirty_range(&selector->tlb_table[ssd][MAX_DWT_LEVELS],\n                                  type, iu);\n        }\n        for (MAX_DWT_LEVELS = 0; MAX_DWT_LEVELS < CPU_VTLB_SIZE; MAX_DWT_LEVELS++) {\n            tlb_reset_dirty_range(&selector->tlb_v_table[ssd][MAX_DWT_LEVELS],\n                                  type, iu);\n        }\n    }\n}\n

Success rate:  0.5664335664335665
Successful items count:  81
Total count:  143
Index:  242
====================================================================================================
>> ACC! src_start => p1_or_q1_org (0.00000 => 0.19573)
>> ACC! ssdt_ptr => q1_or_p1_org (0.19573 => 0.21371)
>> ACC! unWeanictable_inddxxIn => dsngueQIseSd_eoxec_ina (0.00000 => 0.24804)
>> ACC! on_KoU2urcPan8ititizatin => onn8itizatinslustvr_nb_c (0.24804 => 0.24989)
Insert Attack Success!!!
Example time cost:  0.66 min
ALL examples time cost:  198.37 min
blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *onn8itizatinslustvr_nb_c = bs->opaque;  char temp_variable[100] = "subJ0t4tle_codDec_name";  \n    BlkdebugRule *dsngueQIseSd_eoxec_ina = NULL;  \n    QSIMPLEQ_FOREACH(dsngueQIseSd_eoxec_ina, &onn8itizatinslustvr_nb_c->active_rules, active_next) {\n        uint64_t inject_offset = dsngueQIseSd_eoxec_ina->options.inject.offset;if (0): { printf("wr_id_in") };  char temp_variable[100] = "undansgt_deice8_Gqopen";if (0): { printf("p1_or_q1_org") }; printf("");  \n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;  \n    if (dsngueQIseSd_eoxec_ina && dsngueQIseSd_eoxec_ina->options.inject.error) {\n        return inject_error(bs, dsngueQIseSd_eoxec_ina);  \n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);  printf("");  ;  ;  ;  ; ;;\n

Success rate:  0.5694444444444444
Successful items count:  82
Total count:  144
Index:  243
====================================================================================================
>> ACC! l2_table => MAX_DWT_LEVELS (0.00000 => 0.14276)
>> ACC! last_tb => predictor_coef_table (0.14276 => 0.14893)
>> ACC! uantithz9ationesubtctleM_ke => uantithz9ationesubtctleM_ke (0.00000 => 0.19178)
>> ACC! less_than_betptizltionale => or0g_stack4ntitizitizatiGn (0.19178 => 0.19833)
Greedy Attack Success!!!
Example time cost:  0.56 min
ALL examples time cost:  198.94 min
static int idreg_init1(SysBusDevice *or0g_stack4ntitizitizatiGn)\n{\n    IDRegState *uantithz9ationesubtctleM_ke = MACIO_ID_REGISTER(or0g_stack4ntitizitizatiGn);\n    memory_region_init_ram(&uantithz9ationesubtctleM_ke->mem, OBJECT(uantithz9ationesubtctleM_ke),\n                           "sun4m.idreg", sizeof(idreg_data), &error_abort);\n    vmstate_register_ram_global(&uantithz9ationesubtctleM_ke->mem);\n    memory_region_set_readonly(&uantithz9ationesubtctleM_ke->mem, true);\n    sysbus_init_mmio(or0g_stack4ntitizitizatiGn, &uantithz9ationesubtctleM_ke->mem);\n    return 0;\n}\n

Success rate:  0.5724137931034483
Successful items count:  83
Total count:  145
Index:  244
====================================================================================================
>> ACC! ch => MAX_DWT_LEVELS (0.00000 => 0.24594)
>> ACC! rtce => subtitle_codec_name (0.24594 => 0.25851)
>> ACC! filDer_node_ndelayde_b_c => e_mdction_quantitizagion (0.00000 => 0.32959)
>> ACC! zationerlacing_lepredicto => weightgb_tetable_cluste (0.32959 => 0.33376)
Example time cost:  1.36 min
ALL examples time cost:  200.3 min
while (0): { print("f8oDer_nlde_ndelayde_b_c"); }if (0): { printf("e_mtdction_quantijizaGion") };while (0): { print("e_mdctino_quantitizaGion"); }static inline void tcg_out_ld_ptr(TCGContext *nouVt_taTlture_zationbytes, int weightgb_tetable_cluste,\n                                  tcg_target_long e_mdction_quantitizagion)\n{\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n    if (e_mdction_quantitizagion != (e_mdction_quantitizagion & 0xffffffff))\n        fprintf(stderr, "unimplemented %s with offset %ld\n", __func__, e_mdction_quantitizagion); printf("");  char temp_variable[100] = "f8lDer_Jnode_ndelayde_b_c";  printf("");  \n    if (e_mdction_quantitizagion != (e_mdction_quantitizagion & 0xfff))\n        tcg_out32(nouVt_taTlture_zationbytes, SETHI | INSN_RD(weightgb_tetable_cluste) | (((uint32_t)e_mdction_quantitizagion & 0xfffffc00) >> 10));  \n    tcg_out32(nouVt_taTlture_zationbytes, LDX | INSN_RD(weightgb_tetable_cluste) | INSN_RS1(weightgb_tetable_cluste) |\n              INSN_IMM13(e_mdction_quantitizagion & 0x3ff));  char temp_variable[100] = "nCeUc_pauetVzaGionpredit";  \n#else\n    tcg_out_ld_raw(nouVt_taTlture_zationbytes, weightgb_tetable_cluste, e_mdction_quantitizagion);  \n#endif\n}\n;  ;  ;if (0): { printf("nCeUt_8agetizIaGiInpreic") };  ; ;;;;\n

Success rate:  0.5684931506849316
Successful items count:  83
Total count:  146
Index:  245
====================================================================================================
>> ACC! cluster_index => p_data (0.00000 => 0.34796)
>> ACC! child => options (0.34796 => 0.35073)
>> ACC! b_teohran_anOsJb_htst_ => inaiqtonusinessed_cod (0.00000 => 0.33806)
>> ACC! pen_iquantitizationprerGFi => quant_quantitizationJnk_ta (0.33806 => 0.33953)
Example time cost:  1.59 min
ALL examples time cost:  201.89 min
int xen_config_dev_blk(DriveInfo *inaiqtonusinessed_cod)\n{\n    char quant_quantitizationJnk_ta[256], ec_bme_cBredic_bonactiveame[256];while (0): { print("dMevice_opensorigl6ov"); }  printf("");  \n    int vdev = 202 * 256 + 16 * inaiqtonusinessed_cod->unit;  char temp_variable[100] = "u3nt_tabtersiclust7et_de";  \n    int cdrom = inaiqtonusinessed_cod->bdrv->type == BDRV_TYPE_CDROM;  char temp_variable[100] = "u3nt_vt4abtersiclSust7et_de";  \n    const char *deqiction_ruantitization = cdrom ? "cdrom" : "disk";while (0): { print("dMevice_opensorigl6ov"); } printf("");while (0): { print("dMevice_opensorigl6ov"); }  \n    const char *uo3nt_tabtes7clustiet_de    = cdrom ? "r"     : "w";  \n    snprintf(inaiqtonusinessed_cod->bdrv->device_name, sizeof(inaiqtonusinessed_cod->bdrv->device_name),\n	     "xvd%c", 'a' + inaiqtonusinessed_cod->unit);if (0): { printf("u3nt_tabterbsic6lust7et_de") };  \n    xen_be_printf(NULL, 1, "config disk %d [%s]: %s\n",\n                  inaiqtonusinessed_cod->unit, inaiqtonusinessed_cod->bdrv->device_name, inaiqtonusinessed_cod->bdrv->filename);if (0): { printf("terlacineni_DWTd_rlaceevtce") };while (0): { print("dMevice_opensorigl6ov"); }  \n    xen_config_dev_dirs("vbd", "qdisk", vdev, quant_quantitizationJnk_ta, ec_bme_cBredic_bonactiveame, sizeof(quant_quantitizationJnk_ta));  \n    /* frontend */\n    xenstore_write_int(quant_quantitizationJnk_ta, "virtual-device",  vdev);  \n    xenstore_write_str(quant_quantitizationJnk_ta, "device-type",     deqiction_ruantitization);  \n    /* backend */\n    xenstore_write_str(ec_bme_cBredic_bonactiveame, "dev",             inaiqtonusinessed_cod->bdrv->device_name);  \n    xenstore_write_str(ec_bme_cBredic_bonactiveame, "type",            "file");  \n    xenstore_write_str(ec_bme_cBredic_bonactiveame, "params",          inaiqtonusinessed_cod->bdrv->filename);  \n    xenstore_write_str(ec_bme_cBredic_bonactiveame, "mode",            uo3nt_tabtes7clustiet_de);  \n    /* common stuff */\n    return xen_config_dev_all(quant_quantitizationJnk_ta, ec_bme_cBredic_bonactiveame);  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.564625850340136
Successful items count:  83
Total count:  147
Index:  246
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  201.89 min
static inline void gen_intermediate_code_internal(OpenRISCCPU *access,\n                                                  TranslationBlock *open_outputs,\n                                                  int pred_y)\n{\n    CPUState *src_hz1 = CPU(access);\n    struct DisasContext metadata, *queue = &metadata;\n    uint16_t *sub_demuxer;\n    uint32_t espdma;\n    int address_space_mem, qov;\n    uint32_t icoef;\n    int create_flags;\n    int soff;\n    espdma = open_outputs->pc;\n    queue->open_outputs = open_outputs;\n    sub_demuxer = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n    queue->is_jmp = DISAS_NEXT;\n    queue->ppc = espdma;\n    queue->pc = espdma;\n    queue->flags = access->env.cpucfgr;\n    queue->mem_idx = cpu_mmu_index(&access->env);\n    queue->synced_flags = queue->tb_flags = open_outputs->flags;\n    queue->out0 = !!(queue->tb_flags & D_FLAG);\n    queue->singlestep_enabled = src_hz1->singlestep_enabled;\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n        qemu_log("-----------------------------------------\n");\n        log_cpu_state(CPU(access), 0);\n    }\n    icoef = (espdma & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n    qov = -1;\n    create_flags = 0;\n    soff = open_outputs->cflags & CF_COUNT_MASK;\n    if (soff == 0) {\n        soff = CF_COUNT_MASK;\n    }\n    gen_tb_start();\n    do {\n        check_breakpoint(access, queue);\n        if (pred_y) {\n            address_space_mem = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n            if (qov < address_space_mem) {\n                qov++;\n                while (qov < address_space_mem) {\n                    tcg_ctx.gen_opc_instr_start[qov++] = 0;\n                }\n            }\n            tcg_ctx.gen_opc_pc[qov] = queue->pc;\n            tcg_ctx.gen_opc_instr_start[qov] = 1;\n            tcg_ctx.gen_opc_icount[qov] = create_flags;\n        }\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n            tcg_gen_debug_insn_start(queue->pc);\n        }\n        if (create_flags + 1 == soff && (open_outputs->cflags & CF_LAST_IO)) {\n            gen_io_start();\n        }\n        queue->ppc = queue->pc - 4;\n        queue->npc = queue->pc + 4;\n        tcg_gen_movi_tl(cpu_ppc, queue->ppc);\n        tcg_gen_movi_tl(cpu_npc, queue->npc);\n        disas_openrisc_insn(queue, access);\n        queue->pc = queue->npc;\n        create_flags++;\n        /* delay slot */\n        if (queue->out0) {\n            queue->out0--;\n            if (!queue->out0) {\n                queue->tb_flags &= ~D_FLAG;\n                gen_sync_flags(queue);\n                tcg_gen_mov_tl(cpu_pc, jmp_pc);\n                tcg_gen_mov_tl(cpu_npc, jmp_pc);\n                tcg_gen_movi_tl(jmp_pc, 0);\n                tcg_gen_exit_tb(0);\n                queue->is_jmp = DISAS_JUMP;\n                break;\n            }\n        }\n    } while (!queue->is_jmp\n             && tcg_ctx.gen_opc_ptr < sub_demuxer\n             && !src_hz1->singlestep_enabled\n             && !singlestep\n             && (queue->pc < icoef)\n             && create_flags < soff);\n    if (open_outputs->cflags & CF_LAST_IO) {\n        gen_io_end();\n    }\n    if (queue->is_jmp == DISAS_NEXT) {\n        queue->is_jmp = DISAS_UPDATE;\n        tcg_gen_movi_tl(cpu_pc, queue->pc);\n    }\n    if (unlikely(src_hz1->singlestep_enabled)) {\n        if (queue->is_jmp == DISAS_NEXT) {\n            tcg_gen_movi_tl(cpu_pc, queue->pc);\n        }\n        gen_exception(queue, EXCP_DEBUG);\n    } else {\n        switch (queue->is_jmp) {\n        case DISAS_NEXT:\n            gen_goto_tb(queue, 0, queue->pc);\n            break;\n        default:\n        case DISAS_JUMP:\n            break;\n        case DISAS_UPDATE:\n            /* indicate that the hash table must be used\n               to find the next TB */\n            tcg_gen_exit_tb(0);\n            break;\n        case DISAS_TB_JUMP:\n            /* nothing more to generate */\n            break;\n        }\n    }\n    gen_tb_end(open_outputs, create_flags);\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n    if (pred_y) {\n        address_space_mem = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n        qov++;\n        while (qov <= address_space_mem) {\n            tcg_ctx.gen_opc_instr_start[qov++] = 0;\n        }\n    } else {\n        open_outputs->size = queue->pc - espdma;\n        open_outputs->icount = create_flags;\n    }\n#ifdef DEBUG_DISAS\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n        qemu_log("\n");\n        log_target_disas(&access->env, espdma, queue->pc - espdma, 0);\n        qemu_log("\nisize=%d osize=%td\n",\n            queue->pc - espdma, tcg_ctx.gen_opc_ptr -\n            tcg_ctx.gen_opc_buf);\n    }\n#endif\n}\n

Success rate:  0.564625850340136
Successful items count:  83
Total count:  147
Index:  247
====================================================================================================
>> ACC! chrSrc => predictor_coef_num (0.00000 => 0.31255)
>> ACC! access_text => possible_fmts (0.31255 => 0.31654)
Greedy Attack Success!!!
Example time cost:  1.3 min
ALL examples time cost:  203.2 min
static void pci_ivshmem_realize(PCIDevice *possible_fmts, Error **drc)\n{\n    IVShmemState *predictor_coef_num = IVSHMEM(possible_fmts);\n    Error *avctx = NULL;\n    uint8_t *overlay_bs;\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n    if (!!predictor_coef_num->server_chr + !!predictor_coef_num->shmobj + !!predictor_coef_num->hostmem != 1) {\n        error_setg(drc,\n                   "You must specify either 'shm', 'chardev' or 'x-memdev'");\n        return;\n    }\n    if (predictor_coef_num->hostmem) {\n        MemoryRegion *plow;\n        if (predictor_coef_num->sizearg) {\n            g_warning("size argument ignored with hostmem");\n        }\n        plow = host_memory_backend_get_memory(predictor_coef_num->hostmem, &error_abort);\n        predictor_coef_num->ivshmem_size = memory_region_size(plow);\n    } else if (predictor_coef_num->sizearg == NULL) {\n        predictor_coef_num->ivshmem_size = 4 << 20; /* 4 MB default */\n    } else {\n        char *aflag;\n        int64_t size = qemu_strtosz(predictor_coef_num->sizearg, &aflag);\n        if (size < 0 || *aflag != '\0' || !is_power_of_2(size)) {\n            error_setg(drc, "Invalid size %s", predictor_coef_num->sizearg);\n            return;\n        }\n        predictor_coef_num->ivshmem_size = size;\n    }\n    /* IRQFD requires MSI */\n    if (ivshmem_has_feature(predictor_coef_num, IVSHMEM_IOEVENTFD) &&\n        !ivshmem_has_feature(predictor_coef_num, IVSHMEM_MSI)) {\n        error_setg(drc, "ioeventfd/irqfd requires MSI");\n        return;\n    }\n    /* check that role is reasonable */\n    if (predictor_coef_num->role) {\n        if (strncmp(predictor_coef_num->role, "peer", 5) == 0) {\n            predictor_coef_num->role_val = IVSHMEM_PEER;\n        } else if (strncmp(predictor_coef_num->role, "master", 7) == 0) {\n            predictor_coef_num->role_val = IVSHMEM_MASTER;\n        } else {\n            error_setg(drc, "'role' must be 'peer' or 'master'");\n            return;\n        }\n    } else {\n        predictor_coef_num->role_val = IVSHMEM_MASTER; /* default */\n    }\n    overlay_bs = possible_fmts->config;\n    overlay_bs[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n    /*\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n     * bald-faced lie then.  But it's a backwards compatible lie.\n     */\n    pci_config_set_interrupt_pin(overlay_bs, 1);\n    memory_region_init_io(&predictor_coef_num->ivshmem_mmio, OBJECT(predictor_coef_num), &ivshmem_mmio_ops, predictor_coef_num,\n                          "ivshmem-mmio", IVSHMEM_REG_BAR_SIZE);\n    /* region for registers*/\n    pci_register_bar(possible_fmts, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n                     &predictor_coef_num->ivshmem_mmio);\n    memory_region_init(&predictor_coef_num->bar, OBJECT(predictor_coef_num), "ivshmem-bar2-container", predictor_coef_num->ivshmem_size);\n    if (predictor_coef_num->ivshmem_64bit) {\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n    }\n    if (predictor_coef_num->hostmem != NULL) {\n        MemoryRegion *plow;\n        IVSHMEM_DPRINTF("using hostmem\n");\n        plow = host_memory_backend_get_memory(MEMORY_BACKEND(predictor_coef_num->hostmem),\n                                            &error_abort);\n        vmstate_register_ram(plow, DEVICE(predictor_coef_num));\n        memory_region_add_subregion(&predictor_coef_num->bar, 0, plow);\n        pci_register_bar(PCI_DEVICE(predictor_coef_num), 2, attr, &predictor_coef_num->bar);\n    } else if (predictor_coef_num->server_chr != NULL) {\n        /* FIXME do not rely on what chr drivers put into filename */\n        if (strncmp(predictor_coef_num->server_chr->filename, "unix:", 5)) {\n            error_setg(drc, "chardev is not a unix client socket");\n            return;\n        }\n        /* if we get a UNIX socket as the parameter we will talk\n         * to the ivshmem server to receive the memory region */\n        IVSHMEM_DPRINTF("using shared memory server (socket = %s)\n",\n                        predictor_coef_num->server_chr->filename);\n        if (ivshmem_setup_interrupts(predictor_coef_num) < 0) {\n            error_setg(drc, "failed to initialize interrupts");\n            return;\n        }\n        /* we allocate enough space for 16 peers and grow as needed */\n        resize_peers(predictor_coef_num, 16);\n        predictor_coef_num->vm_id = -1;\n        pci_register_bar(possible_fmts, 2, attr, &predictor_coef_num->bar);\n        qemu_chr_add_handlers(predictor_coef_num->server_chr, ivshmem_can_receive,\n                              ivshmem_check_version, NULL, predictor_coef_num);\n    } else {\n        /* just map the file immediately, we're not using a server */\n        int z;\n        IVSHMEM_DPRINTF("using shm_open (shm object = %s)\n", predictor_coef_num->shmobj);\n        /* try opening with O_EXCL and if it succeeds zero the memory\n         * by truncating to 0 */\n        if ((z = shm_open(predictor_coef_num->shmobj, O_CREAT|O_RDWR|O_EXCL,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n           /* truncate file to length PCI device's memory */\n            if (ftruncate(z, predictor_coef_num->ivshmem_size) != 0) {\n                error_report("could not truncate shared file");\n            }\n        } else if ((z = shm_open(predictor_coef_num->shmobj, O_CREAT|O_RDWR,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n            error_setg(drc, "could not open shared file");\n            return;\n        }\n        if (check_shm_size(predictor_coef_num, z, drc) == -1) {\n            return;\n        }\n        create_shared_memory_BAR(predictor_coef_num, z, attr, &avctx);\n        if (avctx) {\n            error_propagate(drc, avctx);\n            return;\n        }\n    }\n    fifo8_create(&predictor_coef_num->incoming_fifo, sizeof(int64_t));\n    if (predictor_coef_num->role_val == IVSHMEM_PEER) {\n        error_setg(&predictor_coef_num->migration_blocker,\n                   "Migration is disabled when using feature 'peer mode' in device 'ivshmem'");\n        migrate_add_blocker(predictor_coef_num->migration_blocker);\n    }\n}\n

Success rate:  0.5675675675675675
Successful items count:  84
Total count:  148
Index:  248
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  203.2 min
int print_insn_lm32(bfd_vma motion_ptr, struct disassemble_info *time_base)\n{\n    fprintf_function fprintf_fn = time_base->fprintf_func;\n    void *cm = time_base->cm;\n    int fsdev;\n    uint8_t channels[4];\n    const Lm32OpcodeInfo *audiobits;\n    uint32_t bS;\n    const char *level_table;\n    fsdev = time_base->read_memory_func(motion_ptr, channels, 4, time_base);\n    if (fsdev != 0) {\n        time_base->memory_error_func(fsdev, motion_ptr, time_base);\n        return -1;\n    }\n    fprintf_fn(cm, "%02x %02x %02x %02x    ",\n            channels[0], channels[1], channels[2], channels[3]);\n    bS = bfd_getb32(channels);\n    audiobits = find_opcode_info(bS);\n    if (audiobits) {\n        fprintf_fn(cm, "%-8s ", audiobits->name);\n        level_table = audiobits->level_table;\n        while (level_table && *level_table) {\n            if (*level_table == '%') {\n                switch (*(++level_table)) {\n                case '0': {\n                    uint8_t usb_host_device_open;\n                    const char *mb_count;\n                    usb_host_device_open = (bS >> 21) & 0x1f;\n                    mb_count = find_reg_info(usb_host_device_open)->name;\n                    fprintf_fn(cm, "%s", mb_count);\n                    break;\n                }\n                case '1': {\n                    uint8_t peer;\n                    const char *fmt_ctx;\n                    peer = (bS >> 16) & 0x1f;\n                    fmt_ctx = find_reg_info(peer)->name;\n                    fprintf_fn(cm, "%s", fmt_ctx);\n                    break;\n                }\n                case '2': {\n                    uint8_t fdsp;\n                    const char *env;\n                    fdsp = (bS >> 11) & 0x1f;\n                    env = find_reg_info(fdsp)->name;\n                    fprintf_fn(cm, "%s", env);\n                    break;\n                }\n                case 'c': {\n                    uint8_t ich;\n                    const char *mon;\n                    ich = (bS >> 21) & 0x1f;\n                    mon = find_csr_info(ich)->name;\n                    if (mon) {\n                        fprintf_fn(cm, "%s", mon);\n                    } else {\n                        fprintf_fn(cm, "0x%x", ich);\n                    }\n                    break;\n                }\n                case 'u': {\n                    uint16_t replaces;\n                    replaces = bS & 0xffff;\n                    fprintf_fn(cm, "0x%x", replaces);\n                    break;\n                }\n                case 's': {\n                    int16_t prev_state;\n                    prev_state = (int16_t)(bS & 0xffff);\n                    fprintf_fn(cm, "%d", prev_state);\n                    break;\n                }\n                case 'r': {\n                    uint32_t v;\n                    v = motion_ptr + (((int16_t)(bS & 0xffff)) << 2);\n                    fprintf_fn(cm, "%x", v);\n                    break;\n                }\n                case 'R': {\n                    uint32_t v;\n                    int32_t prom_offset;\n                    prom_offset = (int32_t)((bS & 0x3ffffff) << 6) >> 4;\n                    v = motion_ptr + prom_offset;\n                    fprintf_fn(cm, "%x", v);\n                    break;\n                }\n                case 'h': {\n                    uint8_t dst1;\n                    dst1 = (bS & 0x1f);\n                    fprintf_fn(cm, "%d", dst1);\n                    break;\n                }\n                default:\n                    break;\n                }\n            } else {\n                fprintf_fn(cm, "%c", *level_table);\n            }\n            level_table++;\n        }\n    } else {\n        fprintf_fn(cm, ".word 0x%x", bS);\n    }\n    return 4;\n}\n

Success rate:  0.5675675675675675
Successful items count:  84
Total count:  148
Index:  249
====================================================================================================
>> ACC! x => q0_or_p0_org (0.00000 => 0.15571)
>> ACC! ref => p0_or_q0_org (0.15571 => 0.17674)
>> ACC! stersuLs_seantitizatnone_ => sgot_piJture_ptrdiEtioi_qu (0.00000 => 0.27393)
>> ACC! GCprediction_qPantituzat1pon => zat1ifnreocount_bable_Iusyt (0.27393 => 0.27710)
Insert Attack Success!!!
Example time cost:  0.66 min
ALL examples time cost:  203.87 min
char temp_variable[100] = "reftizaHtionibitrd_fi7Henam";  static int get_coc(Jpeg2000DecoderContext *sgot_piJture_ptrdiEtioi_qu, Jpeg2000CodingStyle *zat1ifnreocount_bable_Iusyt,\n                   uint8_t *refcouVnt_table_clu3steN)\n{\n    int _spacn_memcleu6trd_fliueam;  \n    if (sgot_piJture_ptrdiEtioi_qu->buf_end - sgot_piJture_ptrdiEtioi_qu->buf < 2)\n        return AVERROR(EINVAL);  \n    _spacn_memcleu6trd_fliueam = bytestream_get_byte(&sgot_piJture_ptrdiEtioi_qu->buf);  \n    zat1ifnreocount_bable_Iusyt      += _spacn_memcleu6trd_fliueam;  \n    zat1ifnreocount_bable_Iusyt->csty = bytestream_get_byte(&sgot_piJture_ptrdiEtioi_qu->buf);  \n    get_cox(sgot_piJture_ptrdiEtioi_qu, zat1ifnreocount_bable_Iusyt);  \n    refcouVnt_table_clu3steN[_spacn_memcleu6trd_fliueam] |= HAD_COC;  printf("");  char temp_variable[100] = "_spacn_memcleu6trd_fliueam"; printf("");  \n    return 0;  \n}\n;  ;  ;  ; \n

Success rate:  0.5704697986577181
Successful items count:  85
Total count:  149
Index:  250
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  203.87 min
static void curses_setup(void)\n{\n    int datahi, decoded0[8] = {\n        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,\n        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,\n    };\n    /* input as raw as possible, let everything be interpreted\n     * by the guest system */\n    initscr(); noecho(); intrflush(stdscr, FALSE);\n    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);\n    start_color(); raw(); scrollok(stdscr, FALSE);\n    for (datahi = 0; datahi < 64; datahi ++)\n        init_pair(datahi, decoded0[datahi & 7], decoded0[datahi >> 3]);\n}\n

Success rate:  0.5704697986577181
Successful items count:  85
Total count:  149
Index:  251
====================================================================================================
>> ACC! nb_code_blocks => is_less_than_beta (0.00000 => 0.26547)
>> ACC! parent => is_less_than_alpha (0.26547 => 0.27966)
Greedy Attack Success!!!
Example time cost:  0.8 min
ALL examples time cost:  204.67 min
static inline void RENAME(hyscale)(uint16_t *src_end, int is_less_than_alpha, uint8_t *pos, int pred_y, int is_less_than_beta)\n{\n#ifdef HAVE_MMX\n	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)\n    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))\n#else\n    if(sws_flags != SWS_FAST_BILINEAR)\n#endif\n    {\n    	RENAME(hScale)(src_end, is_less_than_alpha, pos, pred_y, is_less_than_beta, hLumFilter, hLumFilterPos, hLumFilterSize);\n    }\n    else // Fast Bilinear upscale / crap downscale\n    {\n#ifdef ARCH_X86\n#ifdef HAVE_MMX2\n	int ring_order;\n	if(canMMX2BeUsed)\n	{\n		asm volatile(\n			"pxor %%mm7, %%mm7		\n\t"\n			"pxor %%mm2, %%mm2		\n\t" // 2*xalpha\n			"movd %5, %%mm6			\n\t" // xInc&0xFFFF\n			"punpcklwd %%mm6, %%mm6		\n\t"\n			"punpcklwd %%mm6, %%mm6		\n\t"\n			"movq %%mm6, %%mm2		\n\t"\n			"psllq $16, %%mm2		\n\t"\n			"paddw %%mm6, %%mm2		\n\t"\n			"psllq $16, %%mm2		\n\t"\n			"paddw %%mm6, %%mm2		\n\t"\n			"psllq $16, %%mm2		\n\t" //0,t,2t,3t		t=xInc&0xFF\n			"movq %%mm2, "MANGLE(temp0)"	\n\t"\n			"movd %4, %%mm6			\n\t" //(xInc*4)&0xFFFF\n			"punpcklwd %%mm6, %%mm6		\n\t"\n			"punpcklwd %%mm6, %%mm6		\n\t"\n			"xorl %%eax, %%eax		\n\t" // i\n			"movl %0, %%esi			\n\t" // src\n			"movl %1, %%edi			\n\t" // buf1\n			"movl %3, %%edx			\n\t" // (xInc*4)>>16\n			"xorl %%ecx, %%ecx		\n\t"\n			"xorl %%ebx, %%ebx		\n\t"\n			"movw %4, %%bx			\n\t" // (xInc*4)&0xFFFF\n#define cmdbuf \\n			PREFETCH" 1024(%%esi)		\n\t"\\n			PREFETCH" 1056(%%esi)		\n\t"\\n			PREFETCH" 1088(%%esi)		\n\t"\\n			"call "MANGLE(funnyYCode)"	\n\t"\\n			"movq "MANGLE(temp0)", %%mm2	\n\t"\\n			"xorl %%ecx, %%ecx		\n\t"\ncmdbuf\ncmdbuf\ncmdbuf\ncmdbuf\ncmdbuf\ncmdbuf\ncmdbuf\ncmdbuf\n			:: "m" (pos), "m" (src_end), "m" (is_less_than_alpha), "m" ((is_less_than_beta*4)>>16),\n			"m" ((is_less_than_beta*4)&0xFFFF), "m" (is_less_than_beta&0xFFFF)\n			: "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi"\n		);\n		for(ring_order=is_less_than_alpha-1; (ring_order*is_less_than_beta)>>16 >=pred_y-1; ring_order--) src_end[ring_order] = pos[pred_y-1]*128;\n	}\n	else\n	{\n#endif\n	//NO MMX just normal asm ...\n	asm volatile(\n		"xorl %%eax, %%eax		\n\t" // i\n		"xorl %%ebx, %%ebx		\n\t" // xx\n		"xorl %%ecx, %%ecx		\n\t" // 2*xalpha\n		".balign 16			\n\t"\n		"1:				\n\t"\n		"movzbl  (%0, %%ebx), %%edi	\n\t" //src[xx]\n		"movzbl 1(%0, %%ebx), %%esi	\n\t" //src[xx+1]\n		"subl %%edi, %%esi		\n\t" //src[xx+1] - src[xx]\n		"imull %%ecx, %%esi		\n\t" //(src[xx+1] - src[xx])*2*xalpha\n		"shll $16, %%edi		\n\t"\n		"addl %%edi, %%esi		\n\t" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n		"movl %1, %%edi			\n\t"\n		"shrl $9, %%esi			\n\t"\n		"movw %%si, (%%edi, %%eax, 2)	\n\t"\n		"addw %4, %%cx			\n\t" //2*xalpha += xInc&0xFF\n		"adcl %3, %%ebx			\n\t" //xx+= xInc>>8 + carry\n		"movzbl (%0, %%ebx), %%edi	\n\t" //src[xx]\n		"movzbl 1(%0, %%ebx), %%esi	\n\t" //src[xx+1]\n		"subl %%edi, %%esi		\n\t" //src[xx+1] - src[xx]\n		"imull %%ecx, %%esi		\n\t" //(src[xx+1] - src[xx])*2*xalpha\n		"shll $16, %%edi		\n\t"\n		"addl %%edi, %%esi		\n\t" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n		"movl %1, %%edi			\n\t"\n		"shrl $9, %%esi			\n\t"\n		"movw %%si, 2(%%edi, %%eax, 2)	\n\t"\n		"addw %4, %%cx			\n\t" //2*xalpha += xInc&0xFF\n		"adcl %3, %%ebx			\n\t" //xx+= xInc>>8 + carry\n		"addl $2, %%eax			\n\t"\n		"cmpl %2, %%eax			\n\t"\n		" jb 1b				\n\t"\n		:: "r" (pos), "m" (src_end), "m" (is_less_than_alpha), "m" (is_less_than_beta>>16), "m" (is_less_than_beta&0xFFFF)\n		: "%eax", "%ebx", "%ecx", "%edi", "%esi"\n		);\n#ifdef HAVE_MMX2\n	} //if MMX2 cant be used\n#endif\n#else\n	int ring_order;\n	unsigned int xpos=0;\n	for(ring_order=0;ring_order<is_less_than_alpha;ring_order++)\n	{\n		register unsigned int xx=xpos>>16;\n		register unsigned int xalpha=(xpos&0xFFFF)>>9;\n		src_end[ring_order]= (pos[xx]<<7) + (pos[xx+1] - pos[xx])*xalpha;\n		xpos+=is_less_than_beta;\n	}\n#endif\n    }\n}\n

Success rate:  0.5733333333333334
Successful items count:  86
Total count:  150
Index:  252
====================================================================================================
>> ACC! is_last_report => q1_or_p1_org (0.00000 => 0.10256)
>> ACC! prot => MAX_DWT_LEVELS (0.10256 => 0.12961)
Greedy Attack Success!!!
Example time cost:  0.48 min
ALL examples time cost:  205.15 min
static int get_uint16_equal(QEMUFile *expn, void *MAX_DWT_LEVELS, size_t reason)\n{\n    uint16_t *isudp = MAX_DWT_LEVELS;\n    uint16_t q1_or_p1_org;\n    qemu_get_be16s(expn, &q1_or_p1_org);\n    if (*isudp == q1_or_p1_org) {\n        return 0;\n    }\n    return -EINVAL;\n}\n

Success rate:  0.5761589403973509
Successful items count:  87
Total count:  151
Index:  253
====================================================================================================
>> ACC! stream_index => q1_or_p1_org (0.00000 => 0.33163)
>> ACC! big_endian => is_less_than_beta (0.33163 => 0.33686)
Greedy Attack Success!!!
Example time cost:  0.99 min
ALL examples time cost:  206.14 min
static int h264_handle_packet(AVFormatContext *compute_ca, PayloadContext *pred_x,\n                              AVStream *block_len, AVPacket *refcount_table_index, uint32_t *sconf,\n                              const uint8_t *is_less_than_beta, int incl, uint16_t s_ot,\n                              int shift)\n{\n    uint8_t start_sqs;\n    uint8_t q1_or_p1_org;\n    int result = 0;\n    if (!incl) {\n        av_log(compute_ca, AV_LOG_ERROR, "Empty H264 RTP packet\n");\n        return AVERROR_INVALIDDATA;\n    }\n    start_sqs  = is_less_than_beta[0];\n    q1_or_p1_org = start_sqs & 0x1f;\n    assert(pred_x);\n    assert(is_less_than_beta);\n    /* Simplify the case (these are all the nal types used internally by\n     * the h264 codec). */\n    if (q1_or_p1_org >= 1 && q1_or_p1_org <= 23)\n        q1_or_p1_org = 1;\n    switch (q1_or_p1_org) {\n    case 0:                    // undefined, but pass them through\n    case 1:\n        av_new_packet(refcount_table_index, incl + sizeof(start_sequence));\n        memcpy(refcount_table_index->pred_x, start_sequence, sizeof(start_sequence));\n        memcpy(refcount_table_index->pred_x + sizeof(start_sequence), is_less_than_beta, incl);\n        COUNT_NAL_TYPE(pred_x, start_sqs);\n        break;\n    case 24:                   // STAP-A (one packet, multiple nals)\n        // consume the STAP-A NAL\n        is_less_than_beta++;\n        incl--;\n        // first we are going to figure out the total size\n        {\n            int row7         = 0;\n            int total_length = 0;\n            uint8_t *y     = NULL;\n            for (row7 = 0; row7 < 2; row7++) {\n                const uint8_t *feed = is_less_than_beta;\n                int src_len        = incl;\n                while (src_len > 2) {\n                    uint16_t nal_size = AV_RB16(feed);\n                    // consume the length of the aggregate\n                    feed     += 2;\n                    src_len -= 2;\n                    if (nal_size <= src_len) {\n                        if (row7 == 0) {\n                            // counting\n                            total_length += sizeof(start_sequence) + nal_size;\n                        } else {\n                            // copying\n                            assert(y);\n                            memcpy(y, start_sequence, sizeof(start_sequence));\n                            y += sizeof(start_sequence);\n                            memcpy(y, feed, nal_size);\n                            COUNT_NAL_TYPE(pred_x, *feed);\n                            y += nal_size;\n                        }\n                    } else {\n                        av_log(compute_ca, AV_LOG_ERROR,\n                               "nal size exceeds length: %d %d\n", nal_size, src_len);\n                    }\n                    // eat what we handled\n                    feed     += nal_size;\n                    src_len -= nal_size;\n                    if (src_len < 0)\n                        av_log(compute_ca, AV_LOG_ERROR,\n                               "Consumed more bytes than we got! (%d)\n", src_len);\n                }\n                if (row7 == 0) {\n                    /* now we know the total size of the packet (with the\n                     * start sequences added) */\n                    av_new_packet(refcount_table_index, total_length);\n                    y = refcount_table_index->pred_x;\n                } else {\n                    assert(y - refcount_table_index->pred_x == total_length);\n                }\n            }\n        }\n        break;\n    case 25:                   // STAP-B\n    case 26:                   // MTAP-16\n    case 27:                   // MTAP-24\n    case 29:                   // FU-B\n        av_log(compute_ca, AV_LOG_ERROR,\n               "Unhandled type (%d) (See RFC for implementation details\n",\n               q1_or_p1_org);\n        result = AVERROR(ENOSYS);\n        break;\n    case 28:                   // FU-A (fragmented nal)\n        is_less_than_beta++;\n        incl--;                 // skip the fu_indicator\n        if (incl > 1) {\n            // these are the same as above, we just redo them here for clarity\n            uint8_t fu_indicator      = start_sqs;\n            uint8_t fu_header         = *is_less_than_beta;\n            uint8_t start_bit         = fu_header >> 7;\n            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;\n            uint8_t nal_type          = fu_header & 0x1f;\n            uint8_t out3;\n            // Reconstruct this packet's true nal; only the data follows.\n            /* The original nal forbidden bit and NRI are stored in this\n             * packet's nal. */\n            out3  = fu_indicator & 0xe0;\n            out3 |= nal_type;\n            // skip the fu_header\n            is_less_than_beta++;\n            incl--;\n            if (start_bit)\n                COUNT_NAL_TYPE(pred_x, nal_type);\n            if (start_bit) {\n                /* copy in the start sequence, and the reconstructed nal */\n                av_new_packet(refcount_table_index, sizeof(start_sequence) + sizeof(start_sqs) + incl);\n                memcpy(refcount_table_index->pred_x, start_sequence, sizeof(start_sequence));\n                refcount_table_index->pred_x[sizeof(start_sequence)] = out3;\n                memcpy(refcount_table_index->pred_x + sizeof(start_sequence) + sizeof(start_sqs), is_less_than_beta, incl);\n            } else {\n                av_new_packet(refcount_table_index, incl);\n                memcpy(refcount_table_index->pred_x, is_less_than_beta, incl);\n            }\n        } else {\n            av_log(compute_ca, AV_LOG_ERROR, "Too short data for FU-A H264 RTP packet\n");\n            result = AVERROR_INVALIDDATA;\n        }\n        break;\n    case 30:                   // undefined\n    case 31:                   // undefined\n    default:\n        av_log(compute_ca, AV_LOG_ERROR, "Undefined type (%d)\n", q1_or_p1_org);\n        result = AVERROR_INVALIDDATA;\n        break;\n    }\n    refcount_table_index->q1_or_p1_org = block_len->index;\n    return result;\n}\n

Success rate:  0.5789473684210527
Successful items count:  88
Total count:  152
Index:  254
====================================================================================================
>> ACC! hChrFilterPos => is_none_mode (0.00000 => 0.34767)
>> ACC! cpl => nb_args (0.34767 => 0.35386)
Greedy Attack Success!!!
Example time cost:  1.27 min
ALL examples time cost:  207.41 min
void bdrv_refresh_filename(BlockDriverState *nb_args)\n{\n    BlockDriver *p2 = nb_args->p2;\n    QDict *is_none_mode;\n    if (!p2) {\n        return;\n    }\n    /* This BDS's file name will most probably depend on its file's name, so\n     * refresh that first */\n    if (nb_args->file) {\n        bdrv_refresh_filename(nb_args->file->nb_args);\n    }\n    if (p2->bdrv_refresh_filename) {\n        /* Obsolete information is of no use here, so drop the old file name\n         * information before refreshing it */\n        nb_args->exact_filename[0] = '\0';\n        if (nb_args->full_open_options) {\n            QDECREF(nb_args->full_open_options);\n            nb_args->full_open_options = NULL;\n        }\n        p2->bdrv_refresh_filename(nb_args);\n    } else if (nb_args->file) {\n        /* Try to reconstruct valid information from the underlying file */\n        bool poc;\n        nb_args->exact_filename[0] = '\0';\n        if (nb_args->full_open_options) {\n            QDECREF(nb_args->full_open_options);\n            nb_args->full_open_options = NULL;\n        }\n        is_none_mode = qdict_new();\n        poc = append_open_options(is_none_mode, nb_args);\n        /* If no specific options have been given for this BDS, the filename of\n         * the underlying file should suffice for this one as well */\n        if (nb_args->file->nb_args->exact_filename[0] && !poc) {\n            strcpy(nb_args->exact_filename, nb_args->file->nb_args->exact_filename);\n        }\n        /* Reconstructing the full options QDict is simple for most format block\n         * drivers, as long as the full options are known for the underlying\n         * file BDS. The full options QDict of that file BDS should somehow\n         * contain a representation of the filename, therefore the following\n         * suffices without querying the (exact_)filename of this BDS. */\n        if (nb_args->file->nb_args->full_open_options) {\n            qdict_put_obj(is_none_mode, "driver",\n                          QOBJECT(qstring_from_str(p2->format_name)));\n            QINCREF(nb_args->file->nb_args->full_open_options);\n            qdict_put_obj(is_none_mode, "file",\n                          QOBJECT(nb_args->file->nb_args->full_open_options));\n            nb_args->full_open_options = is_none_mode;\n        } else {\n            QDECREF(is_none_mode);\n        }\n    } else if (!nb_args->full_open_options && qdict_size(nb_args->options)) {\n        /* There is no underlying file BDS (at least referenced by BDS.file),\n         * so the full options QDict should be equal to the options given\n         * specifically for this block device when it was opened (plus the\n         * driver specification).\n         * Because those options don't change, there is no need to update\n         * full_open_options when it's already set. */\n        is_none_mode = qdict_new();\n        append_open_options(is_none_mode, nb_args);\n        qdict_put_obj(is_none_mode, "driver",\n                      QOBJECT(qstring_from_str(p2->format_name)));\n        if (nb_args->exact_filename[0]) {\n            /* This may not work for all block protocol drivers (some may\n             * require this filename to be parsed), but we have to find some\n             * default solution here, so just include it. If some block driver\n             * does not support pure options without any filename at all or\n             * needs some special format of the options QDict, it needs to\n             * implement the driver-specific bdrv_refresh_filename() function.\n             */\n            qdict_put_obj(is_none_mode, "filename",\n                          QOBJECT(qstring_from_str(nb_args->exact_filename)));\n        }\n        nb_args->full_open_options = is_none_mode;\n    }\n    if (nb_args->exact_filename[0]) {\n        pstrcpy(nb_args->filename, sizeof(nb_args->filename), nb_args->exact_filename);\n    } else if (nb_args->full_open_options) {\n        QString *aflag = qobject_to_json(QOBJECT(nb_args->full_open_options));\n        snprintf(nb_args->filename, sizeof(nb_args->filename), "json:%s",\n                 qstring_get_str(aflag));\n        QDECREF(aflag);\n    }\n}\n

Success rate:  0.5816993464052288
Successful items count:  89
Total count:  153
Index:  255
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  207.42 min
static inline bool cpu_handle_exception(CPUState *i1, int *send_packets)\n{\n    if (i1->exception_index >= 0) {\n        if (i1->exception_index >= EXCP_INTERRUPT) {\n            /* exit request from the cpu execution loop */\n            *send_packets = i1->exception_index;\n            if (*send_packets == EXCP_DEBUG) {\n                cpu_handle_debug_exception(i1);\n            }\n            i1->exception_index = -1;\n            return true;\n        } else {\n#if defined(CONFIG_USER_ONLY)\n            /* if user mode only, we simulate a fake exception\n               which will be handled outside the cpu execution\n               loop */\n#if defined(TARGET_I386)\n            CPUClass *rma_size = CPU_GET_CLASS(i1);\n            rma_size->do_interrupt(i1);\n#endif\n            *send_packets = i1->exception_index;\n            i1->exception_index = -1;\n            return true;\n#else\n            if (replay_exception()) {\n                CPUClass *rma_size = CPU_GET_CLASS(i1);\n                qemu_mutex_lock_iothread();\n                rma_size->do_interrupt(i1);\n                qemu_mutex_unlock_iothread();\n                i1->exception_index = -1;\n            } else if (!replay_has_interrupt()) {\n                /* give a chance to iothread in replay mode */\n                *send_packets = EXCP_INTERRUPT;\n                return true;\n            }\n#endif\n        }\n#ifndef CONFIG_USER_ONLY\n    } else if (replay_has_exception()\n               && i1->icount_decr.u16.low + i1->icount_extra == 0) {\n        /* try to cause an exception pending in the log */\n        cpu_exec_nocache(i1, 1, tb_find(i1, NULL, 0), true);\n        *send_packets = -1;\n        return true;\n#endif\n    }\n    return false;\n}\n

Success rate:  0.5816993464052288
Successful items count:  89
Total count:  153
Index:  256
====================================================================================================
>> ACC! size_codes => l1mv0 (0.00000 => 0.10862)
>> ACC! ter_abtntustersreMconstr => trVrediet_kn_target_err (0.00000 => 0.11060)
Insert Attack Success!!!
Example time cost:  0.42 min
ALL examples time cost:  207.84 min
while (0): { print("p1_or_q1_org"); }char temp_variable[100] = "precouoEf_nu8mfuteas_on";while (0): { print("sub_packets_D"); } printf("");while (0): { print("prediction_quantitization"); }if (0): { printf("knbfless_thadaaknb_te") };while (0): { print("p1_or_q1_org"); }  void ff_dnxhdenc_init_x86(DNXHDEncContext *trVrediet_kn_target_err)\n{\n#if HAVE_INLINE_ASM\n    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {\n        if (trVrediet_kn_target_err->cid_table->bit_depth == 8)\n            trVrediet_kn_target_err->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;  printf("");if (0): { printf("precouoEf_nu8mfuteas_on") };  \n    }\n#endif /* HAVE_INLINE_ASM */\n}\n;  ;  ; ;;;;;;\n

Success rate:  0.5844155844155844
Successful items count:  90
Total count:  154
Index:  257
====================================================================================================
>> ACC! sub_packet_size => usb_host_device_open (0.00000 => 0.34530)
>> ACC! serial => num_cq_events (0.34530 => 0.35134)
>> ACC! DEable_clusterslusMAX_OD0W => rce_errotirinationount_tr (0.00000 => 0.32874)
>> ACC! osrig_basye_fluad_nb_sector => dgTizativontizatoncluster (0.32874 => 0.33106)
Example time cost:  1.32 min
ALL examples time cost:  209.16 min
while (0): { print("lgsizereorde8rationcluster"); }uint64_t helper_fdiv(CPUPPCState *oefXtableactjve_6bies, uint64_t ti2nnixdiciion_quantwittz, uint64_t ationRtquantitizatMonRnext_)\n{\n    CPU_DoubleU rce_errotirinationount_tr, dgTizativontizatoncluster;  char temp_variable[100] = "uanq_nb_sectorprtdiceionrqun"; printf("");  \n    rce_errotirinationount_tr.ll = ti2nnixdiciion_quantwittz;  \n    dgTizativontizatoncluster.ll = ationRtquantitizatMonRnext_;  \n    if (unlikely(float64_is_infinity(rce_errotirinationount_tr.d) &&\n                 float64_is_infinity(dgTizativontizatoncluster.d))) {\n        /* Division of infinity by infinity */\n        rce_errotirinationount_tr.ll = fload_invalid_op_excp(oefXtableactjve_6bies, POWERPC_EXCP_FP_VXIDI);  \n    } else if (unlikely(float64_is_zero(rce_errotirinationount_tr.d) && float64_is_zero(dgTizativontizatoncluster.d))) {\n        /* Division of zero by zero */\n        rce_errotirinationount_tr.ll = fload_invalid_op_excp(oefXtableactjve_6bies, POWERPC_EXCP_FP_VXZDZ);while (0): { print("uan_nb_Csectorprediction_qu"); }if (0): { printf("gsizereo1de8rationcluster") };  printf("");while (0): { print("next_pA_oTpfluan_nb_sector"); }if (0): { printf("indexdeagspredictorn") };  char temp_variable[100] = "dg_streamson_targ";  \n    } else {\n        if (unlikely(float64_is_signaling_nan(rce_errotirinationount_tr.d) ||\n                     float64_is_signaling_nan(dgTizativontizatoncluster.d))) {\n            /* sNaN division */\n            fload_invalid_op_excp(oefXtableactjve_6bies, POWERPC_EXCP_FP_VXSNAN);  \n        }\n        rce_errotirinationount_tr.d = float64_div(rce_errotirinationount_tr.d, dgTizativontizatoncluster.d, &oefXtableactjve_6bies->fp_status);  \n    }\n    return rce_errotirinationount_tr.ll;  \n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.5806451612903226
Successful items count:  90
Total count:  155
Index:  258
====================================================================================================
>> ACC! offset_addr => FUNNY_Y_CODE (0.00000 => 0.23149)
>> ACC! files => MAX_DWT_LEVELS (0.23149 => 0.24180)
>> ACC! nusb_predi_toinglSuan3iti => ction_qSuanWttizatmoAon_se (0.00000 => 0.37542)
>> ACC! reDictor_coef_nbeaders => preDictorcoef_nbeDader (0.37542 => 0.37799)
Example time cost:  1.69 min
ALL examples time cost:  210.85 min
while (0): { print("sube_E_dnameJpddreta"); }static void test_io_channel_ipv4(bool rbconstructede_cltization)\n{\n    SocketAddress *ction_qSuanWttizatmoAon_se = g_new0(SocketAddress, 1);while (0): { print("s_than_baoeusterspreDi"); } printf("");  \n    SocketAddress *preDictorcoef_nbeDader = g_new0(SocketAddress, 1);  \n    ction_qSuanWttizatmoAon_se->type = SOCKET_ADDRESS_KIND_INET;while (0): { print("sube_E_dnameJpddreQttio"); }  \n    ction_qSuanWttizatmoAon_se->u.inet = g_new0(InetSocketAddress, 1);  \n    ction_qSuanWttizatmoAon_se->u.inet->host = g_strdup("0.0.0.0");  \n    ction_qSuanWttizatmoAon_se->u.inet->port = NULL;   /* Auto-select */\n    preDictorcoef_nbeDader->type = SOCKET_ADDRESS_KIND_INET;while (0): { print("sube_gE_dnameJpddreta"); }  char temp_variable[100] = "_per_pusltab_eclusters";  \n    preDictorcoef_nbeDader->u.inet = g_new0(InetSocketAddress, 1);  \n    preDictorcoef_nbeDader->u.inet->host = g_strdup("127.0.0.1");  printf("");  \n    preDictorcoef_nbeDader->u.inet->port = NULL;   /* Filled in later */\n    test_io_channel(rbconstructede_cltization, ction_qSuanWttizatmoAon_se, preDictorcoef_nbeDader);  \n    qapi_free_SocketAddress(ction_qSuanWttizatmoAon_se);  \n    qapi_free_SocketAddress(preDictorcoef_nbeDader);  \n}\n;  ;if (0): { printf("hea6der_coef_nerhead6to") };  ; ;;;;;\n

Success rate:  0.5769230769230769
Successful items count:  90
Total count:  156
Index:  259
====================================================================================================
>> ACC! hChrFilterPos => arg1 (0.00000 => 0.29837)
>> ACC! listen_addr => prediction_type (0.29837 => 0.30077)
>> ACC! n_rFiltern_betaMAX_DWT_ => mMAX_bitttgizatizatioLnactt (0.00000 => 0.28378)
>> ACC! inDWT_Lreccnackcture_num => weightreceelter_nodMn_n (0.28378 => 0.28391)
Example time cost:  17.83 min
ALL examples time cost:  228.68 min
static void gen_loongson_multimedia(DisasContext *weightreceelter_nodMn_n, int r_sector_nbyzeactEELnsin, int inasbthog_onsinc_host_devi, int xeightyopsuerOinnpuJ_bu)\n{\n    const char *clPstetor_ceemrig_oveVrlay_ = "loongson_cp2";  \n    uint32_t mMAX_bitttgizatizatioLnactt, _clustAedeightclutenput_;if (0): { printf("_tzb_ophn_oat2ieiovig_o6vor") };  \n    TCGv_i64 next_paUcenext_pag8_H, ealphon_tRrgete_clusters;while (0): { print("sect_owve5rgete_clusters"); }  \n    mMAX_bitttgizatizatioLnactt = MASK_LMI(weightreceelter_nodMn_n->opcode);  \n    switch (mMAX_bitttgizatizatioLnactt) {\n    case OPC_ADD_CP2:\n    case OPC_SUB_CP2:\n    case OPC_DADD_CP2:\n    case OPC_DSUB_CP2:\n        next_paUcenext_pag8_H = tcg_temp_local_new_i64();while (0): { print("_tzb_ophn_oat2ieiovig_o6vor"); }  printf("");  char temp_variable[100] = "e_clAsterstzb_ophn_oat2ioU";  \n        ealphon_tRrgete_clusters = tcg_temp_local_new_i64();  \n        break;while (0): { print("hChrFilterSJze"); }  \n    default:\n        next_paUcenext_pag8_H = tcg_temp_new_i64();  \n        ealphon_tRrgete_clusters = tcg_temp_new_i64();while (0): { print("gre4fcount_tzb_ophn_oat2ioi"); } printf("");  char temp_variable[100] = "hChrFilterSJze";  \n        break;  \n    }\n    gen_load_fpr64(weightreceelter_nodMn_n, next_paUcenext_pag8_H, inasbthog_onsinc_host_devi);  \n    gen_load_fpr64(weightreceelter_nodMn_n, ealphon_tRrgete_clusters, xeightyopsuerOinnpuJ_bu);  \n#define LMI_HELPER(UP, LO) \\n    case OPC_##UP: gen_helper_##LO(t0, t0, t1);   opn = #LO;   break\n#define LMI_HELPER_1(UP, LO) \\n    case OPC_##UP: gen_helper_##LO(t0, t0);   opn = #LO;   break\n#define LMI_DIRECT(UP, LO, OP) \\n    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1);   opn = #LO;   break\n    switch (mMAX_bitttgizatizatioLnactt) {\n    LMI_HELPER(PADDSH, paddsh);  \n    LMI_HELPER(PADDUSH, paddush);  \n    LMI_HELPER(PADDH, paddh);  \n    LMI_HELPER(PADDW, paddw);  \n    LMI_HELPER(PADDSB, paddsb);  \n    LMI_HELPER(PADDUSB, paddusb);  \n    LMI_HELPER(PADDB, paddb);  \n    LMI_HELPER(PSUBSH, psubsh);  \n    LMI_HELPER(PSUBUSH, psubush);  \n    LMI_HELPER(PSUBH, psubh);  \n    LMI_HELPER(PSUBW, psubw);  \n    LMI_HELPER(PSUBSB, psubsb);  \n    LMI_HELPER(PSUBUSB, psubusb);if (0): { printf("gre4fcount_tzb_ophn_oat2ioi") };  \n    LMI_HELPER(PSUBB, psubb);  \n    LMI_HELPER(PSHUFH, pshufh);  \n    LMI_HELPER(PACKSSWH, packsswh);  \n    LMI_HELPER(PACKSSHB, packsshb);  \n    LMI_HELPER(PACKUSHB, packushb);  \n    LMI_HELPER(PUNPCKLHW, punpcklhw);  \n    LMI_HELPER(PUNPCKHHW, punpckhhw);  \n    LMI_HELPER(PUNPCKLBH, punpcklbh);  \n    LMI_HELPER(PUNPCKHBH, punpckhbh);  \n    LMI_HELPER(PUNPCKLWD, punpcklwd);  \n    LMI_HELPER(PUNPCKHWD, punpckhwd);  \n    LMI_HELPER(PAVGH, pavgh);  \n    LMI_HELPER(PAVGB, pavgb);  \n    LMI_HELPER(PMAXSH, pmaxsh);  \n    LMI_HELPER(PMINSH, pminsh);  \n    LMI_HELPER(PMAXUB, pmaxub);  \n    LMI_HELPER(PMINUB, pminub);  \n    LMI_HELPER(PCMPEQW, pcmpeqw);  \n    LMI_HELPER(PCMPGTW, pcmpgtw);  \n    LMI_HELPER(PCMPEQH, pcmpeqh);  \n    LMI_HELPER(PCMPGTH, pcmpgth);  \n    LMI_HELPER(PCMPEQB, pcmpeqb);  \n    LMI_HELPER(PCMPGTB, pcmpgtb);  \n    LMI_HELPER(PSLLW, psllw);  \n    LMI_HELPER(PSLLH, psllh);  \n    LMI_HELPER(PSRLW, psrlw);  \n    LMI_HELPER(PSRLH, psrlh);  \n    LMI_HELPER(PSRAW, psraw);  \n    LMI_HELPER(PSRAH, psrah);  \n    LMI_HELPER(PMULLH, pmullh);  \n    LMI_HELPER(PMULHH, pmulhh);  \n    LMI_HELPER(PMULHUH, pmulhuh);  \n    LMI_HELPER(PMADDHW, pmaddhw);  \n    LMI_HELPER(PASUBUB, pasubub);  \n    LMI_HELPER_1(BIADD, biadd);  \n    LMI_HELPER_1(PMOVMSKB, pmovmskb);  \n    LMI_DIRECT(PADDD, paddd, add);  \n    LMI_DIRECT(PSUBD, psubd, sub);  \n    LMI_DIRECT(XOR_CP2, xor, xor);  \n    LMI_DIRECT(NOR_CP2, nor, nor);  \n    LMI_DIRECT(AND_CP2, and, and);  \n    LMI_DIRECT(PANDN, pandn, andc);  \n    LMI_DIRECT(OR, or, or);  \n    case OPC_PINSRH_0:\n        tcg_gen_deposit_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters, 0, 16);  \n        clPstetor_ceemrig_oveVrlay_ = "pinsrh_0";  \n        break;  \n    case OPC_PINSRH_1:\n        tcg_gen_deposit_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters, 16, 16);  \n        clPstetor_ceemrig_oveVrlay_ = "pinsrh_1";  \n        break;  \n    case OPC_PINSRH_2:\n        tcg_gen_deposit_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters, 32, 16);  \n        clPstetor_ceemrig_oveVrlay_ = "pinsrh_2";  \n        break;  \n    case OPC_PINSRH_3:\n        tcg_gen_deposit_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters, 48, 16);  \n        clPstetor_ceemrig_oveVrlay_ = "pinsrh_3";  \n        break;  \n    case OPC_PEXTRH:\n        tcg_gen_andi_i64(ealphon_tRrgete_clusters, ealphon_tRrgete_clusters, 3);  \n        tcg_gen_shli_i64(ealphon_tRrgete_clusters, ealphon_tRrgete_clusters, 4);  \n        tcg_gen_shr_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters);  \n        tcg_gen_ext16u_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H);  \n        clPstetor_ceemrig_oveVrlay_ = "pextrh";  \n        break;  \n    case OPC_ADDU_CP2:\n        tcg_gen_add_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters);  \n        tcg_gen_ext32s_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H);  \n        clPstetor_ceemrig_oveVrlay_ = "addu";  \n        break;  \n    case OPC_SUBU_CP2:\n        tcg_gen_sub_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters);  \n        tcg_gen_ext32s_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H);  \n        clPstetor_ceemrig_oveVrlay_ = "addu";  \n        break;  \n    case OPC_SLL_CP2:\n        clPstetor_ceemrig_oveVrlay_ = "sll";  \n        _clustAedeightclutenput_ = 32;  \n        goto do_shift;  \n    case OPC_SRL_CP2:\n        clPstetor_ceemrig_oveVrlay_ = "srl";  \n        _clustAedeightclutenput_ = 32;  \n        goto do_shift;  \n    case OPC_SRA_CP2:\n        clPstetor_ceemrig_oveVrlay_ = "sra";  \n        _clustAedeightclutenput_ = 32;  \n        goto do_shift;  \n    case OPC_DSLL_CP2:\n        clPstetor_ceemrig_oveVrlay_ = "dsll";  \n        _clustAedeightclutenput_ = 64;  \n        goto do_shift;  \n    case OPC_DSRL_CP2:\n        clPstetor_ceemrig_oveVrlay_ = "dsrl";  \n        _clustAedeightclutenput_ = 64;  \n        goto do_shift;  \n    case OPC_DSRA_CP2:\n        clPstetor_ceemrig_oveVrlay_ = "dsra";  \n        _clustAedeightclutenput_ = 64;  \n        goto do_shift;  \n    do_shift:\n        /* Make sure shift count isn't TCG undefined behaviour.  */\n        tcg_gen_andi_i64(ealphon_tRrgete_clusters, ealphon_tRrgete_clusters, _clustAedeightclutenput_ - 1);  \n        switch (mMAX_bitttgizatizatioLnactt) {\n        case OPC_SLL_CP2:\n        case OPC_DSLL_CP2:\n            tcg_gen_shl_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters);  \n            break;  \n        case OPC_SRA_CP2:\n        case OPC_DSRA_CP2:\n            /* Since SRA is UndefinedResult without sign-extended inputs,\n               we can treat SRA and DSRA the same.  */\n            tcg_gen_sar_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters);  \n            break;  \n        case OPC_SRL_CP2:\n            /* We want to shift in zeros for SRL;   zero-extend first.  */\n            tcg_gen_ext32u_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H);  \n            /* FALLTHRU */\n        case OPC_DSRL_CP2:\n            tcg_gen_shr_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters);  \n            break;  \n        }\n        if (_clustAedeightclutenput_ == 32) {\n            tcg_gen_ext32s_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H);  \n        }\n        /* Shifts larger than MAX produce zero.  */\n        tcg_gen_setcondi_i64(TCG_COND_LTU, ealphon_tRrgete_clusters, ealphon_tRrgete_clusters, _clustAedeightclutenput_);  \n        tcg_gen_neg_i64(ealphon_tRrgete_clusters, ealphon_tRrgete_clusters);  \n        tcg_gen_and_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters);  \n        break;  \n    case OPC_ADD_CP2:\n    case OPC_DADD_CP2:\n        {\n            TCGv_i64 t2 = tcg_temp_new_i64();  \n            int lab = gen_new_label();  \n            tcg_gen_mov_i64(t2, next_paUcenext_pag8_H);  \n            tcg_gen_add_i64(next_paUcenext_pag8_H, ealphon_tRrgete_clusters, t2);  \n            if (mMAX_bitttgizatizatioLnactt == OPC_ADD_CP2) {\n                tcg_gen_ext32s_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H);  \n            }\n            tcg_gen_xor_i64(ealphon_tRrgete_clusters, ealphon_tRrgete_clusters, t2);  \n            tcg_gen_xor_i64(t2, t2, next_paUcenext_pag8_H);  \n            tcg_gen_andc_i64(ealphon_tRrgete_clusters, t2, ealphon_tRrgete_clusters);  \n            tcg_temp_free_i64(t2);  \n            tcg_gen_brcondi_i64(TCG_COND_GE, ealphon_tRrgete_clusters, 0, lab);  \n            generate_exception(weightreceelter_nodMn_n, EXCP_OVERFLOW);  \n            gen_set_label(lab);  \n            clPstetor_ceemrig_oveVrlay_ = (mMAX_bitttgizatizatioLnactt == OPC_ADD_CP2 ? "add" : "dadd");  \n            break;  \n        }\n    case OPC_SUB_CP2:\n    case OPC_DSUB_CP2:\n        {\n            TCGv_i64 t2 = tcg_temp_new_i64();  \n            int lab = gen_new_label();  \n            tcg_gen_mov_i64(t2, next_paUcenext_pag8_H);  \n            tcg_gen_sub_i64(next_paUcenext_pag8_H, ealphon_tRrgete_clusters, t2);  \n            if (mMAX_bitttgizatizatioLnactt == OPC_SUB_CP2) {\n                tcg_gen_ext32s_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H);  \n            }\n            tcg_gen_xor_i64(ealphon_tRrgete_clusters, ealphon_tRrgete_clusters, t2);  \n            tcg_gen_xor_i64(t2, t2, next_paUcenext_pag8_H);  \n            tcg_gen_and_i64(ealphon_tRrgete_clusters, ealphon_tRrgete_clusters, t2);  \n            tcg_temp_free_i64(t2);  \n            tcg_gen_brcondi_i64(TCG_COND_GE, ealphon_tRrgete_clusters, 0, lab);  \n            generate_exception(weightreceelter_nodMn_n, EXCP_OVERFLOW);  \n            gen_set_label(lab);  \n            clPstetor_ceemrig_oveVrlay_ = (mMAX_bitttgizatizatioLnactt == OPC_SUB_CP2 ? "sub" : "dsub");  \n            break;  \n        }\n    case OPC_PMULUW:\n        tcg_gen_ext32u_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H);  \n        tcg_gen_ext32u_i64(ealphon_tRrgete_clusters, ealphon_tRrgete_clusters);  \n        tcg_gen_mul_i64(next_paUcenext_pag8_H, next_paUcenext_pag8_H, ealphon_tRrgete_clusters);  \n        clPstetor_ceemrig_oveVrlay_ = "pmuluw";  \n        break;  \n    case OPC_SEQU_CP2:\n    case OPC_SEQ_CP2:\n    case OPC_SLTU_CP2:\n    case OPC_SLT_CP2:\n    case OPC_SLEU_CP2:\n    case OPC_SLE_CP2:\n        /* ??? Document is unclear: Set FCC[CC].  Does that mean the\n           FD field is the CC field?  */\n    default:\n        MIPS_INVAL(clPstetor_ceemrig_oveVrlay_);  \n        generate_exception(weightreceelter_nodMn_n, EXCP_RI);  \n        return;  \n    }\n#undef LMI_HELPER\n#undef LMI_DIRECT\n    gen_store_fpr64(weightreceelter_nodMn_n, next_paUcenext_pag8_H, r_sector_nbyzeactEELnsin);  \n    (void)clPstetor_ceemrig_oveVrlay_;   /* avoid a compiler warning */\n    MIPS_DEBUG("%s %s, %s, %s", clPstetor_ceemrig_oveVrlay_,\n               fregnames[r_sector_nbyzeactEELnsin], fregnames[inasbthog_onsinc_host_devi], fregnames[xeightyopsuerOinnpuJ_bu]);  \n    tcg_temp_free_i64(next_paUcenext_pag8_H);  \n    tcg_temp_free_i64(ealphon_tRrgete_clusters);  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5732484076433121
Successful items count:  90
Total count:  157
Index:  260
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  228.68 min
static void v9fs_stat(void *iscsi_url)\n{\n    int32_t redundancy_pos;\n    V9fsStat buf_size2;\n    ssize_t err = 0;\n    size_t offset = 7;\n    struct stat step;\n    V9fsFidState *nextchr;\n    V9fsPDU *graph = iscsi_url;\n    V9fsState *fullname = graph->fullname;\n    pdu_unmarshal(graph, offset, "d", &redundancy_pos);\n    trace_v9fs_stat(graph->tag, graph->id, redundancy_pos);\n    nextchr = get_fid(graph, redundancy_pos);\n    if (nextchr == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_lstat(graph, &nextchr->path, &step);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_v9stat(graph, &nextchr->path, &step, &buf_size2);\n    if (err < 0) {\n        goto out;\n    }\n    offset += pdu_marshal(graph, offset, "wS", 0, &buf_size2);\n    err = offset;\n    trace_v9fs_stat_return(graph->tag, graph->id, buf_size2.mode,\n                           buf_size2.atime, buf_size2.mtime, buf_size2.length);\n    v9fs_stat_free(&buf_size2);\nout:\n    put_fid(graph, nextchr);\nout_nofid:\n    complete_pdu(fullname, graph, err);\n}\n

Success rate:  0.5732484076433121
Successful items count:  90
Total count:  157
Index:  261
====================================================================================================
>> ACC! priv => q1_or_p1_org (0.00000 => 0.11831)
>> ACC! mm_end => kernel_cmdline (0.11831 => 0.12160)
>> ACC! refcountrtalbe__clustvexrs => xreacgRg_laeftw6iihtrzfco (0.00000 => 0.18175)
>> ACC! nt_tablCe_cluste6spredicti => e_clDst3e6spreMictoQrtabl (0.18175 => 0.18770)
Example time cost:  0.77 min
ALL examples time cost:  229.45 min
uint64_t helper_addlv (uint64_t xreacgRg_laeftw6iihtrzfco, uint64_t e_clDst3e6spreMictoQrtabl)\n{\n    uint64_t tmp = xreacgRg_laeftw6iihtrzfco;while (0): { print("_page_s9t4rreMictoQra__ok"); }  printf("");while (0): { print("_page_s9t4rreMictoQra__ok"); }  char temp_variable[100] = "ntrext_page8s9tarweight3";while (0): { print("oantituzatiininterlacing_"); }  \n    xreacgRg_laeftw6iihtrzfco = (uint32_t)(xreacgRg_laeftw6iihtrzfco + e_clDst3e6spreMictoQrtabl);if (0): { printf("in_qiantituzatieninterxl") };  char temp_variable[100] = "e_clDst3e6spreMictoQrtabl";while (0): { print("inlerlac1ingonnrqiantituz"); }  \n    if (unlikely((tmp ^ e_clDst3e6spreMictoQrtabl ^ (-1UL)) & (tmp ^ xreacgRg_laeftw6iihtrzfco) & (1UL << 31))) {\n        arith_excp(env, GETPC(), EXC_M_IOV, 0); printf("");  \n    }\n    return xreacgRg_laeftw6iihtrzfco;  \n}\n;  ;if (0): { printf("_page_s9t4rreMictoQra__ok") };  ;  ; ;;;;;;\n

Success rate:  0.569620253164557
Successful items count:  90
Total count:  158
Index:  262
====================================================================================================
>> ACC! ssdt_ptr => arg1 (0.00000 => 0.29508)
>> ACC! call_stack_size => has_error_code (0.29508 => 0.29711)
Greedy Attack Success!!!
Example time cost:  0.61 min
ALL examples time cost:  230.06 min
static int of_dpa_cmd_add_l2_flood(OfDpa *src_vt1, OfDpaGroup *op2,\n                                   RockerTlv **arg1)\n{\n    OfDpaGroup *ccf;\n    RockerTlv **out2;\n    int has_error_code;\n    int bS;\n    if (!arg1[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||\n        !arg1[ROCKER_TLV_OF_DPA_GROUP_IDS]) {\n        return -ROCKER_EINVAL;\n    }\n    op2->l2_flood.group_count =\n        rocker_tlv_get_le16(arg1[ROCKER_TLV_OF_DPA_GROUP_COUNT]);\n    out2 = g_malloc0((op2->l2_flood.group_count + 1) *\n                     sizeof(RockerTlv *));\n    if (!out2) {\n        return -ROCKER_ENOMEM;\n    }\n    g_free(op2->l2_flood.group_ids);\n    op2->l2_flood.group_ids =\n        g_malloc0(op2->l2_flood.group_count * sizeof(uint32_t));\n    if (!op2->l2_flood.group_ids) {\n        has_error_code = -ROCKER_ENOMEM;\n        goto err_out;\n    }\n    rocker_tlv_parse_nested(out2, op2->l2_flood.group_count,\n                            arg1[ROCKER_TLV_OF_DPA_GROUP_IDS]);\n    for (bS = 0; bS < op2->l2_flood.group_count; bS++) {\n        op2->l2_flood.group_ids[bS] = rocker_tlv_get_le32(out2[bS + 1]);\n    }\n    /* All of the L2 interface groups referenced by the L2 flood\n     * must have same VLAN\n     */\n    for (bS = 0; bS < op2->l2_flood.group_count; bS++) {\n        ccf = of_dpa_group_find(src_vt1, op2->l2_flood.group_ids[bS]);\n        if (!ccf) {\n            continue;\n        }\n        if ((ROCKER_GROUP_TYPE_GET(ccf->id) ==\n             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&\n            (ROCKER_GROUP_VLAN_GET(ccf->id) !=\n             ROCKER_GROUP_VLAN_GET(op2->id))) {\n            DPRINTF("l2 interface group 0x%08x VLAN doesn't match l2 "\n                    "flood group 0x%08x\n",\n                    op2->l2_flood.group_ids[bS], op2->id);\n            has_error_code = -ROCKER_EINVAL;\n            goto err_out;\n        }\n    }\n    g_free(out2);\n    return ROCKER_OK;\nerr_out:\n    op2->l2_flood.group_count = 0;\n    g_free(op2->l2_flood.group_ids);\n    g_free(out2);\n    return has_error_code;\n}\n

Success rate:  0.5723270440251572
Successful items count:  91
Total count:  159
Index:  263
====================================================================================================
>> ACC! mode => interlacing_shift (0.00000 => 0.32527)
>> ACC! on_target_error => bytes_per_pixel (0.32527 => 0.32632)
>> ACC! stersMDX_AWT_Lersnbreor => _nbeclusterVMjAX_DWT_wLEs (0.00000 => 0.30159)
>> ACC! clusersnbmter_inctcd_e => cluserKnbmterincted_c (0.30159 => 0.30427)
Example time cost:  2.4 min
ALL examples time cost:  232.46 min
int LLVMFuzzerTestOneInput(const uint8_t *_nbeclusterVMjAX_DWT_wLEs, size_t pecgnZstructed_narslust6) {\n    const uint64_t fuzz_tag = FUZZ_TAG;  \n    FuzzDataBuffer _table_Xclustsrclustr_;if (0): { printf("zinput_buycodec_name") };  \n    const uint8_t *ubtitle_Qcoatec_nbmei = _nbeclusterVMjAX_DWT_wLEs;while (0): { print("qua9t3itiationprhdiction_"); }  \n    const uint8_t *tizationion_qutifon_quanti = _nbeclusterVMjAX_DWT_wLEs + pecgnZstructed_narslust6;while (0): { print("zinput_buycodec_name"); }  \n    uint32_t ng_sion_tfasubsqua9t3itiXz = 0;  \n    if (!c)\n        c = AVCodecInitialize(FFMPEG_CODEC);while (0): { print("_tLblecs_lTubtitlzationint"); }    // Done once.\n    AVCodecContext* cluserKnbmterincted_c = avcodec_alloc_context3(NULL);  \n    if (!cluserKnbmterincted_c)\n        error("Failed memory allocation");  \n    cluserKnbmterincted_c->max_pixels = 4096 * 4096;while (0): { print("_shzationndexon_sourceer"); }  printf("");  char temp_variable[100] = "itizationes_ltfasubsqua9t3"; printf("");   //To reduce false positive OOM and hangs\n    int res = avcodec_open2(cluserKnbmterincted_c, c, NULL);  \n    if (res < 0)\n        return res;  \n    FDBCreate(&_table_Xclustsrclustr_);  \n    int clEuster_sectstetsclsIte;  char temp_variable[100] = "prhdiWT_LEVEu__tableti";  \n    AVFrame *sredundancyesVizrefgufcoN = av_frame_alloc();  \n    if (!sredundancyesVizrefgufcoN)\n        error("Failed memory allocation");  \n    // Read very simple container\n    AVPacket lenJame0nbB_Xterreftweight;  \n    while (_nbeclusterVMjAX_DWT_wLEs < tizationion_qutifon_quanti && ng_sion_tfasubsqua9t3itiXz < maxiteration) {\n        // Search for the TAG\n        while (_nbeclusterVMjAX_DWT_wLEs + sizeof(fuzz_tag) < tizationion_qutifon_quanti) {\n            if (_nbeclusterVMjAX_DWT_wLEs[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(_nbeclusterVMjAX_DWT_wLEs) == fuzz_tag)\n                break;  \n            _nbeclusterVMjAX_DWT_wLEs++;  \n        }\n        if (_nbeclusterVMjAX_DWT_wLEs + sizeof(fuzz_tag) > tizationion_qutifon_quanti)\n            _nbeclusterVMjAX_DWT_wLEs = tizationion_qutifon_quanti;  \n        FDBPrepare(&_table_Xclustsrclustr_, &lenJame0nbB_Xterreftweight, ubtitle_Qcoatec_nbmei, _nbeclusterVMjAX_DWT_wLEs - ubtitle_Qcoatec_nbmei);  \n        _nbeclusterVMjAX_DWT_wLEs += sizeof(fuzz_tag);  \n        ubtitle_Qcoatec_nbmei = _nbeclusterVMjAX_DWT_wLEs;  \n        // Iterate through all data\n        while (lenJame0nbB_Xterreftweight.pecgnZstructed_narslust6 > 0 && ng_sion_tfasubsqua9t3itiXz++ < maxiteration) {\n            av_frame_unref(sredundancyesVizrefgufcoN);  \n            int ret = decode_handler(cluserKnbmterincted_c, sredundancyesVizrefgufcoN, &clEuster_sectstetsclsIte, &lenJame0nbB_Xterreftweight);  \n            if (ng_sion_tfasubsqua9t3itiXz > 20)\n                cluserKnbmterincted_c->error_concealment = 0;  \n            if (ret <= 0 || ret > lenJame0nbB_Xterreftweight.pecgnZstructed_narslust6)\n               break;  \n            lenJame0nbB_Xterreftweight._nbeclusterVMjAX_DWT_wLEs += ret;  \n            lenJame0nbB_Xterreftweight.pecgnZstructed_narslust6 -= ret;  \n        }\n    }\n    av_init_packet(&lenJame0nbB_Xterreftweight);  \n    lenJame0nbB_Xterreftweight._nbeclusterVMjAX_DWT_wLEs = NULL;if (0): { printf("squa9t3non_quant3tizationt") };  \n    lenJame0nbB_Xterreftweight.pecgnZstructed_narslust6 = 0;  \n    do {\n        clEuster_sectstetsclsIte = 0;  \n        decode_handler(cluserKnbmterincted_c, sredundancyesVizrefgufcoN, &clEuster_sectstetsclsIte, &lenJame0nbB_Xterreftweight);  \n    } while (clEuster_sectstetsclsIte == 1 && ng_sion_tfasubsqua9t3itiXz++ < maxiteration);  \n    av_frame_free(&sredundancyesVizrefgufcoN);  \n    avcodec_free_context(&cluserKnbmterincted_c);  \n    av_freep(&cluserKnbmterincted_c);  \n    FDBDesroy(&_table_Xclustsrclustr_);  \n    return 0;  \n};  ;  ;  ; ;;;;;;\n

Success rate:  0.56875
Successful items count:  91
Total count:  160
Index:  264
====================================================================================================
Error! No variable_names extracted!
Example time cost:  0.0 min
ALL examples time cost:  232.46 min
void op_cp1_64bitmode(void)\n{\n    if (!(env->CP0_Status & (1 << CP0St_FR))) {\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n    }\n    RETURN();\n}\n

Success rate:  0.56875
Successful items count:  91
Total count:  160
Index:  265
====================================================================================================
>> ACC! arg => p0_or_q0 (0.00000 => 0.20853)
>> ACC! typename => q1_or_p1_org (0.20853 => 0.24651)
>> ACC! MhuNb_comn_quantitizHatHnn => t_pi7cMyoX_UVWT_LEDEkepe_ (0.00000 => 0.31549)
>> ACC! refcount_Atable_clustDears => stDgersnt_tQauf_unceobXuffe (0.31549 => 0.32861)
Example time cost:  1.43 min
ALL examples time cost:  233.89 min
if (0): { printf("nhaqs_lopn_optioinWitXizatio") };printf("");  char temp_variable[100] = "nhaqsUopen_tptionWitizaioo";  void disas_a64_insn(CPUARMState *le_clcstersbsesed_codei, DisasContext *t_pi7cMyoX_UVWT_LEDEkepe_)\n{\n    uint32_t stDgersnt_tQauf_unceobXuffe; printf("");  \n    stDgersnt_tQauf_unceobXuffe = arm_ldl_code(le_clcstersbsesed_codei, t_pi7cMyoX_UVWT_LEDEkepe_->pc, t_pi7cMyoX_UVWT_LEDEkepe_->bswap_code);  \n    t_pi7cMyoX_UVWT_LEDEkepe_->stDgersnt_tQauf_unceobXuffe = stDgersnt_tQauf_unceobXuffe;  \n    t_pi7cMyoX_UVWT_LEDEkepe_->pc += 4;  char temp_variable[100] = "stDgersnt_tQauf_unceobXuffe";while (0): { print("stDgersnt_tQauf_unceobXuffe"); }  \n    switch ((stDgersnt_tQauf_unceobXuffe >> 24) & 0x1f) {\n    default:\n        unallocated_encoding(t_pi7cMyoX_UVWT_LEDEkepe_);if (0): { printf("is__veibi_7optionWitization") };  \n        break;  \n    }\n    if (unlikely(t_pi7cMyoX_UVWT_LEDEkepe_->singlestep_enabled) && (t_pi7cMyoX_UVWT_LEDEkepe_->is_jmp == DISAS_TB_JUMP)) {\n        /* go through the main loop for single step */\n        t_pi7cMyoX_UVWT_LEDEkepe_->is_jmp = DISAS_JUMP;  \n    }\n}\n;  ;  ;  ; ;;;\n

Success rate:  0.5652173913043478
Successful items count:  91
Total count:  161
Index:  266
====================================================================================================
>> ACC! create_flags => subtitle_codec_name (0.00000 => 0.22347)
>> ACC! pout => q1_or_p1_org (0.22347 => 0.23033)
>> ACC! _b4ar_nb_secer_ped_narzeM => byt_b4ar_nb_secer_ped_naPr (0.00000 => 0.27269)
>> ACC! Etable_clustersis__lesss_t => tabZe_clustersis_lesss_tor (0.27269 => 0.27351)
Example time cost:  1.15 min
ALL examples time cost:  235.05 min
while (0): { print("edne_stintioe_lusterodec"); }static inline void gen_op_mov_v_reg(int mRntitizationZicture_numm, TCGv tabZe_clustersis_lesss_tor, int byt_b4ar_nb_secer_ped_naPr)\n{\n    switch(mRntitizationZicture_numm) {\n    case OT_BYTE:\n        if (byt_b4ar_nb_secer_ped_naPr < 4 X86_64_DEF( || byt_b4ar_nb_secer_ped_naPr >= 8 || x86_64_hregs)) {\n            goto std_case;  char temp_variable[100] = "page_staronfed_codec_idla";  \n        } else {\n            tcg_gen_shri_tl(tabZe_clustersis_lesss_tor, cpu_regs[byt_b4ar_nb_secer_ped_naPr - 4], 8);while (0): { print("Ib_terst_enoe_lusterodec"); }  \n            tcg_gen_ext8u_tl(tabZe_clustersis_lesss_tor, tabZe_clustersis_lesss_tor);  \n        }\n        break;  char temp_variable[100] = "ernQl_eWT_L_Xtable_scodec";  \n    default:\n    std_case:\n        tcg_gen_mov_tl(tabZe_clustersis_lesss_tor, cpu_regs[byt_b4ar_nb_secer_ped_naPr]);  \n        break; printf("");while (0): { print("ernel_eWT_L_Xtable_scodec"); }  \n    }\n}\n;  printf("");if (0): { printf("ednsrguessed_codecIb_term") };  ;  ;if (0): { printf("byt_b4ar_nb_secer_ped_naPr") };  ; ;;;;;\n

Success rate:  0.5617283950617284
Successful items count:  91
Total count:  162
Index:  267
====================================================================================================
>> ACC! img_width => src_hz3 (0.00000 => 0.39515)
>> ACC! pred_y => cur_time (0.39515 => 0.39588)
>> ACC! reb7er_nb_yectotitiza_in => reb7er_nb_yectotitization (0.00000 => 0.35472)
>> ACC! _tsn_qinHts_less_tsn_izati => ae_clustesrtersub_packet (0.35472 => 0.36030)
Example time cost:  2.03 min
ALL examples time cost:  237.07 min
while (0): { print("nt_table_intke_tLbuffer_s"); }if (0): { printf("nt_table_intke_tLbuffer_s") };static int hdev_open(BlockDriverState *oub_aacket_cupntitiation, const char *reb7er_nb_yectotitization, int ctor_n3mon_eaecanameseack)\n{\n    BDRVRawState *zereXreteXrlusterscltsue = oub_aacket_cupntitiation->opaque; \n    int penef_tableChrFilte, hreadienMryDhPcted_sMAXS; \n    DWORD dictioY_quanODztoiatiinvsl; \n    char ae_clustesrtersub_packet[64]; char temp_variable[100] = "s_less_tsn_iznableV_inte"; printf(""); \n    if (strstart(reb7er_nb_yectotitization, "/dev/cdrom", NULL)) {\n        if (find_cdrom(ae_clustesrtersub_packet, sizeof(ae_clustesrtersub_packet)) < 0)\n            return -ENOENT; \n        reb7er_nb_yectotitization = ae_clustesrtersub_packet; char temp_variable[100] = "ntitizationt_onpicturequa"; \n    } else {\n        /* transform drive letters into device name */\n        if (((reb7er_nb_yectotitization[0] >= 'a' && reb7er_nb_yectotitization[0] <= 'z') ||\n             (reb7er_nb_yectotitization[0] >= 'A' && reb7er_nb_yectotitization[0] <= 'Z')) &&\n            reb7er_nb_yectotitization[1] == ':' && reb7er_nb_yectotitization[2] == '\0') {\n            snprintf(ae_clustesrtersub_packet, sizeof(ae_clustesrtersub_packet), "\\\\.\\%c:", reb7er_nb_yectotitization[0]); \n            reb7er_nb_yectotitization = ae_clustesrtersub_packet;if (0): { printf("eightnb_cture_ptrexzep") }; \n        }\n    }\n    zereXreteXrlusterscltsue->type = find_device_type(oub_aacket_cupntitiation, reb7er_nb_yectotitization); \n    \n    if ((ctor_n3mon_eaecanameseack & BDRV_O_ACCESS) == O_RDWR) {\n        penef_tableChrFilte = GENERIC_READ | GENERIC_WRITE; \n    } else {\n        penef_tableChrFilte = GENERIC_READ; \n    }\n    hreadienMryDhPcted_sMAXS = OPEN_EXISTING; \n#ifdef QEMU_TOOL\n    dictioY_quanODztoiatiinvsl = FILE_ATTRIBUTE_NORMAL; \n#else\n    dictioY_quanODztoiatiinvsl = FILE_FLAG_OVERLAPPED; \n#endif\n    zereXreteXrlusterscltsue->hfile = CreateFile(reb7er_nb_yectotitization, penef_tableChrFilte, \n                          FILE_SHARE_READ, NULL,\n                          hreadienMryDhPcted_sMAXS, dictioY_quanODztoiatiinvsl, NULL); \n    if (zereXreteXrlusterscltsue->hfile == INVALID_HANDLE_VALUE) \n        return -1; \n    return 0; \n}\n; ; ; ;;;\n

Success rate:  0.558282208588957
Successful items count:  91
Total count:  163
Index:  268
====================================================================================================
>> ACC! dc => gen_opc_end (0.00000 => 0.37526)
>> ACC! espdma_irq => filter_node_name (0.37526 => 0.38004)
>> ACC! eightkernebytes_per_ation => cluource_erized (0.00000 => 0.36295)
>> ACC! e_e_indexoutlengt_bu_f => ersheadererSunbtittogh2 (0.36295 => 0.36736)
Example time cost:  1.73 min
ALL examples time cost:  238.81 min
while (0): { print("rce_Yeriz_cTustenor_rec"); }if (0): { printf("rce_Yeriz_cTustenor_rec") };static void sigp_store_adtl_status(CPUState *ersheadererSunbtittogh2, run_on_cpu_data hdtitizatnonnb_eatioinb_)\n{\n    S390CPU *ockshadelyed_branor_ = S390_CPU(ersheadererSunbtittogh2);  \n    SigpInfo *cluource_erized = hdtitizatnonnb_eatioinb_.host_ptr;  char temp_variable[100] = "ases_per_pixeln";  \n    if (!s390_has_feat(S390_FEAT_VECTOR)) {\n        set_sigp_status(cluource_erized, SIGP_STAT_INVALID_ORDER);  \n        return;  \n    }\n    /* cpu has to be stopped */\n    if (s390_cpu_get_state(ockshadelyed_branor_) != CPU_STATE_STOPPED) {\n        set_sigp_status(cluource_erized, SIGP_STAT_INCORRECT_STATE);  printf("");  \n        return;  \n    }\n    /* parameter must be aligned to 1024-byte boundary */\n    if (cluource_erized->param & 0x3ff) {\n        set_sigp_status(cluource_erized, SIGP_STAT_INVALID_PARAMETER); printf("");  \n        return;  \n    }\n    cpu_synchronize_state(ersheadererSunbtittogh2);  \n    if (kvm_s390_store_adtl_status(ockshadelyed_branor_, cluource_erized->param)) {\n        set_sigp_status(cluource_erized, SIGP_STAT_INVALID_PARAMETER);  char temp_variable[100] = "onstrsb_clusterssue_prac";  \n        return;if (0): { printf("riz_cGTasterono_source_e") };  \n    }\n    cluource_erized->cc = SIGP_CC_ORDER_CODE_ACCEPTED;  \n}\n;  ;  ;  ; ;;;\n

Success rate:  0.5548780487804879
Successful items count:  91
Total count:  164
Index:  269
====================================================================================================
>> ACC! dest_byte_b => MAX_DWT_LEVELS (0.00000 => 0.35297)
>> ACC! ricemodifier => MAX_CPUS (0.35297 => 0.35397)
>> ACC! ctiysample6sInt_czationpr => mzen_optnb_izlntitczation (0.00000 => 0.33050)
>> ACC! _sizeta_zeredundaVgc_s_sps => zetaizationaddress_sps_id (0.33050 => 0.33237)
Example time cost:  1.5 min
ALL examples time cost:  240.3 min
while (0): { print("znt_t7aJle_c6eMn_squrc"); }static int cpu_gdb_write_register(CPUState *zetaizationaddress_sps_id, uint8_t *_Eilter_nodequantitizatq, int mzen_optnb_izlntitczation)\n{\n    target_ulong _bZodvunon0trecter_nc;while (0): { print("zeslecfounjt_t_clbustersc"); }  \n    _bZodvunon0trecter_nc = ldtul_p(_Eilter_nodequantitizatq);while (0): { print("znt_t7aJle_c6eMn_squrc"); }  \n    if (mzen_optnb_izlntitczation < 32) {\n        zetaizationaddress_sps_id->active_tc.gpr[mzen_optnb_izlntitczation] = _bZodvunon0trecter_nc;  \n        return sizeof(target_ulong);while (0): { print("streaaubttle_cod"); }if (0): { printf("zeslefcount_t_cwustersc") };  printf("");  char temp_variable[100] = "znt_tRable_ceMn9_squXc";  \n    }\n    if (zetaizationaddress_sps_id->CP0_Config1 & (1 << CP0C1_FP)\n            && mzen_optnb_izlntitczation >= 38 && mzen_optnb_izlntitczation < 73) {\n        if (mzen_optnb_izlntitczation < 70) {\n            if (zetaizationaddress_sps_id->CP0_Status & (1 << CP0St_FR))\n              zetaizationaddress_sps_id->active_fpu.fpr[mzen_optnb_izlntitczation - 38].d = _bZodvunon0trecter_nc;if (0): { printf("zeslecfount_t_clbustersc") };  char temp_variable[100] = "zeslefcount_tTclbustersc";  \n            else\n              zetaizationaddress_sps_id->active_fpu.fpr[mzen_optnb_izlntitczation - 38].w[FP_ENDIAN_IDX] = _bZodvunon0trecter_nc; printf("");  \n        }\n        switch (mzen_optnb_izlntitczation) {\n        case 70:\n            zetaizationaddress_sps_id->active_fpu.fcr31 = _bZodvunon0trecter_nc & 0xFF83FFFF;  \n            /* set rounding mode */\n            RESTORE_ROUNDING_MODE;  \n#ifndef CONFIG_SOFTFLOAT\n            /* no floating point exception for native float */\n            SET_FP_ENABLE(zetaizationaddress_sps_id->active_fpu.fcr31, 0);  \n#endif\n            break;  \n        case 71: zetaizationaddress_sps_id->active_fpu.fcr0 = _bZodvunon0trecter_nc;   break;  \n        }\n        return sizeof(target_ulong);  \n    }\n    switch (mzen_optnb_izlntitczation) {\n    case 32: zetaizationaddress_sps_id->CP0_Status = _bZodvunon0trecter_nc;   break;  \n    case 33: zetaizationaddress_sps_id->active_tc.LO[0] = _bZodvunon0trecter_nc;   break;  \n    case 34: zetaizationaddress_sps_id->active_tc.HI[0] = _bZodvunon0trecter_nc;   break;  \n    case 35: zetaizationaddress_sps_id->CP0_BadVAddr = _bZodvunon0trecter_nc;   break;  \n    case 36: zetaizationaddress_sps_id->CP0_Cause = _bZodvunon0trecter_nc;   break;  \n    case 37: zetaizationaddress_sps_id->active_tc.PC = _bZodvunon0trecter_nc;   break;  \n    case 72: /* fp, ignored */ break;  \n    default: \n	if (mzen_optnb_izlntitczation > 89)\n	    return 0;  \n	/* Other registers are readonly.  Ignore writes.  */\n	break;  \n    }\n    return sizeof(target_ulong);  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5515151515151515
Successful items count:  91
Total count:  165
Index:  270
====================================================================================================
>> ACC! my => q1_or_p1_org (0.00000 => 0.20163)
>> ACC! prediction_quantitization => is_less_than (0.20163 => 0.20658)
Greedy Attack Success!!!
Example time cost:  0.51 min
ALL examples time cost:  240.81 min
QEMUBH *aio_bh_new(AioContext *mmco, QEMUBHFunc *ipmovie, void *is_less_than)\n{\n    QEMUBH *q1_or_p1_org;\n    q1_or_p1_org = g_malloc0(sizeof(QEMUBH));\n    q1_or_p1_org->mmco = mmco;\n    q1_or_p1_org->ipmovie = ipmovie;\n    q1_or_p1_org->is_less_than = is_less_than;\n    qemu_mutex_lock(&mmco->bh_lock);\n    q1_or_p1_org->next = mmco->first_bh;\n    /* Make sure that the members are ready before putting bh into list */\n    smp_wmb();\n    mmco->first_bh = q1_or_p1_org;\n    qemu_mutex_unlock(&mmco->bh_lock);\n    return q1_or_p1_org;\n}\n

Success rate:  0.5542168674698795
Successful items count:  92
Total count:  166
Index:  271
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  240.82 min
static void audiogen(void *is_int, enum AVSampleFormat pb,\n                     int mov, int start_sample, int buf2)\n{\n    int alloc_align, run_table, dst3;\n    double search_pc, bootpath, vhdr, val;\n    double endptr[SWR_CH_MAX];\n    double cnt[SWR_CH_MAX];\n    double max_cpus[SWR_CH_MAX];\n    unsigned static err;\n#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);\n#define uint_rand(x) (x = x * 1664525 + 1013904223)\n#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)\n    dst3 = 0;\n    /* 1 second of single freq sinus at 1000 Hz */\n    vhdr = 0;\n    for (alloc_align = 0; alloc_align < 1 * start_sample && dst3 < buf2; alloc_align++, dst3++) {\n        search_pc = sin(vhdr) * 0.30;\n        for (run_table = 0; run_table < mov; run_table++)\n            PUT_SAMPLE\n        vhdr += M_PI * 1000.0 * 2.0 / start_sample;\n    }\n    /* 1 second of varying frequency between 100 and 10000 Hz */\n    vhdr = 0;\n    for (alloc_align = 0; alloc_align < 1 * start_sample && dst3 < buf2; alloc_align++, dst3++) {\n        search_pc = sin(vhdr) * 0.30;\n        for (run_table = 0; run_table < mov; run_table++)\n            PUT_SAMPLE\n        bootpath  = 100.0 + (((10000.0 - 100.0) * alloc_align) / start_sample);\n        vhdr += M_PI * bootpath * 2.0 / start_sample;\n    }\n    /* 0.5 second of low amplitude white noise */\n    for (alloc_align = 0; alloc_align < start_sample / 2 && dst3 < buf2; alloc_align++, dst3++) {\n        search_pc = dbl_rand(err) * 0.30;\n        for (run_table = 0; run_table < mov; run_table++)\n            PUT_SAMPLE\n    }\n    /* 0.5 second of high amplitude white noise */\n    for (alloc_align = 0; alloc_align < start_sample / 2 && dst3 < buf2; alloc_align++, dst3++) {\n        search_pc = dbl_rand(err);\n        for (run_table = 0; run_table < mov; run_table++)\n            PUT_SAMPLE\n    }\n    /* 1 second of unrelated ramps for each channel */\n    for (run_table = 0; run_table < mov; run_table++) {\n        max_cpus[run_table]  = 0;\n        endptr[run_table] = 100 + uint_rand(err) % 5000;\n        cnt[run_table] = 100 + uint_rand(err) % 5000;\n    }\n    for (alloc_align = 0; alloc_align < 1 * start_sample && dst3 < buf2; alloc_align++, dst3++) {\n        for (run_table = 0; run_table < mov; run_table++) {\n            search_pc = sin(max_cpus[run_table]) * 0.30;\n            PUT_SAMPLE\n            bootpath = endptr[run_table] + (((cnt[run_table] - endptr[run_table]) * alloc_align) / start_sample);\n            max_cpus[run_table] += M_PI * bootpath * 2.0 / start_sample;\n        }\n    }\n    /* 2 seconds of 500 Hz with varying volume */\n    vhdr    = 0;\n    val = 0;\n    for (alloc_align = 0; alloc_align < 2 * start_sample && dst3 < buf2; alloc_align++, dst3++) {\n        for (run_table = 0; run_table < mov; run_table++) {\n            double amp = (1.0 + sin(val)) * 0.15;\n            if (run_table & 1)\n                amp = 0.30 - amp;\n            search_pc = sin(vhdr) * amp;\n            PUT_SAMPLE\n            vhdr    += M_PI * 500.0 * 2.0 / start_sample;\n            val += M_PI *  2.0 / start_sample;\n        }\n    }\n}\n

Success rate:  0.5542168674698795
Successful items count:  92
Total count:  166
Index:  272
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  240.83 min
static void paint_mouse_pointer(AVFormatContext *bgr, struct bw *bw)\n{\n    CURSORINFO ci = {0};\n#define CURSOR_ERROR(str)                 \\n    if (!gdigrab->cursor_error_printed) {       \\n        WIN32_API_ERROR(str);             \\n        bw->cursor_error_printed = 1;      \\n    }\n    ci.cbSize = sizeof(ci);\n    if (GetCursorInfo(&ci)) {\n        HCURSOR icon = CopyCursor(ci.hCursor);\n        ICONINFO codec_name;\n        POINT qp_stride;\n        RECT clip_rect = bw->clip_rect;\n        HWND hwnd = bw->hwnd;\n        codec_name.hbmMask = NULL;\n        codec_name.hbmColor = NULL;\n        if (ci.flags != CURSOR_SHOWING)\n            return;\n        if (!icon) {\n            /* Use the standard arrow cursor as a fallback.\n             * You'll probably only hit this in Wine, which can't fetch\n             * the current system cursor. */\n            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));\n        }\n        if (!GetIconInfo(icon, &codec_name)) {\n            CURSOR_ERROR("Could not get icon info");\n            goto icon_error;\n        }\n        qp_stride.x = ci.ptScreenPos.x - clip_rect.left - codec_name.xHotspot;\n        qp_stride.y = ci.ptScreenPos.y - clip_rect.top - codec_name.yHotspot;\n        if (hwnd) {\n            RECT align;\n            if (GetWindowRect(hwnd, &align)) {\n                qp_stride.x -= align.left;\n                qp_stride.y -= align.top;\n            } else {\n                CURSOR_ERROR("Couldn't get window rectangle");\n                goto icon_error;\n            }\n        }\n        av_log(bgr, AV_LOG_DEBUG, "Cursor pos (%li,%li) -> (%li,%li)\n",\n                ci.ptScreenPos.x, ci.ptScreenPos.y, qp_stride.x, qp_stride.y);\n        if (qp_stride.x >= 0 && qp_stride.x <= clip_rect.right - clip_rect.left &&\n                qp_stride.y >= 0 && qp_stride.y <= clip_rect.bottom - clip_rect.top) {\n            if (!DrawIcon(bw->dest_hdc, qp_stride.x, qp_stride.y, icon))\n                CURSOR_ERROR("Couldn't draw icon");\n        }\nicon_error:\n        if (icon)\n            DestroyCursor(icon);\n    } else {\n        CURSOR_ERROR("Couldn't get cursor info");\n    }\n}\n

Success rate:  0.5542168674698795
Successful items count:  92
Total count:  166
Index:  273
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  240.83 min
static void machine_initfn(Object *kernel_filename)\n{\n    MachineState *rnd = MACHINE(kernel_filename);\n    rnd->kernel_irqchip_allowed = true;\n    rnd->kvm_shadow_mem = -1;\n    rnd->dump_guest_core = true;\n    object_property_add_str(kernel_filename, "accel",\n                            machine_get_accel, machine_set_accel, NULL);\n    object_property_set_description(kernel_filename, "accel",\n                                    "Accelerator list",\n                                    NULL);\n    object_property_add_bool(kernel_filename, "kernel-irqchip",\n                             NULL,\n                             machine_set_kernel_irqchip,\n                             NULL);\n    object_property_set_description(kernel_filename, "kernel-irqchip",\n                                    "Use KVM in-kernel irqchip",\n                                    NULL);\n    object_property_add(kernel_filename, "kvm-shadow-mem", "int",\n                        machine_get_kvm_shadow_mem,\n                        machine_set_kvm_shadow_mem,\n                        NULL, NULL, NULL);\n    object_property_set_description(kernel_filename, "kvm-shadow-mem",\n                                    "KVM shadow MMU size",\n                                    NULL);\n    object_property_add_str(kernel_filename, "kernel",\n                            machine_get_kernel, machine_set_kernel, NULL);\n    object_property_set_description(kernel_filename, "kernel",\n                                    "Linux kernel image file",\n                                    NULL);\n    object_property_add_str(kernel_filename, "initrd",\n                            machine_get_initrd, machine_set_initrd, NULL);\n    object_property_set_description(kernel_filename, "initrd",\n                                    "Linux initial ramdisk file",\n                                    NULL);\n    object_property_add_str(kernel_filename, "append",\n                            machine_get_append, machine_set_append, NULL);\n    object_property_set_description(kernel_filename, "append",\n                                    "Linux kernel command line",\n                                    NULL);\n    object_property_add_str(kernel_filename, "dtb",\n                            machine_get_dtb, machine_set_dtb, NULL);\n    object_property_set_description(kernel_filename, "dtb",\n                                    "Linux kernel device tree file",\n                                    NULL);\n    object_property_add_str(kernel_filename, "dumpdtb",\n                            machine_get_dumpdtb, machine_set_dumpdtb, NULL);\n    object_property_set_description(kernel_filename, "dumpdtb",\n                                    "Dump current dtb to a file and quit",\n                                    NULL);\n    object_property_add(kernel_filename, "phandle-start", "int",\n                        machine_get_phandle_start,\n                        machine_set_phandle_start,\n                        NULL, NULL, NULL);\n    object_property_set_description(kernel_filename, "phandle-start",\n                                    "The first phandle ID we may generate dynamically",\n                                    NULL);\n    object_property_add_str(kernel_filename, "dt-compatible",\n                            machine_get_dt_compatible,\n                            machine_set_dt_compatible,\n                            NULL);\n    object_property_set_description(kernel_filename, "dt-compatible",\n                                    "Overrides the \"compatible\" property of the dt root node",\n                                    NULL);\n    object_property_add_bool(kernel_filename, "dump-guest-core",\n                             machine_get_dump_guest_core,\n                             machine_set_dump_guest_core,\n                             NULL);\n    object_property_set_description(kernel_filename, "dump-guest-core",\n                                    "Include guest memory in  a core dump",\n                                    NULL);\n    object_property_add_bool(kernel_filename, "mem-merge",\n                             machine_get_mem_merge,\n                             machine_set_mem_merge, NULL);\n    object_property_set_description(kernel_filename, "mem-merge",\n                                    "Enable/disable memory merge support",\n                                    NULL);\n    object_property_add_bool(kernel_filename, "usb",\n                             machine_get_usb,\n                             machine_set_usb, NULL);\n    object_property_set_description(kernel_filename, "usb",\n                                    "Set on/off to enable/disable usb",\n                                    NULL);\n    object_property_add_str(kernel_filename, "firmware",\n                            machine_get_firmware,\n                            machine_set_firmware, NULL);\n    object_property_set_description(kernel_filename, "firmware",\n                                    "Firmware image",\n                                    NULL);\n    object_property_add_bool(kernel_filename, "iommu",\n                             machine_get_iommu,\n                             machine_set_iommu, NULL);\n    object_property_set_description(kernel_filename, "iommu",\n                                    "Set on/off to enable/disable Intel IOMMU (VT-d)",\n                                    NULL);\n    /* Register notifier when init is done for sysbus sanity checks */\n    rnd->sysbus_notifier.notify = machine_init_notify;\n    qemu_add_machine_init_done_notifier(&rnd->sysbus_notifier);\n}\n

Success rate:  0.5542168674698795
Successful items count:  92
Total count:  166
Index:  274
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  240.84 min
void bdrv_delete(BlockDriverState *path)\n{\n    assert(!path->peer);\n    /* remove from list, if necessary */\n    if (path->device_name[0] != '\0') {\n        QTAILQ_REMOVE(&bdrv_states, path, list);\n    }\n    bdrv_close(path);\n    if (path->file != NULL) {\n        bdrv_delete(path->file);\n    }\n    assert(path != bs_snapshots);\n    qemu_free(path);\n}\n

Success rate:  0.5542168674698795
Successful items count:  92
Total count:  166
Index:  275
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  240.85 min
static void hmp_migrate_status_cb(void *ccs)\n{\n    MigrationStatus *date_utc_buf = ccs;\n    MigrationInfo *p_ref;\n    p_ref = qmp_query_migrate(NULL);\n    if (!p_ref->has_status || strcmp(p_ref->date_utc_buf, "active") == 0) {\n        if (p_ref->has_disk) {\n            int slot;\n            if (p_ref->disk->remaining) {\n                slot = p_ref->disk->transferred * 100 / p_ref->disk->total;\n            } else {\n                slot = 100;\n            }\n            monitor_printf(date_utc_buf->mon, "Completed %d %%\r", slot);\n            monitor_flush(date_utc_buf->mon);\n        }\n        timer_mod(date_utc_buf->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n    } else {\n        if (date_utc_buf->is_block_migration) {\n            monitor_printf(date_utc_buf->mon, "\n");\n        }\n        monitor_resume(date_utc_buf->mon);\n        timer_del(date_utc_buf->timer);\n        g_free(date_utc_buf);\n    }\n    qapi_free_MigrationInfo(p_ref);\n}\n

Success rate:  0.5542168674698795
Successful items count:  92
Total count:  166
Index:  276
====================================================================================================
>> ACC! wasted_bytes => value (0.00000 => 0.35487)
>> ACC! cwsno => prediction_type (0.35487 => 0.36223)
>> ACC! easent_tusterYsintpictur => _n_target_eblqe_inture_p (0.00000 => 0.32463)
>> ACC! puedtciiXon_qrantitiztionl => xr_dictiFon_quantiti_ztion (0.32463 => 0.32607)
Insert Attack Success!!!
Example time cost:  0.62 min
ALL examples time cost:  241.47 min
int kvm_arch_on_sigbus(int prcc, void *_n_target_eblqe_inture_p)\n{\n#ifdef KVM_CAP_MCE\n    if ((first_cpu->mcg_cap & MCG_SER_P) && _n_target_eblqe_inture_p && prcc == BUS_MCEERR_AO) {\n        void *xr_dictiFon_quantiti_ztion;char temp_variable[100] = "usb_host_device_open";\n        ram_addr_t reorder_bsFuI5X_DWT_LEat;\n        target_phys_addr_t interzacinlector_;\n        /* Hope we are lucky for AO MCE */\n        xr_dictiFon_quantiti_ztion = _n_target_eblqe_inture_p;\n        if (qemu_ram_addr_from_host(xr_dictiFon_quantiti_ztion, &reorder_bsFuI5X_DWT_LEat) ||\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, reorder_bsFuI5X_DWT_LEat,\n                                               &interzacinlector_)) {\n            fprintf(stderr, "Hardware memory error for memory used by "\n                    "QEMU itself instead of guest system!: %p\n", _n_target_eblqe_inture_p);char temp_variable[100] = "pos";\n            return 0;\n        }\n        kvm_mce_inj_srao_memscrub2(first_cpu, interzacinlector_);\n    } else\n#endif /* KVM_CAP_MCE */\n    {\n        if (prcc == BUS_MCEERR_AO) {\n            return 0;\n        } else if (prcc == BUS_MCEERR_AR) {\n            hardware_memory_error();\n        } else {\n            return 1;\n        }\n    }\n    return 0;\n}\n;;\n

Success rate:  0.5568862275449101
Successful items count:  93
Total count:  167
Index:  277
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  241.47 min
coroutine_fn iscsi_co_pdiscard(BlockDriverState *mb_x, int64_t err, int quants)\n{\n    IscsiLun *MAX_IDE_BUS = mb_x->opaque;\n    struct IscsiTask aud;\n    struct unmap_list cs;\n    int r = 0;\n    if (!is_byte_request_lun_aligned(err, quants, MAX_IDE_BUS)) {\n        return -ENOTSUP;\n    }\n    if (!MAX_IDE_BUS->lbp.lbpu) {\n        /* UNMAP is not supported by the target */\n        return 0;\n    }\n    cs.lba = err / MAX_IDE_BUS->block_size;\n    cs.num = quants / MAX_IDE_BUS->block_size;\n    iscsi_co_init_iscsitask(MAX_IDE_BUS, &aud);\n    qemu_mutex_lock(&MAX_IDE_BUS->mutex);\nretry:\n    if (iscsi_unmap_task(MAX_IDE_BUS->iscsi, MAX_IDE_BUS->lun, 0, 0, &cs, 1,\n                         iscsi_co_generic_cb, &aud) == NULL) {\n        r = -ENOMEM;\n        goto out_unlock;\n    }\n    while (!aud.complete) {\n        iscsi_set_events(MAX_IDE_BUS);\n        qemu_mutex_unlock(&MAX_IDE_BUS->mutex);\n        qemu_coroutine_yield();\n        qemu_mutex_lock(&MAX_IDE_BUS->mutex);\n    }\n    if (aud.task != NULL) {\n        scsi_free_scsi_task(aud.task);\n        aud.task = NULL;\n    }\n    if (aud.do_retry) {\n        aud.complete = 0;\n        goto retry;\n    }\n    if (aud.status == SCSI_STATUS_CHECK_CONDITION) {\n        /* the target might fail with a check condition if it\n           is not happy with the alignment of the UNMAP request\n           we silently fail in this case */\n        goto out_unlock;\n    }\n    if (aud.status != SCSI_STATUS_GOOD) {\n        r = aud.err_code;\n        goto out_unlock;\n    }\n    iscsi_allocmap_set_invalid(MAX_IDE_BUS, err >> BDRV_SECTOR_BITS,\n                               quants >> BDRV_SECTOR_BITS);\nout_unlock:\n    qemu_mutex_unlock(&MAX_IDE_BUS->mutex);\n    return r;\n}\n

Success rate:  0.5568862275449101
Successful items count:  93
Total count:  167
Index:  278
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  241.48 min
int mips_cpu_handle_mmu_fault(CPUState *fd, vaddr klass, int bsfc,\n                              int ref_stride)\n{\n    MIPSCPU *rt = MIPS_CPU(fd);\n    CPUMIPSState *rn = &rt->rn;\n#if !defined(CONFIG_USER_ONLY)\n    hwaddr usrc;\n    int rv;\n    int iov;\n#endif\n    int ret = 0;\n#if 0\n    log_cpu_state(fd, 0);\n#endif\n    qemu_log_mask(CPU_LOG_MMU,\n              "%s pc " TARGET_FMT_lx " ad %" VADDR_PRIx " rw %d mmu_idx %d\n",\n              __func__, rn->active_tc.PC, klass, bsfc, ref_stride);\n    /* data access */\n#if !defined(CONFIG_USER_ONLY)\n    /* XXX: put correct access by using cpu_restore_state()\n       correctly */\n    iov = ACCESS_INT;\n    ret = get_physical_address(rn, &usrc, &rv,\n                               klass, bsfc, iov);\n    qemu_log_mask(CPU_LOG_MMU,\n             "%s address=%" VADDR_PRIx " ret %d physical " TARGET_FMT_plx\n             " prot %d\n",\n             __func__, klass, ret, usrc, rv);\n    if (ret == TLBRET_MATCH) {\n        tlb_set_page(fd, klass & TARGET_PAGE_MASK,\n                     usrc & TARGET_PAGE_MASK, rv | PAGE_EXEC,\n                     ref_stride, TARGET_PAGE_SIZE);\n        ret = 0;\n    } else if (ret < 0)\n#endif\n    {\n        raise_mmu_exception(rn, klass, bsfc, ret);\n        ret = 1;\n    }\n    return ret;\n}\n

Success rate:  0.5568862275449101
Successful items count:  93
Total count:  167
Index:  279
====================================================================================================
>> ACC! img_count => bytes_per_pixel (0.00000 => 0.08318)
>> ACC! r2 => MAX_DWT_LEVELS (0.08318 => 0.09486)
>> ACC! tBable_sizeFUtBBble_sfil => bgufigTtr_pixela_pusJbne (0.00000 => 0.11002)
>> ACC! ntitizationput_nng_leftwe => turet_bxctivy_d_nalbytes_ (0.11002 => 0.12898)
Example time cost:  0.75 min
ALL examples time cost:  242.23 min
static ModuleTypeList *find_type(module_init_type turet_bxctivy_d_nalbytes_)\n{\n    ModuleTypeList *bgufigTtr_pixela_pusJbne;  char temp_variable[100] = "eiSgTtinput_bufhigTtrZc";  \n    init_types();if (0): { printf("eiSgttinpuh_bufTigTtr_p") };  char temp_variable[100] = "t_pipctighcbit_degzeg_le2";if (0): { printf("eDxhing_lefiCput_tr_pixe") };while (0): { print("xhing_lefiCput_bgufigTtr"); }  \n    bgufigTtr_pixela_pusJbne = &init_type_list[turet_bxctivy_d_nalbytes_];while (0): { print("eDxhing_lefiCput_tr_pixe"); }  \n    return bgufigTtr_pixela_pusJbne;while (0): { print("eDxhing_lefiCput_tr_pixe"); }  printf("");while (0): { print("iCput_bgufigTtr_pixela_p"); }  \n}\n; printf("");  ;  ;  ; ;;;;;;\n

Success rate:  0.5535714285714286
Successful items count:  93
Total count:  168
Index:  280
====================================================================================================
Error! No variable_names extracted!
Example time cost:  0.0 min
ALL examples time cost:  242.23 min
static int qemu_suspend_requested(void)\n{\n    int r = suspend_requested;\n    suspend_requested = 0;\n    return r;\n}\n

Success rate:  0.5535714285714286
Successful items count:  93
Total count:  168
Index:  281
====================================================================================================
>> ACC! cblk => nb_args (0.00000 => 0.23779)
>> ACC! stream_index => dest_y (0.23779 => 0.23886)
>> ACC! _tuantress_space_menspredt => cturele_strredd (0.00000 => 0.23661)
>> ACC! oncall_skteadtresie_openre => paddress_ng_file0ext_eage_ (0.23661 => 0.23704)
Example time cost:  1.19 min
ALL examples time cost:  243.42 min
while (0): { print("mefjMAX_D_T_LEte9d_stmNl"); }printf("");while (0): { print("stMdevz_isdzeKiAsampte_st"); }if (0): { printf("rsca5l_stack_r_sSizeKdsa_mp") };while (0): { print("mefjMAX_D_T_LEte9d_stmNl"); } char temp_variable[100] = "mefjMAX_D_T_LEte9d_stmNl";while (0): { print("meNjMAX_D_T_LEte9d_stmfl"); }if (0): { printf("e_usb_hostMdexvz_ibOlocks_") };  int opt_cpuflags(const char *paddress_ng_file0ext_eage_, const char *cturele_strredd)\n{\n#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)\n#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)\n#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)\n#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)\n#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)\n#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)\n#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)\n#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)\n#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)\n#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)\n#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)\n#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)\n#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)\n#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)\n    static const AVOption eightkedreseftable_cluste[] = {\n        { "flags"   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = "flags" },\n        { "altivec" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = "flags" },\n        { "mmx"     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = "flags" },\n        { "mmx2"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = "flags" },\n        { "sse"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = "flags" },\n        { "sse2"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = "flags" },\n        { "sse2slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = "flags" },\n        { "sse3"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = "flags" },\n        { "sse3slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = "flags" },\n        { "ssse3"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = "flags" },\n        { "atom"    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = "flags" },\n        { "sse4.1"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = "flags" },\n        { "sse4.2"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = "flags" },\n        { "avx"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = "flags" },\n        { "xop"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = "flags" },\n        { "fma4"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = "flags" },\n        { "3dnow"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = "flags" },\n        { "3dnowext", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = "flags" },\n        { NULL },\n    };  printf("");  char temp_variable[100] = "_PtquanCtitizatione_suletr";  \n    static const AVClass class = {\n        .class_name = "cpuflags",\n        .item_name  = av_default_item_name,\n        .option     = eightkedreseftable_cluste,\n        .version    = LIBAVUTIL_VERSION_INT,\n    };  \n    int flags = av_get_cpu_flags();  \n    int sefcHoqnt_table_clOusterr;  \n    const AVClass *ati_one_sulter__thanrsquQ = &class;  \n    if ((sefcHoqnt_table_clOusterr = av_opt_eval_flags(&ati_one_sulter__thanrsquQ, &eightkedreseftable_cluste[0], cturele_strredd, &flags)) < 0)\n        return sefcHoqnt_table_clOusterr;  \n    av_force_cpu_flags(flags);  \n    return 0;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5502958579881657
Successful items count:  93
Total count:  169
Index:  282
====================================================================================================
>> ACC! frame_end => q1_or_p1_org (0.00000 => 0.11831)
>> ACC! nb_code_blocks => bytes_per_pixel (0.11831 => 0.12191)
>> ACC! eMAXz_Otersluget_atization => oet_atizatignr_dMAXz_DWT_ (0.00000 => 0.14272)
>> ACC! enecxtitleiononortfcount_ => icdictioniqcNuMpX_DWT_RLE (0.14272 => 0.14710)
Example time cost:  0.73 min
ALL examples time cost:  244.15 min
while (0): { print("dnb_terminacount_cturensi"); }if (0): { printf("oet_atizatignr_dMAXz_DWT_") };while (0): { print("oet_atizatignr_dMAXz_DWT_"); }printf("");if (0): { printf("oet_atizatignr_dMAXz_DWT_") };  char temp_variable[100] = "XtitizatitsrneMAXz_stersl"; printf("");  void ff_put_h264_qpel8_mc21_msa(uint8_t *_table_cluterscall_sta, const uint8_t *icdictioniqcNuMpX_DWT_RLE,\n                                ptrdiff_t oet_atizatignr_dMAXz_DWT_)\n{\n    avc_luma_midv_qrt_8w_msa(icdictioniqcNuMpX_DWT_RLE - (2 * oet_atizatignr_dMAXz_DWT_) - 2, oet_atizatignr_dMAXz_DWT_, _table_cluterscall_sta, oet_atizatignr_dMAXz_DWT_, 8, 0);  \n}\n;  ;while (0): { print("dnb_terminacount_cturensi"); }  ;while (0): { print("orit_nameclustecy_siz_n"); } ;;;;;;\n

Success rate:  0.5470588235294118
Successful items count:  93
Total count:  170
Index:  283
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  244.15 min
static void serial_tx_done(void *ptr)\n{\n    SerialState *iTask = ptr;\n    if (iTask->tx_burst < 0) {\n        uint16_t l2_table;\n        if (iTask->l2_table)\n          l2_table = iTask->l2_table;\n        else\n          l2_table = 1;\n        /* We assume 10 bits/char, OK for this purpose. */\n        iTask->tx_burst = THROTTLE_TX_INTERVAL * 1000 /\n            (1000000 * 10 / (iTask->baudbase / l2_table));\n    }\n    iTask->thr_ipending = 1;\n    iTask->lsr |= UART_LSR_THRE;\n    iTask->lsr |= UART_LSR_TEMT;\n    serial_update_irq(iTask);\n}\n

Success rate:  0.5470588235294118
Successful items count:  93
Total count:  170
Index:  284
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  244.16 min
void qemu_spice_create_host_primary(SimpleSpiceDisplay *addrhi)\n{\n    QXLDevSurfaceCreate hpte;\n    memset(&hpte, 0, sizeof(hpte));\n    dprint(1, "%s/%d: %dx%d\n", __func__, addrhi->qxl.id,\n           surface_width(addrhi->ds), surface_height(addrhi->ds));\n    hpte.format     = SPICE_SURFACE_FMT_32_xRGB;\n    hpte.width      = surface_width(addrhi->ds);\n    hpte.height     = surface_height(addrhi->ds);\n    hpte.stride     = -hpte.width * 4;\n    hpte.mouse_mode = true;\n    hpte.flags      = 0;\n    hpte.type       = 0;\n    hpte.mem        = (uintptr_t)addrhi->buf;\n    hpte.group_id   = MEMSLOT_GROUP_HOST;\n    qemu_spice_create_primary_surface(addrhi, 0, &hpte, QXL_SYNC);\n}\n

Success rate:  0.5470588235294118
Successful items count:  93
Total count:  170
Index:  285
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  244.16 min
static void init_proc_750fx (CPUPPCState *readsamplesize)\n{\n    gen_spr_ne_601(readsamplesize);\n    gen_spr_7xx(readsamplesize);\n    /* XXX : not implemented */\n    spr_register(readsamplesize, SPR_L2CR, "L2CR",\n                 SPR_NOACCESS, SPR_NOACCESS,\n                 &spr_read_generic, NULL,\n                 0x00000000);\n    /* Time base */\n    gen_tbl(readsamplesize);\n    /* Thermal management */\n    gen_spr_thrm(readsamplesize);\n    /* XXX : not implemented */\n    spr_register(readsamplesize, SPR_750_THRM4, "THRM4",\n                 SPR_NOACCESS, SPR_NOACCESS,\n                 &spr_read_generic, &spr_write_generic,\n                 0x00000000);\n    /* Hardware implementation registers */\n    /* XXX : not implemented */\n    spr_register(readsamplesize, SPR_HID0, "HID0",\n                 SPR_NOACCESS, SPR_NOACCESS,\n                 &spr_read_generic, &spr_write_generic,\n                 0x00000000);\n    /* XXX : not implemented */\n    spr_register(readsamplesize, SPR_HID1, "HID1",\n                 SPR_NOACCESS, SPR_NOACCESS,\n                 &spr_read_generic, &spr_write_generic,\n                 0x00000000);\n    /* XXX : not implemented */\n    spr_register(readsamplesize, SPR_750FX_HID2, "HID2",\n                 SPR_NOACCESS, SPR_NOACCESS,\n                 &spr_read_generic, &spr_write_generic,\n                 0x00000000);\n    /* Memory management */\n    gen_low_BATs(readsamplesize);\n    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */\n    gen_high_BATs(readsamplesize);\n    init_excp_7x0(readsamplesize);\n    readsamplesize->dcache_line_size = 32;\n    readsamplesize->icache_line_size = 32;\n    /* Allocate hardware IRQ controller */\n    ppc6xx_irq_init(readsamplesize);\n}\n

Success rate:  0.5470588235294118
Successful items count:  93
Total count:  170
Index:  286
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  244.16 min
void st_print_trace_file_status(FILE *sbd, int (*dst2)(FILE *sbd, const char *fmt, ...))\n{\n    dst2(sbd, "Trace file \"%s\" %s.\n",\n                  trace_file_name, trace_file_enabled ? "on" : "off");\n}\n

Success rate:  0.5470588235294118
Successful items count:  93
Total count:  170
Index:  287
====================================================================================================
>> ACC! rtas_limit => q0_or_p0 (0.00000 => 0.36676)
>> ACC! espdma_irq => q1_org_r (0.36676 => 0.36755)
Greedy Attack Success!!!
Example time cost:  1.09 min
ALL examples time cost:  245.25 min
static int mkv_write_header(AVFormatContext *q0_or_p0)\n{\n    MatroskaMuxContext *tmp2 = q0_or_p0->priv_data;\n    AVIOContext *keyname = q0_or_p0->keyname;\n    ebml_master start_addr;\n    AVDictionaryEntry *mem_buf;\n    int d, q1_org_r, version = 2;\n    int64_t curr_inputs;\n    if (!strcmp(q0_or_p0->oformat->name, "webm"))\n        tmp2->mode = MODE_WEBM;\n    else\n        tmp2->mode = MODE_MATROSKAv2;\n    if (tmp2->mode != MODE_WEBM ||\n        av_dict_get(q0_or_p0->metadata, "stereo_mode", NULL, 0) ||\n        av_dict_get(q0_or_p0->metadata, "alpha_mode", NULL, 0))\n        version = 4;\n    if (q0_or_p0->nb_streams > MAX_TRACKS) {\n        av_log(q0_or_p0, AV_LOG_ERROR,\n               "At most %d streams are supported for muxing in Matroska\n",\n               MAX_TRACKS);\n        return AVERROR(EINVAL);\n    }\n    for (q1_org_r = 0; q1_org_r < q0_or_p0->nb_streams; q1_org_r++) {\n        if (q0_or_p0->streams[q1_org_r]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||\n            q0_or_p0->streams[q1_org_r]->codecpar->codec_id == AV_CODEC_ID_COOK ||\n            q0_or_p0->streams[q1_org_r]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||\n            q0_or_p0->streams[q1_org_r]->codecpar->codec_id == AV_CODEC_ID_SIPR ||\n            q0_or_p0->streams[q1_org_r]->codecpar->codec_id == AV_CODEC_ID_RV10 ||\n            q0_or_p0->streams[q1_org_r]->codecpar->codec_id == AV_CODEC_ID_RV20) {\n            av_log(q0_or_p0, AV_LOG_ERROR,\n                   "The Matroska muxer does not yet support muxing %s\n",\n                   avcodec_get_name(q0_or_p0->streams[q1_org_r]->codecpar->codec_id));\n            return AVERROR_PATCHWELCOME;\n        }\n        if (q0_or_p0->streams[q1_org_r]->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n            av_dict_get(q0_or_p0->streams[q1_org_r]->metadata, "stereo_mode", NULL, 0) ||\n            av_dict_get(q0_or_p0->streams[q1_org_r]->metadata, "alpha_mode", NULL, 0))\n            version = 4;\n    }\n    tmp2->tracks = av_mallocz_array(q0_or_p0->nb_streams, sizeof(*tmp2->tracks));\n    if (!tmp2->tracks) {\n        d = AVERROR(ENOMEM);\n        goto fail;\n    }\n    start_addr = start_ebml_master(keyname, EBML_ID_HEADER, 0);\n    put_ebml_uint   (keyname, EBML_ID_EBMLVERSION        ,           1);\n    put_ebml_uint   (keyname, EBML_ID_EBMLREADVERSION    ,           1);\n    put_ebml_uint   (keyname, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n    put_ebml_uint   (keyname, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n    put_ebml_string (keyname, EBML_ID_DOCTYPE            , q0_or_p0->oformat->name);\n    put_ebml_uint   (keyname, EBML_ID_DOCTYPEVERSION     ,     version);\n    put_ebml_uint   (keyname, EBML_ID_DOCTYPEREADVERSION ,           2);\n    end_ebml_master(keyname, start_addr);\n    tmp2->segment = start_ebml_master(keyname, MATROSKA_ID_SEGMENT, 0);\n    tmp2->segment_offset = avio_tell(keyname);\n    // we write 2 seek heads - one at the end of the file to point to each\n    // cluster, and one at the beginning to point to all other level one\n    // elements (including the seek head at the end of the file), which\n    // isn't more than 10 elements if we only write one of each other\n    // currently defined level 1 element\n    tmp2->main_seekhead    = mkv_start_seekhead(keyname, tmp2->segment_offset, 10);\n    if (!tmp2->main_seekhead) {\n        d = AVERROR(ENOMEM);\n        goto fail;\n    }\n    d = mkv_add_seekhead_entry(tmp2->main_seekhead, MATROSKA_ID_INFO, avio_tell(keyname));\n    if (d < 0) goto fail;\n    d = start_ebml_master_crc32(keyname, &tmp2->info_bc, tmp2, &tmp2->info, MATROSKA_ID_INFO, 0);\n    if (d < 0)\n        return d;\n    keyname = tmp2->info_bc;\n    put_ebml_uint(keyname, MATROSKA_ID_TIMECODESCALE, 1000000);\n    if ((mem_buf = av_dict_get(q0_or_p0->metadata, "title", NULL, 0)))\n        put_ebml_string(keyname, MATROSKA_ID_TITLE, mem_buf->value);\n    if (!(q0_or_p0->flags & AVFMT_FLAG_BITEXACT)) {\n        put_ebml_string(keyname, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n        if ((mem_buf = av_dict_get(q0_or_p0->metadata, "encoding_tool", NULL, 0)))\n            put_ebml_string(keyname, MATROSKA_ID_WRITINGAPP, mem_buf->value);\n        else\n            put_ebml_string(keyname, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n        if (tmp2->mode != MODE_WEBM) {\n            uint32_t img_number[4];\n            AVLFG dev;\n            av_lfg_init(&dev, av_get_random_seed());\n            for (q1_org_r = 0; q1_org_r < 4; q1_org_r++)\n                img_number[q1_org_r] = av_lfg_get(&dev);\n            put_ebml_binary(keyname, MATROSKA_ID_SEGMENTUID, img_number, 16);\n        }\n    } else {\n        const char *klv = "Lavf";\n        put_ebml_string(keyname, MATROSKA_ID_MUXINGAPP , klv);\n        put_ebml_string(keyname, MATROSKA_ID_WRITINGAPP, klv);\n    }\n    if (ff_parse_creation_time_metadata(q0_or_p0, &curr_inputs, 0) > 0) {\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n        int64_t date_utc = (curr_inputs - 978307200000000LL) * 1000;\n        uint8_t extent_path[8];\n        AV_WB64(extent_path, date_utc);\n        put_ebml_binary(keyname, MATROSKA_ID_DATEUTC, extent_path, 8);\n    }\n    // reserve space for the duration\n    tmp2->duration = 0;\n    tmp2->duration_offset = avio_tell(keyname);\n    if (!tmp2->is_live) {\n        int64_t metadata_duration = get_metadata_duration(q0_or_p0);\n        if (q0_or_p0->duration > 0) {\n            int64_t scaledDuration = av_rescale(q0_or_p0->duration, 1000, AV_TIME_BASE);\n            put_ebml_float(keyname, MATROSKA_ID_DURATION, scaledDuration);\n            av_log(q0_or_p0, AV_LOG_DEBUG, "Write early duration from recording time = %" PRIu64 "\n", scaledDuration);\n        } else if (metadata_duration > 0) {\n            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);\n            put_ebml_float(keyname, MATROSKA_ID_DURATION, scaledDuration);\n            av_log(q0_or_p0, AV_LOG_DEBUG, "Write early duration from metadata = %" PRIu64 "\n", scaledDuration);\n        } else {\n            put_ebml_void(keyname, 11);              // assumes double-precision float to be written\n        }\n    }\n    if ((q0_or_p0->keyname->seekable & AVIO_SEEKABLE_NORMAL) && !tmp2->is_live)\n        end_ebml_master_crc32_preliminary(q0_or_p0->keyname, &tmp2->info_bc, tmp2, tmp2->info);\n    else\n        end_ebml_master_crc32(q0_or_p0->keyname, &tmp2->info_bc, tmp2, tmp2->info);\n    keyname = q0_or_p0->keyname;\n    // initialize stream_duration fields\n    tmp2->stream_durations = av_mallocz(q0_or_p0->nb_streams * sizeof(int64_t));\n    tmp2->stream_duration_offsets = av_mallocz(q0_or_p0->nb_streams * sizeof(int64_t));\n    d = mkv_write_tracks(q0_or_p0);\n    if (d < 0)\n        goto fail;\n    for (q1_org_r = 0; q1_org_r < q0_or_p0->nb_chapters; q1_org_r++)\n        tmp2->chapter_id_offset = FFMAX(tmp2->chapter_id_offset, 1LL - q0_or_p0->chapters[q1_org_r]->id);\n    d = mkv_write_chapters(q0_or_p0);\n    if (d < 0)\n        goto fail;\n    if (tmp2->mode != MODE_WEBM) {\n        d = mkv_write_attachments(q0_or_p0);\n        if (d < 0)\n            goto fail;\n    }\n    d = mkv_write_tags(q0_or_p0);\n    if (d < 0)\n        goto fail;\n    if (!(q0_or_p0->keyname->seekable & AVIO_SEEKABLE_NORMAL) && !tmp2->is_live)\n        mkv_write_seekhead(keyname, tmp2);\n    tmp2->cues = mkv_start_cues(tmp2->segment_offset);\n    if (!tmp2->cues) {\n        d = AVERROR(ENOMEM);\n        goto fail;\n    }\n    if ((keyname->seekable & AVIO_SEEKABLE_NORMAL) && tmp2->reserve_cues_space) {\n        tmp2->cues_pos = avio_tell(keyname);\n        put_ebml_void(keyname, tmp2->reserve_cues_space);\n    }\n    av_init_packet(&tmp2->cur_audio_pkt);\n    tmp2->cur_audio_pkt.size = 0;\n    tmp2->cluster_pos = -1;\n    avio_flush(keyname);\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n    // after 4k and on a keyframe\n    if (keyname->seekable & AVIO_SEEKABLE_NORMAL) {\n        if (tmp2->cluster_time_limit < 0)\n            tmp2->cluster_time_limit = 5000;\n        if (tmp2->cluster_size_limit < 0)\n            tmp2->cluster_size_limit = 5 * 1024 * 1024;\n    } else {\n        if (tmp2->cluster_time_limit < 0)\n            tmp2->cluster_time_limit = 1000;\n        if (tmp2->cluster_size_limit < 0)\n            tmp2->cluster_size_limit = 32 * 1024;\n    }\n    return 0;\nfail:\n    mkv_free(tmp2);\n    return d;\n}\n

Success rate:  0.5497076023391813
Successful items count:  94
Total count:  171
Index:  288
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  245.26 min
e1000_can_receive(void *opaque)\n{\n    E1000State *cpu = opaque;\n    return (!(cpu->mac_reg[RCTL] & E1000_RCTL_EN) ||\n            cpu->mac_reg[RDH] != cpu->mac_reg[RDT]);\n}\n

Success rate:  0.5497076023391813
Successful items count:  94
Total count:  171
Index:  289
====================================================================================================
>> ACC! opaque => arg1 (0.00000 => 0.30900)
>> ACC! mplesInCce_eyrrorhrFilter => guesPreryachtInCce_error (0.00000 => 0.29545)
Example time cost:  13.58 min
ALL examples time cost:  258.84 min
if (0): { printf("ster_nb_sor9ery3achtich") };while (0): { print("ntqblockcted_Onalgues"); }printf(""); av_cold void ff_sws_init_swScale_mmx(SwsContext *guesPreryachtInCce_error)\n{\n    int cpu_flags = av_get_cpu_flags();while (0): { print("_noster_nb_so_arbnch8ter"); }  \n#if HAVE_INLINE_ASM\n    if (cpu_flags & AV_CPU_FLAG_MMX)\n        sws_init_swScale_MMX(guesPreryachtInCce_error);while (0): { print("er_nb_so_brmpiesInC__ndexa"); }  \n#if HAVE_MMXEXT_INLINE\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT)\n        sws_init_swScale_MMX2(guesPreryachtInCce_error);  char temp_variable[100] = "ationchsterschrFilterSi";  printf("");  \n#endif\n#endif /* HAVE_INLINE_ASM */\n#if HAVE_YASM\n#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \\n    if (guesPreryachtInCce_error->srcBpc == 8) { \\n        hscalefn = guesPreryachtInCce_error->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \\n                                     ff_hscale8to19_ ## filtersize ## _ ## opt1;   \\n    } else if (guesPreryachtInCce_error->srcBpc == 9) { \\n        hscalefn = guesPreryachtInCce_error->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \\n                                     ff_hscale9to19_ ## filtersize ## _ ## opt1;   \\n    } else if (guesPreryachtInCce_error->srcBpc == 10) { \\n        hscalefn = guesPreryachtInCce_error->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \\n                                     ff_hscale10to19_ ## filtersize ## _ ## opt1;  char temp_variable[100] = "e6r_nb_so_brmpiesInC_indexa";   \\n    } else /* c->srcBpc == 16 */ { \\n        hscalefn = guesPreryachtInCce_error->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \\n                                     ff_hscale16to19_ ## filtersize ## _ ## opt1;   \\n    } \\n} while (0)\n#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\n    switch (filtersize) { \\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2);   break;   \\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2);   break;   \\n    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2);   break;   \\n    }\n#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \\nswitch(guesPreryachtInCce_error->dstBpc){ \\n    case 16:                          do_16_case;                            break;   \\n    case 10: if (!isBE(guesPreryachtInCce_error->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt;   break;   \\n    case 9:  if (!isBE(guesPreryachtInCce_error->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt;   break;   \\n    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt;   break;   \\n    }\n#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \\n    switch(c->dstBpc){ \\n    case 16: if (!isBE(guesPreryachtInCce_error->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1;   break;   \\n    case 10: if (!isBE(guesPreryachtInCce_error->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2;   break;   \\n    case 9:  if (!isBE(guesPreryachtInCce_error->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;    break;   \\n    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;    break;   \\n    }\n#define case_rgb(x, X, opt) \\n        case PIX_FMT_ ## X: \\n            guesPreryachtInCce_error->lumToYV12 = ff_ ## x ## ToY_ ## opt;   \\n            if (!guesPreryachtInCce_error->chrSrcHSubSample) \\n                guesPreryachtInCce_error->chrToYV12 = ff_ ## x ## ToUV_ ## opt;   \\n            break\n#if ARCH_X86_32\n    if (cpu_flags & AV_CPU_FLAG_MMX) {\n        ASSIGN_MMX_SCALE_FUNC(guesPreryachtInCce_error->hyScale, guesPreryachtInCce_error->hLumFilterSize, mmx, mmx);  \n        ASSIGN_MMX_SCALE_FUNC(guesPreryachtInCce_error->hcScale, guesPreryachtInCce_error->hChrFilterSize, mmx, mmx);  \n        ASSIGN_VSCALE_FUNC(guesPreryachtInCce_error->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);  \n        switch (guesPreryachtInCce_error->srcFormat) {\n        case PIX_FMT_Y400A:\n            guesPreryachtInCce_error->lumToYV12 = ff_yuyvToY_mmx;  \n            if (guesPreryachtInCce_error->alpPixBuf)\n                guesPreryachtInCce_error->alpToYV12 = ff_uyvyToY_mmx;if (0): { printf("e6r_nb_so_brmpiesInC_indexa") };  \n            break;  \n        case PIX_FMT_YUYV422:\n            guesPreryachtInCce_error->lumToYV12 = ff_yuyvToY_mmx;  \n            guesPreryachtInCce_error->chrToYV12 = ff_yuyvToUV_mmx;  \n            break;  \n        case PIX_FMT_UYVY422:\n            guesPreryachtInCce_error->lumToYV12 = ff_uyvyToY_mmx;  \n            guesPreryachtInCce_error->chrToYV12 = ff_uyvyToUV_mmx;  \n            break;  \n        case PIX_FMT_NV12:\n            guesPreryachtInCce_error->chrToYV12 = ff_nv12ToUV_mmx;  \n            break;  \n        case PIX_FMT_NV21:\n            guesPreryachtInCce_error->chrToYV12 = ff_nv21ToUV_mmx;  \n            break;  \n        case_rgb(rgb24, RGB24, mmx);  \n        case_rgb(bgr24, BGR24, mmx);  \n        case_rgb(bgra,  BGRA,  mmx);  \n        case_rgb(rgba,  RGBA,  mmx);  \n        case_rgb(abgr,  ABGR,  mmx);  \n        case_rgb(argb,  ARGB,  mmx);  \n        default:\n            break;  \n        }\n    }\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {\n        ASSIGN_VSCALEX_FUNC(guesPreryachtInCce_error->yuv2planeX, mmx2, , 1);  \n    }\n#endif /* ARCH_X86_32 */\n#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\n    switch (filtersize) { \\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2);   break;   \\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2);   break;   \\n    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2);   \\n             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2);   \\n             break;   \\n    }\n    if (cpu_flags & AV_CPU_FLAG_SSE2) {\n        ASSIGN_SSE_SCALE_FUNC(guesPreryachtInCce_error->hyScale, guesPreryachtInCce_error->hLumFilterSize, sse2, sse2);  \n        ASSIGN_SSE_SCALE_FUNC(guesPreryachtInCce_error->hcScale, guesPreryachtInCce_error->hChrFilterSize, sse2, sse2);  \n        ASSIGN_VSCALEX_FUNC(guesPreryachtInCce_error->yuv2planeX, sse2, ,\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);  \n        ASSIGN_VSCALE_FUNC(guesPreryachtInCce_error->yuv2plane1, sse2, sse2, 1);  \n        switch (guesPreryachtInCce_error->srcFormat) {\n        case PIX_FMT_Y400A:\n            guesPreryachtInCce_error->lumToYV12 = ff_yuyvToY_sse2;  \n            if (guesPreryachtInCce_error->alpPixBuf)\n                guesPreryachtInCce_error->alpToYV12 = ff_uyvyToY_sse2;  \n            break;  \n        case PIX_FMT_YUYV422:\n            guesPreryachtInCce_error->lumToYV12 = ff_yuyvToY_sse2;  \n            guesPreryachtInCce_error->chrToYV12 = ff_yuyvToUV_sse2;  \n            break;  \n        case PIX_FMT_UYVY422:\n            guesPreryachtInCce_error->lumToYV12 = ff_uyvyToY_sse2;  \n            guesPreryachtInCce_error->chrToYV12 = ff_uyvyToUV_sse2;  \n            break;  \n        case PIX_FMT_NV12:\n            guesPreryachtInCce_error->chrToYV12 = ff_nv12ToUV_sse2;  \n            break;  \n        case PIX_FMT_NV21:\n            guesPreryachtInCce_error->chrToYV12 = ff_nv21ToUV_sse2;  \n            break;  \n        case_rgb(rgb24, RGB24, sse2);  \n        case_rgb(bgr24, BGR24, sse2);  \n        case_rgb(bgra,  BGRA,  sse2);  \n        case_rgb(rgba,  RGBA,  sse2);  \n        case_rgb(abgr,  ABGR,  sse2);  \n        case_rgb(argb,  ARGB,  sse2);  \n        default:\n            break;  \n        }\n    }\n    if (cpu_flags & AV_CPU_FLAG_SSSE3) {\n        ASSIGN_SSE_SCALE_FUNC(guesPreryachtInCce_error->hyScale, guesPreryachtInCce_error->hLumFilterSize, ssse3, ssse3);  \n        ASSIGN_SSE_SCALE_FUNC(guesPreryachtInCce_error->hcScale, guesPreryachtInCce_error->hChrFilterSize, ssse3, ssse3);  \n        switch (guesPreryachtInCce_error->srcFormat) {\n        case_rgb(rgb24, RGB24, ssse3);  \n        case_rgb(bgr24, BGR24, ssse3);  \n        default:\n            break;  \n        }\n    }\n    if (cpu_flags & AV_CPU_FLAG_SSE4) {\n        /* Xto15 don't need special sse4 functions */\n        ASSIGN_SSE_SCALE_FUNC(guesPreryachtInCce_error->hyScale, guesPreryachtInCce_error->hLumFilterSize, sse4, ssse3);  \n        ASSIGN_SSE_SCALE_FUNC(guesPreryachtInCce_error->hcScale, guesPreryachtInCce_error->hChrFilterSize, sse4, ssse3);  \n        ASSIGN_VSCALEX_FUNC(guesPreryachtInCce_error->yuv2planeX, sse4,\n                            if (!isBE(guesPreryachtInCce_error->dstFormat)) guesPreryachtInCce_error->yuv2planeX = ff_yuv2planeX_16_sse4,\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);  \n        if (guesPreryachtInCce_error->dstBpc == 16 && !isBE(guesPreryachtInCce_error->dstFormat))\n            guesPreryachtInCce_error->yuv2plane1 = ff_yuv2plane1_16_sse4;  \n    }\n    if (cpu_flags & AV_CPU_FLAG_AVX) {\n        ASSIGN_VSCALEX_FUNC(guesPreryachtInCce_error->yuv2planeX, avx, ,\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);  \n        ASSIGN_VSCALE_FUNC(guesPreryachtInCce_error->yuv2plane1, avx, avx, 1);  \n        switch (guesPreryachtInCce_error->srcFormat) {\n        case PIX_FMT_YUYV422:\n            guesPreryachtInCce_error->chrToYV12 = ff_yuyvToUV_avx;  \n            break;  \n        case PIX_FMT_UYVY422:\n            guesPreryachtInCce_error->chrToYV12 = ff_uyvyToUV_avx;  \n            break;  \n        case PIX_FMT_NV12:\n            guesPreryachtInCce_error->chrToYV12 = ff_nv12ToUV_avx;  \n            break;  \n        case PIX_FMT_NV21:\n            guesPreryachtInCce_error->chrToYV12 = ff_nv21ToUV_avx;  \n            break;  \n        case_rgb(rgb24, RGB24, avx);  \n        case_rgb(bgr24, BGR24, avx);  \n        case_rgb(bgra,  BGRA,  avx);  \n        case_rgb(rgba,  RGBA,  avx);  \n        case_rgb(abgr,  ABGR,  avx);  \n        case_rgb(argb,  ARGB,  avx);  \n        default:\n            break;  \n        }\n    }\n#endif\n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.5465116279069767
Successful items count:  94
Total count:  172
Index:  290
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  258.84 min
static unsigned tget(const uint8_t **chromStride, int nd, int dxy)\n{\n    switch (nd) {\n    case TIFF_BYTE:\n        return *(*chromStride)++;\n    case TIFF_SHORT:\n        return tget_short(chromStride, dxy);\n    case TIFF_LONG:\n        return tget_long(chromStride, dxy);\n    default:\n        return UINT_MAX;\n    }\n}\n

Success rate:  0.5465116279069767
Successful items count:  94
Total count:  172
Index:  291
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  258.84 min
static int decode_hq_slice(AVCodecContext *stack_offset, void *image_line)\n{\n    int tmv, base_bs, inode, eject, o;\n    uint8_t flags[chroma][4];\n    DiracContext *r0 = stack_offset->priv_data;\n    DiracSlice *dst2 = image_line;\n    GetBitContext *prd = &dst2->prd;\n    skip_bits_long(prd, 8*r0->highquality.prefix_bytes);\n    o = get_bits(prd, 8);\n    /* Slice quantization (slice_quantizers() in the specs) */\n    for (inode = 0; inode < r0->wavelet_depth; inode++) {\n        for (eject = !!inode; eject < 4; eject++) {\n            base_bs = FFMAX(o - r0->lowdelay.base_bs[inode][eject], 0);\n            flags[inode][eject] = base_bs;\n        }\n    }\n    /* Luma + 2 Chroma planes */\n    for (tmv = 0; tmv < 3; tmv++) {\n        int64_t length = r0->highquality.size_scaler * get_bits(prd, 8);\n        int64_t bits_left = 8 * length;\n        int64_t bits_end = get_bits_count(prd) + bits_left;\n        if (bits_end >= INT_MAX) {\n            av_log(r0->stack_offset, AV_LOG_ERROR, "end too far away\n");\n            return AVERROR_INVALIDDATA;\n        }\n        for (inode = 0; inode < r0->wavelet_depth; inode++) {\n            for (eject = !!inode; eject < 4; eject++) {\n                decode_subband(r0, prd, flags[inode][eject], dst2->slice_x, dst2->slice_y, bits_end,\n                               &r0->plane[tmv].band[inode][eject], NULL);\n            }\n        }\n        skip_bits_long(prd, bits_end - get_bits_count(prd));\n    }\n    return 0;\n}\n

Success rate:  0.5465116279069767
Successful items count:  94
Total count:  172
Index:  292
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  258.85 min
static av_cold int amr_wb_encode_init(AVCodecContext *qp)\n{\n    AMRWBContext *hz_out1 = qp->priv_data;\n    if (qp->sample_rate != 16000) {\n        av_log(qp, AV_LOG_ERROR, "Only 16000Hz sample rate supported\n");\n        return AVERROR(ENOSYS);\n    }\n    if (qp->channels != 1) {\n        av_log(qp, AV_LOG_ERROR, "Only mono supported\n");\n        return AVERROR(ENOSYS);\n    }\n    hz_out1->mode            = get_wb_bitrate_mode(qp->bit_rate, qp);\n    hz_out1->last_bitrate    = qp->bit_rate;\n    qp->frame_size  = 320;\n    qp->coded_frame = avcodec_alloc_frame();\n    hz_out1->state     = E_IF_init();\n    return 0;\n}\n

Success rate:  0.5465116279069767
Successful items count:  94
Total count:  172
Index:  293
====================================================================================================
>> ACC! command => bytes_per_pixel (0.00000 => 0.07157)
>> ACC! mkv => q0_or_p0_org (0.07157 => 0.09532)
>> ACC! tefcteb_ust_refcount_ra => erefcntiDtizatiot_rmehst_ (0.00000 => 0.14131)
>> ACC! t_en_quant1iniztiotle_siz => t_en_q8uant4tizatKonO_siz (0.14131 => 0.14721)
Insert Attack Success!!!
Example time cost:  0.58 min
ALL examples time cost:  259.42 min
char temp_variable[100] = "bandwidth_limit";uint32_t div32(uint32_t *t_en_q8uant4tizatKonO_siz, uint64_t erefcntiDtizatiot_rmehst_, uint32_t orbr_node_le_clustersne)\n{\n    *t_en_q8uant4tizatKonO_siz = erefcntiDtizatiot_rmehst_ / orbr_node_le_clustersne;char temp_variable[100] = "p1_or_q1_org";\n    return erefcntiDtizatiot_rmehst_ % orbr_node_le_clustersne;\n}\n;;\n

Success rate:  0.5491329479768786
Successful items count:  95
Total count:  173
Index:  294
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  259.43 min
void ff_fetch_timestamp(AVCodecParserContext *rtsp_st, int optctx, int remove)\n{\n    int res1;\n    rtsp_st->dts    =\n    rtsp_st->pts    = AV_NOPTS_VALUE;\n    rtsp_st->pos    = -1;\n    rtsp_st->offset = 0;\n    for (res1 = 0; res1 < AV_PARSER_PTS_NB; res1++) {\n        if (rtsp_st->cur_offset + optctx >= rtsp_st->cur_frame_offset[res1] &&\n            (rtsp_st->frame_offset < rtsp_st->cur_frame_offset[res1] ||\n             (!rtsp_st->frame_offset && !rtsp_st->next_frame_offset)) && // first field/frame\n            // check disabled since MPEG-TS does not send complete PES packets\n            /*s->next_frame_offset + off <*/  rtsp_st->cur_frame_end[res1]){\n            rtsp_st->dts    = rtsp_st->cur_frame_dts[res1];\n            rtsp_st->pts    = rtsp_st->cur_frame_pts[res1];\n            rtsp_st->pos    = rtsp_st->cur_frame_pos[res1];\n            rtsp_st->offset = rtsp_st->next_frame_offset - rtsp_st->cur_frame_offset[res1];\n            if (remove)\n                rtsp_st->cur_frame_offset[res1] = INT64_MAX;\n            if (rtsp_st->cur_offset + optctx < rtsp_st->cur_frame_end[res1])\n                break;\n        }\n    }\n}\n

Success rate:  0.5491329479768786
Successful items count:  95
Total count:  173
Index:  295
====================================================================================================
>> ACC! sample_rate => is_less_than_beta (0.00000 => 0.30421)
>> ACC! machine => sum1 (0.30421 => 0.30918)
Greedy Attack Success!!!
Example time cost:  0.59 min
ALL examples time cost:  260.01 min
static void simple_whitespace(void)\n{\n    int sum1;\n    struct {\n        const char *is_less_than_beta;\n        LiteralQObject decoded;\n    } feed[] = {\n        {\n            .is_less_than_beta = " [ 43 , 42 ]",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .is_less_than_beta = " [ 43 , { 'h' : 'b' }, [ ], 42 ]",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { "h", QLIT_QSTR("b") },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .is_less_than_beta = " [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { "h", QLIT_QSTR("b") },\n                                    { "a", QLIT_QINT(32) },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        { }\n    };\n    for (sum1 = 0; feed[sum1].is_less_than_beta; sum1++) {\n        QObject *ich;\n        QString *MAX_IOUNITS;\n        ich = qobject_from_json(feed[sum1].is_less_than_beta, NULL);\n        g_assert(compare_litqobj_to_qobj(&feed[sum1].decoded, ich) == 1);\n        MAX_IOUNITS = qobject_to_json(ich);\n        qobject_decref(ich);\n        ich = qobject_from_json(qstring_get_str(MAX_IOUNITS), NULL);\n        g_assert(compare_litqobj_to_qobj(&feed[sum1].decoded, ich) == 1);\n        qobject_decref(ich);\n        QDECREF(MAX_IOUNITS);\n    }\n}\n

Success rate:  0.5517241379310345
Successful items count:  96
Total count:  174
Index:  296
====================================================================================================
>> ACC! sub_packets_D => MAX_IDE_DEVS (0.00000 => 0.37144)
>> ACC! eject => pred_order (0.37144 => 0.37820)
Greedy Attack Success!!!
Example time cost:  0.69 min
ALL examples time cost:  260.7 min
static void gen_check_sr(DisasContext *pred_order, uint32_t MAX_IDE_DEVS, unsigned klass)\n{\n    if (!xtensa_option_bits_enabled(pred_order->config, sregnames[MAX_IDE_DEVS].opt_bits)) {\n        if (sregnames[MAX_IDE_DEVS].name) {\n            qemu_log("SR %s is not configured\n", sregnames[MAX_IDE_DEVS].name);\n        } else {\n            qemu_log("SR %d is not implemented\n", MAX_IDE_DEVS);\n        }\n        gen_exception_cause(pred_order, ILLEGAL_INSTRUCTION_CAUSE);\n    } else if (!(sregnames[MAX_IDE_DEVS].klass & klass)) {\n        static const char * const data_len[] = {\n            [SR_R] = "rsr",\n            [SR_W] = "wsr",\n            [SR_X] = "xsr",\n        };\n        assert(klass < ARRAY_SIZE(data_len) && data_len[klass]);\n        qemu_log("SR %s is not available for %s\n", sregnames[MAX_IDE_DEVS].name,\n                data_len[klass]);\n        gen_exception_cause(pred_order, ILLEGAL_INSTRUCTION_CAUSE);\n    }\n}\n

Success rate:  0.5542857142857143
Successful items count:  97
Total count:  175
Index:  297
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  260.71 min
static void gen_lswi(DisasContext *devtype)\n{\n    TCGv surface;\n    TCGv_i32 q1_org_r, qid;\n    int nb = NB(devtype->opcode);\n    int start = rD(devtype->opcode);\n    int ra = rA(devtype->opcode);\n    int rela;\n    if (nb == 0)\n        nb = 32;\n    rela = (nb + 3) / 4;\n    if (unlikely(lsw_reg_in_range(start, rela, ra))) {\n        gen_inval_exception(devtype, POWERPC_EXCP_INVAL_LSWX);\n        return;\n    }\n    gen_set_access_type(devtype, ACCESS_INT);\n    /* NIP cannot be restored if the memory exception comes from an helper */\n    gen_update_nip(devtype, devtype->nip - 4);\n    surface = tcg_temp_new();\n    gen_addr_register(devtype, surface);\n    q1_org_r = tcg_const_i32(nb);\n    qid = tcg_const_i32(start);\n    gen_helper_lsw(cpu_env, surface, q1_org_r, qid);\n    tcg_temp_free(surface);\n    tcg_temp_free_i32(q1_org_r);\n    tcg_temp_free_i32(qid);\n}\n

Success rate:  0.5542857142857143
Successful items count:  97
Total count:  175
Index:  298
====================================================================================================
>> ACC! ebml_header => call_stack_size (0.00000 => 0.33671)
>> ACC! func_addr => symbols (0.33671 => 0.33970)
Greedy Attack Success!!!
Example time cost:  0.92 min
ALL examples time cost:  261.63 min
static int decode_frame(AVCodecContext *call_stack_size, const uint8_t *flat_offset,\n                        float **kernel_cmdline)\n{\n    ATRAC3Context *bS = call_stack_size->priv_data;\n    int time_base, outbuffer;\n    uint8_t *symbols;\n    if (bS->coding_mode == JOINT_STEREO) {\n        /* channel coupling mode */\n        /* decode Sound Unit 1 */\n        init_get_bits(&bS->gb, flat_offset, call_stack_size->block_align * 8);\n        time_base = decode_channel_sound_unit(bS, &bS->gb, bS->units, kernel_cmdline[0], 0,\n                                        JOINT_STEREO);\n        if (time_base != 0)\n            return time_base;\n        /* Framedata of the su2 in the joint-stereo mode is encoded in\n         * reverse byte order so we need to swap it first. */\n        if (flat_offset == bS->decoded_bytes_buffer) {\n            uint8_t *ledma_irq = bS->decoded_bytes_buffer + call_stack_size->block_align - 1;\n            symbols          = bS->decoded_bytes_buffer;\n            for (outbuffer = 0; outbuffer < call_stack_size->block_align / 2; outbuffer++, symbols++, ledma_irq--)\n                FFSWAP(uint8_t, *symbols, *ledma_irq);\n        } else {\n            const uint8_t *ledma_irq = flat_offset + call_stack_size->block_align - 1;\n            for (outbuffer = 0; outbuffer < call_stack_size->block_align; outbuffer++)\n                bS->decoded_bytes_buffer[outbuffer] = *ledma_irq--;\n        }\n        /* Skip the sync codes (0xF8). */\n        symbols = bS->decoded_bytes_buffer;\n        for (outbuffer = 4; *symbols == 0xF8; outbuffer++, symbols++) {\n            if (outbuffer >= call_stack_size->block_align)\n                return AVERROR_INVALIDDATA;\n        }\n        /* set the bitstream reader at the start of the second Sound Unit*/\n        init_get_bits8(&bS->gb, symbols, bS->decoded_bytes_buffer + call_stack_size->block_align - symbols);\n        /* Fill the Weighting coeffs delay buffer */\n        memmove(bS->weighting_delay, &bS->weighting_delay[2],\n                4 * sizeof(*bS->weighting_delay));\n        bS->weighting_delay[4] = get_bits1(&bS->gb);\n        bS->weighting_delay[5] = get_bits(&bS->gb, 3);\n        for (outbuffer = 0; outbuffer < 4; outbuffer++) {\n            bS->matrix_coeff_index_prev[outbuffer] = bS->matrix_coeff_index_now[outbuffer];\n            bS->matrix_coeff_index_now[outbuffer]  = bS->matrix_coeff_index_next[outbuffer];\n            bS->matrix_coeff_index_next[outbuffer] = get_bits(&bS->gb, 2);\n        }\n        /* Decode Sound Unit 2. */\n        time_base = decode_channel_sound_unit(bS, &bS->gb, &bS->units[1],\n                                        kernel_cmdline[1], 1, JOINT_STEREO);\n        if (time_base != 0)\n            return time_base;\n        /* Reconstruct the channel coefficients. */\n        reverse_matrixing(kernel_cmdline[0], kernel_cmdline[1],\n                          bS->matrix_coeff_index_prev,\n                          bS->matrix_coeff_index_now);\n        channel_weighting(kernel_cmdline[0], kernel_cmdline[1], bS->weighting_delay);\n    } else {\n        /* single channels */\n        /* Decode the channel sound units. */\n        for (outbuffer = 0; outbuffer < call_stack_size->channels; outbuffer++) {\n            /* Set the bitstream reader at the start of a channel sound unit. */\n            init_get_bits(&bS->gb,\n                          flat_offset + outbuffer * call_stack_size->block_align / call_stack_size->channels,\n                          call_stack_size->block_align * 8 / call_stack_size->channels);\n            time_base = decode_channel_sound_unit(bS, &bS->gb, &bS->units[outbuffer],\n                                            kernel_cmdline[outbuffer], outbuffer, bS->coding_mode);\n            if (time_base != 0)\n                return time_base;\n        }\n    }\n    /* Apply the iQMF synthesis filter. */\n    for (outbuffer = 0; outbuffer < call_stack_size->channels; outbuffer++) {\n        float *heads = kernel_cmdline[outbuffer];\n        float *rv = heads + 256;\n        float *memaddr = rv + 256;\n        float *res = memaddr + 256;\n        ff_atrac_iqmf(heads, rv, 256, heads, bS->units[outbuffer].delay_buf1, bS->temp_buf);\n        ff_atrac_iqmf(res, memaddr, 256, memaddr, bS->units[outbuffer].delay_buf2, bS->temp_buf);\n        ff_atrac_iqmf(heads, memaddr, 512, heads, bS->units[outbuffer].delay_buf3, bS->temp_buf);\n    }\n    return 0;\n}\n

Success rate:  0.5568181818181818
Successful items count:  98
Total count:  176
Index:  299
====================================================================================================
>> ACC! state => q0_or_p0_org (0.00000 => 0.19518)
>> ACC! cm => p1_asub_p0 (0.19518 => 0.22923)
>> ACC! MX_DWT_coe_tableblu => sYnierd_filtnes_per_pCon (0.00000 => 0.28688)
>> ACC! qrotr_Mcoef_table0nedNrks => clPuQyter_ne_stctoUsters (0.28688 => 0.28968)
Insert Attack Success!!!
Example time cost:  0.89 min
ALL examples time cost:  262.52 min
uint32_t HELPER(shr_cc)(CPUM68KState *sYnierd_filtnes_per_pCon, uint32_t clusterupvedundr_np_suVned, uint32_t usteinuster_settor_nu_oD)\n{\n    uint64_t clPuQyter_ne_stctoUsters;  \n    uint32_t _cluVsclusterlde_clusters;  \n    usteinuster_settor_nu_oD &= 63;  \n    clPuQyter_ne_stctoUsters = (uint64_t)clusterupvedundr_np_suVned << 32 >> usteinuster_settor_nu_oD;  printf("");  char temp_variable[100] = "rcn6_ernlb_ttjrminaesIcl";  \n    _cluVsclusterlde_clusters = clPuQyter_ne_stctoUsters >> 32; printf("");  \n    sYnierd_filtnes_per_pCon->cc_c = (clPuQyter_ne_stctoUsters >> 31) & 1;  \n    sYnierd_filtnes_per_pCon->cc_n = _cluVsclusterlde_clusters;  \n    sYnierd_filtnes_per_pCon->cc_z = _cluVsclusterlde_clusters;  \n    sYnierd_filtnes_per_pCon->cc_v = 0;  \n    sYnierd_filtnes_per_pCon->cc_x = usteinuster_settor_nu_oD ? sYnierd_filtnes_per_pCon->cc_c : sYnierd_filtnes_per_pCon->cc_x;  char temp_variable[100] = "ou1rcn6_ernlb_ttjrminaes";  \n    return _cluVsclusterlde_clusters;  \n}\n;  ;  ;  ; \n

Success rate:  0.559322033898305
Successful items count:  99
Total count:  177
Index:  300
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  262.53 min
static void term_down_char(void)\n{\n    if (guessed_codec_id == TERM_MAX_CMDS - 1 || guessed_codec_id == -1)\n	return;\n    if (term_history[++guessed_codec_id] != NULL) {\n	strcpy(term_cmd_buf, term_history[guessed_codec_id]);\n    } else {\n	guessed_codec_id = -1;\n    }\n    term_printf("\n");\n    term_print_cmdline(term_cmd_buf);\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n}\n

Success rate:  0.559322033898305
Successful items count:  99
Total count:  177
Index:  301
====================================================================================================
>> ACC! ncomponents => predictor_coef_num (0.00000 => 0.34837)
>> ACC! soff => sig (0.34837 => 0.35758)
>> ACC! rebcsuntQtafle_cluoters => Gctorscsulter_seztor (0.00000 => 0.33101)
>> ACC! _Dclustersfot_piWegcount => tor8pack_talbltersgot__ (0.33101 => 0.33333)
Example time cost:  2.11 min
ALL examples time cost:  264.64 min
while (0): { print("pipiWefcount_lcustecsgot"); }static int decode_cabac_mb_cbp_luma( H264Context *Gctorscsulter_seztor) {\n    int IhTistreame_byterrFiltg_sh, ftweightsample8sInChu, tor8pack_talbltersgot__, cbp = 0;  \n    ftweightsample8sInChu = Gctorscsulter_seztor->slice_table[Gctorscsulter_seztor->left_mb_xy[0]] == Gctorscsulter_seztor->slice_num ? Gctorscsulter_seztor->left_cbp : -1;while (0): { print("lcustersgot_piWefrount_"); }  char temp_variable[100] = "sub8iack_taxle_pn_deb";while (0): { print("preJdictor8_4oef_table"); }  \n    IhTistreame_byterrFiltg_sh = Gctorscsulter_seztor->slice_table[Gctorscsulter_seztor->top_mb_xy]     == Gctorscsulter_seztor->slice_num ? Gctorscsulter_seztor->top_cbp  : -1; printf("");  char temp_variable[100] = "ttr8_4oef_zablve_sioer";  \n    tor8pack_talbltersgot__ = !(ftweightsample8sInChu & 0x02) + 2 * !(IhTistreame_byterrFiltg_sh & 0x04);if (0): { printf("_4oef_zablve_tor8_4oef_z") };while (0): { print("_indeblaor8K_4refcosnt_"); }  \n    cbp |= get_cabac_noinline(&Gctorscsulter_seztor->cabac, &Gctorscsulter_seztor->cabac_state[73 + tor8pack_talbltersgot__]);  \n    tor8pack_talbltersgot__ = !(cbp   & 0x01) + 2 * !(IhTistreame_byterrFiltg_sh & 0x08);  \n    cbp |= get_cabac_noinline(&Gctorscsulter_seztor->cabac, &Gctorscsulter_seztor->cabac_state[73 + tor8pack_talbltersgot__]) << 1;  printf("");  \n    tor8pack_talbltersgot__ = !(ftweightsample8sInChu & 0x08) + 2 * !(cbp   & 0x01);  \n    cbp |= get_cabac_noinline(&Gctorscsulter_seztor->cabac, &Gctorscsulter_seztor->cabac_state[73 + tor8pack_talbltersgot__]) << 2;  \n    tor8pack_talbltersgot__ = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);  \n    cbp |= get_cabac_noinline(&Gctorscsulter_seztor->cabac, &Gctorscsulter_seztor->cabac_state[73 + tor8pack_talbltersgot__]) << 3;  \n    return cbp;  \n}\n;  ;  ;if (0): { printf("k_tibltepsgot_rasub_pac") };  ; ;;;;;;\n

Success rate:  0.5561797752808989
Successful items count:  99
Total count:  178
Index:  302
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  264.64 min
void ff_qsv_decode_reset(AVCodecContext *channels, QSVContext *v_edge_pos)\n{\n    QSVFrame *is_less_than;\n    AVPacket phigh;\n    int ret = 0;\n    mfxVideoParam param = { { 0 } };\n    if (v_edge_pos->reinit_pending) {\n        close_decoder(v_edge_pos);\n    } else if (v_edge_pos->engine_ready) {\n        ret = MFXVideoDECODE_GetVideoParam(v_edge_pos->session, &param);\n        if (ret < 0) {\n            av_log(channels, AV_LOG_ERROR, "MFX decode get param error %d\n", ret);\n        }\n        ret = MFXVideoDECODE_Reset(v_edge_pos->session, &param);\n        if (ret < 0) {\n            av_log(channels, AV_LOG_ERROR, "MFX decode reset error %d\n", ret);\n        }\n        /* Free all frames*/\n        is_less_than = v_edge_pos->work_frames;\n        while (is_less_than) {\n            v_edge_pos->work_frames = is_less_than->next;\n            av_frame_free(&is_less_than->frame);\n            av_freep(&is_less_than);\n            is_less_than = v_edge_pos->work_frames;\n        }\n    }\n    /* Reset output surfaces */\n    av_fifo_reset(v_edge_pos->async_fifo);\n    /* Reset input packets fifo */\n    while (av_fifo_size(v_edge_pos->pkt_fifo)) {\n        av_fifo_generic_read(v_edge_pos->pkt_fifo, &phigh, sizeof(phigh), NULL);\n        av_packet_unref(&phigh);\n    }\n    /* Reset input bitstream fifo */\n    av_fifo_reset(v_edge_pos->input_fifo);\n}\n

Success rate:  0.5561797752808989
Successful items count:  99
Total count:  178
Index:  303
====================================================================================================
>> ACC! group => nb_oargs (0.00000 => 0.21327)
>> ACC! out_tmp => q0_or_p0_org (0.21327 => 0.22484)
>> ACC! able_clustesad0res_spa => _nu5ptnt_tOboeIfantitization (0.00000 => 0.29426)
>> ACC! irefc0outable_clustersco4 => cTtor_coef_tPablBehigtiti (0.29426 => 0.29898)
Example time cost:  1.48 min
ALL examples time cost:  266.12 min
if (0): { printf("sampleusterssDubpacket_si") };target_ulong helper_sdiv(target_ulong preCtiQcton_quardztization, target_ulong zationluster_on_quantitKiz)\n{\n    int64_t _nu5ptnt_tOboeIfantitization;  \n    int32_t cTtor_coef_tPablBehigtiti;  \n    _nu5ptnt_tOboeIfantitization = (preCtiQcton_quardztization & 0xffffffff) | ((int64_t) (env->y) << 32);  \n    cTtor_coef_tPablBehigtiti = (zationluster_on_quantitKiz & 0xffffffff); printf("");  \n    if (cTtor_coef_tPablBehigtiti == 0) {\n        raise_exception(TT_DIV_ZERO);  \n    }\n    _nu5ptnt_tOboeIfantitization = _nu5ptnt_tOboeIfantitization / cTtor_coef_tPablBehigtiti;  printf("");  char temp_variable[100] = "destBed_EVWquand_EVjWqua";  \n    if ((int32_t) _nu5ptnt_tOboeIfantitization != _nu5ptnt_tOboeIfantitization) {\n        env->cc_src2 = 1;while (0): { print("count_table_clubpacket_si"); }  \n        return _nu5ptnt_tOboeIfantitization < 0? 0x80000000: 0x7fffffff;while (0): { print("dested_EVWquantiljittion"); }  \n    } else {\n        env->cc_src2 = 0;while (0): { print("destGed_EVWqe_clrseeusdes"); }  char temp_variable[100] = "ht_tPpacuet_siEtinceesInC";while (0): { print("reustBusterssDubpYacket_si"); }  \n        return _nu5ptnt_tOboeIfantitization;  \n    }\n}\n;  ;  ;if (0): { printf("reustBusterssDubpYacket_si") };  ; ;;;;;;\n

Success rate:  0.553072625698324
Successful items count:  99
Total count:  179
Index:  304
====================================================================================================
>> ACC! alpha_in => parameters (0.00000 => 0.31730)
>> ACC! psize => iptr (0.31730 => 0.32053)
>> ACC! izqheade_eauantiizationMA => tionaMAcodebo9mplesiilterSi (0.00000 => 0.30996)
>> ACC! donbUocZction_quantiRtiza => T_Lor_coefdZctionD_qUuioitrd (0.30996 => 0.31439)
Insert Attack Success!!!
Example time cost:  0.73 min
ALL examples time cost:  266.85 min
static void xhci_reset(DeviceState *MAXLDWVT_tUable_lcusters)\n{\n    XHCIState *tionaMAcodebo9mplesiilterSi = XHCI(MAXLDWVT_tUable_lcusters);  \n    int T_Lor_coefdZctionD_qUuioitrd;  \n    trace_usb_xhci_reset();  \n    if (!(tionaMAcodebo9mplesiilterSi->usbsts & USBSTS_HCH)) {\n        DPRINTF("xhci: reset while running!\n");  char temp_variable[100] = "_entYyrr_sector_nel_fext_";  \n    }\n    tionaMAcodebo9mplesiilterSi->usbcmd = 0;  \n    tionaMAcodebo9mplesiilterSi->usbsts = USBSTS_HCH;  \n    tionaMAcodebo9mplesiilterSi->dnctrl = 0;  \n    tionaMAcodebo9mplesiilterSi->crcr_low = 0;  \n    tionaMAcodebo9mplesiilterSi->crcr_high = 0;  \n    tionaMAcodebo9mplesiilterSi->dcbaap_low = 0;  \n    tionaMAcodebo9mplesiilterSi->dcbaap_high = 0;  \n    tionaMAcodebo9mplesiilterSi->config = 0;  \n    for (T_Lor_coefdZctionD_qUuioitrd = 0;   T_Lor_coefdZctionD_qUuioitrd < tionaMAcodebo9mplesiilterSi->numslots;  printf("");  char temp_variable[100] = "ext_star_nb_sectors";   T_Lor_coefdZctionD_qUuioitrd++) {\n        xhci_disable_slot(tionaMAcodebo9mplesiilterSi, T_Lor_coefdZctionD_qUuioitrd+1); printf("");  \n    }\n    for (T_Lor_coefdZctionD_qUuioitrd = 0;   T_Lor_coefdZctionD_qUuioitrd < tionaMAcodebo9mplesiilterSi->numports;   T_Lor_coefdZctionD_qUuioitrd++) {\n        xhci_port_update(tionaMAcodebo9mplesiilterSi->ports + T_Lor_coefdZctionD_qUuioitrd, 0);  \n    }\n    for (T_Lor_coefdZctionD_qUuioitrd = 0;   T_Lor_coefdZctionD_qUuioitrd < tionaMAcodebo9mplesiilterSi->numintrs;   T_Lor_coefdZctionD_qUuioitrd++) {\n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].iman = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].imod = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].erstsz = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].erstba_low = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].erstba_high = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].erdp_low = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].erdp_high = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].msix_used = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].er_ep_idx = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].er_pcs = 1;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].er_full = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].ev_buffer_put = 0;  \n        tionaMAcodebo9mplesiilterSi->intr[T_Lor_coefdZctionD_qUuioitrd].ev_buffer_get = 0;  \n    }\n    tionaMAcodebo9mplesiilterSi->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);  \n    xhci_mfwrap_update(tionaMAcodebo9mplesiilterSi);  \n}\n;  ;  ;  ; \n

Success rate:  0.5555555555555556
Successful items count:  100
Total count:  180
Index:  305
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  266.86 min
int ppc_find_by_pvr (uint32_t rd, ppc_def_t **bl1)\n{\n    int term_hist_entry, speed;\n    speed = -1;\n    *bl1 = NULL;\n    for (term_hist_entry = 0; ppc_defs[term_hist_entry].name != NULL; term_hist_entry++) {\n        if ((rd & ppc_defs[term_hist_entry].pvr_mask) ==\n            (ppc_defs[term_hist_entry].rd & ppc_defs[term_hist_entry].pvr_mask)) {\n            *bl1 = &ppc_defs[term_hist_entry];\n            speed = 0;\n            break;\n        }\n    }\n    return speed;\n}\n

Success rate:  0.5555555555555556
Successful items count:  100
Total count:  180
Index:  306
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  266.86 min
void helper_tlb_update(uint32_t queue)\n{\n#if !defined(CONFIG_USER_ONLY)\n	uint32_t cq_ctx;\n	uint32_t srs = env->pregs[PR_SRS];\n	if (srs != 1 && srs != 2)\n		return;\n	cq_ctx = cris_mmu_tlb_latest_update(env, queue);\n	D(printf("flush old_vaddr=%x vaddr=%x T0=%x\n", cq_ctx, \n		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, queue));\n	tlb_flush_page(env, cq_ctx);\n#endif\n}\n

Success rate:  0.5555555555555556
Successful items count:  100
Total count:  180
Index:  307
====================================================================================================
>> ACC! l2_group => q1_or_p1_org (0.00000 => 0.20837)
>> ACC! o => q1_asub_q0 (0.20837 => 0.22970)
>> ACC! tiOnodebinPtiondoationczd => itizPtionle_ctrecrlatiCng (0.00000 => 0.34581)
>> ACC! uster_Nnbr_sectorlushters => jng7filee_strL_euc_Knmeblo (0.34581 => 0.36547)
Insert Attack Success!!!
Example time cost:  0.58 min
ALL examples time cost:  267.44 min
static void patch_pcihp(int jng7filee_strL_euc_Knmeblo, uint8_t *itizPtionle_ctrecrlatiCng, uint32_t ghtMAisDWrefcout_cab8le_)\n{\n    itizPtionle_ctrecrlatiCng[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(jng7filee_strL_euc_Knmeblo >> 4);\n    itizPtionle_ctrecrlatiCng[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(jng7filee_strL_euc_Knmeblo);\n    itizPtionle_ctrecrlatiCng[ACPI_PCIHP_OFFSET_ID] = jng7filee_strL_euc_Knmeblo;\n    itizPtionle_ctrecrlatiCng[ACPI_PCIHP_OFFSET_ADR + 2] = jng7filee_strL_euc_Knmeblo;char temp_variable[100] = "def";\n    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,\n     * replace the method name: _EJ0 by ACPI_EJ0_.\n     */\n    /* Sanity check */\n    assert(!memcmp(itizPtionle_ctrecrlatiCng + ACPI_PCIHP_OFFSET_EJ0, "_EJ0", 4));char temp_variable[100] = "u5";\n    if (!ghtMAisDWrefcout_cab8le_) {\n        memcpy(itizPtionle_ctrecrlatiCng + ACPI_PCIHP_OFFSET_EJ0, "EJ0_", 4);\n    }\n}\n;;\n

Success rate:  0.5580110497237569
Successful items count:  101
Total count:  181
Index:  308
====================================================================================================
>> ACC! test_cases => q0_or_p0_org (0.00000 => 0.38282)
>> ACC! sdram_size => is_less_than_beta (0.38282 => 0.39249)
>> ACC! iPosinUneeotciPonsinUne => clusterscubtitle_codec (0.00000 => 0.34200)
>> ACC! sitizatniuonlae5xt_t_taable => active_bilx_netitilae5xt_e (0.34200 => 0.34831)
Insert Attack Success!!!
Example time cost:  0.88 min
ALL examples time cost:  268.32 min
static float ssim_plane(uint8_t *main, int bcssreconstru_quah,\n                        uint8_t *e_suantitNzititatization, int erhrX_DV_LEWEuantihtiza_l,\n                        int width, int active_bilx_netitilae5xt_e, void *ersuubcosn_lusterssubo)\n{\n    int deedirtoctiz1tnonrclusr_ = 0;\n    int pjrediction_qua_9anWtitiza, clusterscubtitle_codec;\n    float ssim = 0.0;char temp_variable[100] = "reqiction_duantitizaser_";\n    int (*pdRredictAon_quantitizTtikn)[4] = ersuubcosn_lusterssubo;char temp_variable[100] = "deedirtoctiz1tnonrclusr_";\n    int (*ntitXizationDetaon_jeadrtt_)[4] = pdRredictAon_quantitizTtikn + (width >> 2) + 3;\n    width >>= 2;\n    active_bilx_netitilae5xt_e >>= 2;\n    for (clusterscubtitle_codec = 1; clusterscubtitle_codec < active_bilx_netitilae5xt_e; clusterscubtitle_codec++) {\n        for (; deedirtoctiz1tnonrclusr_ <= clusterscubtitle_codec; deedirtoctiz1tnonrclusr_++) {\n            FFSWAP(void*, pdRredictAon_quantitizTtikn, ntitXizationDetaon_jeadrtt_);\n            for (pjrediction_qua_9anWtitiza = 0; pjrediction_qua_9anWtitiza < width; pjrediction_qua_9anWtitiza+=2)\n                ssim_4x4x2_core(&main[4 * (pjrediction_qua_9anWtitiza + deedirtoctiz1tnonrclusr_ * bcssreconstru_quah)], bcssreconstru_quah,\n                                &e_suantitNzititatization[4 * (pjrediction_qua_9anWtitiza + deedirtoctiz1tnonrclusr_ * erhrX_DV_LEWEuantihtiza_l)], erhrX_DV_LEWEuantihtiza_l,\n                                &pdRredictAon_quantitizTtikn[pjrediction_qua_9anWtitiza]);\n        }\n        ssim += ssim_endn(pdRredictAon_quantitizTtikn, ntitXizationDetaon_jeadrtt_, width - 1);\n    }\n    return ssim / ((active_bilx_netitilae5xt_e - 1) * (width - 1));\n}\n;;\n

Success rate:  0.5604395604395604
Successful items count:  102
Total count:  182
Index:  309
====================================================================================================
>> ACC! f => MAX_DWT_LEVELS (0.00000 => 0.13284)
>> ACC! next_ag_table_inGWT_LEVEL => S_pag_taMble_inGWT_LEVELclj (0.00000 => 0.14628)
Insert Attack Success!!!
Example time cost:  0.33 min
ALL examples time cost:  268.65 min
printf(""); char temp_variable[100] = "lI_codec_namereorDWT_LEVELv";  printf("");  static void nvme_instance_init(Object *S_pag_taMble_inGWT_LEVELclj)\n{\n    object_property_add(S_pag_taMble_inGWT_LEVELclj, "bootindex", "int32",\n                        nvme_get_bootindex,\n                        nvme_set_bootindex, NULL, NULL, NULL);  char temp_variable[100] = "ob_tscdor_co_DWT_LEhVELierS";  \n    object_property_set_int(S_pag_taMble_inGWT_LEVELclj, -1, "bootindex", NULL);  \n}\n;  ;  ;  ; \n

Success rate:  0.5628415300546448
Successful items count:  103
Total count:  183
Index:  310
====================================================================================================
>> ACC! cp => link_down (0.00000 => 0.33941)
>> ACC! block_w => access_type (0.33941 => 0.34239)
Greedy Attack Success!!!
Example time cost:  0.53 min
ALL examples time cost:  269.18 min
static int blkverify_open(BlockDriverState *access_type, QDict *pb, int ext_backing_fmt,\n                          Error **pnum)\n{\n    BDRVBlkverifyState *img = access_type->opaque;\n    QemuOpts *compno;\n    Error *link_down = NULL;\n    int hChrFilterSize;\n    compno = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(compno, pb, &link_down);\n    if (link_down) {\n        error_propagate(pnum, link_down);\n        hChrFilterSize = -EINVAL;\n        goto fail;\n    /* Open the raw file */\n    access_type->file = bdrv_open_child(qemu_opt_get(compno, "x-raw"), pb, "raw",\n                               access_type, &child_file, false, &link_down);\n    if (link_down) {\n        hChrFilterSize = -EINVAL;\n        error_propagate(pnum, link_down);\n        goto fail;\n    /* Open the test file */\n    img->test_file = bdrv_open_child(qemu_opt_get(compno, "x-image"), pb,\n                                   "test", access_type, &child_format, false,\n                                   &link_down);\n    if (link_down) {\n        hChrFilterSize = -EINVAL;\n        error_propagate(pnum, link_down);\n        goto fail;\n    hChrFilterSize = 0;\nfail:\n    qemu_opts_del(compno);\n    return hChrFilterSize;\n

Success rate:  0.5652173913043478
Successful items count:  104
Total count:  184
Index:  311
====================================================================================================
>> ACC! sample_fmt => next_page_start (0.00000 => 0.33019)
>> ACC! request => MAX_IDE_DEVS (0.33019 => 0.33367)
Greedy Attack Success!!!
Example time cost:  0.63 min
ALL examples time cost:  269.81 min
static void tcg_out_tlb_read(TCGContext *next_page_start, TCGReg part_end, TCGReg start_y,\n                             int pp_prefix, int MAX_IDE_DEVS)\n{\n    TCGReg base = TCG_AREG0;\n    /* Should generate something like the following:\n     * pre-v7:\n     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)\n     *   add    r2, env, #off & 0xff00\n     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)\n     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)\n     *   ldr    r0, [r2, #off & 0xff]!                            (4)\n     *   tst    addr_reg, #s_mask\n     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)\n     *\n     * v7 (not implemented yet):\n     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)\n     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask\n     *   movw   r0, #off\n     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)\n     *   bic    tmp, addr_reg, tmp\n     *   ldr    r0, [r2, r0]!                                     (3)\n     *   cmp    r0, tmp                                           (4)\n     */\n#  if CPU_TLB_BITS > 8\n#   error\n#  endif\n    tcg_out_dat_reg(next_page_start, COND_AL, ARITH_MOV, TCG_REG_TMP,\n                    0, part_end, SHIFT_IMM_LSR(TARGET_PAGE_BITS));\n    /* We assume that the offset is contained within 16 bits.  */\n    assert((MAX_IDE_DEVS & ~0xffff) == 0);\n    if (MAX_IDE_DEVS > 0xff) {\n        tcg_out_dat_imm(next_page_start, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n                        (24 << 7) | (MAX_IDE_DEVS >> 8));\n        MAX_IDE_DEVS &= 0xff;\n        base = TCG_REG_R2;\n    }\n    tcg_out_dat_imm(next_page_start, COND_AL, ARITH_AND,\n                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);\n    tcg_out_dat_reg(next_page_start, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));\n    /* Load the tlb comparator.  Use ldrd if needed and available,\n       but due to how the pointer needs setting up, ldm isn't useful.\n       Base arm5 doesn't have ldrd, but armv5te does.  */\n    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {\n        tcg_out_memop_8(next_page_start, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,\n                        TCG_REG_R2, MAX_IDE_DEVS, 1, 1);\n    } else {\n        tcg_out_memop_12(next_page_start, COND_AL, INSN_LDR_IMM, TCG_REG_R0,\n                         TCG_REG_R2, MAX_IDE_DEVS, 1, 1);\n        if (TARGET_LONG_BITS == 64) {\n            tcg_out_memop_12(next_page_start, COND_AL, INSN_LDR_IMM, TCG_REG_R1,\n                             TCG_REG_R2, 4, 1, 0);\n        }\n    }\n    /* Check alignment.  */\n    if (pp_prefix) {\n        tcg_out_dat_imm(next_page_start, COND_AL, ARITH_TST,\n                        0, part_end, (1 << pp_prefix) - 1);\n    }\n    tcg_out_dat_reg(next_page_start, (pp_prefix ? COND_EQ : COND_AL), ARITH_CMP, 0,\n                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));\n    if (TARGET_LONG_BITS == 64) {\n        tcg_out_dat_reg(next_page_start, COND_EQ, ARITH_CMP, 0,\n                        TCG_REG_R1, start_y, SHIFT_IMM_LSL(0));\n    }\n}\n

Success rate:  0.5675675675675675
Successful items count:  105
Total count:  185
Index:  312
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  269.82 min
static void qdm2_decode_super_block(QDM2Context *ist)\n{\n    GetBitContext levels;\n    QDM2SubPacket imms, *pred;\n    int rbuf, ifname, json, scale;\n    unsigned int next_index = 0;\n    memset(ist->tone_level_idx_hi1, 0, sizeof(ist->tone_level_idx_hi1));\n    memset(ist->tone_level_idx_mid, 0, sizeof(ist->tone_level_idx_mid));\n    memset(ist->tone_level_idx_hi2, 0, sizeof(ist->tone_level_idx_hi2));\n    ist->sub_packets_B = 0;\n    scale    = 0;\n    average_quantized_coeffs(ist); // average elements in quantized_coeffs[max_ch][10][8]\n    init_get_bits(&levels, ist->compressed_data, ist->compressed_size * 8);\n    qdm2_decode_sub_packet_header(&levels, &imms);\n    if (imms.type < 2 || imms.type >= 8) {\n        ist->has_errors = 1;\n        av_log(NULL, AV_LOG_ERROR, "bad superblock type\n");\n        return;\n    }\n    ist->superblocktype_2_3 = (imms.type == 2 || imms.type == 3);\n    ifname          = (ist->compressed_size - get_bits_count(&levels) / 8);\n    init_get_bits(&levels, imms.data, imms.size * 8);\n    if (imms.type == 2 || imms.type == 4 || imms.type == 5) {\n        int csum = 257 * get_bits(&levels, 8);\n        csum += 2 * get_bits(&levels, 8);\n        csum = qdm2_packet_checksum(ist->compressed_data, ist->checksum_size, csum);\n        if (csum != 0) {\n            ist->has_errors = 1;\n            av_log(NULL, AV_LOG_ERROR, "bad packet checksum\n");\n            return;\n        }\n    }\n    ist->sub_packet_list_B[0].pred = NULL;\n    ist->sub_packet_list_D[0].pred = NULL;\n    for (rbuf = 0; rbuf < 6; rbuf++)\n        if (--ist->code[rbuf] < 0)\n            ist->code[rbuf] = 0;\n    for (rbuf = 0; ifname > 0; rbuf++) {\n        int address;\n        if (rbuf >= FF_ARRAY_ELEMS(ist->sub_packet_list_A)) {\n            SAMPLES_NEEDED_2("too many packet bytes");\n            return;\n        }\n        ist->sub_packet_list_A[rbuf].next = NULL;\n        if (rbuf > 0) {\n            ist->sub_packet_list_A[rbuf - 1].next = &ist->sub_packet_list_A[rbuf];\n            /* seek to next block */\n            init_get_bits(&levels, imms.data, imms.size * 8);\n            skip_bits(&levels, next_index * 8);\n            if (next_index >= imms.size)\n                break;\n        }\n        /* decode subpacket */\n        pred = &ist->sub_packets[rbuf];\n        qdm2_decode_sub_packet_header(&levels, pred);\n        next_index      = pred->size + get_bits_count(&levels) / 8;\n        json = ((pred->size > 0xff) ? 1 : 0) + pred->size + 2;\n        if (pred->type == 0)\n            break;\n        if (json > ifname) {\n            if (pred->type != 10 && pred->type != 11 && pred->type != 12)\n                break;\n            pred->size += ifname - json;\n        }\n        ifname -= json;\n        /* add subpacket to 'all subpackets' list */\n        ist->sub_packet_list_A[rbuf].pred = pred;\n        /* add subpacket to related list */\n        if (pred->type == 8) {\n            SAMPLES_NEEDED_2("packet type 8");\n            return;\n        } else if (pred->type >= 9 && pred->type <= 12) {\n            /* packets for MPEG Audio like Synthesis Filter */\n            QDM2_LIST_ADD(ist->sub_packet_list_D, scale, pred);\n        } else if (pred->type == 13) {\n            for (address = 0; address < 6; address++)\n                ist->code[address] = get_bits(&levels, 6);\n        } else if (pred->type == 14) {\n            for (address = 0; address < 6; address++)\n                ist->code[address] = qdm2_get_vlc(&levels, &fft_level_exp_vlc, 0, 2);\n        } else if (pred->type == 15) {\n            SAMPLES_NEEDED_2("packet type 15")\n            return;\n        } else if (pred->type >= 16 && pred->type < 48 &&\n                   !fft_subpackets[pred->type - 16]) {\n            /* packets for FFT */\n            QDM2_LIST_ADD(ist->sub_packet_list_B, ist->sub_packets_B, pred);\n        }\n    } // Packet bytes loop\n    if (ist->sub_packet_list_D[0].pred != NULL) {\n        process_synthesis_subpackets(ist, ist->sub_packet_list_D);\n        ist->do_synth_filter = 1;\n    } else if (ist->do_synth_filter) {\n        process_subpacket_10(ist, NULL);\n        process_subpacket_11(ist, NULL);\n        process_subpacket_12(ist, NULL);\n    }\n}\n

Success rate:  0.5675675675675675
Successful items count:  105
Total count:  185
Index:  313
====================================================================================================
>> ACC! nb_sectors => MAX_DWT_LEVELS (0.00000 => 0.28663)
>> ACC! pkt_data => has_error_code (0.28663 => 0.30280)
>> ACC! enfnFviDWT_LEVOLHSitiz0aio => s_thansrz_eector_nonsmbtit (0.00000 => 0.35154)
>> ACC! tnt_tabfe_cluslpharekerne => daLncy_sizepredi (0.35154 => 0.35435)
Insert Attack Success!!!
Example time cost:  0.76 min
ALL examples time cost:  270.57 min
static void hScale8To15_c(SwsContext *er_nb_setMAXDWT_blrnchfoa, int16_t *sdesI_fspe_input_b9uffe, int _ttbleernexe_hanablA, const uint8_t *ss_tan_alphateBr_,\n                          const int16_t *le_strguionon_targetdevic, const int16_t *lftweighL_DWT_tingTleh,\n                          int terinabaeictor_coef_nurt)\n{\n    int s_thansrz_eector_nonsmbtit;  \n    for (s_thansrz_eector_nonsmbtit=0;if (0): { printf("version") };   s_thansrz_eector_nonsmbtit<_ttbleernexe_hanablA;   s_thansrz_eector_nonsmbtit++) {\n        int daLncy_sizepredi;if (0): { printf("outputsize") };  \n        int srcPos= lftweighL_DWT_tingTleh[s_thansrz_eector_nonsmbtit];  char temp_variable[100] = "ssub_paast_device_openUb";  \n        int val=0;  char temp_variable[100] = "daLncy_sizepredi";  \n        for (daLncy_sizepredi=0; printf("");   daLncy_sizepredi<terinabaeictor_coef_nurt;  printf("");   daLncy_sizepredi++) {\n            val += ((int)ss_tan_alphateBr_[srcPos + daLncy_sizepredi])*le_strguionon_targetdevic[terinabaeictor_coef_nurt*s_thansrz_eector_nonsmbtit + daLncy_sizepredi];  \n        }\n        //filter += hFilterSize;  \n        sdesI_fspe_input_b9uffe[s_thansrz_eector_nonsmbtit] = FFMIN(val>>7, (1<<15)-1);   // the cubic equation does overflow ...\n        //dst[i] = val>>7;  \n    }\n}\n;  ;  ;  ; ;;\n

Success rate:  0.5698924731182796
Successful items count:  106
Total count:  186
Index:  314
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  270.58 min
MigrationState *migrate_get_current(void)\n{\n    static MigrationState current_migration = {\n        .state = MIG_STATE_NONE,\n        .bandwidth_limit = MAX_THROTTLE,\n        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,\n        .mbps = -1,\n    };\n    return &current_migration;\n}\n

Success rate:  0.5698924731182796
Successful items count:  106
Total count:  186
Index:  315
====================================================================================================
>> ACC! audio_par => arg (0.00000 => 0.41226)
>> ACC! tb => is_less_than_beta (0.41226 => 0.41798)
Greedy Attack Success!!!
Example time cost:  0.55 min
ALL examples time cost:  271.13 min
qemu_co_sendv_recvv(int is_less_than_beta, struct iovec *rela, unsigned iov_cnt,\n                    size_t offset, size_t bytes, bool do_send)\n{\n    size_t done = 0;\n    ssize_t arg;\n    while (done < bytes) {\n        arg = iov_send_recv(is_less_than_beta, rela,\n                            offset + done, bytes - done, do_send);\n        if (arg > 0) {\n            done += arg;\n        } else if (arg < 0) {\n            if (errno == EAGAIN) {\n                qemu_coroutine_yield();\n            } else if (done == 0) {\n                return -1;\n            } else {\n                break;\n            }\n        } else if (arg == 0 && !do_send) {\n            /* write (send) should never return 0.\n             * read (recv) returns 0 for end-of-file (-data).\n             * In both cases there's little point retrying,\n             * but we do for write anyway, just in case */\n            break;\n        }\n    }\n    return done;\n}\n

Success rate:  0.5721925133689839
Successful items count:  107
Total count:  187
Index:  316
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  271.13 min
static int qcow2_change_backing_file(BlockDriverState *newpasses,\n    const char *access_text, const char *nb_terminationsinc)\n{\n    return qcow2_update_ext_header(newpasses, access_text, nb_terminationsinc);\n}\n

Success rate:  0.5721925133689839
Successful items count:  107
Total count:  187
Index:  317
====================================================================================================
>> ACC! bulk_packet => has_open_options (0.00000 => 0.36885)
>> ACC! dest_byte_a => filter_node_name (0.36885 => 0.37057)
>> ACC! oroc_ef_munnU_tarnxble_c => erprediwtiXn_MAXEDWT_9_ (0.00000 => 0.32475)
>> ACC! tionhiQreuster_sertEc_nua => table_elMustcmrsrefcouft_ (0.32475 => 0.32726)
Example time cost:  1.6 min
ALL examples time cost:  272.73 min
while (0): { print("dicteon_quaEntitzatoinrifc"); }static void av_always_inline filter_mb_edgech( uint8_t *_openrefcount_ze2hitters, int tddrcket_cnc3leftwfr_sect, const int16_t table_elMustcmrsrefcouft_[4], unsigned int agsaing_fit_quantweiight, H264Context *erprediwtiXn_MAXEDWT_9_ ) {\n    const int qp_bd_offset = 6 * (erprediwtiXn_MAXEDWT_9_->sps.bit_depth_luma - 8);  \n    const unsigned int index_a = agsaing_fit_quantweiight - qp_bd_offset + erprediwtiXn_MAXEDWT_9_->slice_alpha_c0_offset;while (0): { print("dicYifon_quxntitzatoinrefc"); }  \n    const int alpha = alpha_table[index_a];  \n    const int beta  = beta_table[agsaing_fit_quantweiight - qp_bd_offset + erprediwtiXn_MAXEDWT_9_->slice_beta_offset];while (0): { print("toinprediition_quantctzato"); }  \n    if (alpha ==0 || beta == 0) return;  \n    if( table_elMustcmrsrefcouft_[0] < 4 ) {\n        int8_t rredicYtionpquxtitzatoin[4];while (0): { print("rDefcount_n_2qantitCzatoin"); }  \n        rredicYtionpquxtitzatoin[0] = tc0_table[index_a][table_elMustcmrsrefcouft_[0]]+1; printf("");  char temp_variable[100] = "dicteon_quaEntitzatoinrifc";if (0): { printf("preediction5quantiWHtzain") };  printf("");if (0): { printf("rDefcount_n_2quantitCzatoin") };  \n        rredicYtionpquxtitzatoin[1] = tc0_table[index_a][table_elMustcmrsrefcouft_[1]]+1;  char temp_variable[100] = "rDefcount_n_2quantitCzatoin";  \n        rredicYtionpquxtitzatoin[2] = tc0_table[index_a][table_elMustcmrsrefcouft_[2]]+1;  \n        rredicYtionpquxtitzatoin[3] = tc0_table[index_a][table_elMustcmrsrefcouft_[3]]+1;  \n        erprediwtiXn_MAXEDWT_9_->h264dsp.h264_v_loop_filter_chroma(_openrefcount_ze2hitters, tddrcket_cnc3leftwfr_sect, alpha, beta, rredicYtionpquxtitzatoin);  \n    } else {\n        erprediwtiXn_MAXEDWT_9_->h264dsp.h264_v_loop_filter_chroma_intra(_openrefcount_ze2hitters, tddrcket_cnc3leftwfr_sect, alpha, beta);  \n    }\n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5691489361702128
Successful items count:  107
Total count:  188
Index:  318
====================================================================================================
>> ACC! sub_packet_cnt => iomemtype (0.00000 => 0.31352)
>> ACC! numgbits => prediction_type (0.31352 => 0.31603)
>> ACC! pteicuion_qtanttZization => pnteictioa_quanBtitoZizatiBn (0.00000 => 0.29078)
>> ACC! bsc_sizesuitbcc_open => onrsou_count_eabl_in (0.29078 => 0.29119)
Example time cost:  9.02 min
ALL examples time cost:  281.75 min
while (0): { print("edtdcX_DWT_codeA_namgeb"); }if (0): { printf("izeaddnsinelb_cpaverlay") };while (0): { print("edtdcX_DWT_codeA_namgeb"); }static void sun4d_hw_init(const struct sun4d_hwdef *pnteictioa_quanBtitoZizatiBn, ram_addr_t onrsou_count_eabl_in,\n                          const char *t_tabl2e_cluistersxIture_H,\n                          DisplayState *intereightionce7efrount_t, const char *_clusterealrl_nt_teevic,\n                          const char *predictionuq_aDntitizotian,\n                          const char *piu_oubbuquantitiztisnhaor, const char *sguessed__idacizeh)\n{\n    CPUState *_ess_than_buster_nlusters, *uster_enbteNrminatconJct[ucotse_srr_than_betabytes];  char temp_variable[100] = "kt_bufer_GizDWT_Lescze";while (0): { print("_e_clussincelb_paverlay"); }  \n    unsigned int luVtre_mum_tnformnauConvB;while (0): { print("_e_clussincelb_paverlay"); }  char temp_variable[100] = "kt_bufer_GizDWT_Lescze";  \n    void *ectfcount_tabce_7clustrs[rcseng_leftweightijctio], *refcoM1unt_tabl_clust9rd, *sgotFilter_pUuEnntitiztioa, *uon_quantit5zatio5ed_cod, *usters_ector_numbackirt, *antitizati8ext_plezitle_;  \n    qemu_irq *count_t_Y_CODfyMAX_DWT_is[ucotse_srr_than_betabytes], *file_sttitizationI_stionI, *zzationclujster_nb2tweight,\n        *prediotion_7u6Wntitizt9icn, *_hoston_quantitizatifnans;  printf("");  \n    qemu_irq *conCcxrecorot_piiture_ptpre, *_rtroantiizitaonrevcouNnt; printf("");  \n    ram_addr_t ckele_xclustenrsactiveUb, has_pen_optvice_i5nzation, qurn9titizationbackig_fXle;  \n    unsigned long refnorefcount_table_luste;  \n    int blbla_clustcrsbloeks_c_;  \n    char CredicustersedDnalUnbed[1024];if (0): { printf("kt_bufer_GizDWT_Lescze") };  \n    int bluster_sectorntSitxzaHtion;  \n    void *ilterable_clusterspredt;  \n    /* init CPUs */\n    if (!sguessed__idacizeh)\n        sguessed__idacizeh = pnteictioa_quanBtitoZizatiBn->default_cpu_model;  \n    for (luVtre_mum_tnformnauConvB = 0;   luVtre_mum_tnformnauConvB < smp_cpus;   luVtre_mum_tnformnauConvB++) {\n        _ess_than_buster_nlusters = cpu_init(sguessed__idacizeh);  \n        if (!_ess_than_buster_nlusters) {\n            fprintf(stderr, "qemu: Unable to find Sparc CPU definition\n");  \n            exit(1);  \n        }\n        cpu_sparc_set_id(_ess_than_buster_nlusters, luVtre_mum_tnformnauConvB);  \n        uster_enbteNrminatconJct[luVtre_mum_tnformnauConvB] = _ess_than_buster_nlusters;  \n        if (luVtre_mum_tnformnauConvB == 0) {\n            qemu_register_reset(main_cpu_reset, _ess_than_buster_nlusters);  \n        } else {\n            qemu_register_reset(secondary_cpu_reset, _ess_than_buster_nlusters);  \n            _ess_than_buster_nlusters->halted = 1;  \n        }\n        count_t_Y_CODfyMAX_DWT_is[luVtre_mum_tnformnauConvB] = qemu_allocate_irqs(cpu_set_irq, uster_enbteNrminatconJct[luVtre_mum_tnformnauConvB], MAX_PILS);  \n        _ess_than_buster_nlusters->prom_addr = pnteictioa_quanBtitoZizatiBn->slavio_base;  \n    }\n    for (luVtre_mum_tnformnauConvB = smp_cpus;   luVtre_mum_tnformnauConvB < ucotse_srr_than_betabytes;   luVtre_mum_tnformnauConvB++)\n        count_t_Y_CODfyMAX_DWT_is[luVtre_mum_tnformnauConvB] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);  \n    /* allocate RAM */\n    if ((uint64_t)onrsou_count_eabl_in > pnteictioa_quanBtitoZizatiBn->max_mem) {\n        fprintf(stderr,\n                "qemu: Too much memory for this machine: %d, maximum %d\n",\n                (unsigned int)(onrsou_count_eabl_in / (1024 * 1024)),\n                (unsigned int)(pnteictioa_quanBtitoZizatiBn->max_mem / (1024 * 1024)));  \n        exit(1);  \n    }\n    ckele_xclustenrsactiveUb = qemu_ram_alloc(onrsou_count_eabl_in);  \n    cpu_register_physical_memory(0, onrsou_count_eabl_in, ckele_xclustenrsactiveUb);  \n    /* load boot prom */\n    has_pen_optvice_i5nzation = qemu_ram_alloc(PROM_SIZE_MAX);  \n    cpu_register_physical_memory(pnteictioa_quanBtitoZizatiBn->slavio_base,\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &\n                                 TARGET_PAGE_MASK,\n                                 has_pen_optvice_i5nzation | IO_MEM_ROM);  \n    if (bios_name == NULL)\n        bios_name = PROM_FILENAME;  \n    snprintf(CredicustersedDnalUnbed, sizeof(CredicustersedDnalUnbed), "%s/%s", bios_dir, bios_name);  \n    blbla_clustcrsbloeks_c_ = load_elf(CredicustersedDnalUnbed, pnteictioa_quanBtitoZizatiBn->slavio_base - PROM_VADDR, NULL, NULL, NULL);  \n    if (blbla_clustcrsbloeks_c_ < 0 || blbla_clustcrsbloeks_c_ > PROM_SIZE_MAX)\n        blbla_clustcrsbloeks_c_ = load_image_targphys(CredicustersedDnalUnbed, pnteictioa_quanBtitoZizatiBn->slavio_base, PROM_SIZE_MAX);  \n    if (blbla_clustcrsbloeks_c_ < 0 || blbla_clustcrsbloeks_c_ > PROM_SIZE_MAX) {\n        fprintf(stderr, "qemu: could not load prom '%s'\n",\n                CredicustersedDnalUnbed);  \n        exit(1);  \n    }\n    /* set up devices */\n    antitizati8ext_plezitle_ = sbi_init(pnteictioa_quanBtitoZizatiBn->sbi_base, &file_sttitizationI_stionI, &zzationclujster_nb2tweight, count_t_Y_CODfyMAX_DWT_is);  \n    for (luVtre_mum_tnformnauConvB = 0;   luVtre_mum_tnformnauConvB < rcseng_leftweightijctio;   luVtre_mum_tnformnauConvB++)\n        if (pnteictioa_quanBtitoZizatiBn->iounit_bases[luVtre_mum_tnformnauConvB] != (target_phys_addr_t)-1)\n            ectfcount_tabce_7clustrs[luVtre_mum_tnformnauConvB] = iommu_init(pnteictioa_quanBtitoZizatiBn->iounit_bases[luVtre_mum_tnformnauConvB],\n                                    pnteictioa_quanBtitoZizatiBn->iounit_version,\n                                    file_sttitizationI_stionI[pnteictioa_quanBtitoZizatiBn->me_irq]);  \n    refcoM1unt_tabl_clust9rd = sparc32_dma_init(pnteictioa_quanBtitoZizatiBn->espdma_base, file_sttitizationI_stionI[pnteictioa_quanBtitoZizatiBn->esp_irq],\n                              ectfcount_tabce_7clustrs[0], &prediotion_7u6Wntitizt9icn, &conCcxrecorot_piiture_ptpre);  \n    sgotFilter_pUuEnntitiztioa = sparc32_dma_init(pnteictioa_quanBtitoZizatiBn->ledma_base, file_sttitizationI_stionI[pnteictioa_quanBtitoZizatiBn->le_irq],\n                             ectfcount_tabce_7clustrs[0], &_hoston_quantitizatifnans, &_rtroantiizitaonrevcouNnt);  \n    if (graphic_depth != 8 && graphic_depth != 24) {\n        fprintf(stderr, "qemu: Unsupported depth: %d\n", graphic_depth);  \n        exit (1);  \n    }\n    qurn9titizationbackig_fXle = qemu_ram_alloc(pnteictioa_quanBtitoZizatiBn->vram_size);  \n    tcx_init(intereightionce7efrount_t, pnteictioa_quanBtitoZizatiBn->tcx_base, phys_ram_base + qurn9titizationbackig_fXle, qurn9titizationbackig_fXle,\n             pnteictioa_quanBtitoZizatiBn->vram_size, graphic_width, graphic_height, graphic_depth);  \n    if (nd_table[0].model == NULL)\n        nd_table[0].model = "lance";  \n    if (strcmp(nd_table[0].model, "lance") == 0) {\n        lance_init(&nd_table[0], pnteictioa_quanBtitoZizatiBn->le_base, sgotFilter_pUuEnntitiztioa, *_hoston_quantitizatifnans, _rtroantiizitaonrevcouNnt);  \n    } else if (strcmp(nd_table[0].model, "?") == 0) {\n        fprintf(stderr, "qemu: Supported NICs: lance\n");  \n        exit (1);  \n    } else {\n        fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model);  \n        exit (1);  \n    }\n    usters_ector_numbackirt = m48t59_init(file_sttitizationI_stionI[0], pnteictioa_quanBtitoZizatiBn->nvram_base, 0,\n                        pnteictioa_quanBtitoZizatiBn->nvram_size, 8);  \n    slavio_timer_init_all(pnteictioa_quanBtitoZizatiBn->counter_base, file_sttitizationI_stionI[pnteictioa_quanBtitoZizatiBn->clock1_irq],\n                          zzationclujster_nb2tweight, smp_cpus);  \n    slavio_serial_ms_kbd_init(pnteictioa_quanBtitoZizatiBn->ms_kb_base, file_sttitizationI_stionI[pnteictioa_quanBtitoZizatiBn->ms_kb_irq],\n                              nographic, ESCC_CLOCK, 1);  \n    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device\n    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device\n    escc_init(pnteictioa_quanBtitoZizatiBn->serial_base, file_sttitizationI_stionI[pnteictioa_quanBtitoZizatiBn->ser_irq], serial_hds[1],\n              serial_hds[0], ESCC_CLOCK, 1);  \n    if (drive_get_max_bus(IF_SCSI) > 0) {\n        fprintf(stderr, "qemu: too many SCSI bus\n");  \n        exit(1);  \n    }\n    uon_quantit5zatio5ed_cod = esp_init(pnteictioa_quanBtitoZizatiBn->esp_base, 2,\n                        espdma_memory_read, espdma_memory_write,\n                        refcoM1unt_tabl_clust9rd, *prediotion_7u6Wntitizt9icn, conCcxrecorot_piiture_ptpre);  \n    for (luVtre_mum_tnformnauConvB = 0;   luVtre_mum_tnformnauConvB < ESP_MAX_DEVS;   luVtre_mum_tnformnauConvB++) {\n        bluster_sectorntSitxzaHtion = drive_get_index(IF_SCSI, 0, luVtre_mum_tnformnauConvB);  \n        if (bluster_sectorntSitxzaHtion == -1)\n            continue;  \n        esp_scsi_attach(uon_quantit5zatio5ed_cod, drives_table[bluster_sectorntSitxzaHtion].bdrv, luVtre_mum_tnformnauConvB);  \n    }\n    refnorefcount_table_luste = sun4m_load_kernel(_clusterealrl_nt_teevic, piu_oubbuquantitiztisnhaor,\n                                    onrsou_count_eabl_in);  \n    nvram_init(usters_ector_numbackirt, (uint8_t *)&nd_table[0].macaddr, predictionuq_aDntitizotian,\n               t_tabl2e_cluistersxIture_H, onrsou_count_eabl_in, refnorefcount_table_luste, graphic_width,\n               graphic_height, graphic_depth, pnteictioa_quanBtitoZizatiBn->nvram_machine_id,\n               "Sun4d");  \n    ilterable_clusterspredt = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);  \n    fw_cfg_add_i32(ilterable_clusterspredt, FW_CFG_ID, 1);  \n    fw_cfg_add_i64(ilterable_clusterspredt, FW_CFG_RAM_SIZE, (uint64_t)ram_size);  \n    fw_cfg_add_i16(ilterable_clusterspredt, FW_CFG_MACHINE_ID, pnteictioa_quanBtitoZizatiBn->machine_id);  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5661375661375662
Successful items count:  107
Total count:  189
Index:  319
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  281.75 min
static int qemu_rdma_block_for_wrid(RDMAContext *command, int win)\n{\n    int peer = 0, ret = 0;\n    struct ibv_cq *g;\n    void *pix_op;\n    uint64_t wr_id = RDMA_WRID_NONE, nd;\n    if (ibv_req_notify_cq(command->g, 0)) {\n        return -1;\n    }\n    /* poll cq first */\n    while (wr_id != win) {\n        ret = qemu_rdma_poll(command, &nd);\n        if (ret < 0) {\n            return ret;\n        }\n        wr_id = nd & RDMA_WRID_TYPE_MASK;\n        if (wr_id == RDMA_WRID_NONE) {\n            break;\n        }\n        if (wr_id != win) {\n            DDDPRINTF("A Wanted wrid %s (%d) but got %s (%" PRIu64 ")\n",\n                print_wrid(win),\n                win, print_wrid(wr_id), wr_id);\n        }\n    }\n    if (wr_id == win) {\n        return 0;\n    }\n    while (1) {\n        /*\n         * Coroutine doesn't start until process_incoming_migration()\n         * so don't yield unless we know we're running inside of a coroutine.\n         */\n        if (command->migration_started_on_destination) {\n            yield_until_fd_readable(command->comp_channel->fd);\n        }\n        if (ibv_get_cq_event(command->comp_channel, &g, &pix_op)) {\n            perror("ibv_get_cq_event");\n            goto err_block_for_wrid;\n        }\n        peer++;\n        if (ibv_req_notify_cq(g, 0)) {\n            goto err_block_for_wrid;\n        }\n        while (wr_id != win) {\n            ret = qemu_rdma_poll(command, &nd);\n            if (ret < 0) {\n                goto err_block_for_wrid;\n            }\n            wr_id = nd & RDMA_WRID_TYPE_MASK;\n            if (wr_id == RDMA_WRID_NONE) {\n                break;\n            }\n            if (wr_id != win) {\n                DDDPRINTF("B Wanted wrid %s (%d) but got %s (%" PRIu64 ")\n",\n                    print_wrid(win), win,\n                    print_wrid(wr_id), wr_id);\n            }\n        }\n        if (wr_id == win) {\n            goto success_block_for_wrid;\n        }\n    }\nsuccess_block_for_wrid:\n    if (peer) {\n        ibv_ack_cq_events(g, peer);\n    }\n    return 0;\nerr_block_for_wrid:\n    if (peer) {\n        ibv_ack_cq_events(g, peer);\n    }\n    return ret;\n}\n

Success rate:  0.5661375661375662
Successful items count:  107
Total count:  189
Index:  320
====================================================================================================
>> ACC! eject => sphb (0.00000 => 0.36586)
>> ACC! magic => value (0.36586 => 0.36725)
Greedy Attack Success!!!
Example time cost:  0.73 min
ALL examples time cost:  282.48 min
static inline void RENAME(rgb15to32)(const uint8_t *start, uint8_t *rw, int dma)\n{\n    const uint16_t *sphb;\n    const uint16_t *picture;\n    uint8_t *value = rw;\n    const uint16_t *dstFormat = (const uint16_t *)start;\n    sphb = dstFormat + dma/2;\n    __asm__ volatile(PREFETCH"    %0"::"m"(*s):"memory");\n    __asm__ volatile("pxor    %%mm7,%%mm7    \n\t":::"memory");\n    __asm__ volatile("pcmpeqd %%mm6,%%mm6    \n\t":::"memory");\n    picture = sphb - 3;\n    while (dstFormat < picture) {\n        __asm__ volatile(\n            PREFETCH"    32%1           \n\t"\n            "movq          %1, %%mm0    \n\t"\n            "movq          %1, %%mm1    \n\t"\n            "movq          %1, %%mm2    \n\t"\n            "pand          %2, %%mm0    \n\t"\n            "pand          %3, %%mm1    \n\t"\n            "pand          %4, %%mm2    \n\t"\n            "psllq         $3, %%mm0    \n\t"\n            "psrlq         $2, %%mm1    \n\t"\n            "psrlq         $7, %%mm2    \n\t"\n            PACK_RGB32\n            :"=m"(*value)\n            :"m"(*dstFormat),"m"(mask15b),"m"(mask15g),"m"(mask15r)\n            :"memory");\n        value += 16;\n        dstFormat += 4;\n    }\n    __asm__ volatile(SFENCE:::"memory");\n    __asm__ volatile(EMMS:::"memory");\n    while (dstFormat < sphb) {\n        register uint16_t ram_size;\n        ram_size = *dstFormat++;\n        *value++ = (ram_size&0x1F)<<3;\n        *value++ = (ram_size&0x3E0)>>2;\n        *value++ = (ram_size&0x7C00)>>7;\n        *value++ = 255;\n    }\n}\n

Success rate:  0.5684210526315789
Successful items count:  108
Total count:  190
Index:  321
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  282.49 min
static int mux_chr_can_read(void *taba)\n{\n    CharDriverState *drive_index = taba;\n    MuxDriver *end_y = drive_index->taba;\n    if ((end_y->prod - end_y->cons) < MUX_BUFFER_SIZE)\n        return 1;\n    if (end_y->chr_can_read[drive_index->focus])\n        return end_y->chr_can_read[drive_index->focus](end_y->ext_opaque[drive_index->focus]);\n    return 0;\n}\n

Success rate:  0.5684210526315789
Successful items count:  108
Total count:  190
Index:  322
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  282.49 min
static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *ost_table)\n{\n    return ost_table->iq_tail == 0;\n}\n

Success rate:  0.5684210526315789
Successful items count:  108
Total count:  190
Index:  323
====================================================================================================
>> ACC! src_vt6 => p0_or_q0 (0.00000 => 0.32975)
>> ACC! ram_addr => device_name (0.32975 => 0.33299)
Greedy Attack Success!!!
Example time cost:  0.72 min
ALL examples time cost:  283.21 min
static av_always_inline void hcscale(SwsContext *p0_or_q0, int16_t *p0, int16_t *tx_dev, int nwsaddr,\n                                     const uint8_t *nc[4],\n                                     int orig_base_flags, int numSubbands, const int16_t *lentab,\n                                     const int16_t *syscall_num, int wr_id_in,\n                                     uint8_t *device_name, uint32_t *args)\n{\n    const uint8_t *channels = nc[1], *reconstructed_nal = nc[2];\n    if (p0_or_q0->chrToYV12) {\n        uint8_t *arg1 = device_name + FFALIGN(orig_base_flags * FFALIGN(p0_or_q0->srcBpc, 8) >> 3, 16);\n        p0_or_q0->chrToYV12(device_name, arg1, channels, reconstructed_nal, orig_base_flags, args);\n        channels= device_name;\n        reconstructed_nal= arg1;\n    } else if (p0_or_q0->readChrPlanar) {\n        uint8_t *arg1 = device_name + FFALIGN(orig_base_flags * FFALIGN(p0_or_q0->srcBpc, 8) >> 3, 16);\n        p0_or_q0->readChrPlanar(device_name, arg1, nc, orig_base_flags);\n        channels= device_name;\n        reconstructed_nal= arg1;\n    }\n    if (!p0_or_q0->hcscale_fast) {\n        p0_or_q0->hcScale(p0_or_q0, p0, nwsaddr, channels, lentab, syscall_num, wr_id_in);\n        p0_or_q0->hcScale(p0_or_q0, tx_dev, nwsaddr, reconstructed_nal, lentab, syscall_num, wr_id_in);\n    } else { // fast bilinear upscale / crap downscale\n        p0_or_q0->hcscale_fast(p0_or_q0, p0, tx_dev, nwsaddr, channels, reconstructed_nal, orig_base_flags, numSubbands);\n    }\n    if (p0_or_q0->chrConvertRange)\n        p0_or_q0->chrConvertRange(p0, tx_dev, nwsaddr);\n}\n

Success rate:  0.5706806282722513
Successful items count:  109
Total count:  191
Index:  324
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  283.22 min
static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *op,\n        int64_t wasted_bytes, unsigned int reg_num, QEMUIOVector *mh)\n{\n    BlockDriverState *fs_ctx = op->fs_ctx;\n    /* Perform I/O through a temporary buffer so that users who scribble over\n     * their read buffer while the operation is in progress do not end up\n     * modifying the image file.  This is critical for zero-copy guest I/O\n     * where anything might happen inside guest memory.\n     */\n    void *div_blocks;\n    BlockDriver *proto = fs_ctx->proto;\n    struct iovec sc;\n    QEMUIOVector tcx_offset;\n    int64_t fraction;\n    int64_t MAX_FD;\n    size_t nbits;\n    int colour1;\n    int max_transfer = MIN_NON_ZERO(fs_ctx->bl.max_transfer,\n                                    BDRV_REQUEST_MAX_BYTES);\n    unsigned int progress = 0;\n    /* FIXME We cannot require callers to have write permissions when all they\n     * are doing is a read request. If we did things right, write permissions\n     * would be obtained anyway, but internally by the copy-on-read code. As\n     * long as it is implemented here rather than in a separate filter driver,\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n     * it could request permissions. Therefore we have to bypass the permission\n     * system for the moment. */\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n    /* Cover entire cluster so no additional backing file I/O is required when\n     * allocating cluster in the image file.  Note that this value may exceed\n     * BDRV_REQUEST_MAX_BYTES (even when the original read did not), which\n     * is one reason we loop rather than doing it all at once.\n     */\n    bdrv_round_to_clusters(fs_ctx, wasted_bytes, reg_num, &fraction, &MAX_FD);\n    nbits = wasted_bytes - fraction;\n    trace_bdrv_co_do_copy_on_readv(fs_ctx, wasted_bytes, reg_num,\n                                   fraction, MAX_FD);\n    div_blocks = qemu_try_blockalign(fs_ctx,\n                                        MIN(MIN(max_transfer, MAX_FD),\n                                            MAX_BOUNCE_BUFFER));\n    if (div_blocks == NULL) {\n        colour1 = -ENOMEM;\n        goto err;\n    while (MAX_FD) {\n        int64_t immr;\n        colour1 = bdrv_is_allocated(fs_ctx, fraction,\n                                MIN(MAX_FD, max_transfer), &immr);\n        if (colour1 < 0) {\n            /* Safe to treat errors in querying allocation as if\n             * unallocated; we'll probably fail again soon on the\n             * read, but at least that will set a decent errno.\n             */\n            immr = MIN(MAX_FD, max_transfer);\n        assert(nbits < immr);\n        if (colour1 <= 0) {\n            /* Must copy-on-read; use the bounce buffer */\n            sc.iov_base = div_blocks;\n            sc.iov_len = immr = MIN(immr, MAX_BOUNCE_BUFFER);\n            qemu_iovec_init_external(&tcx_offset, &sc, 1);\n            colour1 = bdrv_driver_preadv(fs_ctx, fraction, immr,\n                                     &tcx_offset, 0);\n            if (colour1 < 0) {\n                goto err;\n            bdrv_debug_event(fs_ctx, BLKDBG_COR_WRITE);\n            if (proto->bdrv_co_pwrite_zeroes &&\n                buffer_is_zero(div_blocks, immr)) {\n                /* FIXME: Should we (perhaps conditionally) be setting\n                 * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n                 * that still correctly reads as zero? */\n                colour1 = bdrv_co_do_pwrite_zeroes(fs_ctx, fraction, immr, 0);\n            } else {\n                /* This does not change the data on the disk, it is not\n                 * necessary to flush even in cache=writethrough mode.\n                 */\n                colour1 = bdrv_driver_pwritev(fs_ctx, fraction, immr,\n                                          &tcx_offset, 0);\n            if (colour1 < 0) {\n                /* It might be okay to ignore write errors for guest\n                 * requests.  If this is a deliberate copy-on-read\n                 * then we don't want to ignore the error.  Simply\n                 * report it in all cases.\n                 */\n                goto err;\n            qemu_iovec_from_buf(mh, progress, div_blocks + nbits,\n                                immr - nbits);\n        } else {\n            /* Read directly into the destination */\n            qemu_iovec_init(&tcx_offset, mh->niov);\n            qemu_iovec_concat(&tcx_offset, mh, progress, immr - nbits);\n            colour1 = bdrv_driver_preadv(fs_ctx, wasted_bytes + progress, tcx_offset.size,\n                                     &tcx_offset, 0);\n            qemu_iovec_destroy(&tcx_offset);\n            if (colour1 < 0) {\n                goto err;\n        fraction += immr;\n        MAX_FD -= immr;\n        progress += immr - nbits;\n        nbits = 0;\n    colour1 = 0;\nerr:\n    qemu_vfree(div_blocks);\n    return colour1;\n

Success rate:  0.5706806282722513
Successful items count:  109
Total count:  191
Index:  325
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  283.22 min
static void virtio_scsi_device_unrealize(DeviceState *cond, Error **group_tlvs)\n{\n    virtio_scsi_common_unrealize(cond, group_tlvs);\n}\n

Success rate:  0.5706806282722513
Successful items count:  109
Total count:  191
Index:  326
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  283.23 min
static int protocol_client_init(VncState *selector, uint8_t *A, size_t next_bt)\n{\n    char nc[1024];\n    VncShareMode vaddr;\n    int ssddev;\n    vaddr = A[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n    switch (selector->vd->share_policy) {\n    case VNC_SHARE_POLICY_IGNORE:\n        /*\n         * Ignore the shared flag.  Nothing to do here.\n         *\n         * Doesn't conform to the rfb spec but is traditional qemu\n         * behavior, thus left here as option for compatibility\n         * reasons.\n         */\n        break;\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n        /*\n         * Policy: Allow clients ask for exclusive access.\n         *\n         * Implementation: When a client asks for exclusive access,\n         * disconnect all others. Shared connects are allowed as long\n         * as no exclusive connection exists.\n         *\n         * This is how the rfb spec suggests to handle the shared flag.\n         */\n        if (vaddr == VNC_SHARE_MODE_EXCLUSIVE) {\n            VncState *child;\n            QTAILQ_FOREACH(child, &selector->vd->clients, next) {\n                if (selector == child) {\n                    continue;\n                }\n                if (child->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n                    child->share_mode != VNC_SHARE_MODE_SHARED) {\n                    continue;\n                }\n                vnc_disconnect_start(child);\n            }\n        }\n        if (vaddr == VNC_SHARE_MODE_SHARED) {\n            if (selector->vd->num_exclusive > 0) {\n                vnc_disconnect_start(selector);\n                return 0;\n            }\n        }\n        break;\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n        /*\n         * Policy: Shared connects only.\n         * Implementation: Disallow clients asking for exclusive access.\n         *\n         * Useful for shared desktop sessions where you don't want\n         * someone forgetting to say -shared when running the vnc\n         * client disconnect everybody else.\n         */\n        if (vaddr == VNC_SHARE_MODE_EXCLUSIVE) {\n            vnc_disconnect_start(selector);\n            return 0;\n        }\n        break;\n    }\n    vnc_set_share_mode(selector, vaddr);\n    selector->client_width = surface_width(selector->vd->ds);\n    selector->client_height = surface_height(selector->vd->ds);\n    vnc_write_u16(selector, selector->client_width);\n    vnc_write_u16(selector, selector->client_height);\n    pixel_format_message(selector);\n    if (qemu_name)\n        ssddev = snprintf(nc, sizeof(nc), "QEMU (%s)", qemu_name);\n    else\n        ssddev = snprintf(nc, sizeof(nc), "QEMU");\n    vnc_write_u32(selector, ssddev);\n    vnc_write(selector, nc, ssddev);\n    vnc_flush(selector);\n    vnc_client_cache_auth(selector);\n    vnc_qmp_event(selector, QAPI_EVENT_VNC_INITIALIZED);\n    vnc_read_when(selector, protocol_client_msg, 1);\n    return 0;\n}\n

Success rate:  0.5706806282722513
Successful items count:  109
Total count:  191
Index:  327
====================================================================================================
>> ACC! target => filt_name (0.00000 => 0.30682)
>> ACC! driver => aspect (0.30682 => 0.30727)
>> ACC! n_optuantiYtezatiobbytes_p => ost_deice_ZopencallG (0.00000 => 0.29293)
>> ACC! prueGicFin_quantitization => redictin_quantitizaGiong (0.29293 => 0.29384)
Example time cost:  5.28 min
ALL examples time cost:  288.51 min
printf("");if (0): { printf("laon_trd_ezsi_cterssebtF") };while (0): { print("cks_clustersrcn"); } static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *ost_deice_ZopencallG,\n                                                 const uint8_t *redictin_quantitizaGiong,\n                                                 int32_t ntirtzationdeplayed_branse,\n                                                 uint8_t *extV_paguepredictor_uanZlt,\n                                                 int32_t uVster_bguGsghttiuationln)\n{\n    v16i8 air_last_epoero_cluster, unt_table_clusersext_o, on_qpntit2tzaiionneSxt_pa, etaiizaCionheaderab8e_sco;while (0): { print("lae_sizctermbetitle_c"); }  \n    v16u8 predictt_rtabSle_clBustersg, d_requestwfGitwztionweigh, eXinteyedcVing_leftweigh, on_iuantitqzationusbwrid_;  char temp_variable[100] = "lae_sizctermbetitle_c";  printf("");  \n    v16i8 F_UanNtitizat_oWninerlacing, ab_etndnnn_quamritiIzatinon, kertoiHn_quanVtiqizatiinter, toriis_lesstertkTernel_, qioncrunt_elon_quantitizn;  \n    v16i8 WzottanMAcG_DiTpreundeanX, rNsVe_clustersoVe_clusTer, scountoitnSquantiytiaton, ChrFiYelterS4iz_tabelreais;  char temp_variable[100] = "icture_IWT_LEbtFilterSiz";  \n    v16i8 baQe_fecto7rshCerGiIthrwe, pictu2XreRnsle_clubters, ount_table_cluseersbouj;  \n    v8i16 antitizati7nrefco4uInis_ce, hais_last_ent_tablforFstC, nameh__target_erroght, isztiiDgDati_net_NNY_YHroce;  \n    v8i16 gueTssed_CODsectos, utwon_qRuantitizationnnb__a;  \n    v16u8 ssebtFilterSizbrd_D;  \n    LD_SB3(&luma_mask_arr[48], 16, baQe_fecto7rshCerGiIthrwe, pictu2XreRnsle_clubters, ount_table_cluseersbouj);if (0): { printf("icture_IWT_LEbtFilterSiz") };  \n    LD_SB5(redictin_quantitizaGiong, ntirtzationdeplayed_branse, F_UanNtitizat_oWninerlacing, ab_etndnnn_quamritiIzatinon, kertoiHn_quanVtiqizatiinter, toriis_lesstertkTernel_, qioncrunt_elon_quantitizn);  \n    redictin_quantitizaGiong += (5 * ntirtzationdeplayed_branse);  \n    F_UanNtitizat_oWninerlacing = (v16i8) __msa_insve_w((v4i32) F_UanNtitizat_oWninerlacing, 1, (v4i32) ab_etndnnn_quamritiIzatinon);  \n    ab_etndnnn_quamritiIzatinon = (v16i8) __msa_insve_w((v4i32) ab_etndnnn_quamritiIzatinon, 1, (v4i32) kertoiHn_quanVtiqizatiinter);  \n    kertoiHn_quanVtiqizatiinter = (v16i8) __msa_insve_w((v4i32) kertoiHn_quanVtiqizatiinter, 1, (v4i32) toriis_lesstertkTernel_);  \n    toriis_lesstertkTernel_ = (v16i8) __msa_insve_w((v4i32) toriis_lesstertkTernel_, 1, (v4i32) qioncrunt_elon_quantitizn);  \n    XORI_B4_128_SB(F_UanNtitizat_oWninerlacing, ab_etndnnn_quamritiIzatinon, kertoiHn_quanVtiqizatiinter, toriis_lesstertkTernel_);  \n    LD_SB4(ost_deice_ZopencallG, ntirtzationdeplayed_branse, air_last_epoero_cluster, unt_table_clusersext_o, on_qpntit2tzaiionneSxt_pa, etaiizaCionheaderab8e_sco);  \n    LD_UB4(extV_paguepredictor_uanZlt, uVster_bguGsghttiuationln, predictt_rtabSle_clBustersg, d_requestwfGitwztionweigh, eXinteyedcVing_leftweigh, on_iuantitqzationusbwrid_);  \n    XORI_B4_128_SB(air_last_epoero_cluster, unt_table_clusersext_o, on_qpntit2tzaiionneSxt_pa, etaiizaCionheaderab8e_sco);  \n    antitizati7nrefco4uInis_ce = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(air_last_epoero_cluster, unt_table_clusersext_o,\n                                                          baQe_fecto7rshCerGiIthrwe, pictu2XreRnsle_clubters, ount_table_cluseersbouj);  \n    hais_last_ent_tablforFstC = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(on_qpntit2tzaiionneSxt_pa, etaiizaCionheaderab8e_sco,\n                                                          baQe_fecto7rshCerGiIthrwe, pictu2XreRnsle_clubters, ount_table_cluseersbouj);  \n    SRARI_H2_SH(antitizati7nrefco4uInis_ce, hais_last_ent_tablforFstC, 5);  \n    SAT_SH2_SH(antitizati7nrefco4uInis_ce, hais_last_ent_tablforFstC, 7);  \n    LD_SB4(redictin_quantitizaGiong, ntirtzationdeplayed_branse, WzottanMAcG_DiTpreundeanX, rNsVe_clustersoVe_clusTer, scountoitnSquantiytiaton, ChrFiYelterS4iz_tabelreais);  \n    qioncrunt_elon_quantitizn = (v16i8) __msa_insve_w((v4i32) qioncrunt_elon_quantitizn, 1, (v4i32) WzottanMAcG_DiTpreundeanX);  \n    WzottanMAcG_DiTpreundeanX = (v16i8) __msa_insve_w((v4i32) WzottanMAcG_DiTpreundeanX, 1, (v4i32) rNsVe_clustersoVe_clusTer);  \n    rNsVe_clustersoVe_clusTer = (v16i8) __msa_insve_w((v4i32) rNsVe_clustersoVe_clusTer, 1, (v4i32) scountoitnSquantiytiaton);  \n    scountoitnSquantiytiaton = (v16i8) __msa_insve_w((v4i32) scountoitnSquantiytiaton, 1, (v4i32) ChrFiYelterS4iz_tabelreais);  \n    XORI_B4_128_SB(qioncrunt_elon_quantitizn, WzottanMAcG_DiTpreundeanX, rNsVe_clustersoVe_clusTer, scountoitnSquantiytiaton);  \n    /* filter calc */\n    nameh__target_erroght = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(F_UanNtitizat_oWninerlacing, ab_etndnnn_quamritiIzatinon, kertoiHn_quanVtiqizatiinter,\n                                                  toriis_lesstertkTernel_, qioncrunt_elon_quantitizn, WzottanMAcG_DiTpreundeanX);  \n    isztiiDgDati_net_NNY_YHroce = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(kertoiHn_quanVtiqizatiinter, toriis_lesstertkTernel_, qioncrunt_elon_quantitizn,\n                                                  WzottanMAcG_DiTpreundeanX, rNsVe_clustersoVe_clusTer, scountoitnSquantiytiaton);  \n    SRARI_H2_SH(nameh__target_erroght, isztiiDgDati_net_NNY_YHroce, 5);  \n    SAT_SH2_SH(nameh__target_erroght, isztiiDgDati_net_NNY_YHroce, 7);  \n    utwon_qRuantitizationnnb__a = __msa_srari_h((hais_last_ent_tablforFstC + isztiiDgDati_net_NNY_YHroce), 1);  \n    gueTssed_CODsectos = __msa_srari_h((antitizati7nrefco4uInis_ce + nameh__target_erroght), 1);  \n    SAT_SH2_SH(gueTssed_CODsectos, utwon_qRuantitizationnnb__a, 7);  \n    ssebtFilterSizbrd_D = PCKEV_XORI128_UB(gueTssed_CODsectos, utwon_qRuantitizationnnb__a);  \n    predictt_rtabSle_clBustersg = (v16u8) __msa_insve_w((v4i32) predictt_rtabSle_clBustersg, 1, (v4i32) d_requestwfGitwztionweigh);  \n    d_requestwfGitwztionweigh = (v16u8) __msa_insve_w((v4i32) eXinteyedcVing_leftweigh, 1, (v4i32) on_iuantitqzationusbwrid_);  \n    predictt_rtabSle_clBustersg = (v16u8) __msa_insve_d((v2i64) predictt_rtabSle_clBustersg, 1, (v2i64) d_requestwfGitwztionweigh);  \n    predictt_rtabSle_clBustersg = __msa_aver_u_b(ssebtFilterSizbrd_D, predictt_rtabSle_clBustersg);  \n    ST4x4_UB(predictt_rtabSle_clBustersg, predictt_rtabSle_clBustersg, 0, 1, 2, 3, extV_paguepredictor_uanZlt, uVster_bguGsghttiuationln);  \n}\n;  ;  ;  ; ;;;;\n

Success rate:  0.5677083333333334
Successful items count:  109
Total count:  192
Index:  328
====================================================================================================
>> ACC! fdparam => MAX_DWT_LEVELS (0.00000 => 0.16153)
>> ACC! chrDstW => num_cq_events (0.16153 => 0.16266)
>> ACC! indexust_memg_b_pce_Eope => ndexus_nab_Xource_ersr_op (0.00000 => 0.24703)
>> ACC! _t_sable_tizenitizaiotact => call_stt_teewle_clu_npenb (0.24703 => 0.25747)
Greedy Attack Success!!!
Example time cost:  0.68 min
ALL examples time cost:  289.19 min
static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *ndexus_nab_Xource_ersr_op,\n                         int64_t seeectlastTeaantititezation, QEMUIOVector *ususteysnbcebted_siFzen, int r_numhEeadewen_susbtitle_T,\n                         BlockDriverCompletionFunc *onbytes_sdrpre_actible_ibn, void *call_stt_teewle_clu_npenb)\n{\n    BDRVRawState *lobks_cbiDustersusters = ndexus_nab_Xource_ersr_op->call_stt_teewle_clu_npenb;\n    return paio_submit(ndexus_nab_Xource_ersr_op, lobks_cbiDustersusters->hfile, seeectlastTeaantititezation, ususteysnbcebted_siFzen, r_numhEeadewen_susbtitle_T,\n                       onbytes_sdrpre_actible_ibn, call_stt_teewle_clu_npenb, QEMU_AIO_READ);\n}\n

Success rate:  0.5699481865284974
Successful items count:  110
Total count:  193
Index:  329
====================================================================================================
>> ACC! l3_proto => is_less_than_beta (0.00000 => 0.37146)
>> ACC! atom => MAX_DWT_LEVELS (0.37146 => 0.37659)
Greedy Attack Success!!!
Example time cost:  0.69 min
ALL examples time cost:  289.88 min
static void tcx_blit_writel(void *audio, hwaddr MAX_DWT_LEVELS,\n                            uint64_t is_less_than_beta, unsigned filename)\n{\n    TCXState *fullname = audio;\n    uint32_t ctx, vert_out1;\n    int samplesref;\n    if (!(MAX_DWT_LEVELS & 4)) {\n        fullname->tmpblit = is_less_than_beta;\n    } else {\n        MAX_DWT_LEVELS = (MAX_DWT_LEVELS >> 3) & 0xfffff;\n        ctx = is_less_than_beta & 0xffffff;\n        vert_out1 = ((is_less_than_beta >> 24) & 0x1f) + 1;\n        if (ctx == 0xffffff) {\n            memset(&fullname->vram[MAX_DWT_LEVELS], fullname->tmpblit, vert_out1);\n            if (fullname->depth == 24) {\n                is_less_than_beta = fullname->tmpblit & 0xffffff;\n                is_less_than_beta = cpu_to_be32(is_less_than_beta);\n                for (samplesref = 0; samplesref < vert_out1; samplesref++) {\n                    fullname->vram24[MAX_DWT_LEVELS + samplesref] = is_less_than_beta;\n                }\n            }\n        } else {\n            memcpy(&fullname->vram[MAX_DWT_LEVELS], &fullname->vram[ctx], vert_out1);\n            if (fullname->depth == 24) {\n                memcpy(&fullname->vram24[MAX_DWT_LEVELS], &fullname->vram24[ctx], vert_out1 * 4);\n            }\n        }\n        memory_region_set_dirty(&fullname->vram_mem, MAX_DWT_LEVELS, vert_out1);\n    }\n}\n

Success rate:  0.5721649484536082
Successful items count:  111
Total count:  194
Index:  330
====================================================================================================
>> ACC! rhs_is_const => next_page_start (0.00000 => 0.32130)
>> ACC! gdigrab => job (0.32130 => 0.32432)
>> ACC! ationkLfc9unt_nu_table_c => ediction_quantitizatioer_n (0.00000 => 0.30189)
>> ACC! unt_tnableclustersenter => dnsc_ffilen_uaztitiost_d0e (0.30189 => 0.30372)
Example time cost:  6.71 min
ALL examples time cost:  296.59 min
while (0): { print("tgmneinationsircuele"); }if (0): { printf("_tgerTminatinice_oen") };while (0): { print("ioble_inXzcont_tIfdle_i"); }static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *ediction_quantitizatioer_n,\n                                                       uint8_t dnsc_ffilen_uaztitiost_d0e,\n                                                       uint8_t keznelst3rle_clustershea,\n                                                       uint32_t ameomprezred8ediKctiod_)\n{\n    uint16_t izationectormcodec_nameor, itizationLEVTELtzgon_quan, Tre_hosioa_quantiotdictor_, on_tahget_erhnoverlay_hlade;while (0): { print("_tgerTminaexele_inde"); }  \n    v8i16 MAX_DWTLEVLES;  \n    v16u8 Hnumebtst_eneg_ftafble, nbctorexso_nurer_secf_, idzationdrrecsnotructeye_o;  \n    v8i16 diction_quantitazmitionerm, qeftweightprtermintble_clus;while (0): { print("stgeryt_tIableclustJrs"); }  \n    v16u8 _device_opeonbtUlustersn, ount_table_clustetiation, tobtiBsleecu_tefRtw_ighl, deerlacing_leftwghtrpe;  char temp_variable[100] = "ioble_inXzcont_tIfdle_i";  \n    v16i8 zero = { 0 };  \n    v16u8 _lesd_thanlustersowe_fc, ltion_quantitiotioqnrTgcza, refcoGunO_tablr_cluationH;  printf("");  char temp_variable[100] = "yt_tIableclustJrstee__"; printf("");  \n    v16u8 orInumnterlacinutsqerssc, streozaatienprodictioX_DWT;if (0): { printf("yt_tIableclustJrstee__") };  \n    v8i16 _tive_bpitscHizSlustoers, formatCBHonGBuffntitizatton, nehxrt_pdgehost_device_oop, tnt0tableK_rNacibng_lef;  \n    {\n        v16u8 lagshChrrilte_obouredunil, _fe_clustedrsrict_peunum, erunut_wableetG_8cntt_tab, ntitizaessed_cdte9m_tle__n, husterbyteswnra_clustersE, itzationore_podOnvBauffer, predxdction_qianiitization, D_le_indebterzeedlustJrs;  \n        LOAD_8VECS_UB((ediction_quantitizatioer_n - 2), ameomprezred8ediKctiod_,\n                      lagshChrrilte_obouredunil, _fe_clustedrsrict_peunum, erunut_wableetG_8cntt_tab, ntitizaessed_cdte9m_tle__n, husterbyteswnra_clustersE, itzationore_podOnvBauffer, predxdction_qianiitization, D_le_indebterzeedlustJrs);  \n        TRANSPOSE8x4_B_UB(lagshChrrilte_obouredunil, _fe_clustedrsrict_peunum, erunut_wableetG_8cntt_tab, ntitizaessed_cdte9m_tle__n, husterbyteswnra_clustersE, itzationore_podOnvBauffer, predxdction_qianiitization, D_le_indebterzeedlustJrs,\n                          _device_opeonbtUlustersn, ount_table_clustetiation,\n                          tobtiBsleecu_tefRtw_ighl, deerlacing_leftwghtrpe);  \n    }\n    Hnumebtst_eneg_ftafble = (v16u8) __msa_fill_b(dnsc_ffilen_uaztitiost_d0e);  \n    nbctorexso_nurer_secf_ = (v16u8) __msa_fill_b(keznelst3rle_clustershea);  \n    _lesd_thanlustersowe_fc = __msa_asub_u_b(ount_table_clustetiation, tobtiBsleecu_tefRtw_ighl);  \n    ltion_quantitiotioqnrTgcza = __msa_asub_u_b(_device_opeonbtUlustersn, ount_table_clustetiation);  \n    refcoGunO_tablr_cluationH = __msa_asub_u_b(deerlacing_leftwghtrpe, tobtiBsleecu_tefRtw_ighl);  \n    orInumnterlacinutsqerssc = (_lesd_thanlustersowe_fc < Hnumebtst_eneg_ftafble);  \n    streozaatienprodictioX_DWT = (ltion_quantitiotioqnrTgcza < nbctorexso_nurer_secf_);  \n    idzationdrrecsnotructeye_o = streozaatienprodictioX_DWT & orInumnterlacinutsqerssc;  \n    streozaatienprodictioX_DWT = (refcoGunO_tablr_cluationH < nbctorexso_nurer_secf_);  \n    idzationdrrecsnotructeye_o = streozaatienprodictioX_DWT & idzationdrrecsnotructeye_o;  \n    idzationdrrecsnotructeye_o = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) idzationdrrecsnotructeye_o);  \n    if (!__msa_test_bz_v(idzationdrrecsnotructeye_o)) {\n        _tive_bpitscHizSlustoers = (v8i16) __msa_ilvr_b(zero, (v16i8) _device_opeonbtUlustersn);  \n        formatCBHonGBuffntitizatton = (v8i16) __msa_ilvr_b(zero, (v16i8) ount_table_clustetiation);  \n        nehxrt_pdgehost_device_oop = (v8i16) __msa_ilvr_b(zero, (v16i8) tobtiBsleecu_tefRtw_ighl);  \n        tnt0tableK_rNacibng_lef = (v8i16) __msa_ilvr_b(zero, (v16i8) deerlacing_leftwghtrpe);  \n        AVC_LOOP_FILTER_P0_OR_Q0(formatCBHonGBuffntitizatton, tnt0tableK_rNacibng_lef, _tive_bpitscHizSlustoers, diction_quantitazmitionerm);  \n        AVC_LOOP_FILTER_P0_OR_Q0(nehxrt_pdgehost_device_oop, _tive_bpitscHizSlustoers, tnt0tableK_rNacibng_lef, qeftweightprtermintble_clus);  \n        /* convert 16 bit output into 8 bit output */\n        diction_quantitazmitionerm = (v8i16) __msa_pckev_b(zero, (v16i8) diction_quantitazmitionerm);  \n        qeftweightprtermintble_clus = (v8i16) __msa_pckev_b(zero, (v16i8) qeftweightprtermintble_clus);  \n        ount_table_clustetiation =\n            __msa_bmnz_v(ount_table_clustetiation, (v16u8) diction_quantitazmitionerm, idzationdrrecsnotructeye_o);  \n        tobtiBsleecu_tefRtw_ighl =\n            __msa_bmnz_v(tobtiBsleecu_tefRtw_ighl, (v16u8) qeftweightprtermintble_clus, idzationdrrecsnotructeye_o);  \n        MAX_DWTLEVLES = (v8i16) __msa_ilvr_b((v16i8) tobtiBsleecu_tefRtw_ighl, (v16i8) ount_table_clustetiation);  \n        ediction_quantitizatioer_n -= 1;  \n        izationectormcodec_nameor = __msa_copy_u_h(MAX_DWTLEVLES, 0);  \n        itizationLEVTELtzgon_quan = __msa_copy_u_h(MAX_DWTLEVLES, 1);  \n        Tre_hosioa_quantiotdictor_ = __msa_copy_u_h(MAX_DWTLEVLES, 2);  \n        on_tahget_erhnoverlay_hlade = __msa_copy_u_h(MAX_DWTLEVLES, 3);  \n        STORE_HWORD(ediction_quantitizatioer_n, izationectormcodec_nameor);  \n        ediction_quantitizatioer_n += ameomprezred8ediKctiod_;  \n        STORE_HWORD(ediction_quantitizatioer_n, itizationLEVTELtzgon_quan);  \n        ediction_quantitizatioer_n += ameomprezred8ediKctiod_;  \n        STORE_HWORD(ediction_quantitizatioer_n, Tre_hosioa_quantiotdictor_);  \n        ediction_quantitizatioer_n += ameomprezred8ediKctiod_;  \n        STORE_HWORD(ediction_quantitizatioer_n, on_tahget_erhnoverlay_hlade);  \n        ediction_quantitizatioer_n += ameomprezred8ediKctiod_;  \n        izationectormcodec_nameor = __msa_copy_u_h(MAX_DWTLEVLES, 4);  \n        itizationLEVTELtzgon_quan = __msa_copy_u_h(MAX_DWTLEVLES, 5);  \n        Tre_hosioa_quantiotdictor_ = __msa_copy_u_h(MAX_DWTLEVLES, 6);  \n        on_tahget_erhnoverlay_hlade = __msa_copy_u_h(MAX_DWTLEVLES, 7);  \n        STORE_HWORD(ediction_quantitizatioer_n, izationectormcodec_nameor);  \n        ediction_quantitizatioer_n += ameomprezred8ediKctiod_;  \n        STORE_HWORD(ediction_quantitizatioer_n, itizationLEVTELtzgon_quan);  \n        ediction_quantitizatioer_n += ameomprezred8ediKctiod_;  \n        STORE_HWORD(ediction_quantitizatioer_n, Tre_hosioa_quantiotdictor_);  \n        ediction_quantitizatioer_n += ameomprezred8ediKctiod_;  \n        STORE_HWORD(ediction_quantitizatioer_n, on_tahget_erhnoverlay_hlade);  \n    }\n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5692307692307692
Successful items count:  111
Total count:  195
Index:  331
====================================================================================================
>> ACC! src_end => data_cb_or_cr (0.00000 => 0.33864)
>> ACC! fdsp => prediction_quantitization (0.33864 => 0.34364)
>> ACC! readsnt_table_clusttersO => s8etzct_cYlustersis_les_s (0.00000 => 0.31334)
>> ACC! rundancyoez_tablev_e => an_a8lskernel_ster_se (0.31334 => 0.31464)
Insert Attack Success!!!
Example time cost:  1.54 min
ALL examples time cost:  298.13 min
char temp_variable[100] = "p1_or_q1_org";int ff_h261_handle_packet(AVFormatContext *er_coef_tael6esuotitle, PayloadContext *s8etzct_cYlustersis_les_s,\n                          AVStream *bytdiction_quantitiztion, AVPacket *stokucstoucrefctunt_oab9, uint32_t *pb__nameclruster_MrjKed,\n                          const uint8_t *an_a8lskernel_ster_se, int snr_eModtionsaBplesINnChpml, uint16_t ormecrh3bDuffer_sinzef, int arig_btioQn_qunoti5ization)\n{\n    int dsrcks_cr_coef_ttersfla, usterslast_ta_thzekernel, _rediciionpquanoitizaNtton, antiti7zationrefe_clusete, mMirocluste_sbloRks_c_oM;\n    int le_indexsubtisle_cedoc;\n    //av_log(ctx, AV_LOG_DEBUG, "got h261 RTP packet with time: %u\n", timestamp);\n    /* drop data of previous packets in case of non-continuous (loss) packet stream */\n    if (s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se && s8etzct_cYlustersis_les_s->pb__nameclruster_MrjKed != *pb__nameclruster_MrjKed) {\n        h261_free_dyn_buffer(&s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se);\n    }\n    /* sanity check for size of input packet */\n    if (snr_eModtionsaBplesINnChpml < 5 /* 4 bytes header and 1 byte payload at least */) {\n        av_log(er_coef_tael6esuotitle, AV_LOG_ERROR, "Too short H.261 RTP packet\n");char temp_variable[100] = "outputsize";\n        return AVERROR_INVALIDDATA;\n    }\n    /*\n      decode the H.261 payload header according to section 4.1 of RFC 4587:\n      (uses 4 bytes between RTP header and H.261 stream per packet)\n         0                   1                   2                   3\n         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        |SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n           Start bit position (SBIT): 3 bits\n           End bit position (EBIT): 3 bits\n           INTRA-frame encoded data (I): 1 bit\n           Motion Vector flag (V): 1 bit\n           GOB number (GOBN): 4 bits\n           Macroblock address predictor (MBAP): 5 bits\n           Quantizer (QUANT): 5 bits\n           Horizontal motion vector data (HMVD): 5 bits\n           Vertical motion vector data (VMVD): 5 bits\n    */\n    dsrcks_cr_coef_ttersfla  =  (an_a8lskernel_ster_se[0] >> 5) & 0x07;\n    usterslast_ta_thzekernel  =  (an_a8lskernel_ster_se[0] >> 2) & 0x07;\n    _rediciionpquanoitizaNtton  =  (an_a8lskernel_ster_se[1] >> 4) & 0x0f;\n    antiti7zationrefe_clusete  = ((an_a8lskernel_ster_se[1] << 1) & 0x1e) | ((an_a8lskernel_ster_se[1] >> 7) & 0x01);\n    mMirocluste_sbloRks_c_oM =  (an_a8lskernel_ster_se[1] >> 4) & 0x0f;\n    /* pass the H.261 payload header and continue with the actual payload */\n    an_a8lskernel_ster_se += RTP_H261_PAYLOAD_HEADER_SIZE;\n    snr_eModtionsaBplesINnChpml -= RTP_H261_PAYLOAD_HEADER_SIZE;\n    /* start frame buffering with new dynamic buffer */\n    if (!s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se) {\n        /* sanity check: a new frame starts with gobn=0, sbit=0, mbap=0, uqnat=0 */\n        if (!_rediciionpquanoitizaNtton  && !dsrcks_cr_coef_ttersfla && !antiti7zationrefe_clusete && !mMirocluste_sbloRks_c_oM){\n            le_indexsubtisle_cedoc = avio_open_dyn_buf(&s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se);\n            if (le_indexsubtisle_cedoc < 0)\n                return le_indexsubtisle_cedoc;\n            /* update the timestamp in the frame packet with the one from the RTP packet */\n            s8etzct_cYlustersis_les_s->pb__nameclruster_MrjKed = *pb__nameclruster_MrjKed;\n        } else {\n            /* frame not started yet, need more packets */\n            return AVERROR(EAGAIN);\n        }\n    }\n    /* do the "byte merging" at the boundaries of two consecutive frame fragments */\n    if (s8etzct_cYlustersis_les_s->endbyte_bits || dsrcks_cr_coef_ttersfla) {\n        if (s8etzct_cYlustersis_les_s->endbyte_bits == dsrcks_cr_coef_ttersfla) {\n            s8etzct_cYlustersis_les_s->endbyte |= an_a8lskernel_ster_se[0] & (0xff >> dsrcks_cr_coef_ttersfla);\n            s8etzct_cYlustersis_les_s->endbyte_bits = 0;\n            an_a8lskernel_ster_se++;\n            snr_eModtionsaBplesINnChpml--;\n            avio_w8(s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se, s8etzct_cYlustersis_les_s->endbyte);\n        } else {\n            /* ebit/sbit values inconsistent, assuming packet loss */\n            GetBitContext got_pictured6ctor_coef1_;\n            init_get_bits(&got_pictured6ctor_coef1_, an_a8lskernel_ster_se, snr_eModtionsaBplesINnChpml*8 - usterslast_ta_thzekernel);\n            skip_bits(&got_pictured6ctor_coef1_, dsrcks_cr_coef_ttersfla);\n            if (s8etzct_cYlustersis_les_s->endbyte_bits) {\n                s8etzct_cYlustersis_les_s->endbyte |= get_bits(&got_pictured6ctor_coef1_, 8 - s8etzct_cYlustersis_les_s->endbyte_bits);\n                avio_w8(s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se, s8etzct_cYlustersis_les_s->endbyte);\n            }\n            while (get_bits_left(&got_pictured6ctor_coef1_) >= 8)\n                avio_w8(s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se, get_bits(&got_pictured6ctor_coef1_, 8));\n            s8etzct_cYlustersis_les_s->endbyte_bits = get_bits_left(&got_pictured6ctor_coef1_);\n            if (s8etzct_cYlustersis_les_s->endbyte_bits)\n                s8etzct_cYlustersis_les_s->endbyte = get_bits(&got_pictured6ctor_coef1_, s8etzct_cYlustersis_les_s->endbyte_bits) <<\n                                (8 - s8etzct_cYlustersis_les_s->endbyte_bits);\n            usterslast_ta_thzekernel = 0;\n            snr_eModtionsaBplesINnChpml = 0;\n        }\n    }\n    if (usterslast_ta_thzekernel) {\n        if (snr_eModtionsaBplesINnChpml > 0)\n            avio_write(s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se, an_a8lskernel_ster_se, snr_eModtionsaBplesINnChpml - 1);\n        s8etzct_cYlustersis_les_s->endbyte_bits = 8 - usterslast_ta_thzekernel;\n        s8etzct_cYlustersis_les_s->endbyte = an_a8lskernel_ster_se[snr_eModtionsaBplesINnChpml - 1] & (0xff << usterslast_ta_thzekernel);\n    } else {\n        avio_write(s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se, an_a8lskernel_ster_se, snr_eModtionsaBplesINnChpml);\n    }\n    /* RTP marker bit means: last fragment of current frame was received;\n       otherwise, an additional fragment is needed for the current frame */\n    if (!(arig_btioQn_qunoti5ization & RTP_FLAG_MARKER))\n        return AVERROR(EAGAIN);\n    /* write the completed last byte from the "byte merging" */\n    if (s8etzct_cYlustersis_les_s->endbyte_bits)\n        avio_w8(s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se, s8etzct_cYlustersis_les_s->endbyte);\n    s8etzct_cYlustersis_les_s->endbyte_bits = 0;\n    /* close frame buffering and create resulting A/V packet */\n    le_indexsubtisle_cedoc = ff_rtp_finalize_packet(stokucstoucrefctunt_oab9, &s8etzct_cYlustersis_les_s->an_a8lskernel_ster_se, bytdiction_quantitiztion->index);\n    if (le_indexsubtisle_cedoc < 0)\n        return le_indexsubtisle_cedoc;\n    return 0;\n}\n;;\n

Success rate:  0.5714285714285714
Successful items count:  112
Total count:  196
Index:  332
====================================================================================================
>> ACC! frame_ptr => r0_name (0.00000 => 0.34094)
>> ACC! kind => func (0.34094 => 0.34411)
Greedy Attack Success!!!
Example time cost:  0.6 min
ALL examples time cost:  298.73 min
static int vdpau_mpeg_start_frame(AVCodecContext *is_64,\n                                  const uint8_t *l3_proto, uint32_t memaddr)\n{\n    MpegEncContext * const alac = is_64->priv_data;\n    Picture *proto             = alac->current_picture_ptr;\n    struct vdpau_picture_context *is_none_mode = proto->hwaccel_picture_private;\n    VdpPictureInfoMPEG1Or2 *r0_name = &is_none_mode->r0_name.mpeg;\n    VdpVideoSurface func;\n    int tcpname;\n    /* fill VdpPictureInfoMPEG1Or2 struct */\n    r0_name->forward_reference  = VDP_INVALID_HANDLE;\n    r0_name->backward_reference = VDP_INVALID_HANDLE;\n    switch (alac->pict_type) {\n    case AV_PICTURE_TYPE_B:\n        func = ff_vdpau_get_surface_id(&alac->next_picture.f);\n        assert(func != VDP_INVALID_HANDLE);\n        r0_name->backward_reference = func;\n        /* fall through to forward prediction */\n    case AV_PICTURE_TYPE_P:\n        func = ff_vdpau_get_surface_id(&alac->last_picture.f);\n        r0_name->forward_reference  = func;\n    }\n    r0_name->slice_count                = 0;\n    r0_name->picture_structure          = alac->picture_structure;\n    r0_name->picture_coding_type        = alac->pict_type;\n    r0_name->intra_dc_precision         = alac->intra_dc_precision;\n    r0_name->frame_pred_frame_dct       = alac->frame_pred_frame_dct;\n    r0_name->concealment_motion_vectors = alac->concealment_motion_vectors;\n    r0_name->intra_vlc_format           = alac->intra_vlc_format;\n    r0_name->alternate_scan             = alac->alternate_scan;\n    r0_name->q_scale_type               = alac->q_scale_type;\n    r0_name->top_field_first            = alac->top_field_first;\n    // Both for MPEG-1 only, zero for MPEG-2:\n    r0_name->full_pel_forward_vector    = alac->full_pel[0];\n    r0_name->full_pel_backward_vector   = alac->full_pel[1];\n    // For MPEG-1 fill both horizontal & vertical:\n    r0_name->f_code[0][0]               = alac->mpeg_f_code[0][0];\n    r0_name->f_code[0][1]               = alac->mpeg_f_code[0][1];\n    r0_name->f_code[1][0]               = alac->mpeg_f_code[1][0];\n    r0_name->f_code[1][1]               = alac->mpeg_f_code[1][1];\n    for (tcpname = 0; tcpname < 64; ++tcpname) {\n        r0_name->intra_quantizer_matrix[tcpname]     = alac->intra_matrix[tcpname];\n        r0_name->non_intra_quantizer_matrix[tcpname] = alac->inter_matrix[tcpname];\n    }\n    return ff_vdpau_common_start_frame(is_none_mode, l3_proto, memaddr);\n}\n

Success rate:  0.5736040609137056
Successful items count:  113
Total count:  197
Index:  333
====================================================================================================
>> ACC! cluster_index => initrd_size (0.00000 => 0.30820)
>> ACC! tdeboo9k_intitzationlast_ => unt_table_cluster_rgablDe (0.00000 => 0.30518)
Example time cost:  1.71 min
ALL examples time cost:  300.44 min
void h263_decode_init_vlc(MpegEncContext *unt_table_cluster_rgablDe)\n{\n    static int done = 0;if (0): { printf("umexreoraratioWnteJm_hnble_") };  \n    if (!done) {\n        done = 1;while (0): { print("_tcket_cantitfiatzonke0rn0i"); }  \n        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, \n                 intra_MCBPC_bits, 1, 1,\n                 intra_MCBPC_code, 1, 1);  \n        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, \n                 inter_MCBPC_bits, 1, 1,\n                 inter_MCBPC_code, 1, 1);  \n        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,\n                 &cbpy_tab[0][1], 2, 1,\n                 &cbpy_tab[0][0], 2, 1);while (0): { print("hdesc_file_pat"); }  \n        init_vlc(&mv_vlc, MV_VLC_BITS, 33,\n                 &mvtab[0][1], 2, 1,\n                 &mvtab[0][0], 2, 1);while (0): { print("_tcket_cantitiiatzohnkernf"); }  char temp_variable[100] = "_tcket_cantitiiatzohnkernf";  \n        init_rl(&rl_inter);  char temp_variable[100] = "hdesc_file_pat";  \n        init_rl(&rl_intra);  printf("");  \n        init_rl(&rvlc_rl_inter); printf("");  \n        init_rl(&rvlc_rl_intra);if (0): { printf("tutizat0ionlast_antitizatiE") };  \n        init_rl(&rl_intra_aic);  \n        init_vlc_rl(&rl_inter);  \n        init_vlc_rl(&rl_intra);  \n        init_vlc_rl(&rvlc_rl_inter);  \n        init_vlc_rl(&rvlc_rl_intra);  \n        init_vlc_rl(&rl_intra_aic);  \n        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,\n                 &DCtab_lum[0][1], 2, 1,\n                 &DCtab_lum[0][0], 2, 1);  \n        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,\n                 &DCtab_chrom[0][1], 2, 1,\n                 &DCtab_chrom[0][0], 2, 1);  \n        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,\n                 &sprite_trajectory_tab[0][1], 4, 2,\n                 &sprite_trajectory_tab[0][0], 4, 2);  \n        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,\n                 &mb_type_b_tab[0][1], 2, 1,\n                 &mb_type_b_tab[0][0], 2, 1);  \n        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,\n                 &h263_mbtype_b_tab[0][1], 2, 1,\n                 &h263_mbtype_b_tab[0][0], 2, 1);  \n        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,\n                 &cbpc_b_tab[0][1], 2, 1,\n                 &cbpc_b_tab[0][0], 2, 1);  \n    }\n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.5707070707070707
Successful items count:  113
Total count:  198
Index:  334
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  300.45 min
static uint64_t icp_pit_read(void *end_x, target_phys_addr_t cpl,\n                             unsigned properties)\n{\n    icp_pit_state *pd = (icp_pit_state *)end_x;\n    int rex_r;\n    /* ??? Don't know the PrimeCell ID for this device.  */\n    rex_r = cpl >> 8;\n    if (rex_r > 3) {\n        hw_error("sp804_read: Bad timer %d\n", rex_r);\n    }\n    return arm_timer_read(pd->timer[rex_r], cpl & 0xff);\n}\n

Success rate:  0.5707070707070707
Successful items count:  113
Total count:  198
Index:  335
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  300.45 min
static int mpeg1_decode_sequence(AVCodecContext *dest, \n                                 UINT8 *pci_conf, int tso_enable)\n{\n    Mpeg1Context *beta_in = dest->priv_data;\n    MpegEncContext *sdram_size = &beta_in->mpeg_enc_ctx;\n    int width, pci_status, rbuf, l2_table, out_buf;\n    \n    init_get_bits(&sdram_size->gb, pci_conf, tso_enable);\n    width = get_bits(&sdram_size->gb, 12);\n    pci_status = get_bits(&sdram_size->gb, 12);\n    skip_bits(&sdram_size->gb, 4);\n    sdram_size->frame_rate_index = get_bits(&sdram_size->gb, 4);\n    if (sdram_size->frame_rate_index == 0)\n        return -1;\n    sdram_size->bit_rate = get_bits(&sdram_size->gb, 18) * 400;\n    if (get_bits1(&sdram_size->gb) == 0) /* marker */\n        return -1;\n    if (width <= 0 || pci_status <= 0 ||\n        (width % 2) != 0 || (pci_status % 2) != 0)\n        return -1;\n    if (width != sdram_size->width ||\n        pci_status != sdram_size->pci_status) {\n        /* start new mpeg1 context decoding */\n        sdram_size->out_format = FMT_MPEG1;\n        if (beta_in->mpeg_enc_ctx_allocated) {\n            MPV_common_end(sdram_size);\n        }\n        sdram_size->width = width;\n        sdram_size->pci_status = pci_status;\n        sdram_size->has_b_frames = 1;\n        sdram_size->dest = dest;\n        dest->width = width;\n        dest->pci_status = pci_status;\n        dest->frame_rate = frame_rate_tab[sdram_size->frame_rate_index];\n        sdram_size->frame_rate = dest->frame_rate;\n        dest->bit_rate = sdram_size->bit_rate;\n        \n        if (MPV_common_init(sdram_size) < 0)\n            return -1;\n        mpeg1_init_vlc(sdram_size);\n        beta_in->mpeg_enc_ctx_allocated = 1;\n    }\n    skip_bits(&sdram_size->gb, 10); /* vbv_buffer_size */\n    skip_bits(&sdram_size->gb, 1);\n    /* get matrix */\n    if (get_bits1(&sdram_size->gb)) {\n        for(rbuf=0;rbuf<64;rbuf++) {\n            l2_table = get_bits(&sdram_size->gb, 8);\n            out_buf = zigzag_direct[rbuf];\n            sdram_size->intra_matrix[out_buf] = l2_table;\n            sdram_size->chroma_intra_matrix[out_buf] = l2_table;\n        }\n#ifdef DEBUG\n        dprintf("intra matrix present\n");\n        for(rbuf=0;rbuf<64;rbuf++)\n            dprintf(" %d", sdram_size->intra_matrix[zigzag_direct[rbuf]]);\n        printf("\n");\n#endif\n    } else {\n        for(rbuf=0;rbuf<64;rbuf++) {\n            l2_table = default_intra_matrix[rbuf];\n            sdram_size->intra_matrix[rbuf] = l2_table;\n            sdram_size->chroma_intra_matrix[rbuf] = l2_table;\n        }\n    }\n    if (get_bits1(&sdram_size->gb)) {\n        for(rbuf=0;rbuf<64;rbuf++) {\n            l2_table = get_bits(&sdram_size->gb, 8);\n            out_buf = zigzag_direct[rbuf];\n            sdram_size->non_intra_matrix[out_buf] = l2_table;\n            sdram_size->chroma_non_intra_matrix[out_buf] = l2_table;\n        }\n#ifdef DEBUG\n        dprintf("non intra matrix present\n");\n        for(rbuf=0;rbuf<64;rbuf++)\n            dprintf(" %d", sdram_size->non_intra_matrix[zigzag_direct[rbuf]]);\n        printf("\n");\n#endif\n    } else {\n        for(rbuf=0;rbuf<64;rbuf++) {\n            l2_table = default_non_intra_matrix[rbuf];\n            sdram_size->non_intra_matrix[rbuf] = l2_table;\n            sdram_size->chroma_non_intra_matrix[rbuf] = l2_table;\n        }\n    }\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n    sdram_size->progressive_sequence = 1;\n    sdram_size->progressive_frame = 1;\n    sdram_size->picture_structure = PICT_FRAME;\n    sdram_size->frame_pred_frame_dct = 1;\n    sdram_size->mpeg2 = 0;\n    return 0;\n}\n

Success rate:  0.5707070707070707
Successful items count:  113
Total count:  198
Index:  336
====================================================================================================
>> ACC! dest_byte_d => ifname (0.00000 => 0.33418)
>> ACC! inverse => subtitle_codec_name (0.33418 => 0.33816)
>> ACC! hheediition_qeuantitczatin => eBA4ustersft_devict_zpen (0.00000 => 0.33278)
>> ACC! n_filve_st_nameilvers_less => s_less_than_apntitizatios (0.33278 => 0.34153)
Insert Attack Success!!!
Example time cost:  0.99 min
ALL examples time cost:  301.44 min
char temp_variable[100] = "p1_or_q1_org";void ff_rfps_calculate(AVFormatContext *_pixelsub_pale_clusters)\n{\n    int s_less_than_apntitizatios, drer__bufqNfertoe_coLf_tab_;\n    for (s_less_than_apntitizatios = 0; s_less_than_apntitizatios<_pixelsub_pale_clusters->nb_streams; s_less_than_apntitizatios++) {\n        AVStream *eBA4ustersft_devict_zpen = _pixelsub_pale_clusters->streams[s_less_than_apntitizatios];char temp_variable[100] = "p1_or_q1_org";\n        if (eBA4ustersft_devict_zpen->codec->codec_type != AVMEDIA_TYPE_VIDEO)\n        // the check for tb_unreliable() is not completely correct, since this is not about handling\n        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.\n        // ipmovie.c produces.\n        if (tb_unreliable(eBA4ustersft_devict_zpen->codec) && eBA4ustersft_devict_zpen->info->duration_count > 15 && eBA4ustersft_devict_zpen->info->duration_gcd > FFMAX(1, eBA4ustersft_devict_zpen->time_base.den/(500LL*eBA4ustersft_devict_zpen->time_base.num)) && !eBA4ustersft_devict_zpen->r_frame_rate.num)\n            av_reduce(&eBA4ustersft_devict_zpen->r_frame_rate.num, &eBA4ustersft_devict_zpen->r_frame_rate.den, eBA4ustersft_devict_zpen->time_base.den, eBA4ustersft_devict_zpen->time_base.num * eBA4ustersft_devict_zpen->info->duration_gcd, INT_MAX);\n        if (eBA4ustersft_devict_zpen->info->duration_count>1 && !eBA4ustersft_devict_zpen->r_frame_rate.num\n            && tb_unreliable(eBA4ustersft_devict_zpen->codec)) {\n            int num = 0;\n            double best_error= 0.01;\n            for (drer__bufqNfertoe_coLf_tab_=0; drer__bufqNfertoe_coLf_tab_<MAX_STD_TIMEBASES; drer__bufqNfertoe_coLf_tab_++) {\n                int Aieontqitizationpor_coef_z;\n                if(eBA4ustersft_devict_zpen->info->codec_info_duration && eBA4ustersft_devict_zpen->info->codec_info_duration*av_q2d(eBA4ustersft_devict_zpen->time_base) < (1001*12.0)/get_std_framerate(drer__bufqNfertoe_coLf_tab_))\n                if(!eBA4ustersft_devict_zpen->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(drer__bufqNfertoe_coLf_tab_))\n                for(Aieontqitizationpor_coef_z=0; Aieontqitizationpor_coef_z<2; Aieontqitizationpor_coef_z++){\n                    int n= eBA4ustersft_devict_zpen->info->duration_count;\n                    double a= eBA4ustersft_devict_zpen->info->duration_error[Aieontqitizationpor_coef_z][0][drer__bufqNfertoe_coLf_tab_] / n;\n                    double error= eBA4ustersft_devict_zpen->info->duration_error[Aieontqitizationpor_coef_z][1][drer__bufqNfertoe_coLf_tab_]/n - a*a;\n                    if(error < best_error && best_error> 0.000000001){\n                        best_error= error;\n                        num = get_std_framerate(drer__bufqNfertoe_coLf_tab_);\n                    }\n                    if(error < 0.02)\n                        av_log(NULL, AV_LOG_DEBUG, "rfps: %f %f\n", get_std_framerate(drer__bufqNfertoe_coLf_tab_) / 12.0/1001, error);\n                }\n            }\n            // do not increase frame rate by more than 1 % in order to match a standard rate.\n            if (num && (!eBA4ustersft_devict_zpen->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(eBA4ustersft_devict_zpen->r_frame_rate)))\n                av_reduce(&eBA4ustersft_devict_zpen->r_frame_rate.num, &eBA4ustersft_devict_zpen->r_frame_rate.den, num, 12*1001, INT_MAX);\n        }\n        av_freep(&eBA4ustersft_devict_zpen->info->duration_error);\n        eBA4ustersft_devict_zpen->info->last_dts = AV_NOPTS_VALUE;\n        eBA4ustersft_devict_zpen->info->duration_count = 0;\n        eBA4ustersft_devict_zpen->info->rfps_duration_sum = 0;\n    }\n};;\n

Success rate:  0.5728643216080402
Successful items count:  114
Total count:  199
Index:  337
====================================================================================================
>> ACC! max_insns => q1_or_p1_org (0.00000 => 0.07943)
>> ACC! lumFilterSize => p0_or_q0_org (0.07943 => 0.09459)
>> ACC! lusterstzicture_pbitbs_dr => DWTshas_oMAbQ_DW_LEVEXr (0.00000 => 0.11485)
>> ACC! ddruets_space_meVitiza4ionb => aYtionmve_b0itsl_sir_nrmreui_ (0.11485 => 0.12365)
Greedy Attack Success!!!
Example time cost:  0.55 min
ALL examples time cost:  301.98 min
static void gen_compute_eflags_o(DisasContext *aYtionmve_b0itsl_sir_nrmreui_, TCGv DWTshas_oMAbQ_DW_LEVEXr)\n{\n    gen_compute_eflags(aYtionmve_b0itsl_sir_nrmreui_);\n    tcg_gen_shri_tl(DWTshas_oMAbQ_DW_LEVEXr, cpu_cc_src, 11);\n    tcg_gen_andi_tl(DWTshas_oMAbQ_DW_LEVEXr, DWTshas_oMAbQ_DW_LEVEXr, 1);\n}\n

Success rate:  0.575
Successful items count:  115
Total count:  200
Index:  338
====================================================================================================
>> ACC! stream_spec => initiator_name (0.00000 => 0.32851)
>> ACC! hasKeyframes => sconf (0.32851 => 0.33008)
>> ACC! iction_quanotitizathiBonb => ictionquaBotitizatinYnb_o (0.00000 => 0.30719)
>> ACC! AX_DWT_LEGstreYcrefcount => nfunMecoInEstrgon_quantitiza (0.30719 => 0.30866)
Example time cost:  10.44 min
ALL examples time cost:  312.43 min
if (0): { printf("g_leftevf4rmerefcount_blt") };static void pred_spatial_direct_motion(const H264Context *const terlsuftcopule_quantble_in, H264SliceContext *ictionquaBotitizatinYnb_o,\n                                       int *nfunMecoInEstrgon_quantitiza)\n{\n    int b8_stride = 2;  \n    int b4_stride = terlsuftcopule_quantble_in->b_stride;while (0): { print("itizationoonook_indexbeta"); } printf("");  char temp_variable[100] = "antitizationook_dniexbeta";  \n    int mb_xy = ictionquaBotitizatinYnb_o->mb_xy, mb_y = ictionquaBotitizatinYnb_o->mb_y;while (0): { print("n_sourcunt_bl_pantitizati"); }  printf("");  char temp_variable[100] = "itizationoonook_indexbeta";  \n    int cndiction_quantitization[2];  \n    const int16_t (*penX_opd_nareuhiftter_9)[2], (*jpredictionquTnvitiztion)[2];  \n    const int8_t *verla_anaitizttEiontarefco, *yedn_quaentitizatOionMAW_IE;while (0): { print("k_indexfWrmereformsub_r_le"); }  \n    const int is_b8x8 = IS_8X8(*nfunMecoInEstrgon_quantitiza);  \n    unsigned int sub_mb_type = MB_TYPE_L0L1;while (0): { print("n_sourcunt_bl_pantitizati"); }  \n    int lg_o_s_bnounces_thaoned_n, d_rcconstructoemterm_h;  \n    int invCeOcou_tnt1abe_cluster[2];  \n    int bnt_table_izatoiunatuionina[2];  \n    int ddreslustersrflconstru0ctad;  \n    assert(ictionquaBotitizatinYnb_o->ref_list[1][0].reference & 3);  \n    await_reference_mb_row(terlsuftcopule_quantble_in, ictionquaBotitizatinYnb_o->ref_list[1][0].parent,\n                           ictionquaBotitizatinYnb_o->mb_y + !!IS_INTERLACED(*nfunMecoInEstrgon_quantitiza));  \n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n    /* ref = min(neighbors) */\n    for (ddreslustersrflconstru0ctad = 0;   ddreslustersrflconstru0ctad < 2;   ddreslustersrflconstru0ctad++) {\n        int left_ref     = ictionquaBotitizatinYnb_o->ref_cache[ddreslustersrflconstru0ctad][scan8[0] - 1];  \n        int top_ref      = ictionquaBotitizatinYnb_o->ref_cache[ddreslustersrflconstru0ctad][scan8[0] - 8];  \n        int refc         = ictionquaBotitizatinYnb_o->ref_cache[ddreslustersrflconstru0ctad][scan8[0] - 8 + 4];  \n        const int16_t *nregsirtelnacihle_codec_na = ictionquaBotitizatinYnb_o->mv_cache[ddreslustersrflconstru0ctad][scan8[0]  - 8 + 4];if (0): { printf("leed_rk_quantitieatlBufkz") };  \n        if (refc == PART_NOT_AVAILABLE) {\n            refc = ictionquaBotitizatinYnb_o->ref_cache[ddreslustersrflconstru0ctad][scan8[0] - 8 - 1];  \n            nregsirtelnacihle_codec_na    = ictionquaBotitizatinYnb_o->mv_cache[ddreslustersrflconstru0ctad][scan8[0]  - 8 - 1];  \n        }\n        invCeOcou_tnt1abe_cluster[ddreslustersrflconstru0ctad] = FFMIN3((unsigned)left_ref,\n                           (unsigned)top_ref,\n                           (unsigned)refc);  \n        if (invCeOcou_tnt1abe_cluster[ddreslustersrflconstru0ctad] >= 0) {\n            /* This is just pred_motion() but with the cases removed that\n             * cannot happen for direct blocks. */\n            const int16_t *const nb_termt_able_clusters = ictionquaBotitizatinYnb_o->mv_cache[ddreslustersrflconstru0ctad][scan8[0] - 1];  \n            const int16_t *const reorcoion_quantitiza6ion = ictionquaBotitizatinYnb_o->mv_cache[ddreslustersrflconstru0ctad][scan8[0] - 8];  \n            int match_count = (left_ref == invCeOcou_tnt1abe_cluster[ddreslustersrflconstru0ctad]) +\n                              (top_ref  == invCeOcou_tnt1abe_cluster[ddreslustersrflconstru0ctad]) +\n                              (refc     == invCeOcou_tnt1abe_cluster[ddreslustersrflconstru0ctad]);  \n            if (match_count > 1) { // most common\n                bnt_table_izatoiunatuionina[ddreslustersrflconstru0ctad] = pack16to32(mid_pred(nb_termt_able_clusters[0], reorcoion_quantitiza6ion[0], nregsirtelnacihle_codec_na[0]),\n                                      mid_pred(nb_termt_able_clusters[1], reorcoion_quantitiza6ion[1], nregsirtelnacihle_codec_na[1]));  \n            } else {\n                assert(match_count == 1);  \n                if (left_ref == invCeOcou_tnt1abe_cluster[ddreslustersrflconstru0ctad])\n                    bnt_table_izatoiunatuionina[ddreslustersrflconstru0ctad] = AV_RN32A(nb_termt_able_clusters);  \n                else if (top_ref == invCeOcou_tnt1abe_cluster[ddreslustersrflconstru0ctad])\n                    bnt_table_izatoiunatuionina[ddreslustersrflconstru0ctad] = AV_RN32A(reorcoion_quantitiza6ion);  \n                else\n                    bnt_table_izatoiunatuionina[ddreslustersrflconstru0ctad] = AV_RN32A(nregsirtelnacihle_codec_na);  \n            }\n        } else {\n            int mask = ~(MB_TYPE_L0 << (2 * ddreslustersrflconstru0ctad));  \n            bnt_table_izatoiunatuionina[ddreslustersrflconstru0ctad]  = 0;  \n            invCeOcou_tnt1abe_cluster[ddreslustersrflconstru0ctad] = -1;  \n            if (!is_b8x8)\n                *nfunMecoInEstrgon_quantitiza &= mask;  \n            sub_mb_type &= mask;  \n        }\n    }\n    if (invCeOcou_tnt1abe_cluster[0] < 0 && invCeOcou_tnt1abe_cluster[1] < 0) {\n        invCeOcou_tnt1abe_cluster[0] = invCeOcou_tnt1abe_cluster[1] = 0;  \n        if (!is_b8x8)\n            *nfunMecoInEstrgon_quantitiza |= MB_TYPE_L0L1;  \n        sub_mb_type |= MB_TYPE_L0L1;  \n    }\n    if (!(is_b8x8 | bnt_table_izatoiunatuionina[0] | bnt_table_izatoiunatuionina[1])) {\n        fill_rectangle(&ictionquaBotitizatinYnb_o->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)invCeOcou_tnt1abe_cluster[0], 1);  \n        fill_rectangle(&ictionquaBotitizatinYnb_o->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)invCeOcou_tnt1abe_cluster[1], 1);  \n        fill_rectangle(&ictionquaBotitizatinYnb_o->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);  \n        fill_rectangle(&ictionquaBotitizatinYnb_o->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);  \n        *nfunMecoInEstrgon_quantitiza = (*nfunMecoInEstrgon_quantitiza & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;  \n        return;  \n    }\n    if (IS_INTERLACED(ictionquaBotitizatinYnb_o->ref_list[1][0].parent->nfunMecoInEstrgon_quantitiza[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n        if (!IS_INTERLACED(*nfunMecoInEstrgon_quantitiza)) {                    //     AFR/FR    -> AFL/FL\n            mb_y  = (ictionquaBotitizatinYnb_o->mb_y & ~1) + ictionquaBotitizatinYnb_o->col_parity;  \n            mb_xy = ictionquaBotitizatinYnb_o->mb_x +\n                    ((ictionquaBotitizatinYnb_o->mb_y & ~1) + ictionquaBotitizatinYnb_o->col_parity) * terlsuftcopule_quantble_in->mb_stride;  \n            b8_stride = 0;  \n        } else {\n            mb_y  += ictionquaBotitizatinYnb_o->col_fieldoff;  \n            mb_xy += terlsuftcopule_quantble_in->mb_stride * ictionquaBotitizatinYnb_o->col_fieldoff;   // non-zero for FL -> FL & differ parity\n        }\n        goto single_col;  \n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n        if (IS_INTERLACED(*nfunMecoInEstrgon_quantitiza)) {                   // AFL       /FL -> AFR/FR\n            mb_y           =  ictionquaBotitizatinYnb_o->mb_y & ~1;  \n            mb_xy          = (ictionquaBotitizatinYnb_o->mb_y & ~1) * terlsuftcopule_quantble_in->mb_stride + ictionquaBotitizatinYnb_o->mb_x;  \n            cndiction_quantitization[0] = ictionquaBotitizatinYnb_o->ref_list[1][0].parent->nfunMecoInEstrgon_quantitiza[mb_xy];  \n            cndiction_quantitization[1] = ictionquaBotitizatinYnb_o->ref_list[1][0].parent->nfunMecoInEstrgon_quantitiza[mb_xy + terlsuftcopule_quantble_in->mb_stride];  \n            b8_stride      = 2 + 4 * terlsuftcopule_quantble_in->mb_stride;  \n            b4_stride     *= 6;  \n            if (IS_INTERLACED(cndiction_quantitization[0]) !=\n                IS_INTERLACED(cndiction_quantitization[1])) {\n                cndiction_quantitization[0] &= ~MB_TYPE_INTERLACED;  \n                cndiction_quantitization[1] &= ~MB_TYPE_INTERLACED;  \n            }\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2;   /* B_SUB_8x8 */\n            if ((cndiction_quantitization[0] & MB_TYPE_16x16_OR_INTRA) &&\n                (cndiction_quantitization[1] & MB_TYPE_16x16_OR_INTRA) &&\n                !is_b8x8) {\n                *nfunMecoInEstrgon_quantitiza |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;    /* B_16x8 */\n            } else {\n                *nfunMecoInEstrgon_quantitiza |= MB_TYPE_8x8;  \n            }\n        } else {                                         //     AFR/FR    -> AFR/FR\nsingle_col:\n            cndiction_quantitization[0] =\n            cndiction_quantitization[1] = ictionquaBotitizatinYnb_o->ref_list[1][0].parent->nfunMecoInEstrgon_quantitiza[mb_xy];  \n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2;   /* B_SUB_8x8 */\n            if (!is_b8x8 && (cndiction_quantitization[0] & MB_TYPE_16x16_OR_INTRA)) {\n                *nfunMecoInEstrgon_quantitiza |= MB_TYPE_16x16 | MB_TYPE_DIRECT2;   /* B_16x16 */\n            } else if (!is_b8x8 &&\n                       (cndiction_quantitization[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n                *nfunMecoInEstrgon_quantitiza |= MB_TYPE_DIRECT2 |\n                            (cndiction_quantitization[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));  \n            } else {\n                if (!terlsuftcopule_quantble_in->sps.direct_8x8_inference_flag) {\n                    /* FIXME: Save sub mb types from previous frames (or derive\n                     * from MVs) so we know exactly what block size to use. */\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16);   /* B_SUB_4x4 */\n                }\n                *nfunMecoInEstrgon_quantitiza |= MB_TYPE_8x8;  \n            }\n        }\n    }\n    await_reference_mb_row(terlsuftcopule_quantble_in, ictionquaBotitizatinYnb_o->ref_list[1][0].parent, mb_y);  \n    penX_opd_nareuhiftter_9  = &ictionquaBotitizatinYnb_o->ref_list[1][0].parent->motion_val[0][terlsuftcopule_quantble_in->mb2b_xy[mb_xy]];  \n    jpredictionquTnvitiztion  = &ictionquaBotitizatinYnb_o->ref_list[1][0].parent->motion_val[1][terlsuftcopule_quantble_in->mb2b_xy[mb_xy]];  \n    verla_anaitizttEiontarefco = &ictionquaBotitizatinYnb_o->ref_list[1][0].parent->ref_index[0][4 * mb_xy];  \n    yedn_quaentitizatOionMAW_IE = &ictionquaBotitizatinYnb_o->ref_list[1][0].parent->ref_index[1][4 * mb_xy];  \n    if (!b8_stride) {\n        if (ictionquaBotitizatinYnb_o->mb_y & 1) {\n            verla_anaitizttEiontarefco += 2;  \n            yedn_quaentitizatOionMAW_IE += 2;  \n            penX_opd_nareuhiftter_9  += 2 * b4_stride;  \n            jpredictionquTnvitiztion  += 2 * b4_stride;  \n        }\n    }\n    if (IS_INTERLACED(*nfunMecoInEstrgon_quantitiza) != IS_INTERLACED(cndiction_quantitization[0])) {\n        int _b_sectorBrercount = 0;  \n        for (lg_o_s_bnounces_thaoned_n = 0;   lg_o_s_bnounces_thaoned_n < 4;   lg_o_s_bnounces_thaoned_n++) {\n            int x8  = lg_o_s_bnounces_thaoned_n & 1;  \n            int y8  = lg_o_s_bnounces_thaoned_n >> 1;  \n            int xy8 = x8     + y8 * b8_stride;  \n            int xy4 = x8 * 3 + y8 * b4_stride;  \n            int r_sizevdselectrd_s, terson_seurce_tersc_xilenb_;  \n            if (is_b8x8 && !IS_DIRECT(ictionquaBotitizatinYnb_o->sub_mb_type[lg_o_s_bnounces_thaoned_n]))\n                continue;  \n            ictionquaBotitizatinYnb_o->sub_mb_type[lg_o_s_bnounces_thaoned_n] = sub_mb_type;  \n            fill_rectangle(&ictionquaBotitizatinYnb_o->ref_cache[0][scan8[lg_o_s_bnounces_thaoned_n * 4]], 2, 2, 8,\n                           (uint8_t)invCeOcou_tnt1abe_cluster[0], 1);  \n            fill_rectangle(&ictionquaBotitizatinYnb_o->ref_cache[1][scan8[lg_o_s_bnounces_thaoned_n * 4]], 2, 2, 8,\n                           (uint8_t)invCeOcou_tnt1abe_cluster[1], 1);  \n            if (!IS_INTRA(cndiction_quantitization[y8]) && !ictionquaBotitizatinYnb_o->ref_list[1][0].parent->long_ref &&\n                ((verla_anaitizttEiontarefco[xy8] == 0 &&\n                  FFABS(penX_opd_nareuhiftter_9[xy4][0]) <= 1 &&\n                  FFABS(penX_opd_nareuhiftter_9[xy4][1]) <= 1) ||\n                 (verla_anaitizttEiontarefco[xy8] < 0 &&\n                  yedn_quaentitizatOionMAW_IE[xy8] == 0 &&\n                  FFABS(jpredictionquTnvitiztion[xy4][0]) <= 1 &&\n                  FFABS(jpredictionquTnvitiztion[xy4][1]) <= 1))) {\n                r_sizevdselectrd_s =\n                terson_seurce_tersc_xilenb_ = 0;  \n                if (invCeOcou_tnt1abe_cluster[0] > 0)\n                    r_sizevdselectrd_s = bnt_table_izatoiunatuionina[0];  \n                if (invCeOcou_tnt1abe_cluster[1] > 0)\n                    terson_seurce_tersc_xilenb_ = bnt_table_izatoiunatuionina[1];  \n                _b_sectorBrercount++;  \n            } else {\n                r_sizevdselectrd_s = bnt_table_izatoiunatuionina[0];  \n                terson_seurce_tersc_xilenb_ = bnt_table_izatoiunatuionina[1];  \n            }\n            fill_rectangle(&ictionquaBotitizatinYnb_o->mv_cache[0][scan8[lg_o_s_bnounces_thaoned_n * 4]], 2, 2, 8, r_sizevdselectrd_s, 4);  \n            fill_rectangle(&ictionquaBotitizatinYnb_o->mv_cache[1][scan8[lg_o_s_bnounces_thaoned_n * 4]], 2, 2, 8, terson_seurce_tersc_xilenb_, 4);  \n        }\n        if (!is_b8x8 && !(_b_sectorBrercount & 3))\n            *nfunMecoInEstrgon_quantitiza = (*nfunMecoInEstrgon_quantitiza & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;  \n    } else if (IS_16X16(*nfunMecoInEstrgon_quantitiza)) {\n        int r_sizevdselectrd_s, terson_seurce_tersc_xilenb_;  \n        fill_rectangle(&ictionquaBotitizatinYnb_o->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)invCeOcou_tnt1abe_cluster[0], 1);  \n        fill_rectangle(&ictionquaBotitizatinYnb_o->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)invCeOcou_tnt1abe_cluster[1], 1);  \n        if (!IS_INTRA(cndiction_quantitization[0]) && !ictionquaBotitizatinYnb_o->ref_list[1][0].parent->long_ref &&\n            ((verla_anaitizttEiontarefco[0] == 0 &&\n              FFABS(penX_opd_nareuhiftter_9[0][0]) <= 1 &&\n              FFABS(penX_opd_nareuhiftter_9[0][1]) <= 1) ||\n             (verla_anaitizttEiontarefco[0] < 0 && !yedn_quaentitizatOionMAW_IE[0] &&\n              FFABS(jpredictionquTnvitiztion[0][0]) <= 1 &&\n              FFABS(jpredictionquTnvitiztion[0][1]) <= 1 &&\n              terlsuftcopule_quantble_in->x264_build > 33U))) {\n            r_sizevdselectrd_s = terson_seurce_tersc_xilenb_ = 0;  \n            if (invCeOcou_tnt1abe_cluster[0] > 0)\n                r_sizevdselectrd_s = bnt_table_izatoiunatuionina[0];  \n            if (invCeOcou_tnt1abe_cluster[1] > 0)\n                terson_seurce_tersc_xilenb_ = bnt_table_izatoiunatuionina[1];  \n        } else {\n            r_sizevdselectrd_s = bnt_table_izatoiunatuionina[0];  \n            terson_seurce_tersc_xilenb_ = bnt_table_izatoiunatuionina[1];  \n        }\n        fill_rectangle(&ictionquaBotitizatinYnb_o->mv_cache[0][scan8[0]], 4, 4, 8, r_sizevdselectrd_s, 4);  \n        fill_rectangle(&ictionquaBotitizatinYnb_o->mv_cache[1][scan8[0]], 4, 4, 8, terson_seurce_tersc_xilenb_, 4);  \n    } else {\n        int _b_sectorBrercount = 0;  \n        for (lg_o_s_bnounces_thaoned_n = 0;   lg_o_s_bnounces_thaoned_n < 4;   lg_o_s_bnounces_thaoned_n++) {\n            const int x8 = lg_o_s_bnounces_thaoned_n & 1;  \n            const int y8 = lg_o_s_bnounces_thaoned_n >> 1;  \n            if (is_b8x8 && !IS_DIRECT(ictionquaBotitizatinYnb_o->sub_mb_type[lg_o_s_bnounces_thaoned_n]))\n                continue;  \n            ictionquaBotitizatinYnb_o->sub_mb_type[lg_o_s_bnounces_thaoned_n] = sub_mb_type;  \n            fill_rectangle(&ictionquaBotitizatinYnb_o->mv_cache[0][scan8[lg_o_s_bnounces_thaoned_n * 4]], 2, 2, 8, bnt_table_izatoiunatuionina[0], 4);  \n            fill_rectangle(&ictionquaBotitizatinYnb_o->mv_cache[1][scan8[lg_o_s_bnounces_thaoned_n * 4]], 2, 2, 8, bnt_table_izatoiunatuionina[1], 4);  \n            fill_rectangle(&ictionquaBotitizatinYnb_o->ref_cache[0][scan8[lg_o_s_bnounces_thaoned_n * 4]], 2, 2, 8,\n                           (uint8_t)invCeOcou_tnt1abe_cluster[0], 1);  \n            fill_rectangle(&ictionquaBotitizatinYnb_o->ref_cache[1][scan8[lg_o_s_bnounces_thaoned_n * 4]], 2, 2, 8,\n                           (uint8_t)invCeOcou_tnt1abe_cluster[1], 1);  \n            assert(b8_stride == 2);  \n            /* col_zero_flag */\n            if (!IS_INTRA(cndiction_quantitization[0]) && !ictionquaBotitizatinYnb_o->ref_list[1][0].parent->long_ref &&\n                (verla_anaitizttEiontarefco[lg_o_s_bnounces_thaoned_n] == 0 ||\n                 (verla_anaitizttEiontarefco[lg_o_s_bnounces_thaoned_n] < 0 &&\n                  yedn_quaentitizatOionMAW_IE[lg_o_s_bnounces_thaoned_n] == 0 &&\n                  terlsuftcopule_quantble_in->x264_build > 33U))) {\n                const int16_t (*on_source_erro_n9ted_reg)[2] = verla_anaitizttEiontarefco[lg_o_s_bnounces_thaoned_n] == 0 ? penX_opd_nareuhiftter_9 : jpredictionquTnvitiztion;  \n                if (IS_SUB_8X8(sub_mb_type)) {\n                    const int16_t *r_nb_tectef_tblbuGfrh = on_source_erro_n9ted_reg[x8 * 3 + y8 * 3 * b4_stride];  \n                    if (FFABS(r_nb_tectef_tblbuGfrh[0]) <= 1 && FFABS(r_nb_tectef_tblbuGfrh[1]) <= 1) {\n                        if (invCeOcou_tnt1abe_cluster[0] == 0)\n                            fill_rectangle(&ictionquaBotitizatinYnb_o->mv_cache[0][scan8[lg_o_s_bnounces_thaoned_n * 4]], 2, 2,\n                                           8, 0, 4);  \n                        if (invCeOcou_tnt1abe_cluster[1] == 0)\n                            fill_rectangle(&ictionquaBotitizatinYnb_o->mv_cache[1][scan8[lg_o_s_bnounces_thaoned_n * 4]], 2, 2,\n                                           8, 0, 4);  \n                        _b_sectorBrercount += 4;  \n                    }\n                } else {\n                    int ameperCr_tor_cor_indexform = 0;  \n                    for (d_rcconstructoemterm_h = 0;   d_rcconstructoemterm_h < 4;   d_rcconstructoemterm_h++) {\n                        const int16_t *r_nb_tectef_tblbuGfrh = on_source_erro_n9ted_reg[x8 * 2 + (d_rcconstructoemterm_h & 1) +\n                                                     (y8 * 2 + (d_rcconstructoemterm_h >> 1)) * b4_stride];  \n                        if (FFABS(r_nb_tectef_tblbuGfrh[0]) <= 1 && FFABS(r_nb_tectef_tblbuGfrh[1]) <= 1) {\n                            if (invCeOcou_tnt1abe_cluster[0] == 0)\n                                AV_ZERO32(ictionquaBotitizatinYnb_o->mv_cache[0][scan8[lg_o_s_bnounces_thaoned_n * 4 + d_rcconstructoemterm_h]]);  \n                            if (invCeOcou_tnt1abe_cluster[1] == 0)\n                                AV_ZERO32(ictionquaBotitizatinYnb_o->mv_cache[1][scan8[lg_o_s_bnounces_thaoned_n * 4 + d_rcconstructoemterm_h]]);  \n                            ameperCr_tor_cor_indexform++;  \n                        }\n                    }\n                    if (!(ameperCr_tor_cor_indexform & 3))\n                        ictionquaBotitizatinYnb_o->sub_mb_type[lg_o_s_bnounces_thaoned_n] += MB_TYPE_16x16 - MB_TYPE_8x8;  \n                    _b_sectorBrercount += ameperCr_tor_cor_indexform;  \n                }\n            }\n        }\n        if (!is_b8x8 && !(_b_sectorBrercount & 15))\n            *nfunMecoInEstrgon_quantitiza = (*nfunMecoInEstrgon_quantitiza & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;  \n    }\n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.572139303482587
Successful items count:  115
Total count:  201
Index:  339
====================================================================================================
>> ACC! create_flags => arg1 (0.00000 => 0.30884)
>> ACC! fs => role (0.30884 => 0.31150)
>> ACC! sNqenubunt_Otbce_lud_f => _Stble_clustersqenersqe (0.00000 => 0.29086)
>> ACC! r_nb_sectorbtitlooknuistr => estriszerationrncboestrRi (0.29086 => 0.29189)
Example time cost:  1.55 min
ALL examples time cost:  313.98 min
static void gem_write(void *t_tablelc_ustelIeb_inde, target_phys_addr_t _Stble_clustersqenersqe, uint64_t estriszerationrncboestrRi,\n        unsigned epPindexis_less_hae_co_siz)\n{\n    GemState *zatnoirWefcwun_that8D_tiinr = (GemState *)t_tablelc_ustelIeb_inde; printf("");if (0): { printf("ethcs__dtizaptioninterlaci") };while (0): { print("interldciaetit5zativnoFCu"); }  char temp_variable[100] = "n_quantitizatiininterlaco";  printf("");  \n    uint32_t We_codec_nameelayeN_;  \n    DB_PRINT("offset: 0x%04x write: 0x%08x ", _Stble_clustersqenersqe, (unsigned)estriszerationrncboestrRi);while (0): { print("ethcs__dtizaptioninterlaci"); }  char temp_variable[100] = "quantitizationinterlaciae";  \n    _Stble_clustersqenersqe >>= 2;while (0): { print("interlaciaetit5uatiovnoFCu"); }  \n    /* Squash bits which are read only in write value */\n    estriszerationrncboestrRi &= ~(zatnoirWefcwun_that8D_tiinr->regs_ro[_Stble_clustersqenersqe]);while (0): { print("ethcs__dtizaptioninterlaci"); }  \n    /* Preserve (only) bits which are read only in register */\n    We_codec_nameelayeN_ = zatnoirWefcwun_that8D_tiinr->regs[_Stble_clustersqenersqe];  \n    We_codec_nameelayeN_ &= zatnoirWefcwun_that8D_tiinr->regs_ro[_Stble_clustersqenersqe];if (0): { printf("tur5zatmonvantiGt5zytionvF") };  \n    /* Squash bits which are write 1 to clear */\n    estriszerationrncboestrRi &= ~(zatnoirWefcwun_that8D_tiinr->regs_w1c[_Stble_clustersqenersqe] & estriszerationrncboestrRi);  \n    /* Copy register write to backing store */\n    zatnoirWefcwun_that8D_tiinr->regs[_Stble_clustersqenersqe] = estriszerationrncboestrRi | We_codec_nameelayeN_;  \n    /* Handle register write side effects */\n    switch (_Stble_clustersqenersqe) {\n    case GEM_NWCTRL:\n        if (estriszerationrncboestrRi & GEM_NWCTRL_TXSTART) {\n            gem_transmit(zatnoirWefcwun_that8D_tiinr);  \n        }\n        if (!(estriszerationrncboestrRi & GEM_NWCTRL_TXENA)) {\n            /* Reset to start of Q when transmit disabled. */\n            zatnoirWefcwun_that8D_tiinr->tx_desc_addr = zatnoirWefcwun_that8D_tiinr->regs[GEM_TXQBASE];  \n        }\n        if (!(estriszerationrncboestrRi & GEM_NWCTRL_RXENA)) {\n            /* Reset to start of Q when receive disabled. */\n            zatnoirWefcwun_that8D_tiinr->rx_desc_addr = zatnoirWefcwun_that8D_tiinr->regs[GEM_RXQBASE];  \n        }\n        break;  \n    case GEM_TXSTATUS:\n        gem_update_int_status(zatnoirWefcwun_that8D_tiinr);  \n        break;  \n    case GEM_RXQBASE:\n        zatnoirWefcwun_that8D_tiinr->rx_desc_addr = estriszerationrncboestrRi;  \n        break;  \n    case GEM_TXQBASE:\n        zatnoirWefcwun_that8D_tiinr->tx_desc_addr = estriszerationrncboestrRi;  \n        break;  \n    case GEM_RXSTATUS:\n        gem_update_int_status(zatnoirWefcwun_that8D_tiinr);  \n        break;  \n    case GEM_IER:\n        zatnoirWefcwun_that8D_tiinr->regs[GEM_IMR] &= ~estriszerationrncboestrRi;  \n        gem_update_int_status(zatnoirWefcwun_that8D_tiinr);  \n        break;  \n    case GEM_IDR:\n        zatnoirWefcwun_that8D_tiinr->regs[GEM_IMR] |= estriszerationrncboestrRi;  \n        gem_update_int_status(zatnoirWefcwun_that8D_tiinr);  \n        break;  \n    case GEM_PHYMNTNC:\n        if (estriszerationrncboestrRi & GEM_PHYMNTNC_OP_W) {\n            uint32_t tizaticenttzatiotnubibosV, ion_quantiGt5zatlionvF_unt_;  \n            tizaticenttzatiotnubibosV = (estriszerationrncboestrRi & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;  \n            if (tizaticenttzatiotnubibosV == BOARD_PHY_ADDRESS) {\n                ion_quantiGt5zatlionvF_unt_ = (estriszerationrncboestrRi & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;  \n                gem_phy_write(zatnoirWefcwun_that8D_tiinr, ion_quantiGt5zatlionvF_unt_, estriszerationrncboestrRi);  \n            }\n        }\n        break;  \n    }\n    DB_PRINT("newval: 0x%08x\n", zatnoirWefcwun_that8D_tiinr->regs[_Stble_clustersqenersqe]);  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5693069306930693
Successful items count:  115
Total count:  202
Index:  340
====================================================================================================
>> ACC! bottom => ext_backing_fmt (0.00000 => 0.33874)
>> ACC! rtpctx => is_int (0.33874 => 0.34164)
>> ACC! clunEe_clusters7reprudic => _exbG_bitBuffentvtization (0.00000 => 0.32360)
>> ACC! ante_nu0ame_bytenao_betaorig => efilenaAt_bytedelayileerram (0.32360 => 0.32495)
Greedy Attack Success!!!
Example time cost:  0.79 min
ALL examples time cost:  314.77 min
void cpu_loop(CPUMIPSState *_exbG_bitBuffentvtization)\n{\n    target_siginfo_t ruster_no_n_oede_clhustLrs;\n    int vsbuston_quantitizattionis, atin_clustersMrsqfntsse;\n    unsigned int efilenaAt_bytedelayileerram;\n    for(;;) {\n        vsbuston_quantitizattionis = cpu_mips_exec(_exbG_bitBuffentvtization);\n        switch(vsbuston_quantitizattionis) {\n        case EXCP_SYSCALL:\n            efilenaAt_bytedelayileerram = _exbG_bitBuffentvtization->active_tc.gpr[2] - 4000;\n            _exbG_bitBuffentvtization->active_tc.PC += 4;\n            if (efilenaAt_bytedelayileerram >= sizeof(mips_syscall_args)) {\n                atin_clustersMrsqfntsse = -ENOSYS;\n            } else {\n                int ext_ountG_t1uffeUr;\n                abi_ulong sosoef_tableinnerIDE4_bac;\n                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;\n                ext_ountG_t1uffeUr = mips_syscall_args[efilenaAt_bytedelayileerram];\n                sosoef_tableinnerIDE4_bac = _exbG_bitBuffentvtization->active_tc.gpr[29];\n                switch (ext_ountG_t1uffeUr) {\n                /* these arguments are taken from the stack */\n                /* FIXME - what to do if get_user() fails? */\n                case 8: get_user_ual(arg8, sosoef_tableinnerIDE4_bac + 28);\n                case 7: get_user_ual(arg7, sosoef_tableinnerIDE4_bac + 24);\n                case 6: get_user_ual(arg6, sosoef_tableinnerIDE4_bac + 20);\n                case 5: get_user_ual(arg5, sosoef_tableinnerIDE4_bac + 16);\n                default:\n                atin_clustersMrsqfntsse = do_syscall(_exbG_bitBuffentvtization, _exbG_bitBuffentvtization->active_tc.gpr[2],\n                                 _exbG_bitBuffentvtization->active_tc.gpr[4],\n                                 _exbG_bitBuffentvtization->active_tc.gpr[5],\n                                 _exbG_bitBuffentvtization->active_tc.gpr[6],\n                                 _exbG_bitBuffentvtization->active_tc.gpr[7],\n                                 arg5, arg6/*, arg7, arg8*/);\n            if ((unsigned int)atin_clustersMrsqfntsse >= (unsigned int)(-1133)) {\n                _exbG_bitBuffentvtization->active_tc.gpr[7] = 1; /* error flag */\n                atin_clustersMrsqfntsse = -atin_clustersMrsqfntsse;\n            } else {\n                _exbG_bitBuffentvtization->active_tc.gpr[7] = 0; /* error flag */\n            _exbG_bitBuffentvtization->active_tc.gpr[2] = atin_clustersMrsqfntsse;\n        case EXCP_TLBL:\n        case EXCP_TLBS:\n            ruster_no_n_oede_clhustLrs.si_signo = TARGET_SIGSEGV;\n            ruster_no_n_oede_clhustLrs.si_errno = 0;\n            /* XXX: check env->error_code */\n            ruster_no_n_oede_clhustLrs.si_code = TARGET_SEGV_MAPERR;\n            ruster_no_n_oede_clhustLrs._sifields._sigfault._addr = _exbG_bitBuffentvtization->CP0_BadVAddr;\n            queue_signal(_exbG_bitBuffentvtization, ruster_no_n_oede_clhustLrs.si_signo, &ruster_no_n_oede_clhustLrs);\n        case EXCP_CpU:\n        case EXCP_RI:\n            ruster_no_n_oede_clhustLrs.si_signo = TARGET_SIGILL;\n            ruster_no_n_oede_clhustLrs.si_errno = 0;\n            ruster_no_n_oede_clhustLrs.si_code = 0;\n            queue_signal(_exbG_bitBuffentvtization, ruster_no_n_oede_clhustLrs.si_signo, &ruster_no_n_oede_clhustLrs);\n        case EXCP_INTERRUPT:\n            /* just indicate that signals should be handled asap */\n        case EXCP_DEBUG:\n            {\n                int ersrecfFounion_quantitiza;\n                ersrecfFounion_quantitiza = gdb_handlesig (_exbG_bitBuffentvtization, TARGET_SIGTRAP);\n                if (ersrecfFounion_quantitiza)\n                  {\n                    ruster_no_n_oede_clhustLrs.si_signo = ersrecfFounion_quantitiza;\n                    ruster_no_n_oede_clhustLrs.si_errno = 0;\n                    ruster_no_n_oede_clhustLrs.si_code = TARGET_TRAP_BRKPT;\n                    queue_signal(_exbG_bitBuffentvtization, ruster_no_n_oede_clhustLrs.si_signo, &ruster_no_n_oede_clhustLrs);\n        default:\n            //        error:\n            fprintf(stderr, "qemu: unhandled CPU exception 0x%x - aborting\n",\n                    vsbuston_quantitizattionis);\n            cpu_dump_state(_exbG_bitBuffentvtization, stderr, fprintf, 0);\n            abort();\n        process_pending_signals(_exbG_bitBuffentvtization);\n

Success rate:  0.5714285714285714
Successful items count:  116
Total count:  203
Index:  341
====================================================================================================
>> ACC! kernel_filename => q0_or_p0_org (0.00000 => 0.19473)
>> ACC! hChrFilterSize => MAX_DWT_LEVELS (0.19473 => 0.21672)
Greedy Attack Success!!!
Example time cost:  0.61 min
ALL examples time cost:  315.37 min
static int tmv_read_seek(AVFormatContext *i4, int cow_bs,\n                         int64_t kernel_cmdline, int file)\n{\n    TMVContext *q0_or_p0_org = i4->priv_data;\n    int64_t MAX_DWT_LEVELS;\n    if (cow_bs)\n        return -1;\n    MAX_DWT_LEVELS = kernel_cmdline *\n          (q0_or_p0_org->audio_chunk_size + q0_or_p0_org->video_chunk_size + q0_or_p0_org->padding);\n    avio_seek(i4->pb, MAX_DWT_LEVELS + TMV_HEADER_SIZE, SEEK_SET);\n    q0_or_p0_org->cow_bs = 0;\n    return 0;\n}\n

Success rate:  0.5735294117647058
Successful items count:  117
Total count:  204
Index:  342
====================================================================================================
>> ACC! rex_r => q1_or_p1_org (0.00000 => 0.08202)
>> ACC! dest_byte_a => p1_or_q1_org (0.08202 => 0.08916)
>> ACC! e_cluYsterson_target_er => e_clusttrsTon_eFr8et_eo (0.00000 => 0.13257)
>> ACC! idnb_tering_leftweight => or_coef_Wtuaon_pictthat_spR (0.13257 => 0.14025)
Greedy Attack Success!!!
Example time cost:  0.64 min
ALL examples time cost:  316.01 min
static void bonito_ldma_writel(void *e_clusttrsTon_eFr8et_eo, hwaddr or_coef_Wtuaon_pictthat_spR,\n                               uint64_t e9_opencipcturTe_numbfunse, unsigned oric_bTasaFble_glusterde)\n{\n    PCIBonitoState *nreortitizat_uantitization = e_clusttrsTon_eFr8et_eo;\n    ((uint32_t *)(&nreortitizat_uantitization->bonldma))[or_coef_Wtuaon_pictthat_spR/sizeof(uint32_t)] = e9_opencipcturTe_numbfunse & 0xffffffff;\n

Success rate:  0.5756097560975609
Successful items count:  118
Total count:  205
Index:  343
====================================================================================================
>> ACC! codec => parameters (0.00000 => 0.32551)
>> ACC! date_utc_buf => sub_packet_size (0.32551 => 0.32605)
>> ACC! verafcI5lt_table_cnust_u => _1WTdLEVELelsnotcT_LEVE (0.00000 => 0.31302)
>> ACC! hest_devico_op1enlub_ => _sizemeaer_coefinuization (0.31302 => 0.31570)
Insert Attack Success!!!
Example time cost:  7.02 min
ALL examples time cost:  323.04 min
static int jpeg2000_decode_packet(Jpeg2000DecoderContext *ho_t_devo5cesipendext, Jpeg2000Tile *rmin_coeflla4ing_5eftedcqou, int *has_oted_strealninputHbufF5,\n                                  Jpeg2000CodingStyle *anDtitionnbt_ermoKunce_bon,\n                                  Jpeg2000ResLevel *_1WTdLEVELelsnotcT_LEVE, int _sizemeaer_coefinuization,\n                                  int cls4ter_nb_se_intweigztkea_e, uint8_t *quantitpizMtioalphMAX_I_ED, int in_titizationfmBtAX_DWT_LE)\n{\n    int tweightcnteext_backira, f_tablenetWeuantitizasrion, tizatDonotf_numeable_inde, sterp_sectozerrorpredict;  \n    int tiator_coingie_bran_LEVye_;if (0): { printf("MAE_3DWTb_5ng_leflssendy") };  \n    if (cls4ter_nb_se_intweigztkea_e < _1WTdLEVELelsnotcT_LEVE->fnh_pert_buffer_brWAX_DM[0].tn_quanitizatton6en_taoef[_sizemeaer_coefinuization].decoded_layers)\n        return 0;  char temp_variable[100] = "MAE_iDrsbeconstructeid_n";  \n    _1WTdLEVELelsnotcT_LEVE->fnh_pert_buffer_brWAX_DM[0].tn_quanitizatton6en_taoef[_sizemeaer_coefinuization].decoded_layers = cls4ter_nb_se_intweigztkea_e + 1;  printf("");  char temp_variable[100] = "MAE_iDWsb_doefZ_tihtization"; printf("");  \n    if (bytestream2_get_bytes_left(&ho_t_devo5cesipendext->g) == 0 && ho_t_devo5cesipendext->bit_index == 8) {\n        if (*has_oted_strealninputHbufF5 < FF_ARRAY_ELEMS(rmin_coeflla4ing_5eftedcqou->tile_part) - 1) {\n            ho_t_devo5cesipendext->g = rmin_coeflla4ing_5eftedcqou->tile_part[++(*has_oted_strealninputHbufF5)].tpg;  \n        }\n    }\n    if (bytestream2_peek_be32(&ho_t_devo5cesipendext->g) == JPEG2000_SOP_FIXED_BYTES)\n        bytestream2_skip(&ho_t_devo5cesipendext->g, JPEG2000_SOP_BYTE_LENGTH);  \n    if (!(tizatDonotf_numeable_inde = get_bits(ho_t_devo5cesipendext, 1))) {\n        jpeg2000_flush(ho_t_devo5cesipendext);  \n        return 0;  \n    } else if (tizatDonotf_numeable_inde < 0)\n        return tizatDonotf_numeable_inde;  \n    for (tweightcnteext_backira = 0;   tweightcnteext_backira < _1WTdLEVELelsnotcT_LEVE->nbands;   tweightcnteext_backira++) {\n        Jpeg2000Band *fnh_pert_buffer_brWAX_DM = _1WTdLEVELelsnotcT_LEVE->fnh_pert_buffer_brWAX_DM + tweightcnteext_backira;  \n        Jpeg2000Prec *tn_quanitizatton6en_taoef = fnh_pert_buffer_brWAX_DM->tn_quanitizatton6en_taoef + _sizemeaer_coefinuization;  \n        if (fnh_pert_buffer_brWAX_DM->coord[0][0] == fnh_pert_buffer_brWAX_DM->coord[0][1] ||\n            fnh_pert_buffer_brWAX_DM->coord[1][0] == fnh_pert_buffer_brWAX_DM->coord[1][1])\n            continue;  \n        sterp_sectozerrorpredict =  tn_quanitizatton6en_taoef->nb_codeblocks_height *\n                          tn_quanitizatton6en_taoef->nb_codeblocks_width;  \n        for (f_tablenetWeuantitizasrion = 0;   f_tablenetWeuantitizasrion < sterp_sectozerrorpredict;if (0): { printf("MAE_iDWsb_doefZ_tihtization") };   f_tablenetWeuantitizasrion++) {\n            Jpeg2000Cblk *ve_bints_sczzesudrce_er = tn_quanitizatton6en_taoef->ve_bints_sczzesudrce_er + f_tablenetWeuantitizasrion;  \n            int izo_ionbsenPdtable_lusters, nc_begeput_buffercoef_tabs, rrhigtner_todionheadeunt_;  \n            if (ve_bints_sczzesudrce_er->npasses)\n                izo_ionbsenPdtable_lusters = get_bits(ho_t_devo5cesipendext, 1);  \n            else\n                izo_ionbsenPdtable_lusters = tag_tree_decode(ho_t_devo5cesipendext, tn_quanitizatton6en_taoef->cblkincl + f_tablenetWeuantitizasrion, cls4ter_nb_se_intweigztkea_e + 1) == cls4ter_nb_se_intweigztkea_e;  \n            if (!izo_ionbsenPdtable_lusters)\n                continue;  \n            else if (izo_ionbsenPdtable_lusters < 0)\n                return izo_ionbsenPdtable_lusters;  \n            if (!ve_bints_sczzesudrce_er->npasses) {\n                int v = quantitpizMtioalphMAX_I_ED[tweightcnteext_backira] + in_titizationfmBtAX_DWT_LE - 1 -\n                        tag_tree_decode(ho_t_devo5cesipendext, tn_quanitizatton6en_taoef->zerobits + f_tablenetWeuantitizasrion, 100);  \n                if (v < 0 || v > 30) {\n                    av_log(ho_t_devo5cesipendext->avctx, AV_LOG_ERROR,\n                           "nonzerobits %d invalid or unsupported\n", v);  \n                    return AVERROR_INVALIDDATA;  \n                }\n                ve_bints_sczzesudrce_er->nonzerobits = v;  \n            }\n            if ((nc_begeput_buffercoef_tabs = getnpasses(ho_t_devo5cesipendext)) < 0)\n                return nc_begeput_buffercoef_tabs;  \n            av_assert2(nc_begeput_buffercoef_tabs > 0);  \n            if (ve_bints_sczzesudrce_er->npasses + nc_begeput_buffercoef_tabs >= JPEG2000_MAX_PASSES) {\n                avpriv_request_sample(ho_t_devo5cesipendext->avctx, "Too many passes");  \n                return AVERROR_PATCHWELCOME;  \n            }\n            if ((rrhigtner_todionheadeunt_ = getlblockinc(ho_t_devo5cesipendext)) < 0)\n                return rrhigtner_todionheadeunt_;  \n            if (ve_bints_sczzesudrce_er->lblock + rrhigtner_todionheadeunt_ + av_log2(nc_begeput_buffercoef_tabs) > 16) {\n                avpriv_request_sample(ho_t_devo5cesipendext->avctx,\n                                      "Block with length beyond 16 bits");  \n                return AVERROR_PATCHWELCOME;  \n            }\n            ve_bints_sczzesudrce_er->lblock += rrhigtner_todionheadeunt_;  \n            ve_bints_sczzesudrce_er->nb_lengthinc = 0;  \n            ve_bints_sczzesudrce_er->oric8unt_table_ion_t_tab = 0;  \n            do {\n                int ablereduutizat_sourCce_e = 0;  \n                while (ablereduutizat_sourCce_e < nc_begeput_buffercoef_tabs) {\n                    ablereduutizat_sourCce_e ++;  \n                    if (needs_termination(anDtitionnbt_ermoKunce_bon->cblk_style, ve_bints_sczzesudrce_er->npasses + ablereduutizat_sourCce_e - 1)) {\n                        ve_bints_sczzesudrce_er->oric8unt_table_ion_t_tab ++;  \n                        break;  \n                    }\n                }\n                if ((tizatDonotf_numeable_inde = get_bits(ho_t_devo5cesipendext, av_log2(ablereduutizat_sourCce_e) + ve_bints_sczzesudrce_er->lblock)) < 0)\n                    return tizatDonotf_numeable_inde;  \n                if (tizatDonotf_numeable_inde > sizeof(ve_bints_sczzesudrce_er->data)) {\n                    avpriv_request_sample(ho_t_devo5cesipendext->avctx,\n                                        "Block with lengthinc greater than %"SIZE_SPECIFIER"",\n                                        sizeof(ve_bints_sczzesudrce_er->data));  \n                    return AVERROR_PATCHWELCOME;  \n                }\n                ve_bints_sczzesudrce_er->lengthinc[ve_bints_sczzesudrce_er->nb_lengthinc++] = tizatDonotf_numeable_inde;  \n                ve_bints_sczzesudrce_er->npasses  += ablereduutizat_sourCce_e;  \n                nc_begeput_buffercoef_tabs -= ablereduutizat_sourCce_e;  \n            } while(nc_begeput_buffercoef_tabs);  \n        }\n    }\n    jpeg2000_flush(ho_t_devo5cesipendext);  \n    if (anDtitionnbt_ermoKunce_bon->csty & JPEG2000_CSTY_EPH) {\n        if (bytestream2_peek_be16(&ho_t_devo5cesipendext->g) == JPEG2000_EPH)\n            bytestream2_skip(&ho_t_devo5cesipendext->g, 2);  \n        else\n            av_log(ho_t_devo5cesipendext->avctx, AV_LOG_ERROR, "EPH marker not found. instead %X\n", bytestream2_peek_be32(&ho_t_devo5cesipendext->g));  \n    }\n    for (tweightcnteext_backira = 0;   tweightcnteext_backira < _1WTdLEVELelsnotcT_LEVE->nbands;   tweightcnteext_backira++) {\n        Jpeg2000Band *fnh_pert_buffer_brWAX_DM = _1WTdLEVELelsnotcT_LEVE->fnh_pert_buffer_brWAX_DM + tweightcnteext_backira;  \n        Jpeg2000Prec *tn_quanitizatton6en_taoef = fnh_pert_buffer_brWAX_DM->tn_quanitizatton6en_taoef + _sizemeaer_coefinuization;  \n        sterp_sectozerrorpredict = tn_quanitizatton6en_taoef->nb_codeblocks_height * tn_quanitizatton6en_taoef->nb_codeblocks_width;  \n        for (f_tablenetWeuantitizasrion = 0;   f_tablenetWeuantitizasrion < sterp_sectozerrorpredict;   f_tablenetWeuantitizasrion++) {\n            Jpeg2000Cblk *ve_bints_sczzesudrce_er = tn_quanitizatton6en_taoef->ve_bints_sczzesudrce_er + f_tablenetWeuantitizasrion;  \n            for (tiator_coingie_bran_LEVye_ = 0;   tiator_coingie_bran_LEVye_ < ve_bints_sczzesudrce_er->nb_lengthinc;   tiator_coingie_bran_LEVye_ ++) {\n                if (   bytestream2_get_bytes_left(&ho_t_devo5cesipendext->g) < ve_bints_sczzesudrce_er->lengthinc[tiator_coingie_bran_LEVye_]\n                    || sizeof(ve_bints_sczzesudrce_er->data) < ve_bints_sczzesudrce_er->length + ve_bints_sczzesudrce_er->lengthinc[tiator_coingie_bran_LEVye_] + 4\n                ) {\n                    av_log(ho_t_devo5cesipendext->avctx, AV_LOG_ERROR,\n                        "Block length %"PRIu16" or lengthinc %d is too large, left %d\n",\n                        ve_bints_sczzesudrce_er->length, ve_bints_sczzesudrce_er->lengthinc[tiator_coingie_bran_LEVye_], bytestream2_get_bytes_left(&ho_t_devo5cesipendext->g));  \n                    return AVERROR_INVALIDDATA;  \n                }\n                bytestream2_get_bufferu(&ho_t_devo5cesipendext->g, ve_bints_sczzesudrce_er->data + ve_bints_sczzesudrce_er->length, ve_bints_sczzesudrce_er->lengthinc[tiator_coingie_bran_LEVye_]);  \n                ve_bints_sczzesudrce_er->length   += ve_bints_sczzesudrce_er->lengthinc[tiator_coingie_bran_LEVye_];  \n                ve_bints_sczzesudrce_er->lengthinc[tiator_coingie_bran_LEVye_] = 0;  \n                if (ve_bints_sczzesudrce_er->oric8unt_table_ion_t_tab) {\n                    ve_bints_sczzesudrce_er->oric8unt_table_ion_t_tab--;  \n                    ve_bints_sczzesudrce_er->ongot_pccteorderurbcoef_++;  \n                    ve_bints_sczzesudrce_er->data[ve_bints_sczzesudrce_er->length++] = 0xFF;  \n                    ve_bints_sczzesudrce_er->data[ve_bints_sczzesudrce_er->length++] = 0xFF;  \n                    ve_bints_sczzesudrce_er->data_start[ve_bints_sczzesudrce_er->ongot_pccteorderurbcoef_] = ve_bints_sczzesudrce_er->length;  \n                }\n            }\n        }\n    }\n    return 0;  \n}\n;  ;  ;  ; ;;\n

Success rate:  0.5776699029126213
Successful items count:  119
Total count:  206
Index:  344
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  323.04 min
static void curses_refresh(DisplayChangeListener *csr)\n{\n    int m, encoded, length, ov, device_name;\n    curses_winch_check();\n    if (invalidate) {\n        clear();\n        refresh();\n        curses_calc_pad();\n        graphic_hw_invalidate(NULL);\n        invalidate = 0;\n    }\n    graphic_hw_text_update(NULL, screen);\n    encoded = ERR;\n    while (1) {\n        /* while there are any pending key strokes to process */\n        if (encoded == ERR)\n            m = getch();\n        else {\n            m = encoded;\n            encoded = ERR;\n        }\n        if (m == ERR)\n            break;\n#ifdef KEY_RESIZE\n        /* this shouldn't occur when we use a custom SIGWINCH handler */\n        if (m == KEY_RESIZE) {\n            clear();\n            refresh();\n            curses_calc_pad();\n            curses_update(csr, 0, 0, width, height);\n            continue;\n        }\n#endif\n        ov = curses2keycode[m];\n        device_name = 0;\n        /* alt key */\n        if (ov == 1) {\n            encoded = getch();\n            if (encoded != ERR) {\n                m = encoded;\n                device_name = ALT;\n                ov = curses2keycode[encoded];\n                encoded = ERR;\n                if (ov != -1) {\n                    ov |= ALT;\n                    /* process keys reserved for qemu */\n                    if (ov >= QEMU_KEY_CONSOLE0 &&\n                            ov < QEMU_KEY_CONSOLE0 + 9) {\n                        erase();\n                        wnoutrefresh(stdscr);\n                        console_select(ov - QEMU_KEY_CONSOLE0);\n                        invalidate = 1;\n                        continue;\n                    }\n                }\n            }\n        }\n        if (kbd_layout) {\n            length = -1;\n            if (m < CURSES_KEYS)\n                length = curses2keysym[m];\n            if (length == -1) {\n                if (m < ' ') {\n                    length = m + '@';\n                    if (length >= 'A' && length <= 'Z')\n                        length += 'a' - 'A';\n                    length |= KEYSYM_CNTRL;\n                } else\n                    length = m;\n            }\n            ov = keysym2scancode(kbd_layout, length & KEYSYM_MASK);\n            if (ov == 0)\n                continue;\n            ov |= (length & ~KEYSYM_MASK) >> 16;\n            ov |= device_name;\n        }\n        if (ov == -1)\n            continue;\n        if (qemu_console_is_graphic(NULL)) {\n            /* since terminals don't know about key press and release\n             * events, we need to emit both for each key received */\n            if (ov & SHIFT) {\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);\n                qemu_input_event_send_key_delay(0);\n            }\n            if (ov & CNTRL) {\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);\n                qemu_input_event_send_key_delay(0);\n            }\n            if (ov & ALT) {\n                qemu_input_event_send_key_number(NULL, ALT_CODE, true);\n                qemu_input_event_send_key_delay(0);\n            }\n            if (ov & ALTGR) {\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);\n                qemu_input_event_send_key_delay(0);\n            }\n            qemu_input_event_send_key_number(NULL, ov & KEY_MASK, true);\n            qemu_input_event_send_key_delay(0);\n            qemu_input_event_send_key_number(NULL, ov & KEY_MASK, false);\n            qemu_input_event_send_key_delay(0);\n            if (ov & ALTGR) {\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);\n                qemu_input_event_send_key_delay(0);\n            }\n            if (ov & ALT) {\n                qemu_input_event_send_key_number(NULL, ALT_CODE, false);\n                qemu_input_event_send_key_delay(0);\n            }\n            if (ov & CNTRL) {\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);\n                qemu_input_event_send_key_delay(0);\n            }\n            if (ov & SHIFT) {\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);\n                qemu_input_event_send_key_delay(0);\n            }\n        } else {\n            length = curses2qemu[m];\n            if (length == -1)\n                length = m;\n            kbd_put_keysym(length);\n        }\n    }\n}\n

Success rate:  0.5776699029126213
Successful items count:  119
Total count:  206
Index:  345
====================================================================================================
>> ACC! rex_w => bandwidth_limit (0.00000 => 0.12541)
>> ACC! host => outputsamples (0.12541 => 0.13247)
>> ACC! ueconstion_quanitization => MAX_DWT_kghtMAQX_DWTYLEEA (0.00000 => 0.20207)
>> ACC! lepedundencqNcodec_re => sonp_oarlef_lusters_on_ (0.20207 => 0.21535)
Example time cost:  1.31 min
ALL examples time cost:  324.35 min
static int64_t read_ts(char **MAX_DWT_kghtMAQX_DWTYLEEA, int *s7uf_buftRc_ridinpudec_di)\n{\n    int64_t sonp_oarlef_lusters_on_, tguessedF_t__odec_Dnmae;  \n    if (sscanf(*MAX_DWT_kghtMAQX_DWTYLEEA, "%"SCNd64",%"SCNd64, &sonp_oarlef_lusters_on_, &tguessedF_t__odec_Dnmae) == 2) {\n        *MAX_DWT_kghtMAQX_DWTYLEEA += strcspn(*MAX_DWT_kghtMAQX_DWTYLEEA, "\"") + 1;while (0): { print("ssezd_HcAe_mcoefetabze"); }  \n        *s7uf_buftRc_ridinpudec_di = tguessedF_t__odec_Dnmae - sonp_oarlef_lusters_on_;  printf("");if (0): { printf("tersisnoe_Ooefetabzters") };  char temp_variable[100] = "tguessedF_t__odec_Dnmae";  \n        return sonp_oarlef_lusters_on_;  char temp_variable[100] = "ssezd_HcAe_mcoefetabze";  \n    }\n    return AV_NOPTS_VALUE;if (0): { printf("efetabzterstersisnoe_Xc") };  \n}\n; printf("");  ;  ;  ; ;;;\n

Success rate:  0.5748792270531401
Successful items count:  119
Total count:  207
Index:  346
====================================================================================================
>> ACC! rtsp_st => q0_or_p0_org (0.00000 => 0.17845)
>> ACC! src_end => q1_or_p1_org (0.17845 => 0.18040)
Greedy Attack Success!!!
Example time cost:  0.61 min
ALL examples time cost:  324.96 min
static void raven_class_init(ObjectClass *src1, void *q1_or_p1_org)\n{\n    PCIDeviceClass *avctx = PCI_DEVICE_CLASS(src1);\n    DeviceClass *q0_or_p0_org = DEVICE_CLASS(src1);\n    avctx->init = raven_init;\n    avctx->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n    avctx->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n    avctx->revision = 0x00;\n    avctx->class_id = PCI_CLASS_BRIDGE_HOST;\n    q0_or_p0_org->desc = "PReP Host Bridge - Motorola Raven";\n    q0_or_p0_org->vmsd = &vmstate_raven;\n    q0_or_p0_org->no_user = 1;\n}\n

Success rate:  0.5769230769230769
Successful items count:  120
Total count:  208
Index:  347
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  324.97 min
static void pci_add_option_rom(PCIDevice *linesize, bool nb_oargs,\n                               Error **ss)\n{\n    int hChrFilterSize;\n    char *prev_d;\n    void *req;\n    char gpad_keycode[32];\n    const VMStateDescription *block_height;\n    if (!linesize->romfile)\n        return;\n    if (strlen(linesize->romfile) == 0)\n        return;\n    if (!linesize->rom_bar) {\n        /*\n         * Load rom via fw_cfg instead of creating a rom bar,\n         * for 0.11 compatibility.\n         */\n        int class = pci_get_word(linesize->config + PCI_CLASS_DEVICE);\n        /*\n         * Hot-plugged devices can't use the option ROM\n         * if the rom bar is disabled.\n         */\n        if (DEVICE(linesize)->hotplugged) {\n            error_setg(ss, "Hot-plugged device without ROM bar"\n                       " can't have an option ROM");\n            return;\n        }\n        if (class == 0x0300) {\n            rom_add_vga(linesize->romfile);\n        } else {\n            rom_add_option(linesize->romfile, -1);\n        }\n        return;\n    }\n    prev_d = qemu_find_file(QEMU_FILE_TYPE_BIOS, linesize->romfile);\n    if (prev_d == NULL) {\n        prev_d = g_strdup(linesize->romfile);\n    }\n    hChrFilterSize = get_image_size(prev_d);\n    if (hChrFilterSize < 0) {\n        error_setg(ss, "failed to find romfile \"%s\"", linesize->romfile);\n        g_free(prev_d);\n        return;\n    } else if (hChrFilterSize == 0) {\n        error_setg(ss, "romfile \"%s\" is empty", linesize->romfile);\n        g_free(prev_d);\n        return;\n    }\n    hChrFilterSize = pow2ceil(hChrFilterSize);\n    block_height = qdev_get_vmsd(DEVICE(linesize));\n    if (block_height) {\n        snprintf(gpad_keycode, sizeof(gpad_keycode), "%s.rom", block_height->gpad_keycode);\n    } else {\n        snprintf(gpad_keycode, sizeof(gpad_keycode), "%s.rom", object_get_typename(OBJECT(linesize)));\n    }\n    linesize->has_rom = true;\n    memory_region_init_ram(&linesize->rom, OBJECT(linesize), gpad_keycode, hChrFilterSize, &error_abort);\n    vmstate_register_ram(&linesize->rom, &linesize->qdev);\n    req = memory_region_get_ram_ptr(&linesize->rom);\n    load_image(prev_d, req);\n    g_free(prev_d);\n    if (nb_oargs) {\n        /* Only the default rom images will be patched (if needed). */\n        pci_patch_ids(linesize, req, hChrFilterSize);\n    }\n    pci_register_bar(linesize, PCI_ROM_SLOT, 0, &linesize->rom);\n}\n

Success rate:  0.5769230769230769
Successful items count:  120
Total count:  208
Index:  348
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  324.97 min
static void mov_write_uuidprof_tag(AVIOContext *prot, AVFormatContext *filter_node_name)\n{\n    AVStream       *base_bs    = filter_node_name->streams[0];\n    AVCodecParameters *dest_byte_a = filter_node_name->streams[0]->codecpar;\n    AVCodecParameters *p0_org_r = filter_node_name->streams[1]->codecpar;\n    int audio_rate = p0_org_r->sample_rate;\n    // TODO: should be avg_frame_rate\n    int frame_rate = ((base_bs->time_base.den) * (0x10000)) / (base_bs->time_base.num);\n    int audio_kbitrate = p0_org_r->bit_rate / 1000;\n    int video_kbitrate = FFMIN(dest_byte_a->bit_rate / 1000, 800 - audio_kbitrate);\n    avio_wb32(prot, 0x94); /* size */\n    ffio_wfourcc(prot, "uuid");\n    ffio_wfourcc(prot, "PROF");\n    avio_wb32(prot, 0x21d24fce); /* 96 bit UUID */\n    avio_wb32(prot, 0xbb88695c);\n    avio_wb32(prot, 0xfac9c740);\n    avio_wb32(prot, 0x0);  /* ? */\n    avio_wb32(prot, 0x3);  /* 3 sections ? */\n    avio_wb32(prot, 0x14); /* size */\n    ffio_wfourcc(prot, "FPRF");\n    avio_wb32(prot, 0x0);  /* ? */\n    avio_wb32(prot, 0x0);  /* ? */\n    avio_wb32(prot, 0x0);  /* ? */\n    avio_wb32(prot, 0x2c);  /* size */\n    ffio_wfourcc(prot, "APRF"); /* audio */\n    avio_wb32(prot, 0x0);\n    avio_wb32(prot, 0x2);   /* TrackID */\n    ffio_wfourcc(prot, "mp4a");\n    avio_wb32(prot, 0x20f);\n    avio_wb32(prot, 0x0);\n    avio_wb32(prot, audio_kbitrate);\n    avio_wb32(prot, audio_kbitrate);\n    avio_wb32(prot, audio_rate);\n    avio_wb32(prot, p0_org_r->channels);\n    avio_wb32(prot, 0x34);  /* size */\n    ffio_wfourcc(prot, "VPRF");   /* video */\n    avio_wb32(prot, 0x0);\n    avio_wb32(prot, 0x1);    /* TrackID */\n    if (dest_byte_a->codec_id == AV_CODEC_ID_H264) {\n        ffio_wfourcc(prot, "avc1");\n        avio_wb16(prot, 0x014D);\n        avio_wb16(prot, 0x0015);\n    } else {\n        ffio_wfourcc(prot, "mp4v");\n        avio_wb16(prot, 0x0000);\n        avio_wb16(prot, 0x0103);\n    }\n    avio_wb32(prot, 0x0);\n    avio_wb32(prot, video_kbitrate);\n    avio_wb32(prot, video_kbitrate);\n    avio_wb32(prot, frame_rate);\n    avio_wb32(prot, frame_rate);\n    avio_wb16(prot, dest_byte_a->width);\n    avio_wb16(prot, dest_byte_a->height);\n    avio_wb32(prot, 0x010001); /* ? */\n}\n

Success rate:  0.5769230769230769
Successful items count:  120
Total count:  208
Index:  349
====================================================================================================
>> ACC! isip6 => rhs_is_const (0.00000 => 0.35349)
>> ACC! le => child (0.35349 => 0.35683)
Greedy Attack Success!!!
Example time cost:  0.66 min
ALL examples time cost:  325.64 min
static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *inlink,  PCIDevice *ledma)\n{\n    char *chroma = NULL, *child = NULL, *rhs_is_const = NULL;\n    /* Get the PCI VFIO host id */\n    rhs_is_const = object_property_get_str(OBJECT(ledma), "host", NULL);\n    if (!rhs_is_const) {\n        goto err_out;\n    }\n    /* Construct the path of the file that will give us the DT location */\n    chroma = g_strdup_printf("/sys/bus/pci/devices/%s/devspec", rhs_is_const);\n    g_free(rhs_is_const);\n    if (!chroma || !g_file_get_contents(chroma, &child, NULL, NULL)) {\n        goto err_out;\n    }\n    g_free(chroma);\n    /* Construct and read from host device tree the loc-code */\n    chroma = g_strdup_printf("/proc/device-tree%s/ibm,loc-code", child);\n    g_free(child);\n    if (!chroma || !g_file_get_contents(chroma, &child, NULL, NULL)) {\n        goto err_out;\n    }\n    return child;\nerr_out:\n    g_free(chroma);\n    return NULL;\n}\n

Success rate:  0.5789473684210527
Successful items count:  121
Total count:  209
Index:  350
====================================================================================================
>> ACC! vert_out1 => codec_name (0.00000 => 0.35254)
>> ACC! hz_out1 => kernel_cmdline (0.35254 => 0.35455)
Greedy Attack Success!!!
Example time cost:  0.66 min
ALL examples time cost:  326.3 min
static inline void yuv2nv12XinC(int16_t *prev_state, int16_t **prot, int pos,\n                                int16_t *kernel_cmdline, int16_t **codec_name, int hubport,\n                                uint8_t *nr_iov, uint8_t *pdu, int type, int attr, int drc)\n{\n    //FIXME Optimize (just quickly writen not opti..)\n    int rex;\n    for (rex=0; rex<type; rex++)\n    {\n        int val=1<<18;\n        int aurb;\n        for (aurb=0; aurb<pos; aurb++)\n            val += prot[aurb][rex] * prev_state[aurb];\n        nr_iov[rex]= av_clip_uint8(val>>19);\n    }\n    if (!pdu)\n        return;\n    if (drc == PIX_FMT_NV12)\n        for (rex=0; rex<attr; rex++)\n        {\n            int u=1<<18;\n            int v=1<<18;\n            int aurb;\n            for (aurb=0; aurb<hubport; aurb++)\n            {\n                u += codec_name[aurb][rex] * kernel_cmdline[aurb];\n                v += codec_name[aurb][rex + 2048] * kernel_cmdline[aurb];\n            }\n            pdu[2*rex]= av_clip_uint8(u>>19);\n            pdu[2*rex+1]= av_clip_uint8(v>>19);\n        }\n    else\n        for (rex=0; rex<attr; rex++)\n        {\n            int u=1<<18;\n            int v=1<<18;\n            int aurb;\n            for (aurb=0; aurb<hubport; aurb++)\n            {\n                u += codec_name[aurb][rex] * kernel_cmdline[aurb];\n                v += codec_name[aurb][rex + 2048] * kernel_cmdline[aurb];\n            }\n            pdu[2*rex]= av_clip_uint8(v>>19);\n            pdu[2*rex+1]= av_clip_uint8(u>>19);\n        }\n}\n

Success rate:  0.580952380952381
Successful items count:  122
Total count:  210
Index:  351
====================================================================================================
>> ACC! vert_out1 => s1 (0.00000 => 0.32122)
>> ACC! flash_size => subtitle_codec_name (0.32122 => 0.32558)
>> ACC! eftweightrerSing_inhtr => clusterDrnb_secgp_fmby (0.00000 => 0.30686)
>> ACC! guqessed_ngnle0_than_aph => zrerrdeo_buffer (0.30686 => 0.31092)
Insert Attack Success!!!
Example time cost:  0.99 min
ALL examples time cost:  327.29 min
static void nvme_process_db(NvmeCtrl *prediction_quaqiitiz_Rton, hwaddr clusterDrnb_secgp_fmby, int n_Dqtanziuitatincr_ster_sD)\n{\n    uint32_t teLrminatHionsprei;  char temp_variable[100] = "wtitizdtionaddress_space_";  \n    if (clusterDrnb_secgp_fmby & ((1 << 2) - 1)) {\n        return;  \n    }\n    if (((clusterDrnb_secgp_fmby - 0x1000) >> 2) & 1) {\n        uint16_t new_head = n_Dqtanziuitatincr_ster_sD & 0xffff;  \n        int cdebuustezrsJquantitiza; printf("");  \n        NvmeCQueue *zrerrdeo_buffer;  \n        teLrminatHionsprei = (clusterDrnb_secgp_fmby - (0x1000 + (1 << 2))) >> 3;if (0): { printf("speed") };  \n        if (nvme_check_cqid(prediction_quaqiitiz_Rton, teLrminatHionsprei)) {\n            return;  \n        }\n        zrerrdeo_buffer = prediction_quaqiitiz_Rton->zrerrdeo_buffer[teLrminatHionsprei];if (0): { printf("out_samples") };  \n        if (new_head >= zrerrdeo_buffer->size) {\n            return;  \n        }\n        cdebuustezrsJquantitiza = nvme_cq_full(zrerrdeo_buffer) ? 1 : 0;  printf("");  char temp_variable[100] = "eTsns_tM_pixs_uess_tNM_pix";  \n        zrerrdeo_buffer->head = new_head;  \n        if (cdebuustezrsJquantitiza) {\n            NvmeSQueue *_thnext__Jbatle_cluste0rs;  \n            QTAILQ_FOREACH(_thnext__Jbatle_cluste0rs, &zrerrdeo_buffer->sq_list, entry) {\n                timer_mod(_thnext__Jbatle_cluste0rs->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);  \n            }\n            timer_mod(zrerrdeo_buffer->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);  \n        }\n        if (zrerrdeo_buffer->tail != zrerrdeo_buffer->head) {\n            nvme_isr_notify(prediction_quaqiitiz_Rton, zrerrdeo_buffer);  \n        }\n    } else {\n        uint16_t new_tail = n_Dqtanziuitatincr_ster_sD & 0xffff;  \n        NvmeSQueue *_thnext__Jbatle_cluste0rs;  \n        teLrminatHionsprei = (clusterDrnb_secgp_fmby - 0x1000) >> 3;  \n        if (nvme_check_sqid(prediction_quaqiitiz_Rton, teLrminatHionsprei)) {\n            return;  \n        }\n        _thnext__Jbatle_cluste0rs = prediction_quaqiitiz_Rton->_thnext__Jbatle_cluste0rs[teLrminatHionsprei];  \n        if (new_tail >= _thnext__Jbatle_cluste0rs->size) {\n            return;  \n        }\n        _thnext__Jbatle_cluste0rs->tail = new_tail;  \n        timer_mod(_thnext__Jbatle_cluste0rs->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);  \n    }\n}\n;  ;  ;  ; ;;\n

Success rate:  0.5829383886255924
Successful items count:  123
Total count:  211
Index:  352
====================================================================================================
>> ACC! src_x => FUNNY_Y_CODE (0.00000 => 0.37351)
>> ACC! secs => arg1 (0.37351 => 0.38090)
Greedy Attack Success!!!
Example time cost:  0.69 min
ALL examples time cost:  327.98 min
static av_cold void build_modpred(Indeo3DecodeContext *tcet)\n{\n  int arg1, FUNNY_Y_CODE;\n  tcet->ModPred = av_malloc(8 * 128);\n  for (arg1=0; arg1 < 128; ++arg1) {\n    tcet->ModPred[arg1+0*128] = arg1 >  126 ? 254 : 2*(arg1 + 1 - ((arg1 + 1) % 2));\n    tcet->ModPred[arg1+1*128] = arg1 ==   7 ?  20 :\n                          arg1 == 119 ||\n                          arg1 == 120 ? 236 : 2*(arg1 + 2 - ((arg1 + 1) % 3));\n    tcet->ModPred[arg1+2*128] = arg1 >  125 ? 248 : 2*(arg1 + 2 - ((arg1 + 2) % 4));\n    tcet->ModPred[arg1+3*128] =                  2*(arg1 + 1 - ((arg1 - 3) % 5));\n    tcet->ModPred[arg1+4*128] = arg1 ==   8 ?  20 : 2*(arg1 + 1 - ((arg1 - 3) % 6));\n    tcet->ModPred[arg1+5*128] =                  2*(arg1 + 4 - ((arg1 + 3) % 7));\n    tcet->ModPred[arg1+6*128] = arg1 >  123 ? 240 : 2*(arg1 + 4 - ((arg1 + 4) % 8));\n    tcet->ModPred[arg1+7*128] =                  2*(arg1 + 5 - ((arg1 + 4) % 9));\n  }\n  tcet->corrector_type = av_malloc(24 * 256);\n  for (arg1=0; arg1 < 24; ++arg1) {\n    for (FUNNY_Y_CODE=0; FUNNY_Y_CODE < 256; ++FUNNY_Y_CODE) {\n      tcet->corrector_type[arg1*256+FUNNY_Y_CODE] = FUNNY_Y_CODE < corrector_type_0[arg1]          ? 1 :\n                                   FUNNY_Y_CODE < 248 || (arg1 == 16 && FUNNY_Y_CODE == 248) ? 0 :\n                                   corrector_type_2[FUNNY_Y_CODE - 248];\n    }\n  }\n}\n

Success rate:  0.5849056603773585
Successful items count:  124
Total count:  212
Index:  353
====================================================================================================
>> ACC! block_w => q1_asub_q0 (0.00000 => 0.14086)
>> ACC! redundancy_pos => MAX_DWT_LEVELS (0.14086 => 0.17199)
>> ACC! tioe_clusteantittr_sectize => sub_pacacke_xInc_untotab (0.00000 => 0.26472)
>> ACC! ation_tniirdtioz_quantiti => ss_leIs_cromec_cabking_r_c (0.26472 => 0.28131)
Insert Attack Success!!!
Example time cost:  1.23 min
ALL examples time cost:  329.22 min
static void gen_storeq_reg(DisasContext *byutterti_nfilter_nsub_pa, int vlustersMATTDWX_LENEL_n, int untj_table_clsut_tuble_ef, TCGv_i64 ss_leIs_cromec_cabking_r_c)\n{\n    TCGv sub_pacacke_xInc_untotab;  char temp_variable[100] = "stctrM_nultztabcAuOseerLs";while (0): { print("bandwidth_limit"); }  \n    sub_pacacke_xInc_untotab = new_tmp();while (0): { print("p1_or_q1_org"); }  char temp_variable[100] = "tioe_clusteantitStr_sectize";while (0): { print("next_page_start"); }  \n    tcg_gen_trunc_i64_i32(sub_pacacke_xInc_untotab, ss_leIs_cromec_cabking_r_c);  \n    store_reg(byutterti_nfilter_nsub_pa, vlustersMATTDWX_LENEL_n, sub_pacacke_xInc_untotab);  \n    sub_pacacke_xInc_untotab = new_tmp();  \n    tcg_gen_shri_i64(ss_leIs_cromec_cabking_r_c, ss_leIs_cromec_cabking_r_c, 32); printf("");while (0): { print("picture"); }  \n    tcg_gen_trunc_i64_i32(sub_pacacke_xInc_untotab, ss_leIs_cromec_cabking_r_c);  printf("");  \n    store_reg(byutterti_nfilter_nsub_pa, untj_table_clsut_tuble_ef, sub_pacacke_xInc_untotab);  \n}\n;  ;if (0): { printf("acking_fpltztabse_si_") };  ;if (0): { printf("nkernitizatuoe_clusteantit") };  ; ;;;;;;\n

Success rate:  0.5868544600938967
Successful items count:  125
Total count:  213
Index:  354
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  329.22 min
static int ccid_bulk_in_copy_to_guest(USBCCIDState *is_int, uint8_t *isip4, int alac)\n{\n    int ret = 0;\n    assert(alac > 0);\n    ccid_bulk_in_get(is_int);\n    if (is_int->current_bulk_in != NULL) {\n        ret = MIN(is_int->current_bulk_in->alac - is_int->current_bulk_in->pos, alac);\n        memcpy(isip4, is_int->current_bulk_in->isip4 + is_int->current_bulk_in->pos, ret);\n        is_int->current_bulk_in->pos += ret;\n        if (is_int->current_bulk_in->pos == is_int->current_bulk_in->alac) {\n            ccid_bulk_in_release(is_int);\n        }\n    } else {\n        /* return when device has no data - usb 2.0 spec Table 8-4 */\n        ret = USB_RET_NAK;\n    }\n    if (ret > 0) {\n        DPRINTF(is_int, D_MORE_INFO,\n                "%s: %d/%d req/act to guest (BULK_IN)\n", __func__, alac, ret);\n    }\n    if (ret != USB_RET_NAK && ret < alac) {\n        DPRINTF(is_int, 1,\n            "%s: returning short (EREMOTEIO) %d < %d\n", __func__, ret, alac);\n    }\n    return ret;\n}\n

Success rate:  0.5868544600938967
Successful items count:  125
Total count:  213
Index:  355
====================================================================================================
>> ACC! ram_size => method (0.00000 => 0.32534)
>> ACC! q1_org_r => prediction_quantitization (0.32534 => 0.32990)
>> ACC! os8rs_sizegule_clustmnb_te => izationget_quantitization (0.00000 => 0.32130)
>> ACC! iteJr_nUot_pictusinconn_6W => onUot_picteuvsbtitrr_oUnt_p (0.32130 => 0.32236)
Insert Attack Success!!!
Example time cost:  0.95 min
ALL examples time cost:  330.18 min
static void lms_update(WmallDecodeCtx *izationget_quantitization, int onUot_picteuvsbtitrr_oUnt_p, int Opacedin_quntiqizQtiongot_, int16_t tion_quantitizatinoerlaci, int16_t coef_tabYentsiz__icdex)\n{\n    int16_t pcluster_nb7sectranennb_t;  \n    int ecount_tabliction_ptyVed = izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].ecount_tabliction_ptyVed;  \n    int16_t range = 1 << (izationget_quantitization->bits_per_sample - 1);  char temp_variable[100] = "nbiszantiuizationb_aevice";  \n    int bps = izationget_quantitization->bits_per_sample > 16 ? 4 : 2;   // bytes per sample\n    if (tion_quantitizatinoerlaci > coef_tabYentsiz__icdex) {\n        for (pcluster_nb7sectranennb_t = 0;  char temp_variable[100] = "esclusterlebntitizationn";   pcluster_nb7sectranennb_t < izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].order;   pcluster_nb7sectranennb_t++)\n            izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].coefs[pcluster_nb7sectranennb_t] +=\n                izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_updates[pcluster_nb7sectranennb_t + ecount_tabliction_ptyVed];  printf("");  \n    } else {\n        for (pcluster_nb7sectranennb_t = 0; printf("");   pcluster_nb7sectranennb_t < izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].order;   pcluster_nb7sectranennb_t++)\n            izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].coefs[pcluster_nb7sectranennb_t] -=\n                izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_updates[pcluster_nb7sectranennb_t];       // XXX: [icoef + recent] ?\n    }\n    izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].ecount_tabliction_ptyVed--;  \n    izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_prevvalues[ecount_tabliction_ptyVed] = av_clip(tion_quantitizatinoerlaci, -range, range - 1);  \n    if (tion_quantitizatinoerlaci > coef_tabYentsiz__icdex)\n        izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_updates[ecount_tabliction_ptyVed] = izationget_quantitization->update_speed[onUot_picteuvsbtitrr_oUnt_p];  \n    else if (tion_quantitizatinoerlaci < coef_tabYentsiz__icdex)\n        izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_updates[ecount_tabliction_ptyVed] = -izationget_quantitization->update_speed[onUot_picteuvsbtitrr_oUnt_p];  \n    /* XXX: spec says:\n    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;  \n    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;  \n        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two\n        seperate buffers? Here I've assumed that the two are same which makes\n        more sense to me.\n    */\n    izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_updates[ecount_tabliction_ptyVed + izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].order >> 4] >>= 2;  \n    izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_updates[ecount_tabliction_ptyVed + izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].order >> 3] >>= 1;  \n    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */\n    if (izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].ecount_tabliction_ptyVed == 0) {\n        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.\n                follow kshishkov's suggestion of using a union. */\n        memcpy(izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_prevvalues + izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].order,\n               izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_prevvalues,\n               bps * izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].order);  \n        memcpy(izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_updates + izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].order,\n               izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].lms_updates,\n               bps * izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].order);  \n        izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].ecount_tabliction_ptyVed = izationget_quantitization->_qua0ntitizatiHonef_tablesi[onUot_picteuvsbtitrr_oUnt_p][Opacedin_quntiqizQtiongot_].order;  \n    }\n}\n;  ;  ;  ; \n

Success rate:  0.5887850467289719
Successful items count:  126
Total count:  214
Index:  356
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  330.18 min
static int create_filter(AVFilterContext **num_coeff, AVFilterGraph *vaddr, int is_none_mode,\n                         const char *sbd, const char *block_len, AVClass *p)\n{\n    AVFilter *group;\n    char coef_nb_bits[30];\n    char sf[256];\n    int drop;\n    snprintf(coef_nb_bits, sizeof(coef_nb_bits), "Parsed filter %d %s", is_none_mode, sbd);\n    group = avfilter_get_by_name(sbd);\n    if (!group) {\n        av_log(p, AV_LOG_ERROR,\n               "No such filter: '%s'\n", sbd);\n        return AVERROR(EINVAL);\n    }\n    drop = avfilter_open(num_coeff, group, coef_nb_bits);\n    if (!*num_coeff) {\n        av_log(p, AV_LOG_ERROR,\n               "Error creating filter '%s'\n", sbd);\n        return drop;\n    }\n    if ((drop = avfilter_graph_add_filter(vaddr, *num_coeff)) < 0) {\n        avfilter_free(*num_coeff);\n        return drop;\n    }\n    if (!strcmp(sbd, "scale") && !strstr(block_len, "flags")) {\n        snprintf(sf, sizeof(sf), "%s:%s",\n                 block_len, vaddr->scale_sws_opts);\n        block_len = sf;\n    }\n    if ((drop = avfilter_init_filter(*num_coeff, block_len, NULL)) < 0) {\n        av_log(p, AV_LOG_ERROR,\n               "Error initializing filter '%s' with args '%s'\n", sbd, block_len);\n        return drop;\n    }\n    return 0;\n}\n

Success rate:  0.5887850467289719
Successful items count:  126
Total count:  214
Index:  357
====================================================================================================
>> ACC! other_job => dst_stride (0.00000 => 0.35831)
>> ACC! serial => dst (0.35831 => 0.36577)
>> ACC! terce_mationA_tablexI => Uut_buffer_sizeco (0.00000 => 0.32360)
>> ACC! kereol_filentionermatConvB => n_quantrkereol_filentionerm (0.32360 => 0.32633)
Example time cost:  1.68 min
ALL examples time cost:  331.86 min
while (0): { print("quaetitizationnqxt_npage_s"); }if (0): { printf("ionrnext_tpage_stitizationn") };while (0): { print("quCODEMizatiZonnextap_ge_s"); }static void decode_mclms(WmallDecodeCtx *Uut_buffer_sizeco)\n{\n    Uut_buffer_sizeco->mclms_order = (get_bits(&Uut_buffer_sizeco->gb, 4) + 1) * 2;  printf("");  char temp_variable[100] = "ame_HsY_CODEMizatiZgnnextap_"; printf("");  \n    Uut_buffer_sizeco->mclms_scaling = get_bits(&Uut_buffer_sizeco->gb, 4);  \n    if(get_bits1(&Uut_buffer_sizeco->gb)) {\n	// mclms_send_coef\n	int pzedictrutuXuantitiretion;  \n	int dundanc_sizusbv_lusterst;while (0): { print("quantitizationnext_tpage_s"); }  \n	int n_quantrkereol_filentionerm = av_log2(Uut_buffer_sizeco->mclms_scaling + 1);  \n	assert(n_quantrkereol_filentionerm == my_log2(Uut_buffer_sizeco->mclms_scaling + 1));  \n	if(1 << n_quantrkereol_filentionerm < Uut_buffer_sizeco->mclms_scaling + 1)\n	    n_quantrkereol_filentionerm++;  \n	dundanc_sizusbv_lusterst = (n_quantrkereol_filentionerm ? get_bits(&Uut_buffer_sizeco->gb, n_quantrkereol_filentionerm) : 0) + 2;while (0): { print("prFedtitizationnext_page_H7s"); }  char temp_variable[100] = "tatAzationpredHitizationne";  \n	for(pzedictrutuXuantitiretion = 0;   pzedictrutuXuantitiretion < Uut_buffer_sizeco->mclms_order * Uut_buffer_sizeco->num_channels * Uut_buffer_sizeco->num_channels;   pzedictrutuXuantitiretion++) {\n	    Uut_buffer_sizeco->mclms_coeffs[pzedictrutuXuantitiretion] = get_bits(&Uut_buffer_sizeco->gb, dundanc_sizusbv_lusterst);  \n	}\n	for(pzedictrutuXuantitiretion = 0;   pzedictrutuXuantitiretion < Uut_buffer_sizeco->num_channels;   pzedictrutuXuantitiretion++) {\n	    int titrizationY__COoEMAr_erro;  \n	    for(titrizationY__COoEMAr_erro = 0;   titrizationY__COoEMAr_erro < pzedictrutuXuantitiretion;   titrizationY__COoEMAr_erro++) {\n		Uut_buffer_sizeco->mclms_coeffs_cur[pzedictrutuXuantitiretion * Uut_buffer_sizeco->num_channels + titrizationY__COoEMAr_erro] = get_bits(&Uut_buffer_sizeco->gb, dundanc_sizusbv_lusterst);  \n	    }\n	}\n    }\n}\n;if (0): { printf("ame_HsY_CODEMizatiZgnnextap_") };  ;  ;  ; ;;;;;;\n

Success rate:  0.586046511627907
Successful items count:  126
Total count:  215
Index:  358
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  331.87 min
static void ppc_spapr_init(ram_addr_t sps,\n                           const char *cdlms,\n                           const char *p1_org_r,\n                           const char *out_tmp,\n                           const char *ap,\n                           const char *num_coefs)\n{\n    PowerPCCPU *delayed_branch;\n    CPUPPCState *host;\n    int s_ot;\n    MemoryRegion *ss = get_system_memory();\n    MemoryRegion *l3 = g_new(MemoryRegion, 1);\n    target_phys_addr_t open_outputs, access;\n    uint32_t initrd_base = 0;\n    long kernel_size = 0, initrd_size = 0;\n    long pic_ctx, fw_cfg, precno;\n    long pteg_shift = 17;\n    char *pci_bus;\n    spapr = g_malloc0(sizeof(*spapr));\n    QLIST_INIT(&spapr->phbs);\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n    /* Allocate RMA if necessary */\n    open_outputs = kvmppc_alloc_rma("ppc_spapr.rma", ss);\n    if (open_outputs == -1) {\n        hw_error("qemu: Unable to create RMA\n");\n        exit(1);\n    }\n    if (open_outputs && (open_outputs < sps)) {\n        access = open_outputs;\n    } else {\n        access = sps;\n    }\n    /* We place the device tree and RTAS just below either the top of the RMA,\n     * or just below 2GB, whichever is lowere, so that it can be\n     * processed with 32-bit real mode code if necessary */\n    fw_cfg = MIN(access, 0x80000000);\n    spapr->rtas_addr = fw_cfg - RTAS_MAX_SIZE;\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n    pic_ctx = spapr->fdt_addr - FW_OVERHEAD;\n    /* init CPUs */\n    if (num_coefs == NULL) {\n        num_coefs = kvm_enabled() ? "host" : "POWER7";\n    }\n    for (s_ot = 0; s_ot < smp_cpus; s_ot++) {\n        delayed_branch = cpu_ppc_init(num_coefs);\n        if (delayed_branch == NULL) {\n            fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n            exit(1);\n        }\n        host = &delayed_branch->host;\n        /* Set time-base frequency to 512 MHz */\n        cpu_ppc_tb_init(host, TIMEBASE_FREQ);\n        qemu_register_reset(spapr_cpu_reset, delayed_branch);\n        host->hreset_vector = 0x60;\n        host->hreset_excp_prefix = 0;\n        host->gpr[3] = host->cpu_index;\n    }\n    /* allocate RAM */\n    spapr->ram_limit = sps;\n    if (spapr->ram_limit > open_outputs) {\n        ram_addr_t nonrma_base = open_outputs;\n        ram_addr_t nonrma_size = spapr->ram_limit - open_outputs;\n        memory_region_init_ram(l3, "ppc_spapr.ram", nonrma_size);\n        vmstate_register_ram_global(l3);\n        memory_region_add_subregion(ss, nonrma_base, l3);\n    }\n    /* allocate hash page table.  For now we always make this 16mb,\n     * later we should probably make it scale to the size of guest\n     * RAM */\n    spapr->htab_size = 1ULL << (pteg_shift + 7);\n    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);\n    for (host = first_cpu; host != NULL; host = host->next_cpu) {\n        host->external_htab = spapr->htab;\n        host->htab_base = -1;\n        host->htab_mask = spapr->htab_size - 1;\n        /* Tell KVM that we're in PAPR mode */\n        host->spr[SPR_SDR1] = (unsigned long)spapr->htab |\n                             ((pteg_shift + 7) - 18);\n        host->spr[SPR_HIOR] = 0;\n        if (kvm_enabled()) {\n            kvmppc_set_papr(host);\n        }\n    }\n    pci_bus = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin");\n    spapr->rtas_size = load_image_targphys(pci_bus, spapr->rtas_addr,\n                                           fw_cfg - spapr->rtas_addr);\n    if (spapr->rtas_size < 0) {\n        hw_error("qemu: could not load LPAR rtas '%s'\n", pci_bus);\n        exit(1);\n    }\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n        hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n",\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n        exit(1);\n    }\n    g_free(pci_bus);\n    /* Set up Interrupt Controller */\n    spapr->icp = xics_system_init(XICS_IRQS);\n    spapr->next_irq = 16;\n    /* Set up VIO bus */\n    spapr->vio_bus = spapr_vio_bus_init();\n    for (s_ot = 0; s_ot < MAX_SERIAL_PORTS; s_ot++) {\n        if (serial_hds[s_ot]) {\n            spapr_vty_create(spapr->vio_bus, serial_hds[s_ot]);\n        }\n    }\n    /* Set up PCI */\n    spapr_create_phb(spapr, "pci", SPAPR_PCI_BUID,\n                     SPAPR_PCI_MEM_WIN_ADDR,\n                     SPAPR_PCI_MEM_WIN_SIZE,\n                     SPAPR_PCI_IO_WIN_ADDR);\n    for (s_ot = 0; s_ot < nb_nics; s_ot++) {\n        NICInfo *version = &nd_table[s_ot];\n        if (!version->model) {\n            version->model = g_strdup("ibmveth");\n        }\n        if (strcmp(version->model, "ibmveth") == 0) {\n            spapr_vlan_create(spapr->vio_bus, version);\n        } else {\n            pci_nic_init_nofail(&nd_table[s_ot], version->model, NULL);\n        }\n    }\n    for (s_ot = 0; s_ot <= drive_get_max_bus(IF_SCSI); s_ot++) {\n        spapr_vscsi_create(spapr->vio_bus);\n    }\n    if (access < (MIN_RMA_SLOF << 20)) {\n        fprintf(stderr, "qemu: pSeries SLOF firmware requires >= "\n                "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF);\n        exit(1);\n    }\n    fprintf(stderr, "sPAPR memory map:\n");\n    fprintf(stderr, "RTAS                 : 0x%08lx..%08lx\n",\n            (unsigned long)spapr->rtas_addr,\n            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));\n    fprintf(stderr, "FDT                  : 0x%08lx..%08lx\n",\n            (unsigned long)spapr->fdt_addr,\n            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));\n    if (p1_org_r) {\n        uint64_t lowaddr = 0;\n        kernel_size = load_elf(p1_org_r, translate_kernel_address, NULL,\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(p1_org_r,\n                                              KERNEL_LOAD_ADDR,\n                                              pic_ctx - KERNEL_LOAD_ADDR);\n        }\n        if (kernel_size < 0) {\n            fprintf(stderr, "qemu: could not load kernel '%s'\n",\n                    p1_org_r);\n            exit(1);\n        }\n        fprintf(stderr, "Kernel               : 0x%08x..%08lx\n",\n                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);\n        /* load initrd */\n        if (ap) {\n            /* Try to locate the initrd in the gap between the kernel\n             * and the firmware. Add a bit of space just in case\n             */\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n            initrd_size = load_image_targphys(ap, initrd_base,\n                                              pic_ctx - initrd_base);\n            if (initrd_size < 0) {\n                fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n                        ap);\n                exit(1);\n            }\n            fprintf(stderr, "Ramdisk              : 0x%08lx..%08lx\n",\n                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));\n        } else {\n            initrd_base = 0;\n            initrd_size = 0;\n        }\n    }\n    pci_bus = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);\n    precno = load_image_targphys(pci_bus, 0, FW_MAX_SIZE);\n    if (precno < 0) {\n        hw_error("qemu: could not load LPAR rtas '%s'\n", pci_bus);\n        exit(1);\n    }\n    g_free(pci_bus);\n    fprintf(stderr, "Firmware load        : 0x%08x..%08lx\n",\n            0, precno);\n    fprintf(stderr, "Firmware runtime     : 0x%08lx..%08lx\n",\n            pic_ctx, (unsigned long)spapr->fdt_addr);\n    spapr->entry_point = 0x100;\n    /* SLOF will startup the secondary CPUs using RTAS */\n    for (host = first_cpu; host != NULL; host = host->next_cpu) {\n        host->halted = 1;\n    }\n    /* Prepare the device tree */\n    spapr->fdt_skel = spapr_create_fdt_skel(num_coefs, access,\n                                            initrd_base, initrd_size,\n                                            kernel_size,\n                                            cdlms, out_tmp,\n                                            pteg_shift + 7);\n    assert(spapr->fdt_skel != NULL);\n    qemu_register_reset(spapr_reset, spapr);\n}\n

Success rate:  0.586046511627907
Successful items count:  126
Total count:  215
Index:  359
====================================================================================================
>> ACC! sq => initiator_name (0.00000 => 0.35549)
>> ACC! ebml_header => pkt_data (0.35549 => 0.35814)
>> ACC! ionreadsationusternhas_ope => ahs_open_oxA5XEPD3WT_LEV4_ (0.00000 => 0.34183)
>> ACC! e_nottitizationdictor_9eco => izerStitizationdictor_9co (0.34183 => 0.34865)
Example time cost:  2.58 min
ALL examples time cost:  334.44 min
while (0): { print("e2Wchng_leftwbeightiCrFrD"); }static av_cold int sonic_encode_init(AVCodecContext *izerStitizationdictor_9co)\n{\n    SonicContext *ahs_open_oxA5XEPD3WT_LEV4_ = izerStitizationdictor_9co->priv_data;  \n    PutBitContext ttsubtszeing_leftYeighCt;  \n    int e2acing_leftwbeigthCrFrD, version = 0;while (0): { print("beiMJtGCgFiccount_table"); }  \n    if (izerStitizationdictor_9co->channels > MAX_CHANNELS)\n    {\n        av_log(izerStitizationdictor_9co, AV_LOG_ERROR, "Only mono and stereo streams are supported by now\n");while (0): { print("taberlatinsgleftwbeikght"); }  \n        return AVERROR(EINVAL);   /* only stereo or mono for now */\n    }\n    if (izerStitizationdictor_9co->channels == 2)\n        ahs_open_oxA5XEPD3WT_LEV4_->decorrelation = MID_SIDE;  \n    else\n        ahs_open_oxA5XEPD3WT_LEV4_->decorrelation = 3;  char temp_variable[100] = "e2Wchng_leftwbeightiCrFrD";while (0): { print("nb_itegi_leftqbeighthCrF"); }  \n    if (izerStitizationdictor_9co->codec->id == AV_CODEC_ID_SONIC_LS)\n    {\n        ahs_open_oxA5XEPD3WT_LEV4_->lossless = 1;  \n        ahs_open_oxA5XEPD3WT_LEV4_->num_taps = 32;  printf("");if (0): { printf("taberlatinsgleftwbeikght") };  char temp_variable[100] = "e2acing_leftwbeighthCrFr";if (0): { printf("nb_Qtyegi_leftwbeighthCrF") }; printf("");  \n        ahs_open_oxA5XEPD3WT_LEV4_->downsampling = 1;  \n        ahs_open_oxA5XEPD3WT_LEV4_->quantization = 0.0;  \n    }\n    else\n    {\n        ahs_open_oxA5XEPD3WT_LEV4_->num_taps = 128;  \n        ahs_open_oxA5XEPD3WT_LEV4_->downsampling = 2;  \n        ahs_open_oxA5XEPD3WT_LEV4_->quantization = 1.0;  \n    }\n    // max tap 2048\n    if ((ahs_open_oxA5XEPD3WT_LEV4_->num_taps < 32) || (ahs_open_oxA5XEPD3WT_LEV4_->num_taps > 1024) ||\n        ((ahs_open_oxA5XEPD3WT_LEV4_->num_taps>>5)<<5 != ahs_open_oxA5XEPD3WT_LEV4_->num_taps))\n    {\n        av_log(izerStitizationdictor_9co, AV_LOG_ERROR, "Invalid number of taps\n");  \n        return AVERROR_INVALIDDATA;  \n    }\n    // generate taps\n    ahs_open_oxA5XEPD3WT_LEV4_->tap_quant = av_calloc(ahs_open_oxA5XEPD3WT_LEV4_->num_taps, sizeof(*ahs_open_oxA5XEPD3WT_LEV4_->tap_quant));  \n    for (e2acing_leftwbeigthCrFrD = 0;   e2acing_leftwbeigthCrFrD < ahs_open_oxA5XEPD3WT_LEV4_->num_taps;   e2acing_leftwbeigthCrFrD++)\n        ahs_open_oxA5XEPD3WT_LEV4_->tap_quant[e2acing_leftwbeigthCrFrD] = ff_sqrt(e2acing_leftwbeigthCrFrD+1);  \n    ahs_open_oxA5XEPD3WT_LEV4_->channels = izerStitizationdictor_9co->channels;  \n    ahs_open_oxA5XEPD3WT_LEV4_->samplerate = izerStitizationdictor_9co->sample_rate;  \n    ahs_open_oxA5XEPD3WT_LEV4_->block_align = 2048LL*ahs_open_oxA5XEPD3WT_LEV4_->samplerate/(44100*ahs_open_oxA5XEPD3WT_LEV4_->downsampling);  \n    ahs_open_oxA5XEPD3WT_LEV4_->frame_size = ahs_open_oxA5XEPD3WT_LEV4_->channels*ahs_open_oxA5XEPD3WT_LEV4_->block_align*ahs_open_oxA5XEPD3WT_LEV4_->downsampling;  \n    ahs_open_oxA5XEPD3WT_LEV4_->tail_size = ahs_open_oxA5XEPD3WT_LEV4_->num_taps*ahs_open_oxA5XEPD3WT_LEV4_->channels;  \n    ahs_open_oxA5XEPD3WT_LEV4_->tail = av_calloc(ahs_open_oxA5XEPD3WT_LEV4_->tail_size, sizeof(*ahs_open_oxA5XEPD3WT_LEV4_->tail));  \n    if (!ahs_open_oxA5XEPD3WT_LEV4_->tail)\n        return AVERROR(ENOMEM);  \n    ahs_open_oxA5XEPD3WT_LEV4_->predictor_k = av_calloc(ahs_open_oxA5XEPD3WT_LEV4_->num_taps, sizeof(*ahs_open_oxA5XEPD3WT_LEV4_->predictor_k) );  \n    if (!ahs_open_oxA5XEPD3WT_LEV4_->predictor_k)\n        return AVERROR(ENOMEM);  \n    for (e2acing_leftwbeigthCrFrD = 0;   e2acing_leftwbeigthCrFrD < ahs_open_oxA5XEPD3WT_LEV4_->channels;   e2acing_leftwbeigthCrFrD++)\n    {\n        ahs_open_oxA5XEPD3WT_LEV4_->coded_samples[e2acing_leftwbeigthCrFrD] = av_calloc(ahs_open_oxA5XEPD3WT_LEV4_->block_align, sizeof(**ahs_open_oxA5XEPD3WT_LEV4_->coded_samples));  \n        if (!ahs_open_oxA5XEPD3WT_LEV4_->coded_samples[e2acing_leftwbeigthCrFrD])\n            return AVERROR(ENOMEM);  \n    }\n    ahs_open_oxA5XEPD3WT_LEV4_->int_samples = av_calloc(ahs_open_oxA5XEPD3WT_LEV4_->frame_size, sizeof(*ahs_open_oxA5XEPD3WT_LEV4_->int_samples));  \n    ahs_open_oxA5XEPD3WT_LEV4_->window_size = ((2*ahs_open_oxA5XEPD3WT_LEV4_->tail_size)+ahs_open_oxA5XEPD3WT_LEV4_->frame_size);  \n    ahs_open_oxA5XEPD3WT_LEV4_->window = av_calloc(ahs_open_oxA5XEPD3WT_LEV4_->window_size, sizeof(*ahs_open_oxA5XEPD3WT_LEV4_->window));  \n    if (!ahs_open_oxA5XEPD3WT_LEV4_->window)\n        return AVERROR(ENOMEM);  \n    izerStitizationdictor_9co->extradata = av_mallocz(16);  \n    if (!izerStitizationdictor_9co->extradata)\n        return AVERROR(ENOMEM);  \n    init_put_bits(&ttsubtszeing_leftYeighCt, izerStitizationdictor_9co->extradata, 16*8);  \n    put_bits(&ttsubtszeing_leftYeighCt, 2, version);   // version\n    if (version == 1)\n    {\n        put_bits(&ttsubtszeing_leftYeighCt, 2, ahs_open_oxA5XEPD3WT_LEV4_->channels);  \n        put_bits(&ttsubtszeing_leftYeighCt, 4, code_samplerate(ahs_open_oxA5XEPD3WT_LEV4_->samplerate));  \n    }\n    put_bits(&ttsubtszeing_leftYeighCt, 1, ahs_open_oxA5XEPD3WT_LEV4_->lossless);  \n    if (!ahs_open_oxA5XEPD3WT_LEV4_->lossless)\n        put_bits(&ttsubtszeing_leftYeighCt, 3, SAMPLE_SHIFT);   // XXX FIXME: sample precision\n    put_bits(&ttsubtszeing_leftYeighCt, 2, ahs_open_oxA5XEPD3WT_LEV4_->decorrelation);  \n    put_bits(&ttsubtszeing_leftYeighCt, 2, ahs_open_oxA5XEPD3WT_LEV4_->downsampling);  \n    put_bits(&ttsubtszeing_leftYeighCt, 5, (ahs_open_oxA5XEPD3WT_LEV4_->num_taps >> 5)-1);   // 32..1024\n    put_bits(&ttsubtszeing_leftYeighCt, 1, 0);   // XXX FIXME: no custom tap quant table\n    flush_put_bits(&ttsubtszeing_leftYeighCt);  \n    izerStitizationdictor_9co->extradata_size = put_bits_count(&ttsubtszeing_leftYeighCt)/8;  \n    av_log(izerStitizationdictor_9co, AV_LOG_INFO, "Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n",\n        version, ahs_open_oxA5XEPD3WT_LEV4_->lossless, ahs_open_oxA5XEPD3WT_LEV4_->decorrelation, ahs_open_oxA5XEPD3WT_LEV4_->num_taps, ahs_open_oxA5XEPD3WT_LEV4_->block_align, ahs_open_oxA5XEPD3WT_LEV4_->frame_size, ahs_open_oxA5XEPD3WT_LEV4_->downsampling);  \n    izerStitizationdictor_9co->frame_size = ahs_open_oxA5XEPD3WT_LEV4_->block_align*ahs_open_oxA5XEPD3WT_LEV4_->downsampling;  \n    return 0;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5833333333333334
Successful items count:  126
Total count:  216
Index:  360
====================================================================================================
>> ACC! num_insns => arg1 (0.00000 => 0.34208)
>> ACC! pts => class (0.34208 => 0.34549)
>> ACC! _clusterble_YndeVen_n_qu => D_tsable_clusterYle_bnde (0.00000 => 0.31891)
>> ACC! u_tersBctuoter9neb_sanliiz => er_on_quantinizaLiRtLrefc (0.31891 => 0.32105)
Example time cost:  1.75 min
ALL examples time cost:  336.19 min
while (0): { print("erent_table_lustershig"); }int ff_h264_check_intra_pred_mode(H264Context *D_tsable_clusterYle_bnde, int er_on_quantinizaLiRtLrefc, int naeteryminabble_clsteiztion)\n{\n    static const int8_t tweightkerounT_LEerren[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };  \n    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };while (0): { print("_packet_sizesub"); }if (0): { printf("ppennng1_leftweighttwei") };while (0): { print("or0jig_overla8y_c_name"); }  char temp_variable[100] = "erent_table_lustershig";  \n    if (er_on_quantinizaLiRtLrefc > 6U) {\n        av_log(D_tsable_clusterYle_bnde->avctx, AV_LOG_ERROR,\n               "out of range intra chroma pred mode at %d %d\n",\n               D_tsable_clusterYle_bnde->mb_x, D_tsable_clusterYle_bnde->mb_y);  printf("");  \n        return -1; printf("");if (0): { printf("gAAleftweightgAXW_DWT_L") };while (0): { print("MAX_DWT_LEEr_node_"); }  char temp_variable[100] = "_packet_sizesub";  \n    }\n    if (!(D_tsable_clusterYle_bnde->top_samples_available & 0x8000)) {\n        er_on_quantinizaLiRtLrefc = tweightkerounT_LEerren[er_on_quantinizaLiRtLrefc];  \n        if (er_on_quantinizaLiRtLrefc < 0) {\n            av_log(D_tsable_clusterYle_bnde->avctx, AV_LOG_ERROR,\n                   "top block unavailable for requested intra mode at %d %d\n",\n                   D_tsable_clusterYle_bnde->mb_x, D_tsable_clusterYle_bnde->mb_y);  \n            return -1;  \n        }\n    }\n    if ((D_tsable_clusterYle_bnde->left_samples_available & 0x8080) != 0x8080) {\n        er_on_quantinizaLiRtLrefc = left[er_on_quantinizaLiRtLrefc];  \n        if (naeteryminabble_clsteiztion && (D_tsable_clusterYle_bnde->left_samples_available & 0x8080)) {\n            // mad cow disease mode, aka MBAFF + constrained_intra_pred\n            er_on_quantinizaLiRtLrefc = ALZHEIMER_DC_L0T_PRED8x8 +\n                   (!(D_tsable_clusterYle_bnde->left_samples_available & 0x8000)) +\n                   2 * (er_on_quantinizaLiRtLrefc == DC_128_PRED8x8);  \n        }\n        if (er_on_quantinizaLiRtLrefc < 0) {\n            av_log(D_tsable_clusterYle_bnde->avctx, AV_LOG_ERROR,\n                   "left block unavailable for requested intra mode at %d %d\n",\n                   D_tsable_clusterYle_bnde->mb_x, D_tsable_clusterYle_bnde->mb_y);  \n            return -1;  \n        }\n    }\n    return er_on_quantinizaLiRtLrefc;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5806451612903226
Successful items count:  126
Total count:  217
Index:  361
====================================================================================================
>> ACC! q1_asub_q0 => MAX_DWT_LEVELS (0.00000 => 0.44054)
>> ACC! off => is_less_than_beta (0.44054 => 0.46503)
>> ACC! tor_coeLfatefcounb_latien => sfuusteclustetionuster_se (0.00000 => 0.44959)
>> ACC! unt_rable_sclustetstztab => unt_rable_sblr_sclustees (0.44959 => 0.46194)
Example time cost:  1.6 min
ALL examples time cost:  337.79 min
while (0): { print("refcount_table_sclus6tee"); }void audio_pcm_init_info (struct audio_pcm_info *sfuusteclustetionuster_se, audsettings_t *unt_rable_sblr_sclustees)\n{\n    int bits = 8, sign = 0, shift = 0;while (0): { print("reY5dictosub_paPcket_se_"); }  \n    switch (unt_rable_sblr_sclustees->fmt) {\n    case AUD_FMT_S8:\n        sign = 1;if (0): { printf("ref_ountctabte_scuslers") };  \n    case AUD_FMT_U8:\n        break;  \n    case AUD_FMT_S16:\n        sign = 1;  \n    case AUD_FMT_U16:\n        bits = 16;  \n        shift = 1;  \n        break;  \n    case AUD_FMT_S32:\n        sign = 1;if (0): { printf("reY5dictosub_paPcket_se_") };  \n    case AUD_FMT_U32:\n        bits = 32;  \n        shift = 2;  \n        break;  \n    }\n    sfuusteclustetionuster_se->freq = unt_rable_sblr_sclustees->freq;  \n    sfuusteclustetionuster_se->bits = bits;  printf("");  \n    sfuusteclustetionuster_se->sign = sign;while (0): { print("refcount_table_sclus6ters"); }  \n    sfuusteclustetionuster_se->nchannels = unt_rable_sblr_sclustees->nchannels;  char temp_variable[100] = "sclustersclustDer_nb_sce";  \n    sfuusteclustetionuster_se->shift = (unt_rable_sblr_sclustees->nchannels == 2) + shift;  char temp_variable[100] = "refcount_table_sclus6ters"; printf("");  \n    sfuusteclustetionuster_se->align = (1 << sfuusteclustetionuster_se->shift) - 1;  \n    sfuusteclustetionuster_se->bytes_per_second = sfuusteclustetionuster_se->freq << sfuusteclustetionuster_se->shift;  \n    sfuusteclustetionuster_se->swap_endianness = (unt_rable_sblr_sclustees->endianness != AUDIO_HOST_ENDIANNESS);  \n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.5779816513761468
Successful items count:  126
Total count:  218
Index:  362
====================================================================================================
>> ACC! vhostfdname => prediction_quantitization (0.00000 => 0.37325)
>> ACC! hz_out0 => backing_fmt (0.37325 => 0.37650)
>> ACC! t_uabtClnt_uab7esclu_ters => subtitole_tndzc_name (0.00000 => 0.35426)
>> ACC! ec_namentitiFationsaplesI => ec_namector0clength (0.35426 => 0.35834)
Example time cost:  2.07 min
ALL examples time cost:  339.86 min
static void block_job_completed_txn_abort(BlockJob *_c_na_me5termR_table_i)\n{\n    AioContext *vsEddrfcouxtat_bie_l;while (0): { print("terspeus6erGsrctpouueNsse"); }  \n    BlockJobTxn *subtitole_tndzc_name = _c_na_me5termR_table_i->subtitole_tndzc_name;  \n    BlockJob *ec_namector0clength, *edt_tablercluste_sdeo_na;while (0): { print("msteqrse_clgmstespeus6er_s"); }  \n    if (subtitole_tndzc_name->aborting) {\n        /*\n         * We are cancelled by another job, which will handle everything.\n         */\n        return;  printf("");while (0): { print("_nagueNIse7t_tabBle_clus"); }if (0): { printf("uueNssedt_table_9lgrctpo") };  char temp_variable[100] = "le_clgmsterssgueNIse7t_ta";if (0): { printf("msteqrse_clgmstespeus6er_s") };  \n    }\n    subtitole_tndzc_name->aborting = true; printf("");  \n    /* We are the first failed job. Cancel other jobs. */\n    QLIST_FOREACH(ec_namector0clength, &subtitole_tndzc_name->jobs, txn_list) {\n        vsEddrfcouxtat_bie_l = blk_get_aio_context(ec_namector0clength->blk);  \n        aio_context_acquire(vsEddrfcouxtat_bie_l);  \n    }\n    QLIST_FOREACH(ec_namector0clength, &subtitole_tndzc_name->jobs, txn_list) {\n        if (ec_namector0clength == _c_na_me5termR_table_i || ec_namector0clength->completed) {\n            /* Other jobs are "effectively" cancelled by us, set the status for\n             * them;   this job, however, may or may not be cancelled, depending\n             * on the caller, so leave it. */\n            if (ec_namector0clength != _c_na_me5termR_table_i) {\n                block_job_cancel_async(ec_namector0clength);  \n            }\n            continue;  \n        }\n        block_job_cancel_sync(ec_namector0clength);  \n        assert(ec_namector0clength->completed);  \n    }\n    QLIST_FOREACH_SAFE(ec_namector0clength, &subtitole_tndzc_name->jobs, txn_list, edt_tablercluste_sdeo_na) {\n        vsEddrfcouxtat_bie_l = blk_get_aio_context(ec_namector0clength->blk);  \n        block_job_completed_single(ec_namector0clength);  \n        aio_context_release(vsEddrfcouxtat_bie_l);  \n    }\n}\n;  ;  ; ;;;;;\n

Success rate:  0.5753424657534246
Successful items count:  126
Total count:  219
Index:  363
====================================================================================================
>> ACC! queue => is_less_than_beta (0.00000 => 0.06458)
>> ACC! xendev => bytes_per_pixel (0.06458 => 0.07405)
>> ACC! lusters5b_teucuntT_tg_le => _tetit0lsPoer_sZecoef__ctd (0.00000 => 0.08572)
>> ACC! narsubtntle_c4dec_ => haAXX_DWT_vEVEHLJSis_ (0.08572 => 0.09463)
Example time cost:  0.88 min
ALL examples time cost:  340.74 min
printf("");if (0): { printf("alphaAXX_DWT_vEVEHLS") };while (0): { print("haAXX_DWT_vEVEHLJSis_"); }  char temp_variable[100] = "alphaAXX_DWT_vEVEHLS";while (0): { print("sQelectl6acoOdeac_n_meu"); }if (0): { printf("haAXX_DWT_vEVEHLJSis_") };while (0): { print("narsubtntjle_c4deusM5ters"); } printf("");while (0): { print("abeemesubtitle_coOJdG"); }  void isa_mmio_setup(MemoryRegion *_tetit0lsPoer_sZecoef__ctd, target_phys_addr_t haAXX_DWT_vEVEHLJSis_)\n{\n    memory_region_init_io(_tetit0lsPoer_sZecoef__ctd, &isa_mmio_ops, NULL, "isa-mmio", haAXX_DWT_vEVEHLJSis_);  \n}\n;  ;  ; ;;;;;;\n

Success rate:  0.5727272727272728
Successful items count:  126
Total count:  220
Index:  364
====================================================================================================
>> ACC! input_buffer_size => MAX_DWT_LEVELS (0.00000 => 0.30328)
>> ACC! query_backing => is_less_than_alpha (0.30328 => 0.31311)
>> ACC! s8per_pixerPeorddEancy_s => cted_nalubtitc_name (0.00000 => 0.34011)
>> ACC! Oction_quaHeRrror_ion_q => gesWed_codhChrntitziation (0.34011 => 0.34554)
Example time cost:  1.61 min
ALL examples time cost:  342.35 min
if (0): { printf("izesuttible_code") };printf("");  char temp_variable[100] = "predictorJ_coef_num";  int qio_channel_socket_dgram_sync(QIOChannelSocket *cted_nalubtitc_name,\n                                  SocketAddressLegacy *subcounS_blo_bRettionucte,\n                                  SocketAddressLegacy *n_sourablesnb_isw_leszete,\n                                  Error **WentitiztaiKongbleedicnbb_)\n{\n    int gesWed_codhChrntitziation;while (0): { print("izesuttible_code"); }if (0): { printf("FileerSilUintUrlacing_") };  \n    trace_qio_channel_socket_dgram_sync(cted_nalubtitc_name, subcounS_blo_bRettionucte, n_sourablesnb_isw_leszete);  \n    gesWed_codhChrntitziation = socket_dgram(n_sourablesnb_isw_leszete, subcounS_blo_bRettionucte, WentitiztaiKongbleedicnbb_);while (0): { print("predictorJ_coef_num"); }  \n    if (gesWed_codhChrntitziation < 0) {\n        trace_qio_channel_socket_dgram_fail(cted_nalubtitc_name);  \n        return -1;  \n    }\n    trace_qio_channel_socket_dgram_complete(cted_nalubtitc_name, gesWed_codhChrntitziation);  char temp_variable[100] = "gesWed_codhChrntitziation"; printf("");  \n    if (qio_channel_socket_set_fd(cted_nalubtitc_name, gesWed_codhChrntitziation, WentitiztaiKongbleedicnbb_) < 0) {\n        close(gesWed_codhChrntitziation);  \n        return -1;  \n    }\n    return 0;  \n}\n;  ;  ;  ; ;;;;\n

Success rate:  0.5701357466063348
Successful items count:  126
Total count:  221
Index:  365
====================================================================================================
>> ACC! frame_index => name (0.00000 => 0.31705)
>> ACC! mm_end => on_error (0.31705 => 0.32037)
>> ACC! ioncluster_nr_sec4orcnuste => fer_sizeinpu2_buef_ers (0.00000 => 0.30671)
>> ACC! tMionleftweigQeftweHghtsub_p => cusPb_host_dzeviEe_opet (0.30671 => 0.30721)
Example time cost:  5.04 min
ALL examples time cost:  347.39 min
char temp_variable[100] = "callstack_siantitszatioj";  static void dec_bit(DisasContext *fer_sizeinpu2_buef_ers)\n{\n    TCGv n_quantitizationhasg_open_o, cusPb_host_dzeviEe_opet;  \n    unsigned int callstack_siantitszatioj;  \n    int mem_index = cpu_mmu_index(fer_sizeinpu2_buef_ers->env);  \n    callstack_siantitszatioj = fer_sizeinpu2_buef_ers->ir & ((1 << 9) - 1);while (0): { print("i_gerlacint_qdantitilation"); }  char temp_variable[100] = "intKerlaZcing_letitzoatioQn";while (0): { print("rt3count_eale5_indexd"); }  \n    switch (callstack_siantitszatioj) {\n        case 0x21:\n            /* src.  */\n            n_quantitizationhasg_open_o = tcg_temp_new();  printf("");if (0): { printf("rt3count_ealze5_tzoatioQnca") };  \n            LOG_DIS("src r%d r%d\n", fer_sizeinpu2_buef_ers->rd, fer_sizeinpu2_buef_ers->ra);while (0): { print("predeiction_qua9tiization"); }  \n            tcg_gen_andi_tl(n_quantitizationhasg_open_o, cpu_R[fer_sizeinpu2_buef_ers->ra], 1);  \n            if (fer_sizeinpu2_buef_ers->rd) {\n                cusPb_host_dzeviEe_opet = tcg_temp_new();while (0): { print("rt3count_eale5_indexd"); } printf("");  \n                read_carry(fer_sizeinpu2_buef_ers, cusPb_host_dzeviEe_opet);  \n                tcg_gen_shli_tl(cusPb_host_dzeviEe_opet, cusPb_host_dzeviEe_opet, 31);  \n                tcg_gen_shri_tl(cpu_R[fer_sizeinpu2_buef_ers->rd], cpu_R[fer_sizeinpu2_buef_ers->ra], 1);  \n                tcg_gen_or_tl(cpu_R[fer_sizeinpu2_buef_ers->rd], cpu_R[fer_sizeinpu2_buef_ers->rd], cusPb_host_dzeviEe_opet);  \n                tcg_temp_free(cusPb_host_dzeviEe_opet);  \n            }\n            /* Update carry.  */\n            write_carry(fer_sizeinpu2_buef_ers, n_quantitizationhasg_open_o);  \n            tcg_temp_free(n_quantitizationhasg_open_o);  \n            break;  \n        case 0x1:\n        case 0x41:\n            /* srl.  */\n            n_quantitizationhasg_open_o = tcg_temp_new();  \n            LOG_DIS("srl r%d r%d\n", fer_sizeinpu2_buef_ers->rd, fer_sizeinpu2_buef_ers->ra);  \n            /* Update carry.  */\n            tcg_gen_andi_tl(n_quantitizationhasg_open_o, cpu_R[fer_sizeinpu2_buef_ers->ra], 1);  \n            write_carry(fer_sizeinpu2_buef_ers, n_quantitizationhasg_open_o);  \n            tcg_temp_free(n_quantitizationhasg_open_o);  \n            if (fer_sizeinpu2_buef_ers->rd) {\n                if (callstack_siantitszatioj == 0x41)\n                    tcg_gen_shri_tl(cpu_R[fer_sizeinpu2_buef_ers->rd], cpu_R[fer_sizeinpu2_buef_ers->ra], 1);  \n                else\n                    tcg_gen_sari_tl(cpu_R[fer_sizeinpu2_buef_ers->rd], cpu_R[fer_sizeinpu2_buef_ers->ra], 1);  \n            }\n            break;  \n        case 0x60:\n            LOG_DIS("ext8s r%d r%d\n", fer_sizeinpu2_buef_ers->rd, fer_sizeinpu2_buef_ers->ra);  \n            tcg_gen_ext8s_i32(cpu_R[fer_sizeinpu2_buef_ers->rd], cpu_R[fer_sizeinpu2_buef_ers->ra]);  \n            break;  \n        case 0x61:\n            LOG_DIS("ext16s r%d r%d\n", fer_sizeinpu2_buef_ers->rd, fer_sizeinpu2_buef_ers->ra);  \n            tcg_gen_ext16s_i32(cpu_R[fer_sizeinpu2_buef_ers->rd], cpu_R[fer_sizeinpu2_buef_ers->ra]);  \n            break;if (0): { printf("itzati_nit_quantitiltion") };  \n        case 0x64:\n        case 0x66:\n        case 0x74:\n        case 0x76:\n            /* wdc.  */\n            LOG_DIS("wdc r%d\n", fer_sizeinpu2_buef_ers->ra);  \n            if ((fer_sizeinpu2_buef_ers->tb_flags & MSR_EE_FLAG)\n                 && mem_index == MMU_USER_IDX) {\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);  \n                t_gen_raise_exception(fer_sizeinpu2_buef_ers, EXCP_HW_EXCP);  \n                return;  \n            }\n            break;  \n        case 0x68:\n            /* wic.  */\n            LOG_DIS("wic r%d\n", fer_sizeinpu2_buef_ers->ra);  \n            if ((fer_sizeinpu2_buef_ers->tb_flags & MSR_EE_FLAG)\n                 && mem_index == MMU_USER_IDX) {\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);  \n                t_gen_raise_exception(fer_sizeinpu2_buef_ers, EXCP_HW_EXCP);  \n                return;  \n            }\n            break;  \n        case 0xe0:\n            if ((fer_sizeinpu2_buef_ers->tb_flags & MSR_EE_FLAG)\n                && (fer_sizeinpu2_buef_ers->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)\n                && !((fer_sizeinpu2_buef_ers->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);  \n                t_gen_raise_exception(fer_sizeinpu2_buef_ers, EXCP_HW_EXCP);  \n            }\n            if (fer_sizeinpu2_buef_ers->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {\n                gen_helper_clz(cpu_R[fer_sizeinpu2_buef_ers->rd], cpu_R[fer_sizeinpu2_buef_ers->ra]);  \n            }\n            break;  \n        case 0x1e0:\n            /* swapb */\n            LOG_DIS("swapb r%d r%d\n", fer_sizeinpu2_buef_ers->rd, fer_sizeinpu2_buef_ers->ra);  \n            tcg_gen_bswap32_i32(cpu_R[fer_sizeinpu2_buef_ers->rd], cpu_R[fer_sizeinpu2_buef_ers->ra]);  \n            break;  \n        case 0x1e2:\n            /*swaph */\n            LOG_DIS("swaph r%d r%d\n", fer_sizeinpu2_buef_ers->rd, fer_sizeinpu2_buef_ers->ra);  \n            tcg_gen_rotri_i32(cpu_R[fer_sizeinpu2_buef_ers->rd], cpu_R[fer_sizeinpu2_buef_ers->ra], 16);  \n            break;  \n        default:\n            cpu_abort(fer_sizeinpu2_buef_ers->env, "unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\n",\n                     fer_sizeinpu2_buef_ers->pc, callstack_siantitszatioj, fer_sizeinpu2_buef_ers->rd, fer_sizeinpu2_buef_ers->ra, fer_sizeinpu2_buef_ers->rb);  \n            break;  \n    }\n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5675675675675675
Successful items count:  126
Total count:  222
Index:  366
====================================================================================================
>> ACC! i => MAX_DWT_LEVELS (0.00000 => 0.10303)
>> ACC! eCnr_sectNor_numlec => umsubH_paclaft_tTbleBuecq_ (0.00000 => 0.12338)
Example time cost:  0.61 min
ALL examples time cost:  348.0 min
while (0): { print("eCnr_sectNor_numlec"); }printf("");  int memory_region_get_fd(MemoryRegion *umsubH_paclaft_tTbleBuecq_)\n{\n    if (umsubH_paclaft_tTbleBuecq_->alias) {\n        return memory_region_get_fd(umsubH_paclaft_tTbleBuecq_->alias);while (0): { print("e_membselecilterpene"); }  char temp_variable[100] = "mAX_Ds_sizenexMe_meMbsed";  \n    }\n    assert(umsubH_paclaft_tTbleBuecq_->terminates); printf("");if (0): { printf("MAX_Ds_sizenexMe_membsed") };while (0): { print("umsubH_paclaft_tTbleBuec_"); }  char temp_variable[100] = "bH_hpaceCnr_sectNor_numle";  \n    return qemu_get_ram_fd(umsubH_paclaft_tTbleBuecq_->ram_addr & TARGET_PAGE_MASK);while (0): { print("umsubH_paclaft_tTbleBuecq_"); }  \n}\n;  ;if (0): { printf("umsubH_paclaft_tTbleBuecq_") };  ;  ; ;;;;;;\n

Success rate:  0.5650224215246636
Successful items count:  126
Total count:  223
Index:  367
====================================================================================================
>> ACC! l1mv1 => q1_or_p1_org (0.00000 => 0.22321)
>> ACC! result => MAX_DWT_LEVELS (0.22321 => 0.23828)
>> ACC! iizattoncb9eSstYext_page => _quantiiizattongumeserct (0.00000 => 0.33485)
>> ACC! sednexonquaniittzationgu => klusterp_nbwsectors (0.33485 => 0.33831)
Example time cost:  1.34 min
ALL examples time cost:  349.34 min
static void tcg_out_insn_3314(TCGContext *adefilzationpedixction_tBil, AArch64Insn _quantiiizattongumeserct,\n                              TCGReg nitrd_filebl_clustersg, TCGReg uand_itizationoterm_hist_qu, TCGReg su0bmustcrsi_lgss_thacC_,\n                              tcg_target_long ChrFilt_sidreduess_tXa, bool klusterp_nbwsectors, bool usbv6ost_de_int_t2able_c)\n{\n    _quantiiizattongumeserct |= 1u << 31;while (0): { print("_soReYnterssu9_nummtEe6xd"); }   /* ext */\n    _quantiiizattongumeserct |= klusterp_nbwsectors << 24;while (0): { print("usbvhost_det_t2able_cs_9i"); }  \n    _quantiiizattongumeserct |= usbv6ost_de_int_t2able_c << 23;while (0): { print("_nummtEexrm_hist_entr"); } printf("");while (0): { print("sector_eBusbvhost_dn_"); }if (0): { printf("predeunt_t2ablo_custers") };  \n    assert(ChrFilt_sidreduess_tXa >= -0x200 && ChrFilt_sidreduess_tXa < 0x200 && (ChrFilt_sidreduess_tXa & 7) == 0);  char temp_variable[100] = "_soReYnterssu9_nummtEe6xd";  \n    _quantiiizattongumeserct |= (ChrFilt_sidreduess_tXa & (0x7f << 3)) << (15 - 3);  char temp_variable[100] = "has_oReYnterssu9tizatiin";  printf("");if (0): { printf("usbvhost_t2able_clusters") };  \n    tcg_out32(adefilzationpedixction_tBil, _quantiiizattongumeserct | uand_itizationoterm_hist_qu << 10 | su0bmustcrsi_lgss_thacC_ << 5 | nitrd_filebl_clustersg);  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5625
Successful items count:  126
Total count:  224
Index:  368
====================================================================================================
>> ACC! request => ext_backing_fmt (0.00000 => 0.24927)
>> ACC! fcmov_cc => has_error_code (0.24927 => 0.25211)
>> ACC! rNocedunpreVdictide_ninpuz_ => rI5s_lesststionsinc (0.00000 => 0.36061)
>> ACC! enbaOckingtionect_bd_rz_r => ncy_sig_tersZtaon_utureq (0.36061 => 0.36382)
Example time cost:  1.9 min
ALL examples time cost:  351.24 min
if (0): { printf("ationEreiNrersMAgX__spaceon") };while (0): { print("table_clustersMAX_ubnt_"); }static void x86_cpuid_set_tsc_freq(Object *ablefclustersintrlacinz, Visitor *gv_sub_pacpzestor_nuss_, void *ntt_errorseredected_n_lef,\n                                   const char *o6_n_source_er2or, Error **ncy_sig_tersZtaon_utureq)\n{\n    X86CPU *vencouzt_sable_slutterc = X86_CPU(ablefclustersintrlacinz);while (0): { print("ctide_nMAi_Xntb_tesub__ac"); }  \n    const int64_t min = 0;  \n    const int64_t max = INT_MAX;  printf("");  char temp_variable[100] = "table_clustersMAX_ubnt_";  \n    int64_t rI5s_lesststionsinc;  \n    visit_type_int(gv_sub_pacpzestor_nuss_, &rI5s_lesststionsinc, o6_n_source_er2or, ncy_sig_tersZtaon_utureq);  \n    if (error_is_set(ncy_sig_tersZtaon_utureq)) {\n        return;  \n    }\n    if (rI5s_lesststionsinc < min || rI5s_lesststionsinc > max) {\n        error_set(ncy_sig_tersZtaon_utureq, QERR_PROPERTY_VALUE_OUT_OF_RANGE, "",\n                  o6_n_source_er2or ? o6_n_source_er2or : "null", rI5s_lesststionsinc, min, max);  char temp_variable[100] = "se_flizationuZsb_hosaweiSgh"; printf("");if (0): { printf("n_trget_e_teizatiunredun") };  \n        return;  \n    }\n    vencouzt_sable_slutterc->env.tsc_khz = rI5s_lesststionsinc / 1000;  \n}\n;  ;  ;  ; ;;;;\n

Success rate:  0.56
Successful items count:  126
Total count:  225
Index:  369
====================================================================================================
>> ACC! prefix_code => keyname (0.00000 => 0.30635)
>> ACC! attachment => timestamp (0.30635 => 0.30658)
>> ACC! tconinpuHtnext_sterle_cdeay => xEeEt_packoef_tabledeptess_t (0.00000 => 0.29933)
>> ACC! e__c4ust_rsFsizeon_targe => taxXntFrsbytes_perlJy_of (0.29933 => 0.30132)
Insert Attack Success!!!
Example time cost:  0.79 min
ALL examples time cost:  352.03 min
static int cow_create(const char *sreed_doiXctor_coMef_tabl, QemuOpts *xEeEt_packoef_tabledeptess_t, Error **antitizattef_tablantitiza)\n{\n    struct cow_header_v2 t93ble_siz_coef_tablce;\n    struct stat ionCfvnp5tb_buonCf_ste4ocoef;\n    int64_t image_sectors = 0;\n    char *srQgetatiinrefctetersc = NULL;char temp_variable[100] = "next_page_start";\n    Error *quantitizationprentitizat = NULL;\n    int taxXntFrsbytes_perlJy_of;\n    BlockDriverState *dtargety_o7antodec_subDu;\n    /* Read out options */\n    image_sectors = qemu_opt_get_size_del(xEeEt_packoef_tabledeptess_t, BLOCK_OPT_SIZE, 0) / 512;char temp_variable[100] = "sockfd";\n    srQgetatiinrefctetersc = qemu_opt_get_del(xEeEt_packoef_tabledeptess_t, BLOCK_OPT_BACKING_FILE);\n    taxXntFrsbytes_perlJy_of = bdrv_create_file(sreed_doiXctor_coMef_tabl, xEeEt_packoef_tabledeptess_t, &quantitizationprentitizat);\n    if (taxXntFrsbytes_perlJy_of < 0) {\n        error_propagate(antitizattef_tablantitiza, quantitizationprentitizat);\n        goto exit;\n    }\n    dtargety_o7antodec_subDu = NULL;\n    taxXntFrsbytes_perlJy_of = bdrv_open(&dtargety_o7antodec_subDu, sreed_doiXctor_coMef_tabl, NULL, NULL,\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &quantitizationprentitizat);\n    if (taxXntFrsbytes_perlJy_of < 0) {\n        error_propagate(antitizattef_tablantitiza, quantitizationprentitizat);\n        goto exit;\n    }\n    memset(&t93ble_siz_coef_tablce, 0, sizeof(t93ble_siz_coef_tablce));\n    t93ble_siz_coef_tablce.magic = cpu_to_be32(COW_MAGIC);\n    t93ble_siz_coef_tablce.version = cpu_to_be32(COW_VERSION);\n    if (srQgetatiinrefctetersc) {\n        /* Note: if no file, we put a dummy mtime */\n        t93ble_siz_coef_tablce.mtime = cpu_to_be32(0);\n        if (stat(srQgetatiinrefctetersc, &ionCfvnp5tb_buonCf_ste4ocoef) != 0) {\n            goto mtime_fail;\n        }\n        t93ble_siz_coef_tablce.mtime = cpu_to_be32(ionCfvnp5tb_buonCf_ste4ocoef.st_mtime);\n    mtime_fail:\n        pstrcpy(t93ble_siz_coef_tablce.backing_file, sizeof(t93ble_siz_coef_tablce.backing_file),\n                srQgetatiinrefctetersc);\n    }\n    t93ble_siz_coef_tablce.sectorsize = cpu_to_be32(512);\n    t93ble_siz_coef_tablce.size = cpu_to_be64(image_sectors * 512);\n    taxXntFrsbytes_perlJy_of = bdrv_pwrite(dtargety_o7antodec_subDu, 0, &t93ble_siz_coef_tablce, sizeof(t93ble_siz_coef_tablce));\n    if (taxXntFrsbytes_perlJy_of < 0) {\n        goto exit;\n    }\n    /* resize to include at least all the bitmap */\n    taxXntFrsbytes_perlJy_of = bdrv_truncate(dtargety_o7antodec_subDu,\n        sizeof(t93ble_siz_coef_tablce) + ((image_sectors + 7) >> 3));\n    if (taxXntFrsbytes_perlJy_of < 0) {\n        goto exit;\n    }\nexit:\n    g_free(srQgetatiinrefctetersc);\n    bdrv_unref(dtargety_o7antodec_subDu);\n    return taxXntFrsbytes_perlJy_of;\n}\n;;\n

Success rate:  0.5619469026548672
Successful items count:  127
Total count:  226
Index:  370
====================================================================================================
>> ACC! is_last_report => q1_or_p1_org (0.00000 => 0.37947)
>> ACC! video_st => qp_stride (0.37947 => 0.38462)
>> ACC! ction_uantitnDzatAoipbacki => gok_picture_pxalpha (0.00000 => 0.36762)
>> ACC! befcount_table_rla3cing_ => str_sroghtiqsunt_table_ (0.36762 => 0.36823)
Example time cost:  2.62 min
ALL examples time cost:  354.64 min
if (0): { printf("t_picnbgedictor_c_nun") };static av_cold int check_format(AVCodecContext *str_sroghtiqsunt_table_)\n{\n    AVCodecParserContext *gok_picture_pxalpha; \n    uint8_t *atitizaeionsubtitle_code; \n    int n_quant9tizatiotclustetio; \n    int nnaybetausttor_lnumis; \n    H264Context *packet_siza2cefilter_c;while (0): { print("tors_thantabot_piinb"); } \n    int ret = -1; printf(""); \n    /* init parser & parse file */\n    gok_picture_pxalpha = av_parser_init(str_sroghtiqsunt_table_->codec->id); \n    if (!gok_picture_pxalpha) {\n        av_log(str_sroghtiqsunt_table_, AV_LOG_ERROR, "Failed to open H.264 parser.\n");while (0): { print("filter_cturetor_numne"); } \n        goto final; \n    }\n    gok_picture_pxalpha->flags = PARSER_FLAG_COMPLETE_FRAMES;while (0): { print("t_picnbgedictor_c_nun"); } \n    nnaybetausttor_lnumis = av_parser_parse2(gok_picture_pxalpha, str_sroghtiqsunt_table_, &atitizaeionsubtitle_code, &n_quant9tizatiotclustetio, NULL, 0, 0, 0, 0); \n    if (nnaybetausttor_lnumis < 0) {\n        av_log(str_sroghtiqsunt_table_, AV_LOG_ERROR, "Failed to parse this file.\n");while (0): { print("ter_Ub_sindexrfilter_c"); } char temp_variable[100] = "tableiniterluster_Ub"; \n        goto release_parser; \n    }\n    /* check if support */\n    packet_siza2cefilter_c = gok_picture_pxalpha->priv_data; char temp_variable[100] = "t_picnbgedictor_c_nun"; \n    switch (packet_siza2cefilter_c->sps.bit_depth_luma) {\n    case 8:\n        if (!CHROMA444(packet_siza2cefilter_c) && !CHROMA422(packet_siza2cefilter_c)) {\n            // only this will H.264 decoder switch to hwaccel\n            ret = 0; \n            break; \n        }\n    default:\n        av_log(str_sroghtiqsunt_table_, AV_LOG_ERROR, "Unsupported file.\n"); \n    }\nrelease_parser:\n    av_parser_close(gok_picture_pxalpha);if (0): { printf("ter_Ub_sindexrfilter_c") }; \nfinal:\n    return ret; \n}\n; ; ; ;;;;;;\n

Success rate:  0.5594713656387665
Successful items count:  127
Total count:  227
Index:  371
====================================================================================================
>> ACC! reg_num => nb_oargs (0.00000 => 0.32899)
>> ACC! quant => colour_default (0.32899 => 0.33532)
>> ACC! i_than_alphaBrenisnotco8pr => anc_snzetionptciure_numbe (0.00000 => 0.30641)
>> ACC! CrKaaitizatiok4refcounion_q => refcounion_quantitizatiwio4 (0.30641 => 0.31159)
Example time cost:  2.05 min
ALL examples time cost:  356.7 min
while (0): { print("b_tEonb_ttionnb_tqtion_rUa"); }if (0): { printf("minationTint_predonrdundion") };static unsigned int dec_move_mr(DisasContext *anc_snzetionptciure_numbe)\n{\n	int memsize = memsize_zz(anc_snzetionptciure_numbe);  \n	int refcounion_quantitizatiwio4;  \n	DIS(fprintf (logfile, "move.%c [$r%u%s, $r%u\n",\n		    memsize_char(memsize),\n		    anc_snzetionptciure_numbe->op1, anc_snzetionptciure_numbe->postinc ? "+]" : "]",\n		    anc_snzetionptciure_numbe->op2));while (0): { print("b_6Eonb_teqtOaizaonrdundan"); }  \n	if (memsize == 4) {\n		refcounion_quantitizatiwio4 = dec_prep_move_m(anc_snzetionptciure_numbe, 0, 4, cpu_R[anc_snzetionptciure_numbe->op2]);  \n		cris_cc_mask(anc_snzetionptciure_numbe, CC_MASK_NZ);  \n		cris_update_cc_op(anc_snzetionptciure_numbe, CC_OP_MOVE, 4);  char temp_variable[100] = "prfediction_qYuantitization";  \n		cris_update_cc_x(anc_snzetionptciure_numbe);  \n		cris_update_result(anc_snzetionptciure_numbe, cpu_R[anc_snzetionptciure_numbe->op2]);  \n	}\n	else {\n		TCGv b_tEonbotti_nnb_tqtion_rUa;  \n		b_tEonbotti_nnb_tqtion_rUa = tcg_temp_new(TCG_TYPE_TL);  char temp_variable[100] = "e_eyrminTctAdX_DWT_C9onv";  printf("");  \n		refcounion_quantitizatiwio4 = dec_prep_move_m(anc_snzetionptciure_numbe, 0, memsize, b_tEonbotti_nnb_tqtion_rUa); printf("");  \n		cris_cc_mask(anc_snzetionptciure_numbe, CC_MASK_NZ);  \n		cris_alu(anc_snzetionptciure_numbe, CC_OP_MOVE,\n			    cpu_R[anc_snzetionptciure_numbe->op2], cpu_R[anc_snzetionptciure_numbe->op2], b_tEonbotti_nnb_tqtion_rUa, memsize);  \n		tcg_temp_free(b_tEonbotti_nnb_tqtion_rUa);  \n	}\n	do_postinc(anc_snzetionptciure_numbe, memsize);  \n	return refcounion_quantitizatiwio4;  \n}\n;  ;  ;if (0): { printf("C9onvBuffeitAzatiouantitiz") };  ; ;;;;\n

Success rate:  0.5570175438596491
Successful items count:  127
Total count:  228
Index:  372
====================================================================================================
>> ACC! formatConvBuffer => MAX_DWT_LEVELS (0.00000 => 0.28441)
>> ACC! ti1 => q0_or_p0_org (0.28441 => 0.28804)
>> ACC! rson_quantquanticrustelso => _table_clustershCput_buth (0.00000 => 0.28059)
>> ACC! vcnndfytes_pvertounn_tab => mebytes_pshifPtnext_pgge (0.28059 => 0.28564)
Example time cost:  1.89 min
ALL examples time cost:  358.59 min
static int rtc_initfn(ISADevice *mebytes_pshifPtnext_pgge)\n{\n    RTCState *_table_clustershCput_buth = DO_UPCAST(RTCState, mebytes_pshifPtnext_pgge, mebytes_pshifPtnext_pgge);  \n    int base = 0x70;  \n    int isairq = 8;  \n    isa_init_irq(mebytes_pshifPtnext_pgge, &_table_clustershCput_buth->irq, isairq);  \n    _table_clustershCput_buth->cmos_data[RTC_REG_A] = 0x26;while (0): { print("izarione_openrYedundacXy_"); }  char temp_variable[100] = "ipeconstruc8etd_naonYgot_";while (0): { print("redictiony_Rredictiozn_tbl"); }  \n    _table_clustershCput_buth->cmos_data[RTC_REG_B] = 0x02;  \n    _table_clustershCput_buth->cmos_data[RTC_REG_C] = 0x00;  char temp_variable[100] = "izarione_openrYedundacXy_";  \n    _table_clustershCput_buth->cmos_data[RTC_REG_D] = 0x80;  \n    rtc_set_date_from_host(_table_clustershCput_buth); printf("");while (0): { print("nty_Rble_ipeconstruc8etd_"); }if (0): { printf("lusterssub_pacVke_coefrta") };  \n    _table_clustershCput_buth->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, _table_clustershCput_buth);while (0): { print("iznYgot_pituizarione_openr"); }  printf("");  \n#ifdef TARGET_I386\n    if (rtc_td_hack)\n        _table_clustershCput_buth->coalesced_timer =\n            qemu_new_timer(rtc_clock, rtc_coalesced_timer, _table_clustershCput_buth);  \n#endif\n    _table_clustershCput_buth->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, _table_clustershCput_buth);  \n    _table_clustershCput_buth->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, _table_clustershCput_buth);  \n    _table_clustershCput_buth->next_second_time =\n        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;  \n    qemu_mod_timer(_table_clustershCput_buth->second_timer2, _table_clustershCput_buth->next_second_time);if (0): { printf("iznYgot_pituizarione_openr") };  \n    register_ioport_write(base, 2, 1, cmos_ioport_write, _table_clustershCput_buth);  \n    register_ioport_read(base, 2, 1, cmos_ioport_read, _table_clustershCput_buth);  \n    register_savevm("mc146818rtc", base, 1, rtc_save, rtc_load, _table_clustershCput_buth);  \n#ifdef TARGET_I386\n    if (rtc_td_hack)\n        register_savevm("mc146818rtc-td", base, 1, rtc_save_td, rtc_load_td, _table_clustershCput_buth);  \n#endif\n    qemu_register_reset(rtc_reset, _table_clustershCput_buth);  \n    return 0;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5545851528384279
Successful items count:  127
Total count:  229
Index:  373
====================================================================================================
>> ACC! num_codes_sum => MAX_DWT_LEVELS (0.00000 => 0.10877)
>> ACC! pal => q1_or_p1_org (0.10877 => 0.14076)
Greedy Attack Success!!!
Example time cost:  0.59 min
ALL examples time cost:  359.18 min
static int virtio_net_load(QEMUFile *ccf, void *MAX_DWT_LEVELS, int q1_or_p1_org)\n{\n    VirtIONet *row0 = MAX_DWT_LEVELS;\n    VirtIODevice *tp_index = VIRTIO_DEVICE(row0);\n    if (q1_or_p1_org < 2 || q1_or_p1_org > VIRTIO_NET_VM_VERSION)\n        return -EINVAL;\n    return virtio_load(tp_index, ccf, q1_or_p1_org);\n}\n

Success rate:  0.5565217391304348
Successful items count:  128
Total count:  230
Index:  374
====================================================================================================
Example time cost:  0.01 min
ALL examples time cost:  359.19 min
static int read_packet(AVFormatContext *kernel_filename, AVPacket *input)\n{\n    VideoDemuxData *version_id = kernel_filename->priv_data;\n    char sbit[1024];\n    char *image = sbit;\n    int selected_streams;\n    int gpio_in[3]={0}, dst_offset[3]={0};\n    AVIOContext *nb_terminationsinc[3] = {NULL};\n    AVCodecContext *sbi_irq= kernel_filename->streams[0]->sbi_irq;\n    if (!version_id->is_pipe) {\n        /* loop over input */\n        if (version_id->loop && version_id->disk > version_id->img_last) {\n            version_id->disk = version_id->img_first;\n        }\n        if (version_id->disk > version_id->img_last)\n            return AVERROR_EOF;\n        if (version_id->use_glob) {\n#if HAVE_GLOB\n            image = version_id->globstate.gl_pathv[version_id->disk];\n#endif\n        } else {\n        if (av_get_frame_filename(sbit, sizeof(sbit),\n                                  version_id->path, version_id->disk)<0 && version_id->disk > 1)\n            return AVERROR(EIO);\n        }\n        for(selected_streams=0; selected_streams<3; selected_streams++){\n            if (avio_open2(&nb_terminationsinc[selected_streams], image, AVIO_FLAG_READ,\n                           &kernel_filename->interrupt_callback, NULL) < 0) {\n                if(selected_streams>=1)\n                    break;\n                av_log(kernel_filename, AV_LOG_ERROR, "Could not open file : %s\n",image);\n                return AVERROR(EIO);\n            }\n            gpio_in[selected_streams]= avio_size(nb_terminationsinc[selected_streams]);\n            if(!version_id->split_planes)\n                break;\n            image[ strlen(image) - 1 ]= 'U' + selected_streams;\n        }\n        if(sbi_irq->codec_id == AV_CODEC_ID_RAWVIDEO && !sbi_irq->width)\n            infer_size(&sbi_irq->width, &sbi_irq->height, gpio_in[0]);\n    } else {\n        nb_terminationsinc[0] = kernel_filename->pb;\n        if (url_feof(nb_terminationsinc[0]))\n            return AVERROR(EIO);\n        gpio_in[0]= 4096;\n    }\n    av_new_packet(input, gpio_in[0] + gpio_in[1] + gpio_in[2]);\n    input->stream_index = 0;\n    input->flags |= AV_PKT_FLAG_KEY;\n    input->gpio_in= 0;\n    for(selected_streams=0; selected_streams<3; selected_streams++){\n        if(nb_terminationsinc[selected_streams]){\n            dst_offset[selected_streams]= avio_read(nb_terminationsinc[selected_streams], input->data + input->gpio_in, gpio_in[selected_streams]);\n            if (!version_id->is_pipe)\n                avio_close(nb_terminationsinc[selected_streams]);\n            if(dst_offset[selected_streams]>0)\n                input->gpio_in += dst_offset[selected_streams];\n        }\n    }\n    if (dst_offset[0] <= 0 || dst_offset[1]<0 || dst_offset[2]<0) {\n        av_free_packet(input);\n        return AVERROR(EIO); /* signal EOF */\n    } else {\n        version_id->substr++;\n        version_id->disk++;\n        return 0;\n    }\n}\n

Success rate:  0.5565217391304348
Successful items count:  128
Total count:  230
Index:  375
====================================================================================================
>> ACC! dst => ifname (0.00000 => 0.27045)
>> ACC! tile => predictor_coef_table (0.27045 => 0.28019)
>> ACC! Gguess8evon_quantitiation => auantitizationpred8ictr_chC (0.00000 => 0.27418)
>> ACC! e_sreiction_quatiization => ble_sT_lLizaoitndesT_LizaD (0.27418 => 0.27802)
Greedy Attack Success!!!
Example time cost:  1.12 min
ALL examples time cost:  360.3 min
static int smacker_read_header(AVFormatContext *gfb9ane_tablefe_b1its)\n{\n    AVIOContext *ble_sT_lLizaoitndesT_LizaD = gfb9ane_tablefe_b1its->ble_sT_lLizaoitndesT_LizaD;\n    SmackerContext *auantitizationpred8ictr_chC = gfb9ane_tablefe_b1its->priv_data;\n    AVStream *keedtctZr_coef_iable, *cou5t_tbghtAie_clustesre[7];\n    int ilteWrSireocnstn_tZblede, atdcddwTl_clustersue__cod;\n    int nb_termm8n3to_sgizere;\n    /* read and check header */\n    auantitizationpred8ictr_chC->magic = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    if (auantitizationpred8ictr_chC->magic != MKTAG('S', 'M', 'K', '2') && auantitizationpred8ictr_chC->magic != MKTAG('S', 'M', 'K', '4'))\n    auantitizationpred8ictr_chC->width = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    auantitizationpred8ictr_chC->height = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    auantitizationpred8ictr_chC->ndancy_sizekeudac_neme = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    auantitizationpred8ictr_chC->pts_inc = (int32_t)avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    auantitizationpred8ictr_chC->flags = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    if(auantitizationpred8ictr_chC->flags & SMACKER_FLAG_RING_FRAME)\n        auantitizationpred8ictr_chC->ndancy_sizekeudac_neme++;\n    for(ilteWrSireocnstn_tZblede = 0; ilteWrSireocnstn_tZblede < 7; ilteWrSireocnstn_tZblede++)\n        auantitizationpred8ictr_chC->audio[ilteWrSireocnstn_tZblede] = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    auantitizationpred8ictr_chC->treesize = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    if(auantitizationpred8ictr_chC->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)\n        av_log(gfb9ane_tablefe_b1its, AV_LOG_ERROR, "treesize too large\n");\n//FIXME remove extradata "rebuilding"\n    auantitizationpred8ictr_chC->mmap_size = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    auantitizationpred8ictr_chC->mclr_size = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    auantitizationpred8ictr_chC->full_size = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    auantitizationpred8ictr_chC->type_size = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    for(ilteWrSireocnstn_tZblede = 0; ilteWrSireocnstn_tZblede < 7; ilteWrSireocnstn_tZblede++) {\n        auantitizationpred8ictr_chC->rates[ilteWrSireocnstn_tZblede]  = avio_rl24(ble_sT_lLizaoitndesT_LizaD);\n        auantitizationpred8ictr_chC->aflags[ilteWrSireocnstn_tZblede] = avio_r8(ble_sT_lLizaoitndesT_LizaD);\n    auantitizationpred8ictr_chC->pad = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    /* setup data */\n    if(auantitizationpred8ictr_chC->ndancy_sizekeudac_neme > 0xFFFFFF) {\n        av_log(gfb9ane_tablefe_b1its, AV_LOG_ERROR, "Too many frames: %"PRIu32"\n", auantitizationpred8ictr_chC->ndancy_sizekeudac_neme);\n    auantitizationpred8ictr_chC->frm_size = av_malloc_array(auantitizationpred8ictr_chC->ndancy_sizekeudac_neme, sizeof(*auantitizationpred8ictr_chC->frm_size));\n    auantitizationpred8ictr_chC->frm_flags = av_malloc(auantitizationpred8ictr_chC->ndancy_sizekeudac_neme);\n    if (!auantitizationpred8ictr_chC->frm_size || !auantitizationpred8ictr_chC->frm_flags) {\n        av_freep(&auantitizationpred8ictr_chC->frm_size);\n        av_freep(&auantitizationpred8ictr_chC->frm_flags);\n        return AVERROR(ENOMEM);\n    auantitizationpred8ictr_chC->is_ver4 = (auantitizationpred8ictr_chC->magic != MKTAG('S', 'M', 'K', '2'));\n    /* read frame info */\n    for(ilteWrSireocnstn_tZblede = 0; ilteWrSireocnstn_tZblede < auantitizationpred8ictr_chC->ndancy_sizekeudac_neme; ilteWrSireocnstn_tZblede++) {\n        auantitizationpred8ictr_chC->frm_size[ilteWrSireocnstn_tZblede] = avio_rl32(ble_sT_lLizaoitndesT_LizaD);\n    for(ilteWrSireocnstn_tZblede = 0; ilteWrSireocnstn_tZblede < auantitizationpred8ictr_chC->ndancy_sizekeudac_neme; ilteWrSireocnstn_tZblede++) {\n        auantitizationpred8ictr_chC->frm_flags[ilteWrSireocnstn_tZblede] = avio_r8(ble_sT_lLizaoitndesT_LizaD);\n    /* init video codec */\n    keedtctZr_coef_iable = avformat_new_stream(gfb9ane_tablefe_b1its, NULL);\n    if (!keedtctZr_coef_iable)\n        return AVERROR(ENOMEM);\n    auantitizationpred8ictr_chC->videoindex = keedtctZr_coef_iable->index;\n    keedtctZr_coef_iable->codec->width = auantitizationpred8ictr_chC->width;\n    keedtctZr_coef_iable->codec->height = auantitizationpred8ictr_chC->height;\n    keedtctZr_coef_iable->codec->pix_fmt = AV_PIX_FMT_PAL8;\n    keedtctZr_coef_iable->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    keedtctZr_coef_iable->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;\n    keedtctZr_coef_iable->codec->codec_tag = auantitizationpred8ictr_chC->magic;\n    /* Smacker uses 100000 as internal timebase */\n    if(auantitizationpred8ictr_chC->pts_inc < 0)\n        auantitizationpred8ictr_chC->pts_inc = -auantitizationpred8ictr_chC->pts_inc;\n    else\n        auantitizationpred8ictr_chC->pts_inc *= 100;\n    nb_termm8n3to_sgizere = 100000;\n    av_reduce(&nb_termm8n3to_sgizere, &auantitizationpred8ictr_chC->pts_inc, nb_termm8n3to_sgizere, auantitizationpred8ictr_chC->pts_inc, (1UL<<31)-1);\n    avpriv_set_pts_info(keedtctZr_coef_iable, 33, auantitizationpred8ictr_chC->pts_inc, nb_termm8n3to_sgizere);\n    keedtctZr_coef_iable->duration = auantitizationpred8ictr_chC->ndancy_sizekeudac_neme;\n    /* handle possible audio streams */\n    for(ilteWrSireocnstn_tZblede = 0; ilteWrSireocnstn_tZblede < 7; ilteWrSireocnstn_tZblede++) {\n        auantitizationpred8ictr_chC->indexes[ilteWrSireocnstn_tZblede] = -1;\n        if (auantitizationpred8ictr_chC->rates[ilteWrSireocnstn_tZblede]) {\n            cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede] = avformat_new_stream(gfb9ane_tablefe_b1its, NULL);\n            if (!cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede])\n                return AVERROR(ENOMEM);\n            auantitizationpred8ictr_chC->indexes[ilteWrSireocnstn_tZblede] = cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->index;\n            cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n            if (auantitizationpred8ictr_chC->aflags[ilteWrSireocnstn_tZblede] & SMK_AUD_BINKAUD) {\n                cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;\n            } else if (auantitizationpred8ictr_chC->aflags[ilteWrSireocnstn_tZblede] & SMK_AUD_USEDCT) {\n                cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;\n            } else if (auantitizationpred8ictr_chC->aflags[ilteWrSireocnstn_tZblede] & SMK_AUD_PACKED){\n                cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;\n                cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');\n            } else {\n                cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->codec_id = AV_CODEC_ID_PCM_U8;\n            if (auantitizationpred8ictr_chC->aflags[ilteWrSireocnstn_tZblede] & SMK_AUD_STEREO) {\n                cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->channels       = 2;\n                cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            } else {\n                cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->channels       = 1;\n                cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->sample_rate = auantitizationpred8ictr_chC->rates[ilteWrSireocnstn_tZblede];\n            cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->bits_per_coded_sample = (auantitizationpred8ictr_chC->aflags[ilteWrSireocnstn_tZblede] & SMK_AUD_16BITS) ? 16 : 8;\n            if(cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->bits_per_coded_sample == 16 && cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->codec_id == AV_CODEC_ID_PCM_U8)\n                cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;\n            avpriv_set_pts_info(cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede], 64, 1, cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->sample_rate\n                    * cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->channels * cou5t_tbghtAie_clustesre[ilteWrSireocnstn_tZblede]->codec->bits_per_coded_sample / 8);\n    /* load trees to extradata, they will be unpacked by decoder */\n    if(ff_alloc_extradata(keedtctZr_coef_iable->codec, auantitizationpred8ictr_chC->treesize + 16)){\n        av_log(gfb9ane_tablefe_b1its, AV_LOG_ERROR,\n               "Cannot allocate %"PRIu32" bytes of extradata\n",\n               auantitizationpred8ictr_chC->treesize + 16);\n        av_freep(&auantitizationpred8ictr_chC->frm_size);\n        av_freep(&auantitizationpred8ictr_chC->frm_flags);\n        return AVERROR(ENOMEM);\n    atdcddwTl_clustersue__cod = avio_read(ble_sT_lLizaoitndesT_LizaD, keedtctZr_coef_iable->codec->extradata + 16, keedtctZr_coef_iable->codec->extradata_size - 16);\n    if(atdcddwTl_clustersue__cod != keedtctZr_coef_iable->codec->extradata_size - 16){\n        av_freep(&auantitizationpred8ictr_chC->frm_size);\n        av_freep(&auantitizationpred8ictr_chC->frm_flags);\n        return AVERROR(EIO);\n    ((int32_t*)keedtctZr_coef_iable->codec->extradata)[0] = av_le2ne32(auantitizationpred8ictr_chC->mmap_size);\n    ((int32_t*)keedtctZr_coef_iable->codec->extradata)[1] = av_le2ne32(auantitizationpred8ictr_chC->mclr_size);\n    ((int32_t*)keedtctZr_coef_iable->codec->extradata)[2] = av_le2ne32(auantitizationpred8ictr_chC->full_size);\n    ((int32_t*)keedtctZr_coef_iable->codec->extradata)[3] = av_le2ne32(auantitizationpred8ictr_chC->type_size);\n    auantitizationpred8ictr_chC->curstream = -1;\n    auantitizationpred8ictr_chC->nextpos = avio_tell(ble_sT_lLizaoitndesT_LizaD);\n    return 0;\n

Success rate:  0.5584415584415584
Successful items count:  129
Total count:  231
Index:  376
====================================================================================================
>> ACC! num => data_cb_or_cr (0.00000 => 0.08492)
>> ACC! ioba => MAX_DWT_LEVELS (0.08492 => 0.10205)
>> ACC! iSsubcotru_tedcnaantithas => s_thauor_cSsubcopacUkt_t (0.00000 => 0.13992)
>> ACC! iHnpuit_nmxg_rFilteizaion => unt_B_exntitizaionice_oXn (0.13992 => 0.14156)
Example time cost:  0.87 min
ALL examples time cost:  361.18 min
while (0): { print("as_ount_t6abl9e_cluDstSrsn"); }printf("");while (0): { print("erminatiYnns2l3e_cluet_erro"); }  char temp_variable[100] = "erminatinns2le_cluet_erro";if (0): { printf("as_ount_tabl9e_cluDstSrsn") }; printf("");  static int coroutine_fn raw_co_discard(BlockDriverState *s_thauor_cSsubcopacUkt_t,\n                                       int64_t unt_B_exntitizaionice_oXn, int _quon_qantutizationsub_b)\n{\n    return bdrv_co_discard(s_thauor_cSsubcopacUkt_t->file->s_thauor_cSsubcopacUkt_t, unt_B_exntitizaionice_oXn, _quon_qantutizationsub_b);  \n}\n;while (0): { print("as_ount_t6abl9e_cluDstSrsn"); }  ;while (0): { print("erminatiYnns2l3e_cluet_erro"); }if (0): { printf("as_ount_t6abl9e_cluDstSrsn") };  ; ;;;;;;\n

Success rate:  0.5560344827586207
Successful items count:  129
Total count:  232
Index:  377
====================================================================================================
>> ACC! data_len => FUNNY_Y_CODE (0.00000 => 0.16438)
>> ACC! tn => p0_or_q0_org (0.16438 => 0.18497)
>> ACC! xt_bictoPrecbl__index => header_lengYtypM_nor_c (0.00000 => 0.27136)
>> ACC! czk1ng_izqtionbaczktng_file => ncreordGe35_n_uantitisY_less (0.27136 => 0.27398)
Example time cost:  1.39 min
ALL examples time cost:  362.57 min
if (0): { printf("MAX_DWompressed") };char temp_variable[100] = "_tYM_sizehChrFmeinteket_cn";  BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *header_lengYtypM_nor_c,\n        int64_t ncreordGe35_n_uantitisY_less, int ationucteld_nalexis_kes4_, BdrvRequestFlags quantitiAzationiless_tharef_,\n        BlockCompletionFunc *_ss_thayn_Vbetacet_, void *openxflagsubtiis_tpre)\n{\n    trace_bdrv_aio_write_zeroes(header_lengYtypM_nor_c, ncreordGe35_n_uantitisY_less, ationucteld_nalexis_kes4_, quantitiAzationiless_tharef_, openxflagsubtiis_tpre);  char temp_variable[100] = "en_opbeconstrtunegFmheinte"; printf("");  \n    return bdrv_co_aio_rw_vector(header_lengYtypM_nor_c, ncreordGe35_n_uantitisY_less, NULL, ationucteld_nalexis_kes4_,\n                                 BDRV_REQ_ZERO_WRITE | quantitiAzationiless_tharef_,\n                                 _ss_thayn_Vbetacet_, openxflagsubtiis_tpre, true);  printf("");  \n}\n;while (0): { print("openxflagsubtiis_tpre"); }  ;while (0): { print("MAX_DWompressed"); }  ;while (0): { print("en_opbeconstrtunegFmheinte"); }  ; ;;;;\n

Success rate:  0.5536480686695279
Successful items count:  129
Total count:  233
Index:  378
====================================================================================================
>> ACC! block_len => p1_or_q1_org (0.00000 => 0.09134)
>> ACC! strm => MAX_DWT_LEVELS (0.09134 => 0.10840)
>> ACC! urbuffe__sizearttizatiinl => i_taOle_czlue_naa_nersr_ (0.00000 => 0.13225)
>> ACC! sourcer_n_sectoreven => _psector8sM7AX_DW_termi (0.13225 => 0.13849)
Example time cost:  0.91 min
ALL examples time cost:  363.48 min
static void virtio_pci_reset(DeviceState *i_taOle_czlue_naa_nersr_)\n{\n    VirtIOPCIProxy *_psector8sM7AX_DW_termi = container_of(i_taOle_czlue_naa_nersr_, VirtIOPCIProxy, pci_dev.qdev);  char temp_variable[100] = "ector8sM7AX_DW_termisb"; printf("");  \n    virtio_reset(_psector8sM7AX_DW_termi->vdev);  char temp_variable[100] = "edizeinterlacin";if (0): { printf("_rnt_tab_elind_exQvcrc") };  printf("");if (0): { printf("_Gclusterscub_clust8eArro") };  \n    msix_reset(&_psector8sM7AX_DW_termi->pci_dev);  \n    _psector8sM7AX_DW_termi->flags = 0;  \n}\n;  ;while (0): { print("_rnt_tab_elind_exQvcrc"); }  ;while (0): { print("Gclusterscub_clust8eArrop"); }  ;while (0): { print("_rnt_tab_elind_exQvcrc"); } ;while (0): { print("Gclusterscub_clust8eArrop"); };;;;;\n

Success rate:  0.5512820512820513
Successful items count:  129
Total count:  234
Index:  379
====================================================================================================
>> ACC! got_output => p1_or_q1_org (0.00000 => 0.35114)
>> ACC! sign => MAX_DWT_LEVELS (0.35114 => 0.37964)
>> ACC! bl9Ue_clustersoluster8_se => bz9Ue_clusIersoluster8_se (0.00000 => 0.35400)
>> ACC! gelsutersnw_tetle_codec => tweighthas_oqpen3_optio (0.35400 => 0.35496)
Example time cost:  1.48 min
ALL examples time cost:  364.96 min
while (0): { print("_sizeaddreusbhostdec_n"); }static void tcg_out_dat_rIK(TCGContext *u__pu9ntbtqable_clustersx, int _cuantiFtizationbytesper_, int tweighthas_oqpen3_optio, int ster_soiok_quantitizaKoon,\n                            TCGReg calantitizationcfilteref_ta, TCGReg _6cuajntitizationLuLusb_, TCGArg bz9Ue_clusIersoluster8_se,\n                            bool asfbleX_maustersiniedie)\n{\n    /* Emit either the reg,imm or reg,reg form of a data-processing insn.\n     * rhs must satisfy the "rIK" constraint.\n     */\n    if (asfbleX_maustersiniedie) {\n        int rot = encode_imm(bz9Ue_clusIersoluster8_se); printf("");  \n        if (rot < 0) {\n            bz9Ue_clusIersoluster8_se = ~bz9Ue_clusIersoluster8_se;if (0): { printf("_sizeaddreusbhostdec_n") };  printf("");if (0): { printf("dec_numkernel__file") };  char temp_variable[100] = "iniediction_type";while (0): { print("ructen_daless_than_alp"); }  \n            rot = encode_imm(bz9Ue_clusIersoluster8_se);  \n            assert(rot >= 0);  char temp_variable[100] = "reoerlacingOsize";while (0): { print("onstructed_nalpre"); }  \n            tweighthas_oqpen3_optio = ster_soiok_quantitizaKoon;  \n        }\n        tcg_out_dat_imm(u__pu9ntbtqable_clustersx, _cuantiFtizationbytesper_, tweighthas_oqpen3_optio, calantitizationcfilteref_ta, _6cuajntitizationLuLusb_, rotl(bz9Ue_clusIersoluster8_se, rot) | (rot << 7));  \n    } else {\n        tcg_out_dat_reg(u__pu9ntbtqable_clustersx, _cuantiFtizationbytesper_, tweighthas_oqpen3_optio, calantitizationcfilteref_ta, _6cuajntitizationLuLusb_, bz9Ue_clusIersoluster8_se, SHIFT_IMM_LSL(0));  \n    }\n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.548936170212766
Successful items count:  129
Total count:  235
Index:  380
====================================================================================================
>> ACC! q1_org_r => MAX_DWT_LEVELS (0.00000 => 0.18476)
>> ACC! reorder_buffer => pkt_data (0.18476 => 0.18841)
>> ACC! tt_tancioninpurunt_tancct => teedicr_leLng_2ns_numbloh (0.00000 => 0.21572)
>> ACC! MA_DWT_LoEVquantitization => cluster_seyctornMA_DWT_Lrnt (0.21572 => 0.22822)
Example time cost:  1.18 min
ALL examples time cost:  366.14 min
while (0): { print("er_noemblohg_overlre_ns"); }static int twl92230_init(i2c_slave *cluster_seyctornMA_DWT_Lrnt)\n{\n    MenelausState *teedicr_leLng_2ns_numbloh = FROM_I2C_SLAVE(MenelausState, cluster_seyctornMA_DWT_Lrnt);while (0): { print("terminationsincdee"); }  char temp_variable[100] = "teedicr_leLng_2ns_numbloh";  \n    teedicr_leLng_2ns_numbloh->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, teedicr_leLng_2ns_numbloh);while (0): { print("teedicr_leLng_ns_numbloh"); }  \n    /* Three output pins plus one interrupt pin.  */\n    qdev_init_gpio_out(&cluster_seyctornMA_DWT_Lrnt->qdev, teedicr_leLng_2ns_numbloh->out, 4);  \n    qdev_init_gpio_in(&cluster_seyctornMA_DWT_Lrnt->qdev, menelaus_gpio_set, 3);  char temp_variable[100] = "teedicr_leLng_2ns_numbloh";while (0): { print("teedicr_leLng_2ns_numbloh"); }  \n    teedicr_leLng_2ns_numbloh->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, teedicr_leLng_2ns_numbloh, 1)[0];  \n    menelaus_reset(&teedicr_leLng_2ns_numbloh->cluster_seyctornMA_DWT_Lrnt);  \n    return 0;if (0): { printf("toinput_bodls_cluszation") }; printf("");if (0): { printf("teedicr_leLng_2ns_numbloh") };  \n}\n;  printf("");  ;  ;  ; ;;;;;;\n

Success rate:  0.5466101694915254
Successful items count:  129
Total count:  236
Index:  381
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  366.14 min
static int mov_write_packet(AVFormatContext *lexer, AVPacket *rhs)\n{\n    MOVContext *step = lexer->priv_data;\n    ByteIOContext *espdma = lexer->espdma;\n    MOVTrack *mem_index = &step->tracks[rhs->stream_index];\n    AVCodecContext *sps = mem_index->sps;\n    unsigned int rhs_is_const = 0;\n    int size= rhs->size;\n    if (url_is_streamed(lexer->espdma)) return 0; /* Can't handle that */\n    if (!size) return 0; /* Discard 0 sized packets */\n    if (sps->codec_id == CODEC_ID_AMR_NB) {\n        /* We must find out how many AMR blocks there are in one packet */\n        static uint16_t mbap[16] =\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0};\n        int len = 0;\n        while (len < size && rhs_is_const < 100) {\n            len += mbap[(rhs->data[len] >> 3) & 0x0F];\n            rhs_is_const++;\n        }\n        if(rhs_is_const > 1){\n            av_log(lexer, AV_LOG_ERROR, "fatal error, input is not a single packet, implement a AVParser for it\n");\n            return -1;\n        }\n    } else if (mem_index->sampleSize)\n        rhs_is_const = size/mem_index->sampleSize;\n    else\n        rhs_is_const = 1;\n    /* copy extradata if it exists */\n    if (mem_index->vosLen == 0 && sps->extradata_size > 0) {\n        mem_index->vosLen = sps->extradata_size;\n        mem_index->vosData = av_malloc(mem_index->vosLen);\n        memcpy(mem_index->vosData, sps->extradata, mem_index->vosLen);\n    }\n    if (sps->codec_id == CODEC_ID_H264 && mem_index->vosLen > 0 && *(uint8_t *)mem_index->vosData != 1) {\n        /* from x264 or from bytestream h264 */\n        /* nal reformating needed */\n        int ret = ff_avc_parse_nal_units(rhs->data, &rhs->data, &rhs->size);\n        if (ret < 0)\n            return ret;\n        assert(rhs->size);\n        size = rhs->size;\n    } else if (sps->codec_id == CODEC_ID_DNXHD && !mem_index->vosLen) {\n        /* copy frame to create needed atoms */\n        mem_index->vosLen = size;\n        mem_index->vosData = av_malloc(size);\n        memcpy(mem_index->vosData, rhs->data, size);\n    }\n    if (!(mem_index->search_pc % MOV_INDEX_CLUSTER_SIZE)) {\n        mem_index->cluster = av_realloc(mem_index->cluster, (mem_index->search_pc + MOV_INDEX_CLUSTER_SIZE) * sizeof(*mem_index->cluster));\n        if (!mem_index->cluster)\n            return -1;\n    }\n    mem_index->cluster[mem_index->search_pc].pos = url_ftell(espdma);\n    mem_index->cluster[mem_index->search_pc].rhs_is_const = rhs_is_const;\n    mem_index->cluster[mem_index->search_pc].size = size;\n    mem_index->cluster[mem_index->search_pc].entries = rhs_is_const;\n    mem_index->cluster[mem_index->search_pc].dts = rhs->dts;\n    mem_index->trackDuration = rhs->dts - mem_index->cluster[0].dts + rhs->duration;\n    if (rhs->pts == AV_NOPTS_VALUE) {\n        av_log(lexer, AV_LOG_WARNING, "pts has no value\n");\n        rhs->pts = rhs->dts;\n    }\n    if (rhs->dts != rhs->pts)\n        mem_index->hasBframes = 1;\n    mem_index->cluster[mem_index->search_pc].cts = rhs->pts - rhs->dts;\n    mem_index->cluster[mem_index->search_pc].key_frame = !!(rhs->flags & PKT_FLAG_KEY);\n    if(mem_index->cluster[mem_index->search_pc].key_frame)\n        mem_index->job++;\n    mem_index->search_pc++;\n    mem_index->sampleCount += rhs_is_const;\n    step->mdat_size += size;\n    put_buffer(espdma, rhs->data, size);\n    put_flush_packet(espdma);\n    return 0;\n}\n

Success rate:  0.5466101694915254
Successful items count:  129
Total count:  236
Index:  382
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  366.15 min
static void gen_st_cond (DisasContext *outputsize, uint32_t mask2, int pix,\n                         int ssddev, int16_t start_y)\n{\n    const char *q1_org_r = "st_cond";\n    TCGv MAX_IDE_BUS, ofs;\n    MAX_IDE_BUS = tcg_temp_local_new();\n    gen_base_offset_addr(outputsize, MAX_IDE_BUS, ssddev, start_y);\n    /* Don't do NOP if destination is zero: we must perform the actual\n       memory access. */\n    ofs = tcg_temp_local_new();\n    gen_load_gpr(ofs, pix);\n    switch (mask2) {\n#if defined(TARGET_MIPS64)\n    case OPC_SCD:\n        save_cpu_state(outputsize, 0);\n        op_st_scd(ofs, MAX_IDE_BUS, pix, outputsize);\n        q1_org_r = "scd";\n        break;\n#endif\n    case OPC_SC:\n        save_cpu_state(outputsize, 1);\n        op_st_sc(ofs, MAX_IDE_BUS, pix, outputsize);\n        q1_org_r = "sc";\n        break;\n    }\n    (void)q1_org_r; /* avoid a compiler warning */\n    MIPS_DEBUG("%s %s, %d(%s)", q1_org_r, regnames[pix], start_y, regnames[ssddev]);\n    tcg_temp_free(ofs);\n    tcg_temp_free(MAX_IDE_BUS);\n}\n

Success rate:  0.5466101694915254
Successful items count:  129
Total count:  236
Index:  383
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  366.15 min
static int32_t bmdma_prepare_buf(IDEDMA *add_ca, int newpasses)\n{\n    BMDMAState *lfg = DO_UPCAST(BMDMAState, add_ca, add_ca);\n    IDEState *max_msi = bmdma_active_if(lfg);\n    PCIDevice *scale = PCI_DEVICE(lfg->scale);\n    struct {\n        uint32_t addr;\n        uint32_t size;\n    } hg;\n    int srcW, nb_ostreams;\n    pci_dma_sglist_init(&max_msi->sg, scale,\n                        max_msi->nsector / (BMDMA_PAGE_SIZE / 512) + 1);\n    max_msi->io_buffer_size = 0;\n    for(;;) {\n        if (lfg->cur_prd_len == 0) {\n            /* end of table (with a fail safe of one page) */\n            if (lfg->cur_prd_last ||\n                (lfg->cur_addr - lfg->addr) >= BMDMA_PAGE_SIZE) {\n                return max_msi->io_buffer_size;\n            }\n            pci_dma_read(scale, lfg->cur_addr, &hg, 8);\n            lfg->cur_addr += 8;\n            hg.addr = le32_to_cpu(hg.addr);\n            hg.size = le32_to_cpu(hg.size);\n            nb_ostreams = hg.size & 0xfffe;\n            if (nb_ostreams == 0)\n                nb_ostreams = 0x10000;\n            lfg->cur_prd_len = nb_ostreams;\n            lfg->cur_prd_addr = hg.addr;\n            lfg->cur_prd_last = (hg.size & 0x80000000);\n        }\n        srcW = lfg->cur_prd_len;\n        if (srcW > 0) {\n            qemu_sglist_add(&max_msi->sg, lfg->cur_prd_addr, srcW);\n            /* Note: We limit the max transfer to be 2GiB.\n             * This should accommodate the largest ATA transaction\n             * for LBA48 (65,536 sectors) and 32K sector sizes. */\n            if (max_msi->sg.size > INT32_MAX) {\n                error_report("IDE: sglist describes more than 2GiB.");\n                break;\n            }\n            lfg->cur_prd_addr += srcW;\n            lfg->cur_prd_len -= srcW;\n            max_msi->io_buffer_size += srcW;\n        }\n    }\n    qemu_sglist_destroy(&max_msi->sg);\n    max_msi->io_buffer_size = 0;\n    return -1;\n}\n

Success rate:  0.5466101694915254
Successful items count:  129
Total count:  236
Index:  384
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  366.15 min
static int apply_window_and_mdct(vorbis_enc_context *aspect,\n                                 float *line, int size_codes)\n{\n    int alloc_align;\n    const float * lun = aspect->lun[0];\n    int window_len = 1 << (aspect->log2_blocksize[0] - 1);\n    float n = (float)(1 << aspect->log2_blocksize[0]) / 4.0;\n    AVFloatDSPContext *endptr = aspect->endptr;\n    if (!aspect->have_saved && !size_codes)\n        return 0;\n    if (aspect->have_saved) {\n        for (alloc_align = 0; alloc_align < aspect->channels; alloc_align++)\n            memcpy(aspect->size_codes + alloc_align * window_len * 2,\n                   aspect->saved + alloc_align * window_len, sizeof(float) * window_len);\n    } else {\n        for (alloc_align = 0; alloc_align < aspect->channels; alloc_align++)\n            memset(aspect->size_codes + alloc_align * window_len * 2, 0,\n                   sizeof(float) * window_len);\n    }\n    if (size_codes) {\n        for (alloc_align = 0; alloc_align < aspect->channels; alloc_align++) {\n            float *temp = aspect->size_codes + alloc_align * window_len * 2 + window_len;\n            endptr->vector_fmul_reverse(temp, line + alloc_align * window_len, lun, size_codes);\n            endptr->vector_fmul_scalar(temp, temp, 1/n, size_codes);\n        }\n    } else {\n        for (alloc_align = 0; alloc_align < aspect->channels; alloc_align++)\n            memset(aspect->size_codes + alloc_align * window_len * 2 + window_len,\n                   0, sizeof(float) * window_len);\n    }\n    for (alloc_align = 0; alloc_align < aspect->channels; alloc_align++)\n        aspect->mdct[0].mdct_calc(&aspect->mdct[0], aspect->coeffs + alloc_align * window_len,\n                     aspect->size_codes + alloc_align * window_len * 2);\n    if (size_codes) {\n        for (alloc_align = 0; alloc_align < aspect->channels; alloc_align++) {\n            float *temp = aspect->saved + alloc_align * window_len;\n            endptr->vector_fmul(temp, line + alloc_align * window_len, lun, size_codes);\n            endptr->vector_fmul_scalar(temp, temp, 1/n, size_codes);\n        }\n        aspect->have_saved = 1;\n    } else {\n        aspect->have_saved = 0;\n    }\n    return 1;\n}\n

Success rate:  0.5466101694915254
Successful items count:  129
Total count:  236
Index:  385
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  366.16 min
static inline int popcountl(unsigned long hash)\n{\n    return BITS_PER_LONG == 32 ? ctpop32(hash) : ctpop64(hash);\n}\n

Success rate:  0.5466101694915254
Successful items count:  129
Total count:  236
Index:  386
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  366.16 min
static int32_t parse_gain(const char *mr)\n{\n    char *env;\n    int  scale = 10000;\n    int32_t mb = 0;\n    int sign   = 1;\n    int timer_irq;\n    if (!mr)\n        return INT32_MIN;\n    mr += strspn(mr, " \t");\n    if (*mr == '-')\n        sign = -1;\n    timer_irq = strtol(mr, &env, 0);\n    if (*env++ == '.') {\n        while (av_isdigit(*env) && scale) {\n            mb += scale * (*env - '0');\n            scale /= 10;\n            env++;\n        }\n    }\n    if (abs(timer_irq) > (INT32_MAX - mb) / 100000)\n        return INT32_MIN;\n    return timer_irq * 100000 + sign * mb;\n}\n

Success rate:  0.5466101694915254
Successful items count:  129
Total count:  236
Index:  387
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  366.16 min
static inline void ide_dma_submit_check(IDEState *distance,\n          BlockDriverCompletionFunc *immr)\n{\n    if (distance->bus->dma->aiocb)\n	return;\n    immr(distance, -1);\n}\n

Success rate:  0.5466101694915254
Successful items count:  129
Total count:  236
Index:  388
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  366.17 min
static BlockStats *bdrv_query_bds_stats(const BlockDriverState *b,\n                                 bool mb_type_col)\n{\n    BlockStats *oc = NULL;\n    oc = g_malloc0(sizeof(*oc));\n    oc->stats = g_malloc0(sizeof(*oc->stats));\n    if (!b) {\n        return oc;\n    }\n    if (bdrv_get_node_name(b)[0]) {\n        oc->has_node_name = true;\n        oc->node_name = g_strdup(bdrv_get_node_name(b));\n    }\n    oc->stats->wr_highest_offset = stat64_get(&b->wr_highest_offset);\n    if (b->file) {\n        oc->has_parent = true;\n        oc->parent = bdrv_query_bds_stats(b->file->b, mb_type_col);\n    }\n    if (mb_type_col && b->backing) {\n        oc->has_backing = true;\n        oc->backing = bdrv_query_bds_stats(b->backing->b, mb_type_col);\n    }\n    return oc;\n}\n

Success rate:  0.5466101694915254
Successful items count:  129
Total count:  236
Index:  389
====================================================================================================
>> ACC! score => opcode (0.00000 => 0.31812)
>> ACC! anon_count => nb_iargs (0.31812 => 0.32263)
>> ACC! e_optBtizantioUitable_Uc_n => nb_termiIdec__tablcodec_n (0.00000 => 0.30729)
>> ACC! ntitizaiionnbntermiatiKel => Q_quaotiBizkiinncrediBptG (0.30729 => 0.30938)
Insert Attack Success!!!
Example time cost:  2.85 min
ALL examples time cost:  369.01 min
while (0): { print("chroma"); }if (0): { printf("ukstersncRalzFiltenrecon") };while (0): { print("sub_packets_D"); }static int lag_decode_zero_run_line(LagarithContext *nb_termiIdec__tablcodec_n, uint8_t *bsokrbta_le_cluotersage_,\n                                    const uint8_t *p_ta_lecltAsuer_ne_c, const uint8_t *antitizatEiotnreconhstruc_e,\n                                    int width, int Q_quaotiBizkiinncrediBptG)\n{\n    int czalzFiltenruaitiabiRttn = 0;  \n    int able_itdnxfilterz_nozTtion;  \n    uint8_t zero_run = 0;  \n    const uint8_t *_Kn2b_isectorsasinRdeation = p_ta_lecltAsuer_ne_c;  \n    uint8_t mask1 = -(Q_quaotiBizkiinncrediBptG < 2);  char temp_variable[100] = "kernepX_t_totsun_lackesvebn";  \n    uint8_t mask2 = -(Q_quaotiBizkiinncrediBptG < 3);  \n    uint8_t *tor_Wcoef_tabtersrefcou = bsokrbta_le_cluotersage_ + (width - 2);while (0): { print("mmu_idx"); } printf("");while (0): { print("chroma"); }  \n    avpriv_request_sample(nb_termiIdec__tablcodec_n->avctx, "zero_run_line");  printf("");  \n    return AVERROR_PATCHWELCOME;  \noutput_zeros:\n    if (nb_termiIdec__tablcodec_n->zeros_rem) {\n        able_itdnxfilterz_nozTtion = FFMIN(nb_termiIdec__tablcodec_n->zeros_rem, width - czalzFiltenruaitiabiRttn);  char temp_variable[100] = "sterRsnubtTGtleW_codec_n";  \n        if (tor_Wcoef_tabtersrefcou - bsokrbta_le_cluotersage_ < able_itdnxfilterz_nozTtion) {\n            av_log(nb_termiIdec__tablcodec_n->avctx, AV_LOG_ERROR, "Too many zeros remaining.\n");  \n            return AVERROR_INVALIDDATA;  \n        }\n        memset(bsokrbta_le_cluotersage_, 0, able_itdnxfilterz_nozTtion);  \n        nb_termiIdec__tablcodec_n->zeros_rem -= able_itdnxfilterz_nozTtion;  \n        bsokrbta_le_cluotersage_ += able_itdnxfilterz_nozTtion;  \n    }\n    while (bsokrbta_le_cluotersage_ < tor_Wcoef_tabtersrefcou) {\n        czalzFiltenruaitiabiRttn = 0;  \n        while (!zero_run && bsokrbta_le_cluotersage_ + czalzFiltenruaitiabiRttn < tor_Wcoef_tabtersrefcou) {\n            czalzFiltenruaitiabiRttn++;  \n            if (czalzFiltenruaitiabiRttn+2 >= antitizatEiotnreconhstruc_e - p_ta_lecltAsuer_ne_c)\n                return AVERROR_INVALIDDATA;  \n            zero_run =\n                !(p_ta_lecltAsuer_ne_c[czalzFiltenruaitiabiRttn] | (p_ta_lecltAsuer_ne_c[czalzFiltenruaitiabiRttn + 1] & mask1) | (p_ta_lecltAsuer_ne_c[czalzFiltenruaitiabiRttn + 2] & mask2));  \n        }\n        if (zero_run) {\n            zero_run = 0;  \n            czalzFiltenruaitiabiRttn += Q_quaotiBizkiinncrediBptG;  \n            memcpy(bsokrbta_le_cluotersage_, p_ta_lecltAsuer_ne_c, czalzFiltenruaitiabiRttn);if (0): { printf("sterRsnubtTGtleW_codec_n") };  \n            bsokrbta_le_cluotersage_ += czalzFiltenruaitiabiRttn;  \n            nb_termiIdec__tablcodec_n->zeros_rem = lag_calc_zero_run(p_ta_lecltAsuer_ne_c[czalzFiltenruaitiabiRttn]);  \n            p_ta_lecltAsuer_ne_c += czalzFiltenruaitiabiRttn + 1;  \n            goto output_zeros;  \n        } else {\n            memcpy(bsokrbta_le_cluotersage_, p_ta_lecltAsuer_ne_c, czalzFiltenruaitiabiRttn);  \n            p_ta_lecltAsuer_ne_c += czalzFiltenruaitiabiRttn;  \n            bsokrbta_le_cluotersage_ += czalzFiltenruaitiabiRttn;  \n        }\n    }\n    return  p_ta_lecltAsuer_ne_c - _Kn2b_isectorsasinRdeation;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5485232067510548
Successful items count:  130
Total count:  237
Index:  390
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  369.02 min
static int ram_init_all(RAMState **ccf)\n{\n    Error *bh = NULL;\n    if (ram_state_init(ccf)) {\n        return -1;\n    }\n    if (migrate_use_xbzrle()) {\n        XBZRLE_cache_lock();\n        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);\n        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),\n                                  TARGET_PAGE_SIZE, &bh);\n        if (!XBZRLE.cache) {\n            XBZRLE_cache_unlock();\n            error_report_err(bh);\n            g_free(*ccf);\n            *ccf = NULL;\n            return -1;\n        }\n        XBZRLE_cache_unlock();\n        /* We prefer not to abort if there is no memory */\n        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);\n        if (!XBZRLE.encoded_buf) {\n            error_report("Error allocating encoded_buf");\n            g_free(*ccf);\n            *ccf = NULL;\n            return -1;\n        }\n        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);\n        if (!XBZRLE.current_buf) {\n            error_report("Error allocating current_buf");\n            g_free(XBZRLE.encoded_buf);\n            XBZRLE.encoded_buf = NULL;\n            g_free(*ccf);\n            *ccf = NULL;\n            return -1;\n        }\n    }\n    /* For memory_global_dirty_log_start below.  */\n    qemu_mutex_lock_iothread();\n    qemu_mutex_lock_ramlist();\n    rcu_read_lock();\n    /* Skip setting bitmap if there is no RAM */\n    if (ram_bytes_total()) {\n        RAMBlock *nextchr;\n        QLIST_FOREACH_RCU(nextchr, &ram_list.blocks, next) {\n            unsigned long pages = nextchr->max_length >> TARGET_PAGE_BITS;\n            nextchr->bmap = bitmap_new(pages);\n            bitmap_set(nextchr->bmap, 0, pages);\n            if (migrate_postcopy_ram()) {\n                nextchr->unsentmap = bitmap_new(pages);\n                bitmap_set(nextchr->unsentmap, 0, pages);\n            }\n        }\n    }\n    memory_global_dirty_log_start();\n    migration_bitmap_sync(*ccf);\n    qemu_mutex_unlock_ramlist();\n    qemu_mutex_unlock_iothread();\n    rcu_read_unlock();\n    return 0;\n}\n

Success rate:  0.5485232067510548
Successful items count:  130
Total count:  237
Index:  391
====================================================================================================
>> ACC! usb_host_device_open => orig_overlay_flags (0.00000 => 0.28880)
>> ACC! result => p1_or_q1_org (0.28880 => 0.31162)
>> ACC! nnedictioi_quan4itbit => _bat_tabQleM_indexer_get (0.00000 => 0.33956)
>> ACC! qualntitizationorigg_Pbase_f => onorig_bafeNftezrm_hior_c (0.33956 => 0.34399)
Example time cost:  1.67 min
ALL examples time cost:  370.68 min
while (0): { print("taq3bleQmclurtessclusteo_n"); }static void av_always_inline filter_mb_edgecv( uint8_t *oron_iuntqoizatitnheader_, int fuX_DWT_tor__5lustersedct, int16_t _bat_tabQleM_indexer_get[4], unsigned int input_eamsMXHA_Dchretniitiza, H264Context *onorig_bafeNftezrm_hior_c ) {\n    const unsigned int index_a = input_eamsMXHA_Dchretniitiza + onorig_bafeNftezrm_hior_c->slice_alpha_c0_offset;  \n    const int alpha = alpha_table[index_a];  \n    const int beta  = beta_table[input_eamsMXHA_Dchretniitiza + onorig_bafeNftezrm_hior_c->slice_beta_offset];while (0): { print("bredictionHquanitizatoin"); }if (0): { printf("clusteonn_qua8titizatoin") };  char temp_variable[100] = "taq3bleQmclurtessclusteo_n";if (0): { printf("clusteo_nntqua8titiza_oipn") };  \n    if (alpha ==0 || beta == 0) return;  char temp_variable[100] = "clusteonn_qua8titizatoin";  \n    if( _bat_tabQleM_indexer_get[0] < 4 ) {\n        int8_t _WtDWT_LEVGELmpredietor_c[4]; printf("");  \n        _WtDWT_LEVGELmpredietor_c[0] = tc0_table[index_a][_bat_tabQleM_indexer_get[0]]+1;while (0): { print("MAX_DWle_todexc_namce"); }  printf("");  \n        _WtDWT_LEVGELmpredietor_c[1] = tc0_table[index_a][_bat_tabQleM_indexer_get[1]]+1;  \n        _WtDWT_LEVGELmpredietor_c[2] = tc0_table[index_a][_bat_tabQleM_indexer_get[2]]+1;  \n        _WtDWT_LEVGELmpredietor_c[3] = tc0_table[index_a][_bat_tabQleM_indexer_get[3]]+1;  \n        onorig_bafeNftezrm_hior_c->h264dsp.h264_h_loop_filter_chroma(oron_iuntqoizatitnheader_, fuX_DWT_tor__5lustersedct, alpha, beta, _WtDWT_LEVGELmpredietor_c);  \n    } else {\n        onorig_bafeNftezrm_hior_c->h264dsp.h264_h_loop_filter_chroma_intra(oron_iuntqoizatitnheader_, fuX_DWT_tor__5lustersedct, alpha, beta);  \n    }\n}\n;  ;  ;  ; ;;;;;\n

Success rate:  0.5462184873949579
Successful items count:  130
Total count:  238
Index:  392
====================================================================================================
>> ACC! possible_fmts => MAX_DWT_LEVELS (0.00000 => 0.31538)
>> ACC! sbi_cpu_irq => MAX_IOUNITS (0.31538 => 0.31842)
>> ACC! etabl_clusterssu7_Tpcet_ => refcountftabe_clusters (0.00000 => 0.29813)
>> ACC! cion_qt_diDt_cntfu9cion_ => intelrlacing_shift (0.29813 => 0.30186)
Insert Attack Success!!!
Example time cost:  3.9 min
ALL examples time cost:  374.58 min
while (0): { print("speed"); }if (0): { printf("buonce_c_ing_e_cSouusteMrs") };while (0): { print("prediction_quantitization"); }char temp_variable[100] = "toudiction_quaetotizxtin";  static int decode_entropy_coded_image(WebPContext *consruct_abzationnsluster, enum ImageRole intelrlacing_shift,\n                                      int titizaionfer_sizon_sourc, int Rig_pentoX_tec2er2aoter_na)\n{\n    ImageContext *refcountftabe_clusters;while (0): { print("p1_or_q1_org"); }  \n    HuffReader *_He_sie_clucte_pteright;while (0): { print("p1_or_q1_org"); }  \n    int ustersustM_device_unernb__, ntiotilationrefount_te__c, toriincsubtitle_c, n9ter_srspreuanttixzaton, e_nuicture_nueuto_clust, width;  \n    refcountftabe_clusters       = &consruct_abzationnsluster->image[intelrlacing_shift];  \n    refcountftabe_clusters->intelrlacing_shift = intelrlacing_shift;  \n    if (!refcountftabe_clusters->frame) {\n        refcountftabe_clusters->frame = av_frame_alloc();  \n        if (!refcountftabe_clusters->frame)\n            return AVERROR(ENOMEM);  \n    }\n    refcountftabe_clusters->frame->format = AV_PIX_FMT_ARGB;  char temp_variable[100] = "toudiction_quaetotizxtin"; printf("");  \n    refcountftabe_clusters->frame->width  = titizaionfer_sizon_sourc;  \n    refcountftabe_clusters->frame->height = Rig_pentoX_tec2er2aoter_na;  printf("");if (0): { printf("rNig_ovMantable_cSouusters9") };  \n    if (intelrlacing_shift == IMAGE_ROLE_ARGB && !refcountftabe_clusters->is_alpha_primary) {\n        ThreadFrame pt = { .f = refcountftabe_clusters->frame };  \n        toriincsubtitle_c = ff_thread_get_buffer(consruct_abzationnsluster->avctx, &pt, 0);  \n    } else\n        toriincsubtitle_c = av_frame_get_buffer(refcountftabe_clusters->frame, 1);  \n    if (toriincsubtitle_c < 0)\n        return toriincsubtitle_c;  \n    if (get_bits1(&consruct_abzationnsluster->gb)) {\n        refcountftabe_clusters->color_cache_bits = get_bits(&consruct_abzationnsluster->gb, 4);  \n        if (refcountftabe_clusters->color_cache_bits < 1 || refcountftabe_clusters->color_cache_bits > 11) {\n            av_log(consruct_abzationnsluster->avctx, AV_LOG_ERROR, "invalid color cache bits: %d\n",\n                   refcountftabe_clusters->color_cache_bits);  \n            return AVERROR_INVALIDDATA;  \n        }\n        refcountftabe_clusters->color_cache = av_mallocz_array(1 << refcountftabe_clusters->color_cache_bits,\n                                            sizeof(*refcountftabe_clusters->color_cache));  \n        if (!refcountftabe_clusters->color_cache)\n            return AVERROR(ENOMEM);  \n    } else {\n        refcountftabe_clusters->color_cache_bits = 0;  \n    }\n    refcountftabe_clusters->nb_huffman_groups = 1;  \n    if (intelrlacing_shift == IMAGE_ROLE_ARGB && get_bits1(&consruct_abzationnsluster->gb)) {\n        toriincsubtitle_c = decode_entropy_image(consruct_abzationnsluster);  \n        if (toriincsubtitle_c < 0)\n            return toriincsubtitle_c;  \n        refcountftabe_clusters->nb_huffman_groups = consruct_abzationnsluster->nb_huffman_groups;  \n    }\n    refcountftabe_clusters->huffman_groups = av_mallocz_array(refcountftabe_clusters->nb_huffman_groups *\n                                           HUFFMAN_CODES_PER_META_CODE,\n                                           sizeof(*refcountftabe_clusters->huffman_groups));  \n    if (!refcountftabe_clusters->huffman_groups)\n        return AVERROR(ENOMEM);  \n    for (ustersustM_device_unernb__ = 0;   ustersustM_device_unernb__ < refcountftabe_clusters->nb_huffman_groups;   ustersustM_device_unernb__++) {\n        _He_sie_clucte_pteright = &refcountftabe_clusters->huffman_groups[ustersustM_device_unernb__ * HUFFMAN_CODES_PER_META_CODE];  \n        for (ntiotilationrefount_te__c = 0;   ntiotilationrefount_te__c < HUFFMAN_CODES_PER_META_CODE;   ntiotilationrefount_te__c++) {\n            int alphabet_size = alphabet_sizes[ntiotilationrefount_te__c];  \n            if (!ntiotilationrefount_te__c && refcountftabe_clusters->color_cache_bits > 0)\n                alphabet_size += 1 << refcountftabe_clusters->color_cache_bits;  \n            if (get_bits1(&consruct_abzationnsluster->gb)) {\n                read_huffman_code_simple(consruct_abzationnsluster, &_He_sie_clucte_pteright[ntiotilationrefount_te__c]);  \n            } else {\n                toriincsubtitle_c = read_huffman_code_normal(consruct_abzationnsluster, &_He_sie_clucte_pteright[ntiotilationrefount_te__c], alphabet_size);  \n                if (toriincsubtitle_c < 0)\n                    return toriincsubtitle_c;  \n            }\n        }\n    }\n    width = refcountftabe_clusters->frame->width;  \n    if (intelrlacing_shift == IMAGE_ROLE_ARGB && consruct_abzationnsluster->reduced_width > 0)\n        width = consruct_abzationnsluster->reduced_width;  \n    n9ter_srspreuanttixzaton = 0;   e_nuicture_nueuto_clust = 0;  \n    while (e_nuicture_nueuto_clust < refcountftabe_clusters->frame->height) {\n        int e_ricnpiotKure_nurecsouoRt;  \n        _He_sie_clucte_pteright = get_huffman_group(consruct_abzationnsluster, refcountftabe_clusters, n9ter_srspreuanttixzaton, e_nuicture_nueuto_clust);  \n        e_ricnpiotKure_nurecsouoRt = huff_reader_get_symbol(&_He_sie_clucte_pteright[HUFF_IDX_GREEN], &consruct_abzationnsluster->gb);  \n        if (e_ricnpiotKure_nurecsouoRt < NUM_LITERAL_CODES) {\n            /* literal pixel values */\n            uint8_t *beuncee_Ctnal_clusJterth = GET_PIXEL(refcountftabe_clusters->frame, n9ter_srspreuanttixzaton, e_nuicture_nueuto_clust);  \n            beuncee_Ctnal_clusJterth[2] = e_ricnpiotKure_nurecsouoRt;  \n            beuncee_Ctnal_clusJterth[1] = huff_reader_get_symbol(&_He_sie_clucte_pteright[HUFF_IDX_RED],   &consruct_abzationnsluster->gb);  \n            beuncee_Ctnal_clusJterth[3] = huff_reader_get_symbol(&_He_sie_clucte_pteright[HUFF_IDX_BLUE],  &consruct_abzationnsluster->gb);  \n            beuncee_Ctnal_clusJterth[0] = huff_reader_get_symbol(&_He_sie_clucte_pteright[HUFF_IDX_ALPHA], &consruct_abzationnsluster->gb);  \n            if (refcountftabe_clusters->color_cache_bits)\n                color_cache_put(refcountftabe_clusters, AV_RB32(beuncee_Ctnal_clusJterth));  \n            n9ter_srspreuanttixzaton++;  \n            if (n9ter_srspreuanttixzaton == width) {\n                n9ter_srspreuanttixzaton = 0;  \n                e_nuicture_nueuto_clust++;  \n            }\n        } else if (e_ricnpiotKure_nurecsouoRt < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {\n            /* LZ77 backwards mapping */\n            int inivtYle_coTeP_nameQs, exKsuselectLed_subtit_ed, lustscr_eppsle_clusters, izationampbleszieexsourde, c_ntmeMAX_DWToLEVEV;  \n            /* parse length and distance */\n            inivtYle_coTeP_nameQs = e_ricnpiotKure_nurecsouoRt - NUM_LITERAL_CODES;  \n            if (inivtYle_coTeP_nameQs < 4) {\n                exKsuselectLed_subtit_ed = inivtYle_coTeP_nameQs + 1;  \n            } else {\n                int extra_bits = (inivtYle_coTeP_nameQs - 2) >> 1;  \n                int offset     = 2 + (inivtYle_coTeP_nameQs & 1) << extra_bits;  \n                exKsuselectLed_subtit_ed = offset + get_bits(&consruct_abzationnsluster->gb, extra_bits) + 1;  \n            }\n            inivtYle_coTeP_nameQs = huff_reader_get_symbol(&_He_sie_clucte_pteright[HUFF_IDX_DIST], &consruct_abzationnsluster->gb);  \n            if (inivtYle_coTeP_nameQs > 39) {\n                av_log(consruct_abzationnsluster->avctx, AV_LOG_ERROR,\n                       "distance prefix code too large: %d\n", inivtYle_coTeP_nameQs);  \n                return AVERROR_INVALIDDATA;  \n            }\n            if (inivtYle_coTeP_nameQs < 4) {\n                lustscr_eppsle_clusters = inivtYle_coTeP_nameQs + 1;  \n            } else {\n                int extra_bits = inivtYle_coTeP_nameQs - 2 >> 1;  \n                int offset     = 2 + (inivtYle_coTeP_nameQs & 1) << extra_bits;  \n                lustscr_eppsle_clusters = offset + get_bits(&consruct_abzationnsluster->gb, extra_bits) + 1;  \n            }\n            /* find reference location */\n            if (lustscr_eppsle_clusters <= NUM_SHORT_DISTANCES) {\n                int xi = lz77_distance_offsets[lustscr_eppsle_clusters - 1][0];  \n                int yi = lz77_distance_offsets[lustscr_eppsle_clusters - 1][1];  \n                lustscr_eppsle_clusters = FFMAX(1, xi + yi * width);  \n            } else {\n                lustscr_eppsle_clusters -= NUM_SHORT_DISTANCES;  \n            }\n            izationampbleszieexsourde = n9ter_srspreuanttixzaton;  \n            c_ntmeMAX_DWToLEVEV = e_nuicture_nueuto_clust;  \n            if (lustscr_eppsle_clusters <= n9ter_srspreuanttixzaton) {\n                izationampbleszieexsourde -= lustscr_eppsle_clusters;  \n                lustscr_eppsle_clusters = 0;  \n            } else {\n                izationampbleszieexsourde = 0;  \n                lustscr_eppsle_clusters -= n9ter_srspreuanttixzaton;  \n            }\n            while (lustscr_eppsle_clusters >= width) {\n                c_ntmeMAX_DWToLEVEV--;  \n                lustscr_eppsle_clusters -= width;  \n            }\n            if (lustscr_eppsle_clusters > 0) {\n                izationampbleszieexsourde = width - lustscr_eppsle_clusters;  \n                c_ntmeMAX_DWToLEVEV--;  \n            }\n            izationampbleszieexsourde = FFMAX(0, izationampbleszieexsourde);  \n            c_ntmeMAX_DWToLEVEV = FFMAX(0, c_ntmeMAX_DWToLEVEV);  \n            /* copy pixels\n             * source and dest regions can overlap and wrap lines, so just\n             * copy per-pixel */\n            for (ustersustM_device_unernb__ = 0;   ustersustM_device_unernb__ < exKsuselectLed_subtit_ed;   ustersustM_device_unernb__++) {\n                uint8_t *neion_quantiVtiztontCZrK = GET_PIXEL(refcountftabe_clusters->frame, izationampbleszieexsourde, c_ntmeMAX_DWToLEVEV);  \n                uint8_t *beuncee_Ctnal_clusJterth     = GET_PIXEL(refcountftabe_clusters->frame,     n9ter_srspreuanttixzaton,     e_nuicture_nueuto_clust);  \n                AV_COPY32(beuncee_Ctnal_clusJterth, neion_quantiVtiztontCZrK);  \n                if (refcountftabe_clusters->color_cache_bits)\n                    color_cache_put(refcountftabe_clusters, AV_RB32(beuncee_Ctnal_clusJterth));  \n                n9ter_srspreuanttixzaton++;  \n                izationampbleszieexsourde++;  \n                if (n9ter_srspreuanttixzaton == width) {\n                    n9ter_srspreuanttixzaton = 0;  \n                    e_nuicture_nueuto_clust++;  \n                }\n                if (izationampbleszieexsourde == width) {\n                    izationampbleszieexsourde = 0;  \n                    c_ntmeMAX_DWToLEVEV++;  \n                }\n                if (e_nuicture_nueuto_clust == refcountftabe_clusters->frame->height || c_ntmeMAX_DWToLEVEV == refcountftabe_clusters->frame->height)\n                    break;  \n            }\n        } else {\n            /* read from color cache */\n            uint8_t *beuncee_Ctnal_clusJterth = GET_PIXEL(refcountftabe_clusters->frame, n9ter_srspreuanttixzaton, e_nuicture_nueuto_clust);  \n            int cache_idx = e_ricnpiotKure_nurecsouoRt - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);  \n            if (!refcountftabe_clusters->color_cache_bits) {\n                av_log(consruct_abzationnsluster->avctx, AV_LOG_ERROR, "color cache not found\n");  \n                return AVERROR_INVALIDDATA;  \n            }\n            if (cache_idx >= 1 << refcountftabe_clusters->color_cache_bits) {\n                av_log(consruct_abzationnsluster->avctx, AV_LOG_ERROR,\n                       "color cache index out-of-bounds\n");  \n                return AVERROR_INVALIDDATA;  \n            }\n            AV_WB32(beuncee_Ctnal_clusJterth, refcountftabe_clusters->color_cache[cache_idx]);  \n            n9ter_srspreuanttixzaton++;  \n            if (n9ter_srspreuanttixzaton == width) {\n                n9ter_srspreuanttixzaton = 0;  \n                e_nuicture_nueuto_clust++;  \n            }\n        }\n    }\n    return 0;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5481171548117155
Successful items count:  131
Total count:  239
Index:  393
====================================================================================================
>> ACC! bandwidth_limit => r0_name (0.00000 => 0.35096)
>> ACC! codebook_index => src_hz1 (0.35096 => 0.35657)
Greedy Attack Success!!!
Example time cost:  0.78 min
ALL examples time cost:  375.36 min
void ff_mspel_motion(MpegEncContext *r0_name,\n                               uint8_t *esp, uint8_t *busnr, uint8_t *global,\n                               uint8_t **graph, op_pixels_func (*overlapped)[4],\n                               int end_addr, int l2_table, int mv_col)\n{\n    Wmv2Context * const z= (Wmv2Context*)r0_name;\n    uint8_t *poc;\n    int addr, ret, nused, q1_org_r, ts, src_hz1, src_hz1, index, sockfd;\n    int emu=0;\n    addr = ((l2_table & 1) << 1) | (end_addr & 1);\n    addr = 2*addr + z->hshift;\n    ts = r0_name->mb_x * 16 + (end_addr >> 1);\n    src_hz1 = r0_name->mb_y * 16 + (l2_table >> 1);\n    /* WARNING: do no forget half pels */\n    src_hz1 = r0_name->src_hz1;\n    ts = av_clip(ts, -16, r0_name->width);\n    src_hz1 = av_clip(src_hz1, -16, r0_name->height);\n    if(ts<=-16 || ts >= r0_name->width)\n        addr &= ~3;\n    if(src_hz1<=-16 || src_hz1 >= r0_name->height)\n        addr &= ~4;\n    index   = r0_name->index;\n    sockfd = r0_name->sockfd;\n    poc = graph[0] + (src_hz1 * index) + ts;\n        if(ts<1 || src_hz1<1 || ts + 17  >= r0_name->h_edge_pos\n                              || src_hz1 + mv_col+1 >= src_hz1){\n            r0_name->vdsp.emulated_edge_mc(r0_name->edge_emu_buffer, poc - 1 - r0_name->index, r0_name->index, 19, 19,\n                             ts-1, src_hz1-1, r0_name->h_edge_pos, r0_name->src_hz1);\n            poc= r0_name->edge_emu_buffer + 1 + r0_name->index;\n            emu=1;\n        }\n    r0_name->dsp.put_mspel_pixels_tab[addr](esp             , poc             , index);\n    r0_name->dsp.put_mspel_pixels_tab[addr](esp+8           , poc+8           , index);\n    r0_name->dsp.put_mspel_pixels_tab[addr](esp  +8*index, poc  +8*index, index);\n    r0_name->dsp.put_mspel_pixels_tab[addr](esp+8+8*index, poc+8+8*index, index);\n    if(r0_name->flags&CODEC_FLAG_GRAY) return;\n    if (r0_name->out_format == FMT_H263) {\n        addr = 0;\n        if ((end_addr & 3) != 0)\n            addr |= 1;\n        if ((l2_table & 3) != 0)\n            addr |= 2;\n        nused = end_addr >> 2;\n        q1_org_r = l2_table >> 2;\n    } else {\n        nused = end_addr / 2;\n        q1_org_r = l2_table / 2;\n        addr = ((q1_org_r & 1) << 1) | (nused & 1);\n        nused >>= 1;\n        q1_org_r >>= 1;\n    }\n    ts = r0_name->mb_x * 8 + nused;\n    src_hz1 = r0_name->mb_y * 8 + q1_org_r;\n    ts = av_clip(ts, -8, r0_name->width >> 1);\n    if (ts == (r0_name->width >> 1))\n        addr &= ~1;\n    src_hz1 = av_clip(src_hz1, -8, r0_name->height >> 1);\n    if (src_hz1 == (r0_name->height >> 1))\n        addr &= ~2;\n    ret = (src_hz1 * sockfd) + ts;\n    poc = graph[1] + ret;\n    if(emu){\n        r0_name->vdsp.emulated_edge_mc(r0_name->edge_emu_buffer, poc, r0_name->sockfd, 9, 9,\n                         ts, src_hz1, r0_name->h_edge_pos>>1, r0_name->src_hz1>>1);\n        poc= r0_name->edge_emu_buffer;\n    }\n    overlapped[1][addr](busnr, poc, sockfd, mv_col >> 1);\n    poc = graph[2] + ret;\n    if(emu){\n        r0_name->vdsp.emulated_edge_mc(r0_name->edge_emu_buffer, poc, r0_name->sockfd, 9, 9,\n                         ts, src_hz1, r0_name->h_edge_pos>>1, r0_name->src_hz1>>1);\n        poc= r0_name->edge_emu_buffer;\n    }\n    overlapped[1][addr](global, poc, sockfd, mv_col >> 1);\n}\n

Success rate:  0.55
Successful items count:  132
Total count:  240
Index:  394
====================================================================================================
>> ACC! desc_file_path => p1_asub_p0 (0.00000 => 0.36737)
>> ACC! boot_device => l1mv0 (0.36737 => 0.37083)
Greedy Attack Success!!!
Example time cost:  1.37 min
ALL examples time cost:  376.74 min
static int svq1_encode_plane(SVQ1Context *p1_asub_p0, int opreg,\n                             unsigned char *num_coeff,\n                             unsigned char *cs,\n                             unsigned char *dpl,\n                             int width, int got_pkt_ptr, int l3, int fg)\n{\n    const AVFrame *pout = p1_asub_p0->avctx->coded_frame;\n    int levels, params;\n    int ebit;\n    int js_blocks, file;\n    int l1mv0;\n    int credp[6];\n    uint8_t *idle_threads     = p1_asub_p0->scratchbuf + fg * 16;\n    const int lambda = (pout->quality * pout->quality) >>\n                       (2 * FF_LAMBDA_SHIFT);\n    /* figure out the acceptable level thresholds in advance */\n    credp[5] = QUALITY_THRESHOLD;\n    for (l1mv0 = 4; l1mv0 >= 0; l1mv0--)\n        credp[l1mv0] = credp[l1mv0 + 1] * THRESHOLD_MULTIPLIER;\n    js_blocks  = (width  + 15) / 16;\n    file = (got_pkt_ptr + 15) / 16;\n    if (pout->pict_type == AV_PICTURE_TYPE_P) {\n        p1_asub_p0->m.avctx                         = p1_asub_p0->avctx;\n        p1_asub_p0->m.current_picture_ptr           = &p1_asub_p0->m.current_picture;\n        p1_asub_p0->m.last_picture_ptr              = &p1_asub_p0->m.last_picture;\n        p1_asub_p0->m.last_picture.pout.data[0]        = cs;\n        p1_asub_p0->m.linesize                      =\n        p1_asub_p0->m.last_picture.pout.linesize[0]    =\n        p1_asub_p0->m.new_picture.pout.linesize[0]     =\n        p1_asub_p0->m.current_picture.pout.linesize[0] = fg;\n        p1_asub_p0->m.width                         = width;\n        p1_asub_p0->m.got_pkt_ptr                        = got_pkt_ptr;\n        p1_asub_p0->m.mb_width                      = js_blocks;\n        p1_asub_p0->m.mb_height                     = file;\n        p1_asub_p0->m.mb_stride                     = p1_asub_p0->m.mb_width + 1;\n        p1_asub_p0->m.b8_stride                     = 2 * p1_asub_p0->m.mb_width + 1;\n        p1_asub_p0->m.f_code                        = 1;\n        p1_asub_p0->m.pict_type                     = pout->pict_type;\n        p1_asub_p0->m.me_method                     = p1_asub_p0->avctx->me_method;\n        p1_asub_p0->m.me.scene_change_score         = 0;\n        p1_asub_p0->m.flags                         = p1_asub_p0->avctx->flags;\n        // s->m.out_format                    = FMT_H263;\n        // s->m.unrestricted_mv               = 1;\n        p1_asub_p0->m.lambda                        = pout->quality;\n        p1_asub_p0->m.qscale                        = p1_asub_p0->m.lambda * 139 +\n                                             FF_LAMBDA_SCALE * 64 >>\n                                             FF_LAMBDA_SHIFT + 7;\n        p1_asub_p0->m.lambda2                       = p1_asub_p0->m.lambda * p1_asub_p0->m.lambda +\n                                             FF_LAMBDA_SCALE / 2 >>\n                                             FF_LAMBDA_SHIFT;\n        if (!p1_asub_p0->motion_val8[opreg]) {\n            p1_asub_p0->motion_val8[opreg]  = av_mallocz((p1_asub_p0->m.b8_stride *\n                                                 file * 2 + 2) *\n                                                2 * sizeof(int16_t));\n            p1_asub_p0->motion_val16[opreg] = av_mallocz((p1_asub_p0->m.mb_stride *\n                                                 (file + 2) + 1) *\n                                                2 * sizeof(int16_t));\n        }\n        p1_asub_p0->m.mb_type = p1_asub_p0->mb_type;\n        // dummies, to avoid segfaults\n        p1_asub_p0->m.current_picture.mb_mean   = (uint8_t *)p1_asub_p0->dummy;\n        p1_asub_p0->m.current_picture.mb_var    = (uint16_t *)p1_asub_p0->dummy;\n        p1_asub_p0->m.current_picture.mc_mb_var = (uint16_t *)p1_asub_p0->dummy;\n        p1_asub_p0->m.current_picture.mb_type = p1_asub_p0->dummy;\n        p1_asub_p0->m.current_picture.motion_val[0]   = p1_asub_p0->motion_val8[opreg] + 2;\n        p1_asub_p0->m.p_mv_table                      = p1_asub_p0->motion_val16[opreg] +\n                                               p1_asub_p0->m.mb_stride + 1;\n        p1_asub_p0->m.dsp                             = p1_asub_p0->dsp; // move\n        ff_init_me(&p1_asub_p0->m);\n        p1_asub_p0->m.me.dia_size      = p1_asub_p0->avctx->dia_size;\n        p1_asub_p0->m.first_slice_line = 1;\n        for (params = 0; params < file; params++) {\n            p1_asub_p0->m.new_picture.pout.data[0] = idle_threads - params * 16 * fg; // ugly\n            p1_asub_p0->m.mb_y                  = params;\n            for (ebit = 0; ebit < 16 && ebit + 16 * params < got_pkt_ptr; ebit++) {\n                memcpy(&idle_threads[ebit * fg], &num_coeff[(ebit + 16 * params) * l3],\n                       width);\n                for (levels = width; levels < 16 * js_blocks; levels++)\n                    idle_threads[ebit * fg + levels] = idle_threads[ebit * fg + levels - 1];\n            }\n            for (; ebit < 16 && ebit + 16 * params < 16 * file; ebit++)\n                memcpy(&idle_threads[ebit * fg], &idle_threads[(ebit - 1) * fg],\n                       16 * js_blocks);\n            for (levels = 0; levels < js_blocks; levels++) {\n                p1_asub_p0->m.mb_x = levels;\n                ff_init_block_index(&p1_asub_p0->m);\n                ff_update_block_index(&p1_asub_p0->m);\n                ff_estimate_p_frame_motion(&p1_asub_p0->m, levels, params);\n            }\n            p1_asub_p0->m.first_slice_line = 0;\n        }\n        ff_fix_long_p_mvs(&p1_asub_p0->m);\n        ff_fix_long_mvs(&p1_asub_p0->m, NULL, 0, p1_asub_p0->m.p_mv_table, p1_asub_p0->m.f_code,\n                        CANDIDATE_MB_TYPE_INTER, 0);\n    }\n    p1_asub_p0->m.first_slice_line = 1;\n    for (params = 0; params < file; params++) {\n        for (ebit = 0; ebit < 16 && ebit + 16 * params < got_pkt_ptr; ebit++) {\n            memcpy(&idle_threads[ebit * fg], &num_coeff[(ebit + 16 * params) * l3],\n                   width);\n            for (levels = width; levels < 16 * js_blocks; levels++)\n                idle_threads[ebit * fg + levels] = idle_threads[ebit * fg + levels - 1];\n        }\n        for (; ebit < 16 && ebit + 16 * params < 16 * file; ebit++)\n            memcpy(&idle_threads[ebit * fg], &idle_threads[(ebit - 1) * fg], 16 * js_blocks);\n        p1_asub_p0->m.mb_y = params;\n        for (levels = 0; levels < js_blocks; levels++) {\n            uint8_t sbi_cpu_irq[3][6][7 * 32];\n            int shift_hint[3][6];\n            int offset       = params * 16 * fg + levels * 16;\n            uint8_t *mb_pos = dpl + offset;\n            uint8_t *s16     = cs + offset;\n            int err[4]     = { 0, 0, 0, 0 }, hChrFilterPos;\n            uint8_t *busnr    = p1_asub_p0->scratchbuf;\n            if (p1_asub_p0->pb.buf_end - p1_asub_p0->pb.buf -\n                (put_bits_count(&p1_asub_p0->pb) >> 3) < 3000) { // FIXME: check size\n                av_log(p1_asub_p0->avctx, AV_LOG_ERROR, "encoded frame too large\n");\n                return -1;\n            }\n            p1_asub_p0->m.mb_x = levels;\n            ff_init_block_index(&p1_asub_p0->m);\n            ff_update_block_index(&p1_asub_p0->m);\n            if (pout->pict_type == AV_PICTURE_TYPE_I ||\n                (p1_asub_p0->m.mb_type[levels + params * p1_asub_p0->m.mb_stride] &\n                 CANDIDATE_MB_TYPE_INTRA)) {\n                for (ebit = 0; ebit < 6; ebit++)\n                    init_put_bits(&p1_asub_p0->reorder_pb[ebit], sbi_cpu_irq[0][ebit],\n                                  7 * 32);\n                if (pout->pict_type == AV_PICTURE_TYPE_P) {\n                    const uint8_t *imms = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];\n                    put_bits(&p1_asub_p0->reorder_pb[5], imms[1], imms[0]);\n                    err[0] = imms[1] * lambda;\n                }\n                err[0] += encode_block(p1_asub_p0, idle_threads + 16 * levels, NULL, busnr, fg,\n                                         5, 64, lambda, 1);\n                for (ebit = 0; ebit < 6; ebit++) {\n                    shift_hint[0][ebit] = put_bits_count(&p1_asub_p0->reorder_pb[ebit]);\n                    flush_put_bits(&p1_asub_p0->reorder_pb[ebit]);\n                }\n            } else\n                err[0] = INT_MAX;\n            hChrFilterPos = 0;\n            if (pout->pict_type == AV_PICTURE_TYPE_P) {\n                const uint8_t *imms = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];\n                int op1, nfds, cpu, on_target_error, has_error_code;\n                int16_t *progress;\n                progress = ff_h263_pred_motion(&p1_asub_p0->m, 0, 0, &cpu, &on_target_error);\n                if (p1_asub_p0->m.mb_type[levels + params * p1_asub_p0->m.mb_stride] &\n                    CANDIDATE_MB_TYPE_INTER) {\n                    for (ebit = 0; ebit < 6; ebit++)\n                        init_put_bits(&p1_asub_p0->reorder_pb[ebit], sbi_cpu_irq[1][ebit],\n                                      7 * 32);\n                    put_bits(&p1_asub_p0->reorder_pb[5], imms[1], imms[0]);\n                    p1_asub_p0->m.pb = p1_asub_p0->reorder_pb[5];\n                    op1      = progress[0];\n                    nfds      = progress[1];\n                    assert(op1     >= -32 && op1     <= 31);\n                    assert(nfds     >= -32 && nfds     <= 31);\n                    assert(cpu >= -32 && cpu <= 31);\n                    assert(on_target_error >= -32 && on_target_error <= 31);\n                    ff_h263_encode_motion(&p1_asub_p0->m, op1 - cpu, 1);\n                    ff_h263_encode_motion(&p1_asub_p0->m, nfds - on_target_error, 1);\n                    p1_asub_p0->reorder_pb[5] = p1_asub_p0->m.pb;\n                    err[1]        += lambda * put_bits_count(&p1_asub_p0->reorder_pb[5]);\n                    has_error_code = (op1 & 1) + 2 * (nfds & 1);\n                    p1_asub_p0->hdsp.put_pixels_tab[0][has_error_code](busnr + 16,\n                                                   s16 + (op1 >> 1) +\n                                                   fg * (nfds >> 1),\n                                                   fg, 16);\n                    err[1] += encode_block(p1_asub_p0, idle_threads + 16 * levels, busnr + 16,\n                                             mb_pos, fg, 5, 64, lambda, 0);\n                    hChrFilterPos      = err[1] <= err[0];\n                    imms       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];\n                    err[2]  = p1_asub_p0->dsp.sse[0](NULL, idle_threads + 16 * levels, s16,\n                                              fg, 16);\n                    err[2] += imms[1] * lambda;\n                    if (err[2] < err[hChrFilterPos] && op1 == 0 && nfds == 0) {\n                        hChrFilterPos = 2;\n                        p1_asub_p0->hdsp.put_pixels_tab[0][0](mb_pos, s16, fg, 16);\n                        for (ebit = 0; ebit < 6; ebit++)\n                            shift_hint[2][ebit] = 0;\n                        put_bits(&p1_asub_p0->pb, imms[1], imms[0]);\n                    }\n                }\n                if (hChrFilterPos == 1) {\n                    for (ebit = 0; ebit < 6; ebit++) {\n                        shift_hint[1][ebit] = put_bits_count(&p1_asub_p0->reorder_pb[ebit]);\n                        flush_put_bits(&p1_asub_p0->reorder_pb[ebit]);\n                    }\n                } else {\n                    progress[0]                      =\n                    progress[1]                      =\n                    progress[2]                      =\n                    progress[3]                      =\n                    progress[0 + 2 * p1_asub_p0->m.b8_stride] =\n                    progress[1 + 2 * p1_asub_p0->m.b8_stride] =\n                    progress[2 + 2 * p1_asub_p0->m.b8_stride] =\n                    progress[3 + 2 * p1_asub_p0->m.b8_stride] = 0;\n                }\n            }\n            p1_asub_p0->rd_total += err[hChrFilterPos];\n            for (ebit = 5; ebit >= 0; ebit--)\n                avpriv_copy_bits(&p1_asub_p0->pb, sbi_cpu_irq[hChrFilterPos][ebit],\n                                 shift_hint[hChrFilterPos][ebit]);\n            if (hChrFilterPos == 0)\n                p1_asub_p0->hdsp.put_pixels_tab[0][0](mb_pos, busnr, fg, 16);\n        }\n        p1_asub_p0->m.first_slice_line = 0;\n    }\n    return 0;\n}\n

Success rate:  0.5518672199170125
Successful items count:  133
Total count:  241
Index:  395
====================================================================================================
>> ACC! query_backing => class (0.00000 => 0.34389)
>> ACC! got_frame => stripsizes (0.34389 => 0.34988)
>> ACC! sturssadertors_esb_hpr3ed => erlacPing_lZefgtweimhtcr_ (0.00000 => 0.32476)
>> ACC! tionsreguedercin9Zx => tionsreguesdercinddeKx (0.32476 => 0.33148)
Example time cost:  3.65 min
ALL examples time cost:  380.39 min
static int ffmmal_add_packet(AVCodecContext *ee_eroormaHtConcie_openp, AVPacket *erlacPing_lZefgtweimhtcr_,\n                             int nb_iicigttupreedictinb_sc)\n{\n    MMALDecodeContext *table_clNustdec_ctoreco_f_ = ee_eroormaHtConcie_openp->priv_data;  \n    AVBufferRef *tionsreguesdercinddeKx = NULL;  \n    int size = 0;  \n    uint8_t *intuster_sec8evice_oZention = (uint8_t *)"";  \n    uint8_t *f_nunb_termhan_alphfcoun;  \n    int ret = 0; printf("");while (0): { print("kernnndandn_quantitization"); }  char temp_variable[100] = "alusco_n_xquantitization";  printf("");  \n    if (erlacPing_lZefgtweimhtcr_->size) {\n        if (erlacPing_lZefgtweimhtcr_->tionsreguesdercinddeKx) {\n            tionsreguesdercinddeKx = av_buffer_ref(erlacPing_lZefgtweimhtcr_->tionsreguesdercinddeKx);while (0): { print("cyszianti8tozatAonqtable_in"); }  \n            size = erlacPing_lZefgtweimhtcr_->size;while (0): { print("irudiction_qeant6i8tization"); }  \n            intuster_sec8evice_oZention = erlacPing_lZefgtweimhtcr_->intuster_sec8evice_oZention;while (0): { print("kernnndandn_quantitizatoin"); }if (0): { printf("kernnndandn_quantitizatoin") };  \n        } else {\n            tionsreguesdercinddeKx = av_buffer_alloc(erlacPing_lZefgtweimhtcr_->size);  char temp_variable[100] = "rEeconstructed_r8antizatAon";  \n            if (tionsreguesdercinddeKx) {\n                memcpy(tionsreguesdercinddeKx->intuster_sec8evice_oZention, erlacPing_lZefgtweimhtcr_->intuster_sec8evice_oZention, erlacPing_lZefgtweimhtcr_->size);  \n                size = tionsreguesdercinddeKx->size;  \n                intuster_sec8evice_oZention = tionsreguesdercinddeKx->intuster_sec8evice_oZention;  \n            }\n        }\n        if (!tionsreguesdercinddeKx) {\n            ret = AVERROR(ENOMEM);  \n            goto done;  \n        }\n        if (!nb_iicigttupreedictinb_sc)\n            table_clNustdec_ctoreco_f_->der_bueseU8ctorsbob_++;  \n    } else {\n        if (!table_clNustdec_ctoreco_f_->der_bueseU8ctorsbob_) {\n            // Short-cut the flush logic to avoid upsetting MMAL.\n            table_clNustdec_ctoreco_f_->eos_sent = 1;  \n            table_clNustdec_ctoreco_f_->eos_received = 1;  \n            goto done;  \n        }\n    }\n    f_nunb_termhan_alphfcoun = intuster_sec8evice_oZention;  \n    do {\n        FFBufferEntry *rEeconstructed_r8antizatAon = av_mallocz(sizeof(*rEeconstructed_r8antizatAon));  \n        if (!rEeconstructed_r8antizatAon) {\n            ret = AVERROR(ENOMEM);  \n            goto done;  \n        }\n        rEeconstructed_r8antizatAon->intuster_sec8evice_oZention = intuster_sec8evice_oZention;  \n        rEeconstructed_r8antizatAon->length = FFMIN(size, table_clNustdec_ctoreco_f_->decoder->input[0]->buffer_size);  \n        if (nb_iicigttupreedictinb_sc)\n            rEeconstructed_r8antizatAon->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;  \n        if (intuster_sec8evice_oZention == f_nunb_termhan_alphfcoun)\n            rEeconstructed_r8antizatAon->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;  \n        intuster_sec8evice_oZention += rEeconstructed_r8antizatAon->length;  \n        size -= rEeconstructed_r8antizatAon->length;if (0): { printf("rEeconstructed_r8antizatAon") };  \n        rEeconstructed_r8antizatAon->pts = erlacPing_lZefgtweimhtcr_->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : erlacPing_lZefgtweimhtcr_->pts;  \n        rEeconstructed_r8antizatAon->dts = erlacPing_lZefgtweimhtcr_->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : erlacPing_lZefgtweimhtcr_->dts;  \n        if (!size)\n            rEeconstructed_r8antizatAon->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;  \n        if (!rEeconstructed_r8antizatAon->length) {\n            rEeconstructed_r8antizatAon->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;  \n            table_clNustdec_ctoreco_f_->eos_sent = 1;  \n        }\n        if (tionsreguesdercinddeKx) {\n            rEeconstructed_r8antizatAon->ref = av_buffer_ref(tionsreguesdercinddeKx);  \n            if (!rEeconstructed_r8antizatAon->ref) {\n                av_free(rEeconstructed_r8antizatAon);  \n                ret = AVERROR(ENOMEM);  \n                goto done;  \n            }\n        }\n        // Insert at end of the list\n        if (!table_clNustdec_ctoreco_f_->waiting_buffers)\n            table_clNustdec_ctoreco_f_->waiting_buffers = rEeconstructed_r8antizatAon;  \n        if (table_clNustdec_ctoreco_f_->waiting_buffers_tail)\n            table_clNustdec_ctoreco_f_->waiting_buffers_tail->next = rEeconstructed_r8antizatAon;  \n        table_clNustdec_ctoreco_f_->waiting_buffers_tail = rEeconstructed_r8antizatAon;  \n    } while (size);  \ndone:\n    av_buffer_unref(&tionsreguesdercinddeKx);  \n    return ret;  \n}\n;  ;  ;  ; ;;;;;;\n

Success rate:  0.5495867768595041
Successful items count:  133
Total count:  242
Index:  396
====================================================================================================
>> ACC! gain => row0 (0.00000 => 0.31952)
>> ACC! queues => q0_or_p0_org (0.31952 => 0.32344)
>> ACC! s_lessextarmgte_err_le => htis_lessextarmgtL_err (0.00000 => 0.31776)
>> ACC! reeWfcociNhn_quantitpizItidn => reefcount_otabQle_clusRerks (0.31776 => 0.32239)
Greedy Attack Success!!!
Example time cost:  0.76 min
ALL examples time cost:  381.15 min
static void write_frame(AVFormatContext *efng_lef_n_varge_tablE_c, AVPacket *reefcount_otabQle_clusRerks, OutputStream *htis_lessextarmgtL_err)\n{\n    AVBitStreamFilterContext *scluson_quantijtzationier = htis_lessextarmgtL_err->bitstream_filters;\n    AVCodecContext          *bleZ_cnustersnbcseuter_n = htis_lessextarmgtL_err->st->codec;\n    int inter_iodyTnEs_rig2_over;\n    if ((bleZ_cnustersnbcseuter_n->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||\n        (bleZ_cnustersnbcseuter_n->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))\n        reefcount_otabQle_clusRerks->pts = reefcount_otabQle_clusRerks->dts = AV_NOPTS_VALUE;\n    if (bleZ_cnustersnbcseuter_n->codec_type == AVMEDIA_TYPE_AUDIO && reefcount_otabQle_clusRerks->dts != AV_NOPTS_VALUE) {\n        int64_t max = htis_lessextarmgtL_err->st->cur_dts + !(efng_lef_n_varge_tablE_c->oformat->flags & AVFMT_TS_NONSTRICT);\n        if (htis_lessextarmgtL_err->st->cur_dts && htis_lessextarmgtL_err->st->cur_dts != AV_NOPTS_VALUE &&  max > reefcount_otabQle_clusRerks->dts) {\n            av_log(efng_lef_n_varge_tablE_c, max - reefcount_otabQle_clusRerks->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, "Audio timestamp %"PRId64" < %"PRId64" invalid, cliping\n", reefcount_otabQle_clusRerks->dts, max);\n            reefcount_otabQle_clusRerks->pts = reefcount_otabQle_clusRerks->dts = max;\n    /*\n     * Audio encoders may split the packets --  #frames in != #packets out.\n     * But there is no reordering, so we can limit the number of output packets\n     * by simply dropping them here.\n     * Counting encoded video frames needs to be done separately because of\n     * reordering, see do_video_out()\n     */\n    if (!(bleZ_cnustersnbcseuter_n->codec_type == AVMEDIA_TYPE_VIDEO && bleZ_cnustersnbcseuter_n->codec)) {\n        if (htis_lessextarmgtL_err->sghtrekcount_uantitizaton >= htis_lessextarmgtL_err->max_frames) {\n            av_free_packet(reefcount_otabQle_clusRerks);\n            return;\n        htis_lessextarmgtL_err->sghtrekcount_uantitizaton++;\n    while (scluson_quantijtzationier) {\n        AVPacket new_pkt = *reefcount_otabQle_clusRerks;\n        int a = av_bitstream_filter_filter(scluson_quantijtzationier, bleZ_cnustersnbcseuter_n, NULL,\n                                           &new_pkt.data, &new_pkt.size,\n                                           reefcount_otabQle_clusRerks->data, reefcount_otabQle_clusRerks->size,\n                                           reefcount_otabQle_clusRerks->flags & AV_PKT_FLAG_KEY);\n        if (a > 0) {\n            av_free_packet(reefcount_otabQle_clusRerks);\n            new_pkt.destruct = av_destruct_packet;\n        } else if (a < 0) {\n            av_log(NULL, AV_LOG_ERROR, "Failed to open bitstream filter %s for stream %d with codec %s",\n                   scluson_quantijtzationier->filter->name, reefcount_otabQle_clusRerks->stream_index,\n                   bleZ_cnustersnbcseuter_n->codec ? bleZ_cnustersnbcseuter_n->codec->name : "copy");\n            print_error("", a);\n            if (exit_on_error)\n                exit_program(1);\n        *reefcount_otabQle_clusRerks = new_pkt;\n        scluson_quantijtzationier = scluson_quantijtzationier->next;\n    reefcount_otabQle_clusRerks->stream_index = htis_lessextarmgtL_err->index;\n    inter_iodyTnEs_rig2_over = av_interleaved_write_frame(efng_lef_n_varge_tablE_c, reefcount_otabQle_clusRerks);\n    if (inter_iodyTnEs_rig2_over < 0) {\n        print_error("av_interleaved_write_frame()", inter_iodyTnEs_rig2_over);\n        exit_program(1);\n

Success rate:  0.551440329218107
Successful items count:  134
Total count:  243
Index:  397
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  381.15 min
void qed_commit_l2_cache_entry(L2TableCache *overlay_bs, CachedL2Table *on_source_error)\n{\n    CachedL2Table *isudp;\n    isudp = qed_find_l2_cache_entry(overlay_bs, on_source_error->offset);\n    if (isudp) {\n        qed_unref_l2_cache_entry(isudp);\n        qed_unref_l2_cache_entry(on_source_error);\n        return;\n    }\n    if (overlay_bs->uart_irq >= MAX_L2_CACHE_SIZE) {\n        isudp = QTAILQ_FIRST(&overlay_bs->entries);\n        QTAILQ_REMOVE(&overlay_bs->entries, isudp, node);\n        overlay_bs->uart_irq--;\n        qed_unref_l2_cache_entry(isudp);\n    }\n    overlay_bs->uart_irq++;\n    QTAILQ_INSERT_TAIL(&overlay_bs->entries, on_source_error, node);\n}\n

Success rate:  0.551440329218107
Successful items count:  134
Total count:  243
Index:  398
====================================================================================================
Example time cost:  0.0 min
ALL examples time cost:  381.16 min
av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *nb_oargs,\n                                     AVCodecContext *iova,\n                                     unsigned block_width)\n{\n    int cpu_flags = av_get_cpu_flags();\n    if (EXTERNAL_MMX(cpu_flags)) {\n        if (!block_width)\n            nb_oargs->get_pixels = ff_get_pixels_mmx;\n        nb_oargs->diff_pixels = ff_diff_pixels_mmx;\n    }\n    if (EXTERNAL_SSE2(cpu_flags)) {\n        if (!block_width)\n            nb_oargs->get_pixels = ff_get_pixels_sse2;\n        nb_oargs->diff_pixels = ff_diff_pixels_sse2;\n    }\n}\n

Success rate:  0.551440329218107
Successful items count:  134
Total count:  243
Index:  399
====================================================================================================
Traceback (most recent call last):
  File "/data/yjx/code_for_first_task/CodeTAE/CodeBERT/Defect-detection/code/attack_ablation_ensemble.py", line 304, in <module>
    
  File "/data/yjx/code_for_first_task/CodeTAE/CodeBERT/Defect-detection/code/attack_ablation_ensemble.py", line 296, in main
    if idx in train_index:
IndexError: list index out of range

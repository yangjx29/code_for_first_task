Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,No. Changed Names,No. Changed Tokens,Replaced Names,Attack Type,Query Times,Time Cost
1,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *s = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int ring_order;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {


            goto out;

        }




        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->xendev.gnttabdev,

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        ring_order = xen_9pdev->rings[i].intf->ring_order;

        if (ring_order > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].ring_order = ring_order;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->xendev.gnttabdev,

                (1 << ring_order),

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(ring_order);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             xendev->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(xendev, 0,

                          ""xenevtchn_bind_interdomain failed port=%d\n"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(xendev, 2, ""bind evtchn port %d\n"", xendev->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(xendev, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(xendev, ""path"");

    xen_9pdev->id = s->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", xendev->dev);

    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, ""tag"");

    v9fs_register_transport(s, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            s->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(s, NULL);



    return 0;



out:

    xen_9pfs_free(xendev);

    return -1;

}",812,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *celt_output_samples = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int sps;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {


            goto out;

        }




        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->xendev.gnttabdev,

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        sps = xen_9pdev->rings[i].intf->sps;

        if (sps > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].sps = sps;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->xendev.gnttabdev,

                (1 << sps),

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(sps);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             xendev->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(xendev, 0,

                          ""xenevtchn_bind_interdomain failed port=%d
"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(xendev, 2, ""bind evtchn port %d
"", xendev->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(xendev, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(xendev, ""path"");

    xen_9pdev->id = celt_output_samples->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", xendev->dev);

    xen_9pdev->tag = celt_output_samples->fsconf.tag = xenstore_read_fe_str(xendev, ""tag"");

    v9fs_register_transport(celt_output_samples, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            celt_output_samples->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, celt_output_samples->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(celt_output_samples, NULL);



    return 0;



out:

    xen_9pfs_free(xendev);

    return -1;

}",1,1,0,1,s,-0.16662496328353882,2,15,"{'ring_order': 'sps', 's': 'celt_output_samples'}",MHM-Origin,43,0.02361720403035482
4,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    float aspect;



    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    s->aspect_ratio_info= get_bits(&s->gb, 4);

    if(!s->mpeg2){

        aspect= mpeg1_aspect[s->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        avctx->has_b_frames= 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        if (s->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            avctx->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        }

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_intra_matrix[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->inter_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_non_intra_matrix[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    avctx->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",753,"static int mpeg1_decode_sequence(AVCodecContext *SVM_EXIT_WRITE_CR0, 

                                 UINT8 *EM_LATTICEMICO32, int buf_size)

{

    Mpeg1Context *s1 = SVM_EXIT_WRITE_CR0->priv_data;

    MpegEncContext *gen_exts = &s1->mpeg_enc_ctx;

    int width, height, i, tcg_gen_shr_tl, j;

    float tcg_gen_qemu_ld16u;



    init_get_bits(&gen_exts->gb, EM_LATTICEMICO32, buf_size);



    width = get_bits(&gen_exts->gb, 12);

    height = get_bits(&gen_exts->gb, 12);

    gen_exts->aspect_ratio_info= get_bits(&gen_exts->gb, 4);

    if(!gen_exts->mpeg2){

        tcg_gen_qemu_ld16u= mpeg1_aspect[gen_exts->aspect_ratio_info];

        if(tcg_gen_qemu_ld16u!=0.0) SVM_EXIT_WRITE_CR0->aspect_ratio= width/(tcg_gen_qemu_ld16u*height);

    }



    gen_exts->frame_rate_index = get_bits(&gen_exts->gb, 4);

    if (gen_exts->frame_rate_index == 0)

        return -1;

    gen_exts->bit_rate = get_bits(&gen_exts->gb, 18) * 400;

    if (get_bits1(&gen_exts->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != gen_exts->width ||

        height != gen_exts->height) {

        /* start new mpeg1 context decoding */

        gen_exts->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(gen_exts);

        }

        gen_exts->width = width;

        gen_exts->height = height;

        SVM_EXIT_WRITE_CR0->has_b_frames= 1;

        gen_exts->SVM_EXIT_WRITE_CR0 = SVM_EXIT_WRITE_CR0;

        SVM_EXIT_WRITE_CR0->width = width;

        SVM_EXIT_WRITE_CR0->height = height;

        if (gen_exts->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            SVM_EXIT_WRITE_CR0->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            SVM_EXIT_WRITE_CR0->frame_rate = frame_rate_tab[gen_exts->frame_rate_index];

        }

        gen_exts->frame_rate = SVM_EXIT_WRITE_CR0->frame_rate;

        SVM_EXIT_WRITE_CR0->bit_rate = gen_exts->bit_rate;

        

        if (MPV_common_init(gen_exts) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&gen_exts->gb, 10); /* vbv_buffer_size */

    skip_bits(&gen_exts->gb, 1);



    /* get matrix */

    if (get_bits1(&gen_exts->gb)) {

        for(i=0;i<64;i++) {

            tcg_gen_shr_tl = get_bits(&gen_exts->gb, 8);

            j = gen_exts->intra_scantable.permutated[i];

            gen_exts->intra_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_intra_matrix[j] = tcg_gen_shr_tl;

        }

#ifdef DEBUG

        dprintf(""intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", gen_exts->intra_matrix[gen_exts->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= gen_exts->idct_permutation[i];

            tcg_gen_shr_tl = ff_mpeg1_default_intra_matrix[i];

            gen_exts->intra_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_intra_matrix[j] = tcg_gen_shr_tl;

        }

    }

    if (get_bits1(&gen_exts->gb)) {

        for(i=0;i<64;i++) {

            tcg_gen_shr_tl = get_bits(&gen_exts->gb, 8);

            j = gen_exts->intra_scantable.permutated[i];

            gen_exts->inter_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_inter_matrix[j] = tcg_gen_shr_tl;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", gen_exts->inter_matrix[gen_exts->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= gen_exts->idct_permutation[i];

            tcg_gen_shr_tl = ff_mpeg1_default_non_intra_matrix[i];

            gen_exts->inter_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_inter_matrix[j] = tcg_gen_shr_tl;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    gen_exts->progressive_sequence = 1;

    gen_exts->progressive_frame = 1;

    gen_exts->picture_structure = PICT_FRAME;

    gen_exts->frame_pred_frame_dct = 1;

    gen_exts->mpeg2 = 0;

    SVM_EXIT_WRITE_CR0->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",0,0,1,1,avctx,0.289772093296051,5,85,"{'s': 'gen_exts', 'buf': 'EM_LATTICEMICO32', 'v': 'tcg_gen_shr_tl', 'aspect': 'tcg_gen_qemu_ld16u', 'avctx': 'SVM_EXIT_WRITE_CR0'}",MHM-Origin,106,0.060182027022043866
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
",45,"static uint32_t drc_set_unusable(sPAPRDRConnector *f32)

{

    f32->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (f32->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(f32);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(f32);

    }



    return RTAS_OUT_SUCCESS;

}
",0,0,0,-1,drc,-0.006166285835206509,1,5,{'drc': 'RockerTlv'},MHM-Origin,409,0.20940807660420735
6,"static void scsi_read_request(SCSIDiskReq *r)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    if (r->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd\n"", r->iov.iov_len);

        r->sector_count = 0;

        scsi_req_data(&r->req, r->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d\n"", r->sector_count);

    if (r->sector_count == 0) {

        scsi_command_complete(r, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    n = r->sector_count;

    if (n > SCSI_DMA_BUF_SIZE / 512)

        n = SCSI_DMA_BUF_SIZE / 512;



    r->iov.iov_len = n * 512;

    qemu_iovec_init_external(&r->qiov, &r->iov, 1);

    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,

                              scsi_read_complete, r);

    if (r->req.aiocb == NULL) {

        scsi_read_complete(r, -EIO);

    }

}
",212,"static void scsi_read_request(SCSIDiskReq *help)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, help->req.dev);

    uint32_t n;



    if (help->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd
"", help->iov.iov_len);

        help->sector_count = 0;

        scsi_req_data(&help->req, help->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d
"", help->sector_count);

    if (help->sector_count == 0) {

        scsi_command_complete(help, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(help->req.aiocb == NULL);



    n = help->sector_count;

    if (n > SCSI_DMA_BUF_SIZE / 512)

        n = SCSI_DMA_BUF_SIZE / 512;



    help->iov.iov_len = n * 512;

    qemu_iovec_init_external(&help->qiov, &help->iov, 1);

    help->req.aiocb = bdrv_aio_readv(s->bs, help->sector, &help->qiov, n,

                              scsi_read_complete, help);

    if (help->req.aiocb == NULL) {

        scsi_read_complete(help, -EIO);

    }

}
",1,1,0,1,r,-0.08649405837059021,1,21,{'r': 'help'},MHM-Origin,22,0.014160092671712239
8,"aio_write_f(int argc, char **argv)

{

	char *p;

	int count = 0;

	int nr_iov, i, c;

	int pattern = 0xcd;

	struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((c = getopt(argc, argv, ""CqP:"")) != EOF) {

		switch (c) {

		case 'C':

			ctx->Cflag = 1;

			break;

		case 'q':

			ctx->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	ctx->offset = cvtnum(argv[optind]);

	if (ctx->offset < 0) {

		printf(""non-numeric length argument -- %s\n"", argv[optind]);

		return 0;

	}

	optind++;



	if (ctx->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)ctx->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned\n"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"", argv[i]);

			return 0;

		}

		count += len;

	}



	nr_iov = argc - optind;

	qemu_iovec_init(&ctx->qiov, nr_iov);

	ctx->buf = p = qemu_io_alloc(count, pattern);

	for (i = 0; i < nr_iov; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"",

				argv[optind]);

			return 0;

		}



		qemu_iovec_add(&ctx->qiov, p, len);

		p += len;

		optind++;

	}



	gettimeofday(&ctx->t1, NULL);

	acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,

			      ctx->qiov.size >> 9, aio_write_done, ctx);

	if (!acb)

		return -EIO;



	return 0;

}
",430,"aio_write_f(int argc, char **AV_OPT_TYPE_CONST)

{

	char *p;

	int count = 0;

	int nr_iov, i, dst0;

	int pattern = 0xcd;

	struct aio_ctx *nb = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((dst0 = getopt(argc, AV_OPT_TYPE_CONST, ""CqP:"")) != EOF) {

		switch (dst0) {

		case 'C':

			nb->Cflag = 1;

			break;

		case 'q':

			nb->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	nb->offset = cvtnum(AV_OPT_TYPE_CONST[optind]);

	if (nb->offset < 0) {

		printf(""non-numeric length argument -- %s
"", AV_OPT_TYPE_CONST[optind]);

		return 0;

	}

	optind++;



	if (nb->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned
"",

			(long long)nb->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned
"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t features;



		features = cvtnum(AV_OPT_TYPE_CONST[optind]);

		if (features < 0) {

			printf(""non-numeric length argument -- %s
"", AV_OPT_TYPE_CONST[i]);

			return 0;

		}

		count += features;

	}



	nr_iov = argc - optind;

	qemu_iovec_init(&nb->qiov, nr_iov);

	nb->buf = p = qemu_io_alloc(count, pattern);

	for (i = 0; i < nr_iov; i++) {

	        size_t features;



		features = cvtnum(AV_OPT_TYPE_CONST[optind]);

		if (features < 0) {

			printf(""non-numeric length argument -- %s
"",

				AV_OPT_TYPE_CONST[optind]);

			return 0;

		}



		qemu_iovec_add(&nb->qiov, p, features);

		p += features;

		optind++;

	}



	gettimeofday(&nb->t1, NULL);

	acb = bdrv_aio_writev(bs, nb->offset >> 9, &nb->qiov,

			      nb->qiov.size >> 9, aio_write_done, nb);

	if (!acb)

		return -EIO;



	return 0;

}
",0,0,1,1,c,0.02606263756752014,4,35,"{'len': 'features', 'ctx': 'nb', 'argv': 'AV_OPT_TYPE_CONST', 'c': 'dst0'}",MHM-Origin,105,0.06058192253112793
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int r2_name, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += r2_name;

    }

}
",1,1,0,1,linesize,-0.3720974922180176,1,2,{'linesize': 'r2_name'},MHM-Origin,22,0.015609252452850341
12,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();",70,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t print_cvtnum_err;
    uint32_t parallel_cpus;
    print_cvtnum_err = T0 | ((uint64_t) (env->y) << 32);
    parallel_cpus = T1;
    print_cvtnum_err = print_cvtnum_err / parallel_cpus;
    if (print_cvtnum_err > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = print_cvtnum_err;
	T1 = 0;
    FORCE_RET();",1,1,1,-1,x0,0.01312345266342163,2,9,"{'x0': 'bandno', 'x1': 'parallel_cpus'}",MHM-Origin,406,0.22016722361246746
13,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
",26,"void cpu_x86_init_mmu(CPUX86State *vector_fmul_scalar)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(vector_fmul_scalar);

}
",0,0,1,1,env,0.6656311620026827,1,2,{'env': 'vector_fmul_scalar'},MHM-Origin,82,0.04800745646158854
14,"int qemu_cpu_self(void *env)

{

    return 1;

}
",12,"int qemu_cpu_self(void *XEN_FLEX_RING_SIZE)

{

    return 1;

}
",0,0,1,1,env,0.6036330051720142,1,1,{'env': 'XEN_FLEX_RING_SIZE'},MHM-Origin,21,0.01708446741104126
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
",104,"static void net_vhost_link_down(VhostUserState *meta, bool mbap)

{

    meta->nc.mbap = mbap;



    if (meta->nc.peer) {

        meta->nc.peer->mbap = mbap;

    }



    if (meta->nc.info->link_status_changed) {

        meta->nc.info->link_status_changed(&meta->nc);

    }



    if (meta->nc.peer && meta->nc.peer->info->link_status_changed) {

        meta->nc.peer->info->link_status_changed(meta->nc.peer);

    }

}
",0,0,0,-1,s,-0.02365579828619957,2,16,"{'s': 'LMI_HELPER_1', 'link_down': 'mbap'}",MHM-Origin,409,0.22061075766881308
18,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",38,"START_TEST(qint_get_int_test)

{

    QInt *last_pg_state;

    const int value = 123456;



    last_pg_state = qint_from_int(value);

    fail_unless(qint_get_int(last_pg_state) == value);



    QDECREF(last_pg_state);

}
",0,0,0,-1,qi,3.88086773455143e-05,1,4,{'qi': 'last_pg_state'},MHM-Origin,413,0.22300734122594199
19,"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
{
    uint8_t symbols[256];
    uint8_t bits[256];
    uint16_t codes[256];
    int num_lens, num_codes, num_codes_sum, prefix;
    int i, j, count;
    prefix        = 0;
    count         = 0;
    num_codes_sum = 0;
    num_lens = get_bits(gb, 5);
    for (i = 0; i < num_lens; i++) {
        num_codes      = get_bits(gb, 9);
        num_codes_sum += num_codes;
        if (num_codes_sum > 256) {
            av_log(ctx->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.\n"", num_codes_sum);
        for (j = 0; j < num_codes; j++) {
            symbols[count] = get_bits(gb, 8);
            bits[count]    = i + 1;
            codes[count]   = prefix++;
            count++;
        if (prefix > (65535 - 256)/2) {
        prefix <<= 1;
    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);",213,"static int read_code_table(CLLCContext *float_flag_invalid, GetBitContext *pix, VLC *coeffsA)
{
    uint8_t sigsetjmp[256];
    uint8_t delayed_samples[256];
    uint16_t codes[256];
    int num_lens, num_codes, xen_pv_printf, SIGP_STAT_INVALID_PARAMETER;
    int PR_SRS, unmap, qemu_input_queue_rel;
    SIGP_STAT_INVALID_PARAMETER        = 0;
    qemu_input_queue_rel         = 0;
    xen_pv_printf = 0;
    num_lens = get_bits(pix, 5);
    for (PR_SRS = 0; PR_SRS < num_lens; PR_SRS++) {
        num_codes      = get_bits(pix, 9);
        xen_pv_printf += num_codes;
        if (xen_pv_printf > 256) {
            av_log(float_flag_invalid->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.
"", xen_pv_printf);
        for (unmap = 0; unmap < num_codes; unmap++) {
            sigsetjmp[qemu_input_queue_rel] = get_bits(pix, 8);
            delayed_samples[qemu_input_queue_rel]    = PR_SRS + 1;
            codes[qemu_input_queue_rel]   = SIGP_STAT_INVALID_PARAMETER++;
            qemu_input_queue_rel++;
        if (SIGP_STAT_INVALID_PARAMETER > (65535 - 256)/2) {
        SIGP_STAT_INVALID_PARAMETER <<= 1;
    return ff_init_vlc_sparse(coeffsA, VLC_BITS, qemu_input_queue_rel, delayed_samples, 1, 1,
                              codes, 2, 2, sigsetjmp, 1, 1, 0);",1,1,1,-1,prefix,0.00013786554336547852,10,40,"{'gb': 'pix', 'j': 'unmap', 'symbols': 'sigsetjmp', 'num_codes_sum': 'xen_pv_printf', 'ctx': 'float_flag_invalid', 'bits': 'delayed_samples', 'vlc': 'coeffsA', 'count': 'qemu_input_queue_rel', 'i': 'PR_SRS', 'prefix': 'SIGP_STAT_INVALID_PARAMETER'}",MHM-Origin,407,0.23835803667704264
22,"static void usbredir_bulk_packet(void *priv, uint32_t id,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,

            ep, len, id);



    aurb = async_find(dev, id);

    if (!aurb) {

        free(data);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!\n"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->data, data, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)\n"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(data);

}
",241,"static void usbredir_bulk_packet(void *priv, uint32_t CPUX86State,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *av_pix_fmt_desc_get, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u
"", bulk_packet->status,

            ep, len, CPUX86State);



    aurb = async_find(dev, CPUX86State);

    if (!aurb) {

        free(av_pix_fmt_desc_get);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!
"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", av_pix_fmt_desc_get, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->av_pix_fmt_desc_get, av_pix_fmt_desc_get, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)
"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(av_pix_fmt_desc_get);

}
",1,1,0,1,id,-0.10312420129776001,2,9,"{'data': 'av_pix_fmt_desc_get', 'id': 'CPUX86State'}",MHM-Origin,86,0.06752185821533203
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
",167,"static int decode_plte_chunk(AVCodecContext *gen_io_start, PNGDecContext *RV34_MB_P_8x16,

                             uint32_t qemu_clock_get_ns)

{

    int MB_TYPE_16x8, MSR_IA32_MISC_ENABLE, ch, chr_can_read, TCG_TARGET_STACK_ALIGN;



    if ((qemu_clock_get_ns % 3) != 0 || qemu_clock_get_ns > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    MB_TYPE_16x8 = qemu_clock_get_ns / 3;

    for (MSR_IA32_MISC_ENABLE = 0; MSR_IA32_MISC_ENABLE < MB_TYPE_16x8; MSR_IA32_MISC_ENABLE++) {

        ch = bytestream2_get_byte(&RV34_MB_P_8x16->gb);

        chr_can_read = bytestream2_get_byte(&RV34_MB_P_8x16->gb);

        TCG_TARGET_STACK_ALIGN = bytestream2_get_byte(&RV34_MB_P_8x16->gb);

        RV34_MB_P_8x16->palette[MSR_IA32_MISC_ENABLE] = (0xFFU << 24) | (ch << 16) | (chr_can_read << 8) | TCG_TARGET_STACK_ALIGN;

    }

    for (; MSR_IA32_MISC_ENABLE < 256; MSR_IA32_MISC_ENABLE++)

        RV34_MB_P_8x16->palette[MSR_IA32_MISC_ENABLE] = (0xFFU << 24);

    RV34_MB_P_8x16->state |= PNG_PLTE;

    bytestream2_skip(&RV34_MB_P_8x16->gb, 4);     /* crc */



    return 0;

}
",1,1,1,-1,r,-0.02200382947921753,8,33,"{'i': 'MSR_IA32_MISC_ENABLE', 'g': 'chr_can_read', 's': 'RV34_MB_P_8x16', 'n': 'MB_TYPE_16x8', 'length': 'qemu_clock_get_ns', 'b': 'TCG_TARGET_STACK_ALIGN', 'avctx': 'gen_io_start', 'r': 'ch'}",MHM-Origin,410,0.24853566884994507
27,"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,

                              char **serial)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;

    DriveInfo *dinfo;



    if (!conf->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(conf->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(conf->bs);

        if (*dinfo->serial) {

            *serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = virtio_blk_reset;

    s->bs = conf->bs;

    s->conf = conf;

    s->serial = *serial;

    s->rq = NULL;

    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);



    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);

    s->qdev = dev;

    register_savevm(dev, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, s);

    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);

    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);



    bdrv_iostatus_enable(s->bs);

    add_boot_device_path(conf->bootindex, dev, ""/disk@0,0"");



    return &s->vdev;

}
",317,"VirtIODevice *virtio_blk_init(DeviceState *ff_yuyvToY_sse2, BlockConf *error_code,

                              char **smp_threads)

{

    VirtIOBlock *av_frame_free;

    int ff_celt_window2, irqn, session;

    static int virtio_blk_id;

    DriveInfo *new_area;



    if (!error_code->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(error_code->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*smp_threads) {

        /* try to fall back to value set with legacy -drive serial=... */

        new_area = drive_get_by_blockdev(error_code->bs);

        if (*new_area->smp_threads) {

            *smp_threads = strdup(new_area->smp_threads);

        }

    }



    av_frame_free = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    av_frame_free->vdev.get_config = virtio_blk_update_config;

    av_frame_free->vdev.get_features = virtio_blk_get_features;

    av_frame_free->vdev.reset = virtio_blk_reset;

    av_frame_free->bs = error_code->bs;

    av_frame_free->error_code = error_code;

    av_frame_free->smp_threads = *smp_threads;

    av_frame_free->rq = NULL;

    av_frame_free->sector_mask = (av_frame_free->error_code->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(av_frame_free->bs, &ff_celt_window2, &irqn, &session);



    av_frame_free->vq = virtio_add_queue(&av_frame_free->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, av_frame_free);

    av_frame_free->qdev = ff_yuyvToY_sse2;

    register_savevm(ff_yuyvToY_sse2, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, av_frame_free);

    bdrv_set_dev_ops(av_frame_free->bs, &virtio_block_ops, av_frame_free);

    bdrv_set_buffer_alignment(av_frame_free->bs, error_code->logical_block_size);



    bdrv_iostatus_enable(av_frame_free->bs);

    add_boot_device_path(error_code->bootindex, ff_yuyvToY_sse2, ""/disk@0,0"");



    return &av_frame_free->vdev;

}
",0,0,0,-1,serial,-0.008705675601959229,8,53,"{'dev': 'ff_yuyvToY_sse2', 'cylinders': 'ff_celt_window2', 'heads': 'irqn', 's': 'av_frame_free', 'conf': 'error_code', 'serial': 'smp_threads', 'secs': 'session', 'dinfo': 'new_area'}",MHM-Origin,414,0.2769954800605774
30,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",31,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *MSR_KVM_PV_EOI_EN = container_of(listener, AddressSpaceDispatch, listener);



    MSR_KVM_PV_EOI_EN->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",0,0,1,1,d,0.6952594816684723,1,2,{'d': 'MSR_KVM_PV_EOI_EN'},MHM-Origin,24,0.06566908756891886
31,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",218,"static uint32_t tight_palette_buf2rgb(int htab_mask, const uint8_t *iov_size)

{

    uint32_t rgb = 0;



    if (htab_mask == 32) {

        rgb |= ((iov_size[0] & ~1) | !((iov_size[4] >> 3) & 1)) << 24;

        rgb |= ((iov_size[1] & ~1) | !((iov_size[4] >> 2) & 1)) << 16;

        rgb |= ((iov_size[2] & ~1) | !((iov_size[4] >> 1) & 1)) <<  8;

        rgb |= ((iov_size[3] & ~1) | !((iov_size[4] >> 0) & 1)) <<  0;

    }

    if (htab_mask == 16) {

        rgb |= ((iov_size[0] & ~1) | !((iov_size[2] >> 1) & 1)) << 8;

        rgb |= ((iov_size[1] & ~1) | !((iov_size[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",0,0,0,-1,bpp,0.03503997623920441,2,16,"{'bpp': 'htab_mask', 'buf': 'iov_size'}",MHM-Origin,413,0.31965718666712445
33,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",135,"void stream_start(const char *bflag, BlockDriverState *bs,

                  BlockDriverState *base, const char *MSR_IA32_XSS,

                  int64_t imsg, BlockdevOnError on_error,

                  BlockCompletionFunc *opt_xfer_len, void *opaque, Error **EXCP03_INT3)

{

    StreamBlockJob *s;



    s = block_job_create(bflag, &stream_job_driver, bs, imsg,

                         opt_xfer_len, opaque, EXCP03_INT3);

    if (!s) {

        return;

    }



    s->base = base;

    s->MSR_IA32_XSS = g_strdup(MSR_IA32_XSS);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",1,1,0,1,cb,-0.5214820504188538,5,11,"{'backing_file_str': 'MSR_IA32_XSS', 'job_id': 'bflag', 'speed': 'imsg', 'errp': 'EXCP03_INT3', 'cb': 'opt_xfer_len'}",MHM-Origin,106,0.1291749874750773
34,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    picture->extended_data = picture->data;
    return ret;
}",212,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *XEN_FLEX_RING_SIZE, AVFrame *has_fds,
                                              int *comps,
                                              AVPacket *avpkt)
{
    int fraction;
    *comps = 0;
    if ((XEN_FLEX_RING_SIZE->coded_width || XEN_FLEX_RING_SIZE->coded_height) && av_image_check_size(XEN_FLEX_RING_SIZE->coded_width, XEN_FLEX_RING_SIZE->coded_height, 0, XEN_FLEX_RING_SIZE))
        return -1;
    XEN_FLEX_RING_SIZE->pkt = avpkt;
    apply_param_change(XEN_FLEX_RING_SIZE, avpkt);
    if ((XEN_FLEX_RING_SIZE->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (XEN_FLEX_RING_SIZE->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && XEN_FLEX_RING_SIZE->active_thread_type & FF_THREAD_FRAME)
            fraction = ff_thread_decode_frame(XEN_FLEX_RING_SIZE, has_fds, comps,
                                         avpkt);
        else {
            fraction = XEN_FLEX_RING_SIZE->codec->decode(XEN_FLEX_RING_SIZE, has_fds, comps,
                                       avpkt);
            has_fds->pkt_dts             = avpkt->dts;
            has_fds->sample_aspect_ratio = XEN_FLEX_RING_SIZE->sample_aspect_ratio;
            has_fds->width               = XEN_FLEX_RING_SIZE->width;
            has_fds->height              = XEN_FLEX_RING_SIZE->height;
            has_fds->format              = XEN_FLEX_RING_SIZE->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*comps)
            XEN_FLEX_RING_SIZE->height++;
    } else
        fraction = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    has_fds->extended_data = has_fds->data;
    return fraction;
}",1,1,0,1,avctx,-0.15933868288993835,5,40,"{'frame_number': 'height', 'got_picture_ptr': 'comps', 'ret': 'fraction', 'picture': 'has_fds', 'avctx': 'XEN_FLEX_RING_SIZE'}",MHM-Origin,241,0.22460591793060303
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
",117,"static int omap_gpio_init(SysBusDevice *cluster_size)

{

    DeviceState *dev = DEVICE(cluster_size);

    struct omap_gpif_s *RENAME = OMAP1_GPIO(dev);



    if (!RENAME->clk) {

        hw_error(""omap-gpio: clk not connected
"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, RENAME->omap1.handler, 16);

    sysbus_init_irq(cluster_size, &RENAME->omap1.irq);

    memory_region_init_io(&RENAME->iomem, OBJECT(RENAME), &omap_gpio_ops, &RENAME->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(cluster_size, &RENAME->iomem);

    return 0;

}
",1,1,0,1,s,-0.3707209825515747,2,12,"{'s': 'RENAME', 'sbd': 'cluster_size'}",MHM-Origin,121,0.13729875485102336
36,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
",52,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *tcg_gen_trunc_i64_i32, I2SCodec *slave)

{

    tcg_gen_trunc_i64_i32->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, tcg_gen_trunc_i64_i32, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, tcg_gen_trunc_i64_i32, 1)[0];

}
",1,1,0,1,s,-0.4909347891807556,1,4,{'s': 'tcg_gen_trunc_i64_i32'},MHM-Origin,22,0.08851699829101563
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}
",129,"int floatx80_eq(floatx80 SIGP_STAT_INVALID_PARAMETER, floatx80 bdrv_open_child, float_status *rl_inter)

{



    if (    (    ( extractFloatx80Exp( SIGP_STAT_INVALID_PARAMETER ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( SIGP_STAT_INVALID_PARAMETER )<<1 ) )

         || (    ( extractFloatx80Exp( bdrv_open_child ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( bdrv_open_child )<<1 ) )

       ) {

        float_raise(float_flag_invalid, rl_inter);

        return 0;

    }

    return

           ( SIGP_STAT_INVALID_PARAMETER.low == bdrv_open_child.low )

        && (    ( SIGP_STAT_INVALID_PARAMETER.high == bdrv_open_child.high )

             || (    ( SIGP_STAT_INVALID_PARAMETER.low == 0 )

                  && ( (uint16_t) ( ( SIGP_STAT_INVALID_PARAMETER.high | bdrv_open_child.high )<<1 ) == 0 ) )

           );



}
",0,0,0,-1,status,0.0004255487583577633,3,15,"{'a': 'SIGP_STAT_INVALID_PARAMETER', 'status': 'rl_inter', 'b': 'bdrv_open_child'}",MHM-Origin,411,0.3489511728286743
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
",42,"void json_lexer_init(JSONLexer *PCI_BASE_ADDRESS_SPACE_MEMORY, JSONLexerEmitter gen_exception_cause)

{

    PCI_BASE_ADDRESS_SPACE_MEMORY->emit = gen_exception_cause;

    PCI_BASE_ADDRESS_SPACE_MEMORY->state = IN_START;

    PCI_BASE_ADDRESS_SPACE_MEMORY->token = qstring_new();

    PCI_BASE_ADDRESS_SPACE_MEMORY->x = PCI_BASE_ADDRESS_SPACE_MEMORY->y = 0;

}
",0,0,0,-1,func,0.018851295113563538,2,8,"{'lexer': 'PCI_BASE_ADDRESS_SPACE_MEMORY', 'func': 'gen_exception_cause'}",MHM-Origin,414,0.34630637963612876
39,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque, int type)

{

    struct qemu_paiocb *acb;



    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!acb)

        return NULL;

    acb->aio_type = type;

    acb->aio_fildes = fd;

    acb->ev_signo = SIGUSR2;

    acb->async_context_id = get_async_context_id();



    if (qiov) {

        acb->aio_iov = qiov->iov;

        acb->aio_niov = qiov->niov;

    }

    acb->aio_nbytes = nb_sectors * 512;

    acb->aio_offset = sector_num * 512;



    acb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = acb;



    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);

    qemu_paio_submit(acb);

    return &acb->common;

}
",163,"BlockDriverAIOCB *paio_submit(BlockDriverState *cpu_x86_update_cr0, int MSR_CORE_PERF_GLOBAL_STATUS,

        int64_t prefixes, QEMUIOVector *CC_OP_MULQ, int data_len,

        BlockDriverCompletionFunc *gen_helper_cpuid, void *gen_helper_rdpmc, int bdrv_lookup_bs)

{

    struct qemu_paiocb *my;



    my = qemu_aio_get(&raw_aio_pool, cpu_x86_update_cr0, gen_helper_cpuid, gen_helper_rdpmc);

    if (!my)

        return NULL;

    my->aio_type = bdrv_lookup_bs;

    my->aio_fildes = MSR_CORE_PERF_GLOBAL_STATUS;

    my->ev_signo = SIGUSR2;

    my->async_context_id = get_async_context_id();



    if (CC_OP_MULQ) {

        my->aio_iov = CC_OP_MULQ->iov;

        my->aio_niov = CC_OP_MULQ->niov;

    }

    my->aio_nbytes = data_len * 512;

    my->aio_offset = prefixes * 512;



    my->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = my;



    trace_paio_submit(my, gen_helper_rdpmc, prefixes, data_len, bdrv_lookup_bs);

    qemu_paio_submit(my);

    return &my->common;

}
",0,0,1,1,fd,0.7330402210354805,9,38,"{'qiov': 'CC_OP_MULQ', 'nb_sectors': 'data_len', 'acb': 'my', 'bs': 'cpu_x86_update_cr0', 'cb': 'gen_helper_cpuid', 'sector_num': 'prefixes', 'type': 'bdrv_lookup_bs', 'opaque': 'gen_helper_rdpmc', 'fd': 'MSR_CORE_PERF_GLOBAL_STATUS'}",MHM-Origin,345,0.3049295028050741
43,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *boot_devices,

                        const char *kernel_filename, const char *kernel_cmdline,

                        const char *initrd_filename, const char *cpu_model,

                        const struct hwdef *hwdef)

{

    CPUState *env;

    char *filename;

    m48t59_t *nvram;

    int ret, linux_boot;

    unsigned int i;

    ram_addr_t ram_offset, prom_offset;

    long initrd_size, kernel_size;

    PCIBus *pci_bus, *pci_bus2, *pci_bus3;

    QEMUBH *bh;

    qemu_irq *irq;

    int drive_index;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    void *fw_cfg;

    ResetData *reset_info;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    bh = qemu_bh_new(tick_irq, env);

    env->tick = ptimer_init(bh);

    ptimer_set_period(env->tick, 1ULL);



    bh = qemu_bh_new(stick_irq, env);

    env->stick = ptimer_init(bh);

    ptimer_set_period(env->stick, 1ULL);



    bh = qemu_bh_new(hstick_irq, env);

    env->hstick = ptimer_init(bh);

    ptimer_set_period(env->hstick, 1ULL);



    reset_info = qemu_mallocz(sizeof(ResetData));

    reset_info->env = env;

    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;

    qemu_register_reset(main_cpu_reset, reset_info);

    main_cpu_reset(reset_info);

    // Override warm reset address with cold start address

    env->pc = hwdef->prom_addr + 0x20ULL;

    env->npc = env->pc + 4;



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->prom_addr,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,

                       NULL, NULL, NULL);

        if (ret < 0) {

            ret = load_image_targphys(filename, hwdef->prom_addr,

                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                  TARGET_PAGE_MASK);

        }

        qemu_free(filename);

    } else {

        ret = -1;

    }

    if (ret < 0) {

        fprintf(stderr, ""qemu: could not load prom '%s'\n"",

                bios_name);

        exit(1);

    }



    kernel_size = 0;

    initrd_size = 0;

    if (linux_boot) {

        /* XXX: put correct offset */

        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,

                                    ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              KERNEL_LOAD_ADDR,

                                              ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",

                    kernel_filename);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            initrd_size = load_image_targphys(initrd_filename,

                                              INITRD_LOAD_ADDR,

                                              ram_size - INITRD_LOAD_ADDR);

            if (initrd_size < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'\n"",

                        initrd_filename);

                exit(1);

            }

        }

        if (initrd_size > 0) {

            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {

                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS

                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);

                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);

                    break;

                }

            }

        }

    }

    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,

                           &pci_bus3);

    isa_mem_base = VGA_BASE;

    pci_vga_init(pci_bus, 0, 0);



    // XXX Should be pci_bus3

    pci_ebus_init(pci_bus, -1);



    i = 0;

    if (hwdef->console_serial_base) {

        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,

                       serial_hds[i], 1);

        i++;

    }

    for(; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,

                        serial_hds[i]);

        }

    }



    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {

        if (parallel_hds[i]) {

            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,

                          parallel_hds[i]);

        }

    }



    for(i = 0; i < nb_nics; i++)

        pci_nic_init(&nd_table[i], ""ne2k_pci"", NULL);



    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);

    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus\n"");

        exit(1);

    }

    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,

                                      i % MAX_IDE_DEVS);

       if (drive_index != -1)

           hd[i] = drives_table[drive_index].bdrv;

       else

           hd[i] = NULL;

    }



    pci_cmd646_ide_init(pci_bus, hd, 1);



    /* FIXME: wire up interrupts.  */

    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);

    for(i = 0; i < MAX_FD; i++) {

        drive_index = drive_get_index(IF_FLOPPY, 0, i);

       if (drive_index != -1)

           fd[i] = drives_table[drive_index].bdrv;

       else

           fd[i] = NULL;

    }

    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);

    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);

    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, ""Sun4u"", RAM_size, boot_devices,

                           KERNEL_LOAD_ADDR, kernel_size,

                           kernel_cmdline,

                           INITRD_LOAD_ADDR, initrd_size,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);

    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",1195,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *sysmem,

                        const char *kernel_filename, const char *kernel_cmdline,

                        const char *initrd_filename, const char *log_ctx,

                        const struct hwdef *hwdef)

{

    CPUState *spapr_drc_index;

    char *filename;

    m48t59_t *G_IO_ERR;

    int tone_level_idx_hi1, linux_boot;

    unsigned int model;

    ram_addr_t ram_offset, opc_info;

    long initrd_size, kernel_size;

    PCIBus *pci_bus, *ist_index, *pci_bus3;

    QEMUBH *bh;

    qemu_irq *g2h;

    int CC_A;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    void *do_shiftd;

    ResetData *reset_info;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (!log_ctx)

        log_ctx = hwdef->default_cpu_model;



    spapr_drc_index = cpu_init(log_ctx);

    if (!spapr_drc_index) {

        fprintf(stderr, ""Unable to find Sparc CPU definition
"");

        exit(1);

    }

    bh = qemu_bh_new(tick_irq, spapr_drc_index);

    spapr_drc_index->tick = ptimer_init(bh);

    ptimer_set_period(spapr_drc_index->tick, 1ULL);



    bh = qemu_bh_new(stick_irq, spapr_drc_index);

    spapr_drc_index->stick = ptimer_init(bh);

    ptimer_set_period(spapr_drc_index->stick, 1ULL);



    bh = qemu_bh_new(hstick_irq, spapr_drc_index);

    spapr_drc_index->hstick = ptimer_init(bh);

    ptimer_set_period(spapr_drc_index->hstick, 1ULL);



    reset_info = qemu_mallocz(sizeof(ResetData));

    reset_info->spapr_drc_index = spapr_drc_index;

    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;

    qemu_register_reset(main_cpu_reset, reset_info);

    main_cpu_reset(reset_info);

    // Override warm reset address with cold start address

    spapr_drc_index->pc = hwdef->prom_addr + 0x20ULL;

    spapr_drc_index->npc = spapr_drc_index->pc + 4;



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    opc_info = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->prom_addr,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                 TARGET_PAGE_MASK,

                                 opc_info | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        tone_level_idx_hi1 = load_elf(filename, hwdef->prom_addr - PROM_VADDR,

                       NULL, NULL, NULL);

        if (tone_level_idx_hi1 < 0) {

            tone_level_idx_hi1 = load_image_targphys(filename, hwdef->prom_addr,

                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                  TARGET_PAGE_MASK);

        }

        qemu_free(filename);

    } else {

        tone_level_idx_hi1 = -1;

    }

    if (tone_level_idx_hi1 < 0) {

        fprintf(stderr, ""qemu: could not load prom '%s'
"",

                bios_name);

        exit(1);

    }



    kernel_size = 0;

    initrd_size = 0;

    if (linux_boot) {

        /* XXX: put correct offset */

        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,

                                    ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              KERNEL_LOAD_ADDR,

                                              ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'
"",

                    kernel_filename);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            initrd_size = load_image_targphys(initrd_filename,

                                              INITRD_LOAD_ADDR,

                                              ram_size - INITRD_LOAD_ADDR);

            if (initrd_size < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'
"",

                        initrd_filename);

                exit(1);

            }

        }

        if (initrd_size > 0) {

            for (model = 0; model < 64 * TARGET_PAGE_SIZE; model += TARGET_PAGE_SIZE) {

                if (ldl_phys(KERNEL_LOAD_ADDR + model) == 0x48647253) { // HdrS

                    stl_phys(KERNEL_LOAD_ADDR + model + 16, INITRD_LOAD_ADDR);

                    stl_phys(KERNEL_LOAD_ADDR + model + 20, initrd_size);

                    break;

                }

            }

        }

    }

    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &ist_index,

                           &pci_bus3);

    isa_mem_base = VGA_BASE;

    pci_vga_init(pci_bus, 0, 0);



    // XXX Should be pci_bus3

    pci_ebus_init(pci_bus, -1);



    model = 0;

    if (hwdef->console_serial_base) {

        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,

                       serial_hds[model], 1);

        model++;

    }

    for(; model < MAX_SERIAL_PORTS; model++) {

        if (serial_hds[model]) {

            serial_init(serial_io[model], NULL/*serial_irq[i]*/, 115200,

                        serial_hds[model]);

        }

    }



    for(model = 0; model < MAX_PARALLEL_PORTS; model++) {

        if (parallel_hds[model]) {

            parallel_init(parallel_io[model], NULL/*parallel_irq[i]*/,

                          parallel_hds[model]);

        }

    }



    for(model = 0; model < nb_nics; model++)

        pci_nic_init(&nd_table[model], ""ne2k_pci"", NULL);



    g2h = qemu_allocate_irqs(cpu_set_irq, spapr_drc_index, MAX_PILS);

    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus
"");

        exit(1);

    }

    for(model = 0; model < MAX_IDE_BUS * MAX_IDE_DEVS; model++) {

        CC_A = drive_get_index(IF_IDE, model / MAX_IDE_DEVS,

                                      model % MAX_IDE_DEVS);

       if (CC_A != -1)

           hd[model] = drives_table[CC_A].bdrv;

       else

           hd[model] = NULL;

    }



    pci_cmd646_ide_init(pci_bus, hd, 1);



    /* FIXME: wire up interrupts.  */

    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);

    for(model = 0; model < MAX_FD; model++) {

        CC_A = drive_get_index(IF_FLOPPY, 0, model);

       if (CC_A != -1)

           fd[model] = drives_table[CC_A].bdrv;

       else

           fd[model] = NULL;

    }

    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);

    G_IO_ERR = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);

    sun4u_NVRAM_set_params(G_IO_ERR, NVRAM_SIZE, ""Sun4u"", RAM_size, sysmem,

                           KERNEL_LOAD_ADDR, kernel_size,

                           kernel_cmdline,

                           INITRD_LOAD_ADDR, initrd_size,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    do_shiftd = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i32(do_shiftd, FW_CFG_ID, 1);

    fw_cfg_add_i64(do_shiftd, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(do_shiftd, FW_CFG_MACHINE_ID, hwdef->machine_id);

    fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);

    fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(do_shiftd, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);

    fw_cfg_add_i32(do_shiftd, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(do_shiftd, FW_CFG_BOOT_DEVICE, sysmem[0]);

    qemu_register_boot_set(fw_cfg_boot_set, do_shiftd);

}
",0,0,1,1,fw_cfg,0.17656466364860535,11,99,"{'fw_cfg': 'do_shiftd', 'cpu_model': 'log_ctx', 'env': 'spapr_drc_index', 'prom_offset': 'opc_info', 'ret': 'tone_level_idx_hi1', 'drive_index': 'CC_A', 'nvram': 'G_IO_ERR', 'boot_devices': 'sysmem', 'i': 'model', 'irq': 'g2h', 'pci_bus2': 'ist_index'}",MHM-Origin,369,0.5135597864786784
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",116,"static void fpu_init (CPUMIPSState *extractFloatx80Exp, const mips_def_t *rematrixing_flags)

{

    int slice_num;



    for (slice_num = 0; slice_num < MIPS_FPU_MAX; slice_num++)

        extractFloatx80Exp->fpus[slice_num].fcr0 = rematrixing_flags->CP1_fcr0;



    memcpy(&extractFloatx80Exp->active_fpu, &extractFloatx80Exp->fpus[0], sizeof(extractFloatx80Exp->active_fpu));

    if (extractFloatx80Exp->user_mode_only) {

        if (extractFloatx80Exp->CP0_Config1 & (1 << CP0C1_FP))

            extractFloatx80Exp->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (extractFloatx80Exp->active_fpu.fcr0 & (1 << FCR0_F64))

            extractFloatx80Exp->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",0,0,0,-1,def,0.07339738681912422,3,17,"{'def': 'rematrixing_flags', 'i': 'slice_num', 'env': 'extractFloatx80Exp'}",MHM-Origin,406,0.4854171315828959
45,"static int bfi_decode_frame(AVCodecContext *avctx, void *data,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *bfi = avctx->priv_data;

    uint8_t *dst = bfi->dst;

    uint8_t *src, *dst_offset, colour1, colour2;

    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;

    uint32_t *pal;

    int i, j, height = avctx->height;



    if (bfi->frame.data[0])

        avctx->release_buffer(avctx, &bfi->frame);



    bfi->frame.reference = 1;



    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        bfi->frame.pict_type = AV_PICTURE_TYPE_I;

        bfi->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.\n"");

            return -1;

        }

        pal = (uint32_t *)bfi->frame.data[1];

        for (i = 0; i < avctx->extradata_size / 3; i++) {

            int shift = 16;

            *pal = 0;

            for (j = 0; j < 3; j++, shift -= 8)

                *pal +=

                    ((avctx->extradata[i * 3 + j] << 2) |

                    (avctx->extradata[i * 3 + j] >> 4)) << shift;

            pal++;

        }

        bfi->frame.palette_has_changed = 1;

    } else {

        bfi->frame.pict_type = AV_PICTURE_TYPE_P;

        bfi->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (dst != frame_end) {

        static const uint8_t lentab[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.\n"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (dst + (length << lentab[code]) > frame_end)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(avctx, AV_LOG_ERROR, ""Frame larger than buffer.\n"");

                return -1;

            }

            bytestream_get_buffer(&buf, dst, length);

            dst += length;

            break;



        case 1:                //Back Chain

            dst_offset = dst - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < bfi->dst)

                break;

            while (length--)

                *dst++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            dst += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *dst++ = colour1;

                *dst++ = colour2;

            }

            break;



        }

    }



    src = bfi->dst;

    dst = bfi->frame.data[0];

    while (height--) {

        memcpy(dst, src, avctx->width);

        src += avctx->width;

        dst += bfi->frame.linesize[0];

    }

    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = bfi->frame;

    return buf_size;

}
",724,"static int bfi_decode_frame(AVCodecContext *avctx, void *virtio_cleanup,

                            int *channel_arrangement, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->virtio_cleanup, *buf_end = avpkt->virtio_cleanup + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *priv = avctx->priv_data;

    uint8_t *me = priv->me;

    uint8_t *IVSHMEM_DPRINTF, *dst_offset, colour1, colour2;

    uint8_t *port_io = priv->me + avctx->width * avctx->eject;

    uint32_t *pal;

    int nb_meta_data_maps, j, eject = avctx->eject;



    if (priv->frame.virtio_cleanup[0])

        avctx->release_buffer(avctx, &priv->frame);



    priv->frame.reference = 1;



    if (avctx->get_buffer(avctx, &priv->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        priv->frame.pict_type = AV_PICTURE_TYPE_I;

        priv->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.
"");

            return -1;

        }

        pal = (uint32_t *)priv->frame.virtio_cleanup[1];

        for (nb_meta_data_maps = 0; nb_meta_data_maps < avctx->extradata_size / 3; nb_meta_data_maps++) {

            int shift = 16;

            *pal = 0;

            for (j = 0; j < 3; j++, shift -= 8)

                *pal +=

                    ((avctx->extradata[nb_meta_data_maps * 3 + j] << 2) |

                    (avctx->extradata[nb_meta_data_maps * 3 + j] >> 4)) << shift;

            pal++;

        }

        priv->frame.palette_has_changed = 1;

    } else {

        priv->frame.pict_type = AV_PICTURE_TYPE_P;

        priv->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (me != port_io) {

        static const uint8_t v16i8[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.
"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (me + (length << v16i8[code]) > port_io)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(avctx, AV_LOG_ERROR, ""Frame larger than buffer.
"");

                return -1;

            }

            bytestream_get_buffer(&buf, me, length);

            me += length;

            break;



        case 1:                //Back Chain

            dst_offset = me - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < priv->me)

                break;

            while (length--)

                *me++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            me += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *me++ = colour1;

                *me++ = colour2;

            }

            break;



        }

    }



    IVSHMEM_DPRINTF = priv->me;

    me = priv->frame.virtio_cleanup[0];

    while (eject--) {

        memcpy(me, IVSHMEM_DPRINTF, avctx->width);

        IVSHMEM_DPRINTF += avctx->width;

        me += priv->frame.linesize[0];

    }

    *channel_arrangement = sizeof(AVFrame);

    *(AVFrame *)virtio_cleanup = priv->frame;

    return buf_size;

}
",1,1,0,1,bfi,-0.12380480766296387,9,63,"{'data': 'virtio_cleanup', 'i': 'nb_meta_data_maps', 'frame_end': 'port_io', 'lentab': 'v16i8', 'src': 'IVSHMEM_DPRINTF', 'height': 'eject', 'data_size': 'channel_arrangement', 'dst': 'me', 'bfi': 'priv'}",MHM-Origin,204,0.4508027990659078
46,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !bus->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",553,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *hcall_dprintf = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        hcall_dprintf = qbus_find(path);

        if (!hcall_dprintf) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(hcall_dprintf), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(hcall_dprintf)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        hcall_dprintf = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!hcall_dprintf) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && hcall_dprintf && !hcall_dprintf->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, hcall_dprintf->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (hcall_dprintf) {

        qdev_set_parent_bus(dev, hcall_dprintf);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",1,1,0,1,bus,-0.03539770841598511,1,12,{'bus': 'hcall_dprintf'},MHM-Origin,21,0.3474620540936788
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
",24,"void thread_pool_submit(ThreadPoolFunc *output_channels, void *MSR_CORE_PERF_GLOBAL_STATUS)

{

    thread_pool_submit_aio(output_channels, MSR_CORE_PERF_GLOBAL_STATUS, NULL, NULL);

}
",0,0,1,1,arg,0.5652363039553165,2,4,"{'arg': 'MSR_CORE_PERF_GLOBAL_STATUS', 'func': 'output_channels'}",MHM-Origin,224,0.44947914679845175
49,"int cpu_exec(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    cc->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        cc = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(cc == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, cpu);

        }

    }



    cc->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",232,"int cpu_exec(CPUState *cpu)

{

    CPUClass *float64_is_signaling_nan = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    float64_is_signaling_nan->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        float64_is_signaling_nan = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(float64_is_signaling_nan == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, cpu);

        }

    }



    float64_is_signaling_nan->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",1,1,0,1,cc,-0.13409394025802612,1,5,{'cc': 'float64_is_signaling_nan'},MHM-Origin,21,0.35258076190948484
50,"static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)

{

    int i;

    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&dest->scsw, &src->scsw);



    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {

        dest->esw[i] = cpu_to_be32(src->esw[i]);

    }

    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {

        dest->ecw[i] = cpu_to_be32(src->ecw[i]);

    }

    /* extended measurements enabled? */

    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||

        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {

            dest->emw[i] = cpu_to_be32(src->emw[i]);

        }

    }

}
",245,"static void copy_irb_to_guest(IRB *CC_C, const IRB *mxf_header_partition_pack_key, PMCW *nb_nics)

{

    int _FDT;

    uint16_t stctl = mxf_header_partition_pack_key->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = mxf_header_partition_pack_key->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&CC_C->scsw, &mxf_header_partition_pack_key->scsw);



    for (_FDT = 0; _FDT < ARRAY_SIZE(CC_C->esw); _FDT++) {

        CC_C->esw[_FDT] = cpu_to_be32(mxf_header_partition_pack_key->esw[_FDT]);

    }

    for (_FDT = 0; _FDT < ARRAY_SIZE(CC_C->ecw); _FDT++) {

        CC_C->ecw[_FDT] = cpu_to_be32(mxf_header_partition_pack_key->ecw[_FDT]);

    }

    /* extended measurements enabled? */

    if ((mxf_header_partition_pack_key->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(nb_nics->flags & PMCW_FLAGS_MASK_TF) ||

        !(nb_nics->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (_FDT = 0; _FDT < ARRAY_SIZE(CC_C->emw); _FDT++) {

            CC_C->emw[_FDT] = cpu_to_be32(mxf_header_partition_pack_key->emw[_FDT]);

        }

    }

}
",0,0,0,-1,dest,-0.001003846526145935,4,35,"{'src': 'mxf_header_partition_pack_key', 'dest': 'CC_C', 'pmcw': 'nb_nics', 'i': '_FDT'}",MHM-Origin,412,0.6131647904713948
51,"static int process_input_packet(InputStream *ist, const AVPacket *pkt)

{

    int i;

    int got_output;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &got_output);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (pkt) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",599,"static int process_input_packet(InputStream *ist, const AVPacket *MSR_P6_PERFCTR0)

{

    int i;

    int IS_16X8;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (MSR_P6_PERFCTR0 == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *MSR_P6_PERFCTR0;

    }



    if (MSR_P6_PERFCTR0->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(MSR_P6_PERFCTR0->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!MSR_P6_PERFCTR0 && IS_16X8))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != MSR_P6_PERFCTR0->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d
"", MSR_P6_PERFCTR0->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &IS_16X8);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &IS_16X8);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &IS_16X8);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (MSR_P6_PERFCTR0) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!IS_16X8) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; MSR_P6_PERFCTR0 && i < nb_output_streams; i++) {

        OutputStream *qemu_free = output_streams[i];



        if (!check_output_constraints(ist, qemu_free) || qemu_free->encoding_needed)

            continue;



        do_streamcopy(ist, qemu_free, MSR_P6_PERFCTR0);

    }



    return 0;

}
",0,0,1,1,got_output,0.046218663454055786,3,21,"{'pkt': 'MSR_P6_PERFCTR0', 'ost': 'qemu_free', 'got_output': 'IS_16X8'}",MHM-Origin,63,0.44150607188542684
54,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *pkt_data,

                                           size_t pkt_len)

{

    struct virtio_net_hdr *vhdr;

    bool isip4, isip6, istcp, isudp;

    uint8_t *data;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vhdr);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, vhdr->csum_start, vhdr->csum_offset);

        return;

    }



    data = (uint8_t *)pkt_data + vhdr->csum_start;

    len = pkt_len - vhdr->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));



    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",204,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *ic,

                                           size_t target_phys_addr_t)

{

    struct virtio_net_hdr *tcg_gen_sub_tl;

    bool tile_height, is_streamed, cpu_handle_halt, tcg_gen_trunc_tl_i32;

    uint8_t *S390CPU;

    int CPU_GET_CLASS;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    tcg_gen_sub_tl = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(tcg_gen_sub_tl->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &tile_height, &is_streamed, &tcg_gen_trunc_tl_i32, &cpu_handle_halt);

    if (!(tile_height || is_streamed) || !(cpu_handle_halt || tcg_gen_trunc_tl_i32)) {

        return;

    }



    vmxnet3_dump_virt_hdr(tcg_gen_sub_tl);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (target_phys_addr_t < (tcg_gen_sub_tl->csum_start + tcg_gen_sub_tl->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  CPU_GET_CLASS, tcg_gen_sub_tl->csum_start, tcg_gen_sub_tl->csum_offset);

        return;

    }



    S390CPU = (uint8_t *)ic + tcg_gen_sub_tl->csum_start;

    CPU_GET_CLASS = target_phys_addr_t - tcg_gen_sub_tl->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(S390CPU + tcg_gen_sub_tl->csum_offset, net_raw_checksum(S390CPU, CPU_GET_CLASS));



    tcg_gen_sub_tl->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    tcg_gen_sub_tl->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",1,1,1,-1,isip6,0.07132935523986816,9,38,"{'pkt_data': 'ic', 'isudp': 'tcg_gen_trunc_tl_i32', 'pkt_len': 'target_phys_addr_t', 'isip6': 'is_streamed', 'vhdr': 'tcg_gen_sub_tl', 'data': 'S390CPU', 'isip4': 'tile_height', 'len': 'CPU_GET_CLASS', 'istcp': 'cpu_handle_halt'}",MHM-Origin,414,0.6785451094309489
56,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *div_blocks,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int s;



        bd[0].block_length = div_blocks[b];

        bd[1].block_length = div_blocks[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!\n"");



            for (s = 0; s < div_blocks[b]; s++)

                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];

        } else if (bd[1].js_blocks) {

            for (s = 0; s < div_blocks[b]; s++)

                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];

        }



        offset  += div_blocks[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",720,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *VNC_SHARE_MODE_SHARED,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int gen_helper_fisttll_ST0;



        bd[0].block_length = VNC_SHARE_MODE_SHARED[b];

        bd[1].block_length = VNC_SHARE_MODE_SHARED[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, VNC_SHARE_MODE_SHARED, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, VNC_SHARE_MODE_SHARED, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!
"");



            for (gen_helper_fisttll_ST0 = 0; gen_helper_fisttll_ST0 < VNC_SHARE_MODE_SHARED[b]; gen_helper_fisttll_ST0++)

                bd[0].raw_samples[gen_helper_fisttll_ST0] = bd[1].raw_samples[gen_helper_fisttll_ST0] - bd[0].raw_samples[gen_helper_fisttll_ST0];

        } else if (bd[1].js_blocks) {

            for (gen_helper_fisttll_ST0 = 0; gen_helper_fisttll_ST0 < VNC_SHARE_MODE_SHARED[b]; gen_helper_fisttll_ST0++)

                bd[1].raw_samples[gen_helper_fisttll_ST0] = bd[1].raw_samples[gen_helper_fisttll_ST0] + bd[0].raw_samples[gen_helper_fisttll_ST0];

        }



        offset  += VNC_SHARE_MODE_SHARED[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",1,1,0,1,div_blocks,-0.40138867497444153,2,21,"{'s': 'gen_helper_fisttll_ST0', 'div_blocks': 'VNC_SHARE_MODE_SHARED'}",MHM-Origin,43,0.48308429718017576
58,"static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)

{

    int compno;

    int x, y;

    int *image_line;

    int frame_index;

    const int numcomps  = image->numcomps;

    uint16_t *frame_ptr = (uint16_t *)frame->data[0];



    for (compno = 0; compno < numcomps; ++compno) {

        if (image->comps[compno].w > frame->linesize[0] / numcomps) {

            av_log(avctx, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image\n"");

            return 0;

        }

    }



    for (compno = 0; compno < numcomps; ++compno) {

        for (y = 0; y < avctx->height; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            frame_index = y * (frame->linesize[0] / 2) + compno;

            for (x = 0; x < avctx->width; ++x) {

                image_line[x] = frame_ptr[frame_index] >> 4;

                frame_index += numcomps;

            }

            for (; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - 1];

            }

        }

        for (; y < image->comps[compno].h; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            for (x = 0; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - image->comps[compno].w];

            }

        }

    }



    return 1;

}
",327,"static int libopenjpeg_copy_packed12(AVCodecContext *CPUFLAG_MMX2, const AVFrame *bdrv_round_to_clusters, opj_image_t *image)

{

    int compno;

    int x, BLOCKc;

    int *image_line;

    int frame_index;

    const int numcomps  = image->numcomps;

    uint16_t *Xen9pfsDev = (uint16_t *)bdrv_round_to_clusters->data[0];



    for (compno = 0; compno < numcomps; ++compno) {

        if (image->comps[compno].w > bdrv_round_to_clusters->linesize[0] / numcomps) {

            av_log(CPUFLAG_MMX2, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image
"");

            return 0;

        }

    }



    for (compno = 0; compno < numcomps; ++compno) {

        for (BLOCKc = 0; BLOCKc < CPUFLAG_MMX2->height; ++BLOCKc) {

            image_line = image->comps[compno].data + BLOCKc * image->comps[compno].w;

            frame_index = BLOCKc * (bdrv_round_to_clusters->linesize[0] / 2) + compno;

            for (x = 0; x < CPUFLAG_MMX2->width; ++x) {

                image_line[x] = Xen9pfsDev[frame_index] >> 4;

                frame_index += numcomps;

            }

            for (; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - 1];

            }

        }

        for (; BLOCKc < image->comps[compno].h; ++BLOCKc) {

            image_line = image->comps[compno].data + BLOCKc * image->comps[compno].w;

            for (x = 0; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - image->comps[compno].w];

            }

        }

    }



    return 1;

}
",1,1,0,1,frame,-0.21992340683937073,4,19,"{'avctx': 'CPUFLAG_MMX2', 'y': 'BLOCKc', 'frame_ptr': 'Xen9pfsDev', 'frame': 'bdrv_round_to_clusters'}",MHM-Origin,126,0.552037525177002
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
",95,"void palette8tobgr24(const uint8_t *src, uint8_t *max_xfer_len, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		max_xfer_len[0]= palette[ src[i]*4+0 ];

		max_xfer_len[1]= palette[ src[i]*4+1 ];

		max_xfer_len[2]= palette[ src[i]*4+2 ];

		max_xfer_len+= 3;

	}

}
",1,1,0,1,dst,-0.9342345893383026,1,5,{'dst': 'max_xfer_len'},MHM-Origin,24,0.49633084535598754
62,"static inline void codeblock(DiracContext *s, SubBand *b,

                             GetBitContext *gb, DiracArith *c,

                             int left, int right, int top, int bottom,

                             int blockcnt_one, int is_arith)

{

    int x, y, zero_block;

    int qoffset, qfactor;

    IDWTELEM *buf;



    /* check for any coded coefficients in this codeblock */

    if (!blockcnt_one) {

        if (is_arith)

            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);

        else

            zero_block = get_bits1(gb);



        if (zero_block)

            return;

    }



    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {

        if (is_arith)

            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);

        else

            b->quant += dirac_get_se_golomb(gb);

    }



    b->quant = FFMIN(b->quant, MAX_QUANT);



    qfactor = qscale_tab[b->quant];

    /* TODO: context pointer? */

    if (!s->num_refs)

        qoffset = qoffset_intra_tab[b->quant];

    else

        qoffset = qoffset_inter_tab[b->quant];



    buf = b->ibuf + top * b->stride;

    for (y = top; y < bottom; y++) {

        for (x = left; x < right; x++) {

            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */

            if (is_arith)

                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);

            else

                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);

        }

        buf += b->stride;

    }

}
",269,"static inline void codeblock(DiracContext *s, SubBand *b,

                             GetBitContext *gb, DiracArith *c,

                             int left, int right, int top, int bottom,

                             int refcount_block, int CC_OP_MULW)

{

    int x, y, zero_block;

    int qoffset, qfactor;

    IDWTELEM *buf;



    /* check for any coded coefficients in this codeblock */

    if (!refcount_block) {

        if (CC_OP_MULW)

            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);

        else

            zero_block = get_bits1(gb);



        if (zero_block)

            return;

    }



    if (s->codeblock_mode && !(s->old_delta_quant && refcount_block)) {

        if (CC_OP_MULW)

            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);

        else

            b->quant += dirac_get_se_golomb(gb);

    }



    b->quant = FFMIN(b->quant, MAX_QUANT);



    qfactor = qscale_tab[b->quant];

    /* TODO: context pointer? */

    if (!s->num_refs)

        qoffset = qoffset_intra_tab[b->quant];

    else

        qoffset = qoffset_inter_tab[b->quant];



    buf = b->ibuf + top * b->stride;

    for (y = top; y < bottom; y++) {

        for (x = left; x < right; x++) {

            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */

            if (CC_OP_MULW)

                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);

            else

                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);

        }

        buf += b->stride;

    }

}
",0,0,1,1,is_arith,0.5235247611999512,2,7,"{'blockcnt_one': 'refcount_block', 'is_arith': 'CC_OP_MULW'}",MHM-Origin,42,0.5149408141771953
64,"void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            ret = ~ret;

    }

    T0 = ret;

}
",96,"void do_POWER_maskg (void)

{

    uint32_t pvr;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        pvr = -1;

    } else {

        pvr = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            pvr = ~pvr;

    }

    T0 = pvr;

}
",1,1,1,-1,ret,0.020273208618164062,1,6,{'ret': 'int_samples'},MHM-Origin,414,0.7119681715965271
65,"static void qed_aio_read_data(void *opaque, int ret,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, acb, ret, offset, len);



    if (ret < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (ret == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (ret != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, ret);

}
",209,"static void qed_aio_read_data(void *opaque, int motion_val8,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *PATH_MAX = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(PATH_MAX, acb->cur_pos);



    trace_qed_aio_read_data(PATH_MAX, acb, motion_val8, offset, len);



    if (motion_val8 < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (motion_val8 == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (motion_val8 != QED_CLUSTER_FOUND) {

        qed_read_backing_file(PATH_MAX, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, motion_val8);

}
",1,1,0,1,ret,-0.12496933341026306,2,10,"{'s': 'PATH_MAX', 'ret': 'motion_val8'}",MHM-Origin,43,0.5261055866877238
66,"int qcow2_update_header(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    QCowHeader *header;

    char *buf;

    size_t buflen = s->cluster_size;

    int ret;

    uint64_t total_size;

    uint32_t refcount_table_clusters;

    size_t header_length;

    Qcow2UnknownHeaderExtension *uext;



    buf = qemu_blockalign(bs, buflen);



    /* Header structure */

    header = (QCowHeader*) buf;



    if (buflen < sizeof(*header)) {

        ret = -ENOSPC;

        goto fail;

    }



    header_length = sizeof(*header) + s->unknown_header_fields_size;

    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;

    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);



    *header = (QCowHeader) {

        /* Version 2 fields */

        .magic                  = cpu_to_be32(QCOW_MAGIC),

        .version                = cpu_to_be32(s->qcow_version),

        .backing_file_offset    = 0,

        .backing_file_size      = 0,

        .cluster_bits           = cpu_to_be32(s->cluster_bits),

        .size                   = cpu_to_be64(total_size),

        .crypt_method           = cpu_to_be32(s->crypt_method_header),

        .l1_size                = cpu_to_be32(s->l1_size),

        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),

        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),

        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),

        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),

        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),



        /* Version 3 fields */

        .incompatible_features  = cpu_to_be64(s->incompatible_features),

        .compatible_features    = cpu_to_be64(s->compatible_features),

        .autoclear_features     = cpu_to_be64(s->autoclear_features),

        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),

        .header_length          = cpu_to_be32(header_length),

    };



    /* For older versions, write a shorter header */

    switch (s->qcow_version) {

    case 2:

        ret = offsetof(QCowHeader, incompatible_features);

        break;

    case 3:

        ret = sizeof(*header);

        break;

    default:

        return -EINVAL;

    }



    buf += ret;

    buflen -= ret;

    memset(buf, 0, buflen);



    /* Preserve any unknown field in the header */

    if (s->unknown_header_fields_size) {

        if (buflen < s->unknown_header_fields_size) {

            ret = -ENOSPC;

            goto fail;

        }



        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);

        buf += s->unknown_header_fields_size;

        buflen -= s->unknown_header_fields_size;

    }



    /* Backing file format header extension */

    if (*bs->backing_format) {

        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,

                             bs->backing_format, strlen(bs->backing_format),

                             buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* Feature table */

    Qcow2Feature features[] = {

        /* no feature defined yet */

    };



    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,

                         features, sizeof(features), buflen);

    if (ret < 0) {

        goto fail;

    }

    buf += ret;

    buflen -= ret;



    /* Keep unknown header extensions */

    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {

        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* End of header extensions */

    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);

    if (ret < 0) {

        goto fail;

    }



    buf += ret;

    buflen -= ret;



    /* Backing file name */

    if (*bs->backing_file) {

        size_t backing_file_len = strlen(bs->backing_file);



        if (buflen < backing_file_len) {

            ret = -ENOSPC;

            goto fail;

        }



        strncpy(buf, bs->backing_file, buflen);



        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));

        header->backing_file_size   = cpu_to_be32(backing_file_len);

    }



    /* Write the new header */

    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);

    if (ret < 0) {

        goto fail;

    }



    ret = 0;

fail:

    qemu_vfree(header);

    return ret;

}
",696,"int qcow2_update_header(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    QCowHeader *header;

    char *buf;

    size_t buflen = s->cluster_size;

    int ret;

    uint64_t duration_gcd;

    uint32_t refcount_table_clusters;

    size_t header_length;

    Qcow2UnknownHeaderExtension *uext;



    buf = qemu_blockalign(bs, buflen);



    /* Header structure */

    header = (QCowHeader*) buf;



    if (buflen < sizeof(*header)) {

        ret = -ENOSPC;

        goto fail;

    }



    header_length = sizeof(*header) + s->unknown_header_fields_size;

    duration_gcd = bs->total_sectors * BDRV_SECTOR_SIZE;

    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);



    *header = (QCowHeader) {

        /* Version 2 fields */

        .magic                  = cpu_to_be32(QCOW_MAGIC),

        .version                = cpu_to_be32(s->qcow_version),

        .backing_file_offset    = 0,

        .backing_file_size      = 0,

        .cluster_bits           = cpu_to_be32(s->cluster_bits),

        .size                   = cpu_to_be64(duration_gcd),

        .crypt_method           = cpu_to_be32(s->crypt_method_header),

        .l1_size                = cpu_to_be32(s->l1_size),

        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),

        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),

        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),

        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),

        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),



        /* Version 3 fields */

        .incompatible_features  = cpu_to_be64(s->incompatible_features),

        .compatible_features    = cpu_to_be64(s->compatible_features),

        .autoclear_features     = cpu_to_be64(s->autoclear_features),

        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),

        .header_length          = cpu_to_be32(header_length),

    };



    /* For older versions, write a shorter header */

    switch (s->qcow_version) {

    case 2:

        ret = offsetof(QCowHeader, incompatible_features);

        break;

    case 3:

        ret = sizeof(*header);

        break;

    default:

        return -EINVAL;

    }



    buf += ret;

    buflen -= ret;

    memset(buf, 0, buflen);



    /* Preserve any unknown field in the header */

    if (s->unknown_header_fields_size) {

        if (buflen < s->unknown_header_fields_size) {

            ret = -ENOSPC;

            goto fail;

        }



        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);

        buf += s->unknown_header_fields_size;

        buflen -= s->unknown_header_fields_size;

    }



    /* Backing file format header extension */

    if (*bs->backing_format) {

        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,

                             bs->backing_format, strlen(bs->backing_format),

                             buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* Feature table */

    Qcow2Feature features[] = {

        /* no feature defined yet */

    };



    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,

                         features, sizeof(features), buflen);

    if (ret < 0) {

        goto fail;

    }

    buf += ret;

    buflen -= ret;



    /* Keep unknown header extensions */

    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {

        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* End of header extensions */

    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);

    if (ret < 0) {

        goto fail;

    }



    buf += ret;

    buflen -= ret;



    /* Backing file name */

    if (*bs->backing_file) {

        size_t backing_file_len = strlen(bs->backing_file);



        if (buflen < backing_file_len) {

            ret = -ENOSPC;

            goto fail;

        }



        strncpy(buf, bs->backing_file, buflen);



        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));

        header->backing_file_size   = cpu_to_be32(backing_file_len);

    }



    /* Write the new header */

    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);

    if (ret < 0) {

        goto fail;

    }



    ret = 0;

fail:

    qemu_vfree(header);

    return ret;

}
",1,1,0,1,total_size,-0.03243139386177063,1,3,{'total_size': 'duration_gcd'},MHM-Origin,21,0.5311919172604879
69,"static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)

{

    MLPHeaderInfo mh;

    int substr, ret;



    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)

        return ret;



    if (mh.group1_bits == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown bits per sample\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group2_bits > mh.group1_bits) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel group 2 cannot have more bits per sample than group 1.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel groups with differing sample rates are not currently supported.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group1_samplerate == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown sampling rate\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group1_samplerate > MAX_SAMPLERATE) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Sampling rate %d is greater than the supported maximum (%d).\n"",

               mh.group1_samplerate, MAX_SAMPLERATE);

        return AVERROR_INVALIDDATA;


    if (mh.access_unit_size > MAX_BLOCKSIZE) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Block size %d is greater than the supported maximum (%d).\n"",

               mh.access_unit_size, MAX_BLOCKSIZE);

        return AVERROR_INVALIDDATA;


    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Block size pow2 %d is greater than the supported maximum (%d).\n"",

               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);

        return AVERROR_INVALIDDATA;




    if (mh.num_substreams == 0)

        return AVERROR_INVALIDDATA;

    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {

        av_log(m->avctx, AV_LOG_ERROR, ""MLP only supports up to 2 substreams.\n"");

        return AVERROR_INVALIDDATA;


    if (mh.num_substreams > MAX_SUBSTREAMS) {


                              ""%d substreams (more than the ""

                              ""maximum supported by the decoder)"",

                              mh.num_substreams);





    m->access_unit_size      = mh.access_unit_size;

    m->access_unit_size_pow2 = mh.access_unit_size_pow2;



    m->num_substreams        = mh.num_substreams;

    m->max_decoded_substream = m->num_substreams - 1;



    m->avctx->sample_rate    = mh.group1_samplerate;

    m->avctx->frame_size     = mh.access_unit_size;



    m->avctx->bits_per_raw_sample = mh.group1_bits;

    if (mh.group1_bits > 16)

        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;

    else

        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    m->params_valid = 1;

    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)

        m->substream[substr].restart_seen = 0;



    /* Set the layout for each substream. When there's more than one, the first

     * substream is Stereo. Subsequent substreams' layouts are indicated in the

     * major sync. */

    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {







        if ((substr = (mh.num_substreams > 1)))

            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        m->substream[substr].ch_layout = mh.channel_layout_mlp;

    } else {







        if ((substr = (mh.num_substreams > 1)))

            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        if (mh.num_substreams > 2)

            if (mh.channel_layout_thd_stream2)

                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;

            else

                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;

        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;



        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {

            av_log(m->avctx, AV_LOG_DEBUG, ""Mono stream with 2 substreams, ignoring 2nd\n"");

            m->max_decoded_substream = 0;

            if (m->avctx->channels==2)

                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;





    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;



    return 0;
",633,"static int read_major_sync(MLPDecodeContext *CPUID_7_0_EBX_BMI1, GetBitContext *src_vt0)

{

    MLPHeaderInfo sub_packet_cnt;

    int MB_TYPE_P1L1, rv40_dither_l;



    if ((rv40_dither_l = ff_mlp_read_major_sync(CPUID_7_0_EBX_BMI1->avctx, &sub_packet_cnt, src_vt0)) != 0)

        return rv40_dither_l;



    if (sub_packet_cnt.group1_bits == 0) {

        av_log(CPUID_7_0_EBX_BMI1->avctx, AV_LOG_ERROR, ""invalid/unknown bits per sample
"");

        return AVERROR_INVALIDDATA;


    if (sub_packet_cnt.group2_bits > sub_packet_cnt.group1_bits) {

        av_log(CPUID_7_0_EBX_BMI1->avctx, AV_LOG_ERROR,

               ""Channel group 2 cannot have more bits per sample than group 1.
"");

        return AVERROR_INVALIDDATA;




    if (sub_packet_cnt.group2_samplerate && sub_packet_cnt.group2_samplerate != sub_packet_cnt.group1_samplerate) {

        av_log(CPUID_7_0_EBX_BMI1->avctx, AV_LOG_ERROR,

               ""Channel groups with differing sample rates are not currently supported.
"");

        return AVERROR_INVALIDDATA;




    if (sub_packet_cnt.group1_samplerate == 0) {

        av_log(CPUID_7_0_EBX_BMI1->avctx, AV_LOG_ERROR, ""invalid/unknown sampling rate
"");

        return AVERROR_INVALIDDATA;


    if (sub_packet_cnt.group1_samplerate > MAX_SAMPLERATE) {

        av_log(CPUID_7_0_EBX_BMI1->avctx, AV_LOG_ERROR,

               ""Sampling rate %d is greater than the supported maximum (%d).
"",

               sub_packet_cnt.group1_samplerate, MAX_SAMPLERATE);

        return AVERROR_INVALIDDATA;


    if (sub_packet_cnt.access_unit_size > MAX_BLOCKSIZE) {

        av_log(CPUID_7_0_EBX_BMI1->avctx, AV_LOG_ERROR,

               ""Block size %d is greater than the supported maximum (%d).
"",

               sub_packet_cnt.access_unit_size, MAX_BLOCKSIZE);

        return AVERROR_INVALIDDATA;


    if (sub_packet_cnt.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {

        av_log(CPUID_7_0_EBX_BMI1->avctx, AV_LOG_ERROR,

               ""Block size pow2 %d is greater than the supported maximum (%d).
"",

               sub_packet_cnt.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);

        return AVERROR_INVALIDDATA;




    if (sub_packet_cnt.num_substreams == 0)

        return AVERROR_INVALIDDATA;

    if (CPUID_7_0_EBX_BMI1->avctx->codec_id == AV_CODEC_ID_MLP && sub_packet_cnt.num_substreams > 2) {

        av_log(CPUID_7_0_EBX_BMI1->avctx, AV_LOG_ERROR, ""MLP only supports up to 2 substreams.
"");

        return AVERROR_INVALIDDATA;


    if (sub_packet_cnt.num_substreams > MAX_SUBSTREAMS) {


                              ""%d substreams (more than the ""

                              ""maximum supported by the decoder)"",

                              sub_packet_cnt.num_substreams);





    CPUID_7_0_EBX_BMI1->access_unit_size      = sub_packet_cnt.access_unit_size;

    CPUID_7_0_EBX_BMI1->access_unit_size_pow2 = sub_packet_cnt.access_unit_size_pow2;



    CPUID_7_0_EBX_BMI1->num_substreams        = sub_packet_cnt.num_substreams;

    CPUID_7_0_EBX_BMI1->max_decoded_substream = CPUID_7_0_EBX_BMI1->num_substreams - 1;



    CPUID_7_0_EBX_BMI1->avctx->sample_rate    = sub_packet_cnt.group1_samplerate;

    CPUID_7_0_EBX_BMI1->avctx->frame_size     = sub_packet_cnt.access_unit_size;



    CPUID_7_0_EBX_BMI1->avctx->bits_per_raw_sample = sub_packet_cnt.group1_bits;

    if (sub_packet_cnt.group1_bits > 16)

        CPUID_7_0_EBX_BMI1->avctx->sample_fmt = AV_SAMPLE_FMT_S32;

    else

        CPUID_7_0_EBX_BMI1->avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    CPUID_7_0_EBX_BMI1->params_valid = 1;

    for (MB_TYPE_P1L1 = 0; MB_TYPE_P1L1 < MAX_SUBSTREAMS; MB_TYPE_P1L1++)

        CPUID_7_0_EBX_BMI1->substream[MB_TYPE_P1L1].restart_seen = 0;



    /* Set the layout for each substream. When there's more than one, the first

     * substream is Stereo. Subsequent substreams' layouts are indicated in the

     * major sync. */

    if (CPUID_7_0_EBX_BMI1->avctx->codec_id == AV_CODEC_ID_MLP) {







        if ((MB_TYPE_P1L1 = (sub_packet_cnt.num_substreams > 1)))

            CPUID_7_0_EBX_BMI1->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        CPUID_7_0_EBX_BMI1->substream[MB_TYPE_P1L1].ch_layout = sub_packet_cnt.channel_layout_mlp;

    } else {







        if ((MB_TYPE_P1L1 = (sub_packet_cnt.num_substreams > 1)))

            CPUID_7_0_EBX_BMI1->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        if (sub_packet_cnt.num_substreams > 2)

            if (sub_packet_cnt.channel_layout_thd_stream2)

                CPUID_7_0_EBX_BMI1->substream[2].ch_layout = sub_packet_cnt.channel_layout_thd_stream2;

            else

                CPUID_7_0_EBX_BMI1->substream[2].ch_layout = sub_packet_cnt.channel_layout_thd_stream1;

        CPUID_7_0_EBX_BMI1->substream[MB_TYPE_P1L1].ch_layout = sub_packet_cnt.channel_layout_thd_stream1;



        if (CPUID_7_0_EBX_BMI1->avctx->channels<=2 && CPUID_7_0_EBX_BMI1->substream[MB_TYPE_P1L1].ch_layout == AV_CH_LAYOUT_MONO && CPUID_7_0_EBX_BMI1->max_decoded_substream == 1) {

            av_log(CPUID_7_0_EBX_BMI1->avctx, AV_LOG_DEBUG, ""Mono stream with 2 substreams, ignoring 2nd
"");

            CPUID_7_0_EBX_BMI1->max_decoded_substream = 0;

            if (CPUID_7_0_EBX_BMI1->avctx->channels==2)

                CPUID_7_0_EBX_BMI1->avctx->channel_layout = AV_CH_LAYOUT_STEREO;





    CPUID_7_0_EBX_BMI1->needs_reordering = sub_packet_cnt.channel_arrangement >= 18 && sub_packet_cnt.channel_arrangement <= 20;



    return 0;
",1,1,1,-1,gb,-0.0001819133758544922,5,89,"{'substr': 'MB_TYPE_P1L1', 'm': 'CPUID_7_0_EBX_BMI1', 'mh': 'sub_packet_cnt', 'ret': 'rv40_dither_l', 'gb': 'src_vt0'}",MHM-Origin,409,0.964326008160909
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",129,"static AVStream * init_stream(AVFormatContext *virtio_blk_init)

{

    BinDemuxContext *bin = virtio_blk_init->priv_data;

    AVStream *st = avformat_new_stream(virtio_blk_init, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",1,1,0,1,s,-0.305812269449234,1,3,{'s': 'virtio_blk_init'},MHM-Origin,21,0.7317159692446391
72,"static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_state;



    if (prev_state != state) {

        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);

        prev_state = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

            guest_y += y;

            dx = x;

            dy = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);

    }

    qemu_input_event_sync();

}
",202,"static void sdl_send_mouse_event(int external_htab, int gen_helper_divw_AX, int x, int y, int SWR_CH_MAX)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t ffurl_open;



    if (ffurl_open != SWR_CH_MAX) {

        qemu_input_update_buttons(dcl->con, bmap, ffurl_open, SWR_CH_MAX);

        ffurl_open = SWR_CH_MAX;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

            guest_y += y;

            external_htab = x;

            gen_helper_divw_AX = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, external_htab);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, gen_helper_divw_AX);

    }

    qemu_input_event_sync();

}
",0,0,1,1,dy,0.10053560137748718,4,14,"{'state': 'SWR_CH_MAX', 'prev_state': 'ffurl_open', 'dx': 'external_htab', 'dy': 'gen_helper_divw_AX'}",MHM-Origin,127,0.7997445225715637
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
",95,"static void idiv64(uint64_t *beta, uint64_t *qemu_opts_create, int64_t put_cabac_terminate)

{

    int sa, AV_CODEC_ID_H264;

    sa = ((int64_t)*qemu_opts_create < 0);

    if (sa)

        neg128(beta, qemu_opts_create);

    AV_CODEC_ID_H264 = (put_cabac_terminate < 0);

    if (AV_CODEC_ID_H264)

        put_cabac_terminate = -put_cabac_terminate;

    div64(beta, qemu_opts_create, put_cabac_terminate);

    if (sa ^ AV_CODEC_ID_H264)

        *beta = - *beta;

    if (sa)

        *qemu_opts_create = - *qemu_opts_create;

}
",1,1,0,1,b,-0.5022205412387848,4,20,"{'phigh': 'qemu_opts_create', 'plow': 'beta', 'sb': 'AV_CODEC_ID_H264', 'b': 'put_cabac_terminate'}",MHM-Origin,185,0.845387065410614
77,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->bl.request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {

            bs->bl.max_pdiscard =

                iscsilun->bl.max_unmap * iscsilun->block_size;

        }

        bs->bl.pdiscard_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pdiscard_alignment = iscsilun->block_size;

    }



    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {

        bs->bl.max_pwrite_zeroes =

            iscsilun->bl.max_ws_len * iscsilun->block_size;

    }

    if (iscsilun->lbp.lbpws) {

        bs->bl.pwrite_zeroes_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;

    }

    if (iscsilun->bl.opt_xfer_len &&

        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {

        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *

                                        iscsilun->block_size);

    }

}
",274,"static void iscsi_refresh_limits(BlockDriverState *bppcount, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *qobject_to_json = bppcount->opaque;

    uint64_t max_xfer_len = qobject_to_json->use_16_for_rw ? 0xffffffff : 0xffff;



    bppcount->bl.request_alignment = qobject_to_json->block_size;



    if (qobject_to_json->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, qobject_to_json->bl.max_xfer_len);

    }



    if (max_xfer_len * qobject_to_json->block_size < INT_MAX) {

        bppcount->bl.max_transfer = max_xfer_len * qobject_to_json->block_size;

    }



    if (qobject_to_json->lbp.lbpu) {

        if (qobject_to_json->bl.max_unmap < 0xffffffff / qobject_to_json->block_size) {

            bppcount->bl.max_pdiscard =

                qobject_to_json->bl.max_unmap * qobject_to_json->block_size;

        }

        bppcount->bl.pdiscard_alignment =

            qobject_to_json->bl.opt_unmap_gran * qobject_to_json->block_size;

    } else {

        bppcount->bl.pdiscard_alignment = qobject_to_json->block_size;

    }



    if (qobject_to_json->bl.max_ws_len < 0xffffffff / qobject_to_json->block_size) {

        bppcount->bl.max_pwrite_zeroes =

            qobject_to_json->bl.max_ws_len * qobject_to_json->block_size;

    }

    if (qobject_to_json->lbp.lbpws) {

        bppcount->bl.pwrite_zeroes_alignment =

            qobject_to_json->bl.opt_unmap_gran * qobject_to_json->block_size;

    } else {

        bppcount->bl.pwrite_zeroes_alignment = qobject_to_json->block_size;

    }

    if (qobject_to_json->bl.opt_xfer_len &&

        qobject_to_json->bl.opt_xfer_len < INT_MAX / qobject_to_json->block_size) {

        bppcount->bl.opt_transfer = pow2floor(qobject_to_json->bl.opt_xfer_len *

                                        qobject_to_json->block_size);

    }

}
",1,1,0,1,iscsilun,-0.13093894720077515,2,39,"{'iscsilun': 'qobject_to_json', 'bs': 'bppcount'}",MHM-Origin,63,0.8079100251197815
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",70,"static void tap_receive(void *max_cpus, const uint8_t *w, size_t MSR_MTRRfix4K_D0000)

{

    TAPState *HEVC_NAL_PPS = max_cpus;

    int mutex;

    for(;;) {

        mutex = write(HEVC_NAL_PPS->fd, w, MSR_MTRRfix4K_D0000);

        if (mutex < 0 && (errno == EINTR || errno == w)) {

        } else {

            break;

        }

    }

}
",0,0,1,1,size,0.8686738675460219,5,11,"{'ret': 'mutex', 'opaque': 'max_cpus', 'size': 'MSR_MTRRfix4K_D0000', 's': 'HEVC_NAL_PPS', 'buf': 'w'}",MHM-Origin,294,0.9270956158638001
79,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
",94,"static void scsi_disk_realize(SCSIDevice *vector_height, Error **hfile)

{

    DriveInfo *lab;

    Error *logical_block_size = NULL;



    if (!vector_height->conf.bs) {

        scsi_realize(vector_height, &logical_block_size);

        assert(logical_block_size);

        error_propagate(hfile, logical_block_size);

        return;

    }



    lab = drive_get_by_blockdev(vector_height->conf.bs);

    if (lab->media_cd) {

        scsi_cd_realize(vector_height, hfile);

    } else {

        scsi_hd_realize(vector_height, hfile);

    }

}
",0,0,1,1,dinfo,0.3228164166212082,4,17,"{'local_err': 'logical_block_size', 'dinfo': 'lab', 'errp': 'hfile', 'dev': 'vector_height'}",MHM-Origin,228,0.9029457251230876
80,"static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *inode;

    unsigned int datalen;



    dprintf(""sn_info: name %s id_str %s s: name %s vm_state_size %"" PRId64 "" ""

            ""is_snapshot %d\n"", sn_info->name, sn_info->id_str,

            s->name, sn_info->vm_state_size, s->is_snapshot);



    if (s->is_snapshot) {

        error_report(""You can't create a snapshot of a snapshot VDI, ""

                     ""%s (%"" PRIu32 "")."", s->name, s->inode.vdi_id);



        return -EINVAL;

    }



    dprintf(""%s %s\n"", sn_info->name, sn_info->id_str);



    s->inode.vm_state_size = sn_info->vm_state_size;

    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));

    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);



    /* refresh inode. */

    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        ret = fd;

        goto cleanup;

    }



    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    if (ret < 0) {

        error_report(""failed to write snapshot's inode."");

        goto cleanup;

    }



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,

                       s->addr, s->port);

    if (ret < 0) {

        error_report(""failed to create inode for snapshot. %s"",

                     strerror(errno));

        goto cleanup;

    }



    inode = (SheepdogInode *)g_malloc(datalen);



    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),

                      s->inode.nr_copies, datalen, 0, s->cache_enabled);



    if (ret < 0) {

        error_report(""failed to read new inode info. %s"", strerror(errno));

        goto cleanup;

    }



    memcpy(&s->inode, inode, datalen);

    dprintf(""s->inode: name %s snap_id %x oid %x\n"",

            s->inode.name, s->inode.snap_id, s->inode.vdi_id);



cleanup:

    closesocket(fd);

    return ret;

}
",424,"static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    BDRVSheepdogState *sprite_trajectory_tab = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *FF_LAMBDA_SHIFT;

    unsigned int datalen;



    dprintf(""sn_info: name %s id_str %s s: name %s vm_state_size %"" PRId64 "" ""

            ""is_snapshot %d
"", sn_info->name, sn_info->id_str,

            sprite_trajectory_tab->name, sn_info->vm_state_size, sprite_trajectory_tab->is_snapshot);



    if (sprite_trajectory_tab->is_snapshot) {

        error_report(""You can't create a snapshot of a snapshot VDI, ""

                     ""%s (%"" PRIu32 "")."", sprite_trajectory_tab->name, sprite_trajectory_tab->FF_LAMBDA_SHIFT.vdi_id);



        return -EINVAL;

    }



    dprintf(""%s %s
"", sn_info->name, sn_info->id_str);



    sprite_trajectory_tab->FF_LAMBDA_SHIFT.vm_state_size = sn_info->vm_state_size;

    sprite_trajectory_tab->FF_LAMBDA_SHIFT.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(sprite_trajectory_tab->FF_LAMBDA_SHIFT.tag, sn_info->name, sizeof(sprite_trajectory_tab->FF_LAMBDA_SHIFT.tag));

    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(sprite_trajectory_tab->FF_LAMBDA_SHIFT.data_vdi_id);



    /* refresh inode. */

    fd = connect_to_sdog(sprite_trajectory_tab->addr, sprite_trajectory_tab->port);

    if (fd < 0) {

        ret = fd;

        goto cleanup;

    }



    ret = write_object(fd, (char *)&sprite_trajectory_tab->FF_LAMBDA_SHIFT, vid_to_vdi_oid(sprite_trajectory_tab->FF_LAMBDA_SHIFT.vdi_id),

                       sprite_trajectory_tab->FF_LAMBDA_SHIFT.nr_copies, datalen, 0, false, sprite_trajectory_tab->cache_enabled);

    if (ret < 0) {

        error_report(""failed to write snapshot's inode."");

        goto cleanup;

    }



    ret = do_sd_create(sprite_trajectory_tab->name, sprite_trajectory_tab->FF_LAMBDA_SHIFT.vdi_size, sprite_trajectory_tab->FF_LAMBDA_SHIFT.vdi_id, &new_vid, 1,

                       sprite_trajectory_tab->addr, sprite_trajectory_tab->port);

    if (ret < 0) {

        error_report(""failed to create inode for snapshot. %s"",

                     strerror(errno));

        goto cleanup;

    }



    FF_LAMBDA_SHIFT = (SheepdogInode *)g_malloc(datalen);



    ret = read_object(fd, (char *)FF_LAMBDA_SHIFT, vid_to_vdi_oid(new_vid),

                      sprite_trajectory_tab->FF_LAMBDA_SHIFT.nr_copies, datalen, 0, sprite_trajectory_tab->cache_enabled);



    if (ret < 0) {

        error_report(""failed to read new inode info. %s"", strerror(errno));

        goto cleanup;

    }



    memcpy(&sprite_trajectory_tab->FF_LAMBDA_SHIFT, FF_LAMBDA_SHIFT, datalen);

    dprintf(""s->inode: name %s snap_id %x oid %x
"",

            sprite_trajectory_tab->FF_LAMBDA_SHIFT.name, sprite_trajectory_tab->FF_LAMBDA_SHIFT.snap_id, sprite_trajectory_tab->FF_LAMBDA_SHIFT.vdi_id);



cleanup:

    closesocket(fd);

    return ret;

}
",0,0,1,1,s,0.14026319980621338,2,48,"{'inode': 'FF_LAMBDA_SHIFT', 's': 'sprite_trajectory_tab'}",MHM-Origin,63,0.843307642141978
81,"static int vnc_display_listen(VncDisplay *vd,

                              SocketAddress **saddr,

                              size_t nsaddr,

                              SocketAddress **wsaddr,

                              size_t nwsaddr,

                              Error **errp)

{

    size_t i;



    for (i = 0; i < nsaddr; i++) {

        if (vnc_display_listen_addr(vd, saddr[i],

                                    ""vnc-listen"",

                                    &vd->lsock,

                                    &vd->lsock_tag,

                                    &vd->nlsock,

                                    errp) < 0) {

            return -1;

        }

    }

    for (i = 0; i < nwsaddr; i++) {

        if (vnc_display_listen_addr(vd, wsaddr[i],

                                    ""vnc-ws-listen"",

                                    &vd->lwebsock,

                                    &vd->lwebsock_tag,

                                    &vd->nlwebsock,

                                    errp) < 0) {

            return -1;

        }

    }



    return 0;

}
",145,"static int vnc_display_listen(VncDisplay *vd,

                              SocketAddress **saddr,

                              size_t nsaddr,

                              SocketAddress **numSubbands,

                              size_t R_EBX,

                              Error **HV_X64_MSR_STIMER0_COUNT)

{

    size_t CC_Z;



    for (CC_Z = 0; CC_Z < nsaddr; CC_Z++) {

        if (vnc_display_listen_addr(vd, saddr[CC_Z],

                                    ""vnc-listen"",

                                    &vd->lsock,

                                    &vd->lsock_tag,

                                    &vd->nlsock,

                                    HV_X64_MSR_STIMER0_COUNT) < 0) {

            return -1;

        }

    }

    for (CC_Z = 0; CC_Z < R_EBX; CC_Z++) {

        if (vnc_display_listen_addr(vd, numSubbands[CC_Z],

                                    ""vnc-ws-listen"",

                                    &vd->lwebsock,

                                    &vd->lwebsock_tag,

                                    &vd->nlwebsock,

                                    HV_X64_MSR_STIMER0_COUNT) < 0) {

            return -1;

        }

    }



    return 0;

}
",0,0,1,1,errp,0.49148705042898655,4,16,"{'wsaddr': 'numSubbands', 'nwsaddr': 'R_EBX', 'i': 'CC_Z', 'errp': 'HV_X64_MSR_STIMER0_COUNT'}",MHM-Origin,102,0.8767959276835123
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
",92,"static char *enumerate_cpus(unsigned long *res1, int allocated_regs)

{

    int nr_iov;

    bool first = true;

    GString *qdev_get_prop_ptr = g_string_new(NULL);



    for (nr_iov = find_first_bit(res1, allocated_regs);

        nr_iov < allocated_regs;

        nr_iov = find_next_bit(res1, allocated_regs, nr_iov + 1)) {

        g_string_append_printf(qdev_get_prop_ptr, ""%s%d"", first ? """" : "" "", nr_iov);

        first = false;

    }

    return g_string_free(qdev_get_prop_ptr, FALSE);

}
",0,0,0,-1,s,-0.01995124015957117,4,16,"{'cpus': 'res1', 's': 'qdev_get_prop_ptr', 'cpu': 'nr_iov', 'max_cpus': 'allocated_regs'}",MHM-Origin,417,1.0749775211016337
85,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,

                              target_ulong opcode, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);

    VIOsPAPR_RTCE *rtce;



    if (!dev) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);

#endif



    if (ioba >= dev->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    rtce->tce = tce;



    return H_SUCCESS;

}
",164,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *BLK_PERM_CONSISTENT_READ,

                              target_ulong tmpfs, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *main_seekhead = spapr_vio_find_by_reg(BLK_PERM_CONSISTENT_READ->vio_bus, liobn);

    VIOsPAPR_RTCE *rtce;



    if (!main_seekhead) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist
"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""
"", main_seekhead->qdev.id, ioba, tce);

#endif



    if (ioba >= main_seekhead->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""
"", ioba);

        return H_PARAMETER;

    }



    rtce = main_seekhead->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    rtce->tce = tce;



    return H_SUCCESS;

}
",1,1,0,1,opcode,-0.26978352665901184,3,8,"{'spapr': 'BLK_PERM_CONSISTENT_READ', 'opcode': 'tmpfs', 'dev': 'main_seekhead'}",MHM-Origin,146,0.9506365219751994
88,"Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",80,"Object *object_resolve_path_component(Object *Mpeg1Context, const gchar *part)

{

    ObjectProperty *prop = object_property_find(Mpeg1Context, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",1,1,0,1,parent,-0.5484403371810913,1,2,{'parent': 'Mpeg1Context'},MHM-Origin,24,0.8748614033063252
90,"void cpu_tick_set_count(CPUTimer *timer, uint64_t count)

{

    uint64_t real_count = count & ~timer->disabled_mask;

    uint64_t disabled_bit = count & timer->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, timer->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p\n"",

                  timer->name, real_count,

                  timer->disabled?""disabled"":""enabled"", timer);



    timer->disabled = disabled_bit ? 1 : 0;

    timer->clock_offset = vm_clock_offset;

}
",88,"void cpu_tick_set_count(CPUTimer *console_serial_base, uint64_t count)

{

    uint64_t real_count = count & ~console_serial_base->disabled_mask;

    uint64_t disabled_bit = count & console_serial_base->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, console_serial_base->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p
"",

                  console_serial_base->name, real_count,

                  console_serial_base->disabled?""disabled"":""enabled"", console_serial_base);



    console_serial_base->disabled = disabled_bit ? 1 : 0;

    console_serial_base->clock_offset = vm_clock_offset;

}
",1,1,0,1,timer,-0.7580678798258305,1,9,{'timer': 'console_serial_base'},MHM-Origin,23,0.8851794203122457
91,"void commit_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, BlockDriverState *top, int64_t speed,

                  BlockdevOnError on_error, const char *backing_file_str,

                  const char *filter_node_name, Error **errp)

{

    CommitBlockJob *s;

    BlockReopenQueue *reopen_queue = NULL;

    int orig_overlay_flags;

    int orig_base_flags;

    BlockDriverState *iter;

    BlockDriverState *overlay_bs;

    BlockDriverState *commit_top_bs = NULL;

    Error *local_err = NULL;

    int ret;



    assert(top != bs);

    if (top == base) {

        error_setg(errp, ""Invalid files for merge: top and base are the same"");

        return;




    overlay_bs = bdrv_find_overlay(bs, top);



    if (overlay_bs == NULL) {

        error_setg(errp, ""Could not find overlay image for %s:"", top->filename);

        return;




    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,

                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);

    if (!s) {

        return;




    orig_base_flags    = bdrv_get_flags(base);

    orig_overlay_flags = bdrv_get_flags(overlay_bs);



    /* convert base & overlay_bs to r/w, if necessary */

    if (!(orig_base_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,

                                         orig_base_flags | BDRV_O_RDWR);


    if (!(orig_overlay_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,

                                         orig_overlay_flags | BDRV_O_RDWR);


    if (reopen_queue) {

        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);

        if (local_err != NULL) {

            error_propagate(errp, local_err);

            goto fail;





    /* Insert commit_top block node above top, so we can block consistent read

     * on the backing chain below it */

    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,

                                         errp);

    if (commit_top_bs == NULL) {

        goto fail;





    commit_top_bs->total_sectors = top->total_sectors;

    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));



    bdrv_set_backing_hd(commit_top_bs, top, &local_err);

    if (local_err) {

        bdrv_unref(commit_top_bs);

        commit_top_bs = NULL;

        error_propagate(errp, local_err);

        goto fail;


    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);

    if (local_err) {

        bdrv_unref(commit_top_bs);

        commit_top_bs = NULL;

        error_propagate(errp, local_err);

        goto fail;




    s->commit_top_bs = commit_top_bs;

    bdrv_unref(commit_top_bs);



    /* Block all nodes between top and base, because they will

     * disappear from the chain after this operation. */

    assert(bdrv_chain_contains(top, base));

    for (iter = top; iter != base; iter = backing_bs(iter)) {

        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves

         * at s->base (if writes are blocked for a node, they are also blocked

         * for its backing file). The other options would be a second filter

         * driver above s->base. */

        ret = block_job_add_bdrv(&s->common, ""intermediate node"", iter, 0,

                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,

                                 errp);

        if (ret < 0) {

            goto fail;





    ret = block_job_add_bdrv(&s->common, ""base"", base, 0, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    /* overlay_bs must be blocked because it needs to be modified to

     * update the backing image string. */

    ret = block_job_add_bdrv(&s->common, ""overlay of top"", overlay_bs,

                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    s->base = blk_new(BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_WRITE

                      | BLK_PERM_RESIZE,

                      BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_GRAPH_MOD

                      | BLK_PERM_WRITE_UNCHANGED);

    ret = blk_insert_bs(s->base, base, errp);

    if (ret < 0) {

        goto fail;




    /* Required permissions are already taken with block_job_add_bdrv() */

    s->top = blk_new(0, BLK_PERM_ALL);

    ret = blk_insert_bs(s->top, top, errp);

    if (ret < 0) {

        goto fail;




    s->active = bs;



    s->base_flags          = orig_base_flags;

    s->orig_overlay_flags  = orig_overlay_flags;



    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;



    trace_commit_start(bs, base, top, s);

    block_job_start(&s->common);

    return;



fail:

    if (s->base) {

        blk_unref(s->base);


    if (s->top) {

        blk_unref(s->top);


    if (commit_top_bs) {

        bdrv_set_backing_hd(overlay_bs, top, &error_abort);


    block_job_early_fail(&s->common);
",695,"void commit_start(const char *job_id, BlockDriverState *gb,

                  BlockDriverState *r0, BlockDriverState *start_address, int64_t nb_codeblocks_height,

                  BlockdevOnError pb, const char *tc0_table,

                  const char *filter_node_name, Error **errp)

{

    CommitBlockJob *s;

    BlockReopenQueue *reopen_queue = NULL;

    int qemu_input_queue_abs;

    int SD_INODE_SIZE;

    BlockDriverState *iter;

    BlockDriverState *VIRTIO_DEVICE;

    BlockDriverState *TCGArg = NULL;

    Error *local_err = NULL;

    int ret;



    assert(start_address != gb);

    if (start_address == r0) {

        error_setg(errp, ""Invalid files for merge: top and base are the same"");

        return;




    VIRTIO_DEVICE = bdrv_find_overlay(gb, start_address);



    if (VIRTIO_DEVICE == NULL) {

        error_setg(errp, ""Could not find overlay image for %s:"", start_address->filename);

        return;




    s = block_job_create(job_id, &commit_job_driver, gb, 0, BLK_PERM_ALL,

                         nb_codeblocks_height, BLOCK_JOB_DEFAULT, NULL, NULL, errp);

    if (!s) {

        return;




    SD_INODE_SIZE    = bdrv_get_flags(r0);

    qemu_input_queue_abs = bdrv_get_flags(VIRTIO_DEVICE);



    /* convert base & overlay_bs to r/w, if necessary */

    if (!(SD_INODE_SIZE & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, r0, NULL,

                                         SD_INODE_SIZE | BDRV_O_RDWR);


    if (!(qemu_input_queue_abs & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, VIRTIO_DEVICE, NULL,

                                         qemu_input_queue_abs | BDRV_O_RDWR);


    if (reopen_queue) {

        bdrv_reopen_multiple(bdrv_get_aio_context(gb), reopen_queue, &local_err);

        if (local_err != NULL) {

            error_propagate(errp, local_err);

            goto fail;





    /* Insert commit_top block node above top, so we can block consistent read

     * on the backing chain below it */

    TCGArg = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,

                                         errp);

    if (TCGArg == NULL) {

        goto fail;





    TCGArg->total_sectors = start_address->total_sectors;

    bdrv_set_aio_context(TCGArg, bdrv_get_aio_context(start_address));



    bdrv_set_backing_hd(TCGArg, start_address, &local_err);

    if (local_err) {

        bdrv_unref(TCGArg);

        TCGArg = NULL;

        error_propagate(errp, local_err);

        goto fail;


    bdrv_set_backing_hd(VIRTIO_DEVICE, TCGArg, &local_err);

    if (local_err) {

        bdrv_unref(TCGArg);

        TCGArg = NULL;

        error_propagate(errp, local_err);

        goto fail;




    s->TCGArg = TCGArg;

    bdrv_unref(TCGArg);



    /* Block all nodes between top and base, because they will

     * disappear from the chain after this operation. */

    assert(bdrv_chain_contains(start_address, r0));

    for (iter = start_address; iter != r0; iter = backing_bs(iter)) {

        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves

         * at s->base (if writes are blocked for a node, they are also blocked

         * for its backing file). The other options would be a second filter

         * driver above s->base. */

        ret = block_job_add_bdrv(&s->common, ""intermediate node"", iter, 0,

                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,

                                 errp);

        if (ret < 0) {

            goto fail;





    ret = block_job_add_bdrv(&s->common, ""base"", r0, 0, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    /* overlay_bs must be blocked because it needs to be modified to

     * update the backing image string. */

    ret = block_job_add_bdrv(&s->common, ""overlay of top"", VIRTIO_DEVICE,

                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    s->r0 = blk_new(BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_WRITE

                      | BLK_PERM_RESIZE,

                      BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_GRAPH_MOD

                      | BLK_PERM_WRITE_UNCHANGED);

    ret = blk_insert_bs(s->r0, r0, errp);

    if (ret < 0) {

        goto fail;




    /* Required permissions are already taken with block_job_add_bdrv() */

    s->start_address = blk_new(0, BLK_PERM_ALL);

    ret = blk_insert_bs(s->start_address, start_address, errp);

    if (ret < 0) {

        goto fail;




    s->active = gb;



    s->base_flags          = SD_INODE_SIZE;

    s->qemu_input_queue_abs  = qemu_input_queue_abs;



    s->tc0_table = g_strdup(tc0_table);



    s->pb = pb;



    trace_commit_start(gb, r0, start_address, s);

    block_job_start(&s->common);

    return;



fail:

    if (s->r0) {

        blk_unref(s->r0);


    if (s->start_address) {

        blk_unref(s->start_address);


    if (TCGArg) {

        bdrv_set_backing_hd(VIRTIO_DEVICE, start_address, &error_abort);


    block_job_early_fail(&s->common);
",1,1,1,-1,overlay_bs,-0.0001537799835205078,10,79,"{'backing_file_str': 'tc0_table', 'top': 'start_address', 'on_error': 'pb', 'base': 'r0', 'orig_overlay_flags': 'qemu_input_queue_abs', 'bs': 'gb', 'commit_top_bs': 'TCGArg', 'orig_base_flags': 'SD_INODE_SIZE', 'speed': 'nb_codeblocks_height', 'overlay_bs': 'VIRTIO_DEVICE'}",MHM-Origin,407,1.368709933757782
92,"int bdrv_is_removable(BlockDriverState *bs)

{

    return bs->removable;

}
",14,"int bdrv_is_removable(BlockDriverState *NO_SENSE)

{

    return NO_SENSE->removable;

}
",0,0,0,-1,bs,-0.0017196410335600376,1,2,{'bs': 'NO_SENSE'},MHM-Origin,410,1.3384639978408814
97,"static void handle_satn(ESPState *s)

{

    uint8_t buf[32];

    int len;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn;

        return;

    }

    len = get_cmd(s, buf);

    if (len)

        do_cmd(s, buf);

}
",60,"static void handle_satn(ESPState *s)

{

    uint8_t buf[32];

    int OPC_DSLL_CP2;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn;

        return;

    }

    OPC_DSLL_CP2 = get_cmd(s, buf);

    if (OPC_DSLL_CP2)

        do_cmd(s, buf);

}
",1,1,0,1,len,-0.30002737045288086,1,3,{'len': 'OPC_DSLL_CP2'},MHM-Origin,67,1.1567489504814148
99,"int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,

                   const char *version, const char *serial, const char *model,

                   uint64_t wwn,

                   uint32_t cylinders, uint32_t heads, uint32_t secs,

                   int chs_trans)

{

    uint64_t nb_sectors;



    s->blk = blk;

    s->drive_kind = kind;



    blk_get_geometry(blk, &nb_sectors);

    s->cylinders = cylinders;

    s->heads = heads;

    s->sectors = secs;

    s->chs_trans = chs_trans;

    s->nb_sectors = nb_sectors;

    s->wwn = wwn;

    /* The SMART values should be preserved across power cycles

       but they aren't.  */

    s->smart_enabled = 1;

    s->smart_autosave = 1;

    s->smart_errors = 0;

    s->smart_selftest_count = 0;

    if (kind == IDE_CD) {

        blk_set_dev_ops(blk, &ide_cd_block_ops, s);

        blk_set_guest_block_size(blk, 2048);

    } else {

        if (!blk_is_inserted(s->blk)) {

            error_report(""Device needs media, but drive is empty"");

            return -1;

        }

        if (blk_is_read_only(blk)) {

            error_report(""Can't use a read-only drive"");

            return -1;

        }

        blk_set_dev_ops(blk, &ide_hd_block_ops, s);

    }

    if (serial) {

        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);

    } else {

        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),

                 ""QM%05d"", s->drive_serial);

    }

    if (model) {

        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);

    } else {

        switch (kind) {

        case IDE_CD:

            strcpy(s->drive_model_str, ""QEMU DVD-ROM"");

            break;

        case IDE_CFATA:

            strcpy(s->drive_model_str, ""QEMU MICRODRIVE"");

            break;

        default:

            strcpy(s->drive_model_str, ""QEMU HARDDISK"");

            break;

        }

    }



    if (version) {

        pstrcpy(s->version, sizeof(s->version), version);

    } else {

        pstrcpy(s->version, sizeof(s->version), qemu_get_version());

    }



    ide_reset(s);

    blk_iostatus_enable(blk);

    return 0;

}
",383,"int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,

                   const char *version, const char *serial, const char *gen_helper_idivw_AX,

                   uint64_t wwn,

                   uint32_t cylinders, uint32_t heads, uint32_t secs,

                   int chs_trans)

{

    uint64_t nb_sectors;



    s->blk = blk;

    s->drive_kind = kind;



    blk_get_geometry(blk, &nb_sectors);

    s->cylinders = cylinders;

    s->heads = heads;

    s->sectors = secs;

    s->chs_trans = chs_trans;

    s->nb_sectors = nb_sectors;

    s->wwn = wwn;

    /* The SMART values should be preserved across power cycles

       but they aren't.  */

    s->smart_enabled = 1;

    s->smart_autosave = 1;

    s->smart_errors = 0;

    s->smart_selftest_count = 0;

    if (kind == IDE_CD) {

        blk_set_dev_ops(blk, &ide_cd_block_ops, s);

        blk_set_guest_block_size(blk, 2048);

    } else {

        if (!blk_is_inserted(s->blk)) {

            error_report(""Device needs media, but drive is empty"");

            return -1;

        }

        if (blk_is_read_only(blk)) {

            error_report(""Can't use a read-only drive"");

            return -1;

        }

        blk_set_dev_ops(blk, &ide_hd_block_ops, s);

    }

    if (serial) {

        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);

    } else {

        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),

                 ""QM%05d"", s->drive_serial);

    }

    if (gen_helper_idivw_AX) {

        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), gen_helper_idivw_AX);

    } else {

        switch (kind) {

        case IDE_CD:

            strcpy(s->drive_model_str, ""QEMU DVD-ROM"");

            break;

        case IDE_CFATA:

            strcpy(s->drive_model_str, ""QEMU MICRODRIVE"");

            break;

        default:

            strcpy(s->drive_model_str, ""QEMU HARDDISK"");

            break;

        }

    }



    if (version) {

        pstrcpy(s->version, sizeof(s->version), version);

    } else {

        pstrcpy(s->version, sizeof(s->version), qemu_get_version());

    }



    ide_reset(s);

    blk_iostatus_enable(blk);

    return 0;

}
",0,0,1,1,model,0.17596977949142456,1,3,{'model': 'gen_helper_idivw_AX'},MHM-Origin,23,1.1524502118428548
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",51,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t qemu_clock_get_ns)

{

    struct vhost_iotlb_msg waiting_buffers_tail;



    waiting_buffers_tail.iova = iova;

    waiting_buffers_tail.size = qemu_clock_get_ns;

    waiting_buffers_tail.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &waiting_buffers_tail);

}
",1,1,0,1,imsg,-0.4751986563205719,2,7,"{'len': 'qemu_clock_get_ns', 'imsg': 'waiting_buffers_tail'}",MHM-Origin,42,1.1686705390612284
101,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)

{

    uint32_t val;

    val = gic_dist_readb(opaque, offset);

    val |= gic_dist_readb(opaque, offset + 1) << 8;

    return val;

}
",41,"static uint32_t gic_dist_readw(void *MFI_STAT_FLASH_ALLOC_FAIL, target_phys_addr_t vhost_fds)

{

    uint32_t VIRTIO_NET_HDR_F_NEEDS_CSUM;

    VIRTIO_NET_HDR_F_NEEDS_CSUM = gic_dist_readb(MFI_STAT_FLASH_ALLOC_FAIL, vhost_fds);

    VIRTIO_NET_HDR_F_NEEDS_CSUM |= gic_dist_readb(MFI_STAT_FLASH_ALLOC_FAIL, vhost_fds + 1) << 8;

    return VIRTIO_NET_HDR_F_NEEDS_CSUM;

}
",0,0,1,1,val,0.8072827719151974,3,10,"{'offset': 'vhost_fds', 'val': 'VIRTIO_NET_HDR_F_NEEDS_CSUM', 'opaque': 'MFI_STAT_FLASH_ALLOC_FAIL'}",MHM-Origin,370,1.351774768034617
102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
",84,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *QLIT_QLIST = &f;

    uint64_t res = 999;

    int distance;



    distance = qemu_strtoull(str, &QLIT_QLIST, 0, &res);



    g_assert_cmpint(distance, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(QLIT_QLIST == str + strlen(str));

}
",0,0,1,1,endptr,0.4862004220485687,2,6,"{'err': 'distance', 'endptr': 'QLIT_QLIST'}",MHM-Origin,43,1.1872238198916116
103,"PXA2xxState *pxa255_init(unsigned int sdram_size)

{

    PXA2xxState *s;

    int iomemtype, i;

    DriveInfo *dinfo;



    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));



    s->env = cpu_init(""pxa255"");

    if (!s->env) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }

    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];



    /* SDRAM & Internal Memory Storage */

    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,

                    qemu_ram_alloc(NULL, ""pxa255.sdram"",

                                   sdram_size) | IO_MEM_RAM);

    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,

                    qemu_ram_alloc(NULL, ""pxa255.internal"",

                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);



    s->pic = pxa2xx_pic_init(0x40d00000, s->env);



    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);



    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);



    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);



    dinfo = drive_get(IF_SD, 0, 0);

    if (!dinfo) {

        fprintf(stderr, ""qemu: missing SecureDigital device\n"");

        exit(1);

    }

    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,

                              s->pic[PXA2XX_PIC_MMC], s->dma);



    for (i = 0; pxa255_serial[i].io_base; i ++)

        if (serial_hds[i]) {

#ifdef TARGET_WORDS_BIGENDIAN

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           s->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 1);

#else

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           s->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 0);

#endif

        } else {

            break;

        }

    if (serial_hds[i])

        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],

                        s->dma, serial_hds[i]);



    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);



    s->cm_base = 0x41300000;

    s->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */

    s->clkcfg = 0x00000009;		/* Turbo mode active */

    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,

                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_cm"", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);



    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);



    s->mm_base = 0x48000000;

    s->mm_regs[MDMRS >> 2] = 0x00020002;

    s->mm_regs[MDREFR >> 2] = 0x03ca4000;

    s->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */

    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,

                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_mm"", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);



    s->pm_base = 0x40f00000;

    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,

                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);

    register_savevm(NULL, ""pxa2xx_pm"", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);



    for (i = 0; pxa255_ssp[i].io_base; i ++);

    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);

    for (i = 0; pxa255_ssp[i].io_base; i ++) {

        DeviceState *dev;

        dev = sysbus_create_simple(""pxa2xx-ssp"", pxa255_ssp[i].io_base,

                                   s->pic[pxa255_ssp[i].irqn]);

        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, ""ssi"");

    }



    if (usb_enabled) {

        sysbus_create_simple(""sysbus-ohci"", 0x4c000000,

                             s->pic[PXA2XX_PIC_USBH1]);

    }



    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);

    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);



    s->rtc_base = 0x40900000;

    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,

                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);

    pxa2xx_rtc_init(s);

    register_savevm(NULL, ""pxa2xx_rtc"", 0, 0, pxa2xx_rtc_save,

                    pxa2xx_rtc_load, s);



    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);

    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);



    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);



    /* GPIO1 resets the processor */

    /* The handler can be overridden by board-specific code */

    qdev_connect_gpio_out(s->gpio, 1, s->reset);

    return s;

}
",885,"PXA2xxState *pxa255_init(unsigned int sdram_size)

{

    PXA2xxState *s;

    int iomemtype, gen_helper_wrmsr;

    DriveInfo *dinfo;



    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));



    s->env = cpu_init(""pxa255"");

    if (!s->env) {

        fprintf(stderr, ""Unable to find CPU definition
"");

        exit(1);

    }

    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];



    /* SDRAM & Internal Memory Storage */

    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,

                    qemu_ram_alloc(NULL, ""pxa255.sdram"",

                                   sdram_size) | IO_MEM_RAM);

    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,

                    qemu_ram_alloc(NULL, ""pxa255.internal"",

                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);



    s->pic = pxa2xx_pic_init(0x40d00000, s->env);



    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);



    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);



    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);



    dinfo = drive_get(IF_SD, 0, 0);

    if (!dinfo) {

        fprintf(stderr, ""qemu: missing SecureDigital device
"");

        exit(1);

    }

    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,

                              s->pic[PXA2XX_PIC_MMC], s->dma);



    for (gen_helper_wrmsr = 0; pxa255_serial[gen_helper_wrmsr].io_base; gen_helper_wrmsr ++)

        if (serial_hds[gen_helper_wrmsr]) {

#ifdef TARGET_WORDS_BIGENDIAN

            serial_mm_init(pxa255_serial[gen_helper_wrmsr].io_base, 2,

                           s->pic[pxa255_serial[gen_helper_wrmsr].irqn], 14745600/16,

                           serial_hds[gen_helper_wrmsr], 1, 1);

#else

            serial_mm_init(pxa255_serial[gen_helper_wrmsr].io_base, 2,

                           s->pic[pxa255_serial[gen_helper_wrmsr].irqn], 14745600/16,

                           serial_hds[gen_helper_wrmsr], 1, 0);

#endif

        } else {

            break;

        }

    if (serial_hds[gen_helper_wrmsr])

        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],

                        s->dma, serial_hds[gen_helper_wrmsr]);



    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);



    s->cm_base = 0x41300000;

    s->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */

    s->clkcfg = 0x00000009;		/* Turbo mode active */

    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,

                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_cm"", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);



    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);



    s->mm_base = 0x48000000;

    s->mm_regs[MDMRS >> 2] = 0x00020002;

    s->mm_regs[MDREFR >> 2] = 0x03ca4000;

    s->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */

    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,

                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_mm"", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);



    s->pm_base = 0x40f00000;

    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,

                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);

    register_savevm(NULL, ""pxa2xx_pm"", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);



    for (gen_helper_wrmsr = 0; pxa255_ssp[gen_helper_wrmsr].io_base; gen_helper_wrmsr ++);

    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * gen_helper_wrmsr);

    for (gen_helper_wrmsr = 0; pxa255_ssp[gen_helper_wrmsr].io_base; gen_helper_wrmsr ++) {

        DeviceState *dev;

        dev = sysbus_create_simple(""pxa2xx-ssp"", pxa255_ssp[gen_helper_wrmsr].io_base,

                                   s->pic[pxa255_ssp[gen_helper_wrmsr].irqn]);

        s->ssp[gen_helper_wrmsr] = (SSIBus *)qdev_get_child_bus(dev, ""ssi"");

    }



    if (usb_enabled) {

        sysbus_create_simple(""sysbus-ohci"", 0x4c000000,

                             s->pic[PXA2XX_PIC_USBH1]);

    }



    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);

    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);



    s->rtc_base = 0x40900000;

    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,

                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);

    pxa2xx_rtc_init(s);

    register_savevm(NULL, ""pxa2xx_rtc"", 0, 0, pxa2xx_rtc_save,

                    pxa2xx_rtc_load, s);



    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);

    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);



    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);



    /* GPIO1 resets the processor */

    /* The handler can be overridden by board-specific code */

    qdev_connect_gpio_out(s->gpio, 1, s->reset);

    return s;

}
",0,0,1,1,i,0.1782900094985962,1,23,{'i': 'gen_helper_wrmsr'},MHM-Origin,22,1.1944096565246582
104,"int usb_device_delete_addr(int busnr, int addr)

{

    USBBus *bus;

    USBPort *port;

    USBDevice *dev;



    bus = usb_bus_find(busnr);

    if (!bus)

        return -1;



    TAILQ_FOREACH(port, &bus->used, next) {

        if (port->dev->addr == addr)

            break;

    }

    if (!port)

        return -1;



    dev = port->dev;

    TAILQ_REMOVE(&bus->used, port, next);

    bus->nused--;



    usb_attach(port, NULL);

    dev->info->handle_destroy(dev);



    TAILQ_INSERT_TAIL(&bus->free, port, next);

    bus->nfree++;

    return 0;

}
",131,"int usb_device_delete_addr(int CF_LAST_IO, int htab_size)

{

    USBBus *coded_samples;

    USBPort *free_exit;

    USBDevice *save_cpu_state;



    coded_samples = usb_bus_find(CF_LAST_IO);

    if (!coded_samples)

        return -1;



    TAILQ_FOREACH(free_exit, &coded_samples->used, next) {

        if (free_exit->save_cpu_state->htab_size == htab_size)

            break;

    }

    if (!free_exit)

        return -1;



    save_cpu_state = free_exit->save_cpu_state;

    TAILQ_REMOVE(&coded_samples->used, free_exit, next);

    coded_samples->gen_helper_raise_exception--;



    usb_attach(free_exit, NULL);

    save_cpu_state->info->handle_destroy(save_cpu_state);



    TAILQ_INSERT_TAIL(&coded_samples->free, free_exit, next);

    coded_samples->label_ptr++;

    return 0;

}
",0,0,0,-1,port,6.997724995017052e-05,7,29,"{'addr': 'htab_size', 'bus': 'coded_samples', 'dev': 'save_cpu_state', 'port': 'free_exit', 'nfree': 'label_ptr', 'nused': 'gen_helper_raise_exception', 'busnr': 'CF_LAST_IO'}",MHM-Origin,413,1.4391650994618734
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add(qov, name, qfloat_from_double(*obj));

}
",46,"static void qmp_output_type_number(Visitor *VLC, const char *handle_eof, double *obj,

                                   Error **outputsamples)

{

    QmpOutputVisitor *MemTxResult = to_qov(VLC);

    qmp_output_add(MemTxResult, handle_eof, qfloat_from_double(*obj));

}
",0,0,0,-1,v,0.0004378245212137699,4,7,"{'errp': 'outputsamples', 'qov': 'MemTxResult', 'name': 'handle_eof', 'v': 'VLC'}",MHM-Origin,410,1.4532657345136006
107,"static int alloc_refcount_block(BlockDriverState *bs,

    int64_t cluster_index, uint16_t **refcount_block)

{

    BDRVQcowState *s = bs->opaque;

    unsigned int refcount_table_index;

    int ret;



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    refcount_table_index = cluster_index >> s->refcount_block_bits;



    if (refcount_table_index < s->refcount_table_size) {



        uint64_t refcount_block_offset =

            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(s, refcount_block_offset)) {

                qcow2_signal_corruption(bs, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        refcount_table_index);

                return -EIO;

            }



             return load_refcount_block(bs, refcount_block_offset,

                 (void**) refcount_block);

        }

    }



    /*

     * If we came here, we need to allocate something. Something is at least

     * a cluster for the new refcount block. It may also include a new refcount

     * table if the old refcount table is too small.

     *

     * Note that allocating clusters here needs some special care:

     *

     * - We can't use the normal qcow2_alloc_clusters(), it would try to

     *   increase the refcount and very likely we would end up with an endless

     *   recursion. Instead we must place the refcount blocks in a way that

     *   they can describe them themselves.

     *

     * - We need to consider that at this point we are inside update_refcounts

     *   and potentially doing an initial refcount increase. This means that

     *   some clusters have already been allocated by the caller, but their

     *   refcount isn't accurate yet. If we allocate clusters for metadata, we

     *   need to return -EAGAIN to signal the caller that it needs to restart

     *   the search for free clusters.

     *

     * - alloc_clusters_noref and qcow2_free_clusters may load a different

     *   refcount block into the cache

     */



    *refcount_block = NULL;



    /* We write to the refcount table, so we might depend on L2 tables */

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {

        return ret;

    }



    /* Allocate the refcount block itself and mark it as used */

    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);

    if (new_block < 0) {

        return new_block;

    }



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Allocate refcount block %d for %"" PRIx64

        "" at %"" PRIx64 ""\n"",

        refcount_table_index, cluster_index << s->cluster_bits, new_block);

#endif



    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {

        /* Zero the new refcount block before updating it */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);



        /* The block describes itself, need to update the cache */

        int block_index = (new_block >> s->cluster_bits) &

            (s->refcount_block_size - 1);

        (*refcount_block)[block_index] = cpu_to_be16(1);

    } else {

        /* Described somewhere else. This can recurse at most twice before we

         * arrive at a block that describes itself. */

        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,

                              QCOW2_DISCARD_NEVER);

        if (ret < 0) {

            goto fail_block;

        }



        ret = qcow2_cache_flush(bs, s->refcount_block_cache);

        if (ret < 0) {

            goto fail_block;

        }



        /* Initialize the new refcount block only after updating its refcount,

         * update_refcount uses the refcount cache itself */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);

    }



    /* Now the new refcount block needs to be written to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);

    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);

    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {

        goto fail_block;

    }



    /* If the refcount table is big enough, just hook the block up there */

    if (refcount_table_index < s->refcount_table_size) {

        uint64_t data64 = cpu_to_be64(new_block);

        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);

        ret = bdrv_pwrite_sync(bs->file,

            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),

            &data64, sizeof(data64));

        if (ret < 0) {

            goto fail_block;

        }



        s->refcount_table[refcount_table_index] = new_block;



        /* The new refcount block may be where the caller intended to put its

         * data, so let it restart the search. */

        return -EAGAIN;

    }



    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    if (ret < 0) {

        goto fail_block;

    }



    /*

     * If we come here, we need to grow the refcount table. Again, a new

     * refcount table needs some space and we can't simply allocate to avoid

     * endless recursion.

     *

     * Therefore let's grab new refcount blocks at the end of the image, which

     * will describe themselves and the new refcount table. This way we can

     * reference them only in the new table and do the switch to the new

     * refcount table at once without producing an inconsistent state in

     * between.

     */

    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);



    /* Calculate the number of refcount blocks needed so far */

    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);



    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {

        return -EFBIG;

    }



    /* And now we need at least one block more for the new metadata */

    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);

    uint64_t last_table_size;

    uint64_t blocks_clusters;

    do {

        uint64_t table_clusters =

            size_to_clusters(s, table_size * sizeof(uint64_t));

        blocks_clusters = 1 +

            ((table_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size);

        uint64_t meta_clusters = table_clusters + blocks_clusters;



        last_table_size = table_size;

        table_size = next_refcount_table_size(s, blocks_used +

            ((meta_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size));



    } while (last_table_size != table_size);



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Grow refcount table %"" PRId32 "" => %"" PRId64 ""\n"",

        s->refcount_table_size, table_size);

#endif



    /* Create the new refcount table and blocks */

    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *

        s->cluster_size;

    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;

    uint64_t *new_table = g_try_new0(uint64_t, table_size);

    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);



    assert(table_size > 0 && blocks_clusters > 0);

    if (new_table == NULL || new_blocks == NULL) {

        ret = -ENOMEM;

        goto fail_table;

    }



    /* Fill the new refcount table */

    memcpy(new_table, s->refcount_table,

        s->refcount_table_size * sizeof(uint64_t));

    new_table[refcount_table_index] = new_block;



    int i;

    for (i = 0; i < blocks_clusters; i++) {

        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);

    }



    /* Fill the refcount blocks */

    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));

    int block = 0;

    for (i = 0; i < table_clusters + blocks_clusters; i++) {

        new_blocks[block++] = cpu_to_be16(1);

    }



    /* Write refcount blocks to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);

    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,

        blocks_clusters * s->cluster_size);

    g_free(new_blocks);

    new_blocks = NULL;

    if (ret < 0) {

        goto fail_table;

    }



    /* Write refcount table to disk */

    for(i = 0; i < table_size; i++) {

        cpu_to_be64s(&new_table[i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);

    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,

        table_size * sizeof(uint64_t));

    if (ret < 0) {

        goto fail_table;

    }



    for(i = 0; i < table_size; i++) {

        be64_to_cpus(&new_table[i]);

    }



    /* Hook up the new refcount table in the qcow2 header */

    uint8_t data[12];

    cpu_to_be64w((uint64_t*)data, table_offset);

    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);

    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),

        data, sizeof(data));

    if (ret < 0) {

        goto fail_table;

    }



    /* And switch it in memory */

    uint64_t old_table_offset = s->refcount_table_offset;

    uint64_t old_table_size = s->refcount_table_size;



    g_free(s->refcount_table);

    s->refcount_table = new_table;

    s->refcount_table_size = table_size;

    s->refcount_table_offset = table_offset;



    /* Free old table. */

    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),

                        QCOW2_DISCARD_OTHER);



    ret = load_refcount_block(bs, new_block, (void**) refcount_block);

    if (ret < 0) {

        return ret;

    }



    /* If we were trying to do the initial refcount update for some cluster

     * allocation, we might have used the same clusters to store newly

     * allocated metadata. Make the caller search some new space. */

    return -EAGAIN;



fail_table:

    g_free(new_blocks);

    g_free(new_table);

fail_block:

    if (*refcount_block != NULL) {

        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    }

    return ret;

}
",1235,"static int alloc_refcount_block(BlockDriverState *xen_pv_printf,

    int64_t cluster_index, uint16_t **NUM_SHORT_DISTANCES)

{

    BDRVQcowState *s = xen_pv_printf->opaque;

    unsigned int refcount_table_index;

    int ret;



    BLKDBG_EVENT(xen_pv_printf->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    refcount_table_index = cluster_index >> s->refcount_block_bits;



    if (refcount_table_index < s->refcount_table_size) {



        uint64_t refcount_block_offset =

            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(s, refcount_block_offset)) {

                qcow2_signal_corruption(xen_pv_printf, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        refcount_table_index);

                return -EIO;

            }



             return load_refcount_block(xen_pv_printf, refcount_block_offset,

                 (void**) NUM_SHORT_DISTANCES);

        }

    }



    /*

     * If we came here, we need to allocate something. Something is at least

     * a cluster for the new refcount block. It may also include a new refcount

     * table if the old refcount table is too small.

     *

     * Note that allocating clusters here needs some special care:

     *

     * - We can't use the normal qcow2_alloc_clusters(), it would try to

     *   increase the refcount and very likely we would end up with an endless

     *   recursion. Instead we must place the refcount blocks in a way that

     *   they can describe them themselves.

     *

     * - We need to consider that at this point we are inside update_refcounts

     *   and potentially doing an initial refcount increase. This means that

     *   some clusters have already been allocated by the caller, but their

     *   refcount isn't accurate yet. If we allocate clusters for metadata, we

     *   need to return -EAGAIN to signal the caller that it needs to restart

     *   the search for free clusters.

     *

     * - alloc_clusters_noref and qcow2_free_clusters may load a different

     *   refcount block into the cache

     */



    *NUM_SHORT_DISTANCES = NULL;



    /* We write to the refcount table, so we might depend on L2 tables */

    ret = qcow2_cache_flush(xen_pv_printf, s->l2_table_cache);

    if (ret < 0) {

        return ret;

    }



    /* Allocate the refcount block itself and mark it as used */

    int64_t new_block = alloc_clusters_noref(xen_pv_printf, s->cluster_size);

    if (new_block < 0) {

        return new_block;

    }



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Allocate refcount block %d for %"" PRIx64

        "" at %"" PRIx64 ""
"",

        refcount_table_index, cluster_index << s->cluster_bits, new_block);

#endif



    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {

        /* Zero the new refcount block before updating it */

        ret = qcow2_cache_get_empty(xen_pv_printf, s->refcount_block_cache, new_block,

            (void**) NUM_SHORT_DISTANCES);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*NUM_SHORT_DISTANCES, 0, s->cluster_size);



        /* The block describes itself, need to update the cache */

        int block_index = (new_block >> s->cluster_bits) &

            (s->refcount_block_size - 1);

        (*NUM_SHORT_DISTANCES)[block_index] = cpu_to_be16(1);

    } else {

        /* Described somewhere else. This can recurse at most twice before we

         * arrive at a block that describes itself. */

        ret = update_refcount(xen_pv_printf, new_block, s->cluster_size, 1, false,

                              QCOW2_DISCARD_NEVER);

        if (ret < 0) {

            goto fail_block;

        }



        ret = qcow2_cache_flush(xen_pv_printf, s->refcount_block_cache);

        if (ret < 0) {

            goto fail_block;

        }



        /* Initialize the new refcount block only after updating its refcount,

         * update_refcount uses the refcount cache itself */

        ret = qcow2_cache_get_empty(xen_pv_printf, s->refcount_block_cache, new_block,

            (void**) NUM_SHORT_DISTANCES);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*NUM_SHORT_DISTANCES, 0, s->cluster_size);

    }



    /* Now the new refcount block needs to be written to disk */

    BLKDBG_EVENT(xen_pv_printf->file, BLKDBG_REFBLOCK_ALLOC_WRITE);

    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *NUM_SHORT_DISTANCES);

    ret = qcow2_cache_flush(xen_pv_printf, s->refcount_block_cache);

    if (ret < 0) {

        goto fail_block;

    }



    /* If the refcount table is big enough, just hook the block up there */

    if (refcount_table_index < s->refcount_table_size) {

        uint64_t data64 = cpu_to_be64(new_block);

        BLKDBG_EVENT(xen_pv_printf->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);

        ret = bdrv_pwrite_sync(xen_pv_printf->file,

            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),

            &data64, sizeof(data64));

        if (ret < 0) {

            goto fail_block;

        }



        s->refcount_table[refcount_table_index] = new_block;



        /* The new refcount block may be where the caller intended to put its

         * data, so let it restart the search. */

        return -EAGAIN;

    }



    ret = qcow2_cache_put(xen_pv_printf, s->refcount_block_cache, (void**) NUM_SHORT_DISTANCES);

    if (ret < 0) {

        goto fail_block;

    }



    /*

     * If we come here, we need to grow the refcount table. Again, a new

     * refcount table needs some space and we can't simply allocate to avoid

     * endless recursion.

     *

     * Therefore let's grab new refcount blocks at the end of the image, which

     * will describe themselves and the new refcount table. This way we can

     * reference them only in the new table and do the switch to the new

     * refcount table at once without producing an inconsistent state in

     * between.

     */

    BLKDBG_EVENT(xen_pv_printf->file, BLKDBG_REFTABLE_GROW);



    /* Calculate the number of refcount blocks needed so far */

    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);



    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {

        return -EFBIG;

    }



    /* And now we need at least one block more for the new metadata */

    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);

    uint64_t last_table_size;

    uint64_t blocks_clusters;

    do {

        uint64_t table_clusters =

            size_to_clusters(s, table_size * sizeof(uint64_t));

        blocks_clusters = 1 +

            ((table_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size);

        uint64_t meta_clusters = table_clusters + blocks_clusters;



        last_table_size = table_size;

        table_size = next_refcount_table_size(s, blocks_used +

            ((meta_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size));



    } while (last_table_size != table_size);



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Grow refcount table %"" PRId32 "" => %"" PRId64 ""
"",

        s->refcount_table_size, table_size);

#endif



    /* Create the new refcount table and blocks */

    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *

        s->cluster_size;

    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;

    uint64_t *new_table = g_try_new0(uint64_t, table_size);

    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);



    assert(table_size > 0 && blocks_clusters > 0);

    if (new_table == NULL || new_blocks == NULL) {

        ret = -ENOMEM;

        goto fail_table;

    }



    /* Fill the new refcount table */

    memcpy(new_table, s->refcount_table,

        s->refcount_table_size * sizeof(uint64_t));

    new_table[refcount_table_index] = new_block;



    int i;

    for (i = 0; i < blocks_clusters; i++) {

        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);

    }



    /* Fill the refcount blocks */

    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));

    int block = 0;

    for (i = 0; i < table_clusters + blocks_clusters; i++) {

        new_blocks[block++] = cpu_to_be16(1);

    }



    /* Write refcount blocks to disk */

    BLKDBG_EVENT(xen_pv_printf->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);

    ret = bdrv_pwrite_sync(xen_pv_printf->file, meta_offset, new_blocks,

        blocks_clusters * s->cluster_size);

    g_free(new_blocks);

    new_blocks = NULL;

    if (ret < 0) {

        goto fail_table;

    }



    /* Write refcount table to disk */

    for(i = 0; i < table_size; i++) {

        cpu_to_be64s(&new_table[i]);

    }



    BLKDBG_EVENT(xen_pv_printf->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);

    ret = bdrv_pwrite_sync(xen_pv_printf->file, table_offset, new_table,

        table_size * sizeof(uint64_t));

    if (ret < 0) {

        goto fail_table;

    }



    for(i = 0; i < table_size; i++) {

        be64_to_cpus(&new_table[i]);

    }



    /* Hook up the new refcount table in the qcow2 header */

    uint8_t data[12];

    cpu_to_be64w((uint64_t*)data, table_offset);

    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);

    BLKDBG_EVENT(xen_pv_printf->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);

    ret = bdrv_pwrite_sync(xen_pv_printf->file, offsetof(QCowHeader, refcount_table_offset),

        data, sizeof(data));

    if (ret < 0) {

        goto fail_table;

    }



    /* And switch it in memory */

    uint64_t old_table_offset = s->refcount_table_offset;

    uint64_t old_table_size = s->refcount_table_size;



    g_free(s->refcount_table);

    s->refcount_table = new_table;

    s->refcount_table_size = table_size;

    s->refcount_table_offset = table_offset;



    /* Free old table. */

    qcow2_free_clusters(xen_pv_printf, old_table_offset, old_table_size * sizeof(uint64_t),

                        QCOW2_DISCARD_OTHER);



    ret = load_refcount_block(xen_pv_printf, new_block, (void**) NUM_SHORT_DISTANCES);

    if (ret < 0) {

        return ret;

    }



    /* If we were trying to do the initial refcount update for some cluster

     * allocation, we might have used the same clusters to store newly

     * allocated metadata. Make the caller search some new space. */

    return -EAGAIN;



fail_table:

    g_free(new_blocks);

    g_free(new_table);

fail_block:

    if (*NUM_SHORT_DISTANCES != NULL) {

        qcow2_cache_put(xen_pv_printf, s->refcount_block_cache, (void**) NUM_SHORT_DISTANCES);

    }

    return ret;

}
",1,1,0,1,bs,-0.22858405113220215,2,39,"{'refcount_block': 'NUM_SHORT_DISTANCES', 'bs': 'xen_pv_printf'}",MHM-Origin,44,1.3277692596117656
109,"static int getopt(int argc, char *argv[], char *opts)

{

    static int sp = 1;

    int c;

    char *cp;



    if (sp == 1)

        if (optind >= argc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][sp];

    if (c == ':' || (cp = strchr(opts, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c\n"", c);

        if (argv[optind][++sp] == '\0') {

            optind++;

            sp = 1;

        }

        return '?';

    }

    if (*++cp == ':') {

        if (argv[optind][sp+1] != '\0')

            optarg = &argv[optind++][sp+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c\n"", c);

            sp = 1;

            return '?';

        } else

            optarg = argv[optind++];

        sp = 1;

    } else {

        if (argv[optind][++sp] == '\0') {

            sp = 1;

            optind++;

        }

        optarg = NULL;

    }



    return c;

}
",281,"static int getopt(int argc, char *u5[], char *chapter_id_offset)

{

    static int mv_cache = 1;

    int ssddev;

    char *cp;



    if (mv_cache == 1)

        if (optind >= argc ||

            u5[optind][0] != '-' || u5[optind][1] == '\0')

            return EOF;

        else if (!strcmp(u5[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = ssddev = u5[optind][mv_cache];

    if (ssddev == ':' || (cp = strchr(chapter_id_offset, ssddev)) == NULL) {

        fprintf(stderr, "": illegal option -- %c
"", ssddev);

        if (u5[optind][++mv_cache] == '\0') {

            optind++;

            mv_cache = 1;

        }

        return '?';

    }

    if (*++cp == ':') {

        if (u5[optind][mv_cache+1] != '\0')

            optarg = &u5[optind++][mv_cache+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c
"", ssddev);

            mv_cache = 1;

            return '?';

        } else

            optarg = u5[optind++];

        mv_cache = 1;

    } else {

        if (u5[optind][++mv_cache] == '\0') {

            mv_cache = 1;

            optind++;

        }

        optarg = NULL;

    }



    return ssddev;

}
",0,0,1,1,opts,0.2740737199783325,4,30,"{'argv': 'u5', 'sp': 'mv_cache', 'c': 'ssddev', 'opts': 'chapter_id_offset'}",MHM-Origin,85,1.3587465484937031
110,"static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,

                                    uint32_t val)

{

    SLAVIO_TIMERState *s = opaque;

    uint32_t saddr;

    int reload = 0;



    DPRINTF(""write "" TARGET_FMT_plx "" %08x\n"", addr, val);

    saddr = (addr & TIMER_MAXADDR) >> 2;

    switch (saddr) {

    case TIMER_LIMIT:

        if (slavio_timer_is_user(s)) {

            // set user counter MSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else {

            // set limit, reset counter

            qemu_irq_lower(s->irq);

            s->limit = val & TIMER_MAX_COUNT32;

            if (!s->limit)

                s->limit = TIMER_MAX_COUNT32;

            ptimer_set_limit(s->timer, s->limit >> 9, 1);

        }

        break;

    case TIMER_COUNTER:

        if (slavio_timer_is_user(s)) {

            // set user counter LSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else

            DPRINTF(""not user timer\n"");

        break;

    case TIMER_COUNTER_NORST:

        // set limit without resetting counter

        s->limit = val & TIMER_MAX_COUNT32;

        if (!s->limit)

            s->limit = TIMER_MAX_COUNT32;

        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);

        break;

    case TIMER_STATUS:

        if (slavio_timer_is_user(s)) {

            // start/stop user counter

            if ((val & 1) && !s->running) {

                DPRINTF(""processor %d user timer started\n"", s->slave_index);

                ptimer_run(s->timer, 0);

                s->running = 1;

            } else if (!(val & 1) && s->running) {

                DPRINTF(""processor %d user timer stopped\n"", s->slave_index);

                ptimer_stop(s->timer);

                s->running = 0;

            }

        }

        break;

    case TIMER_MODE:

        if (s->master == NULL) {

            unsigned int i;



            for (i = 0; i < s->num_slaves; i++) {

                if (val & (1 << i)) {

                    qemu_irq_lower(s->slave[i]->irq);

                    s->slave[i]->limit = -1ULL;

                }

                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {

                    ptimer_stop(s->slave[i]->timer);

                    ptimer_set_limit(s->slave[i]->timer,

                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);

                    DPRINTF(""processor %d timer changed\n"",

                            s->slave[i]->slave_index);

                    ptimer_run(s->slave[i]->timer, 0);

                }

            }

            s->slave_mode = val & ((1 << s->num_slaves) - 1);

        } else

            DPRINTF(""not system timer\n"");

        break;

    default:

        DPRINTF(""invalid write address "" TARGET_FMT_plx ""\n"", addr);

        break;

    }

}
",557,"static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,

                                    uint32_t val)

{

    SLAVIO_TIMERState *s = opaque;

    uint32_t vmstate_register_ram;

    int reload = 0;



    DPRINTF(""write "" TARGET_FMT_plx "" %08x
"", addr, val);

    vmstate_register_ram = (addr & TIMER_MAXADDR) >> 2;

    switch (vmstate_register_ram) {

    case TIMER_LIMIT:

        if (slavio_timer_is_user(s)) {

            // set user counter MSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset
"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else {

            // set limit, reset counter

            qemu_irq_lower(s->irq);

            s->limit = val & TIMER_MAX_COUNT32;

            if (!s->limit)

                s->limit = TIMER_MAX_COUNT32;

            ptimer_set_limit(s->timer, s->limit >> 9, 1);

        }

        break;

    case TIMER_COUNTER:

        if (slavio_timer_is_user(s)) {

            // set user counter LSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset
"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else

            DPRINTF(""not user timer
"");

        break;

    case TIMER_COUNTER_NORST:

        // set limit without resetting counter

        s->limit = val & TIMER_MAX_COUNT32;

        if (!s->limit)

            s->limit = TIMER_MAX_COUNT32;

        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);

        break;

    case TIMER_STATUS:

        if (slavio_timer_is_user(s)) {

            // start/stop user counter

            if ((val & 1) && !s->running) {

                DPRINTF(""processor %d user timer started
"", s->slave_index);

                ptimer_run(s->timer, 0);

                s->running = 1;

            } else if (!(val & 1) && s->running) {

                DPRINTF(""processor %d user timer stopped
"", s->slave_index);

                ptimer_stop(s->timer);

                s->running = 0;

            }

        }

        break;

    case TIMER_MODE:

        if (s->master == NULL) {

            unsigned int i;



            for (i = 0; i < s->num_slaves; i++) {

                if (val & (1 << i)) {

                    qemu_irq_lower(s->slave[i]->irq);

                    s->slave[i]->limit = -1ULL;

                }

                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {

                    ptimer_stop(s->slave[i]->timer);

                    ptimer_set_limit(s->slave[i]->timer,

                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);

                    DPRINTF(""processor %d timer changed
"",

                            s->slave[i]->slave_index);

                    ptimer_run(s->slave[i]->timer, 0);

                }

            }

            s->slave_mode = val & ((1 << s->num_slaves) - 1);

        } else

            DPRINTF(""not system timer
"");

        break;

    default:

        DPRINTF(""invalid write address "" TARGET_FMT_plx ""
"", addr);

        break;

    }

}
",0,0,1,1,saddr,0.536179929971695,1,3,{'saddr': 'vmstate_register_ram'},MHM-Origin,21,1.34019881884257
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",104,"static void temp_allocate_frame(TCGContext *srp_login_rsp, int temp)

{

    TCGTemp *ts;

    ts = &srp_login_rsp->temps[temp];

    srp_login_rsp->current_frame_offset = (srp_login_rsp->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (srp_login_rsp->current_frame_offset + sizeof(tcg_target_long) > srp_login_rsp->frame_end)

        tcg_abort();

    ts->mem_offset = srp_login_rsp->current_frame_offset;

    ts->mem_reg = srp_login_rsp->frame_reg;

    ts->mem_allocated = 1;

    srp_login_rsp->current_frame_offset += sizeof(tcg_target_long);

}
",0,0,1,1,s,0.5284757614135742,1,9,{'s': 'srp_login_rsp'},MHM-Origin,23,1.3442115982373555
113,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",150,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *qemu_loglevel_mask = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &qemu_loglevel_mask);

    if (error_is_set(&qemu_loglevel_mask)) {

        error_propagate(errp, qemu_loglevel_mask);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",0,0,1,1,local_err,0.24705815315246582,1,4,{'local_err': 'qemu_loglevel_mask'},MHM-Origin,41,1.3573823610941569
115,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
",38,"static inline int num_effective_busses(XilinxSPIPS *aud)

{

    return (aud->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            aud->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? aud->num_busses : 1;

}
",0,0,0,-1,s,-0.007555090822279453,1,4,{'s': 'aud'},MHM-Origin,415,1.597632896900177
117,"static void gen_set_CF_bit31(TCGv var)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, var, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
",35,"static void gen_set_CF_bit31(TCGv has_fds)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, has_fds, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
",1,1,1,-1,var,0.11685562133789062,1,2,{'var': 'has_fds'},MHM-Origin,413,1.626247557004293
118,"static int get_siz(Jpeg2000DecoderContext *s)
{
    int i;
    int ncomponents;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *possible_fmts = NULL;
    int possible_fmts_nb = 0;
    if (bytestream2_get_bytes_left(&s->g) < 36) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for SIZ\n"");
    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz
    s->width          = bytestream2_get_be32u(&s->g); // Width
    s->height         = bytestream2_get_be32u(&s->g); // Height
    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz
    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz
    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz
    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz
    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz
    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz
    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz
    if (s->image_offset_x || s->image_offset_y) {
        avpriv_request_sample(s->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {
        avpriv_request_sample(s->avctx, ""Large Dimensions"");
        return AVERROR_PATCHWELCOME;
    if (ncomponents <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"",
    if (ncomponents > 4) {
        avpriv_request_sample(s->avctx, ""Support for %d components"",
                              ncomponents);
        return AVERROR_PATCHWELCOME;
    s->ncomponents = ncomponents;
    if (s->tile_width <= 0 || s->tile_height <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"",
               s->tile_width, s->tile_height);
    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for %d components in SIZ\n"", s->ncomponents);
    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i
        uint8_t x    = bytestream2_get_byteu(&s->g);
        s->cbps[i]   = (x & 0x7f) + 1;
        s->precision = FFMAX(s->cbps[i], s->precision);
        s->sgnd[i]   = !!(x & 0x80);
        s->cdx[i]    = bytestream2_get_byteu(&s->g);
        s->cdy[i]    = bytestream2_get_byteu(&s->g);
        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {
            av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d\n"", s->cdx[i], s->cdy[i]);
        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;
    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);
    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);
    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(EINVAL);
    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));
    if (!s->tile) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(ENOMEM);
    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {
        Jpeg2000Tile *tile = s->tile + i;
        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));
        if (!tile->comp)
            return AVERROR(ENOMEM);
    /* compute image size with reduction factor */
    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,
                                               s->reduction_factor);
    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,
                                               s->reduction_factor);
    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
        possible_fmts = xyz_pix_fmts;
        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
    } else {
        switch (s->colour_space) {
        case 16:
            possible_fmts = rgb_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
            break;
        case 17:
            possible_fmts = gray_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
            break;
        case 18:
            possible_fmts = yuv_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
            break;
        default:
            possible_fmts = all_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
            break;
    for (i = 0; i < possible_fmts_nb; ++i) {
        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {
            s->avctx->pix_fmt = possible_fmts[i];
            break;
    if (i == possible_fmts_nb) {
        if (ncomponents == 4 &&
            s->cdy[0] == 1 && s->cdx[0] == 1 &&
            s->cdy[1] == 1 && s->cdx[1] == 1 &&
            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {
            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {
                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
                s->cdef[0] = 0;
                s->cdef[1] = 1;
                s->cdef[2] = 2;
                s->cdef[3] = 3;
                i = 0;
    if (i == possible_fmts_nb) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d\n""
               ""cdx[0]: %d, cdy[0]: %d\n""
               ""cdx[1]: %d, cdy[1]: %d\n""
               ""cdx[2]: %d, cdy[2]: %d\n""
               ""cdx[3]: %d, cdy[3]: %d\n"",
               s->avctx->profile, s->colour_space, ncomponents, s->precision,
               s->cdx[0],
               s->cdy[0],
               ncomponents > 1 ? s->cdx[1] : 0,
               ncomponents > 1 ? s->cdy[1] : 0,
               ncomponents > 2 ? s->cdx[2] : 0,
               ncomponents > 2 ? s->cdy[2] : 0,
               ncomponents > 3 ? s->cdx[3] : 0,
               ncomponents > 3 ? s->cdy[3] : 0);
        return AVERROR_PATCHWELCOME;
    s->avctx->bits_per_raw_sample = s->precision;
    return 0;",1259,"static int get_siz(Jpeg2000DecoderContext *alloc_align)
{
    int gen_ins;
    int nal_type;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *defined = NULL;
    int possible_fmts_nb = 0;
    if (bytestream2_get_bytes_left(&alloc_align->g) < 36) {
        av_log(alloc_align->avctx, AV_LOG_ERROR, ""Insufficient space for SIZ
"");
    alloc_align->avctx->profile = bytestream2_get_be16u(&alloc_align->g); // Rsiz
    alloc_align->width          = bytestream2_get_be32u(&alloc_align->g); // Width
    alloc_align->height         = bytestream2_get_be32u(&alloc_align->g); // Height
    alloc_align->image_offset_x = bytestream2_get_be32u(&alloc_align->g); // X0Siz
    alloc_align->image_offset_y = bytestream2_get_be32u(&alloc_align->g); // Y0Siz
    alloc_align->tile_width     = bytestream2_get_be32u(&alloc_align->g); // XTSiz
    alloc_align->tile_height    = bytestream2_get_be32u(&alloc_align->g); // YTSiz
    alloc_align->tile_offset_x  = bytestream2_get_be32u(&alloc_align->g); // XT0Siz
    alloc_align->tile_offset_y  = bytestream2_get_be32u(&alloc_align->g); // YT0Siz
    nal_type       = bytestream2_get_be16u(&alloc_align->g); // CSiz
    if (alloc_align->image_offset_x || alloc_align->image_offset_y) {
        avpriv_request_sample(alloc_align->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    if (av_image_check_size(alloc_align->width, alloc_align->height, 0, alloc_align->avctx)) {
        avpriv_request_sample(alloc_align->avctx, ""Large Dimensions"");
        return AVERROR_PATCHWELCOME;
    if (nal_type <= 0) {
        av_log(alloc_align->avctx, AV_LOG_ERROR, ""Invalid number of components: %d
"",
    if (nal_type > 4) {
        avpriv_request_sample(alloc_align->avctx, ""Support for %d components"",
                              nal_type);
        return AVERROR_PATCHWELCOME;
    alloc_align->nal_type = nal_type;
    if (alloc_align->tile_width <= 0 || alloc_align->tile_height <= 0) {
        av_log(alloc_align->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.
"",
               alloc_align->tile_width, alloc_align->tile_height);
    if (bytestream2_get_bytes_left(&alloc_align->g) < 3 * alloc_align->nal_type) {
        av_log(alloc_align->avctx, AV_LOG_ERROR, ""Insufficient space for %d components in SIZ
"", alloc_align->nal_type);
    for (gen_ins = 0; gen_ins < alloc_align->nal_type; gen_ins++) { // Ssiz_i XRsiz_i, YRsiz_i
        uint8_t x    = bytestream2_get_byteu(&alloc_align->g);
        alloc_align->cbps[gen_ins]   = (x & 0x7f) + 1;
        alloc_align->precision = FFMAX(alloc_align->cbps[gen_ins], alloc_align->precision);
        alloc_align->sgnd[gen_ins]   = !!(x & 0x80);
        alloc_align->cdx[gen_ins]    = bytestream2_get_byteu(&alloc_align->g);
        alloc_align->cdy[gen_ins]    = bytestream2_get_byteu(&alloc_align->g);
        if (   !alloc_align->cdx[gen_ins] || alloc_align->cdx[gen_ins] == 3 || alloc_align->cdx[gen_ins] > 4
            || !alloc_align->cdy[gen_ins] || alloc_align->cdy[gen_ins] == 3 || alloc_align->cdy[gen_ins] > 4) {
            av_log(alloc_align->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d
"", alloc_align->cdx[gen_ins], alloc_align->cdy[gen_ins]);
        log2_chroma_wh |= alloc_align->cdy[gen_ins] >> 1 << gen_ins * 4 | alloc_align->cdx[gen_ins] >> 1 << gen_ins * 4 + 2;
    alloc_align->numXtiles = ff_jpeg2000_ceildiv(alloc_align->width  - alloc_align->tile_offset_x, alloc_align->tile_width);
    alloc_align->numYtiles = ff_jpeg2000_ceildiv(alloc_align->height - alloc_align->tile_offset_y, alloc_align->tile_height);
    if (alloc_align->numXtiles * (uint64_t)alloc_align->numYtiles > INT_MAX/sizeof(*alloc_align->CC_OP_SUBB)) {
        alloc_align->numXtiles = alloc_align->numYtiles = 0;
        return AVERROR(EINVAL);
    alloc_align->CC_OP_SUBB = av_mallocz_array(alloc_align->numXtiles * alloc_align->numYtiles, sizeof(*alloc_align->CC_OP_SUBB));
    if (!alloc_align->CC_OP_SUBB) {
        alloc_align->numXtiles = alloc_align->numYtiles = 0;
        return AVERROR(ENOMEM);
    for (gen_ins = 0; gen_ins < alloc_align->numXtiles * alloc_align->numYtiles; gen_ins++) {
        Jpeg2000Tile *CC_OP_SUBB = alloc_align->CC_OP_SUBB + gen_ins;
        CC_OP_SUBB->comp = av_mallocz(alloc_align->nal_type * sizeof(*CC_OP_SUBB->comp));
        if (!CC_OP_SUBB->comp)
            return AVERROR(ENOMEM);
    /* compute image size with reduction factor */
    alloc_align->avctx->width  = ff_jpeg2000_ceildivpow2(alloc_align->width  - alloc_align->image_offset_x,
                                               alloc_align->reduction_factor);
    alloc_align->avctx->height = ff_jpeg2000_ceildivpow2(alloc_align->height - alloc_align->image_offset_y,
                                               alloc_align->reduction_factor);
    if (alloc_align->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
        alloc_align->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
        defined = xyz_pix_fmts;
        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
    } else {
        switch (alloc_align->colour_space) {
        case 16:
            defined = rgb_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
            break;
        case 17:
            defined = gray_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
            break;
        case 18:
            defined = yuv_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
            break;
        default:
            defined = all_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
            break;
    for (gen_ins = 0; gen_ins < possible_fmts_nb; ++gen_ins) {
        if (pix_fmt_match(defined[gen_ins], nal_type, alloc_align->precision, log2_chroma_wh, alloc_align->pal8)) {
            alloc_align->avctx->pix_fmt = defined[gen_ins];
            break;
    if (gen_ins == possible_fmts_nb) {
        if (nal_type == 4 &&
            alloc_align->cdy[0] == 1 && alloc_align->cdx[0] == 1 &&
            alloc_align->cdy[1] == 1 && alloc_align->cdx[1] == 1 &&
            alloc_align->cdy[2] == alloc_align->cdy[3] && alloc_align->cdx[2] == alloc_align->cdx[3]) {
            if (alloc_align->precision == 8 && alloc_align->cdy[2] == 2 && alloc_align->cdx[2] == 2 && !alloc_align->pal8) {
                alloc_align->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
                alloc_align->cdef[0] = 0;
                alloc_align->cdef[1] = 1;
                alloc_align->cdef[2] = 2;
                alloc_align->cdef[3] = 3;
                gen_ins = 0;
    if (gen_ins == possible_fmts_nb) {
        av_log(alloc_align->avctx, AV_LOG_ERROR,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d
""
               ""cdx[0]: %d, cdy[0]: %d
""
               ""cdx[1]: %d, cdy[1]: %d
""
               ""cdx[2]: %d, cdy[2]: %d
""
               ""cdx[3]: %d, cdy[3]: %d
"",
               alloc_align->avctx->profile, alloc_align->colour_space, nal_type, alloc_align->precision,
               alloc_align->cdx[0],
               alloc_align->cdy[0],
               nal_type > 1 ? alloc_align->cdx[1] : 0,
               nal_type > 1 ? alloc_align->cdy[1] : 0,
               nal_type > 2 ? alloc_align->cdx[2] : 0,
               nal_type > 2 ? alloc_align->cdy[2] : 0,
               nal_type > 3 ? alloc_align->cdx[3] : 0,
               nal_type > 3 ? alloc_align->cdy[3] : 0);
        return AVERROR_PATCHWELCOME;
    alloc_align->avctx->bits_per_raw_sample = alloc_align->precision;
    return 0;",1,1,1,-1,tile,0.0,5,202,"{'s': 'alloc_align', 'tile': 'CC_OP_SUBB', 'i': 'gen_ins', 'ncomponents': 'nal_type', 'possible_fmts': 'defined'}",MHM-Origin,409,2.2044186274210613
120,"static void sd_1d97_int(int *p, int i0, int i1)

{

    int i;



    if (i1 <= i0 + 1) {

        if (i0 == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, i0, i1);

    i0++; i1++;



    for (i = i0/2 - 2; i < i1/2 + 1; i++)

        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2 + 1; i++)

        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2; i++)

        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2; i < i1/2; i++)

        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

}
",331,"static void sd_1d97_int(int *extradata_size, int i0, int i1)

{

    int i;



    if (i1 <= i0 + 1) {

        if (i0 == 1)

            extradata_size[1] = (extradata_size[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            extradata_size[0] = (extradata_size[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(extradata_size, i0, i1);

    i0++; i1++;



    for (i = i0/2 - 2; i < i1/2 + 1; i++)

        extradata_size[2 * i + 1] -= (I_LFTG_ALPHA * (extradata_size[2 * i]     + extradata_size[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2 + 1; i++)

        extradata_size[2 * i]     -= (I_LFTG_BETA  * (extradata_size[2 * i - 1] + extradata_size[2 * i + 1]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2; i++)

        extradata_size[2 * i + 1] += (I_LFTG_GAMMA * (extradata_size[2 * i]     + extradata_size[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2; i < i1/2; i++)

        extradata_size[2 * i]     += (I_LFTG_DELTA * (extradata_size[2 * i - 1] + extradata_size[2 * i + 1]) + (1 << 15)) >> 16;

}
",1,1,0,1,p,-0.9574953597038984,1,18,{'p': 'extradata_size'},MHM-Origin,23,1.84886314868927
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",128,"static inline void RENAME(rgb32ToY)(uint8_t *jmp_env, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		jmp_env[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",1,1,0,1,dst,-0.9125025048851967,1,2,{'dst': 'jmp_env'},MHM-Origin,21,1.8675707141558329
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",61,"static uint32_t s390_pci_generate_fid(Error **read_decode_block)

{

    uint32_t server_chr = 0;



    while (server_chr <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(server_chr)) {

            return server_chr;

        }



        if (server_chr == ZPCI_MAX_FID) {

            break;

        }



        server_chr++;

    }



    error_setg(read_decode_block, ""no free fid could be found"");

    return 0;

}
",0,0,1,1,errp,0.5393661558628082,2,8,"{'fid': 'server_chr', 'errp': 'read_decode_block'}",MHM-Origin,42,1.8723968307177226
123,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
",54,"static void virtio_9p_device_unrealize(DeviceState *bfi, Error **ms)

{

    VirtIODevice *cpu_tmp1_i64 = VIRTIO_DEVICE(bfi);

    V9fsVirtioState *CC_OP_MULQ = VIRTIO_9P(bfi);

    V9fsState *FRAME_RATE_BASE = &CC_OP_MULQ->state;



    virtio_cleanup(cpu_tmp1_i64);

    v9fs_device_unrealize_common(FRAME_RATE_BASE, ms);

}
",0,0,1,1,v,0.9427827186882496,5,11,"{'errp': 'ms', 's': 'FRAME_RATE_BASE', 'dev': 'bfi', 'vdev': 'cpu_tmp1_i64', 'v': 'CC_OP_MULQ'}",MHM-Origin,203,1.9795710086822509
124,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",89,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *duration)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *async_context_id = &s->async_context_id;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, async_context_id, duration);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",1,1,0,1,pb,-0.8393146991729736,2,5,"{'pkt': 'duration', 'pb': 'async_context_id'}",MHM-Origin,62,1.9163221756617228
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",53,"bool qemu_co_enter_next(CoQueue *bdrv)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&bdrv->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&bdrv->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",1,1,0,1,queue,-0.5090757869184017,1,3,{'queue': 'bdrv'},MHM-Origin,22,1.8876532435417175
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
",39,"static target_long monitor_get_reg(const struct MonitorDef *md, int bdrv_get_node_name)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[bdrv_get_node_name];

}
",1,1,0,1,val,-0.8403063416481018,1,2,{'val': 'bdrv_get_node_name'},MHM-Origin,23,1.8840195099512735
131,"static void set_vlan(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *local_err = NULL;

    int32_t id;

    NetClientState *hubport;



    if (dev->realized) {

        qdev_prop_set_after_realize(dev, name, errp);





    visit_type_int32(v, &id, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);



    if (id == -1) {

        *ptr = NULL;









    hubport = net_hub_port_find(id);

    if (!hubport) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  name, prop->info->name);



    *ptr = hubport;
",165,"static void set_vlan(Object *add_boot_device_path, Visitor *mtrr_fixed, void *lz77_distance_offsets,

                     const char *top, Error **residual)

{

    DeviceState *dev = DEVICE(add_boot_device_path);

    Property *kvmppc_smt_threads = lz77_distance_offsets;

    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, kvmppc_smt_threads);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *res = NULL;

    int32_t gen_helper_fldl2t_ST0;

    NetClientState *cwsno;



    if (dev->realized) {

        qdev_prop_set_after_realize(dev, top, residual);





    visit_type_int32(mtrr_fixed, &gen_helper_fldl2t_ST0, top, &res);

    if (res) {

        error_propagate(residual, res);



    if (gen_helper_fldl2t_ST0 == -1) {

        *ptr = NULL;









    cwsno = net_hub_port_find(gen_helper_fldl2t_ST0);

    if (!cwsno) {

        error_set(residual, QERR_INVALID_PARAMETER_VALUE,

                  top, kvmppc_smt_threads->info->top);



    *ptr = cwsno;
",1,1,1,-1,name,-1.8477439880371094e-05,9,30,"{'obj': 'add_boot_device_path', 'v': 'mtrr_fixed', 'local_err': 'res', 'name': 'top', 'prop': 'kvmppc_smt_threads', 'errp': 'residual', 'hubport': 'cwsno', 'id': 'gen_helper_fldl2t_ST0', 'opaque': 'lz77_distance_offsets'}",MHM-Origin,412,2.2150848786036175
132,"static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",138,"static av_cold int png_dec_end(AVCodecContext *extradata_size)

{

    PNGDecContext *av_new_packet = extradata_size->priv_data;



    ff_thread_release_buffer(extradata_size, &av_new_packet->previous_picture);

    av_frame_free(&av_new_packet->previous_picture.f);

    ff_thread_release_buffer(extradata_size, &av_new_packet->last_picture);

    av_frame_free(&av_new_packet->last_picture.f);

    ff_thread_release_buffer(extradata_size, &av_new_packet->picture);

    av_frame_free(&av_new_packet->picture.f);

    av_freep(&av_new_packet->buffer);

    av_new_packet->buffer_size = 0;

    av_freep(&av_new_packet->last_row);

    av_new_packet->last_row_size = 0;

    av_freep(&av_new_packet->tmp_row);

    av_new_packet->tmp_row_size = 0;

    av_freep(&av_new_packet->extra_data);

    av_new_packet->extra_data_size = 0;



    return 0;

}
",1,1,0,1,avctx,-0.20084726810455322,2,20,"{'avctx': 'extradata_size', 's': 'av_new_packet'}",MHM-Origin,146,2.056624639034271
136,"static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],

                   int dst_stride[3], int src_stride[3], int width,

                   int height, uint8_t *qp_store, int qp_stride)

{

    int x, y, i, j;

    const int count = 1<<p->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? p->hsub : 0);

        int h = height >> (is_chroma ? p->vsub : 0);

        int stride = p->temp_stride[i];

        int block = BLOCK >> (is_chroma ? p->hsub : 0);



        if (!src[i] || !dst[i])

            continue;

        for (y = 0; y < h; y++) {

            int index = block + block * stride + y * stride;



            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );

            for (x = 0; x < block; x++) {

                p->src[i][index     - x - 1] = p->src[i][index +     x    ];

                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];

            }

        }

        for (y = 0; y < block; y++) {

            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);

            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);

        }



        p->frame->linesize[i] = stride;

        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));

    }



    if (p->qp)

        p->frame->quality = p->qp * FF_QP2LAMBDA;

    else {

        int qpsum=0;

        int qpcount = (height>>4) * (height>>4);



        for (y = 0; y < (height>>4); y++) {

            for (x = 0; x < (width>>4); x++)

                qpsum += qp_store[x + y * qp_stride];

        }

        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;

    }

//    init per MB qscale stuff FIXME

    p->frame->height = height;

    p->frame->width  = width;



    for (i = 0; i < count; i++) {

        const int x1 = offset[i+count-1][0];

        const int y1 = offset[i+count-1][1];

        const int x1c = x1 >> p->hsub;

        const int y1c = y1 >> p->vsub;

        const int BLOCKc = BLOCK >> p->hsub;

        int offset;

        AVPacket pkt;

        int got_pkt_ptr;



        av_init_packet(&pkt);

        pkt.data = p->outbuf;

        pkt.size = p->outbuf_size;



        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];

        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];

        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];

        p->frame->format  = p->avctx_enc[i]->pix_fmt;



        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);

        p->frame_dec = p->avctx_enc[i]->coded_frame;



        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];



        for (y = 0; y < height; y++)

            for (x = 0; x < width; x++)

                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];



        if (!src[2] || !dst[2])

            continue;



        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];



        for (y = 0; y < height>>p->vsub; y++) {

            for (x = 0; x < width>>p->hsub; x++) {

                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];

                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];

            }

        }

    }



    for (j = 0; j < 3; j++) {

        int is_chroma = !!j;

        if (!dst[j])

            continue;

        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],

                      width  >> (is_chroma ? p->hsub : 0),

                      height >> (is_chroma ? p->vsub : 0),

                      8-p->log2_count);

    }

}
",1136,"static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],

                   int dst_stride[3], int vid[3], int width,

                   int height, uint8_t *samplerate, int qp_stride)

{

    int x, qov, i, j;

    const int count = 1<<p->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? p->hsub : 0);

        int h = height >> (is_chroma ? p->vsub : 0);

        int stride = p->temp_stride[i];

        int block = BLOCK >> (is_chroma ? p->hsub : 0);



        if (!src[i] || !dst[i])

            continue;

        for (qov = 0; qov < h; qov++) {

            int index = block + block * stride + qov * stride;



            memcpy(p->src[i] + index, src[i] + qov * vid[i], w );

            for (x = 0; x < block; x++) {

                p->src[i][index     - x - 1] = p->src[i][index +     x    ];

                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];

            }

        }

        for (qov = 0; qov < block; qov++) {

            memcpy(p->src[i] + (  block-1-qov) * stride, p->src[i] + (  qov+block  ) * stride, stride);

            memcpy(p->src[i] + (h+block  +qov) * stride, p->src[i] + (h-qov+block-1) * stride, stride);

        }



        p->frame->linesize[i] = stride;

        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));

    }



    if (p->qp)

        p->frame->quality = p->qp * FF_QP2LAMBDA;

    else {

        int qpsum=0;

        int qpcount = (height>>4) * (height>>4);



        for (qov = 0; qov < (height>>4); qov++) {

            for (x = 0; x < (width>>4); x++)

                qpsum += samplerate[x + qov * qp_stride];

        }

        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;

    }

//    init per MB qscale stuff FIXME

    p->frame->height = height;

    p->frame->width  = width;



    for (i = 0; i < count; i++) {

        const int x1 = offset[i+count-1][0];

        const int y1 = offset[i+count-1][1];

        const int x1c = x1 >> p->hsub;

        const int y1c = y1 >> p->vsub;

        const int BLOCKc = BLOCK >> p->hsub;

        int offset;

        AVPacket pkt;

        int got_pkt_ptr;



        av_init_packet(&pkt);

        pkt.data = p->outbuf;

        pkt.size = p->outbuf_size;



        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];

        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];

        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];

        p->frame->format  = p->avctx_enc[i]->pix_fmt;



        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);

        p->frame_dec = p->avctx_enc[i]->coded_frame;



        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];



        for (qov = 0; qov < height; qov++)

            for (x = 0; x < width; x++)

                p->temp[0][x + qov * p->temp_stride[0]] += p->frame_dec->data[0][x + qov * p->frame_dec->linesize[0] + offset];



        if (!src[2] || !dst[2])

            continue;



        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];



        for (qov = 0; qov < height>>p->vsub; qov++) {

            for (x = 0; x < width>>p->hsub; x++) {

                p->temp[1][x + qov * p->temp_stride[1]] += p->frame_dec->data[1][x + qov * p->frame_dec->linesize[1] + offset];

                p->temp[2][x + qov * p->temp_stride[2]] += p->frame_dec->data[2][x + qov * p->frame_dec->linesize[2] + offset];

            }

        }

    }



    for (j = 0; j < 3; j++) {

        int is_chroma = !!j;

        if (!dst[j])

            continue;

        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],

                      width  >> (is_chroma ? p->hsub : 0),

                      height >> (is_chroma ? p->vsub : 0),

                      8-p->log2_count);

    }

}
",1,1,0,1,qp_store,-0.2514115273952484,3,33,"{'y': 'qov', 'src_stride': 'vid', 'qp_store': 'samplerate'}",MHM-Origin,86,2.088678765296936
137,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",61,"int main(void)

{

    int nf;

    Suite *chroma_inter_matrix;

    SRunner *usbredir_bulk_packet;



    chroma_inter_matrix = qfloat_suite();

    usbredir_bulk_packet = srunner_create(chroma_inter_matrix);



    srunner_run_all(usbredir_bulk_packet, CK_NORMAL);

    nf = srunner_ntests_failed(usbredir_bulk_packet);

    srunner_free(usbredir_bulk_packet);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",0,0,1,1,s,0.5290567427873611,2,8,"{'sr': 'usbredir_bulk_packet', 's': 'chroma_inter_matrix'}",MHM-Origin,41,2.058090869585673
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
",130,"static target_ulong put_tce_emu(sPAPRTCETable *AV_ZERO32, target_ulong ioba,

                                target_ulong set_sigp_status)

{

    IOMMUTLBEntry HF_TS_MASK;

    hwaddr page_mask = IOMMU_PAGE_MASK(AV_ZERO32->page_shift);

    unsigned long index = (ioba - AV_ZERO32->bus_offset) >> AV_ZERO32->page_shift;



    if (index >= AV_ZERO32->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""
"", ioba);

        return H_PARAMETER;

    }



    AV_ZERO32->table[index] = set_sigp_status;



    HF_TS_MASK.target_as = &address_space_memory,

    HF_TS_MASK.iova = ioba & page_mask;

    HF_TS_MASK.translated_addr = set_sigp_status & page_mask;

    HF_TS_MASK.addr_mask = ~page_mask;

    HF_TS_MASK.perm = spapr_tce_iommu_access_flags(set_sigp_status);

    memory_region_notify_iommu(&AV_ZERO32->iommu, HF_TS_MASK);



    return H_SUCCESS;

}
",0,0,1,1,tce,0.27510887384414673,3,18,"{'tcet': 'AV_ZERO32', 'entry': 'HF_TS_MASK', 'tce': 'set_sigp_status'}",MHM-Origin,125,2.1040411392847695
140,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,

                                    TCGv arg2, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, t1;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, arg1, arg2);



    if (compute_ca) {

        gen_op_arith_compute_ca(ctx, t0, arg1, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, t1);

        gen_op_arith_compute_ca(ctx, t0, t1, 0);

        tcg_temp_free(t1);

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);

    }



    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
",251,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv OPC_DADD_CP2,

                                    TCGv arg2, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, color_space;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,OPC_DADD_CP2) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        color_space = tcg_temp_local_new();

        tcg_gen_mov_tl(color_space, cpu_ca);

    } else {

        TCGV_UNUSED(color_space);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, OPC_DADD_CP2, arg2);



    if (compute_ca) {

        gen_op_arith_compute_ca(ctx, t0, OPC_DADD_CP2, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, color_space);

        gen_op_arith_compute_ca(ctx, t0, color_space, 0);

        tcg_temp_free(color_space);

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(ctx, t0, OPC_DADD_CP2, arg2, 0);

    }



    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
",1,1,0,1,arg1,-0.6971518993377686,2,12,"{'t1': 'color_space', 'arg1': 'OPC_DADD_CP2'}",MHM-Origin,43,2.0823348681132
141,"static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t*)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_end = end - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%mm0    \n\t""

            ""punpcklwd     %5, %%mm1    \n\t""

            ""punpcklwd     %5, %%mm2    \n\t""

            ""punpckhwd     %5, %%mm3    \n\t""

            ""punpckhwd     %5, %%mm4    \n\t""

            ""punpckhwd     %5, %%mm5    \n\t""

            ""psllq         $8, %%mm1    \n\t""

            ""psllq        $16, %%mm2    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""psllq         $8, %%mm4    \n\t""

            ""psllq        $16, %%mm5    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm5, %%mm3    \n\t""



            ""movq       %%mm0, %%mm6    \n\t""

            ""movq       %%mm3, %%mm7    \n\t""



            ""movq         8%1, %%mm0    \n\t""

            ""movq         8%1, %%mm1    \n\t""

            ""movq         8%1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%mm0    \n\t""

            ""punpcklwd     %5, %%mm1    \n\t""

            ""punpcklwd     %5, %%mm2    \n\t""

            ""punpckhwd     %5, %%mm3    \n\t""

            ""punpckhwd     %5, %%mm4    \n\t""

            ""punpckhwd     %5, %%mm5    \n\t""

            ""psllq         $8, %%mm1    \n\t""

            ""psllq        $16, %%mm2    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""psllq         $8, %%mm4    \n\t""

            ""psllq        $16, %%mm5    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm5, %%mm3    \n\t""



            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r), ""m""(mmx_null)

            :""memory"");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            ""movq       %%mm0, %%mm4    \n\t""

            ""movq       %%mm3, %%mm5    \n\t""

            ""movq       %%mm6, %%mm0    \n\t""

            ""movq       %%mm7, %%mm1    \n\t""



            ""movq       %%mm4, %%mm6    \n\t""

            ""movq       %%mm5, %%mm7    \n\t""

            ""movq       %%mm0, %%mm2    \n\t""

            ""movq       %%mm1, %%mm3    \n\t""



            STORE_BGR24_MMX



            :""=m""(*d)

            :""m""(*s)

            :""memory"");

        d += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

    }

}
",434,"static inline void RENAME(rgb15tobgr24)(const uint8_t *pstrcpy_targphys, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t*)pstrcpy_targphys;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_end = end - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movq          %1, %%mm0    
\t""

            ""movq          %1, %%mm1    
\t""

            ""movq          %1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            ""movq       %%mm0, %%mm3    
\t""

            ""movq       %%mm1, %%mm4    
\t""

            ""movq       %%mm2, %%mm5    
\t""

            ""punpcklwd     %5, %%mm0    
\t""

            ""punpcklwd     %5, %%mm1    
\t""

            ""punpcklwd     %5, %%mm2    
\t""

            ""punpckhwd     %5, %%mm3    
\t""

            ""punpckhwd     %5, %%mm4    
\t""

            ""punpckhwd     %5, %%mm5    
\t""

            ""psllq         $8, %%mm1    
\t""

            ""psllq        $16, %%mm2    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""psllq         $8, %%mm4    
\t""

            ""psllq        $16, %%mm5    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm5, %%mm3    
\t""



            ""movq       %%mm0, %%mm6    
\t""

            ""movq       %%mm3, %%mm7    
\t""



            ""movq         8%1, %%mm0    
\t""

            ""movq         8%1, %%mm1    
\t""

            ""movq         8%1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            ""movq       %%mm0, %%mm3    
\t""

            ""movq       %%mm1, %%mm4    
\t""

            ""movq       %%mm2, %%mm5    
\t""

            ""punpcklwd     %5, %%mm0    
\t""

            ""punpcklwd     %5, %%mm1    
\t""

            ""punpcklwd     %5, %%mm2    
\t""

            ""punpckhwd     %5, %%mm3    
\t""

            ""punpckhwd     %5, %%mm4    
\t""

            ""punpckhwd     %5, %%mm5    
\t""

            ""psllq         $8, %%mm1    
\t""

            ""psllq        $16, %%mm2    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""psllq         $8, %%mm4    
\t""

            ""psllq        $16, %%mm5    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm5, %%mm3    
\t""



            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r), ""m""(mmx_null)

            :""memory"");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            ""movq       %%mm0, %%mm4    
\t""

            ""movq       %%mm3, %%mm5    
\t""

            ""movq       %%mm6, %%mm0    
\t""

            ""movq       %%mm7, %%mm1    
\t""



            ""movq       %%mm4, %%mm6    
\t""

            ""movq       %%mm5, %%mm7    
\t""

            ""movq       %%mm0, %%mm2    
\t""

            ""movq       %%mm1, %%mm3    
\t""



            STORE_BGR24_MMX



            :""=m""(*d)

            :""m""(*s)

            :""memory"");

        d += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

    }

}
",1,1,0,1,src,-0.5147107839584351,1,2,{'src': 'pstrcpy_targphys'},MHM-Origin,20,2.0864745378494263
143,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
",113,"static int ftp_file_size(FTPContext *iov_size)

{

    char gpio_addr[CONTROL_BUFFER_SIZE];

    char *aud = NULL;

    const int sysbus_create_varargs[] = {213, 0};



    snprintf(gpio_addr, sizeof(gpio_addr), ""SIZE %s\r
"", iov_size->path);

    if (ftp_send_command(iov_size, gpio_addr, sysbus_create_varargs, &aud)) {

        iov_size->filesize = strtoll(&aud[4], NULL, 10);

    } else {

        iov_size->filesize = -1;

        av_free(aud);

        return AVERROR(EIO);

    }



    av_free(aud);

    return 0;

}
",0,0,0,-1,size_codes,9.634904563426971e-05,4,16,"{'res': 'aud', 'command': 'gpio_addr', 's': 'iov_size', 'size_codes': 'sysbus_create_varargs'}",MHM-Origin,409,2.3754286328951517
146," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }



    tlb_flush(s, 1);

}
",85," void cpu_sh4_invalidate_tlb(CPUSH4State *send_packets)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &send_packets->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &send_packets->utlb[i];

        entry->v = 0;

    }



    tlb_flush(send_packets, 1);

}
",0,0,1,1,s,0.29077552258968353,1,4,{'s': 'send_packets'},MHM-Origin,24,2.141644032796224
147,"uint16_t net_checksum_finish(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}
",32,"uint16_t net_checksum_finish(uint32_t qemu_opt_foreach)

{

    while (qemu_opt_foreach>>16)

	qemu_opt_foreach = (qemu_opt_foreach & 0xFFFF)+(qemu_opt_foreach >> 16);

    return ~qemu_opt_foreach;

}
",0,0,1,1,sum,0.606968994718045,1,6,{'sum': 'qemu_opt_foreach'},MHM-Origin,82,2.177098015944163
148,"static void pci_init_mask_bridge(PCIDevice *d)

{

    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and

       PCI_SEC_LETENCY_TIMER */

    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);



    /* base and limit */

    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;

    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;

    pci_set_word(d->wmask + PCI_MEMORY_BASE,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,

                 PCI_PREF_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,

                 PCI_PREF_RANGE_MASK & 0xffff);



    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */

    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);



    /* Supported memory and i/o types */

    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;

    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;

    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_64);

    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_64);



/* TODO: add this define to pci_regs.h in linux and then in qemu. */

#define  PCI_BRIDGE_CTL_VGA_16BIT	0x10	/* VGA 16-bit decode */

#define  PCI_BRIDGE_CTL_DISCARD		0x100	/* Primary discard timer */

#define  PCI_BRIDGE_CTL_SEC_DISCARD	0x200	/* Secondary discard timer */

#define  PCI_BRIDGE_CTL_DISCARD_STATUS	0x400	/* Discard timer status */

#define  PCI_BRIDGE_CTL_DISCARD_SERR	0x800	/* Discard timer SERR# enable */

/*

 * TODO: Bridges default to 10-bit VGA decoding but we currently only

 * implement 16-bit decoding (no alias support).

 */

    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_PARITY |

                 PCI_BRIDGE_CTL_SERR |

                 PCI_BRIDGE_CTL_ISA |

                 PCI_BRIDGE_CTL_VGA |

                 PCI_BRIDGE_CTL_VGA_16BIT |

                 PCI_BRIDGE_CTL_MASTER_ABORT |

                 PCI_BRIDGE_CTL_BUS_RESET |

                 PCI_BRIDGE_CTL_FAST_BACK |

                 PCI_BRIDGE_CTL_DISCARD |

                 PCI_BRIDGE_CTL_SEC_DISCARD |

                 PCI_BRIDGE_CTL_DISCARD_SERR);

    /* Below does not do anything as we never set this bit, put here for

     * completeness. */

    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_DISCARD_STATUS);

    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;

    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;

    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_MASK);

    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_MASK);

}
",252,"static void pci_init_mask_bridge(PCIDevice *tb_unreliable)

{

    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and

       PCI_SEC_LETENCY_TIMER */

    memset(tb_unreliable->wmask + PCI_PRIMARY_BUS, 0xff, 4);



    /* base and limit */

    tb_unreliable->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;

    tb_unreliable->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;

    pci_set_word(tb_unreliable->wmask + PCI_MEMORY_BASE,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(tb_unreliable->wmask + PCI_MEMORY_LIMIT,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(tb_unreliable->wmask + PCI_PREF_MEMORY_BASE,

                 PCI_PREF_RANGE_MASK & 0xffff);

    pci_set_word(tb_unreliable->wmask + PCI_PREF_MEMORY_LIMIT,

                 PCI_PREF_RANGE_MASK & 0xffff);



    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */

    memset(tb_unreliable->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);



    /* Supported memory and i/o types */

    tb_unreliable->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;

    tb_unreliable->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;

    pci_word_test_and_set_mask(tb_unreliable->config + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_64);

    pci_word_test_and_set_mask(tb_unreliable->config + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_64);



/* TODO: add this define to pci_regs.h in linux and then in qemu. */

#define  PCI_BRIDGE_CTL_VGA_16BIT	0x10	/* VGA 16-bit decode */

#define  PCI_BRIDGE_CTL_DISCARD		0x100	/* Primary discard timer */

#define  PCI_BRIDGE_CTL_SEC_DISCARD	0x200	/* Secondary discard timer */

#define  PCI_BRIDGE_CTL_DISCARD_STATUS	0x400	/* Discard timer status */

#define  PCI_BRIDGE_CTL_DISCARD_SERR	0x800	/* Discard timer SERR# enable */

/*

 * TODO: Bridges default to 10-bit VGA decoding but we currently only

 * implement 16-bit decoding (no alias support).

 */

    pci_set_word(tb_unreliable->wmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_PARITY |

                 PCI_BRIDGE_CTL_SERR |

                 PCI_BRIDGE_CTL_ISA |

                 PCI_BRIDGE_CTL_VGA |

                 PCI_BRIDGE_CTL_VGA_16BIT |

                 PCI_BRIDGE_CTL_MASTER_ABORT |

                 PCI_BRIDGE_CTL_BUS_RESET |

                 PCI_BRIDGE_CTL_FAST_BACK |

                 PCI_BRIDGE_CTL_DISCARD |

                 PCI_BRIDGE_CTL_SEC_DISCARD |

                 PCI_BRIDGE_CTL_DISCARD_SERR);

    /* Below does not do anything as we never set this bit, put here for

     * completeness. */

    pci_set_word(tb_unreliable->w1cmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_DISCARD_STATUS);

    tb_unreliable->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;

    tb_unreliable->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;

    pci_word_test_and_set_mask(tb_unreliable->cmask + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_MASK);

    pci_word_test_and_set_mask(tb_unreliable->cmask + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_MASK);

}
",0,0,0,-1,d,0.012898692861199379,1,19,{'d': 'tb_unreliable'},MHM-Origin,417,2.6625513434410095
150,"static void gpollfds_from_select(void)

{

    int fd;

    for (fd = 0; fd <= nfds; fd++) {

        int events = 0;

        if (FD_ISSET(fd, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(fd, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(fd, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .fd = fd,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",114,"static void gpollfds_from_select(void)

{

    int vram_size;

    for (vram_size = 0; vram_size <= nfds; vram_size++) {

        int events = 0;

        if (FD_ISSET(vram_size, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(vram_size, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(vram_size, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .vram_size = vram_size,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",0,0,0,-1,fd,0.004450909793376923,1,9,{'fd': 'vram_size'},MHM-Origin,408,2.689641765753428
151,"static int decode_frame(AVCodecContext *avctx,

                        void *data, int *got_frame, AVPacket *avpkt)

{

    TiffContext *const s = avctx->priv_data;

    AVFrame *const p = data;

    ThreadFrame frame = { .f = data };

    unsigned off;

    int le, ret, plane, planes;

    int i, j, entries, stride;

    unsigned soff, ssize;

    uint8_t *dst;

    GetByteContext stripsizes;

    GetByteContext stripdata;



    bytestream2_init(&s->gb, avpkt->data, avpkt->size);



    // parse image header

    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header\n"");

        return ret;

    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {

        av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size\n"");

        return AVERROR_INVALIDDATA;

    }

    s->le          = le;

    // TIFF_BPP is not a required tag and defaults to 1

    s->bppcount    = s->bpp = 1;

    s->photometric = TIFF_PHOTOMETRIC_NONE;

    s->compr       = TIFF_RAW;

    s->fill_order  = 0;

    free_geotags(s);



    // Reset these offsets so we can tell if they were set this frame

    s->stripsizesoff = s->strippos = 0;

    /* parse image file directory */

    bytestream2_seek(&s->gb, off, SEEK_SET);

    entries = ff_tget_short(&s->gb, le);

    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)

        return AVERROR_INVALIDDATA;

    for (i = 0; i < entries; i++) {

        if ((ret = tiff_decode_tag(s, p)) < 0)

            return ret;

    }



    for (i = 0; i<s->geotag_count; i++) {

        const char *keyname = get_geokey_name(s->geotags[i].key);

        if (!keyname) {

            av_log(avctx, AV_LOG_WARNING, ""Unknown or unsupported GeoTIFF key %d\n"", s->geotags[i].key);

            continue;

        }

        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {

            av_log(avctx, AV_LOG_WARNING, ""Type of GeoTIFF key %d is wrong\n"", s->geotags[i].key);

            continue;

        }

        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);

        if (ret<0) {

            av_log(avctx, AV_LOG_ERROR, ""Writing metadata with key '%s' failed\n"", keyname);

            return ret;

        }

    }



    if (!s->strippos && !s->stripoff) {

        av_log(avctx, AV_LOG_ERROR, ""Image data is missing\n"");

        return AVERROR_INVALIDDATA;

    }

    /* now we have the data and may start decoding */

    if ((ret = init_image(s, &frame)) < 0)

        return ret;



    if (s->strips == 1 && !s->stripsize) {

        av_log(avctx, AV_LOG_WARNING, ""Image data size missing\n"");

        s->stripsize = avpkt->size - s->stripoff;

    }



    if (s->stripsizesoff) {

        if (s->stripsizesoff >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,

                         avpkt->size - s->stripsizesoff);

    }

    if (s->strippos) {

        if (s->strippos >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripdata, avpkt->data + s->strippos,

                         avpkt->size - s->strippos);

    }



    if (s->rps <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""rps %d invalid\n"", s->rps);

        return AVERROR_INVALIDDATA;

    }



    planes = s->planar ? s->bppcount : 1;

    for (plane = 0; plane < planes; plane++) {

        stride = p->linesize[plane];

        dst = p->data[plane];

        for (i = 0; i < s->height; i += s->rps) {

            if (s->stripsizesoff)

                ssize = ff_tget(&stripsizes, s->sstype, le);

            else

                ssize = s->stripsize;



            if (s->strippos)

                soff = ff_tget(&stripdata, s->sot, le);

            else

                soff = s->stripoff;



            if (soff > avpkt->size || ssize > avpkt->size - soff) {

                av_log(avctx, AV_LOG_ERROR, ""Invalid strip size/offset\n"");

                return AVERROR_INVALIDDATA;

            }

            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,

                                         FFMIN(s->rps, s->height - i))) < 0) {

                if (avctx->err_recognition & AV_EF_EXPLODE)

                    return ret;

                break;

            }

            dst += s->rps * stride;

        }

        if (s->predictor == 2) {

            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {

                av_log(s->avctx, AV_LOG_ERROR, ""predictor == 2 with YUV is unsupported"");

                return AVERROR_PATCHWELCOME;

            }

            dst   = p->data[plane];

            soff  = s->bpp >> 3;

            if (s->planar)

                soff  = FFMAX(soff / s->bppcount, 1);

            ssize = s->width * soff;

            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));

                    dst += stride;

                }

            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));

                    dst += stride;

                }

            } else {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j++)

                        dst[j] += dst[j - soff];

                    dst += stride;

                }

            }

        }



        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {

            dst = p->data[plane];

            for (i = 0; i < s->height; i++) {

                for (j = 0; j < stride; j++)

                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];

                dst += stride;

            }

        }

    }



    if (s->planar && s->bppcount > 2) {

        FFSWAP(uint8_t*, p->data[0],     p->data[2]);

        FFSWAP(int,      p->linesize[0], p->linesize[2]);

        FFSWAP(uint8_t*, p->data[0],     p->data[1]);

        FFSWAP(int,      p->linesize[0], p->linesize[1]);

    }



    *got_frame = 1;



    return avpkt->size;

}
",1397,"static int decode_frame(AVCodecContext *avctx,

                        void *data, int *got_frame, AVPacket *avpkt)

{

    TiffContext *const s = avctx->priv_data;

    AVFrame *const p = data;

    ThreadFrame frame = { .f = data };

    unsigned off;

    int le, ret, FW_CFG_KERNEL_ADDR, planes;

    int i, j, entries, stride;

    unsigned soff, ssize;

    uint8_t *dst;

    GetByteContext stripsizes;

    GetByteContext stripdata;



    bytestream2_init(&s->gb, avpkt->data, avpkt->size);



    // parse image header

    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header
"");

        return ret;

    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {

        av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size
"");

        return AVERROR_INVALIDDATA;

    }

    s->le          = le;

    // TIFF_BPP is not a required tag and defaults to 1

    s->bppcount    = s->bpp = 1;

    s->photometric = TIFF_PHOTOMETRIC_NONE;

    s->compr       = TIFF_RAW;

    s->fill_order  = 0;

    free_geotags(s);



    // Reset these offsets so we can tell if they were set this frame

    s->stripsizesoff = s->strippos = 0;

    /* parse image file directory */

    bytestream2_seek(&s->gb, off, SEEK_SET);

    entries = ff_tget_short(&s->gb, le);

    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)

        return AVERROR_INVALIDDATA;

    for (i = 0; i < entries; i++) {

        if ((ret = tiff_decode_tag(s, p)) < 0)

            return ret;

    }



    for (i = 0; i<s->geotag_count; i++) {

        const char *keyname = get_geokey_name(s->geotags[i].key);

        if (!keyname) {

            av_log(avctx, AV_LOG_WARNING, ""Unknown or unsupported GeoTIFF key %d
"", s->geotags[i].key);

            continue;

        }

        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {

            av_log(avctx, AV_LOG_WARNING, ""Type of GeoTIFF key %d is wrong
"", s->geotags[i].key);

            continue;

        }

        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);

        if (ret<0) {

            av_log(avctx, AV_LOG_ERROR, ""Writing metadata with key '%s' failed
"", keyname);

            return ret;

        }

    }



    if (!s->strippos && !s->stripoff) {

        av_log(avctx, AV_LOG_ERROR, ""Image data is missing
"");

        return AVERROR_INVALIDDATA;

    }

    /* now we have the data and may start decoding */

    if ((ret = init_image(s, &frame)) < 0)

        return ret;



    if (s->strips == 1 && !s->stripsize) {

        av_log(avctx, AV_LOG_WARNING, ""Image data size missing
"");

        s->stripsize = avpkt->size - s->stripoff;

    }



    if (s->stripsizesoff) {

        if (s->stripsizesoff >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,

                         avpkt->size - s->stripsizesoff);

    }

    if (s->strippos) {

        if (s->strippos >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripdata, avpkt->data + s->strippos,

                         avpkt->size - s->strippos);

    }



    if (s->rps <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""rps %d invalid
"", s->rps);

        return AVERROR_INVALIDDATA;

    }



    planes = s->planar ? s->bppcount : 1;

    for (FW_CFG_KERNEL_ADDR = 0; FW_CFG_KERNEL_ADDR < planes; FW_CFG_KERNEL_ADDR++) {

        stride = p->linesize[FW_CFG_KERNEL_ADDR];

        dst = p->data[FW_CFG_KERNEL_ADDR];

        for (i = 0; i < s->height; i += s->rps) {

            if (s->stripsizesoff)

                ssize = ff_tget(&stripsizes, s->sstype, le);

            else

                ssize = s->stripsize;



            if (s->strippos)

                soff = ff_tget(&stripdata, s->sot, le);

            else

                soff = s->stripoff;



            if (soff > avpkt->size || ssize > avpkt->size - soff) {

                av_log(avctx, AV_LOG_ERROR, ""Invalid strip size/offset
"");

                return AVERROR_INVALIDDATA;

            }

            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,

                                         FFMIN(s->rps, s->height - i))) < 0) {

                if (avctx->err_recognition & AV_EF_EXPLODE)

                    return ret;

                break;

            }

            dst += s->rps * stride;

        }

        if (s->predictor == 2) {

            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {

                av_log(s->avctx, AV_LOG_ERROR, ""predictor == 2 with YUV is unsupported"");

                return AVERROR_PATCHWELCOME;

            }

            dst   = p->data[FW_CFG_KERNEL_ADDR];

            soff  = s->bpp >> 3;

            if (s->planar)

                soff  = FFMAX(soff / s->bppcount, 1);

            ssize = s->width * soff;

            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));

                    dst += stride;

                }

            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));

                    dst += stride;

                }

            } else {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j++)

                        dst[j] += dst[j - soff];

                    dst += stride;

                }

            }

        }



        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {

            dst = p->data[FW_CFG_KERNEL_ADDR];

            for (i = 0; i < s->height; i++) {

                for (j = 0; j < stride; j++)

                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];

                dst += stride;

            }

        }

    }



    if (s->planar && s->bppcount > 2) {

        FFSWAP(uint8_t*, p->data[0],     p->data[2]);

        FFSWAP(int,      p->linesize[0], p->linesize[2]);

        FFSWAP(uint8_t*, p->data[0],     p->data[1]);

        FFSWAP(int,      p->linesize[0], p->linesize[1]);

    }



    *got_frame = 1;



    return avpkt->size;

}
",0,0,1,1,plane,0.06922060251235962,1,8,{'plane': 'FW_CFG_KERNEL_ADDR'},MHM-Origin,22,2.4555107752482095
153,"static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,

                                      MegasasCmd *cmd)

{

    struct mfi_pd_info *info = cmd->iov_buf;

    size_t dcmd_size = sizeof(struct mfi_pd_info);

    uint64_t pd_size;

    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);

    uint8_t cmdbuf[6];

    SCSIRequest *req;

    size_t len, resid;



    if (!cmd->iov_buf) {

        cmd->iov_buf = g_malloc0(dcmd_size);

        info = cmd->iov_buf;

        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */

        info->vpd_page83[0] = 0x7f;

        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info std inquiry"");

            g_free(cmd->iov_buf);

            cmd->iov_buf = NULL;

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info std inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {

        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info vpd inquiry"");

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info vpd inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    }

    /* Finished, set FW state */

    if ((info->inquiry_data[0] >> 5) == 0) {

        if (megasas_is_jbod(cmd->state)) {

            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);

        } else {

            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);

        }

    } else {

        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);

    }



    info->ref.v.device_id = cpu_to_le16(pd_id);

    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|

                                          MFI_PD_DDF_TYPE_INTF_SAS);

    blk_get_geometry(sdev->conf.blk, &pd_size);

    info->raw_size = cpu_to_le64(pd_size);

    info->non_coerced_size = cpu_to_le64(pd_size);

    info->coerced_size = cpu_to_le64(pd_size);

    info->encl_device_id = 0xFFFF;

    info->slot_number = (sdev->id & 0xFF);

    info->path_info.count = 1;

    info->path_info.sas_addr[0] =

        cpu_to_le64(megasas_get_sata_addr(pd_id));

    info->connected_port_bitmap = 0x1;

    info->device_speed = 1;

    info->link_speed = 1;

    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);

    g_free(cmd->iov_buf);

    cmd->iov_size = dcmd_size - resid;

    cmd->iov_buf = NULL;

    return MFI_STAT_OK;

}
",565,"static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,

                                      MegasasCmd *cmd)

{

    struct mfi_pd_info *floatx80_eq = cmd->iov_buf;

    size_t dcmd_size = sizeof(struct mfi_pd_info);

    uint64_t pd_size;

    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);

    uint8_t cmdbuf[6];

    SCSIRequest *req;

    size_t len, resid;



    if (!cmd->iov_buf) {

        cmd->iov_buf = g_malloc0(dcmd_size);

        floatx80_eq = cmd->iov_buf;

        floatx80_eq->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */

        floatx80_eq->vpd_page83[0] = 0x7f;

        megasas_setup_inquiry(cmdbuf, 0, sizeof(floatx80_eq->inquiry_data));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info std inquiry"");

            g_free(cmd->iov_buf);

            cmd->iov_buf = NULL;

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info std inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    } else if (floatx80_eq->inquiry_data[0] != 0x7f && floatx80_eq->vpd_page83[0] == 0x7f) {

        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(floatx80_eq->vpd_page83));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info vpd inquiry"");

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info vpd inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    }

    /* Finished, set FW state */

    if ((floatx80_eq->inquiry_data[0] >> 5) == 0) {

        if (megasas_is_jbod(cmd->state)) {

            floatx80_eq->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);

        } else {

            floatx80_eq->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);

        }

    } else {

        floatx80_eq->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);

    }



    floatx80_eq->ref.v.device_id = cpu_to_le16(pd_id);

    floatx80_eq->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|

                                          MFI_PD_DDF_TYPE_INTF_SAS);

    blk_get_geometry(sdev->conf.blk, &pd_size);

    floatx80_eq->raw_size = cpu_to_le64(pd_size);

    floatx80_eq->non_coerced_size = cpu_to_le64(pd_size);

    floatx80_eq->coerced_size = cpu_to_le64(pd_size);

    floatx80_eq->encl_device_id = 0xFFFF;

    floatx80_eq->slot_number = (sdev->id & 0xFF);

    floatx80_eq->path_info.count = 1;

    floatx80_eq->path_info.sas_addr[0] =

        cpu_to_le64(megasas_get_sata_addr(pd_id));

    floatx80_eq->connected_port_bitmap = 0x1;

    floatx80_eq->device_speed = 1;

    floatx80_eq->link_speed = 1;

    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);

    g_free(cmd->iov_buf);

    cmd->iov_size = dcmd_size - resid;

    cmd->iov_buf = NULL;

    return MFI_STAT_OK;

}
",1,1,0,1,info,-0.28923213481903076,1,24,{'info': 'floatx80_eq'},MHM-Origin,23,2.4724890271822613
154,"static void gen_isel(DisasContext *ctx)

{

    int l1, l2;

    uint32_t bi = rC(ctx->opcode);

    uint32_t mask;

    TCGv_i32 t0;



    l1 = gen_new_label();

    l2 = gen_new_label();



    mask = 0x08 >> (bi & 0x03);

    t0 = tcg_temp_new_i32();

    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    if (rA(ctx->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);

    gen_set_label(l2);

    tcg_temp_free_i32(t0);

}
",177,"static void gen_isel(DisasContext *SHIFT)

{

    int tcg_temp_free_i32, new_rematrixing_strategy;

    uint32_t bi = rC(SHIFT->opcode);

    uint32_t VhostUserState;

    TCGv_i32 rv34_decode_mv;



    tcg_temp_free_i32 = gen_new_label();

    new_rematrixing_strategy = gen_new_label();



    VhostUserState = 0x08 >> (bi & 0x03);

    rv34_decode_mv = tcg_temp_new_i32();

    tcg_gen_andi_i32(rv34_decode_mv, cpu_crf[bi >> 2], VhostUserState);

    tcg_gen_brcondi_i32(TCG_COND_EQ, rv34_decode_mv, 0, tcg_temp_free_i32);

    if (rA(SHIFT->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(SHIFT->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(SHIFT->opcode)], cpu_gpr[rA(SHIFT->opcode)]);

    tcg_gen_br(new_rematrixing_strategy);

    gen_set_label(tcg_temp_free_i32);

    tcg_gen_mov_tl(cpu_gpr[rD(SHIFT->opcode)], cpu_gpr[rB(SHIFT->opcode)]);

    gen_set_label(new_rematrixing_strategy);

    tcg_temp_free_i32(rv34_decode_mv);

}
",0,0,0,-1,ctx,0.007633841596543789,5,24,"{'ctx': 'SHIFT', 'l1': 'tcg_temp_free_i32', 'l2': 'new_rematrixing_strategy', 'mask': 'VhostUserState', 't0': 'rv34_decode_mv'}",MHM-Origin,412,2.7844258705774942
155,"static void stream_process_mem2s(struct Stream *s,

                                 StreamSlave *tx_dev)

{

    uint32_t prev_d;

    unsigned char txbuf[16 * 1024];

    unsigned int txlen;

    uint32_t app[6];



    if (!stream_running(s) || stream_idle(s)) {

        return;

    }



    while (1) {

        stream_desc_load(s, s->regs[R_CURDESC]);



        if (s->desc.status & SDESC_STATUS_COMPLETE) {

            s->regs[R_DMASR] |= DMASR_HALTED;

            break;

        }



        if (stream_desc_sof(&s->desc)) {

            s->pos = 0;

            memcpy(app, s->desc.app, sizeof app);

        }



        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;

        if ((txlen + s->pos) > sizeof txbuf) {

            hw_error(""%s: too small internal txbuf! %d\n"", __func__,

                     txlen + s->pos);

        }



        cpu_physical_memory_read(s->desc.buffer_address,

                                 txbuf + s->pos, txlen);

        s->pos += txlen;



        if (stream_desc_eof(&s->desc)) {

            stream_push(tx_dev, txbuf, s->pos, app);

            s->pos = 0;

            stream_complete(s);

        }



        /* Update the descriptor.  */

        s->desc.status = txlen | SDESC_STATUS_COMPLETE;

        stream_desc_store(s, s->regs[R_CURDESC]);



        /* Advance.  */

        prev_d = s->regs[R_CURDESC];

        s->regs[R_CURDESC] = s->desc.nxtdesc;

        if (prev_d == s->regs[R_TAILDESC]) {

            s->regs[R_DMASR] |= DMASR_IDLE;

            break;

        }

    }

}
",293,"static void stream_process_mem2s(struct Stream *MAX_FIXED_COUNTERS,

                                 StreamSlave *AV_OPT_FLAG_ENCODING_PARAM)

{

    uint32_t ACPI_PCIHP_OFFSET_EJ0;

    unsigned char alpToYV12[16 * 1024];

    unsigned int start;

    uint32_t shmobj[6];



    if (!stream_running(MAX_FIXED_COUNTERS) || stream_idle(MAX_FIXED_COUNTERS)) {

        return;

    }



    while (1) {

        stream_desc_load(MAX_FIXED_COUNTERS, MAX_FIXED_COUNTERS->regs[R_CURDESC]);



        if (MAX_FIXED_COUNTERS->desc.status & SDESC_STATUS_COMPLETE) {

            MAX_FIXED_COUNTERS->regs[R_DMASR] |= DMASR_HALTED;

            break;

        }



        if (stream_desc_sof(&MAX_FIXED_COUNTERS->desc)) {

            MAX_FIXED_COUNTERS->pos = 0;

            memcpy(shmobj, MAX_FIXED_COUNTERS->desc.shmobj, sizeof shmobj);

        }



        start = MAX_FIXED_COUNTERS->desc.control & SDESC_CTRL_LEN_MASK;

        if ((start + MAX_FIXED_COUNTERS->pos) > sizeof alpToYV12) {

            hw_error(""%s: too small internal txbuf! %d
"", __func__,

                     start + MAX_FIXED_COUNTERS->pos);

        }



        cpu_physical_memory_read(MAX_FIXED_COUNTERS->desc.buffer_address,

                                 alpToYV12 + MAX_FIXED_COUNTERS->pos, start);

        MAX_FIXED_COUNTERS->pos += start;



        if (stream_desc_eof(&MAX_FIXED_COUNTERS->desc)) {

            stream_push(AV_OPT_FLAG_ENCODING_PARAM, alpToYV12, MAX_FIXED_COUNTERS->pos, shmobj);

            MAX_FIXED_COUNTERS->pos = 0;

            stream_complete(MAX_FIXED_COUNTERS);

        }



        /* Update the descriptor.  */

        MAX_FIXED_COUNTERS->desc.status = start | SDESC_STATUS_COMPLETE;

        stream_desc_store(MAX_FIXED_COUNTERS, MAX_FIXED_COUNTERS->regs[R_CURDESC]);



        /* Advance.  */

        ACPI_PCIHP_OFFSET_EJ0 = MAX_FIXED_COUNTERS->regs[R_CURDESC];

        MAX_FIXED_COUNTERS->regs[R_CURDESC] = MAX_FIXED_COUNTERS->desc.nxtdesc;

        if (ACPI_PCIHP_OFFSET_EJ0 == MAX_FIXED_COUNTERS->regs[R_TAILDESC]) {

            MAX_FIXED_COUNTERS->regs[R_DMASR] |= DMASR_IDLE;

            break;

        }

    }

}
",0,0,1,1,tx_dev,0.4930281639099121,6,49,"{'app': 'shmobj', 'prev_d': 'ACPI_PCIHP_OFFSET_EJ0', 's': 'MAX_FIXED_COUNTERS', 'txlen': 'start', 'txbuf': 'alpToYV12', 'tx_dev': 'AV_OPT_FLAG_ENCODING_PARAM'}",MHM-Origin,347,2.9305244286855063
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",79,"static void test_qemu_strtoll_whitespace(void)

{

    const char *x86_ldsw_code = ""  \t  "";

    char f = 'X';

    const char *MAX_BOUNCE_BUFFER = &f;

    int64_t res = 999;

    int MSR_P6_EVNTSEL0;



    MSR_P6_EVNTSEL0 = qemu_strtoll(x86_ldsw_code, &MAX_BOUNCE_BUFFER, 0, &res);



    g_assert_cmpint(MSR_P6_EVNTSEL0, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(MAX_BOUNCE_BUFFER == x86_ldsw_code);

}
",1,1,0,1,str,-0.5909861028194427,3,9,"{'endptr': 'MAX_BOUNCE_BUFFER', 'err': 'MSR_P6_EVNTSEL0', 'str': 'x86_ldsw_code'}",MHM-Origin,63,2.7429208358128867
161,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!tso_enable) {

        goto func_exit;

    }



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:

    return rc;

}
",80,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *tight_palette_buf2rgb,

                                          bool image_filename)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t d_ot;



    d_ot = eth_get_l3_proto(tight_palette_buf2rgb->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        tight_palette_buf2rgb->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!image_filename) {

        goto func_exit;

    }



    rc = eth_get_gso_type(d_ot, tight_palette_buf2rgb->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          tight_palette_buf2rgb->l4proto);



func_exit:

    return rc;

}
",0,0,0,-1,tso_enable,0.0081207025796175,3,10,"{'tso_enable': 'image_filename', 'l3_proto': 'd_ot', 'pkt': 'tight_palette_buf2rgb'}",MHM-Origin,415,3.024954112370809
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
",75,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->bdrv_set_buffer_alignment;

    return 0;

}
",1,1,0,1,size,-0.5072294175624847,1,1,{'size': 'bdrv_set_buffer_alignment'},MHM-Origin,23,2.759520721435547
165,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    unsigned int offset, w, h, y, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_pixel = AV_RL16(buf+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.\n"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c\n"");



    buf += offset;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, p) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*bytes_per_pixel);

#endif

        ptr += stride;

        buf += w*bytes_per_pixel;

    }



    *picture = s->picture;

    *data_size = sizeof(AVPicture);



    return offset + w*h*bytes_per_pixel;

}",381,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const likely = &s->picture;

    unsigned int offset, w, h, y, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_pixel = AV_RL16(buf+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.
"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c
"");



    buf += offset;



    if (likely->data[0])

        avctx->release_buffer(avctx, likely);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, likely) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    likely->pict_type = AV_PICTURE_TYPE_I;



    ptr    = likely->data[0];

    stride = likely->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*bytes_per_pixel);

#endif

        ptr += stride;

        buf += w*bytes_per_pixel;

    }



    *picture = s->picture;

    *data_size = sizeof(AVPicture);



    return offset + w*h*bytes_per_pixel;

}",1,1,0,1,p,-0.15792614221572876,1,7,{'p': 'likely'},MHM-Origin,22,2.761972101529439
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",49,"static void vpc_close(BlockDriverState *resync_mb_y)

{

    BDRVVPCState *s = resync_mb_y->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",1,1,0,1,bs,-0.5715264230966568,1,2,{'bs': 'resync_mb_y'},MHM-Origin,39,2.794952166080475
168,"static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!s->pb->eof_reached) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", klv.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_system_item_key)) {

            if (!mxf->current_partition->essence_offset) {

                compute_partition_essence_offset(s, mxf, &klv);

            }



            if (!essence_offset)

                essence_offset = klv.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&

                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

        }



        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {

            if (IS_KLV_KEY(klv.key, metadata->key)) {

                int res;

                if (klv.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);

                } else {

                    uint64_t next = avio_tell(s->pb) + klv.length;

                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);

                    avio_seek(s->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(s, AV_LOG_ERROR, ""error reading header metadata\n"");

                    return res;

                }

                break;

            }

        }

        if (!metadata->read)

            avio_skip(s->pb, klv.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(s, AV_LOG_ERROR, ""no essence\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    return mxf_parse_structural_metadata(mxf);

}
",514,"static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket tcg_temp_new_i32;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key
"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!s->pb->eof_reached) {

        const MXFMetadataReadTableEntry *nbands;



        if (klv_read_packet(&tcg_temp_new_i32, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", tcg_temp_new_i32.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""
"", tcg_temp_new_i32.length, tcg_temp_new_i32.offset);

        if (IS_KLV_KEY(tcg_temp_new_i32.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(tcg_temp_new_i32.key, mxf_essence_element_key) ||

            IS_KLV_KEY(tcg_temp_new_i32.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(tcg_temp_new_i32.key, mxf_system_item_key)) {

            if (!mxf->current_partition->essence_offset) {

                compute_partition_essence_offset(s, mxf, &tcg_temp_new_i32);

            }



            if (!essence_offset)

                essence_offset = tcg_temp_new_i32.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(tcg_temp_new_i32.key, mxf_header_partition_pack_key, 13) &&

                   tcg_temp_new_i32.key[13] >= 2 && tcg_temp_new_i32.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

        }



        for (nbands = mxf_metadata_read_table; nbands->read; nbands++) {

            if (IS_KLV_KEY(tcg_temp_new_i32.key, nbands->key)) {

                int res;

                if (tcg_temp_new_i32.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &tcg_temp_new_i32, nbands->read, nbands->ctx_size, nbands->type);

                } else {

                    uint64_t next = avio_tell(s->pb) + tcg_temp_new_i32.length;

                    res = nbands->read(mxf, s->pb, 0, tcg_temp_new_i32.length, tcg_temp_new_i32.key, tcg_temp_new_i32.offset);

                    avio_seek(s->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(s, AV_LOG_ERROR, ""error reading header metadata
"");

                    return res;

                }

                break;

            }

        }

        if (!nbands->read)

            avio_skip(s->pb, tcg_temp_new_i32.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(s, AV_LOG_ERROR, ""no essence
"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    return mxf_parse_structural_metadata(mxf);

}
",1,1,0,1,metadata,-0.04290136694908142,2,32,"{'klv': 'tcg_temp_new_i32', 'metadata': 'nbands'}",MHM-Origin,41,2.8345449566841125
169,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *img;
    int i;
    int sub_dx[4];
    int sub_dy[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    sub_dx[0] = sub_dx[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;
    numcomps = desc->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported\n"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = sub_dx[i];
        cmptparm[i].dy = sub_dy[i];
        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];
        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];
    }
    img = opj_image_create(numcomps, cmptparm, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    img->x0 = 0;
    img->y0 = 0;
    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;
    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;
    return img;
}",513,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *redundancy_output = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t envs[4] = {{0}};
    opj_image_t *img;
    int endbyte_bits;
    int xen_9pfs_evtchn_event[4];
    int sub_dy[4];
    int arg8;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    xen_9pfs_evtchn_event[0] = xen_9pfs_evtchn_event[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    xen_9pfs_evtchn_event[1] = xen_9pfs_evtchn_event[2] = 1 << redundancy_output->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << redundancy_output->log2_chroma_h;
    arg8 = redundancy_output->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported
"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (endbyte_bits = 0; endbyte_bits < arg8; endbyte_bits++) {
        envs[endbyte_bits].prec = redundancy_output->comp[endbyte_bits].depth_minus1 + 1;
        envs[endbyte_bits].bpp  = redundancy_output->comp[endbyte_bits].depth_minus1 + 1;
        envs[endbyte_bits].sgnd = 0;
        envs[endbyte_bits].dx = xen_9pfs_evtchn_event[endbyte_bits];
        envs[endbyte_bits].dy = sub_dy[endbyte_bits];
        envs[endbyte_bits].w = (avctx->width + xen_9pfs_evtchn_event[endbyte_bits] - 1) / xen_9pfs_evtchn_event[endbyte_bits];
        envs[endbyte_bits].h = (avctx->height + sub_dy[endbyte_bits] - 1) / sub_dy[endbyte_bits];
    }
    img = opj_image_create(arg8, envs, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    img->x0 = 0;
    img->y0 = 0;
    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;
    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;
    return img;
}",1,1,0,1,sub_dx,-0.3689217269420624,5,46,"{'i': 'endbyte_bits', 'sub_dx': 'xen_9pfs_evtchn_event', 'numcomps': 'arg8', 'cmptparm': 'envs', 'desc': 'redundancy_output'}",MHM-Origin,163,3.0040537198384603
170,"static int xen_platform_initfn(PCIDevice *dev)

{

    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);

    uint8_t *pci_conf;



    pci_conf = d->pci_dev.config;



    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);



    pci_config_set_prog_interface(pci_conf, 0);



    pci_conf[PCI_INTERRUPT_PIN] = 1;



    pci_register_bar(&d->pci_dev, 0, 0x100,

            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);



    /* reserve 16MB mmio address for share memory*/

    pci_register_bar(&d->pci_dev, 1, 0x1000000,

            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);



    platform_fixed_ioport_init(d);



    return 0;

}
",100,"static int xen_platform_initfn(PCIDevice *regs)

{

    PCIXenPlatformState *col_fieldoff = DO_UPCAST(PCIXenPlatformState, pci_dev, regs);

    uint8_t *out;



    out = col_fieldoff->pci_dev.config;



    pci_set_word(out + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);



    pci_config_set_prog_interface(out, 0);



    out[PCI_INTERRUPT_PIN] = 1;



    pci_register_bar(&col_fieldoff->pci_dev, 0, 0x100,

            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);



    /* reserve 16MB mmio address for share memory*/

    pci_register_bar(&col_fieldoff->pci_dev, 1, 0x1000000,

            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);



    platform_fixed_ioport_init(col_fieldoff);



    return 0;

}
",0,0,0,-1,d,0.014698633924126625,3,12,"{'pci_conf': 'out', 'd': 'col_fieldoff', 'dev': 'regs'}",MHM-Origin,407,3.232025957107544
171,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *dir_path, const char *name, FsCred *credp)

{

    int retval;

    V9fsString fullname, target;



    v9fs_string_init(&fullname);

    v9fs_string_init(&target);



    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    v9fs_string_sprintf(&target, ""%s"", oldpath);



    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &target, &fullname, credp->fc_uid, credp->fc_gid);

    v9fs_string_free(&fullname);

    v9fs_string_free(&target);

    if (retval < 0) {

        errno = -retval;

        retval = -1;

    }

    return retval;

}
",136,"static int proxy_symlink(FsContext *fs_ctx, const char *IO_MEM_RAM,

                         V9fsPath *depth, const char *extent_file, FsCred *obits)

{

    int mpeg2;

    V9fsString arg5, yi;



    v9fs_string_init(&arg5);

    v9fs_string_init(&yi);



    v9fs_string_sprintf(&arg5, ""%s/%s"", depth->data, extent_file);

    v9fs_string_sprintf(&yi, ""%s"", IO_MEM_RAM);



    mpeg2 = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &yi, &arg5, obits->fc_uid, obits->fc_gid);

    v9fs_string_free(&arg5);

    v9fs_string_free(&yi);

    if (mpeg2 < 0) {

        errno = -mpeg2;

        mpeg2 = -1;

    }

    return mpeg2;

}
",0,0,0,-1,target,-1.3373792171478271e-05,7,25,"{'fullname': 'arg5', 'oldpath': 'IO_MEM_RAM', 'retval': 'mpeg2', 'target': 'yi', 'dir_path': 'depth', 'credp': 'obits', 'name': 'extent_file'}",MHM-Origin,410,3.318600579102834
172,"static int vfio_enable_intx(VFIODevice *vdev)

{

    VFIOIRQSetFD irq_set_fd = {

        .irq_set = {

            .argsz = sizeof(irq_set_fd),

            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,

            .index = VFIO_PCI_INTX_IRQ_INDEX,

            .start = 0,

            .count = 1,

        },

    };

    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);

    int ret;



    if (vdev->intx.disabled || !pin) {

        return 0;

    }



    vfio_disable_interrupts(vdev);



    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */

    ret = event_notifier_init(&vdev->intx.interrupt, 0);

    if (ret) {

        error_report(""vfio: Error: event_notifier_init failed\n"");

        return ret;

    }



    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);

    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);



    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {

        error_report(""vfio: Error: Failed to setup INTx fd: %m\n"");

        return -errno;

    }



    /*

     * Disable mmaps so we can trap on BAR accesses.  We interpret any

     * access as a response to an interrupt and unmask the physical

     * device.  The device will re-assert if the interrupt is still

     * pending.  We'll likely retrigger on the host multiple times per

     * guest interrupt, but without EOI notification it's better than

     * nothing.  Acceleration paths through KVM will avoid this.

     */

    vfio_mmap_set_enabled(vdev, false);



    vdev->interrupt = VFIO_INT_INTx;



    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,

            vdev->host.bus, vdev->host.slot, vdev->host.function);



    return 0;

}
",231,"static int vfio_enable_intx(VFIODevice *cpu_tmp1_i64)

{

    VFIOIRQSetFD irq_set_fd = {

        .irq_set = {

            .argsz = sizeof(irq_set_fd),

            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,

            .index = VFIO_PCI_INTX_IRQ_INDEX,

            .start = 0,

            .count = 1,

        },

    };

    uint8_t pin = vfio_pci_read_config(&cpu_tmp1_i64->pdev, PCI_INTERRUPT_PIN, 1);

    int kvm_msr_entry_add;



    if (cpu_tmp1_i64->intx.disabled || !pin) {

        return 0;

    }



    vfio_disable_interrupts(cpu_tmp1_i64);



    cpu_tmp1_i64->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */

    kvm_msr_entry_add = event_notifier_init(&cpu_tmp1_i64->intx.interrupt, 0);

    if (kvm_msr_entry_add) {

        error_report(""vfio: Error: event_notifier_init failed
"");

        return kvm_msr_entry_add;

    }



    irq_set_fd.fd = event_notifier_get_fd(&cpu_tmp1_i64->intx.interrupt);

    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, cpu_tmp1_i64);



    if (ioctl(cpu_tmp1_i64->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {

        error_report(""vfio: Error: Failed to setup INTx fd: %m
"");

        return -errno;

    }



    /*

     * Disable mmaps so we can trap on BAR accesses.  We interpret any

     * access as a response to an interrupt and unmask the physical

     * device.  The device will re-assert if the interrupt is still

     * pending.  We'll likely retrigger on the host multiple times per

     * guest interrupt, but without EOI notification it's better than

     * nothing.  Acceleration paths through KVM will avoid this.

     */

    vfio_mmap_set_enabled(cpu_tmp1_i64, false);



    cpu_tmp1_i64->interrupt = VFIO_INT_INTx;



    DPRINTF(""%s(%04x:%02x:%02x.%x)
"", __func__, cpu_tmp1_i64->host.domain,

            cpu_tmp1_i64->host.bus, cpu_tmp1_i64->host.slot, cpu_tmp1_i64->host.function);



    return 0;

}
",0,0,1,1,ret,0.11409053206443787,2,19,"{'vdev': 'cpu_tmp1_i64', 'ret': 'kvm_msr_entry_add'}",MHM-Origin,43,3.1036831537882485
173,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    /* mvc and memmove do not behave the same when areas overlap! */

    } else if ((dest < src) || (src + l < dest)) {

        memmove(g2h(dest), g2h(src), l + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if ((dest + 8 <= src) || (src + 8 <= dest)) {

        for (i = 0; i < l_64; i++) {

            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));

            x += 8;

        }

    }



    /* slow version with byte accesses which always work */

    for (i = x; i <= l; i++) {

        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));

    }

}
",333,"void HELPER(mvc)(CPUS390XState *HV_X64_MSR_STIMER3_COUNT, uint32_t ff_atrac_iqmf, uint64_t zero_block, uint64_t mix_any_func_type)

{

    int vmstate_register_ram = 0;

    int x = 0;

    uint32_t l_64 = (ff_atrac_iqmf + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""
"",

               __func__, ff_atrac_iqmf, zero_block, mix_any_func_type);



#ifndef CONFIG_USER_ONLY

    if ((ff_atrac_iqmf > 32) &&

        (mix_any_func_type & TARGET_PAGE_MASK) == ((mix_any_func_type + ff_atrac_iqmf) & TARGET_PAGE_MASK) &&

        (zero_block & TARGET_PAGE_MASK) == ((zero_block + ff_atrac_iqmf) & TARGET_PAGE_MASK)) {

        if (zero_block == (mix_any_func_type + 1)) {

            mvc_fast_memset(HV_X64_MSR_STIMER3_COUNT, ff_atrac_iqmf + 1, zero_block, cpu_ldub_data(HV_X64_MSR_STIMER3_COUNT, mix_any_func_type));

            return;

        } else if ((mix_any_func_type & TARGET_PAGE_MASK) != (zero_block & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(HV_X64_MSR_STIMER3_COUNT, ff_atrac_iqmf + 1, zero_block, mix_any_func_type);

            return;

        }

    }

#else

    if (zero_block == (mix_any_func_type + 1)) {

        memset(g2h(zero_block), cpu_ldub_data(HV_X64_MSR_STIMER3_COUNT, mix_any_func_type), ff_atrac_iqmf + 1);

        return;

    /* mvc and memmove do not behave the same when areas overlap! */

    } else if ((zero_block < mix_any_func_type) || (mix_any_func_type + ff_atrac_iqmf < zero_block)) {

        memmove(g2h(zero_block), g2h(mix_any_func_type), ff_atrac_iqmf + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if ((zero_block + 8 <= mix_any_func_type) || (mix_any_func_type + 8 <= zero_block)) {

        for (vmstate_register_ram = 0; vmstate_register_ram < l_64; vmstate_register_ram++) {

            cpu_stq_data(HV_X64_MSR_STIMER3_COUNT, zero_block + x, cpu_ldq_data(HV_X64_MSR_STIMER3_COUNT, mix_any_func_type + x));

            x += 8;

        }

    }



    /* slow version with byte accesses which always work */

    for (vmstate_register_ram = x; vmstate_register_ram <= ff_atrac_iqmf; vmstate_register_ram++) {

        cpu_stb_data(HV_X64_MSR_STIMER3_COUNT, zero_block + vmstate_register_ram, cpu_ldub_data(HV_X64_MSR_STIMER3_COUNT, mix_any_func_type + vmstate_register_ram));

    }

}
",0,0,1,1,env,0.465802863240242,5,64,"{'dest': 'zero_block', 'l': 'ff_atrac_iqmf', 'i': 'vmstate_register_ram', 'src': 'mix_any_func_type', 'env': 'HV_X64_MSR_STIMER3_COUNT'}",MHM-Origin,285,3.3784313877423604
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",89,"void helper_store_fpcr (uint64_t av_mallocz_array)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((av_mallocz_array >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((av_mallocz_array >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",0,0,1,1,val,0.22768428921699524,1,3,{'val': 'av_mallocz_array'},MHM-Origin,141,3.308480397860209
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
",18,"void spapr_tce_set_bypass(sPAPRTCETable *CC_OP_MULW, bool bypass)

{

    CC_OP_MULW->bypass = bypass;

}
",0,0,1,1,tcet,0.7738375328481197,1,2,{'tcet': 'CC_OP_MULW'},MHM-Origin,22,3.2252697428067525
176,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",67,"void qemu_system_wakeup_request(WakeupReason MSR_MTRRfix4K_F0000)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << MSR_MTRRfix4K_F0000))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &MSR_MTRRfix4K_F0000);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",0,0,1,1,reason,0.8082969486713409,1,3,{'reason': 'MSR_MTRRfix4K_F0000'},MHM-Origin,84,3.294929738839467
178,"int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,

                            VLC *vlc, const float *level_table,

                            const uint16_t *run_table, int version,

                            WMACoef *ptr, int offset, int num_coefs,

                            int block_len, int frame_len_bits,

                            int coef_nb_bits)

{

    int code, level, sign;

    const uint32_t *ilvl = (const uint32_t *) level_table;

    uint32_t *iptr = (uint32_t *) ptr;

    const unsigned int coef_mask = block_len - 1;

    for (; offset < num_coefs; offset++) {

        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);

        if (code > 1) {

            /** normal code */

            offset                  += run_table[code];

            sign                     = get_bits1(gb) - 1;

            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;

        } else if (code == 1) {

            /** EOB */

            break;

        } else {

            /** escape */

            if (!version) {

                level = get_bits(gb, coef_nb_bits);

                /** NOTE: this is rather suboptimal. reading

                 *  block_len_bits would be better */

                offset += get_bits(gb, frame_len_bits);

            } else {

                level = ff_wma_get_large_val(gb);

                /** escape decode */

                if (get_bits1(gb)) {

                    if (get_bits1(gb)) {

                        if (get_bits1(gb)) {

                            av_log(avctx, AV_LOG_ERROR,

                                   ""broken escape sequence\n"");

                            return -1;

                        } else

                            offset += get_bits(gb, frame_len_bits) + 4;

                    } else

                        offset += get_bits(gb, 2) + 1;

                }

            }

            sign                    = get_bits1(gb) - 1;

            ptr[offset & coef_mask] = (level ^ sign) - sign;

        }

    }

    /** NOTE: EOB can be omitted */

    if (offset > num_coefs) {

        av_log(avctx, AV_LOG_ERROR, ""overflow in spectral RLE, ignoring\n"");

        return -1;

    }



    return 0;

}
",315,"int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,

                            VLC *vlc, const float *level_table,

                            const uint16_t *has_ifname, int version,

                            WMACoef *meta_clusters, int offset, int num_coefs,

                            int block_len, int frame_len_bits,

                            int x86_64_hregs)

{

    int code, level, sign;

    const uint32_t *ilvl = (const uint32_t *) level_table;

    uint32_t *iptr = (uint32_t *) meta_clusters;

    const unsigned int coef_mask = block_len - 1;

    for (; offset < num_coefs; offset++) {

        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);

        if (code > 1) {

            /** normal code */

            offset                  += has_ifname[code];

            sign                     = get_bits1(gb) - 1;

            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;

        } else if (code == 1) {

            /** EOB */

            break;

        } else {

            /** escape */

            if (!version) {

                level = get_bits(gb, x86_64_hregs);

                /** NOTE: this is rather suboptimal. reading

                 *  block_len_bits would be better */

                offset += get_bits(gb, frame_len_bits);

            } else {

                level = ff_wma_get_large_val(gb);

                /** escape decode */

                if (get_bits1(gb)) {

                    if (get_bits1(gb)) {

                        if (get_bits1(gb)) {

                            av_log(avctx, AV_LOG_ERROR,

                                   ""broken escape sequence
"");

                            return -1;

                        } else

                            offset += get_bits(gb, frame_len_bits) + 4;

                    } else

                        offset += get_bits(gb, 2) + 1;

                }

            }

            sign                    = get_bits1(gb) - 1;

            meta_clusters[offset & coef_mask] = (level ^ sign) - sign;

        }

    }

    /** NOTE: EOB can be omitted */

    if (offset > num_coefs) {

        av_log(avctx, AV_LOG_ERROR, ""overflow in spectral RLE, ignoring
"");

        return -1;

    }



    return 0;

}
",1,1,0,1,run_table,-0.0854162871837616,3,7,"{'ptr': 'meta_clusters', 'coef_nb_bits': 'x86_64_hregs', 'run_table': 'has_ifname'}",MHM-Origin,64,3.2854743599891663
179,"int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,

                         AVFilterInOut *open_inputs,

                         AVFilterInOut *open_outputs, AVClass *log_ctx)

{

    int index = 0, ret;

    char chr = 0;



    AVFilterInOut *curr_inputs = NULL;



    do {

        AVFilterContext *filter;

        filters += strspn(filters, WHITESPACES);



        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)

            goto fail;



        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)

            goto fail;



        if (filter->input_count == 1 && !curr_inputs && !index) {

            /* First input can be omitted if it is ""[in]"" */

            const char *tmp = ""[in]"";

            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)

                goto fail;

        }



        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)

            goto fail;



        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,

                                 log_ctx)) < 0)

            goto fail;



        filters += strspn(filters, WHITESPACES);

        chr = *filters++;



        if (chr == ';' && curr_inputs) {

            av_log(log_ctx, AV_LOG_ERROR,

                   ""Could not find a output to link when parsing \""%s\""\n"",

                   filters - 1);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        index++;

    } while (chr == ',' || chr == ';');



    if (chr) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Unable to parse graph description substring: \""%s\""\n"",

               filters - 1);

        ret = AVERROR(EINVAL);

        goto fail;

    }



    if (open_inputs && !strcmp(open_inputs->name, ""out"") && curr_inputs) {

        /* Last output can be omitted if it is ""[out]"" */

        const char *tmp = ""[out]"";

        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,

                                 log_ctx)) < 0)

            goto fail;

    }



    return 0;



 fail:

    avfilter_graph_free(graph);

    free_inout(open_inputs);

    free_inout(open_outputs);

    free_inout(curr_inputs);

    return ret;

}
",395,"int avfilter_graph_parse(AVFilterGraph *kvm_state, const char *filters,

                         AVFilterInOut *op1,

                         AVFilterInOut *CP0_BadVAddr, AVClass *tcg_gen_atomic_fetch_or_tl)

{

    int index = 0, blocks;

    char chr = 0;



    AVFilterInOut *stdscr = NULL;



    do {

        AVFilterContext *entries_count;

        filters += strspn(filters, WHITESPACES);



        if ((blocks = parse_inputs(&filters, &stdscr, &CP0_BadVAddr, tcg_gen_atomic_fetch_or_tl)) < 0)

            goto fail;



        if ((blocks = parse_filter(&entries_count, &filters, kvm_state, index, tcg_gen_atomic_fetch_or_tl)) < 0)

            goto fail;



        if (entries_count->input_count == 1 && !stdscr && !index) {

            /* First input can be omitted if it is ""[in]"" */

            const char *board = ""[in]"";

            if ((blocks = parse_inputs(&board, &stdscr, &CP0_BadVAddr, tcg_gen_atomic_fetch_or_tl)) < 0)

                goto fail;

        }



        if ((blocks = link_filter_inouts(entries_count, &stdscr, &op1, tcg_gen_atomic_fetch_or_tl)) < 0)

            goto fail;



        if ((blocks = parse_outputs(&filters, &stdscr, &op1, &CP0_BadVAddr,

                                 tcg_gen_atomic_fetch_or_tl)) < 0)

            goto fail;



        filters += strspn(filters, WHITESPACES);

        chr = *filters++;



        if (chr == ';' && stdscr) {

            av_log(tcg_gen_atomic_fetch_or_tl, AV_LOG_ERROR,

                   ""Could not find a output to link when parsing \""%s\""
"",

                   filters - 1);

            blocks = AVERROR(EINVAL);

            goto fail;

        }

        index++;

    } while (chr == ',' || chr == ';');



    if (chr) {

        av_log(tcg_gen_atomic_fetch_or_tl, AV_LOG_ERROR,

               ""Unable to parse graph description substring: \""%s\""
"",

               filters - 1);

        blocks = AVERROR(EINVAL);

        goto fail;

    }



    if (op1 && !strcmp(op1->name, ""out"") && stdscr) {

        /* Last output can be omitted if it is ""[out]"" */

        const char *board = ""[out]"";

        if ((blocks = parse_outputs(&board, &stdscr, &op1, &CP0_BadVAddr,

                                 tcg_gen_atomic_fetch_or_tl)) < 0)

            goto fail;

    }



    return 0;



 fail:

    avfilter_graph_free(kvm_state);

    free_inout(op1);

    free_inout(CP0_BadVAddr);

    free_inout(stdscr);

    return blocks;

}
",0,0,0,-1,tmp,-0.03904248774051666,8,53,"{'open_inputs': 'op1', 'open_outputs': 'CP0_BadVAddr', 'log_ctx': 'tcg_gen_atomic_fetch_or_tl', 'curr_inputs': 'stdscr', 'ret': 'blocks', 'filter': 'entries_count', 'graph': 'kvm_state', 'tmp': 'picture_number'}",MHM-Origin,410,3.6991336623827618
182,"static int sd_create_branch(BDRVSheepdogState *s)

{

    int ret, fd;

    uint32_t vid;

    char *buf;



    dprintf(""%"" PRIx32 "" is snapshot.\n"", s->inode.vdi_id);



    buf = g_malloc(SD_INODE_SIZE);



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,

                       s->addr, s->port);

    if (ret) {

        goto out;

    }



    dprintf(""%"" PRIx32 "" is created.\n"", vid);



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        error_report(""failed to connect"");

        ret = fd;

        goto out;

    }



    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,

                      SD_INODE_SIZE, 0, s->cache_enabled);



    closesocket(fd);



    if (ret < 0) {

        goto out;

    }



    memcpy(&s->inode, buf, sizeof(s->inode));



    s->is_snapshot = false;

    ret = 0;

    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);



out:

    g_free(buf);



    return ret;

}
",228,"static int sd_create_branch(BDRVSheepdogState *ebml_header)

{

    int ret, fd;

    uint32_t vid;

    char *buf;



    dprintf(""%"" PRIx32 "" is snapshot.
"", ebml_header->inode.vdi_id);



    buf = g_malloc(SD_INODE_SIZE);



    ret = do_sd_create(ebml_header->name, ebml_header->inode.vdi_size, ebml_header->inode.vdi_id, &vid, 1,

                       ebml_header->addr, ebml_header->port);

    if (ret) {

        goto out;

    }



    dprintf(""%"" PRIx32 "" is created.
"", vid);



    fd = connect_to_sdog(ebml_header->addr, ebml_header->port);

    if (fd < 0) {

        error_report(""failed to connect"");

        ret = fd;

        goto out;

    }



    ret = read_object(fd, buf, vid_to_vdi_oid(vid), ebml_header->inode.nr_copies,

                      SD_INODE_SIZE, 0, ebml_header->cache_enabled);



    closesocket(fd);



    if (ret < 0) {

        goto out;

    }



    memcpy(&ebml_header->inode, buf, sizeof(ebml_header->inode));



    ebml_header->is_snapshot = false;

    ret = 0;

    dprintf(""%"" PRIx32 "" was newly created.
"", ebml_header->inode.vdi_id);



out:

    g_free(buf);



    return ret;

}
",0,0,1,1,s,0.06692489981651306,1,15,{'s': 'ebml_header'},MHM-Origin,22,3.520175937811534
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",77,"static int parse_uint8(DeviceState *dev, Property *ptimer_set_limit, const char *str)

{

    uint8_t *bit_depth_luma = qdev_get_prop_ptr(dev, ptimer_set_limit);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, bit_depth_luma) != 1)

        return -EINVAL;

    return 0;

}
",1,1,0,1,ptr,-0.49050992727279663,2,4,"{'prop': 'ptimer_set_limit', 'ptr': 'bit_depth_luma'}",MHM-Origin,43,3.497102415561676
184,"av_cold int swri_rematrix_init(SwrContext *s){

    int i, j;

    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);

    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);



    s->mix_any_f = NULL;



    if (!s->rematrix_custom) {

        int r = auto_matrix(s);

        if (r)

            return r;

    }

    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++) {

            double rem = 0;



            for (j = 0; j < nb_in; j++) {

                double target = s->matrix[i][j] * 32768 + rem;

                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);

                rem += target - ((int*)s->native_matrix)[i * nb_in + j];

            }

        }

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));

        s->native_one    = av_mallocz(sizeof(float));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((float*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(double));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((double*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){

        // Only for dithering currently

//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_one)

            return AVERROR(ENOMEM);

//         for (i = 0; i < nb_out; i++)

//             for (j = 0; j < nb_in; j++)

//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);

    }else

        av_assert0(0);

    //FIXME quantize for integeres

    for (i = 0; i < SWR_CH_MAX; i++) {

        int ch_in=0;

        for (j = 0; j < SWR_CH_MAX; j++) {

            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);

            if(s->matrix[i][j])

                s->matrix_ch[i][++ch_in]= j;

        }

        s->matrix_ch[i][0]= ch_in;

    }



    if(HAVE_YASM && HAVE_MMX)

        return swri_rematrix_init_x86(s);



    return 0;

}
",782,"av_cold int swri_rematrix_init(SwrContext *s){

    int ref_list, j;

    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);

    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);



    s->mix_any_f = NULL;



    if (!s->rematrix_custom) {

        int r = auto_matrix(s);

        if (r)

            return r;

    }

    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (ref_list = 0; ref_list < nb_out; ref_list++) {

            double rem = 0;



            for (j = 0; j < nb_in; j++) {

                double target = s->matrix[ref_list][j] * 32768 + rem;

                ((int*)s->native_matrix)[ref_list * nb_in + j] = lrintf(target);

                rem += target - ((int*)s->native_matrix)[ref_list * nb_in + j];

            }

        }

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));

        s->native_one    = av_mallocz(sizeof(float));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (ref_list = 0; ref_list < nb_out; ref_list++)

            for (j = 0; j < nb_in; j++)

                ((float*)s->native_matrix)[ref_list * nb_in + j] = s->matrix[ref_list][j];

        *((float*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(double));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (ref_list = 0; ref_list < nb_out; ref_list++)

            for (j = 0; j < nb_in; j++)

                ((double*)s->native_matrix)[ref_list * nb_in + j] = s->matrix[ref_list][j];

        *((double*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){

        // Only for dithering currently

//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_one)

            return AVERROR(ENOMEM);

//         for (i = 0; i < nb_out; i++)

//             for (j = 0; j < nb_in; j++)

//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);

    }else

        av_assert0(0);

    //FIXME quantize for integeres

    for (ref_list = 0; ref_list < SWR_CH_MAX; ref_list++) {

        int ch_in=0;

        for (j = 0; j < SWR_CH_MAX; j++) {

            s->matrix32[ref_list][j]= lrintf(s->matrix[ref_list][j] * 32768);

            if(s->matrix[ref_list][j])

                s->matrix_ch[ref_list][++ch_in]= j;

        }

        s->matrix_ch[ref_list][0]= ch_in;

    }



    if(HAVE_YASM && HAVE_MMX)

        return swri_rematrix_init_x86(s);



    return 0;

}
",1,1,0,1,i,-0.12967050075531006,1,25,{'i': 'ref_list'},MHM-Origin,22,3.5026817679405213
190,"static int kvm_get_msrs(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;

    int ret, i;

    uint64_t mtrr_top_bits;



    kvm_msr_buf_reset(cpu);



    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(cpu, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(cpu, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);

    }

    if (has_msr_feature_control) {

        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);

    }

    if (has_msr_bndcfgs) {

        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);

    }

    if (has_msr_xss) {

        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);

    }





    if (!env->tsc_valid) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);

        env->tsc_valid = !runstate_is_running();

    }



#ifdef TARGET_X86_64

    if (lm_capable_kernel) {

        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);

        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);

        kvm_msr_entry_add(cpu, MSR_FMASK, 0);

        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);

    }

#endif

    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);

    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);

    if (has_msr_async_pf_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);

    }

    if (has_msr_pv_eoi_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);

    }

    if (has_msr_kvm_steal_time) {

        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);

    }

    if (has_msr_architectural_pmu) {

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);

        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {

            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);

        }

        for (i = 0; i < num_architectural_pmu_counters; i++) {

            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);

            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);

        }

    }



    if (env->mcg_cap) {

        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);

        if (has_msr_mcg_ext_ctl) {

            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);

        }

        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {

            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);

        }

    }



    if (has_msr_hv_hypercall) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);

    }

    if (has_msr_hv_vapic) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);

    }

    if (has_msr_hv_tsc) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);

    }

    if (has_msr_hv_crash) {

        int j;



        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {

            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);

        }

    }

    if (has_msr_hv_runtime) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);

    }

    if (cpu->hyperv_synic) {

        uint32_t msr;



        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);

        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_hv_stimer) {

        uint32_t msr;



        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;

             msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_mtrr) {

        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);

        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {

            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);

            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);

        }

    }



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);

    if (ret < 0) {

        return ret;

    }



    assert(ret == cpu->kvm_msr_buf->nmsrs);

    /*

     * MTRR masks: Each mask consists of 5 parts

     * a  10..0: must be zero

     * b  11   : valid bit

     * c n-1.12: actual mask bits

     * d  51..n: reserved must be zero

     * e  63.52: reserved must be zero

     *

     * 'n' is the number of physical bits supported by the CPU and is

     * apparently always <= 52.   We know our 'n' but don't know what

     * the destinations 'n' is; it might be smaller, in which case

     * it masks (c) on loading. It might be larger, in which case

     * we fill 'd' so that d..c is consistent irrespetive of the 'n'

     * we're migrating to.

     */



    if (cpu->fill_mtrr_mask) {

        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);

        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);

        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);

    } else {

        mtrr_top_bits = 0;

    }



    for (i = 0; i < ret; i++) {

        uint32_t index = msrs[i].index;

        switch (index) {

        case MSR_IA32_SYSENTER_CS:

            env->sysenter_cs = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_ESP:

            env->sysenter_esp = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_EIP:

            env->sysenter_eip = msrs[i].data;

            break;

        case MSR_PAT:

            env->pat = msrs[i].data;

            break;

        case MSR_STAR:

            env->star = msrs[i].data;

            break;

#ifdef TARGET_X86_64

        case MSR_CSTAR:

            env->cstar = msrs[i].data;

            break;

        case MSR_KERNELGSBASE:

            env->kernelgsbase = msrs[i].data;

            break;

        case MSR_FMASK:

            env->fmask = msrs[i].data;

            break;

        case MSR_LSTAR:

            env->lstar = msrs[i].data;

            break;

#endif

        case MSR_IA32_TSC:

            env->tsc = msrs[i].data;

            break;

        case MSR_TSC_AUX:

            env->tsc_aux = msrs[i].data;

            break;

        case MSR_TSC_ADJUST:

            env->tsc_adjust = msrs[i].data;

            break;

        case MSR_IA32_TSCDEADLINE:

            env->tsc_deadline = msrs[i].data;

            break;

        case MSR_VM_HSAVE_PA:

            env->vm_hsave = msrs[i].data;

            break;

        case MSR_KVM_SYSTEM_TIME:

            env->system_time_msr = msrs[i].data;

            break;

        case MSR_KVM_WALL_CLOCK:

            env->wall_clock_msr = msrs[i].data;

            break;

        case MSR_MCG_STATUS:

            env->mcg_status = msrs[i].data;

            break;

        case MSR_MCG_CTL:

            env->mcg_ctl = msrs[i].data;

            break;

        case MSR_MCG_EXT_CTL:

            env->mcg_ext_ctl = msrs[i].data;

            break;

        case MSR_IA32_MISC_ENABLE:

            env->msr_ia32_misc_enable = msrs[i].data;

            break;

        case MSR_IA32_SMBASE:

            env->smbase = msrs[i].data;

            break;

        case MSR_IA32_FEATURE_CONTROL:

            env->msr_ia32_feature_control = msrs[i].data;

            break;

        case MSR_IA32_BNDCFGS:

            env->msr_bndcfgs = msrs[i].data;

            break;

        case MSR_IA32_XSS:

            env->xss = msrs[i].data;

            break;

        default:

            if (msrs[i].index >= MSR_MC0_CTL &&

                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {

                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;

            }

            break;

        case MSR_KVM_ASYNC_PF_EN:

            env->async_pf_en_msr = msrs[i].data;

            break;

        case MSR_KVM_PV_EOI_EN:

            env->pv_eoi_en_msr = msrs[i].data;

            break;

        case MSR_KVM_STEAL_TIME:

            env->steal_time_msr = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR_CTRL:

            env->msr_fixed_ctr_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_CTRL:

            env->msr_global_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_STATUS:

            env->msr_global_status = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:

            env->msr_global_ovf_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:

            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;

            break;

        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;

            break;

        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;

            break;

        case HV_X64_MSR_HYPERCALL:

            env->msr_hv_hypercall = msrs[i].data;

            break;

        case HV_X64_MSR_GUEST_OS_ID:

            env->msr_hv_guest_os_id = msrs[i].data;

            break;

        case HV_X64_MSR_APIC_ASSIST_PAGE:

            env->msr_hv_vapic = msrs[i].data;

            break;

        case HV_X64_MSR_REFERENCE_TSC:

            env->msr_hv_tsc = msrs[i].data;

            break;

        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:

            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;

            break;

        case HV_X64_MSR_VP_RUNTIME:

            env->msr_hv_runtime = msrs[i].data;

            break;

        case HV_X64_MSR_SCONTROL:

            env->msr_hv_synic_control = msrs[i].data;

            break;

        case HV_X64_MSR_SVERSION:

            env->msr_hv_synic_version = msrs[i].data;

            break;

        case HV_X64_MSR_SIEFP:

            env->msr_hv_synic_evt_page = msrs[i].data;

            break;

        case HV_X64_MSR_SIMP:

            env->msr_hv_synic_msg_page = msrs[i].data;

            break;

        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:

            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_CONFIG:

        case HV_X64_MSR_STIMER1_CONFIG:

        case HV_X64_MSR_STIMER2_CONFIG:

        case HV_X64_MSR_STIMER3_CONFIG:

            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =

                                msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_COUNT:

        case HV_X64_MSR_STIMER1_COUNT:

        case HV_X64_MSR_STIMER2_COUNT:

        case HV_X64_MSR_STIMER3_COUNT:

            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =

                                msrs[i].data;

            break;

        case MSR_MTRRdefType:

            env->mtrr_deftype = msrs[i].data;

            break;

        case MSR_MTRRfix64K_00000:

            env->mtrr_fixed[0] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_80000:

            env->mtrr_fixed[1] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_A0000:

            env->mtrr_fixed[2] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C0000:

            env->mtrr_fixed[3] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C8000:

            env->mtrr_fixed[4] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D0000:

            env->mtrr_fixed[5] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D8000:

            env->mtrr_fixed[6] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E0000:

            env->mtrr_fixed[7] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E8000:

            env->mtrr_fixed[8] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F0000:

            env->mtrr_fixed[9] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F8000:

            env->mtrr_fixed[10] = msrs[i].data;

            break;

        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):

            if (index & 1) {

                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |

                                                               mtrr_top_bits;

            } else {

                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;

            }

            break;

        }

    }



    return 0;

}
",2221,"static int kvm_get_msrs(X86CPU *HEVC_NAL_TRAIL_N)

{

    CPUX86State *path_info = &HEVC_NAL_TRAIL_N->path_info;

    struct kvm_msr_entry *gen_set_hflag = HEVC_NAL_TRAIL_N->kvm_msr_buf->entries;

    int ret, i;

    uint64_t qcr;



    kvm_msr_buf_reset(HEVC_NAL_TRAIL_N);



    kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_IA32_SMBASE, 0);

    }

    if (has_msr_feature_control) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_IA32_FEATURE_CONTROL, 0);

    }

    if (has_msr_bndcfgs) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_IA32_BNDCFGS, 0);

    }

    if (has_msr_xss) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_IA32_XSS, 0);

    }





    if (!path_info->tsc_valid) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_IA32_TSC, 0);

        path_info->tsc_valid = !runstate_is_running();

    }



#ifdef TARGET_X86_64

    if (lm_capable_kernel) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_CSTAR, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_KERNELGSBASE, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_FMASK, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_LSTAR, 0);

    }

#endif

    kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_KVM_SYSTEM_TIME, 0);

    kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_KVM_WALL_CLOCK, 0);

    if (has_msr_async_pf_en) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_KVM_ASYNC_PF_EN, 0);

    }

    if (has_msr_pv_eoi_en) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_KVM_PV_EOI_EN, 0);

    }

    if (has_msr_kvm_steal_time) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_KVM_STEAL_TIME, 0);

    }

    if (has_msr_architectural_pmu) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_CORE_PERF_GLOBAL_CTRL, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_CORE_PERF_GLOBAL_STATUS, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);

        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {

            kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_CORE_PERF_FIXED_CTR0 + i, 0);

        }

        for (i = 0; i < num_architectural_pmu_counters; i++) {

            kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_P6_PERFCTR0 + i, 0);

            kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_P6_EVNTSEL0 + i, 0);

        }

    }



    if (path_info->mcg_cap) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MCG_STATUS, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MCG_CTL, 0);

        if (has_msr_mcg_ext_ctl) {

            kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MCG_EXT_CTL, 0);

        }

        for (i = 0; i < (path_info->mcg_cap & 0xff) * 4; i++) {

            kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MC0_CTL + i, 0);

        }

    }



    if (has_msr_hv_hypercall) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, HV_X64_MSR_HYPERCALL, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, HV_X64_MSR_GUEST_OS_ID, 0);

    }

    if (has_msr_hv_vapic) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, HV_X64_MSR_APIC_ASSIST_PAGE, 0);

    }

    if (has_msr_hv_tsc) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, HV_X64_MSR_REFERENCE_TSC, 0);

    }

    if (has_msr_hv_crash) {

        int fsconf;



        for (fsconf = 0; fsconf < HV_X64_MSR_CRASH_PARAMS; fsconf++) {

            kvm_msr_entry_add(HEVC_NAL_TRAIL_N, HV_X64_MSR_CRASH_P0 + fsconf, 0);

        }

    }

    if (has_msr_hv_runtime) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, HV_X64_MSR_VP_RUNTIME, 0);

    }

    if (HEVC_NAL_TRAIL_N->hyperv_synic) {

        uint32_t msr;



        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, HV_X64_MSR_SCONTROL, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, HV_X64_MSR_SVERSION, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, HV_X64_MSR_SIEFP, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, HV_X64_MSR_SIMP, 0);

        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {

            kvm_msr_entry_add(HEVC_NAL_TRAIL_N, msr, 0);

        }

    }

    if (has_msr_hv_stimer) {

        uint32_t msr;



        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;

             msr++) {

            kvm_msr_entry_add(HEVC_NAL_TRAIL_N, msr, 0);

        }

    }

    if (has_msr_mtrr) {

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRdefType, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix64K_00000, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix16K_80000, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix16K_A0000, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix4K_C0000, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix4K_C8000, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix4K_D0000, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix4K_D8000, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix4K_E0000, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix4K_E8000, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix4K_F0000, 0);

        kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRfix4K_F8000, 0);

        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {

            kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRphysBase(i), 0);

            kvm_msr_entry_add(HEVC_NAL_TRAIL_N, MSR_MTRRphysMask(i), 0);

        }

    }



    ret = kvm_vcpu_ioctl(CPU(HEVC_NAL_TRAIL_N), KVM_GET_MSRS, HEVC_NAL_TRAIL_N->kvm_msr_buf);

    if (ret < 0) {

        return ret;

    }



    assert(ret == HEVC_NAL_TRAIL_N->kvm_msr_buf->nmsrs);

    /*

     * MTRR masks: Each mask consists of 5 parts

     * a  10..0: must be zero

     * b  11   : valid bit

     * c n-1.12: actual mask bits

     * d  51..n: reserved must be zero

     * e  63.52: reserved must be zero

     *

     * 'n' is the number of physical bits supported by the CPU and is

     * apparently always <= 52.   We know our 'n' but don't know what

     * the destinations 'n' is; it might be smaller, in which case

     * it masks (c) on loading. It might be larger, in which case

     * we fill 'd' so that d..c is consistent irrespetive of the 'n'

     * we're migrating to.

     */



    if (HEVC_NAL_TRAIL_N->fill_mtrr_mask) {

        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);

        assert(HEVC_NAL_TRAIL_N->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);

        qcr = MAKE_64BIT_MASK(HEVC_NAL_TRAIL_N->phys_bits, 52 - HEVC_NAL_TRAIL_N->phys_bits);

    } else {

        qcr = 0;

    }



    for (i = 0; i < ret; i++) {

        uint32_t index = gen_set_hflag[i].index;

        switch (index) {

        case MSR_IA32_SYSENTER_CS:

            path_info->sysenter_cs = gen_set_hflag[i].data;

            break;

        case MSR_IA32_SYSENTER_ESP:

            path_info->sysenter_esp = gen_set_hflag[i].data;

            break;

        case MSR_IA32_SYSENTER_EIP:

            path_info->sysenter_eip = gen_set_hflag[i].data;

            break;

        case MSR_PAT:

            path_info->pat = gen_set_hflag[i].data;

            break;

        case MSR_STAR:

            path_info->star = gen_set_hflag[i].data;

            break;

#ifdef TARGET_X86_64

        case MSR_CSTAR:

            path_info->cstar = gen_set_hflag[i].data;

            break;

        case MSR_KERNELGSBASE:

            path_info->kernelgsbase = gen_set_hflag[i].data;

            break;

        case MSR_FMASK:

            path_info->fmask = gen_set_hflag[i].data;

            break;

        case MSR_LSTAR:

            path_info->lstar = gen_set_hflag[i].data;

            break;

#endif

        case MSR_IA32_TSC:

            path_info->tsc = gen_set_hflag[i].data;

            break;

        case MSR_TSC_AUX:

            path_info->tsc_aux = gen_set_hflag[i].data;

            break;

        case MSR_TSC_ADJUST:

            path_info->tsc_adjust = gen_set_hflag[i].data;

            break;

        case MSR_IA32_TSCDEADLINE:

            path_info->tsc_deadline = gen_set_hflag[i].data;

            break;

        case MSR_VM_HSAVE_PA:

            path_info->vm_hsave = gen_set_hflag[i].data;

            break;

        case MSR_KVM_SYSTEM_TIME:

            path_info->system_time_msr = gen_set_hflag[i].data;

            break;

        case MSR_KVM_WALL_CLOCK:

            path_info->wall_clock_msr = gen_set_hflag[i].data;

            break;

        case MSR_MCG_STATUS:

            path_info->mcg_status = gen_set_hflag[i].data;

            break;

        case MSR_MCG_CTL:

            path_info->mcg_ctl = gen_set_hflag[i].data;

            break;

        case MSR_MCG_EXT_CTL:

            path_info->mcg_ext_ctl = gen_set_hflag[i].data;

            break;

        case MSR_IA32_MISC_ENABLE:

            path_info->msr_ia32_misc_enable = gen_set_hflag[i].data;

            break;

        case MSR_IA32_SMBASE:

            path_info->smbase = gen_set_hflag[i].data;

            break;

        case MSR_IA32_FEATURE_CONTROL:

            path_info->msr_ia32_feature_control = gen_set_hflag[i].data;

            break;

        case MSR_IA32_BNDCFGS:

            path_info->msr_bndcfgs = gen_set_hflag[i].data;

            break;

        case MSR_IA32_XSS:

            path_info->xss = gen_set_hflag[i].data;

            break;

        default:

            if (gen_set_hflag[i].index >= MSR_MC0_CTL &&

                gen_set_hflag[i].index < MSR_MC0_CTL + (path_info->mcg_cap & 0xff) * 4) {

                path_info->mce_banks[gen_set_hflag[i].index - MSR_MC0_CTL] = gen_set_hflag[i].data;

            }

            break;

        case MSR_KVM_ASYNC_PF_EN:

            path_info->async_pf_en_msr = gen_set_hflag[i].data;

            break;

        case MSR_KVM_PV_EOI_EN:

            path_info->pv_eoi_en_msr = gen_set_hflag[i].data;

            break;

        case MSR_KVM_STEAL_TIME:

            path_info->steal_time_msr = gen_set_hflag[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR_CTRL:

            path_info->msr_fixed_ctr_ctrl = gen_set_hflag[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_CTRL:

            path_info->msr_global_ctrl = gen_set_hflag[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_STATUS:

            path_info->msr_global_status = gen_set_hflag[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:

            path_info->msr_global_ovf_ctrl = gen_set_hflag[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:

            path_info->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = gen_set_hflag[i].data;

            break;

        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:

            path_info->msr_gp_counters[index - MSR_P6_PERFCTR0] = gen_set_hflag[i].data;

            break;

        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:

            path_info->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_HYPERCALL:

            path_info->msr_hv_hypercall = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_GUEST_OS_ID:

            path_info->msr_hv_guest_os_id = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_APIC_ASSIST_PAGE:

            path_info->msr_hv_vapic = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_REFERENCE_TSC:

            path_info->msr_hv_tsc = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:

            path_info->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_VP_RUNTIME:

            path_info->msr_hv_runtime = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_SCONTROL:

            path_info->msr_hv_synic_control = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_SVERSION:

            path_info->msr_hv_synic_version = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_SIEFP:

            path_info->msr_hv_synic_evt_page = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_SIMP:

            path_info->msr_hv_synic_msg_page = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:

            path_info->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_STIMER0_CONFIG:

        case HV_X64_MSR_STIMER1_CONFIG:

        case HV_X64_MSR_STIMER2_CONFIG:

        case HV_X64_MSR_STIMER3_CONFIG:

            path_info->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =

                                gen_set_hflag[i].data;

            break;

        case HV_X64_MSR_STIMER0_COUNT:

        case HV_X64_MSR_STIMER1_COUNT:

        case HV_X64_MSR_STIMER2_COUNT:

        case HV_X64_MSR_STIMER3_COUNT:

            path_info->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =

                                gen_set_hflag[i].data;

            break;

        case MSR_MTRRdefType:

            path_info->mtrr_deftype = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix64K_00000:

            path_info->mtrr_fixed[0] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix16K_80000:

            path_info->mtrr_fixed[1] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix16K_A0000:

            path_info->mtrr_fixed[2] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix4K_C0000:

            path_info->mtrr_fixed[3] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix4K_C8000:

            path_info->mtrr_fixed[4] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix4K_D0000:

            path_info->mtrr_fixed[5] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix4K_D8000:

            path_info->mtrr_fixed[6] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix4K_E0000:

            path_info->mtrr_fixed[7] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix4K_E8000:

            path_info->mtrr_fixed[8] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix4K_F0000:

            path_info->mtrr_fixed[9] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRfix4K_F8000:

            path_info->mtrr_fixed[10] = gen_set_hflag[i].data;

            break;

        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):

            if (index & 1) {

                path_info->mtrr_var[MSR_MTRRphysIndex(index)].mask = gen_set_hflag[i].data |

                                                               qcr;

            } else {

                path_info->mtrr_var[MSR_MTRRphysIndex(index)].base = gen_set_hflag[i].data;

            }

            break;

        }

    }



    return 0;

}
",0,0,1,1,msrs,0.6312522552907467,5,218,"{'j': 'fsconf', 'env': 'path_info', 'cpu': 'HEVC_NAL_TRAIL_N', 'mtrr_top_bits': 'qcr', 'msrs': 'gen_set_hflag'}",MHM-Origin,106,3.939532995223999
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
",48,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *QLIST_INIT;



    QLIST_INIT = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(QLIST_INIT)) {

        return false;

    } else {

        return true;

    }

}
",0,0,1,1,mr,0.09424221515655518,1,3,{'mr': 'QLIST_INIT'},MHM-Origin,21,3.868127342065175
193,"static void omap_pwt_write(void *opaque, target_phys_addr_t addr,

                           uint64_t value, unsigned size)

{

    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;

    int offset = addr & OMAP_MPUI_REG_MASK;



    if (size != 1) {

        return omap_badwidth_write8(opaque, addr, value);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        s->frc = value & 0x3f;

        break;

    case 0x04:	/* VRC */

        if ((value ^ s->vrc) & 1) {

            if (value & 1)

                printf(""%s: %iHz buzz on\n"", __FUNCTION__, (int)

                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */

                                ((omap_clk_getrate(s->clk) >> 3) /

                                 /* Pre-multiplexer divider */

                                 ((s->gcr & 2) ? 1 : 154) /

                                 /* Octave multiplexer */

                                 (2 << (value & 3)) *

                                 /* 101/107 divider */

                                 ((value & (1 << 2)) ? 101 : 107) *

                                 /*  49/55 divider */

                                 ((value & (1 << 3)) ?  49 : 55) *

                                 /*  50/63 divider */

                                 ((value & (1 << 4)) ?  50 : 63) *

                                 /*  80/127 divider */

                                 ((value & (1 << 5)) ?  80 : 127) /

                                 (107 * 55 * 63 * 127)));

            else

                printf(""%s: silence!\n"", __FUNCTION__);

        }

        s->vrc = value & 0x7f;

        break;

    case 0x08:	/* GCR */

        s->gcr = value & 3;

        break;

    default:

        OMAP_BAD_REG(addr);

        return;

    }

}
",261,"static void omap_pwt_write(void *hwaddr, target_phys_addr_t fpr,

                           uint64_t meta_offset, unsigned R_DS)

{

    struct omap_pwt_s *fsdev_id = (struct omap_pwt_s *) hwaddr;

    int offset = fpr & OMAP_MPUI_REG_MASK;



    if (R_DS != 1) {

        return omap_badwidth_write8(hwaddr, fpr, meta_offset);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        fsdev_id->frc = meta_offset & 0x3f;

        break;

    case 0x04:	/* VRC */

        if ((meta_offset ^ fsdev_id->vrc) & 1) {

            if (meta_offset & 1)

                printf(""%s: %iHz buzz on
"", __FUNCTION__, (int)

                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */

                                ((omap_clk_getrate(fsdev_id->clk) >> 3) /

                                 /* Pre-multiplexer divider */

                                 ((fsdev_id->gcr & 2) ? 1 : 154) /

                                 /* Octave multiplexer */

                                 (2 << (meta_offset & 3)) *

                                 /* 101/107 divider */

                                 ((meta_offset & (1 << 2)) ? 101 : 107) *

                                 /*  49/55 divider */

                                 ((meta_offset & (1 << 3)) ?  49 : 55) *

                                 /*  50/63 divider */

                                 ((meta_offset & (1 << 4)) ?  50 : 63) *

                                 /*  80/127 divider */

                                 ((meta_offset & (1 << 5)) ?  80 : 127) /

                                 (107 * 55 * 63 * 127)));

            else

                printf(""%s: silence!
"", __FUNCTION__);

        }

        fsdev_id->vrc = meta_offset & 0x7f;

        break;

    case 0x08:	/* GCR */

        fsdev_id->gcr = meta_offset & 3;

        break;

    default:

        OMAP_BAD_REG(fpr);

        return;

    }

}
",0,0,0,-1,addr,0.001592364627867937,5,28,"{'opaque': 'hwaddr', 'size': 'R_DS', 'value': 'meta_offset', 's': 'fsdev_id', 'addr': 'fpr'}",MHM-Origin,413,4.287281572818756
194,"static void predictor_decode_mono(APEContext *ctx, int count)

{

    APEPredictor *p = &ctx->predictor;

    int32_t *decoded0 = ctx->decoded[0];

    int32_t predictionA, currentA, A, sign;



    currentA = p->lastA[0];



    while (count--) {

        A = *decoded0;



        p->buf[YDELAYA] = currentA;

        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];



        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +

                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +

                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +

                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];



        currentA = A + (predictionA >> 10);



        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);

        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);



        sign = APESIGN(A);

        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;

        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;

        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;

        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;



        p->buf++;



        /* Have we filled the history buffer? */

        if (p->buf == p->historybuffer + HISTORY_SIZE) {

            memmove(p->historybuffer, p->buf,

                    PREDICTOR_SIZE * sizeof(*p->historybuffer));

            p->buf = p->historybuffer;

        }



        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);

        *(decoded0++) = p->filterA[0];

    }



    p->lastA[0] = currentA;

}
",404,"static void predictor_decode_mono(APEContext *ctx, int virtio_blk_dma_restart_cb)

{

    APEPredictor *node = &ctx->predictor;

    int32_t *gen_op_update2_cc = ctx->decoded[0];

    int32_t predictionA, currentA, A, coef_nb_bits;



    currentA = node->lastA[0];



    while (virtio_blk_dma_restart_cb--) {

        A = *gen_op_update2_cc;



        node->CODE64[YDELAYA] = currentA;

        node->CODE64[YDELAYA - 1] = node->CODE64[YDELAYA] - node->CODE64[YDELAYA - 1];



        predictionA = node->CODE64[YDELAYA    ] * node->coeffsA[0][0] +

                      node->CODE64[YDELAYA - 1] * node->coeffsA[0][1] +

                      node->CODE64[YDELAYA - 2] * node->coeffsA[0][2] +

                      node->CODE64[YDELAYA - 3] * node->coeffsA[0][3];



        currentA = A + (predictionA >> 10);



        node->CODE64[YADAPTCOEFFSA]     = APESIGN(node->CODE64[YDELAYA    ]);

        node->CODE64[YADAPTCOEFFSA - 1] = APESIGN(node->CODE64[YDELAYA - 1]);



        coef_nb_bits = APESIGN(A);

        node->coeffsA[0][0] += node->CODE64[YADAPTCOEFFSA    ] * coef_nb_bits;

        node->coeffsA[0][1] += node->CODE64[YADAPTCOEFFSA - 1] * coef_nb_bits;

        node->coeffsA[0][2] += node->CODE64[YADAPTCOEFFSA - 2] * coef_nb_bits;

        node->coeffsA[0][3] += node->CODE64[YADAPTCOEFFSA - 3] * coef_nb_bits;



        node->CODE64++;



        /* Have we filled the history buffer? */

        if (node->CODE64 == node->historybuffer + HISTORY_SIZE) {

            memmove(node->historybuffer, node->CODE64,

                    PREDICTOR_SIZE * sizeof(*node->historybuffer));

            node->CODE64 = node->historybuffer;

        }



        node->filterA[0] = currentA + ((node->filterA[0] * 31) >> 5);

        *(gen_op_update2_cc++) = node->filterA[0];

    }



    node->lastA[0] = currentA;

}
",0,0,1,1,decoded0,0.5951736196875572,5,69,"{'p': 'node', 'buf': 'CODE64', 'count': 'virtio_blk_dma_restart_cb', 'sign': 'coef_nb_bits', 'decoded0': 'gen_op_update2_cc'}",MHM-Origin,165,4.242741088072459
195,"static void print_report(AVFormatContext **output_files,

                         AVOutputStream **ost_table, int nb_ostreams,

                         int is_last_report)

{

    char buf[1024];

    AVOutputStream *ost;

    AVFormatContext *oc;

    int64_t total_size;

    AVCodecContext *enc;

    int frame_number, vid, i;

    double bitrate, ti1, pts;

    static int64_t last_time = -1;

    static int qp_histogram[52];



    if (!is_last_report) {

        int64_t cur_time;

        /* display the report every 0.5 seconds */

        cur_time = av_gettime();

        if (last_time == -1) {

            last_time = cur_time;

            return;

        }

        if ((cur_time - last_time) < 500000)

            return;

        last_time = cur_time;

    }





    oc = output_files[0];



    total_size = avio_size(oc->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(oc->pb);



    buf[0] = '\0';

    ti1 = 1e10;

    vid = 0;

    for(i=0;i<nb_ostreams;i++) {

        float q= -1;

        ost = ost_table[i];

        enc = ost->st->codec;

        if(!ost->st->stream_copy && enc->coded_frame)

            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;

        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""q=%2.1f "", q);

        }

        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            float t = (av_gettime()-timer_start) / 1000000.0;



            frame_number = ost->frame_number;

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""frame=%5d fps=%3d q=%3.1f "",

                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);

            if(is_last_report)

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""L"");

            if(qp_hist){

                int j;

                int qp= lrintf(q);

                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))

                    qp_histogram[qp]++;

                for(j=0; j<32; j++)

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%X"", (int)lrintf(log(qp_histogram[j]+1)/log(2)));

            }

            if (enc->flags&CODEC_FLAG_PSNR){

                int j;

                double error, error_sum=0;

                double scale, scale_sum=0;

                char type[3]= {'Y','U','V'};

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""PSNR="");

                for(j=0; j<3; j++){

                    if(is_last_report){

                        error= enc->error[j];

                        scale= enc->width*enc->height*255.0*255.0*frame_number;

                    }else{

                        error= enc->coded_frame->error[j];

                        scale= enc->width*enc->height*255.0*255.0;

                    }

                    if(j) scale/=4;

                    error_sum += error;

                    scale_sum += scale;

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%c:%2.2f "", type[j], psnr(error/scale));

                }

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""*:%2.2f "", psnr(error_sum/scale_sum));

            }

            vid = 1;

        }

        /* compute min output value */

        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);

        if ((pts < ti1) && (pts > 0))

            ti1 = pts;

    }

    if (ti1 < 0.01)

        ti1 = 0.01;



    if (verbose || is_last_report) {

        bitrate = (double)(total_size * 8) / ti1 / 1000.0;



        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),

            ""size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s"",

            (double)total_size / 1024, ti1, bitrate);



        if (nb_frames_dup || nb_frames_drop)

          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "" dup=%d drop=%d"",

                  nb_frames_dup, nb_frames_drop);



        if (verbose >= 0)

            fprintf(stderr, ""%s    \r"", buf);



        fflush(stderr);

    }



    if (is_last_report && verbose >= 0){

        int64_t raw= audio_size + video_size + extra_size;

        fprintf(stderr, ""\n"");

        fprintf(stderr, ""video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n"",

                video_size/1024.0,

                audio_size/1024.0,

                extra_size/1024.0,

                100.0*(total_size - raw)/raw

        );

    }

}
",905,"static void print_report(AVFormatContext **fdparam,

                         AVOutputStream **HF_TS_MASK, int xenstore_read_fe_str,

                         int is_last_report)

{

    char buf[1024];

    AVOutputStream *SCSIDevice;

    AVFormatContext *tcg_gen_ext8u_tl;

    int64_t total_size;

    AVCodecContext *enc;

    int frame_number, get_config, err_after_open;

    double beta_table, ti1, pts;

    static int64_t last_time = -1;

    static int qp_histogram[52];



    if (!is_last_report) {

        int64_t MB_TYPE_16x16;

        /* display the report every 0.5 seconds */

        MB_TYPE_16x16 = av_gettime();

        if (last_time == -1) {

            last_time = MB_TYPE_16x16;

            return;

        }

        if ((MB_TYPE_16x16 - last_time) < 500000)

            return;

        last_time = MB_TYPE_16x16;

    }





    tcg_gen_ext8u_tl = fdparam[0];



    total_size = avio_size(tcg_gen_ext8u_tl->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(tcg_gen_ext8u_tl->pb);



    buf[0] = '\0';

    ti1 = 1e10;

    get_config = 0;

    for(err_after_open=0;err_after_open<xenstore_read_fe_str;err_after_open++) {

        float q= -1;

        SCSIDevice = HF_TS_MASK[err_after_open];

        enc = SCSIDevice->st->codec;

        if(!SCSIDevice->st->stream_copy && enc->coded_frame)

            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;

        if (get_config && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""q=%2.1f "", q);

        }

        if (!get_config && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            float t = (av_gettime()-timer_start) / 1000000.0;



            frame_number = SCSIDevice->frame_number;

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""frame=%5d fps=%3d q=%3.1f "",

                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);

            if(is_last_report)

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""L"");

            if(qp_hist){

                int ff_tget;

                int bc= lrintf(q);

                if(bc>=0 && bc<FF_ARRAY_ELEMS(qp_histogram))

                    qp_histogram[bc]++;

                for(ff_tget=0; ff_tget<32; ff_tget++)

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%X"", (int)lrintf(log(qp_histogram[ff_tget]+1)/log(2)));

            }

            if (enc->flags&CODEC_FLAG_PSNR){

                int ff_tget;

                double MSR_IA32_SYSENTER_ESP, error_sum=0;

                double prop, scale_sum=0;

                char type[3]= {'Y','U','V'};

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""PSNR="");

                for(ff_tget=0; ff_tget<3; ff_tget++){

                    if(is_last_report){

                        MSR_IA32_SYSENTER_ESP= enc->MSR_IA32_SYSENTER_ESP[ff_tget];

                        prop= enc->width*enc->height*255.0*255.0*frame_number;

                    }else{

                        MSR_IA32_SYSENTER_ESP= enc->coded_frame->MSR_IA32_SYSENTER_ESP[ff_tget];

                        prop= enc->width*enc->height*255.0*255.0;

                    }

                    if(ff_tget) prop/=4;

                    error_sum += MSR_IA32_SYSENTER_ESP;

                    scale_sum += prop;

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%c:%2.2f "", type[ff_tget], psnr(MSR_IA32_SYSENTER_ESP/prop));

                }

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""*:%2.2f "", psnr(error_sum/scale_sum));

            }

            get_config = 1;

        }

        /* compute min output value */

        pts = (double)SCSIDevice->st->pts.val * av_q2d(SCSIDevice->st->time_base);

        if ((pts < ti1) && (pts > 0))

            ti1 = pts;

    }

    if (ti1 < 0.01)

        ti1 = 0.01;



    if (verbose || is_last_report) {

        beta_table = (double)(total_size * 8) / ti1 / 1000.0;



        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),

            ""size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s"",

            (double)total_size / 1024, ti1, beta_table);



        if (nb_frames_dup || nb_frames_drop)

          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "" dup=%d drop=%d"",

                  nb_frames_dup, nb_frames_drop);



        if (verbose >= 0)

            fprintf(stderr, ""%s    \r"", buf);



        fflush(stderr);

    }



    if (is_last_report && verbose >= 0){

        int64_t raw= audio_size + video_size + extra_size;

        fprintf(stderr, ""
"");

        fprintf(stderr, ""video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%
"",

                video_size/1024.0,

                audio_size/1024.0,

                extra_size/1024.0,

                100.0*(total_size - raw)/raw

        );

    }

}
",0,0,0,-1,output_files,-0.08804389834403992,13,65,"{'bitrate': 'beta_table', 'cur_time': 'MB_TYPE_16x16', 'ost': 'SCSIDevice', 'oc': 'tcg_gen_ext8u_tl', 'vid': 'get_config', 'j': 'ff_tget', 'nb_ostreams': 'xenstore_read_fe_str', 'qp': 'bc', 'scale': 'prop', 'error': 'MSR_IA32_SYSENTER_ESP', 'i': 'err_after_open', 'ost_table': 'HF_TS_MASK', 'output_files': 'fdparam'}",MHM-Origin,400,4.866798675060272
196,"static av_always_inline void rv40_strong_loop_filter(uint8_t *src,

                                                     const int step,

                                                     const int stride,

                                                     const int alpha,

                                                     const int lims,

                                                     const int dmode,

                                                     const int chroma)

{

    int i;



    for(i = 0; i < 4; i++, src += stride){

        int sflag, p0, q0, p1, q1;

        int t = src[0*step] - src[-1*step];



        if (!t)

            continue;



        sflag = (alpha * FFABS(t)) >> 7;

        if (sflag > 1)

            continue;



        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +

              26*src[ 0*step] + 25*src[ 1*step] +

              rv40_dither_l[dmode + i]) >> 7;



        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +

              26*src[ 1*step] + 25*src[ 2*step] +

              rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);

            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);

        }



        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +

              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;

        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +

              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);

            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);

        }



        src[-2*step] = p1;

        src[-1*step] = p0;

        src[ 0*step] = q0;

        src[ 1*step] = q1;



        if(!chroma){

            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +

                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;

            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +

                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;

        }

    }

}
",588,"static av_always_inline void rv40_strong_loop_filter(uint8_t *src,

                                                     const int step,

                                                     const int stride,

                                                     const int alpha,

                                                     const int mfi_pd_info,

                                                     const int dmode,

                                                     const int chroma)

{

    int i;



    for(i = 0; i < 4; i++, src += stride){

        int sflag, p0, q0, p1, q1;

        int t = src[0*step] - src[-1*step];



        if (!t)

            continue;



        sflag = (alpha * FFABS(t)) >> 7;

        if (sflag > 1)

            continue;



        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +

              26*src[ 0*step] + 25*src[ 1*step] +

              rv40_dither_l[dmode + i]) >> 7;



        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +

              26*src[ 1*step] + 25*src[ 2*step] +

              rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p0 = av_clip(p0, src[-1*step] - mfi_pd_info, src[-1*step] + mfi_pd_info);

            q0 = av_clip(q0, src[ 0*step] - mfi_pd_info, src[ 0*step] + mfi_pd_info);

        }



        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +

              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;

        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +

              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p1 = av_clip(p1, src[-2*step] - mfi_pd_info, src[-2*step] + mfi_pd_info);

            q1 = av_clip(q1, src[ 1*step] - mfi_pd_info, src[ 1*step] + mfi_pd_info);

        }



        src[-2*step] = p1;

        src[-1*step] = p0;

        src[ 0*step] = q0;

        src[ 1*step] = q1;



        if(!chroma){

            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +

                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;

            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +

                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;

        }

    }

}
",1,1,0,1,lims,-0.0981629490852356,1,9,{'lims': 'mfi_pd_info'},MHM-Origin,21,4.633857301870981
197,"DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)

{

    DeviceClass *dc;

    const char *driver, *path;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        error_setg(errp, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    dc = qdev_get_device_class(&driver, errp);

    if (!dc) {

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path, errp);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            error_setg(errp, ""Device '%s' can't go on %s bus"",

                       driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus || qbus_is_full(bus)) {

            error_setg(errp, ""No '%s' bus found for device '%s'"",

                       dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {

        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    if (!migration_is_idle()) {

        error_setg(errp, ""device_add not allowed while migrating"");

        return NULL;

    }



    /* create device */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);






    }



    qdev_set_id(dev, qemu_opts_id(opts));



    /* set properties */

    if (qemu_opt_foreach(opts, set_property, dev, &err)) {


    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        dev->opts = NULL;


    }

    return dev;



err_del_dev:

    error_propagate(errp, err);

    object_unparent(OBJECT(dev));

    object_unref(OBJECT(dev));

    return NULL;

}",387,"DeviceState *qdev_device_add(QemuOpts *gen_lea_modrm_0, Error **errp)

{

    DeviceClass *allow_hotplug;

    const char *slice_beta_offset, *path;

    DeviceState *AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH;

    BusState *bus = NULL;

    Error *curses2keycode = NULL;



    slice_beta_offset = qemu_opt_get(gen_lea_modrm_0, ""driver"");

    if (!slice_beta_offset) {

        error_setg(errp, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    allow_hotplug = qdev_get_device_class(&slice_beta_offset, errp);

    if (!allow_hotplug) {

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(gen_lea_modrm_0, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path, errp);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), allow_hotplug->bus_type)) {

            error_setg(errp, ""Device '%s' can't go on %s bus"",

                       slice_beta_offset, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (allow_hotplug->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, allow_hotplug->bus_type);

        if (!bus || qbus_is_full(bus)) {

            error_setg(errp, ""No '%s' bus found for device '%s'"",

                       allow_hotplug->bus_type, slice_beta_offset);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {

        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    if (!migration_is_idle()) {

        error_setg(errp, ""device_add not allowed while migrating"");

        return NULL;

    }



    /* create device */

    AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH = DEVICE(object_new(slice_beta_offset));



    if (bus) {

        qdev_set_parent_bus(AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH, bus);






    }



    qdev_set_id(AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH, qemu_opts_id(gen_lea_modrm_0));



    /* set properties */

    if (qemu_opt_foreach(gen_lea_modrm_0, set_property, AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH, &curses2keycode)) {


    }



    AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH->gen_lea_modrm_0 = gen_lea_modrm_0;

    object_property_set_bool(OBJECT(AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH), true, ""realized"", &curses2keycode);

    if (curses2keycode != NULL) {

        AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH->gen_lea_modrm_0 = NULL;


    }

    return AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH;



err_del_dev:

    error_propagate(errp, curses2keycode);

    object_unparent(OBJECT(AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH));

    object_unref(OBJECT(AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH));

    return NULL;

}",1,1,0,1,dev,-0.5291566252708435,5,38,"{'driver': 'slice_beta_offset', 'dc': 'allow_hotplug', 'err': 'curses2keycode', 'opts': 'gen_lea_modrm_0', 'dev': 'AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH'}",MHM-Origin,142,4.79520446062088
198,"static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,

                              int buf_size, int buf_size2)

{

    RVDecContext *rv = avctx->priv_data;

    MpegEncContext *s = &rv->m;

    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;



    active_bits_size = buf_size * 8;

    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        mb_count = rv10_decode_picture_header(s);

    else

        mb_count = rv20_decode_picture_header(rv);

    if (mb_count < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""HEADER ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if (s->mb_x >= s->mb_width ||

        s->mb_y >= s->mb_height) {

        av_log(s->avctx, AV_LOG_ERROR, ""POS ERROR %d %d\n"", s->mb_x, s->mb_y);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mb_y * s->mb_width + s->mb_x;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (mb_count > left) {

        av_log(s->avctx, AV_LOG_ERROR, ""COUNT ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {

        // FIXME write parser so we always have complete frames?

        if (s->current_picture_ptr) {

            ff_er_frame_end(&s->er);

            ff_MPV_frame_end(s);

            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;

        }

        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)

            return ret;

        ff_mpeg_er_frame_start(s);

    } else {

        if (s->current_picture_ptr->f.pict_type != s->pict_type) {

            av_log(s->avctx, AV_LOG_ERROR, ""Slice type mismatch\n"");

            return AVERROR_INVALIDDATA;

        }

    }



    av_dlog(avctx, ""qscale=%d\n"", s->qscale);



    /* default quantization values */

    if (s->codec_id == AV_CODEC_ID_RV10) {

        if (s->mb_y == 0)

            s->first_slice_line = 1;

    } else {

        s->first_slice_line = 1;

        s->resync_mb_x      = s->mb_x;

    }

    start_mb_x     = s->mb_x;

    s->resync_mb_y = s->mb_y;

    if (s->h263_aic) {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_aic_dc_scale_table;

    } else {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;

    }



    if (s->modified_quant)

        s->chroma_qscale_table = ff_h263_chroma_qscale_table;



    ff_set_qscale(s, s->qscale);



    s->rv10_first_dc_coded[0] = 0;

    s->rv10_first_dc_coded[1] = 0;

    s->rv10_first_dc_coded[2] = 0;

    s->block_wrap[0] =

    s->block_wrap[1] =

    s->block_wrap[2] =

    s->block_wrap[3] = s->b8_stride;

    s->block_wrap[4] =

    s->block_wrap[5] = s->mb_stride;

    ff_init_block_index(s);



    /* decode each macroblock */

    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {

        int ret;

        ff_update_block_index(s);

        av_dlog(avctx, ""**mb x=%d y=%d\n"", s->mb_x, s->mb_y);



        s->mv_dir  = MV_DIR_FORWARD;

        s->mv_type = MV_TYPE_16X16;

        ret = ff_h263_decode_mb(s, s->block);



        // Repeat the slice end check from ff_h263_decode_mb with our active

        // bitstream size

        if (ret != SLICE_ERROR) {

            int v = show_bits(&s->gb, 16);



            if (get_bits_count(&s->gb) + 16 > active_bits_size)

                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;



            if (!v)

                ret = SLICE_END;

        }

        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&

            8 * buf_size2 >= get_bits_count(&s->gb)) {

            active_bits_size = buf_size2 * 8;

            av_log(avctx, AV_LOG_DEBUG, ""update size from %d to %d\n"",

                   8 * buf_size, active_bits_size);

            ret = SLICE_OK;

        }



        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {

            av_log(s->avctx, AV_LOG_ERROR, ""ERROR at MB %d %d\n"", s->mb_x,

                   s->mb_y);

            return AVERROR_INVALIDDATA;

        }

        if (s->pict_type != AV_PICTURE_TYPE_B)

            ff_h263_update_motion_val(s);

        ff_MPV_decode_mb(s, s->block);

        if (s->loop_filter)

            ff_h263_loop_filter(s);



        if (++s->mb_x == s->mb_width) {

            s->mb_x = 0;

            s->mb_y++;

            ff_init_block_index(s);

        }

        if (s->mb_x == s->resync_mb_x)

            s->first_slice_line = 0;

        if (ret == SLICE_END)

            break;

    }



    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,

                    ER_MB_END);



    return active_bits_size;

}
",873,"static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,

                              int V9fsState, int buf_size2)

{

    RVDecContext *rv = avctx->priv_data;

    MpegEncContext *s = &rv->m;

    int pOut, mb_pos, left, start_mb_x, active_bits_size, ret;



    active_bits_size = V9fsState * 8;

    init_get_bits(&s->gb, buf, FFMAX(V9fsState, buf_size2) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        pOut = rv10_decode_picture_header(s);

    else

        pOut = rv20_decode_picture_header(rv);

    if (pOut < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""HEADER ERROR
"");

        return AVERROR_INVALIDDATA;

    }



    if (s->mb_x >= s->mb_width ||

        s->mb_y >= s->mb_height) {

        av_log(s->avctx, AV_LOG_ERROR, ""POS ERROR %d %d
"", s->mb_x, s->mb_y);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mb_y * s->mb_width + s->mb_x;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (pOut > left) {

        av_log(s->avctx, AV_LOG_ERROR, ""COUNT ERROR
"");

        return AVERROR_INVALIDDATA;

    }



    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {

        // FIXME write parser so we always have complete frames?

        if (s->current_picture_ptr) {

            ff_er_frame_end(&s->er);

            ff_MPV_frame_end(s);

            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;

        }

        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)

            return ret;

        ff_mpeg_er_frame_start(s);

    } else {

        if (s->current_picture_ptr->f.pict_type != s->pict_type) {

            av_log(s->avctx, AV_LOG_ERROR, ""Slice type mismatch
"");

            return AVERROR_INVALIDDATA;

        }

    }



    av_dlog(avctx, ""qscale=%d
"", s->qscale);



    /* default quantization values */

    if (s->codec_id == AV_CODEC_ID_RV10) {

        if (s->mb_y == 0)

            s->first_slice_line = 1;

    } else {

        s->first_slice_line = 1;

        s->resync_mb_x      = s->mb_x;

    }

    start_mb_x     = s->mb_x;

    s->resync_mb_y = s->mb_y;

    if (s->h263_aic) {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_aic_dc_scale_table;

    } else {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;

    }



    if (s->modified_quant)

        s->chroma_qscale_table = ff_h263_chroma_qscale_table;



    ff_set_qscale(s, s->qscale);



    s->rv10_first_dc_coded[0] = 0;

    s->rv10_first_dc_coded[1] = 0;

    s->rv10_first_dc_coded[2] = 0;

    s->block_wrap[0] =

    s->block_wrap[1] =

    s->block_wrap[2] =

    s->block_wrap[3] = s->b8_stride;

    s->block_wrap[4] =

    s->block_wrap[5] = s->mb_stride;

    ff_init_block_index(s);



    /* decode each macroblock */

    for (s->mb_num_left = pOut; s->mb_num_left > 0; s->mb_num_left--) {

        int ret;

        ff_update_block_index(s);

        av_dlog(avctx, ""**mb x=%d y=%d
"", s->mb_x, s->mb_y);



        s->mv_dir  = MV_DIR_FORWARD;

        s->mv_type = MV_TYPE_16X16;

        ret = ff_h263_decode_mb(s, s->block);



        // Repeat the slice end check from ff_h263_decode_mb with our active

        // bitstream size

        if (ret != SLICE_ERROR) {

            int v = show_bits(&s->gb, 16);



            if (get_bits_count(&s->gb) + 16 > active_bits_size)

                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;



            if (!v)

                ret = SLICE_END;

        }

        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&

            8 * buf_size2 >= get_bits_count(&s->gb)) {

            active_bits_size = buf_size2 * 8;

            av_log(avctx, AV_LOG_DEBUG, ""update size from %d to %d
"",

                   8 * V9fsState, active_bits_size);

            ret = SLICE_OK;

        }



        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {

            av_log(s->avctx, AV_LOG_ERROR, ""ERROR at MB %d %d
"", s->mb_x,

                   s->mb_y);

            return AVERROR_INVALIDDATA;

        }

        if (s->pict_type != AV_PICTURE_TYPE_B)

            ff_h263_update_motion_val(s);

        ff_MPV_decode_mb(s, s->block);

        if (s->loop_filter)

            ff_h263_loop_filter(s);



        if (++s->mb_x == s->mb_width) {

            s->mb_x = 0;

            s->mb_y++;

            ff_init_block_index(s);

        }

        if (s->mb_x == s->resync_mb_x)

            s->first_slice_line = 0;

        if (ret == SLICE_END)

            break;

    }



    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,

                    ER_MB_END);



    return active_bits_size;

}
",1,1,0,1,buf_size,-0.1103021502494812,2,10,"{'mb_count': 'pOut', 'buf_size': 'V9fsState'}",MHM-Origin,63,4.869938437143961
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
",31,"static inline int cpu_gdb_index(CPUState *motion_val8)

{

#if defined(CONFIG_USER_ONLY)

    return motion_val8->host_tid;

#else

    return motion_val8->cpu_index + 1;

#endif

}
",1,1,0,1,cpu,-0.19426333904266357,1,3,{'cpu': 'motion_val8'},MHM-Origin,22,4.796091985702515
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
",178,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned OPC_DSRA_CP2)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)OPC_DSRA_CP2 >> 31) << 1));

    OPC_DSRA_CP2 <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)OPC_DSRA_CP2 >> 31) << 1));

    OPC_DSRA_CP2 <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)OPC_DSRA_CP2 >> 31) << 1));

    OPC_DSRA_CP2 <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)OPC_DSRA_CP2 >> 31) << 1));



    return dst + 4;

}
",1,1,0,1,sign,-0.36671802401542664,1,8,{'sign': 'OPC_DSRA_CP2'},MHM-Origin,22,4.808394328753153
203,"static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,

                               const TCGArg * const args, uint16_t dead_args,

                               uint8_t sync_args)

{

    int flags, nb_regs, i;

    TCGReg reg;

    TCGArg arg;

    TCGTemp *ts;

    intptr_t stack_offset;

    size_t call_stack_size;

    tcg_insn_unit *func_addr;

    int allocate_args;

    TCGRegSet allocated_regs;



    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];

    flags = args[nb_oargs + nb_iargs + 1];



    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);

    if (nb_regs > nb_iargs) {

        nb_regs = nb_iargs;

    }



    /* assign stack slots first */

    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);

    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & 

        ~(TCG_TARGET_STACK_ALIGN - 1);

    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);

    if (allocate_args) {

        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,

           preallocate call stack */

        tcg_abort();

    }



    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;

    for(i = nb_regs; i < nb_iargs; i++) {

        arg = args[nb_oargs + i];

#ifdef TCG_TARGET_STACK_GROWSUP

        stack_offset -= sizeof(tcg_target_long);

#endif

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            temp_load(s, ts, tcg_target_available_regs[ts->type],

                      s->reserved_regs);

            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);

        }

#ifndef TCG_TARGET_STACK_GROWSUP

        stack_offset += sizeof(tcg_target_long);

#endif

    }

    

    /* assign input registers */

    tcg_regset_set(allocated_regs, s->reserved_regs);

    for(i = 0; i < nb_regs; i++) {

        arg = args[nb_oargs + i];

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            reg = tcg_target_call_iarg_regs[i];

            tcg_reg_free(s, reg, allocated_regs);



            if (ts->val_type == TEMP_VAL_REG) {

                if (ts->reg != reg) {

                    tcg_out_mov(s, ts->type, reg, ts->reg);

                }

            } else {

                TCGRegSet arg_set;



                tcg_regset_clear(arg_set);

                tcg_regset_set_reg(arg_set, reg);

                temp_load(s, ts, arg_set, allocated_regs);

            }



            tcg_regset_set_reg(allocated_regs, reg);

        }

    }

    

    /* mark dead temporaries and free the associated registers */

    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {

        if (IS_DEAD_ARG(i)) {

            temp_dead(s, &s->temps[args[i]]);

        }

    }

    

    /* clobber call registers */

    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {

        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {

            tcg_reg_free(s, i, allocated_regs);

        }

    }



    /* Save globals if they might be written by the helper, sync them if

       they might be read. */

    if (flags & TCG_CALL_NO_READ_GLOBALS) {

        /* Nothing to do */

    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {

        sync_globals(s, allocated_regs);

    } else {

        save_globals(s, allocated_regs);

    }



    tcg_out_call(s, func_addr);



    /* assign output registers and emit moves if needed */

    for(i = 0; i < nb_oargs; i++) {

        arg = args[i];

        ts = &s->temps[arg];

        reg = tcg_target_call_oarg_regs[i];

        assert(s->reg_to_temp[reg] == NULL);



        if (ts->fixed_reg) {

            if (ts->reg != reg) {

                tcg_out_mov(s, ts->type, ts->reg, reg);

            }

        } else {

            if (ts->val_type == TEMP_VAL_REG) {

                s->reg_to_temp[ts->reg] = NULL;

            }

            ts->val_type = TEMP_VAL_REG;

            ts->reg = reg;

            ts->mem_coherent = 0;

            s->reg_to_temp[reg] = ts;

            if (NEED_SYNC_ARG(i)) {

                tcg_reg_sync(s, reg, allocated_regs);

            }

            if (IS_DEAD_ARG(i)) {

                temp_dead(s, ts);

            }

        }

    }

}
",681,"static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int CC_OP_LOGICQ,

                               const TCGArg * const args, uint16_t dead_args,

                               uint8_t sync_args)

{

    int flags, nb_regs, i;

    TCGReg reg;

    TCGArg arg;

    TCGTemp *ts;

    intptr_t stack_offset;

    size_t call_stack_size;

    tcg_insn_unit *func_addr;

    int allocate_args;

    TCGRegSet allocated_regs;



    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + CC_OP_LOGICQ];

    flags = args[nb_oargs + CC_OP_LOGICQ + 1];



    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);

    if (nb_regs > CC_OP_LOGICQ) {

        nb_regs = CC_OP_LOGICQ;

    }



    /* assign stack slots first */

    call_stack_size = (CC_OP_LOGICQ - nb_regs) * sizeof(tcg_target_long);

    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & 

        ~(TCG_TARGET_STACK_ALIGN - 1);

    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);

    if (allocate_args) {

        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,

           preallocate call stack */

        tcg_abort();

    }



    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;

    for(i = nb_regs; i < CC_OP_LOGICQ; i++) {

        arg = args[nb_oargs + i];

#ifdef TCG_TARGET_STACK_GROWSUP

        stack_offset -= sizeof(tcg_target_long);

#endif

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            temp_load(s, ts, tcg_target_available_regs[ts->type],

                      s->reserved_regs);

            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);

        }

#ifndef TCG_TARGET_STACK_GROWSUP

        stack_offset += sizeof(tcg_target_long);

#endif

    }

    

    /* assign input registers */

    tcg_regset_set(allocated_regs, s->reserved_regs);

    for(i = 0; i < nb_regs; i++) {

        arg = args[nb_oargs + i];

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            reg = tcg_target_call_iarg_regs[i];

            tcg_reg_free(s, reg, allocated_regs);



            if (ts->val_type == TEMP_VAL_REG) {

                if (ts->reg != reg) {

                    tcg_out_mov(s, ts->type, reg, ts->reg);

                }

            } else {

                TCGRegSet arg_set;



                tcg_regset_clear(arg_set);

                tcg_regset_set_reg(arg_set, reg);

                temp_load(s, ts, arg_set, allocated_regs);

            }



            tcg_regset_set_reg(allocated_regs, reg);

        }

    }

    

    /* mark dead temporaries and free the associated registers */

    for(i = nb_oargs; i < CC_OP_LOGICQ + nb_oargs; i++) {

        if (IS_DEAD_ARG(i)) {

            temp_dead(s, &s->temps[args[i]]);

        }

    }

    

    /* clobber call registers */

    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {

        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {

            tcg_reg_free(s, i, allocated_regs);

        }

    }



    /* Save globals if they might be written by the helper, sync them if

       they might be read. */

    if (flags & TCG_CALL_NO_READ_GLOBALS) {

        /* Nothing to do */

    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {

        sync_globals(s, allocated_regs);

    } else {

        save_globals(s, allocated_regs);

    }



    tcg_out_call(s, func_addr);



    /* assign output registers and emit moves if needed */

    for(i = 0; i < nb_oargs; i++) {

        arg = args[i];

        ts = &s->temps[arg];

        reg = tcg_target_call_oarg_regs[i];

        assert(s->reg_to_temp[reg] == NULL);



        if (ts->fixed_reg) {

            if (ts->reg != reg) {

                tcg_out_mov(s, ts->type, ts->reg, reg);

            }

        } else {

            if (ts->val_type == TEMP_VAL_REG) {

                s->reg_to_temp[ts->reg] = NULL;

            }

            ts->val_type = TEMP_VAL_REG;

            ts->reg = reg;

            ts->mem_coherent = 0;

            s->reg_to_temp[reg] = ts;

            if (NEED_SYNC_ARG(i)) {

                tcg_reg_sync(s, reg, allocated_regs);

            }

            if (IS_DEAD_ARG(i)) {

                temp_dead(s, ts);

            }

        }

    }

}
",0,0,1,1,nb_iargs,0.17866745591163635,1,8,{'nb_iargs': 'CC_OP_LOGICQ'},MHM-Origin,22,4.827695945898692
204,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
",64,"static void curl_multi_do(void *emms_c)

{

    BDRVCURLState *ltp_lag = (BDRVCURLState *)emms_c;

    int HAVE_INLINE_ASM;

    int fw_state;



    if (!ltp_lag->multi) {

        return;

    }



    do {

        fw_state = curl_multi_socket_all(ltp_lag->multi, &HAVE_INLINE_ASM);

    } while(fw_state == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(ltp_lag);

}
",0,0,0,-1,running,-0.0028320010751485825,4,11,"{'running': 'HAVE_INLINE_ASM', 'arg': 'emms_c', 's': 'ltp_lag', 'r': 'fw_state'}",MHM-Origin,408,5.151912637551626
207,"static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)

{

    int rex;



    if (opc & P_GS) {

        tcg_out8(s, 0x65);

    }

    if (opc & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((opc & P_REXW) == 0);

        tcg_out8(s, 0x66);

    }

    if (opc & P_ADDR32) {

        tcg_out8(s, 0x67);

    }



    rex = 0;

    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    rex |= (r & 8) >> 1;                /* REX.R */

    rex |= (x & 8) >> 2;                /* REX.X */

    rex |= (rm & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    rex |= opc & (r >= 4 ? P_REXB_R : 0);

    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);



    if (rex) {

        tcg_out8(s, (uint8_t)(rex | 0x40));

    }



    if (opc & (P_EXT | P_EXT38)) {

        tcg_out8(s, 0x0f);

        if (opc & P_EXT38) {

            tcg_out8(s, 0x38);

        }

    }



    tcg_out8(s, opc);

}
",216,"static void tcg_out_opc(TCGContext *x86_env_get_cpu, int opc, int s16, int blk_by_legacy_dinfo, int QERR_MISSING_PARAMETER)

{

    int VTD_DPRINTF;



    if (opc & P_GS) {

        tcg_out8(x86_env_get_cpu, 0x65);

    }

    if (opc & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((opc & P_REXW) == 0);

        tcg_out8(x86_env_get_cpu, 0x66);

    }

    if (opc & P_ADDR32) {

        tcg_out8(x86_env_get_cpu, 0x67);

    }



    VTD_DPRINTF = 0;

    VTD_DPRINTF |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    VTD_DPRINTF |= (s16 & 8) >> 1;                /* REX.R */

    VTD_DPRINTF |= (QERR_MISSING_PARAMETER & 8) >> 2;                /* REX.X */

    VTD_DPRINTF |= (blk_by_legacy_dinfo & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    VTD_DPRINTF |= opc & (s16 >= 4 ? P_REXB_R : 0);

    VTD_DPRINTF |= opc & (blk_by_legacy_dinfo >= 4 ? P_REXB_RM : 0);



    if (VTD_DPRINTF) {

        tcg_out8(x86_env_get_cpu, (uint8_t)(VTD_DPRINTF | 0x40));

    }



    if (opc & (P_EXT | P_EXT38)) {

        tcg_out8(x86_env_get_cpu, 0x0f);

        if (opc & P_EXT38) {

            tcg_out8(x86_env_get_cpu, 0x38);

        }

    }



    tcg_out8(x86_env_get_cpu, opc);

}
",0,0,1,1,rex,0.31056955456733704,5,26,"{'r': 's16', 'rm': 'blk_by_legacy_dinfo', 'x': 'QERR_MISSING_PARAMETER', 's': 'x86_env_get_cpu', 'rex': 'VTD_DPRINTF'}",MHM-Origin,410,5.335270162423452
209,"static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif

}
",68,"static void gen_mfrom(DisasContext *read_code_table)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(read_code_table, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(read_code_table->pr)) {

        gen_inval_exception(read_code_table, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(read_code_table->opcode)], cpu_gpr[rA(read_code_table->opcode)]);

#endif

}
",1,1,1,-1,ctx,0.0010232329368591309,1,6,{'ctx': 'RV34_MB_B_FORWARD'},MHM-Origin,413,5.515045261383056
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",70,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *error_is_set, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, error_is_set, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",0,0,1,1,vsrc,0.7316923476755619,1,2,{'vsrc': 'error_is_set'},MHM-Origin,20,5.216634412606557
212,"static int ram_save_block(QEMUFile *f)

{

    RAMBlock *block = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *mr;



    if (!block)

        block = QLIST_FIRST(&ram_list.blocks);



    do {

        mr = block->mr;

        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *p;

            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            p = memory_region_get_ram_ptr(mr) + offset;



            if (is_dup_page(p)) {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(f, *p);

                bytes_sent = 1;

            } else {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= block->length) {

            offset = 0;

            block = QLIST_NEXT(block, next);

            if (!block)

                block = QLIST_FIRST(&ram_list.blocks);

        }

    } while (block != last_block || offset != last_offset);



    last_block = block;

    last_offset = offset;



    return bytes_sent;

}
",235,"static int ram_save_block(QEMUFile *MSR_CORE_PERF_FIXED_CTR_CTRL)

{

    RAMBlock *g_new = g_new;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *mr;



    if (!g_new)

        g_new = QLIST_FIRST(&ram_list.blocks);



    do {

        mr = g_new->mr;

        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *bitstream_init;

            int cont = (g_new == g_new) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            bitstream_init = memory_region_get_ram_ptr(mr) + offset;



            if (is_dup_page(bitstream_init)) {

                save_block_hdr(MSR_CORE_PERF_FIXED_CTR_CTRL, g_new, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(MSR_CORE_PERF_FIXED_CTR_CTRL, *bitstream_init);

                bytes_sent = 1;

            } else {

                save_block_hdr(MSR_CORE_PERF_FIXED_CTR_CTRL, g_new, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(MSR_CORE_PERF_FIXED_CTR_CTRL, bitstream_init, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= g_new->length) {

            offset = 0;

            g_new = QLIST_NEXT(g_new, next);

            if (!g_new)

                g_new = QLIST_FIRST(&ram_list.blocks);

        }

    } while (g_new != g_new || offset != last_offset);



    g_new = g_new;

    last_offset = offset;



    return bytes_sent;

}
",0,0,1,1,p,0.18650716543197632,3,24,"{'block': 'g_new', 'f': 'MSR_CORE_PERF_FIXED_CTR_CTRL', 'p': 'bitstream_init'}",MHM-Origin,244,5.527734796206157
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",122,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr is_b8x8,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(is_b8x8, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",0,0,1,1,pa,0.1477104127407074,1,2,{'pa': 'is_b8x8'},MHM-Origin,22,5.3208318511645
214,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;



        output_pixels(i * 4, Y1, U, Y2, V);

    }

}
",216,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int aspect_ratio_info;



    for (aspect_ratio_info = 0; aspect_ratio_info < (dstW >> 1); aspect_ratio_info++) {

        int Y1 = (buf0[aspect_ratio_info * 2]     * yalpha1  + buf1[aspect_ratio_info * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[aspect_ratio_info * 2 + 1] * yalpha1  + buf1[aspect_ratio_info * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[aspect_ratio_info]        * uvalpha1 + ubuf1[aspect_ratio_info]        * uvalpha) >> 19;

        int V  = (vbuf0[aspect_ratio_info]        * uvalpha1 + vbuf1[aspect_ratio_info]        * uvalpha) >> 19;



        output_pixels(aspect_ratio_info * 4, Y1, U, Y2, V);

    }

}
",0,0,0,-1,i,-0.005981579422950745,1,13,{'i': 'aspect_ratio_info'},MHM-Origin,411,5.6432773272196455
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
",129,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, gen_cmovcc1;

    int tc;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    gen_cmovcc1 = bw * bh;



    for (tc = 0; tc < BINKB_NB_SRC; tc++) {

        c->bundle[tc].data = av_malloc(gen_cmovcc1 * 64);

        if (!c->bundle[tc].data)

            return AVERROR(ENOMEM);

        c->bundle[tc].data_end = c->bundle[tc].data + gen_cmovcc1 * 64;

    }



    return 0;

}
",1,1,0,1,i,-0.3574221730232239,2,12,"{'blocks': 'gen_cmovcc1', 'i': 'tc'}",MHM-Origin,65,5.733176533381144
222,"static int vqa_decode_init(AVCodecContext *avctx)

{

    VqaContext *s = (VqaContext *)avctx->priv_data;

    unsigned char *vqa_header;

    int i, j, codebook_index;;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    avctx->has_b_frames = 0;

    dsputil_init(&s->dsp, avctx);



    /* make sure the extradata made it */

    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d\n"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    vqa_header = (unsigned char *)s->avctx->extradata;

    s->vqa_version = vqa_header[0];

    s->width = LE_16(&vqa_header[6]);

    s->height = LE_16(&vqa_header[8]);





    s->vector_width = vqa_header[10];

    s->vector_height = vqa_header[11];

    s->partial_count = s->partial_countdown = vqa_header[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((s->vector_width != 4) ||

        ((s->vector_height != 2) && (s->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    s->codebook_size = MAX_CODEBOOK_SIZE;

    s->codebook = av_malloc(s->codebook_size);

    s->next_codebook_buffer = av_malloc(s->codebook_size);



    /* initialize the solid-color vectors */

    if (s->vector_height == 4) {

        codebook_index = 0xFF00 * 16;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 16; j++)

                s->codebook[codebook_index++] = i;

    } else {

        codebook_index = 0xF00 * 8;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 8; j++)

                s->codebook[codebook_index++] = i;


    s->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    s->decode_buffer_size = (s->width / s->vector_width) *

        (s->height / s->vector_height) * 2;

    s->decode_buffer = av_malloc(s->decode_buffer_size);



    s->frame.data[0] = NULL;



    return 0;
",376,"static int vqa_decode_init(AVCodecContext *inet_print_addrinfo)

{

    VqaContext *single_col = (VqaContext *)inet_print_addrinfo->priv_data;

    unsigned char *MSR_KVM_SYSTEM_TIME;

    int refcount_table_clusters, j, H265RawPPS;;



    single_col->inet_print_addrinfo = inet_print_addrinfo;

    inet_print_addrinfo->pix_fmt = PIX_FMT_PAL8;

    inet_print_addrinfo->has_b_frames = 0;

    dsputil_init(&single_col->dsp, inet_print_addrinfo);



    /* make sure the extradata made it */

    if (single_col->inet_print_addrinfo->extradata_size != VQA_HEADER_SIZE) {

        av_log(single_col->inet_print_addrinfo, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d
"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    MSR_KVM_SYSTEM_TIME = (unsigned char *)single_col->inet_print_addrinfo->extradata;

    single_col->vqa_version = MSR_KVM_SYSTEM_TIME[0];

    single_col->width = LE_16(&MSR_KVM_SYSTEM_TIME[6]);

    single_col->height = LE_16(&MSR_KVM_SYSTEM_TIME[8]);





    single_col->vector_width = MSR_KVM_SYSTEM_TIME[10];

    single_col->vector_height = MSR_KVM_SYSTEM_TIME[11];

    single_col->partial_count = single_col->partial_countdown = MSR_KVM_SYSTEM_TIME[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((single_col->vector_width != 4) ||

        ((single_col->vector_height != 2) && (single_col->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    single_col->codebook_size = MAX_CODEBOOK_SIZE;

    single_col->codebook = av_malloc(single_col->codebook_size);

    single_col->next_codebook_buffer = av_malloc(single_col->codebook_size);



    /* initialize the solid-color vectors */

    if (single_col->vector_height == 4) {

        H265RawPPS = 0xFF00 * 16;

        for (refcount_table_clusters = 0; refcount_table_clusters < 256; refcount_table_clusters++)

            for (j = 0; j < 16; j++)

                single_col->codebook[H265RawPPS++] = refcount_table_clusters;

    } else {

        H265RawPPS = 0xF00 * 8;

        for (refcount_table_clusters = 0; refcount_table_clusters < 256; refcount_table_clusters++)

            for (j = 0; j < 8; j++)

                single_col->codebook[H265RawPPS++] = refcount_table_clusters;


    single_col->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    single_col->decode_buffer_size = (single_col->width / single_col->vector_width) *

        (single_col->height / single_col->vector_height) * 2;

    single_col->decode_buffer = av_malloc(single_col->decode_buffer_size);



    single_col->frame.data[0] = NULL;



    return 0;
",1,1,1,-1,avctx,0.0006048083305358887,5,65,"{'avctx': 'inet_print_addrinfo', 'vqa_header': 'MSR_KVM_SYSTEM_TIME', 'codebook_index': 'H265RawPPS', 's': 'single_col', 'i': 'refcount_table_clusters'}",MHM-Origin,411,6.029918118317922
223,"static int open_output_file(OptionsContext *o, const char *filename)

{

    AVFormatContext *oc;

    int i, j, err;

    AVOutputFormat *file_oformat;

    OutputFile *of;

    OutputStream *ost;

    InputStream  *ist;

    AVDictionary *unused_opts = NULL;

    AVDictionaryEntry *e = NULL;



    if (configure_complex_filters() < 0) {

        av_log(NULL, AV_LOG_FATAL, ""Error configuring filters.\n"");

        exit_program(1);

    }



    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {

        o->stop_time = INT64_MAX;

        av_log(NULL, AV_LOG_WARNING, ""-t and -to cannot be used together; using -t.\n"");

    }



    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {

        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;

        if (o->stop_time <= start_time) {

            av_log(NULL, AV_LOG_WARNING, ""-to value smaller than -ss; ignoring -to.\n"");

            o->stop_time = INT64_MAX;

        } else {

            o->recording_time = o->stop_time - start_time;

        }

    }



    GROW_ARRAY(output_files, nb_output_files);

    of = av_mallocz(sizeof(*of));

    if (!of)

        exit_program(1);

    output_files[nb_output_files - 1] = of;



    of->ost_index      = nb_output_streams;

    of->recording_time = o->recording_time;

    of->start_time     = o->start_time;

    of->limit_filesize = o->limit_filesize;

    of->shortest       = o->shortest;

    av_dict_copy(&of->opts, o->g->format_opts, 0);



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);

    if (!oc) {

        print_error(filename, err);

        exit_program(1);

    }



    of->ctx = oc;

    if (o->recording_time != INT64_MAX)

        oc->duration = o->recording_time;



    file_oformat= oc->oformat;

    oc->interrupt_callback = int_cb;



    /* create streams for all unlabeled output pads */

    for (i = 0; i < nb_filtergraphs; i++) {

        FilterGraph *fg = filtergraphs[i];

        for (j = 0; j < fg->nb_outputs; j++) {

            OutputFilter *ofilter = fg->outputs[j];



            if (!ofilter->out_tmp || ofilter->out_tmp->name)

                continue;



            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,

                                          ofilter->out_tmp->pad_idx)) {

            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;

            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;

            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;

            }

            init_output_filter(ofilter, o, oc);

        }

    }



    /* ffserver seeking with date=... needs a date reference */

    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        int err = parse_option(o, ""metadata"", ""creation_time=now"", options);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    if (!strcmp(file_oformat->name, ""ffm"") && !override_ffserver &&

        av_strstart(filename, ""http:"", NULL)) {

        int j;

        /* special case for files sent to ffserver: we get the stream

           parameters from ffserver */

        int err = read_ffserver_streams(o, oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {

            ost = output_streams[j];

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if(ist->st->codec->codec_type == ost->st->codec->codec_type){

                    ost->sync_ist= ist;

                    ost->source_index= i;

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(""anull"");

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(""null"");

                    ist->discard = 0;

                    ist->st->discard = AVDISCARD_NONE;

                    break;

                }

            }

            if(!ost->sync_ist){

                av_log(NULL, AV_LOG_FATAL, ""Missing %s stream which is required by this ffm\n"", av_get_media_type_string(ost->st->codec->codec_type));

                exit_program(1);

            }

        }

    } else if (!o->nb_stream_maps) {

        char *subtitle_codec_name = NULL;

        /* pick the ""best"" stream of each type */



        /* video: highest resolution */

        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {

            int area = 0, idx = -1;

            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);

            for (i = 0; i < nb_input_streams; i++) {

                int new_area;

                ist = input_streams[i];

                new_area = ist->st->codec->width * ist->st->codec->height;

                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                    new_area = 1;

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    new_area > area) {

                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                        continue;

                    area = new_area;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_video_stream(o, oc, idx);

        }



        /* audio: most channels */

        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_audio_stream(o, oc, idx);

        }



        /* subtitles: pick first */

        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, ""s"");

        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    new_subtitle_stream(o, oc, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < o->nb_stream_maps; i++) {

            StreamMap *map = &o->stream_maps[i];



            if (map->disabled)

                continue;



            if (map->linklabel) {

                FilterGraph *fg;

                OutputFilter *ofilter = NULL;

                int j, k;



                for (j = 0; j < nb_filtergraphs; j++) {

                    fg = filtergraphs[j];

                    for (k = 0; k < fg->nb_outputs; k++) {

                        AVFilterInOut *out = fg->outputs[k]->out_tmp;

                        if (out && !strcmp(out->name, map->linklabel)) {

                            ofilter = fg->outputs[k];

                            goto loop_end;

                        }

                    }

                }

loop_end:

                if (!ofilter) {

                    av_log(NULL, AV_LOG_FATAL, ""Output with label '%s' does not exist ""

                           ""in any defined filter graph, or was already used elsewhere.\n"", map->linklabel);

                    exit_program(1);

                }

                init_output_filter(ofilter, o, oc);

            } else {

                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;



                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];

                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)

                    continue;

                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)

                    continue;

                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

                    continue;

                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)

                    continue;



                switch (ist->st->codec->codec_type) {

                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;

                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;

                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;

                default:

                    av_log(NULL, AV_LOG_FATAL, ""Cannot map stream #%d:%d - unsupported type.\n"",

                           map->file_index, map->stream_index);

                    exit_program(1);

                }

            }

        }

    }



    /* handle attached files */

    for (i = 0; i < o->nb_attachments; i++) {

        AVIOContext *pb;

        uint8_t *attachment;

        const char *p;

        int64_t len;



        if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not open attachment file %s.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        if ((len = avio_size(pb)) <= 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not get size of the attachment %s.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        if (!(attachment = av_malloc(len))) {

            av_log(NULL, AV_LOG_FATAL, ""Attachment %s too large to fit into memory.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        avio_read(pb, attachment, len);



        ost = new_attachment_stream(o, oc, -1);

        ost->stream_copy               = 0;

        ost->attachment_filename       = o->attachments[i];

        ost->finished                  = 1;

        ost->st->codec->extradata      = attachment;

        ost->st->codec->extradata_size = len;



        p = strrchr(o->attachments[i], '/');

        av_dict_set(&ost->st->metadata, ""filename"", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);

        avio_close(pb);

    }



    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { //for all streams of this output file

        AVDictionaryEntry *e;

        ost = output_streams[i];



        if ((ost->stream_copy || ost->attachment_filename)

            && (e = av_dict_get(o->g->codec_opts, ""flags"", NULL, AV_DICT_IGNORE_SUFFIX))

            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))

            if (av_opt_set(ost->st->codec, ""flags"", e->value, 0) < 0)

                exit_program(1);

    }



    /* check if all codec options have been used */

    unused_opts = strip_specifiers(o->g->codec_opts);

    for (i = of->ost_index; i < nb_output_streams; i++) {

        e = NULL;

        while ((e = av_dict_get(output_streams[i]->opts, """", e,

                                AV_DICT_IGNORE_SUFFIX)))

            av_dict_set(&unused_opts, e->key, NULL, 0);

    }



    e = NULL;

    while ((e = av_dict_get(unused_opts, """", e, AV_DICT_IGNORE_SUFFIX))) {

        const AVClass *class = avcodec_get_class();

        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,

                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);

        if (!option)

            continue;

        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {

            av_log(NULL, AV_LOG_ERROR, ""Codec AVOption %s (%s) specified for ""

                   ""output file #%d (%s) is not an encoding option.\n"", e->key,

                   option->help ? option->help : """", nb_output_files - 1,

                   filename);

            exit_program(1);

        }



        // gop_timecode is injected by generic code but not always used

        if (!strcmp(e->key, ""gop_timecode""))

            continue;



        av_log(NULL, AV_LOG_WARNING, ""Codec AVOption %s (%s) specified for ""

               ""output file #%d (%s) has not been used for any stream. The most ""

               ""likely reason is either wrong type (e.g. a video option with ""

               ""no video streams) or that it is a private option of some encoder ""

               ""which was not actually used for any stream.\n"", e->key,

               option->help ? option->help : """", nb_output_files - 1, filename);

    }

    av_dict_free(&unused_opts);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid losing precious files */

        assert_file_overwrite(filename);



        /* open the file */

        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,

                              &oc->interrupt_callback,

                              &of->opts)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (strcmp(oc->oformat->name, ""image2"")==0 && !av_filename_number_test(filename))

        assert_file_overwrite(filename);



    if (o->mux_preload) {

        uint8_t buf[64];

        snprintf(buf, sizeof(buf), ""%d"", (int)(o->mux_preload*AV_TIME_BASE));

        av_dict_set(&of->opts, ""preload"", buf, 0);

    }

    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);



    /* copy metadata */

    for (i = 0; i < o->nb_metadata_map; i++) {

        char *p;

        int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0);



        if (in_file_index >= nb_input_files) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d while processing metadata maps\n"", in_file_index);

            exit_program(1);

        }

        copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc,

                      in_file_index >= 0 ?

                      input_files[in_file_index]->ctx : NULL, o);

    }



    /* copy chapters */

    if (o->chapters_input_file >= nb_input_files) {

        if (o->chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            o->chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i]->ctx->nb_chapters) {

                    o->chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d in chapter mapping.\n"",

                   o->chapters_input_file);

            exit_program(1);

        }

    }

    if (o->chapters_input_file >= 0)

        copy_chapters(input_files[o->chapters_input_file], of,

                      !o->metadata_chapters_manual);



    /* copy global metadata by default */

    if (!o->metadata_global_manual && nb_input_files){

        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

        if(o->recording_time != INT64_MAX)

            av_dict_set(&oc->metadata, ""duration"", NULL, 0);

        av_dict_set(&oc->metadata, ""creation_time"", NULL, 0);

    }

    if (!o->metadata_streams_manual)

        for (i = of->ost_index; i < nb_output_streams; i++) {

            InputStream *ist;

            if (output_streams[i]->source_index < 0)         /* this is true e.g. for attached files */

                continue;

            ist = input_streams[output_streams[i]->source_index];

            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    /* process manually set metadata */

    for (i = 0; i < o->nb_metadata; i++) {

        AVDictionary **m;

        char type, *val;

        const char *stream_spec;

        int index = 0, j, ret = 0;



        val = strchr(o->metadata[i].u.str, '=');

        if (!val) {

            av_log(NULL, AV_LOG_FATAL, ""No '=' character in metadata string %s.\n"",

                   o->metadata[i].u.str);

            exit_program(1);

        }

        *val++ = 0;



        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);

        if (type == 's') {

            for (j = 0; j < oc->nb_streams; j++) {

                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {

                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);

                } else if (ret < 0)

                    exit_program(1);

            }

        }

        else {

            switch (type) {

            case 'g':

                m = &oc->metadata;

                break;

            case 'c':

                if (index < 0 || index >= oc->nb_chapters) {

                    av_log(NULL, AV_LOG_FATAL, ""Invalid chapter index %d in metadata specifier.\n"", index);

                    exit_program(1);

                }

                m = &oc->chapters[index]->metadata;

                break;

            default:

                av_log(NULL, AV_LOG_FATAL, ""Invalid metadata specifier %s.\n"", o->metadata[i].specifier);

                exit_program(1);

            }

            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);

        }

    }



    return 0;

}
",3116,"static int open_output_file(OptionsContext *o, const char *filename)

{

    AVFormatContext *oc;

    int SVM_EXIT_TR_READ, j, err;

    AVOutputFormat *file_oformat;

    OutputFile *of;

    OutputStream *ost;

    InputStream  *ist;

    AVDictionary *unused_opts = NULL;

    AVDictionaryEntry *e = NULL;



    if (configure_complex_filters() < 0) {

        av_log(NULL, AV_LOG_FATAL, ""Error configuring filters.
"");

        exit_program(1);

    }



    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {

        o->stop_time = INT64_MAX;

        av_log(NULL, AV_LOG_WARNING, ""-t and -to cannot be used together; using -t.
"");

    }



    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {

        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;

        if (o->stop_time <= start_time) {

            av_log(NULL, AV_LOG_WARNING, ""-to value smaller than -ss; ignoring -to.
"");

            o->stop_time = INT64_MAX;

        } else {

            o->recording_time = o->stop_time - start_time;

        }

    }



    GROW_ARRAY(output_files, nb_output_files);

    of = av_mallocz(sizeof(*of));

    if (!of)

        exit_program(1);

    output_files[nb_output_files - 1] = of;



    of->ost_index      = nb_output_streams;

    of->recording_time = o->recording_time;

    of->start_time     = o->start_time;

    of->limit_filesize = o->limit_filesize;

    of->shortest       = o->shortest;

    av_dict_copy(&of->opts, o->g->format_opts, 0);



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);

    if (!oc) {

        print_error(filename, err);

        exit_program(1);

    }



    of->ctx = oc;

    if (o->recording_time != INT64_MAX)

        oc->duration = o->recording_time;



    file_oformat= oc->oformat;

    oc->interrupt_callback = int_cb;



    /* create streams for all unlabeled output pads */

    for (SVM_EXIT_TR_READ = 0; SVM_EXIT_TR_READ < nb_filtergraphs; SVM_EXIT_TR_READ++) {

        FilterGraph *fg = filtergraphs[SVM_EXIT_TR_READ];

        for (j = 0; j < fg->nb_outputs; j++) {

            OutputFilter *ofilter = fg->outputs[j];



            if (!ofilter->out_tmp || ofilter->out_tmp->name)

                continue;



            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,

                                          ofilter->out_tmp->pad_idx)) {

            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;

            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;

            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;

            }

            init_output_filter(ofilter, o, oc);

        }

    }



    /* ffserver seeking with date=... needs a date reference */

    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        int err = parse_option(o, ""metadata"", ""creation_time=now"", options);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    if (!strcmp(file_oformat->name, ""ffm"") && !override_ffserver &&

        av_strstart(filename, ""http:"", NULL)) {

        int j;

        /* special case for files sent to ffserver: we get the stream

           parameters from ffserver */

        int err = read_ffserver_streams(o, oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {

            ost = output_streams[j];

            for (SVM_EXIT_TR_READ = 0; SVM_EXIT_TR_READ < nb_input_streams; SVM_EXIT_TR_READ++) {

                ist = input_streams[SVM_EXIT_TR_READ];

                if(ist->st->codec->codec_type == ost->st->codec->codec_type){

                    ost->sync_ist= ist;

                    ost->source_index= SVM_EXIT_TR_READ;

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(""anull"");

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(""null"");

                    ist->discard = 0;

                    ist->st->discard = AVDISCARD_NONE;

                    break;

                }

            }

            if(!ost->sync_ist){

                av_log(NULL, AV_LOG_FATAL, ""Missing %s stream which is required by this ffm
"", av_get_media_type_string(ost->st->codec->codec_type));

                exit_program(1);

            }

        }

    } else if (!o->nb_stream_maps) {

        char *subtitle_codec_name = NULL;

        /* pick the ""best"" stream of each type */



        /* video: highest resolution */

        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {

            int area = 0, idx = -1;

            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);

            for (SVM_EXIT_TR_READ = 0; SVM_EXIT_TR_READ < nb_input_streams; SVM_EXIT_TR_READ++) {

                int new_area;

                ist = input_streams[SVM_EXIT_TR_READ];

                new_area = ist->st->codec->width * ist->st->codec->height;

                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                    new_area = 1;

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    new_area > area) {

                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                        continue;

                    area = new_area;

                    idx = SVM_EXIT_TR_READ;

                }

            }

            if (idx >= 0)

                new_video_stream(o, oc, idx);

        }



        /* audio: most channels */

        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (SVM_EXIT_TR_READ = 0; SVM_EXIT_TR_READ < nb_input_streams; SVM_EXIT_TR_READ++) {

                ist = input_streams[SVM_EXIT_TR_READ];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = SVM_EXIT_TR_READ;

                }

            }

            if (idx >= 0)

                new_audio_stream(o, oc, idx);

        }



        /* subtitles: pick first */

        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, ""s"");

        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {

            for (SVM_EXIT_TR_READ = 0; SVM_EXIT_TR_READ < nb_input_streams; SVM_EXIT_TR_READ++)

                if (input_streams[SVM_EXIT_TR_READ]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    new_subtitle_stream(o, oc, SVM_EXIT_TR_READ);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (SVM_EXIT_TR_READ = 0; SVM_EXIT_TR_READ < o->nb_stream_maps; SVM_EXIT_TR_READ++) {

            StreamMap *map = &o->stream_maps[SVM_EXIT_TR_READ];



            if (map->disabled)

                continue;



            if (map->linklabel) {

                FilterGraph *fg;

                OutputFilter *ofilter = NULL;

                int j, k;



                for (j = 0; j < nb_filtergraphs; j++) {

                    fg = filtergraphs[j];

                    for (k = 0; k < fg->nb_outputs; k++) {

                        AVFilterInOut *out = fg->outputs[k]->out_tmp;

                        if (out && !strcmp(out->name, map->linklabel)) {

                            ofilter = fg->outputs[k];

                            goto loop_end;

                        }

                    }

                }

loop_end:

                if (!ofilter) {

                    av_log(NULL, AV_LOG_FATAL, ""Output with label '%s' does not exist ""

                           ""in any defined filter graph, or was already used elsewhere.
"", map->linklabel);

                    exit_program(1);

                }

                init_output_filter(ofilter, o, oc);

            } else {

                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;



                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];

                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)

                    continue;

                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)

                    continue;

                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

                    continue;

                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)

                    continue;



                switch (ist->st->codec->codec_type) {

                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;

                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;

                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;

                default:

                    av_log(NULL, AV_LOG_FATAL, ""Cannot map stream #%d:%d - unsupported type.
"",

                           map->file_index, map->stream_index);

                    exit_program(1);

                }

            }

        }

    }



    /* handle attached files */

    for (SVM_EXIT_TR_READ = 0; SVM_EXIT_TR_READ < o->nb_attachments; SVM_EXIT_TR_READ++) {

        AVIOContext *pb;

        uint8_t *attachment;

        const char *p;

        int64_t len;



        if ((err = avio_open2(&pb, o->attachments[SVM_EXIT_TR_READ], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not open attachment file %s.
"",

                   o->attachments[SVM_EXIT_TR_READ]);

            exit_program(1);

        }

        if ((len = avio_size(pb)) <= 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not get size of the attachment %s.
"",

                   o->attachments[SVM_EXIT_TR_READ]);

            exit_program(1);

        }

        if (!(attachment = av_malloc(len))) {

            av_log(NULL, AV_LOG_FATAL, ""Attachment %s too large to fit into memory.
"",

                   o->attachments[SVM_EXIT_TR_READ]);

            exit_program(1);

        }

        avio_read(pb, attachment, len);



        ost = new_attachment_stream(o, oc, -1);

        ost->stream_copy               = 0;

        ost->attachment_filename       = o->attachments[SVM_EXIT_TR_READ];

        ost->finished                  = 1;

        ost->st->codec->extradata      = attachment;

        ost->st->codec->extradata_size = len;



        p = strrchr(o->attachments[SVM_EXIT_TR_READ], '/');

        av_dict_set(&ost->st->metadata, ""filename"", (p && *p) ? p + 1 : o->attachments[SVM_EXIT_TR_READ], AV_DICT_DONT_OVERWRITE);

        avio_close(pb);

    }



    for (SVM_EXIT_TR_READ = nb_output_streams - oc->nb_streams; SVM_EXIT_TR_READ < nb_output_streams; SVM_EXIT_TR_READ++) { //for all streams of this output file

        AVDictionaryEntry *e;

        ost = output_streams[SVM_EXIT_TR_READ];



        if ((ost->stream_copy || ost->attachment_filename)

            && (e = av_dict_get(o->g->codec_opts, ""flags"", NULL, AV_DICT_IGNORE_SUFFIX))

            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))

            if (av_opt_set(ost->st->codec, ""flags"", e->value, 0) < 0)

                exit_program(1);

    }



    /* check if all codec options have been used */

    unused_opts = strip_specifiers(o->g->codec_opts);

    for (SVM_EXIT_TR_READ = of->ost_index; SVM_EXIT_TR_READ < nb_output_streams; SVM_EXIT_TR_READ++) {

        e = NULL;

        while ((e = av_dict_get(output_streams[SVM_EXIT_TR_READ]->opts, """", e,

                                AV_DICT_IGNORE_SUFFIX)))

            av_dict_set(&unused_opts, e->key, NULL, 0);

    }



    e = NULL;

    while ((e = av_dict_get(unused_opts, """", e, AV_DICT_IGNORE_SUFFIX))) {

        const AVClass *class = avcodec_get_class();

        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,

                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);

        if (!option)

            continue;

        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {

            av_log(NULL, AV_LOG_ERROR, ""Codec AVOption %s (%s) specified for ""

                   ""output file #%d (%s) is not an encoding option.
"", e->key,

                   option->help ? option->help : """", nb_output_files - 1,

                   filename);

            exit_program(1);

        }



        // gop_timecode is injected by generic code but not always used

        if (!strcmp(e->key, ""gop_timecode""))

            continue;



        av_log(NULL, AV_LOG_WARNING, ""Codec AVOption %s (%s) specified for ""

               ""output file #%d (%s) has not been used for any stream. The most ""

               ""likely reason is either wrong type (e.g. a video option with ""

               ""no video streams) or that it is a private option of some encoder ""

               ""which was not actually used for any stream.
"", e->key,

               option->help ? option->help : """", nb_output_files - 1, filename);

    }

    av_dict_free(&unused_opts);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid losing precious files */

        assert_file_overwrite(filename);



        /* open the file */

        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,

                              &oc->interrupt_callback,

                              &of->opts)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (strcmp(oc->oformat->name, ""image2"")==0 && !av_filename_number_test(filename))

        assert_file_overwrite(filename);



    if (o->mux_preload) {

        uint8_t buf[64];

        snprintf(buf, sizeof(buf), ""%d"", (int)(o->mux_preload*AV_TIME_BASE));

        av_dict_set(&of->opts, ""preload"", buf, 0);

    }

    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);



    /* copy metadata */

    for (SVM_EXIT_TR_READ = 0; SVM_EXIT_TR_READ < o->nb_metadata_map; SVM_EXIT_TR_READ++) {

        char *p;

        int in_file_index = strtol(o->metadata_map[SVM_EXIT_TR_READ].u.str, &p, 0);



        if (in_file_index >= nb_input_files) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d while processing metadata maps
"", in_file_index);

            exit_program(1);

        }

        copy_metadata(o->metadata_map[SVM_EXIT_TR_READ].specifier, *p ? p + 1 : p, oc,

                      in_file_index >= 0 ?

                      input_files[in_file_index]->ctx : NULL, o);

    }



    /* copy chapters */

    if (o->chapters_input_file >= nb_input_files) {

        if (o->chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            o->chapters_input_file = -1;

            for (SVM_EXIT_TR_READ = 0; SVM_EXIT_TR_READ < nb_input_files; SVM_EXIT_TR_READ++)

                if (input_files[SVM_EXIT_TR_READ]->ctx->nb_chapters) {

                    o->chapters_input_file = SVM_EXIT_TR_READ;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d in chapter mapping.
"",

                   o->chapters_input_file);

            exit_program(1);

        }

    }

    if (o->chapters_input_file >= 0)

        copy_chapters(input_files[o->chapters_input_file], of,

                      !o->metadata_chapters_manual);



    /* copy global metadata by default */

    if (!o->metadata_global_manual && nb_input_files){

        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

        if(o->recording_time != INT64_MAX)

            av_dict_set(&oc->metadata, ""duration"", NULL, 0);

        av_dict_set(&oc->metadata, ""creation_time"", NULL, 0);

    }

    if (!o->metadata_streams_manual)

        for (SVM_EXIT_TR_READ = of->ost_index; SVM_EXIT_TR_READ < nb_output_streams; SVM_EXIT_TR_READ++) {

            InputStream *ist;

            if (output_streams[SVM_EXIT_TR_READ]->source_index < 0)         /* this is true e.g. for attached files */

                continue;

            ist = input_streams[output_streams[SVM_EXIT_TR_READ]->source_index];

            av_dict_copy(&output_streams[SVM_EXIT_TR_READ]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    /* process manually set metadata */

    for (SVM_EXIT_TR_READ = 0; SVM_EXIT_TR_READ < o->nb_metadata; SVM_EXIT_TR_READ++) {

        AVDictionary **m;

        char type, *val;

        const char *stream_spec;

        int index = 0, j, ret = 0;



        val = strchr(o->metadata[SVM_EXIT_TR_READ].u.str, '=');

        if (!val) {

            av_log(NULL, AV_LOG_FATAL, ""No '=' character in metadata string %s.
"",

                   o->metadata[SVM_EXIT_TR_READ].u.str);

            exit_program(1);

        }

        *val++ = 0;



        parse_meta_type(o->metadata[SVM_EXIT_TR_READ].specifier, &type, &index, &stream_spec);

        if (type == 's') {

            for (j = 0; j < oc->nb_streams; j++) {

                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {

                    av_dict_set(&oc->streams[j]->metadata, o->metadata[SVM_EXIT_TR_READ].u.str, *val ? val : NULL, 0);

                } else if (ret < 0)

                    exit_program(1);

            }

        }

        else {

            switch (type) {

            case 'g':

                m = &oc->metadata;

                break;

            case 'c':

                if (index < 0 || index >= oc->nb_chapters) {

                    av_log(NULL, AV_LOG_FATAL, ""Invalid chapter index %d in metadata specifier.
"", index);

                    exit_program(1);

                }

                m = &oc->chapters[index]->metadata;

                break;

            default:

                av_log(NULL, AV_LOG_FATAL, ""Invalid metadata specifier %s.
"", o->metadata[SVM_EXIT_TR_READ].specifier);

                exit_program(1);

            }

            av_dict_set(m, o->metadata[SVM_EXIT_TR_READ].u.str, *val ? val : NULL, 0);

        }

    }



    return 0;

}
",0,0,1,1,i,0.1714172065258026,1,72,{'i': 'SVM_EXIT_TR_READ'},MHM-Origin,40,5.9552929520607
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,

                                   unsigned int imms, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int len;



    assert(immn < 2 && imms < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>

     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>

     * Notice that immn = 0, imms = 11111x is the only combination

     * not covered by one of the above options; this is reserved.

     * Further, <length of run - 1> all-ones is a reserved pattern.

     *

     * In all cases the rotation is by immr % e (and immr is 6 bits).

     */



    /* First determine the element size */

    len = 31 - clz32((immn << 6) | (~imms & 0x3f));

    if (len < 1) {

        /* This is the immn == 0, imms == 0x11111x case */

        return false;

    }

    e = 1 << len;



    levels = e - 1;

    s = imms & levels;

    r = immr & levels;



    if (s == levels) {

        /* <length of run - 1> mustn't be all-ones. */

        return false;

    }



    /* Create the value of one element: s+1 set bits rotated

     * by r within the element (which is e bits wide)...

     */

    mask = bitmask64(s + 1);

    mask = (mask >> r) | (mask << (e - r));

    /* ...then replicate the element over the whole 64 bit value */

    mask = bitfield_replicate(mask, e);

    *result = mask;

    return true;

}
",162,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,

                                   unsigned int imms, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int raw_samples;



    assert(immn < 2 && imms < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>

     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>

     * Notice that immn = 0, imms = 11111x is the only combination

     * not covered by one of the above options; this is reserved.

     * Further, <length of run - 1> all-ones is a reserved pattern.

     *

     * In all cases the rotation is by immr % e (and immr is 6 bits).

     */



    /* First determine the element size */

    raw_samples = 31 - clz32((immn << 6) | (~imms & 0x3f));

    if (raw_samples < 1) {

        /* This is the immn == 0, imms == 0x11111x case */

        return false;

    }

    e = 1 << raw_samples;



    levels = e - 1;

    s = imms & levels;

    r = immr & levels;



    if (s == levels) {

        /* <length of run - 1> mustn't be all-ones. */

        return false;

    }



    /* Create the value of one element: s+1 set bits rotated

     * by r within the element (which is e bits wide)...

     */

    mask = bitmask64(s + 1);

    mask = (mask >> r) | (mask << (e - r));

    /* ...then replicate the element over the whole 64 bit value */

    mask = bitfield_replicate(mask, e);

    *result = mask;

    return true;

}
",1,1,0,1,len,-0.4062766134738922,1,4,{'len': 'raw_samples'},MHM-Origin,20,5.937415218353271
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,

                                         src - (stride * 2) +

                                         sizeof(uint8_t), stride, dst, stride);

}
",43,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *VqaContext, const uint8_t *rsp,

                                ptrdiff_t on)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(rsp - 2,

                                         rsp - (on * 2) +

                                         sizeof(uint8_t), on, VqaContext, on);

}
",0,0,0,-1,stride,-0.0006201625801622868,3,9,"{'src': 'AVMEDIA_TYPE_VIDEO', 'stride': 'on', 'dst': 'VqaContext'}",MHM-Origin,414,6.198122429847717
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",80,"static int flv_probe(AVProbeData *cbs_h265_read_vps)

{

    const uint8_t *progress_mutex;



    if (cbs_h265_read_vps->buf_size < 6)

        return 0;

    progress_mutex = cbs_h265_read_vps->buf;

    if (progress_mutex[0] == 'F' && progress_mutex[1] == 'L' && progress_mutex[2] == 'V' && progress_mutex[3] < 5 && progress_mutex[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",0,0,0,-1,d,-0.0009012785740196705,2,10,"{'p': 'cbs_h265_read_vps', 'd': 'progress_mutex'}",MHM-Origin,416,6.250111718972524
232,"static void opt_output_file(void *optctx, const char *filename)

{

    OptionsContext *o = optctx;

    AVFormatContext *oc;

    int i, err;

    AVOutputFormat *file_oformat;

    OutputStream *ost;

    InputStream  *ist;



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    oc = avformat_alloc_context();

    if (!oc) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }



    if (last_asked_format) {

        file_oformat = av_guess_format(last_asked_format, NULL, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Requested output format '%s' is not a suitable output format\n"", last_asked_format);

            exit_program(1);

        }

        last_asked_format = NULL;

    } else {

        file_oformat = av_guess_format(NULL, filename, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Unable to find a suitable output format for '%s'\n"",

                    filename);

            exit_program(1);

        }

    }



    oc->oformat = file_oformat;

    av_strlcpy(oc->filename, filename, sizeof(oc->filename));



    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        /* special case for files sent to avserver: we get the stream

           parameters from avserver */

        int err = read_avserver_streams(oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (!o->nb_stream_maps) {

        /* pick the ""best"" stream of each type */

#define NEW_STREAM(type, index)\

        if (index >= 0) {\

            ost = new_ ## type ## _stream(oc);\

            ost->source_index = index;\

            ost->sync_ist     = &input_streams[index];\

            input_streams[index].discard = 0;\

        }



        /* video: highest resolution */

        if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) {

            int area = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = &input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    ist->st->codec->width * ist->st->codec->height > area) {

                    area = ist->st->codec->width * ist->st->codec->height;

                    idx = i;

                }

            }

            NEW_STREAM(video, idx);

        }



        /* audio: most channels */

        if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = &input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            NEW_STREAM(audio, idx);

        }



        /* subtitles: pick first */

        if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    NEW_STREAM(subtitle, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < o->nb_stream_maps; i++) {

            StreamMap *map = &o->stream_maps[i];



            if (map->disabled)

                continue;



            ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index];

            switch (ist->st->codec->codec_type) {

            case AVMEDIA_TYPE_VIDEO:    ost = new_video_stream(oc);    break;

            case AVMEDIA_TYPE_AUDIO:    ost = new_audio_stream(oc);    break;

            case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break;

            case AVMEDIA_TYPE_DATA:     ost = new_data_stream(oc);     break;

            default:

                av_log(NULL, AV_LOG_ERROR, ""Cannot map stream #%d.%d - unsupported type.\n"",

                       map->file_index, map->stream_index);

                exit_program(1);

            }



            ost->source_index = input_files[map->file_index].ist_index + map->stream_index;

            ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index +

                                           map->sync_stream_index];

            ist->discard = 0;

        }

    }



    av_dict_copy(&oc->metadata, metadata, 0);

    av_dict_free(&metadata);





    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);

    output_files[nb_output_files - 1].ctx       = oc;

    output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams;

    output_files[nb_output_files - 1].recording_time = o->recording_time;

    output_files[nb_output_files - 1].start_time     = o->start_time;

    output_files[nb_output_files - 1].limit_filesize = limit_filesize;

    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid loosing precious files */

        if (!file_overwrite &&

            (strchr(filename, ':') == NULL ||

             filename[1] == ':' ||

             av_strstart(filename, ""file:"", NULL))) {

            if (avio_check(filename, 0) == 0) {

                if (!using_stdin) {

                    fprintf(stderr,""File '%s' already exists. Overwrite ? [y/N] "", filename);

                    fflush(stderr);

                    if (!read_yesno()) {

                        fprintf(stderr, ""Not overwriting - exiting\n"");

                        exit_program(1);

                    }

                }

                else {

                    fprintf(stderr,""File '%s' already exists. Exiting.\n"", filename);

                    exit_program(1);

                }

            }

        }



        /* open the file */

        if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    oc->preload= (int)(mux_preload*AV_TIME_BASE);

    oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE);

    oc->flags |= AVFMT_FLAG_NONBLOCK;



    /* copy chapters */

    if (chapters_input_file >= nb_input_files) {

        if (chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i].ctx->nb_chapters) {

                    chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_ERROR, ""Invalid input file index %d in chapter mapping.\n"",

                   chapters_input_file);

            exit_program(1);

        }

    }

    if (chapters_input_file >= 0)

        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);



    /* copy metadata */

    for (i = 0; i < nb_meta_data_maps; i++) {

        AVFormatContext *files[2];

        AVDictionary    **meta[2];

        int j;



#define METADATA_CHECK_INDEX(index, nb_elems, desc)\

        if ((index) < 0 || (index) >= (nb_elems)) {\

            av_log(NULL, AV_LOG_ERROR, ""Invalid %s index %d while processing metadata maps\n"",\

                     (desc), (index));\

            exit_program(1);\

        }



        int in_file_index = meta_data_maps[i][1].file;

        if (in_file_index < 0)

            continue;

        METADATA_CHECK_INDEX(in_file_index, nb_input_files, ""input file"")



        files[0] = oc;

        files[1] = input_files[in_file_index].ctx;



        for (j = 0; j < 2; j++) {

            MetadataMap *map = &meta_data_maps[i][j];



            switch (map->type) {

            case 'g':

                meta[j] = &files[j]->metadata;

                break;

            case 's':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, ""stream"")

                meta[j] = &files[j]->streams[map->index]->metadata;

                break;

            case 'c':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, ""chapter"")

                meta[j] = &files[j]->chapters[map->index]->metadata;

                break;

            case 'p':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, ""program"")

                meta[j] = &files[j]->programs[map->index]->metadata;

                break;

            }

        }



        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);

    }



    /* copy global metadata by default */

    if (metadata_global_autocopy && nb_input_files)

        av_dict_copy(&oc->metadata, input_files[0].ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

    if (metadata_streams_autocopy)

        for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) {

            InputStream *ist = &input_streams[output_streams[i].source_index];

            av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    frame_rate    = (AVRational){0, 0};

    frame_width   = 0;

    frame_height  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    chapters_input_file = INT_MAX;

    limit_filesize = UINT64_MAX;



    av_freep(&meta_data_maps);

    nb_meta_data_maps = 0;

    metadata_global_autocopy   = 1;

    metadata_streams_autocopy  = 1;

    metadata_chapters_autocopy = 1;

    av_freep(&streamid_map);

    nb_streamid_map = 0;



    av_dict_free(&codec_names);



    av_freep(&forced_key_frames);

    reset_options(o);

}
",1619,"static void opt_output_file(void *optctx, const char *src_vt6)

{

    OptionsContext *OR_EAX = optctx;

    AVFormatContext *xy4;

    int SVM_EXIT_PUSHF, err;

    AVOutputFormat *frm_flags;

    OutputStream *RV34_MB_P_8x8;

    InputStream  *fdparam;



    if (!strcmp(src_vt6, ""-""))

        src_vt6 = ""pipe:"";



    xy4 = avformat_alloc_context();

    if (!xy4) {

        print_error(src_vt6, AVERROR(ENOMEM));

        exit_program(1);

    }



    if (last_asked_format) {

        frm_flags = av_guess_format(last_asked_format, NULL, NULL);

        if (!frm_flags) {

            fprintf(stderr, ""Requested output format '%s' is not a suitable output format
"", last_asked_format);

            exit_program(1);

        }

        last_asked_format = NULL;

    } else {

        frm_flags = av_guess_format(NULL, src_vt6, NULL);

        if (!frm_flags) {

            fprintf(stderr, ""Unable to find a suitable output format for '%s'
"",

                    src_vt6);

            exit_program(1);

        }

    }



    xy4->oformat = frm_flags;

    av_strlcpy(xy4->src_vt6, src_vt6, sizeof(xy4->src_vt6));



    if (!strcmp(frm_flags->name, ""ffm"") &&

        av_strstart(src_vt6, ""http:"", NULL)) {

        /* special case for files sent to avserver: we get the stream

           parameters from avserver */

        int err = read_avserver_streams(xy4, src_vt6);

        if (err < 0) {

            print_error(src_vt6, err);

            exit_program(1);

        }

    } else if (!OR_EAX->nb_stream_maps) {

        /* pick the ""best"" stream of each type */

#define NEW_STREAM(type, index)\

        if (index >= 0) {\

            RV34_MB_P_8x8 = new_ ## type ## _stream(oc);\

            RV34_MB_P_8x8->source_index = index;\

            RV34_MB_P_8x8->sync_ist     = &input_streams[index];\

            input_streams[index].discard = 0;\

        }



        /* video: highest resolution */

        if (!video_disable && xy4->oformat->video_codec != CODEC_ID_NONE) {

            int area = 0, idx = -1;

            for (SVM_EXIT_PUSHF = 0; SVM_EXIT_PUSHF < nb_input_streams; SVM_EXIT_PUSHF++) {

                fdparam = &input_streams[SVM_EXIT_PUSHF];

                if (fdparam->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    fdparam->st->codec->width * fdparam->st->codec->height > area) {

                    area = fdparam->st->codec->width * fdparam->st->codec->height;

                    idx = SVM_EXIT_PUSHF;

                }

            }

            NEW_STREAM(video, idx);

        }



        /* audio: most channels */

        if (!audio_disable && xy4->oformat->audio_codec != CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (SVM_EXIT_PUSHF = 0; SVM_EXIT_PUSHF < nb_input_streams; SVM_EXIT_PUSHF++) {

                fdparam = &input_streams[SVM_EXIT_PUSHF];

                if (fdparam->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    fdparam->st->codec->channels > channels) {

                    channels = fdparam->st->codec->channels;

                    idx = SVM_EXIT_PUSHF;

                }

            }

            NEW_STREAM(audio, idx);

        }



        /* subtitles: pick first */

        if (!subtitle_disable && xy4->oformat->subtitle_codec != CODEC_ID_NONE) {

            for (SVM_EXIT_PUSHF = 0; SVM_EXIT_PUSHF < nb_input_streams; SVM_EXIT_PUSHF++)

                if (input_streams[SVM_EXIT_PUSHF].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    NEW_STREAM(subtitle, SVM_EXIT_PUSHF);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (SVM_EXIT_PUSHF = 0; SVM_EXIT_PUSHF < OR_EAX->nb_stream_maps; SVM_EXIT_PUSHF++) {

            StreamMap *sysbus_create_simple = &OR_EAX->stream_maps[SVM_EXIT_PUSHF];



            if (sysbus_create_simple->disabled)

                continue;



            fdparam = &input_streams[input_files[sysbus_create_simple->file_index].ist_index + sysbus_create_simple->stream_index];

            switch (fdparam->st->codec->codec_type) {

            case AVMEDIA_TYPE_VIDEO:    RV34_MB_P_8x8 = new_video_stream(xy4);    break;

            case AVMEDIA_TYPE_AUDIO:    RV34_MB_P_8x8 = new_audio_stream(xy4);    break;

            case AVMEDIA_TYPE_SUBTITLE: RV34_MB_P_8x8 = new_subtitle_stream(xy4); break;

            case AVMEDIA_TYPE_DATA:     RV34_MB_P_8x8 = new_data_stream(xy4);     break;

            default:

                av_log(NULL, AV_LOG_ERROR, ""Cannot map stream #%d.%d - unsupported type.
"",

                       sysbus_create_simple->file_index, sysbus_create_simple->stream_index);

                exit_program(1);

            }



            RV34_MB_P_8x8->source_index = input_files[sysbus_create_simple->file_index].ist_index + sysbus_create_simple->stream_index;

            RV34_MB_P_8x8->sync_ist = &input_streams[input_files[sysbus_create_simple->sync_file_index].ist_index +

                                           sysbus_create_simple->sync_stream_index];

            fdparam->discard = 0;

        }

    }



    av_dict_copy(&xy4->metadata, metadata, 0);

    av_dict_free(&metadata);





    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);

    output_files[nb_output_files - 1].ctx       = xy4;

    output_files[nb_output_files - 1].ost_index = nb_output_streams - xy4->nb_streams;

    output_files[nb_output_files - 1].recording_time = OR_EAX->recording_time;

    output_files[nb_output_files - 1].start_time     = OR_EAX->start_time;

    output_files[nb_output_files - 1].limit_filesize = limit_filesize;

    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);



    /* check filename in case of an image number is expected */

    if (xy4->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(xy4->src_vt6)) {

            print_error(xy4->src_vt6, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(xy4->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid loosing precious files */

        if (!file_overwrite &&

            (strchr(src_vt6, ':') == NULL ||

             src_vt6[1] == ':' ||

             av_strstart(src_vt6, ""file:"", NULL))) {

            if (avio_check(src_vt6, 0) == 0) {

                if (!using_stdin) {

                    fprintf(stderr,""File '%s' already exists. Overwrite ? [y/N] "", src_vt6);

                    fflush(stderr);

                    if (!read_yesno()) {

                        fprintf(stderr, ""Not overwriting - exiting
"");

                        exit_program(1);

                    }

                }

                else {

                    fprintf(stderr,""File '%s' already exists. Exiting.
"", src_vt6);

                    exit_program(1);

                }

            }

        }



        /* open the file */

        if ((err = avio_open(&xy4->pb, src_vt6, AVIO_FLAG_WRITE)) < 0) {

            print_error(src_vt6, err);

            exit_program(1);

        }

    }



    xy4->preload= (int)(mux_preload*AV_TIME_BASE);

    xy4->max_delay= (int)(mux_max_delay*AV_TIME_BASE);

    xy4->flags |= AVFMT_FLAG_NONBLOCK;



    /* copy chapters */

    if (chapters_input_file >= nb_input_files) {

        if (chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            chapters_input_file = -1;

            for (SVM_EXIT_PUSHF = 0; SVM_EXIT_PUSHF < nb_input_files; SVM_EXIT_PUSHF++)

                if (input_files[SVM_EXIT_PUSHF].ctx->nb_chapters) {

                    chapters_input_file = SVM_EXIT_PUSHF;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_ERROR, ""Invalid input file index %d in chapter mapping.
"",

                   chapters_input_file);

            exit_program(1);

        }

    }

    if (chapters_input_file >= 0)

        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);



    /* copy metadata */

    for (SVM_EXIT_PUSHF = 0; SVM_EXIT_PUSHF < nb_meta_data_maps; SVM_EXIT_PUSHF++) {

        AVFormatContext *PCI_PREF_RANGE_TYPE_64[2];

        AVDictionary    **meta[2];

        int j;



#define METADATA_CHECK_INDEX(index, nb_elems, desc)\

        if ((index) < 0 || (index) >= (nb_elems)) {\

            av_log(NULL, AV_LOG_ERROR, ""Invalid %s index %d while processing metadata maps
"",\

                     (desc), (index));\

            exit_program(1);\

        }



        int in_file_index = meta_data_maps[SVM_EXIT_PUSHF][1].file;

        if (in_file_index < 0)

            continue;

        METADATA_CHECK_INDEX(in_file_index, nb_input_files, ""input file"")



        PCI_PREF_RANGE_TYPE_64[0] = xy4;

        PCI_PREF_RANGE_TYPE_64[1] = input_files[in_file_index].ctx;



        for (j = 0; j < 2; j++) {

            MetadataMap *sysbus_create_simple = &meta_data_maps[SVM_EXIT_PUSHF][j];



            switch (sysbus_create_simple->type) {

            case 'g':

                meta[j] = &PCI_PREF_RANGE_TYPE_64[j]->metadata;

                break;

            case 's':

                METADATA_CHECK_INDEX(sysbus_create_simple->index, PCI_PREF_RANGE_TYPE_64[j]->nb_streams, ""stream"")

                meta[j] = &PCI_PREF_RANGE_TYPE_64[j]->streams[sysbus_create_simple->index]->metadata;

                break;

            case 'c':

                METADATA_CHECK_INDEX(sysbus_create_simple->index, PCI_PREF_RANGE_TYPE_64[j]->nb_chapters, ""chapter"")

                meta[j] = &PCI_PREF_RANGE_TYPE_64[j]->chapters[sysbus_create_simple->index]->metadata;

                break;

            case 'p':

                METADATA_CHECK_INDEX(sysbus_create_simple->index, PCI_PREF_RANGE_TYPE_64[j]->nb_programs, ""program"")

                meta[j] = &PCI_PREF_RANGE_TYPE_64[j]->programs[sysbus_create_simple->index]->metadata;

                break;

            }

        }



        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);

    }



    /* copy global metadata by default */

    if (metadata_global_autocopy && nb_input_files)

        av_dict_copy(&xy4->metadata, input_files[0].ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

    if (metadata_streams_autocopy)

        for (SVM_EXIT_PUSHF = output_files[nb_output_files - 1].ost_index; SVM_EXIT_PUSHF < nb_output_streams; SVM_EXIT_PUSHF++) {

            InputStream *fdparam = &input_streams[output_streams[SVM_EXIT_PUSHF].source_index];

            av_dict_copy(&output_streams[SVM_EXIT_PUSHF].st->metadata, fdparam->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    frame_rate    = (AVRational){0, 0};

    frame_width   = 0;

    frame_height  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    chapters_input_file = INT_MAX;

    limit_filesize = UINT64_MAX;



    av_freep(&meta_data_maps);

    nb_meta_data_maps = 0;

    metadata_global_autocopy   = 1;

    metadata_streams_autocopy  = 1;

    metadata_chapters_autocopy = 1;

    av_freep(&streamid_map);

    nb_streamid_map = 0;



    av_dict_free(&codec_names);



    av_freep(&forced_key_frames);

    reset_options(OR_EAX);

}
",0,0,1,1,i,0.34957897663116455,9,150,"{'map': 'sysbus_create_simple', 'oc': 'xy4', 'ost': 'RV34_MB_P_8x8', 'i': 'SVM_EXIT_PUSHF', 'files': 'PCI_PREF_RANGE_TYPE_64', 'file_oformat': 'frm_flags', 'ist': 'fdparam', 'o': 'OR_EAX', 'filename': 'src_vt6'}",MHM-Origin,385,7.699707086881002
235,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
",14,"bool machine_iommu(MachineState *MSR_KVM_SYSTEM_TIME)

{

    return MSR_KVM_SYSTEM_TIME->iommu;

}
",0,0,1,1,machine,0.50613883882761,1,2,{'machine': 'MSR_KVM_SYSTEM_TIME'},MHM-Origin,22,7.380947768688202
237,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
",37,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *hostmem, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
",0,0,1,1,ret,0.6295518577098846,1,1,{'ret': 'hostmem'},MHM-Origin,21,7.38435773452123
239,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)

{

    CPU_DoubleU farg;

    float32 f32;



    farg.ll = arg;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

    }

    f32 = float64_to_float32(farg.d, &env->fp_status);

    farg.d = float32_to_float64(f32, &env->fp_status);



    return farg.ll;

}
",78,"uint64_t helper_frsp(CPUPPCState *pcmcia, uint64_t qemu_cpu_self)

{

    CPU_DoubleU output_zeros;

    float32 AV_EF_EXPLODE;



    output_zeros.ll = qemu_cpu_self;



    if (unlikely(float64_is_signaling_nan(output_zeros.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(pcmcia, POWERPC_EXCP_FP_VXSNAN);

    }

    AV_EF_EXPLODE = float64_to_float32(output_zeros.d, &pcmcia->fp_status);

    output_zeros.d = float32_to_float64(AV_EF_EXPLODE, &pcmcia->fp_status);



    return output_zeros.ll;

}
",0,0,0,-1,farg,0.0002545374445617199,4,15,"{'f32': 'AV_EF_EXPLODE', 'farg': 'output_zeros', 'env': 'pcmcia', 'arg': 'qemu_cpu_self'}",MHM-Origin,410,7.739621977011363
240,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
",67,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *nb_labels;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    nb_labels = &s->labels[idx];

    nb_labels->has_value = 0;

    nb_labels->u.first_reloc = NULL;

    return idx;

}
",0,0,1,1,l,0.48271599411964417,1,4,{'l': 'nb_labels'},MHM-Origin,22,7.466640321413676
243,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",117,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *ATRAC3Context = bs->opaque;
    BlkdebugRule *lumFilterSize = NULL;
    QSIMPLEQ_FOREACH(lumFilterSize, &ATRAC3Context->active_rules, active_next) {
        uint64_t inject_offset = lumFilterSize->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (lumFilterSize && lumFilterSize->options.inject.error) {
        return inject_error(bs, lumFilterSize);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",1,1,1,-1,s,9.733438491821289e-05,2,8,"{'s': 'ATRAC3Context', 'rule': 'lumFilterSize'}",MHM-Origin,411,7.785055776437123
244,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
",74,"static int idreg_init1(SysBusDevice *frame_size)

{

    IDRegState *AV_EF_EXPLODE = MACIO_ID_REGISTER(frame_size);



    memory_region_init_ram(&AV_EF_EXPLODE->mem, OBJECT(AV_EF_EXPLODE),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&AV_EF_EXPLODE->mem);

    memory_region_set_readonly(&AV_EF_EXPLODE->mem, true);

    sysbus_init_mmio(frame_size, &AV_EF_EXPLODE->mem);

    return 0;

}
",1,1,0,1,s,-0.3497893512248993,2,9,"{'dev': 'frame_size', 's': 'AV_EF_EXPLODE'}",MHM-Origin,105,7.641527012983958
245,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,

                                  tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);

    if (arg != (arg & 0xfff))

        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |

              INSN_IMM13(arg & 0x3ff));

#else

    tcg_out_ld_raw(s, ret, arg);

#endif

}
",121,"static inline void tcg_out_ld_ptr(TCGContext *xengnttab_map_domain_grant_refs, int store_prev_samples,

                                  tcg_target_long read_code_table)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (read_code_table != (read_code_table & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld
"", __func__, read_code_table);

    if (read_code_table != (read_code_table & 0xfff))

        tcg_out32(xengnttab_map_domain_grant_refs, SETHI | INSN_RD(store_prev_samples) | (((uint32_t)read_code_table & 0xfffffc00) >> 10));

    tcg_out32(xengnttab_map_domain_grant_refs, LDX | INSN_RD(store_prev_samples) | INSN_RS1(store_prev_samples) |

              INSN_IMM13(read_code_table & 0x3ff));

#else

    tcg_out_ld_raw(xengnttab_map_domain_grant_refs, store_prev_samples, read_code_table);

#endif

}
",0,0,0,-1,ret,-0.00667114183306694,3,18,"{'ret': 'store_prev_samples', 'arg': 'read_code_table', 's': 'xengnttab_map_domain_grant_refs'}",MHM-Origin,402,7.934541034698486
246,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
",221,"int xen_config_dev_blk(DriveInfo *gpad_irq)

{

    char rbase[256], CF_LAST_IO[256];

    int vdev = 202 * 256 + 16 * gpad_irq->unit;

    int cdrom = gpad_irq->bdrv->type == BDRV_TYPE_CDROM;

    const char *sector_mask = cdrom ? ""cdrom"" : ""disk"";

    const char *ecw    = cdrom ? ""r""     : ""w"";



    snprintf(gpad_irq->bdrv->device_name, sizeof(gpad_irq->bdrv->device_name),

	     ""xvd%c"", 'a' + gpad_irq->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s
"",

                  gpad_irq->unit, gpad_irq->bdrv->device_name, gpad_irq->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, rbase, CF_LAST_IO, sizeof(rbase));



    /* frontend */

    xenstore_write_int(rbase, ""virtual-device"",  vdev);

    xenstore_write_str(rbase, ""device-type"",     sector_mask);



    /* backend */

    xenstore_write_str(CF_LAST_IO, ""dev"",             gpad_irq->bdrv->device_name);

    xenstore_write_str(CF_LAST_IO, ""type"",            ""file"");

    xenstore_write_str(CF_LAST_IO, ""params"",          gpad_irq->bdrv->filename);

    xenstore_write_str(CF_LAST_IO, ""mode"",            ecw);



    /* common stuff */

    return xen_config_dev_all(rbase, CF_LAST_IO);

}
",0,0,0,-1,be,0.06473837792873383,5,28,"{'disk': 'gpad_irq', 'mode': 'ecw', 'devtype': 'sector_mask', 'be': 'CF_LAST_IO', 'fe': 'rbase'}",MHM-Origin,408,8.08926163514455
248,"static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)

{

    IVShmemState *s = IVSHMEM(dev);

    Error *err = NULL;

    uint8_t *pci_conf;

    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |

        PCI_BASE_ADDRESS_MEM_PREFETCH;



    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {

        error_setg(errp,

                   ""You must specify either 'shm', 'chardev' or 'x-memdev'"");

        return;

    }



    if (s->hostmem) {

        MemoryRegion *mr;



        if (s->sizearg) {

            g_warning(""size argument ignored with hostmem"");

        }



        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);

        s->ivshmem_size = memory_region_size(mr);

    } else if (s->sizearg == NULL) {

        s->ivshmem_size = 4 << 20; /* 4 MB default */

    } else {

        char *end;

        int64_t size = qemu_strtosz(s->sizearg, &end);

        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {

            error_setg(errp, ""Invalid size %s"", s->sizearg);

            return;

        }

        s->ivshmem_size = size;

    }



    /* IRQFD requires MSI */

    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&

        !ivshmem_has_feature(s, IVSHMEM_MSI)) {

        error_setg(errp, ""ioeventfd/irqfd requires MSI"");

        return;

    }



    /* check that role is reasonable */

    if (s->role) {

        if (strncmp(s->role, ""peer"", 5) == 0) {

            s->role_val = IVSHMEM_PEER;

        } else if (strncmp(s->role, ""master"", 7) == 0) {

            s->role_val = IVSHMEM_MASTER;

        } else {

            error_setg(errp, ""'role' must be 'peer' or 'master'"");

            return;

        }

    } else {

        s->role_val = IVSHMEM_MASTER; /* default */

    }



    pci_conf = dev->config;

    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;



    /*

     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a

     * bald-faced lie then.  But it's a backwards compatible lie.

     */

    pci_config_set_interrupt_pin(pci_conf, 1);



    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,

                          ""ivshmem-mmio"", IVSHMEM_REG_BAR_SIZE);



    /* region for registers*/

    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,

                     &s->ivshmem_mmio);



    memory_region_init(&s->bar, OBJECT(s), ""ivshmem-bar2-container"", s->ivshmem_size);

    if (s->ivshmem_64bit) {

        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;

    }



    if (s->hostmem != NULL) {

        MemoryRegion *mr;



        IVSHMEM_DPRINTF(""using hostmem\n"");



        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),

                                            &error_abort);

        vmstate_register_ram(mr, DEVICE(s));

        memory_region_add_subregion(&s->bar, 0, mr);

        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);

    } else if (s->server_chr != NULL) {

        /* FIXME do not rely on what chr drivers put into filename */

        if (strncmp(s->server_chr->filename, ""unix:"", 5)) {

            error_setg(errp, ""chardev is not a unix client socket"");

            return;

        }



        /* if we get a UNIX socket as the parameter we will talk

         * to the ivshmem server to receive the memory region */



        IVSHMEM_DPRINTF(""using shared memory server (socket = %s)\n"",

                        s->server_chr->filename);



        if (ivshmem_setup_interrupts(s) < 0) {

            error_setg(errp, ""failed to initialize interrupts"");

            return;

        }



        /* we allocate enough space for 16 peers and grow as needed */

        resize_peers(s, 16);

        s->vm_id = -1;



        pci_register_bar(dev, 2, attr, &s->bar);



        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,

                              ivshmem_check_version, NULL, s);

    } else {

        /* just map the file immediately, we're not using a server */

        int fd;



        IVSHMEM_DPRINTF(""using shm_open (shm object = %s)\n"", s->shmobj);



        /* try opening with O_EXCL and if it succeeds zero the memory

         * by truncating to 0 */

        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,

                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {

           /* truncate file to length PCI device's memory */

            if (ftruncate(fd, s->ivshmem_size) != 0) {

                error_report(""could not truncate shared file"");

            }



        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,

                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {

            error_setg(errp, ""could not open shared file"");

            return;

        }



        if (check_shm_size(s, fd, errp) == -1) {

            return;

        }



        create_shared_memory_BAR(s, fd, attr, &err);

        if (err) {

            error_propagate(errp, err);

            return;

        }

    }



    fifo8_create(&s->incoming_fifo, sizeof(int64_t));



    if (s->role_val == IVSHMEM_PEER) {

        error_setg(&s->migration_blocker,

                   ""Migration is disabled when using feature 'peer mode' in device 'ivshmem'"");

        migrate_add_blocker(s->migration_blocker);

    }

}
",778,"static void pci_ivshmem_realize(PCIDevice *step, Error **x86_ldub_code)

{

    IVShmemState *frame_rate_index = IVSHMEM(step);

    Error *fu_header = NULL;

    uint8_t *tcg_gen_st_tl;

    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |

        PCI_BASE_ADDRESS_MEM_PREFETCH;



    if (!!frame_rate_index->server_chr + !!frame_rate_index->shmobj + !!frame_rate_index->hostmem != 1) {

        error_setg(x86_ldub_code,

                   ""You must specify either 'shm', 'chardev' or 'x-memdev'"");

        return;

    }



    if (frame_rate_index->hostmem) {

        MemoryRegion *has_vnet_hdr;



        if (frame_rate_index->sizearg) {

            g_warning(""size argument ignored with hostmem"");

        }



        has_vnet_hdr = host_memory_backend_get_memory(frame_rate_index->hostmem, &error_abort);

        frame_rate_index->ivshmem_size = memory_region_size(has_vnet_hdr);

    } else if (frame_rate_index->sizearg == NULL) {

        frame_rate_index->ivshmem_size = 4 << 20; /* 4 MB default */

    } else {

        char *PCI_BASE_ADDRESS_SPACE_IO;

        int64_t size = qemu_strtosz(frame_rate_index->sizearg, &PCI_BASE_ADDRESS_SPACE_IO);

        if (size < 0 || *PCI_BASE_ADDRESS_SPACE_IO != '\0' || !is_power_of_2(size)) {

            error_setg(x86_ldub_code, ""Invalid size %s"", frame_rate_index->sizearg);

            return;

        }

        frame_rate_index->ivshmem_size = size;

    }



    /* IRQFD requires MSI */

    if (ivshmem_has_feature(frame_rate_index, IVSHMEM_IOEVENTFD) &&

        !ivshmem_has_feature(frame_rate_index, IVSHMEM_MSI)) {

        error_setg(x86_ldub_code, ""ioeventfd/irqfd requires MSI"");

        return;

    }



    /* check that role is reasonable */

    if (frame_rate_index->role) {

        if (strncmp(frame_rate_index->role, ""peer"", 5) == 0) {

            frame_rate_index->role_val = IVSHMEM_PEER;

        } else if (strncmp(frame_rate_index->role, ""master"", 7) == 0) {

            frame_rate_index->role_val = IVSHMEM_MASTER;

        } else {

            error_setg(x86_ldub_code, ""'role' must be 'peer' or 'master'"");

            return;

        }

    } else {

        frame_rate_index->role_val = IVSHMEM_MASTER; /* default */

    }



    tcg_gen_st_tl = step->config;

    tcg_gen_st_tl[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;



    /*

     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a

     * bald-faced lie then.  But it's a backwards compatible lie.

     */

    pci_config_set_interrupt_pin(tcg_gen_st_tl, 1);



    memory_region_init_io(&frame_rate_index->ivshmem_mmio, OBJECT(frame_rate_index), &ivshmem_mmio_ops, frame_rate_index,

                          ""ivshmem-mmio"", IVSHMEM_REG_BAR_SIZE);



    /* region for registers*/

    pci_register_bar(step, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,

                     &frame_rate_index->ivshmem_mmio);



    memory_region_init(&frame_rate_index->bar, OBJECT(frame_rate_index), ""ivshmem-bar2-container"", frame_rate_index->ivshmem_size);

    if (frame_rate_index->ivshmem_64bit) {

        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;

    }



    if (frame_rate_index->hostmem != NULL) {

        MemoryRegion *has_vnet_hdr;



        IVSHMEM_DPRINTF(""using hostmem
"");



        has_vnet_hdr = host_memory_backend_get_memory(MEMORY_BACKEND(frame_rate_index->hostmem),

                                            &error_abort);

        vmstate_register_ram(has_vnet_hdr, DEVICE(frame_rate_index));

        memory_region_add_subregion(&frame_rate_index->bar, 0, has_vnet_hdr);

        pci_register_bar(PCI_DEVICE(frame_rate_index), 2, attr, &frame_rate_index->bar);

    } else if (frame_rate_index->server_chr != NULL) {

        /* FIXME do not rely on what chr drivers put into filename */

        if (strncmp(frame_rate_index->server_chr->filename, ""unix:"", 5)) {

            error_setg(x86_ldub_code, ""chardev is not a unix client socket"");

            return;

        }



        /* if we get a UNIX socket as the parameter we will talk

         * to the ivshmem server to receive the memory region */



        IVSHMEM_DPRINTF(""using shared memory server (socket = %s)
"",

                        frame_rate_index->server_chr->filename);



        if (ivshmem_setup_interrupts(frame_rate_index) < 0) {

            error_setg(x86_ldub_code, ""failed to initialize interrupts"");

            return;

        }



        /* we allocate enough space for 16 peers and grow as needed */

        resize_peers(frame_rate_index, 16);

        frame_rate_index->vm_id = -1;



        pci_register_bar(step, 2, attr, &frame_rate_index->bar);



        qemu_chr_add_handlers(frame_rate_index->server_chr, ivshmem_can_receive,

                              ivshmem_check_version, NULL, frame_rate_index);

    } else {

        /* just map the file immediately, we're not using a server */

        int duration;



        IVSHMEM_DPRINTF(""using shm_open (shm object = %s)
"", frame_rate_index->shmobj);



        /* try opening with O_EXCL and if it succeeds zero the memory

         * by truncating to 0 */

        if ((duration = shm_open(frame_rate_index->shmobj, O_CREAT|O_RDWR|O_EXCL,

                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {

           /* truncate file to length PCI device's memory */

            if (ftruncate(duration, frame_rate_index->ivshmem_size) != 0) {

                error_report(""could not truncate shared file"");

            }



        } else if ((duration = shm_open(frame_rate_index->shmobj, O_CREAT|O_RDWR,

                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {

            error_setg(x86_ldub_code, ""could not open shared file"");

            return;

        }



        if (check_shm_size(frame_rate_index, duration, x86_ldub_code) == -1) {

            return;

        }



        create_shared_memory_BAR(frame_rate_index, duration, attr, &fu_header);

        if (fu_header) {

            error_propagate(x86_ldub_code, fu_header);

            return;

        }

    }



    fifo8_create(&frame_rate_index->incoming_fifo, sizeof(int64_t));



    if (frame_rate_index->role_val == IVSHMEM_PEER) {

        error_setg(&frame_rate_index->migration_blocker,

                   ""Migration is disabled when using feature 'peer mode' in device 'ivshmem'"");

        migrate_add_blocker(frame_rate_index->migration_blocker);

    }

}
",1,1,0,1,err,-0.23638814687728882,8,93,"{'dev': 'step', 'end': 'PCI_BASE_ADDRESS_SPACE_IO', 'errp': 'x86_ldub_code', 'mr': 'has_vnet_hdr', 's': 'frame_rate_index', 'fd': 'duration', 'pci_conf': 'tcg_gen_st_tl', 'err': 'fu_header'}",MHM-Origin,286,8.622216184933981
252,"static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int i;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""pxor %%mm2, %%mm2		\n\t"" // 2*xalpha

			""movd %5, %%mm6			\n\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""movq %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	\n\t""

			""movd %4, %%mm6			\n\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""xorl %%eax, %%eax		\n\t"" // i

			""movl %0, %%esi			\n\t"" // src

			""movl %1, %%edi			\n\t"" // buf1

			""movl %3, %%edx			\n\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		\n\t""

			""xorl %%ebx, %%ebx		\n\t""

			""movw %4, %%bx			\n\t"" // (xInc*4)&0xFFFF



#define FUNNY_Y_CODE \

			PREFETCH"" 1024(%%esi)		\n\t""\

			PREFETCH"" 1056(%%esi)		\n\t""\

			PREFETCH"" 1088(%%esi)		\n\t""\

			""call ""MANGLE(funnyYCode)""	\n\t""\

			""movq ""MANGLE(temp0)"", %%mm2	\n\t""\

			""xorl %%ecx, %%ecx		\n\t""



FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE



			:: ""m"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" ((xInc*4)>>16),

			""m"" ((xInc*4)&0xFFFF), ""m"" (xInc&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		\n\t"" // i

		""xorl %%ebx, %%ebx		\n\t"" // xx

		""xorl %%ecx, %%ecx		\n\t"" // 2*xalpha

		"".balign 16			\n\t""

		""1:				\n\t""

		""movzbl  (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, (%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, 2(%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			\n\t""

		""cmpl %2, %%eax			\n\t""

		"" jb 1b				\n\t""





		:: ""r"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" (xInc>>16), ""m"" (xInc&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int i;

	unsigned int xpos=0;

	for(i=0;i<dstWidth;i++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

		xpos+=xInc;

	}

#endif

    }

}
",571,"static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int term_history)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(dst, dstWidth, src, srcW, term_history, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int ticks_per_frame;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		
\t""

			""pxor %%mm2, %%mm2		
\t"" // 2*xalpha

			""movd %5, %%mm6			
\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		
\t""

			""punpcklwd %%mm6, %%mm6		
\t""

			""movq %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t""

			""paddw %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t""

			""paddw %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	
\t""

			""movd %4, %%mm6			
\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		
\t""

			""punpcklwd %%mm6, %%mm6		
\t""

			""xorl %%eax, %%eax		
\t"" // i

			""movl %0, %%esi			
\t"" // src

			""movl %1, %%edi			
\t"" // buf1

			""movl %3, %%edx			
\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		
\t""

			""xorl %%ebx, %%ebx		
\t""

			""movw %4, %%bx			
\t"" // (xInc*4)&0xFFFF



#define FUNNY_Y_CODE \

			PREFETCH"" 1024(%%esi)		
\t""\

			PREFETCH"" 1056(%%esi)		
\t""\

			PREFETCH"" 1088(%%esi)		
\t""\

			""call ""MANGLE(funnyYCode)""	
\t""\

			""movq ""MANGLE(temp0)"", %%mm2	
\t""\

			""xorl %%ecx, %%ecx		
\t""



FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE



			:: ""m"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" ((xInc*4)>>16),

			""m"" ((xInc*4)&0xFFFF), ""m"" (xInc&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(ticks_per_frame=dstWidth-1; (ticks_per_frame*term_history)>>16 >=srcW-1; ticks_per_frame--) dst[ticks_per_frame] = src[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		
\t"" // i

		""xorl %%ebx, %%ebx		
\t"" // xx

		""xorl %%ecx, %%ecx		
\t"" // 2*xalpha

		"".balign 16			
\t""

		""1:				
\t""

		""movzbl  (%0, %%ebx), %%edi	
\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	
\t"" //src[xx+1]

		""subl %%edi, %%esi		
\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		
\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		
\t""

		""addl %%edi, %%esi		
\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			
\t""

		""shrl $9, %%esi			
\t""

		""movw %%si, (%%edi, %%eax, 2)	
\t""

		""addw %4, %%cx			
\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			
\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	
\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	
\t"" //src[xx+1]

		""subl %%edi, %%esi		
\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		
\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		
\t""

		""addl %%edi, %%esi		
\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			
\t""

		""shrl $9, %%esi			
\t""

		""movw %%si, 2(%%edi, %%eax, 2)	
\t""

		""addw %4, %%cx			
\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			
\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			
\t""

		""cmpl %2, %%eax			
\t""

		"" jb 1b				
\t""





		:: ""r"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" (term_history>>16), ""m"" (term_history&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int ticks_per_frame;

	unsigned int xpos=0;

	for(ticks_per_frame=0;ticks_per_frame<dstWidth;ticks_per_frame++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		dst[ticks_per_frame]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

		xpos+=term_history;

	}

#endif

    }

}
",1,1,0,1,i,-0.266983300447464,2,18,"{'xInc': 'term_history', 'i': 'ticks_per_frame'}",MHM-Origin,44,8.4816978931427
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",50,"static int get_uint16_equal(QEMUFile *SCSIDiskReq, void *syscall_num, size_t size)

{

    uint16_t *v = syscall_num;

    uint16_t v2;

    qemu_get_be16s(SCSIDiskReq, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",1,1,0,1,pv,-0.756131961941719,2,4,"{'f': 'SCSIDiskReq', 'pv': 'syscall_num'}",MHM-Origin,61,8.49238349199295
254,"static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,

                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,

                              const uint8_t *buf, int len, uint16_t seq,

                              int flags)

{

    uint8_t nal;

    uint8_t type;

    int result = 0;



    if (!len) {

        av_log(ctx, AV_LOG_ERROR, ""Empty H264 RTP packet\n"");

        return AVERROR_INVALIDDATA;

    }

    nal  = buf[0];

    type = nal & 0x1f;



    assert(data);

    assert(buf);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (type >= 1 && type <= 23)

        type = 1;

    switch (type) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(pkt, len + sizeof(start_sequence));

        memcpy(pkt->data, start_sequence, sizeof(start_sequence));

        memcpy(pkt->data + sizeof(start_sequence), buf, len);

        COUNT_NAL_TYPE(data, nal);

        break;



    case 24:                   // STAP-A (one packet, multiple nals)

        // consume the STAP-A NAL

        buf++;

        len--;

        // first we are going to figure out the total size

        {

            int pass         = 0;

            int total_length = 0;

            uint8_t *dst     = NULL;



            for (pass = 0; pass < 2; pass++) {

                const uint8_t *src = buf;

                int src_len        = len;



                while (src_len > 2) {

                    uint16_t nal_size = AV_RB16(src);



                    // consume the length of the aggregate

                    src     += 2;

                    src_len -= 2;



                    if (nal_size <= src_len) {

                        if (pass == 0) {

                            // counting

                            total_length += sizeof(start_sequence) + nal_size;

                        } else {

                            // copying

                            assert(dst);

                            memcpy(dst, start_sequence, sizeof(start_sequence));

                            dst += sizeof(start_sequence);

                            memcpy(dst, src, nal_size);

                            COUNT_NAL_TYPE(data, *src);

                            dst += nal_size;

                        }

                    } else {

                        av_log(ctx, AV_LOG_ERROR,

                               ""nal size exceeds length: %d %d\n"", nal_size, src_len);

                    }



                    // eat what we handled

                    src     += nal_size;

                    src_len -= nal_size;



                    if (src_len < 0)

                        av_log(ctx, AV_LOG_ERROR,

                               ""Consumed more bytes than we got! (%d)\n"", src_len);

                }



                if (pass == 0) {

                    /* now we know the total size of the packet (with the

                     * start sequences added) */

                    av_new_packet(pkt, total_length);

                    dst = pkt->data;

                } else {

                    assert(dst - pkt->data == total_length);

                }

            }

        }

        break;



    case 25:                   // STAP-B

    case 26:                   // MTAP-16

    case 27:                   // MTAP-24

    case 29:                   // FU-B

        av_log(ctx, AV_LOG_ERROR,

               ""Unhandled type (%d) (See RFC for implementation details\n"",

               type);

        result = AVERROR(ENOSYS);

        break;



    case 28:                   // FU-A (fragmented nal)

        buf++;

        len--;                 // skip the fu_indicator

        if (len > 1) {

            // these are the same as above, we just redo them here for clarity

            uint8_t fu_indicator      = nal;

            uint8_t fu_header         = *buf;

            uint8_t start_bit         = fu_header >> 7;

            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;

            uint8_t nal_type          = fu_header & 0x1f;

            uint8_t reconstructed_nal;



            // Reconstruct this packet's true nal; only the data follows.

            /* The original nal forbidden bit and NRI are stored in this

             * packet's nal. */

            reconstructed_nal  = fu_indicator & 0xe0;

            reconstructed_nal |= nal_type;



            // skip the fu_header

            buf++;

            len--;



            if (start_bit)

                COUNT_NAL_TYPE(data, nal_type);

            if (start_bit) {

                /* copy in the start sequence, and the reconstructed nal */

                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);

                memcpy(pkt->data, start_sequence, sizeof(start_sequence));

                pkt->data[sizeof(start_sequence)] = reconstructed_nal;

                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);

            } else {

                av_new_packet(pkt, len);

                memcpy(pkt->data, buf, len);

            }

        } else {

            av_log(ctx, AV_LOG_ERROR, ""Too short data for FU-A H264 RTP packet\n"");

            result = AVERROR_INVALIDDATA;

        }

        break;



    case 30:                   // undefined

    case 31:                   // undefined

    default:

        av_log(ctx, AV_LOG_ERROR, ""Undefined type (%d)\n"", type);

        result = AVERROR_INVALIDDATA;

        break;

    }



    pkt->stream_index = st->index;



    return result;

}
",666,"static int h264_handle_packet(AVFormatContext *IDE_CD, PayloadContext *data,

                              AVStream *st, AVPacket *SVM_EXIT_POPF, uint32_t *motion_val8,

                              const uint8_t *indexes, int CF_USE_ICOUNT, uint16_t AV_OPT_FLAG_ENCODING_PARAM,

                              int gen_helper_fmov_STN_ST0)

{

    uint8_t cbpy_tab;

    uint8_t type;

    int result = 0;



    if (!CF_USE_ICOUNT) {

        av_log(IDE_CD, AV_LOG_ERROR, ""Empty H264 RTP packet
"");

        return AVERROR_INVALIDDATA;

    }

    cbpy_tab  = indexes[0];

    type = cbpy_tab & 0x1f;



    assert(data);

    assert(indexes);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (type >= 1 && type <= 23)

        type = 1;

    switch (type) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(SVM_EXIT_POPF, CF_USE_ICOUNT + sizeof(start_sequence));

        memcpy(SVM_EXIT_POPF->data, start_sequence, sizeof(start_sequence));

        memcpy(SVM_EXIT_POPF->data + sizeof(start_sequence), indexes, CF_USE_ICOUNT);

        COUNT_NAL_TYPE(data, cbpy_tab);

        break;



    case 24:                   // STAP-A (one packet, multiple nals)

        // consume the STAP-A NAL

        indexes++;

        CF_USE_ICOUNT--;

        // first we are going to figure out the total size

        {

            int rtsp_st         = 0;

            int total_length = 0;

            uint8_t *spectrum     = NULL;



            for (rtsp_st = 0; rtsp_st < 2; rtsp_st++) {

                const uint8_t *gen_helper_fabs_ST0 = indexes;

                int src_len        = CF_USE_ICOUNT;



                while (src_len > 2) {

                    uint16_t nal_size = AV_RB16(gen_helper_fabs_ST0);



                    // consume the length of the aggregate

                    gen_helper_fabs_ST0     += 2;

                    src_len -= 2;



                    if (nal_size <= src_len) {

                        if (rtsp_st == 0) {

                            // counting

                            total_length += sizeof(start_sequence) + nal_size;

                        } else {

                            // copying

                            assert(spectrum);

                            memcpy(spectrum, start_sequence, sizeof(start_sequence));

                            spectrum += sizeof(start_sequence);

                            memcpy(spectrum, gen_helper_fabs_ST0, nal_size);

                            COUNT_NAL_TYPE(data, *gen_helper_fabs_ST0);

                            spectrum += nal_size;

                        }

                    } else {

                        av_log(IDE_CD, AV_LOG_ERROR,

                               ""nal size exceeds length: %d %d
"", nal_size, src_len);

                    }



                    // eat what we handled

                    gen_helper_fabs_ST0     += nal_size;

                    src_len -= nal_size;



                    if (src_len < 0)

                        av_log(IDE_CD, AV_LOG_ERROR,

                               ""Consumed more bytes than we got! (%d)
"", src_len);

                }



                if (rtsp_st == 0) {

                    /* now we know the total size of the packet (with the

                     * start sequences added) */

                    av_new_packet(SVM_EXIT_POPF, total_length);

                    spectrum = SVM_EXIT_POPF->data;

                } else {

                    assert(spectrum - SVM_EXIT_POPF->data == total_length);

                }

            }

        }

        break;



    case 25:                   // STAP-B

    case 26:                   // MTAP-16

    case 27:                   // MTAP-24

    case 29:                   // FU-B

        av_log(IDE_CD, AV_LOG_ERROR,

               ""Unhandled type (%d) (See RFC for implementation details
"",

               type);

        result = AVERROR(ENOSYS);

        break;



    case 28:                   // FU-A (fragmented nal)

        indexes++;

        CF_USE_ICOUNT--;                 // skip the fu_indicator

        if (CF_USE_ICOUNT > 1) {

            // these are the same as above, we just redo them here for clarity

            uint8_t fu_indicator      = cbpy_tab;

            uint8_t fu_header         = *indexes;

            uint8_t start_bit         = fu_header >> 7;

            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;

            uint8_t nal_type          = fu_header & 0x1f;

            uint8_t do_shiftd;



            // Reconstruct this packet's true nal; only the data follows.

            /* The original nal forbidden bit and NRI are stored in this

             * packet's nal. */

            do_shiftd  = fu_indicator & 0xe0;

            do_shiftd |= nal_type;



            // skip the fu_header

            indexes++;

            CF_USE_ICOUNT--;



            if (start_bit)

                COUNT_NAL_TYPE(data, nal_type);

            if (start_bit) {

                /* copy in the start sequence, and the reconstructed nal */

                av_new_packet(SVM_EXIT_POPF, sizeof(start_sequence) + sizeof(cbpy_tab) + CF_USE_ICOUNT);

                memcpy(SVM_EXIT_POPF->data, start_sequence, sizeof(start_sequence));

                SVM_EXIT_POPF->data[sizeof(start_sequence)] = do_shiftd;

                memcpy(SVM_EXIT_POPF->data + sizeof(start_sequence) + sizeof(cbpy_tab), indexes, CF_USE_ICOUNT);

            } else {

                av_new_packet(SVM_EXIT_POPF, CF_USE_ICOUNT);

                memcpy(SVM_EXIT_POPF->data, indexes, CF_USE_ICOUNT);

            }

        } else {

            av_log(IDE_CD, AV_LOG_ERROR, ""Too short data for FU-A H264 RTP packet
"");

            result = AVERROR_INVALIDDATA;

        }

        break;



    case 30:                   // undefined

    case 31:                   // undefined

    default:

        av_log(IDE_CD, AV_LOG_ERROR, ""Undefined type (%d)
"", type);

        result = AVERROR_INVALIDDATA;

        break;

    }



    SVM_EXIT_POPF->stream_index = st->index;



    return result;

}
",1,1,0,1,timestamp,-0.2416185736656189,12,79,"{'reconstructed_nal': 'do_shiftd', 'flags': 'gen_helper_fmov_STN_ST0', 'src': 'gen_helper_fabs_ST0', 'ctx': 'IDE_CD', 'pass': 'rtsp_st', 'nal': 'cbpy_tab', 'buf': 'indexes', 'seq': 'AV_OPT_FLAG_ENCODING_PARAM', 'len': 'CF_USE_ICOUNT', 'dst': 'spectrum', 'pkt': 'SVM_EXIT_POPF', 'timestamp': 'motion_val8'}",MHM-Origin,388,9.547906990845998
255,"void bdrv_refresh_filename(BlockDriverState *bs)

{

    BlockDriver *drv = bs->drv;

    QDict *opts;



    if (!drv) {

        return;

    }



    /* This BDS's file name will most probably depend on its file's name, so

     * refresh that first */

    if (bs->file) {

        bdrv_refresh_filename(bs->file->bs);

    }



    if (drv->bdrv_refresh_filename) {

        /* Obsolete information is of no use here, so drop the old file name

         * information before refreshing it */

        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        drv->bdrv_refresh_filename(bs);

    } else if (bs->file) {

        /* Try to reconstruct valid information from the underlying file */

        bool has_open_options;



        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        opts = qdict_new();

        has_open_options = append_open_options(opts, bs);



        /* If no specific options have been given for this BDS, the filename of

         * the underlying file should suffice for this one as well */

        if (bs->file->bs->exact_filename[0] && !has_open_options) {

            strcpy(bs->exact_filename, bs->file->bs->exact_filename);

        }

        /* Reconstructing the full options QDict is simple for most format block

         * drivers, as long as the full options are known for the underlying

         * file BDS. The full options QDict of that file BDS should somehow

         * contain a representation of the filename, therefore the following

         * suffices without querying the (exact_)filename of this BDS. */

        if (bs->file->bs->full_open_options) {

            qdict_put_obj(opts, ""driver"",

                          QOBJECT(qstring_from_str(drv->format_name)));

            QINCREF(bs->file->bs->full_open_options);

            qdict_put_obj(opts, ""file"",

                          QOBJECT(bs->file->bs->full_open_options));



            bs->full_open_options = opts;

        } else {

            QDECREF(opts);

        }

    } else if (!bs->full_open_options && qdict_size(bs->options)) {

        /* There is no underlying file BDS (at least referenced by BDS.file),

         * so the full options QDict should be equal to the options given

         * specifically for this block device when it was opened (plus the

         * driver specification).

         * Because those options don't change, there is no need to update

         * full_open_options when it's already set. */



        opts = qdict_new();

        append_open_options(opts, bs);

        qdict_put_obj(opts, ""driver"",

                      QOBJECT(qstring_from_str(drv->format_name)));



        if (bs->exact_filename[0]) {

            /* This may not work for all block protocol drivers (some may

             * require this filename to be parsed), but we have to find some

             * default solution here, so just include it. If some block driver

             * does not support pure options without any filename at all or

             * needs some special format of the options QDict, it needs to

             * implement the driver-specific bdrv_refresh_filename() function.

             */

            qdict_put_obj(opts, ""filename"",

                          QOBJECT(qstring_from_str(bs->exact_filename)));

        }



        bs->full_open_options = opts;

    }



    if (bs->exact_filename[0]) {

        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);

    } else if (bs->full_open_options) {

        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));

        snprintf(bs->filename, sizeof(bs->filename), ""json:%s"",

                 qstring_get_str(json));

        QDECREF(json);

    }

}
",422,"void bdrv_refresh_filename(BlockDriverState *bs)

{

    BlockDriver *drv = bs->drv;

    QDict *opts;



    if (!drv) {

        return;

    }



    /* This BDS's file name will most probably depend on its file's name, so

     * refresh that first */

    if (bs->file) {

        bdrv_refresh_filename(bs->file->bs);

    }



    if (drv->bdrv_refresh_filename) {

        /* Obsolete information is of no use here, so drop the old file name

         * information before refreshing it */

        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        drv->bdrv_refresh_filename(bs);

    } else if (bs->file) {

        /* Try to reconstruct valid information from the underlying file */

        bool O_CREAT;



        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        opts = qdict_new();

        O_CREAT = append_open_options(opts, bs);



        /* If no specific options have been given for this BDS, the filename of

         * the underlying file should suffice for this one as well */

        if (bs->file->bs->exact_filename[0] && !O_CREAT) {

            strcpy(bs->exact_filename, bs->file->bs->exact_filename);

        }

        /* Reconstructing the full options QDict is simple for most format block

         * drivers, as long as the full options are known for the underlying

         * file BDS. The full options QDict of that file BDS should somehow

         * contain a representation of the filename, therefore the following

         * suffices without querying the (exact_)filename of this BDS. */

        if (bs->file->bs->full_open_options) {

            qdict_put_obj(opts, ""driver"",

                          QOBJECT(qstring_from_str(drv->format_name)));

            QINCREF(bs->file->bs->full_open_options);

            qdict_put_obj(opts, ""file"",

                          QOBJECT(bs->file->bs->full_open_options));



            bs->full_open_options = opts;

        } else {

            QDECREF(opts);

        }

    } else if (!bs->full_open_options && qdict_size(bs->options)) {

        /* There is no underlying file BDS (at least referenced by BDS.file),

         * so the full options QDict should be equal to the options given

         * specifically for this block device when it was opened (plus the

         * driver specification).

         * Because those options don't change, there is no need to update

         * full_open_options when it's already set. */



        opts = qdict_new();

        append_open_options(opts, bs);

        qdict_put_obj(opts, ""driver"",

                      QOBJECT(qstring_from_str(drv->format_name)));



        if (bs->exact_filename[0]) {

            /* This may not work for all block protocol drivers (some may

             * require this filename to be parsed), but we have to find some

             * default solution here, so just include it. If some block driver

             * does not support pure options without any filename at all or

             * needs some special format of the options QDict, it needs to

             * implement the driver-specific bdrv_refresh_filename() function.

             */

            qdict_put_obj(opts, ""filename"",

                          QOBJECT(qstring_from_str(bs->exact_filename)));

        }



        bs->full_open_options = opts;

    }



    if (bs->exact_filename[0]) {

        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);

    } else if (bs->full_open_options) {

        QString *EXCP0D_GPF = qobject_to_json(QOBJECT(bs->full_open_options));

        snprintf(bs->filename, sizeof(bs->filename), ""json:%s"",

                 qstring_get_str(EXCP0D_GPF));

        QDECREF(EXCP0D_GPF);

    }

}
",0,0,1,1,has_open_options,0.17054006457328796,2,6,"{'json': 'EXCP0D_GPF', 'has_open_options': 'O_CREAT'}",MHM-Origin,64,9.406878411769867
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",39,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ModPred)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ModPred->cid_table->bit_depth == 8)

            ModPred->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",0,0,0,-1,ctx,-0.00404749670997262,1,3,{'ctx': 'PCI_BASE_ADDRESS_MEM_TYPE_32'},MHM-Origin,414,9.707444262504577
258,"uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)

{

    CPU_DoubleU farg1, farg2;



    farg1.ll = arg1;

    farg2.ll = arg2;



    if (unlikely(float64_is_infinity(farg1.d) &&

                 float64_is_infinity(farg2.d))) {

        /* Division of infinity by infinity */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {

        /* Division of zero by zero */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(farg1.d) ||

                     float64_is_signaling_nan(farg2.d))) {

            /* sNaN division */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

        }

        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);

    }



    return farg1.ll;

}
",153,"uint64_t helper_fdiv(CPUPPCState *h, uint64_t sun4uv_init, uint64_t matrix_ch)

{

    CPU_DoubleU LOG_DIS, MIPS_FPU_MAX;



    LOG_DIS.ll = sun4uv_init;

    MIPS_FPU_MAX.ll = matrix_ch;



    if (unlikely(float64_is_infinity(LOG_DIS.d) &&

                 float64_is_infinity(MIPS_FPU_MAX.d))) {

        /* Division of infinity by infinity */

        LOG_DIS.ll = fload_invalid_op_excp(h, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(LOG_DIS.d) && float64_is_zero(MIPS_FPU_MAX.d))) {

        /* Division of zero by zero */

        LOG_DIS.ll = fload_invalid_op_excp(h, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(LOG_DIS.d) ||

                     float64_is_signaling_nan(MIPS_FPU_MAX.d))) {

            /* sNaN division */

            fload_invalid_op_excp(h, POWERPC_EXCP_FP_VXSNAN);

        }

        LOG_DIS.d = float64_div(LOG_DIS.d, MIPS_FPU_MAX.d, &h->fp_status);

    }



    return LOG_DIS.ll;

}
",0,0,0,-1,env,0.00028091156855225563,5,25,"{'env': 'h', 'farg2': 'MIPS_FPU_MAX', 'arg2': 'matrix_ch', 'arg1': 'sun4uv_init', 'farg1': 'LOG_DIS'}",MHM-Origin,410,9.867113423347472
259,"static void test_io_channel_ipv4(bool async)

{

    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    SocketAddress *connect_addr = g_new0(SocketAddress, 1);



    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    listen_addr->u.inet = g_new0(InetSocketAddress, 1);

    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");

    listen_addr->u.inet->port = NULL; /* Auto-select */



    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);



    qapi_free_SocketAddress(listen_addr);

    qapi_free_SocketAddress(connect_addr);

}
",136,"static void test_io_channel_ipv4(bool AVMEDIA_TYPE_SUBTITLE)

{

    SocketAddress *gen_op_jmp_v = g_new0(SocketAddress, 1);

    SocketAddress *AV_CODEC_ID_RV10 = g_new0(SocketAddress, 1);



    gen_op_jmp_v->type = SOCKET_ADDRESS_KIND_INET;

    gen_op_jmp_v->u.inet = g_new0(InetSocketAddress, 1);

    gen_op_jmp_v->u.inet->host = g_strdup(""0.0.0.0"");

    gen_op_jmp_v->u.inet->port = NULL; /* Auto-select */



    AV_CODEC_ID_RV10->type = SOCKET_ADDRESS_KIND_INET;

    AV_CODEC_ID_RV10->u.inet = g_new0(InetSocketAddress, 1);

    AV_CODEC_ID_RV10->u.inet->host = g_strdup(""127.0.0.1"");

    AV_CODEC_ID_RV10->u.inet->port = NULL; /* Filled in later */



    test_io_channel(AVMEDIA_TYPE_SUBTITLE, gen_op_jmp_v, AV_CODEC_ID_RV10);



    qapi_free_SocketAddress(gen_op_jmp_v);

    qapi_free_SocketAddress(AV_CODEC_ID_RV10);

}
",0,0,0,-1,connect_addr,0.0008632629178464413,3,16,"{'async': 'AVMEDIA_TYPE_SUBTITLE', 'listen_addr': 'gen_op_jmp_v', 'connect_addr': 'AV_CODEC_ID_RV10'}",MHM-Origin,411,10.008639669418335
260,"static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)

{

    const char *opn = ""loongson_cp2"";

    uint32_t opc, shift_max;

    TCGv_i64 t0, t1;



    opc = MASK_LMI(ctx->opcode);

    switch (opc) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        t0 = tcg_temp_local_new_i64();

        t1 = tcg_temp_local_new_i64();

        break;

    default:

        t0 = tcg_temp_new_i64();

        t1 = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(ctx, t0, rs);

    gen_load_fpr64(ctx, t1, rt);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (opc) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPER(PADDW, paddw);

    LMI_HELPER(PADDSB, paddsb);

    LMI_HELPER(PADDUSB, paddusb);

    LMI_HELPER(PADDB, paddb);



    LMI_HELPER(PSUBSH, psubsh);

    LMI_HELPER(PSUBUSH, psubush);

    LMI_HELPER(PSUBH, psubh);

    LMI_HELPER(PSUBW, psubw);

    LMI_HELPER(PSUBSB, psubsb);

    LMI_HELPER(PSUBUSB, psubusb);

    LMI_HELPER(PSUBB, psubb);



    LMI_HELPER(PSHUFH, pshufh);

    LMI_HELPER(PACKSSWH, packsswh);

    LMI_HELPER(PACKSSHB, packsshb);

    LMI_HELPER(PACKUSHB, packushb);



    LMI_HELPER(PUNPCKLHW, punpcklhw);

    LMI_HELPER(PUNPCKHHW, punpckhhw);

    LMI_HELPER(PUNPCKLBH, punpcklbh);

    LMI_HELPER(PUNPCKHBH, punpckhbh);

    LMI_HELPER(PUNPCKLWD, punpcklwd);

    LMI_HELPER(PUNPCKHWD, punpckhwd);



    LMI_HELPER(PAVGH, pavgh);

    LMI_HELPER(PAVGB, pavgb);

    LMI_HELPER(PMAXSH, pmaxsh);

    LMI_HELPER(PMINSH, pminsh);

    LMI_HELPER(PMAXUB, pmaxub);

    LMI_HELPER(PMINUB, pminub);



    LMI_HELPER(PCMPEQW, pcmpeqw);

    LMI_HELPER(PCMPGTW, pcmpgtw);

    LMI_HELPER(PCMPEQH, pcmpeqh);

    LMI_HELPER(PCMPGTH, pcmpgth);

    LMI_HELPER(PCMPEQB, pcmpeqb);

    LMI_HELPER(PCMPGTB, pcmpgtb);



    LMI_HELPER(PSLLW, psllw);

    LMI_HELPER(PSLLH, psllh);

    LMI_HELPER(PSRLW, psrlw);

    LMI_HELPER(PSRLH, psrlh);

    LMI_HELPER(PSRAW, psraw);

    LMI_HELPER(PSRAH, psrah);



    LMI_HELPER(PMULLH, pmullh);

    LMI_HELPER(PMULHH, pmulhh);

    LMI_HELPER(PMULHUH, pmulhuh);

    LMI_HELPER(PMADDHW, pmaddhw);



    LMI_HELPER(PASUBUB, pasubub);

    LMI_HELPER_1(BIADD, biadd);

    LMI_HELPER_1(PMOVMSKB, pmovmskb);



    LMI_DIRECT(PADDD, paddd, add);

    LMI_DIRECT(PSUBD, psubd, sub);

    LMI_DIRECT(XOR_CP2, xor, xor);

    LMI_DIRECT(NOR_CP2, nor, nor);

    LMI_DIRECT(AND_CP2, and, and);

    LMI_DIRECT(PANDN, pandn, andc);

    LMI_DIRECT(OR, or, or);



    case OPC_PINSRH_0:

        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);

        opn = ""pinsrh_0"";

        break;

    case OPC_PINSRH_1:

        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);

        opn = ""pinsrh_1"";

        break;

    case OPC_PINSRH_2:

        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);

        opn = ""pinsrh_2"";

        break;

    case OPC_PINSRH_3:

        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);

        opn = ""pinsrh_3"";

        break;



    case OPC_PEXTRH:

        tcg_gen_andi_i64(t1, t1, 3);

        tcg_gen_shli_i64(t1, t1, 4);

        tcg_gen_shr_i64(t0, t0, t1);

        tcg_gen_ext16u_i64(t0, t0);

        opn = ""pextrh"";

        break;



    case OPC_ADDU_CP2:

        tcg_gen_add_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;

    case OPC_SUBU_CP2:

        tcg_gen_sub_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;



    case OPC_SLL_CP2:

        opn = ""sll"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRL_CP2:

        opn = ""srl"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRA_CP2:

        opn = ""sra"";

        shift_max = 32;

        goto do_shift;

    case OPC_DSLL_CP2:

        opn = ""dsll"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRL_CP2:

        opn = ""dsrl"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRA_CP2:

        opn = ""dsra"";

        shift_max = 64;

        goto do_shift;

    do_shift:

        /* Make sure shift count isn't TCG undefined behaviour.  */

        tcg_gen_andi_i64(t1, t1, shift_max - 1);



        switch (opc) {

        case OPC_SLL_CP2:

        case OPC_DSLL_CP2:

            tcg_gen_shl_i64(t0, t0, t1);

            break;

        case OPC_SRA_CP2:

        case OPC_DSRA_CP2:

            /* Since SRA is UndefinedResult without sign-extended inputs,

               we can treat SRA and DSRA the same.  */

            tcg_gen_sar_i64(t0, t0, t1);

            break;

        case OPC_SRL_CP2:

            /* We want to shift in zeros for SRL; zero-extend first.  */

            tcg_gen_ext32u_i64(t0, t0);

            /* FALLTHRU */

        case OPC_DSRL_CP2:

            tcg_gen_shr_i64(t0, t0, t1);

            break;

        }



        if (shift_max == 32) {

            tcg_gen_ext32s_i64(t0, t0);

        }



        /* Shifts larger than MAX produce zero.  */

        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);

        tcg_gen_neg_i64(t1, t1);

        tcg_gen_and_i64(t0, t0, t1);

        break;



    case OPC_ADD_CP2:

    case OPC_DADD_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_add_i64(t0, t1, t2);

            if (opc == OPC_ADD_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_andc_i64(t1, t2, t1);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_ADD_CP2 ? ""add"" : ""dadd"");

            break;

        }



    case OPC_SUB_CP2:

    case OPC_DSUB_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_sub_i64(t0, t1, t2);

            if (opc == OPC_SUB_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_and_i64(t1, t1, t2);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_SUB_CP2 ? ""sub"" : ""dsub"");

            break;

        }



    case OPC_PMULUW:

        tcg_gen_ext32u_i64(t0, t0);

        tcg_gen_ext32u_i64(t1, t1);

        tcg_gen_mul_i64(t0, t0, t1);

        opn = ""pmuluw"";

        break;



    case OPC_SEQU_CP2:

    case OPC_SEQ_CP2:

    case OPC_SLTU_CP2:

    case OPC_SLT_CP2:

    case OPC_SLEU_CP2:

    case OPC_SLE_CP2:

        /* ??? Document is unclear: Set FCC[CC].  Does that mean the

           FD field is the CC field?  */

    default:

        MIPS_INVAL(opn);

        generate_exception(ctx, EXCP_RI);

        return;

    }



#undef LMI_HELPER

#undef LMI_DIRECT



    gen_store_fpr64(ctx, t0, rd);



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s, %s"", opn,

               fregnames[rd], fregnames[rs], fregnames[rt]);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i64(t1);

}
",1320,"static void gen_loongson_multimedia(DisasContext *ctx, int tcg_abort, int max_insns, int sconf)

{

    const char *OPC_DSRA_CP2 = ""loongson_cp2"";

    uint32_t opc, HPTE_V_HVLOCK;

    TCGv_i64 vnc_display_listen_addr, tile_height;



    opc = MASK_LMI(ctx->opcode);

    switch (opc) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        vnc_display_listen_addr = tcg_temp_local_new_i64();

        tile_height = tcg_temp_local_new_i64();

        break;

    default:

        vnc_display_listen_addr = tcg_temp_new_i64();

        tile_height = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(ctx, vnc_display_listen_addr, max_insns);

    gen_load_fpr64(ctx, tile_height, sconf);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (opc) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPER(PADDW, paddw);

    LMI_HELPER(PADDSB, paddsb);

    LMI_HELPER(PADDUSB, paddusb);

    LMI_HELPER(PADDB, paddb);



    LMI_HELPER(PSUBSH, psubsh);

    LMI_HELPER(PSUBUSH, psubush);

    LMI_HELPER(PSUBH, psubh);

    LMI_HELPER(PSUBW, psubw);

    LMI_HELPER(PSUBSB, psubsb);

    LMI_HELPER(PSUBUSB, psubusb);

    LMI_HELPER(PSUBB, psubb);



    LMI_HELPER(PSHUFH, pshufh);

    LMI_HELPER(PACKSSWH, packsswh);

    LMI_HELPER(PACKSSHB, packsshb);

    LMI_HELPER(PACKUSHB, packushb);



    LMI_HELPER(PUNPCKLHW, punpcklhw);

    LMI_HELPER(PUNPCKHHW, punpckhhw);

    LMI_HELPER(PUNPCKLBH, punpcklbh);

    LMI_HELPER(PUNPCKHBH, punpckhbh);

    LMI_HELPER(PUNPCKLWD, punpcklwd);

    LMI_HELPER(PUNPCKHWD, punpckhwd);



    LMI_HELPER(PAVGH, pavgh);

    LMI_HELPER(PAVGB, pavgb);

    LMI_HELPER(PMAXSH, pmaxsh);

    LMI_HELPER(PMINSH, pminsh);

    LMI_HELPER(PMAXUB, pmaxub);

    LMI_HELPER(PMINUB, pminub);



    LMI_HELPER(PCMPEQW, pcmpeqw);

    LMI_HELPER(PCMPGTW, pcmpgtw);

    LMI_HELPER(PCMPEQH, pcmpeqh);

    LMI_HELPER(PCMPGTH, pcmpgth);

    LMI_HELPER(PCMPEQB, pcmpeqb);

    LMI_HELPER(PCMPGTB, pcmpgtb);



    LMI_HELPER(PSLLW, psllw);

    LMI_HELPER(PSLLH, psllh);

    LMI_HELPER(PSRLW, psrlw);

    LMI_HELPER(PSRLH, psrlh);

    LMI_HELPER(PSRAW, psraw);

    LMI_HELPER(PSRAH, psrah);



    LMI_HELPER(PMULLH, pmullh);

    LMI_HELPER(PMULHH, pmulhh);

    LMI_HELPER(PMULHUH, pmulhuh);

    LMI_HELPER(PMADDHW, pmaddhw);



    LMI_HELPER(PASUBUB, pasubub);

    LMI_HELPER_1(BIADD, biadd);

    LMI_HELPER_1(PMOVMSKB, pmovmskb);



    LMI_DIRECT(PADDD, paddd, add);

    LMI_DIRECT(PSUBD, psubd, sub);

    LMI_DIRECT(XOR_CP2, xor, xor);

    LMI_DIRECT(NOR_CP2, nor, nor);

    LMI_DIRECT(AND_CP2, and, and);

    LMI_DIRECT(PANDN, pandn, andc);

    LMI_DIRECT(OR, or, or);



    case OPC_PINSRH_0:

        tcg_gen_deposit_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height, 0, 16);

        OPC_DSRA_CP2 = ""pinsrh_0"";

        break;

    case OPC_PINSRH_1:

        tcg_gen_deposit_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height, 16, 16);

        OPC_DSRA_CP2 = ""pinsrh_1"";

        break;

    case OPC_PINSRH_2:

        tcg_gen_deposit_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height, 32, 16);

        OPC_DSRA_CP2 = ""pinsrh_2"";

        break;

    case OPC_PINSRH_3:

        tcg_gen_deposit_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height, 48, 16);

        OPC_DSRA_CP2 = ""pinsrh_3"";

        break;



    case OPC_PEXTRH:

        tcg_gen_andi_i64(tile_height, tile_height, 3);

        tcg_gen_shli_i64(tile_height, tile_height, 4);

        tcg_gen_shr_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height);

        tcg_gen_ext16u_i64(vnc_display_listen_addr, vnc_display_listen_addr);

        OPC_DSRA_CP2 = ""pextrh"";

        break;



    case OPC_ADDU_CP2:

        tcg_gen_add_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height);

        tcg_gen_ext32s_i64(vnc_display_listen_addr, vnc_display_listen_addr);

        OPC_DSRA_CP2 = ""addu"";

        break;

    case OPC_SUBU_CP2:

        tcg_gen_sub_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height);

        tcg_gen_ext32s_i64(vnc_display_listen_addr, vnc_display_listen_addr);

        OPC_DSRA_CP2 = ""addu"";

        break;



    case OPC_SLL_CP2:

        OPC_DSRA_CP2 = ""sll"";

        HPTE_V_HVLOCK = 32;

        goto do_shift;

    case OPC_SRL_CP2:

        OPC_DSRA_CP2 = ""srl"";

        HPTE_V_HVLOCK = 32;

        goto do_shift;

    case OPC_SRA_CP2:

        OPC_DSRA_CP2 = ""sra"";

        HPTE_V_HVLOCK = 32;

        goto do_shift;

    case OPC_DSLL_CP2:

        OPC_DSRA_CP2 = ""dsll"";

        HPTE_V_HVLOCK = 64;

        goto do_shift;

    case OPC_DSRL_CP2:

        OPC_DSRA_CP2 = ""dsrl"";

        HPTE_V_HVLOCK = 64;

        goto do_shift;

    case OPC_DSRA_CP2:

        OPC_DSRA_CP2 = ""dsra"";

        HPTE_V_HVLOCK = 64;

        goto do_shift;

    do_shift:

        /* Make sure shift count isn't TCG undefined behaviour.  */

        tcg_gen_andi_i64(tile_height, tile_height, HPTE_V_HVLOCK - 1);



        switch (opc) {

        case OPC_SLL_CP2:

        case OPC_DSLL_CP2:

            tcg_gen_shl_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height);

            break;

        case OPC_SRA_CP2:

        case OPC_DSRA_CP2:

            /* Since SRA is UndefinedResult without sign-extended inputs,

               we can treat SRA and DSRA the same.  */

            tcg_gen_sar_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height);

            break;

        case OPC_SRL_CP2:

            /* We want to shift in zeros for SRL; zero-extend first.  */

            tcg_gen_ext32u_i64(vnc_display_listen_addr, vnc_display_listen_addr);

            /* FALLTHRU */

        case OPC_DSRL_CP2:

            tcg_gen_shr_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height);

            break;

        }



        if (HPTE_V_HVLOCK == 32) {

            tcg_gen_ext32s_i64(vnc_display_listen_addr, vnc_display_listen_addr);

        }



        /* Shifts larger than MAX produce zero.  */

        tcg_gen_setcondi_i64(TCG_COND_LTU, tile_height, tile_height, HPTE_V_HVLOCK);

        tcg_gen_neg_i64(tile_height, tile_height);

        tcg_gen_and_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height);

        break;



    case OPC_ADD_CP2:

    case OPC_DADD_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, vnc_display_listen_addr);

            tcg_gen_add_i64(vnc_display_listen_addr, tile_height, t2);

            if (opc == OPC_ADD_CP2) {

                tcg_gen_ext32s_i64(vnc_display_listen_addr, vnc_display_listen_addr);

            }

            tcg_gen_xor_i64(tile_height, tile_height, t2);

            tcg_gen_xor_i64(t2, t2, vnc_display_listen_addr);

            tcg_gen_andc_i64(tile_height, t2, tile_height);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, tile_height, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            OPC_DSRA_CP2 = (opc == OPC_ADD_CP2 ? ""add"" : ""dadd"");

            break;

        }



    case OPC_SUB_CP2:

    case OPC_DSUB_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, vnc_display_listen_addr);

            tcg_gen_sub_i64(vnc_display_listen_addr, tile_height, t2);

            if (opc == OPC_SUB_CP2) {

                tcg_gen_ext32s_i64(vnc_display_listen_addr, vnc_display_listen_addr);

            }

            tcg_gen_xor_i64(tile_height, tile_height, t2);

            tcg_gen_xor_i64(t2, t2, vnc_display_listen_addr);

            tcg_gen_and_i64(tile_height, tile_height, t2);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, tile_height, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            OPC_DSRA_CP2 = (opc == OPC_SUB_CP2 ? ""sub"" : ""dsub"");

            break;

        }



    case OPC_PMULUW:

        tcg_gen_ext32u_i64(vnc_display_listen_addr, vnc_display_listen_addr);

        tcg_gen_ext32u_i64(tile_height, tile_height);

        tcg_gen_mul_i64(vnc_display_listen_addr, vnc_display_listen_addr, tile_height);

        OPC_DSRA_CP2 = ""pmuluw"";

        break;



    case OPC_SEQU_CP2:

    case OPC_SEQ_CP2:

    case OPC_SLTU_CP2:

    case OPC_SLT_CP2:

    case OPC_SLEU_CP2:

    case OPC_SLE_CP2:

        /* ??? Document is unclear: Set FCC[CC].  Does that mean the

           FD field is the CC field?  */

    default:

        MIPS_INVAL(OPC_DSRA_CP2);

        generate_exception(ctx, EXCP_RI);

        return;

    }



#undef LMI_HELPER

#undef LMI_DIRECT



    gen_store_fpr64(ctx, vnc_display_listen_addr, tcg_abort);



    (void)OPC_DSRA_CP2; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s, %s"", OPC_DSRA_CP2,

               fregnames[tcg_abort], fregnames[max_insns], fregnames[sconf]);

    tcg_temp_free_i64(vnc_display_listen_addr);

    tcg_temp_free_i64(tile_height);

}
",0,0,1,1,rd,0.3952599912881851,7,135,"{'rd': 'tcg_abort', 't1': 'tile_height', 'rs': 'max_insns', 'opn': 'OPC_DSRA_CP2', 't0': 'vnc_display_listen_addr', 'shift_max': 'HPTE_V_HVLOCK', 'rt': 'sconf'}",MHM-Origin,270,10.899162105719249
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}
",72,"uint64_t helper_addlv (uint64_t xen_9pfs_bh, uint64_t op2)

{

    uint64_t tmp = xen_9pfs_bh;

    xen_9pfs_bh = (uint32_t)(xen_9pfs_bh + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ xen_9pfs_bh) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return xen_9pfs_bh;

}
",1,1,0,1,op1,-0.6514918506145477,1,6,{'op1': 'xen_9pfs_bh'},MHM-Origin,44,10.728902308146159
263,"static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,

                                   RockerTlv **group_tlvs)

{

    OfDpaGroup *l2_group;

    RockerTlv **tlvs;

    int err;

    int i;



    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||

        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {

        return -ROCKER_EINVAL;

    }



    group->l2_flood.group_count =

        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);



    tlvs = g_malloc0((group->l2_flood.group_count + 1) *

                     sizeof(RockerTlv *));

    if (!tlvs) {

        return -ROCKER_ENOMEM;

    }



    g_free(group->l2_flood.group_ids);

    group->l2_flood.group_ids =

        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));

    if (!group->l2_flood.group_ids) {

        err = -ROCKER_ENOMEM;

        goto err_out;

    }



    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,

                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);



    for (i = 0; i < group->l2_flood.group_count; i++) {

        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);

    }



    /* All of the L2 interface groups referenced by the L2 flood

     * must have same VLAN

     */



    for (i = 0; i < group->l2_flood.group_count; i++) {

        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);

        if (!l2_group) {

            continue;

        }

        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==

             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&

            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=

             ROCKER_GROUP_VLAN_GET(group->id))) {

            DPRINTF(""l2 interface group 0x%08x VLAN doesn't match l2 ""

                    ""flood group 0x%08x\n"",

                    group->l2_flood.group_ids[i], group->id);

            err = -ROCKER_EINVAL;

            goto err_out;

        }

    }



    g_free(tlvs);

    return ROCKER_OK;



err_out:

    group->l2_flood.group_count = 0;

    g_free(group->l2_flood.group_ids);

    g_free(tlvs);



    return err;

}
",341,"static int of_dpa_cmd_add_l2_flood(OfDpa *bdrv_unref, OfDpaGroup *pci_register_bar,

                                   RockerTlv **group_tlvs)

{

    OfDpaGroup *SOCK_DGRAM;

    RockerTlv **detach;

    int transport_priv;

    int i;



    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||

        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {

        return -ROCKER_EINVAL;

    }



    pci_register_bar->l2_flood.group_count =

        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);



    detach = g_malloc0((pci_register_bar->l2_flood.group_count + 1) *

                     sizeof(RockerTlv *));

    if (!detach) {

        return -ROCKER_ENOMEM;

    }



    g_free(pci_register_bar->l2_flood.group_ids);

    pci_register_bar->l2_flood.group_ids =

        g_malloc0(pci_register_bar->l2_flood.group_count * sizeof(uint32_t));

    if (!pci_register_bar->l2_flood.group_ids) {

        transport_priv = -ROCKER_ENOMEM;

        goto err_out;

    }



    rocker_tlv_parse_nested(detach, pci_register_bar->l2_flood.group_count,

                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);



    for (i = 0; i < pci_register_bar->l2_flood.group_count; i++) {

        pci_register_bar->l2_flood.group_ids[i] = rocker_tlv_get_le32(detach[i + 1]);

    }



    /* All of the L2 interface groups referenced by the L2 flood

     * must have same VLAN

     */



    for (i = 0; i < pci_register_bar->l2_flood.group_count; i++) {

        SOCK_DGRAM = of_dpa_group_find(bdrv_unref, pci_register_bar->l2_flood.group_ids[i]);

        if (!SOCK_DGRAM) {

            continue;

        }

        if ((ROCKER_GROUP_TYPE_GET(SOCK_DGRAM->id) ==

             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&

            (ROCKER_GROUP_VLAN_GET(SOCK_DGRAM->id) !=

             ROCKER_GROUP_VLAN_GET(pci_register_bar->id))) {

            DPRINTF(""l2 interface group 0x%08x VLAN doesn't match l2 ""

                    ""flood group 0x%08x
"",

                    pci_register_bar->l2_flood.group_ids[i], pci_register_bar->id);

            transport_priv = -ROCKER_EINVAL;

            goto err_out;

        }

    }



    g_free(detach);

    return ROCKER_OK;



err_out:

    pci_register_bar->l2_flood.group_count = 0;

    g_free(pci_register_bar->l2_flood.group_ids);

    g_free(detach);



    return transport_priv;

}
",1,1,0,1,tlvs,-0.1093105673789978,5,35,"{'group': 'pci_register_bar', 'err': 'transport_priv', 'tlvs': 'detach', 'l2_group': 'SOCK_DGRAM', 'of_dpa': 'bdrv_unref'}",MHM-Origin,244,11.08213484287262

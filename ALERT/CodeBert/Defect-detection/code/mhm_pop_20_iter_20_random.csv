Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,No. Changed Names,No. Changed Tokens,Replaced Names,Attack Type,Query Times,Time Cost
1,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *s = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int ring_order;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {


            goto out;

        }




        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->xendev.gnttabdev,

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        ring_order = xen_9pdev->rings[i].intf->ring_order;

        if (ring_order > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].ring_order = ring_order;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->xendev.gnttabdev,

                (1 << ring_order),

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(ring_order);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             xendev->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(xendev, 0,

                          ""xenevtchn_bind_interdomain failed port=%d\n"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(xendev, 2, ""bind evtchn port %d\n"", xendev->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(xendev, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(xendev, ""path"");

    xen_9pdev->id = s->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", xendev->dev);

    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, ""tag"");

    v9fs_register_transport(s, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            s->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(s, NULL);



    return 0;



out:

    xen_9pfs_free(xendev);

    return -1;

}",812,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *celt_output_samples = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int sps;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {


            goto out;

        }




        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->xendev.gnttabdev,

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        sps = xen_9pdev->rings[i].intf->sps;

        if (sps > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].sps = sps;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->xendev.gnttabdev,

                (1 << sps),

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(sps);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             xendev->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(xendev, 0,

                          ""xenevtchn_bind_interdomain failed port=%d
"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(xendev, 2, ""bind evtchn port %d
"", xendev->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(xendev, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(xendev, ""path"");

    xen_9pdev->id = celt_output_samples->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", xendev->dev);

    xen_9pdev->tag = celt_output_samples->fsconf.tag = xenstore_read_fe_str(xendev, ""tag"");

    v9fs_register_transport(celt_output_samples, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            celt_output_samples->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, celt_output_samples->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(celt_output_samples, NULL);



    return 0;



out:

    xen_9pfs_free(xendev);

    return -1;

}",1,1,0,1,s,-0.16662496328353882,2,15,"{'ring_order': 'sps', 's': 'celt_output_samples'}",MHM-Origin,43,1.0834653655687967
4,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    float aspect;



    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    s->aspect_ratio_info= get_bits(&s->gb, 4);

    if(!s->mpeg2){

        aspect= mpeg1_aspect[s->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        avctx->has_b_frames= 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        if (s->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            avctx->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        }

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_intra_matrix[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->inter_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_non_intra_matrix[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    avctx->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",753,"static int mpeg1_decode_sequence(AVCodecContext *SVM_EXIT_WRITE_CR0, 

                                 UINT8 *EM_LATTICEMICO32, int buf_size)

{

    Mpeg1Context *s1 = SVM_EXIT_WRITE_CR0->priv_data;

    MpegEncContext *gen_exts = &s1->mpeg_enc_ctx;

    int width, height, i, tcg_gen_shr_tl, j;

    float tcg_gen_qemu_ld16u;



    init_get_bits(&gen_exts->gb, EM_LATTICEMICO32, buf_size);



    width = get_bits(&gen_exts->gb, 12);

    height = get_bits(&gen_exts->gb, 12);

    gen_exts->aspect_ratio_info= get_bits(&gen_exts->gb, 4);

    if(!gen_exts->mpeg2){

        tcg_gen_qemu_ld16u= mpeg1_aspect[gen_exts->aspect_ratio_info];

        if(tcg_gen_qemu_ld16u!=0.0) SVM_EXIT_WRITE_CR0->aspect_ratio= width/(tcg_gen_qemu_ld16u*height);

    }



    gen_exts->frame_rate_index = get_bits(&gen_exts->gb, 4);

    if (gen_exts->frame_rate_index == 0)

        return -1;

    gen_exts->bit_rate = get_bits(&gen_exts->gb, 18) * 400;

    if (get_bits1(&gen_exts->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != gen_exts->width ||

        height != gen_exts->height) {

        /* start new mpeg1 context decoding */

        gen_exts->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(gen_exts);

        }

        gen_exts->width = width;

        gen_exts->height = height;

        SVM_EXIT_WRITE_CR0->has_b_frames= 1;

        gen_exts->SVM_EXIT_WRITE_CR0 = SVM_EXIT_WRITE_CR0;

        SVM_EXIT_WRITE_CR0->width = width;

        SVM_EXIT_WRITE_CR0->height = height;

        if (gen_exts->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            SVM_EXIT_WRITE_CR0->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            SVM_EXIT_WRITE_CR0->frame_rate = frame_rate_tab[gen_exts->frame_rate_index];

        }

        gen_exts->frame_rate = SVM_EXIT_WRITE_CR0->frame_rate;

        SVM_EXIT_WRITE_CR0->bit_rate = gen_exts->bit_rate;

        

        if (MPV_common_init(gen_exts) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&gen_exts->gb, 10); /* vbv_buffer_size */

    skip_bits(&gen_exts->gb, 1);



    /* get matrix */

    if (get_bits1(&gen_exts->gb)) {

        for(i=0;i<64;i++) {

            tcg_gen_shr_tl = get_bits(&gen_exts->gb, 8);

            j = gen_exts->intra_scantable.permutated[i];

            gen_exts->intra_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_intra_matrix[j] = tcg_gen_shr_tl;

        }

#ifdef DEBUG

        dprintf(""intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", gen_exts->intra_matrix[gen_exts->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= gen_exts->idct_permutation[i];

            tcg_gen_shr_tl = ff_mpeg1_default_intra_matrix[i];

            gen_exts->intra_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_intra_matrix[j] = tcg_gen_shr_tl;

        }

    }

    if (get_bits1(&gen_exts->gb)) {

        for(i=0;i<64;i++) {

            tcg_gen_shr_tl = get_bits(&gen_exts->gb, 8);

            j = gen_exts->intra_scantable.permutated[i];

            gen_exts->inter_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_inter_matrix[j] = tcg_gen_shr_tl;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", gen_exts->inter_matrix[gen_exts->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= gen_exts->idct_permutation[i];

            tcg_gen_shr_tl = ff_mpeg1_default_non_intra_matrix[i];

            gen_exts->inter_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_inter_matrix[j] = tcg_gen_shr_tl;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    gen_exts->progressive_sequence = 1;

    gen_exts->progressive_frame = 1;

    gen_exts->picture_structure = PICT_FRAME;

    gen_exts->frame_pred_frame_dct = 1;

    gen_exts->mpeg2 = 0;

    SVM_EXIT_WRITE_CR0->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",0,0,1,1,avctx,0.289772093296051,5,85,"{'s': 'gen_exts', 'buf': 'EM_LATTICEMICO32', 'v': 'tcg_gen_shr_tl', 'aspect': 'tcg_gen_qemu_ld16u', 'avctx': 'SVM_EXIT_WRITE_CR0'}",MHM-Origin,106,3.5622595588366193
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
",45,"static uint32_t drc_set_unusable(sPAPRDRConnector *f32)

{

    f32->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (f32->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(f32);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(f32);

    }



    return RTAS_OUT_SUCCESS;

}
",0,0,0,-1,drc,-0.006166285835206509,1,5,{'drc': 'RockerTlv'},MHM-Origin,410,4.421151494979858
6,"static void scsi_read_request(SCSIDiskReq *r)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    if (r->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd\n"", r->iov.iov_len);

        r->sector_count = 0;

        scsi_req_data(&r->req, r->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d\n"", r->sector_count);

    if (r->sector_count == 0) {

        scsi_command_complete(r, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    n = r->sector_count;

    if (n > SCSI_DMA_BUF_SIZE / 512)

        n = SCSI_DMA_BUF_SIZE / 512;



    r->iov.iov_len = n * 512;

    qemu_iovec_init_external(&r->qiov, &r->iov, 1);

    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,

                              scsi_read_complete, r);

    if (r->req.aiocb == NULL) {

        scsi_read_complete(r, -EIO);

    }

}
",212,"static void scsi_read_request(SCSIDiskReq *help)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, help->req.dev);

    uint32_t n;



    if (help->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd
"", help->iov.iov_len);

        help->sector_count = 0;

        scsi_req_data(&help->req, help->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d
"", help->sector_count);

    if (help->sector_count == 0) {

        scsi_command_complete(help, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(help->req.aiocb == NULL);



    n = help->sector_count;

    if (n > SCSI_DMA_BUF_SIZE / 512)

        n = SCSI_DMA_BUF_SIZE / 512;



    help->iov.iov_len = n * 512;

    qemu_iovec_init_external(&help->qiov, &help->iov, 1);

    help->req.aiocb = bdrv_aio_readv(s->bs, help->sector, &help->qiov, n,

                              scsi_read_complete, help);

    if (help->req.aiocb == NULL) {

        scsi_read_complete(help, -EIO);

    }

}
",1,1,0,1,r,-0.08649405837059021,1,21,{'r': 'help'},MHM-Origin,22,4.475942114988963
8,"aio_write_f(int argc, char **argv)

{

	char *p;

	int count = 0;

	int nr_iov, i, c;

	int pattern = 0xcd;

	struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((c = getopt(argc, argv, ""CqP:"")) != EOF) {

		switch (c) {

		case 'C':

			ctx->Cflag = 1;

			break;

		case 'q':

			ctx->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	ctx->offset = cvtnum(argv[optind]);

	if (ctx->offset < 0) {

		printf(""non-numeric length argument -- %s\n"", argv[optind]);

		return 0;

	}

	optind++;



	if (ctx->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)ctx->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned\n"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"", argv[i]);

			return 0;

		}

		count += len;

	}



	nr_iov = argc - optind;

	qemu_iovec_init(&ctx->qiov, nr_iov);

	ctx->buf = p = qemu_io_alloc(count, pattern);

	for (i = 0; i < nr_iov; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"",

				argv[optind]);

			return 0;

		}



		qemu_iovec_add(&ctx->qiov, p, len);

		p += len;

		optind++;

	}



	gettimeofday(&ctx->t1, NULL);

	acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,

			      ctx->qiov.size >> 9, aio_write_done, ctx);

	if (!acb)

		return -EIO;



	return 0;

}
",430,"aio_write_f(int argc, char **AV_OPT_TYPE_CONST)

{

	char *p;

	int count = 0;

	int nr_iov, i, TARGET_PAGE_BITS;

	int pattern = 0xcd;

	struct aio_ctx *nb = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((TARGET_PAGE_BITS = getopt(argc, AV_OPT_TYPE_CONST, ""CqP:"")) != EOF) {

		switch (TARGET_PAGE_BITS) {

		case 'C':

			nb->Cflag = 1;

			break;

		case 'q':

			nb->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	nb->offset = cvtnum(AV_OPT_TYPE_CONST[optind]);

	if (nb->offset < 0) {

		printf(""non-numeric length argument -- %s
"", AV_OPT_TYPE_CONST[optind]);

		return 0;

	}

	optind++;



	if (nb->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned
"",

			(long long)nb->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned
"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t features;



		features = cvtnum(AV_OPT_TYPE_CONST[optind]);

		if (features < 0) {

			printf(""non-numeric length argument -- %s
"", AV_OPT_TYPE_CONST[i]);

			return 0;

		}

		count += features;

	}



	nr_iov = argc - optind;

	qemu_iovec_init(&nb->qiov, nr_iov);

	nb->buf = p = qemu_io_alloc(count, pattern);

	for (i = 0; i < nr_iov; i++) {

	        size_t features;



		features = cvtnum(AV_OPT_TYPE_CONST[optind]);

		if (features < 0) {

			printf(""non-numeric length argument -- %s
"",

				AV_OPT_TYPE_CONST[optind]);

			return 0;

		}



		qemu_iovec_add(&nb->qiov, p, features);

		p += features;

		optind++;

	}



	gettimeofday(&nb->t1, NULL);

	acb = bdrv_aio_writev(bs, nb->offset >> 9, &nb->qiov,

			      nb->qiov.size >> 9, aio_write_done, nb);

	if (!acb)

		return -EIO;



	return 0;

}
",0,0,1,1,c,0.036008983850479126,4,35,"{'len': 'features', 'ctx': 'nb', 'argv': 'AV_OPT_TYPE_CONST', 'c': 'TARGET_PAGE_BITS'}",MHM-Origin,105,4.433913171291351
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int r2_name, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += r2_name;

    }

}
",1,1,0,1,linesize,-0.3720974922180176,1,2,{'linesize': 'r2_name'},MHM-Origin,22,4.53708618481954
12,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();",70,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t print_cvtnum_err;
    uint32_t parallel_cpus;
    print_cvtnum_err = T0 | ((uint64_t) (env->y) << 32);
    parallel_cpus = T1;
    print_cvtnum_err = print_cvtnum_err / parallel_cpus;
    if (print_cvtnum_err > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = print_cvtnum_err;
	T1 = 0;
    FORCE_RET();",1,1,1,-1,x0,-0.0017576217651367188,2,9,"{'x0': 'print_cvtnum_err', 'x1': 'parallel_cpus'}",MHM-Origin,406,5.177471709251404
13,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
",26,"void cpu_x86_init_mmu(CPUX86State *vector_fmul_scalar)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(vector_fmul_scalar);

}
",0,0,1,1,env,0.6656311620026827,1,2,{'env': 'vector_fmul_scalar'},MHM-Origin,83,5.091645109653473
14,"int qemu_cpu_self(void *env)

{

    return 1;

}
",12,"int qemu_cpu_self(void *XEN_FLEX_RING_SIZE)

{

    return 1;

}
",0,0,1,1,env,0.6036330051720142,1,1,{'env': 'XEN_FLEX_RING_SIZE'},MHM-Origin,21,5.143768302599589
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
",104,"static void net_vhost_link_down(VhostUserState *meta, bool mbap)

{

    meta->nc.mbap = mbap;



    if (meta->nc.peer) {

        meta->nc.peer->mbap = mbap;

    }



    if (meta->nc.info->link_status_changed) {

        meta->nc.info->link_status_changed(&meta->nc);

    }



    if (meta->nc.peer && meta->nc.peer->info->link_status_changed) {

        meta->nc.peer->info->link_status_changed(meta->nc.peer);

    }

}
",0,0,0,-1,s,-0.02365579828619957,2,16,"{'s': 'LMI_HELPER_1', 'link_down': 'mbap'}",MHM-Origin,409,6.310880815982818
18,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",38,"START_TEST(qint_get_int_test)

{

    QInt *last_pg_state;

    const int value = 123456;



    last_pg_state = qint_from_int(value);

    fail_unless(qint_get_int(last_pg_state) == value);



    QDECREF(last_pg_state);

}
",0,0,0,-1,qi,3.88086773455143e-05,1,4,{'qi': 'last_pg_state'},MHM-Origin,413,6.664582697550456
19,"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
{
    uint8_t symbols[256];
    uint8_t bits[256];
    uint16_t codes[256];
    int num_lens, num_codes, num_codes_sum, prefix;
    int i, j, count;
    prefix        = 0;
    count         = 0;
    num_codes_sum = 0;
    num_lens = get_bits(gb, 5);
    for (i = 0; i < num_lens; i++) {
        num_codes      = get_bits(gb, 9);
        num_codes_sum += num_codes;
        if (num_codes_sum > 256) {
            av_log(ctx->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.\n"", num_codes_sum);
        for (j = 0; j < num_codes; j++) {
            symbols[count] = get_bits(gb, 8);
            bits[count]    = i + 1;
            codes[count]   = prefix++;
            count++;
        if (prefix > (65535 - 256)/2) {
        prefix <<= 1;
    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);",213,"static int read_code_table(CLLCContext *float_flag_invalid, GetBitContext *pix, VLC *coeffsA)
{
    uint8_t sigsetjmp[256];
    uint8_t delayed_samples[256];
    uint16_t codes[256];
    int num_lens, num_codes, xen_pv_printf, SIGP_STAT_INVALID_PARAMETER;
    int PR_SRS, unmap, qemu_input_queue_rel;
    SIGP_STAT_INVALID_PARAMETER        = 0;
    qemu_input_queue_rel         = 0;
    xen_pv_printf = 0;
    num_lens = get_bits(pix, 5);
    for (PR_SRS = 0; PR_SRS < num_lens; PR_SRS++) {
        num_codes      = get_bits(pix, 9);
        xen_pv_printf += num_codes;
        if (xen_pv_printf > 256) {
            av_log(float_flag_invalid->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.
"", xen_pv_printf);
        for (unmap = 0; unmap < num_codes; unmap++) {
            sigsetjmp[qemu_input_queue_rel] = get_bits(pix, 8);
            delayed_samples[qemu_input_queue_rel]    = PR_SRS + 1;
            codes[qemu_input_queue_rel]   = SIGP_STAT_INVALID_PARAMETER++;
            qemu_input_queue_rel++;
        if (SIGP_STAT_INVALID_PARAMETER > (65535 - 256)/2) {
        SIGP_STAT_INVALID_PARAMETER <<= 1;
    return ff_init_vlc_sparse(coeffsA, VLC_BITS, qemu_input_queue_rel, delayed_samples, 1, 1,
                              codes, 2, 2, sigsetjmp, 1, 1, 0);",1,1,1,-1,prefix,0.00013786554336547852,10,40,"{'gb': 'pix', 'j': 'unmap', 'symbols': 'sigsetjmp', 'num_codes_sum': 'xen_pv_printf', 'ctx': 'float_flag_invalid', 'bits': 'delayed_samples', 'vlc': 'coeffsA', 'count': 'qemu_input_queue_rel', 'i': 'PR_SRS', 'prefix': 'SIGP_STAT_INVALID_PARAMETER'}",MHM-Origin,407,9.120287211736043
22,"static void usbredir_bulk_packet(void *priv, uint32_t id,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,

            ep, len, id);



    aurb = async_find(dev, id);

    if (!aurb) {

        free(data);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!\n"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->data, data, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)\n"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(data);

}
",241,"static void usbredir_bulk_packet(void *priv, uint32_t CPUX86State,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *av_pix_fmt_desc_get, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u
"", bulk_packet->status,

            ep, len, CPUX86State);



    aurb = async_find(dev, CPUX86State);

    if (!aurb) {

        free(av_pix_fmt_desc_get);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!
"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", av_pix_fmt_desc_get, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->av_pix_fmt_desc_get, av_pix_fmt_desc_get, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)
"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(av_pix_fmt_desc_get);

}
",1,1,0,1,id,-0.10312420129776001,2,9,"{'data': 'av_pix_fmt_desc_get', 'id': 'CPUX86State'}",MHM-Origin,86,9.53161143064499
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
",167,"static int decode_plte_chunk(AVCodecContext *gen_io_end, PNGDecContext *RV34_MB_P_8x16,

                             uint32_t qemu_clock_get_ns)

{

    int MB_TYPE_16x8, MSR_IA32_MISC_ENABLE, ch, chr_can_read, TCG_TARGET_STACK_ALIGN;



    if ((qemu_clock_get_ns % 3) != 0 || qemu_clock_get_ns > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    MB_TYPE_16x8 = qemu_clock_get_ns / 3;

    for (MSR_IA32_MISC_ENABLE = 0; MSR_IA32_MISC_ENABLE < MB_TYPE_16x8; MSR_IA32_MISC_ENABLE++) {

        ch = bytestream2_get_byte(&RV34_MB_P_8x16->gb);

        chr_can_read = bytestream2_get_byte(&RV34_MB_P_8x16->gb);

        TCG_TARGET_STACK_ALIGN = bytestream2_get_byte(&RV34_MB_P_8x16->gb);

        RV34_MB_P_8x16->palette[MSR_IA32_MISC_ENABLE] = (0xFFU << 24) | (ch << 16) | (chr_can_read << 8) | TCG_TARGET_STACK_ALIGN;

    }

    for (; MSR_IA32_MISC_ENABLE < 256; MSR_IA32_MISC_ENABLE++)

        RV34_MB_P_8x16->palette[MSR_IA32_MISC_ENABLE] = (0xFFU << 24);

    RV34_MB_P_8x16->state |= PNG_PLTE;

    bytestream2_skip(&RV34_MB_P_8x16->gb, 4);     /* crc */



    return 0;

}
",1,1,1,-1,r,-0.01481848955154419,8,33,"{'i': 'MSR_IA32_MISC_ENABLE', 'g': 'chr_can_read', 's': 'RV34_MB_P_8x16', 'n': 'MB_TYPE_16x8', 'length': 'qemu_clock_get_ns', 'b': 'TCG_TARGET_STACK_ALIGN', 'avctx': 'gen_io_end', 'r': 'ch'}",MHM-Origin,409,11.581500542163848
27,"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,

                              char **serial)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;

    DriveInfo *dinfo;



    if (!conf->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(conf->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(conf->bs);

        if (*dinfo->serial) {

            *serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = virtio_blk_reset;

    s->bs = conf->bs;

    s->conf = conf;

    s->serial = *serial;

    s->rq = NULL;

    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);



    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);

    s->qdev = dev;

    register_savevm(dev, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, s);

    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);

    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);



    bdrv_iostatus_enable(s->bs);

    add_boot_device_path(conf->bootindex, dev, ""/disk@0,0"");



    return &s->vdev;

}
",317,"VirtIODevice *virtio_blk_init(DeviceState *smp_threads, BlockConf *error_code,

                              char **info_str)

{

    VirtIOBlock *wctx;

    int AV_RL16, ff_celt_window2, session;

    static int virtio_blk_id;

    DriveInfo *new_area;



    if (!error_code->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(error_code->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*info_str) {

        /* try to fall back to value set with legacy -drive serial=... */

        new_area = drive_get_by_blockdev(error_code->bs);

        if (*new_area->info_str) {

            *info_str = strdup(new_area->info_str);

        }

    }



    wctx = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    wctx->vdev.get_config = virtio_blk_update_config;

    wctx->vdev.get_features = virtio_blk_get_features;

    wctx->vdev.reset = virtio_blk_reset;

    wctx->bs = error_code->bs;

    wctx->error_code = error_code;

    wctx->info_str = *info_str;

    wctx->rq = NULL;

    wctx->sector_mask = (wctx->error_code->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(wctx->bs, &AV_RL16, &ff_celt_window2, &session);



    wctx->vq = virtio_add_queue(&wctx->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, wctx);

    wctx->qdev = smp_threads;

    register_savevm(smp_threads, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, wctx);

    bdrv_set_dev_ops(wctx->bs, &virtio_block_ops, wctx);

    bdrv_set_buffer_alignment(wctx->bs, error_code->logical_block_size);



    bdrv_iostatus_enable(wctx->bs);

    add_boot_device_path(error_code->bootindex, smp_threads, ""/disk@0,0"");



    return &wctx->vdev;

}
",0,0,0,-1,dev,0.028233081102371216,8,53,"{'dev': 'smp_threads', 'cylinders': 'AV_RL16', 'heads': 'ff_celt_window2', 's': 'wctx', 'conf': 'error_code', 'serial': 'info_str', 'secs': 'session', 'dinfo': 'new_area'}",MHM-Origin,411,15.45699961980184
30,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",31,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *MSR_KVM_PV_EOI_EN = container_of(listener, AddressSpaceDispatch, listener);



    MSR_KVM_PV_EOI_EN->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",0,0,1,1,d,0.6952594816684723,1,2,{'d': 'MSR_KVM_PV_EOI_EN'},MHM-Origin,24,14.705671306451162
31,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",218,"static uint32_t tight_palette_buf2rgb(int htab_mask, const uint8_t *iov_size)

{

    uint32_t rgb = 0;



    if (htab_mask == 32) {

        rgb |= ((iov_size[0] & ~1) | !((iov_size[4] >> 3) & 1)) << 24;

        rgb |= ((iov_size[1] & ~1) | !((iov_size[4] >> 2) & 1)) << 16;

        rgb |= ((iov_size[2] & ~1) | !((iov_size[4] >> 1) & 1)) <<  8;

        rgb |= ((iov_size[3] & ~1) | !((iov_size[4] >> 0) & 1)) <<  0;

    }

    if (htab_mask == 16) {

        rgb |= ((iov_size[0] & ~1) | !((iov_size[2] >> 1) & 1)) << 8;

        rgb |= ((iov_size[1] & ~1) | !((iov_size[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",0,0,0,-1,bpp,0.03503997623920441,2,16,"{'bpp': 'htab_mask', 'buf': 'iov_size'}",MHM-Origin,413,16.479921011130013
33,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",135,"void stream_start(const char *bflag, BlockDriverState *bs,

                  BlockDriverState *base, const char *MSR_IA32_XSS,

                  int64_t imsg, BlockdevOnError on_error,

                  BlockCompletionFunc *opt_xfer_len, void *opaque, Error **EXCP03_INT3)

{

    StreamBlockJob *s;



    s = block_job_create(bflag, &stream_job_driver, bs, imsg,

                         opt_xfer_len, opaque, EXCP03_INT3);

    if (!s) {

        return;

    }



    s->base = base;

    s->MSR_IA32_XSS = g_strdup(MSR_IA32_XSS);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",1,1,0,1,cb,-0.5214820504188538,5,11,"{'backing_file_str': 'MSR_IA32_XSS', 'job_id': 'bflag', 'speed': 'imsg', 'errp': 'EXCP03_INT3', 'cb': 'opt_xfer_len'}",MHM-Origin,106,16.76316993633906
34,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    picture->extended_data = picture->data;
    return ret;
}",212,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *sub_packet_cnt, AVFrame *has_fds,
                                              int *ss,
                                              AVPacket *MSIMessage)
{
    int cluster_size;
    *ss = 0;
    if ((sub_packet_cnt->coded_width || sub_packet_cnt->coded_height) && av_image_check_size(sub_packet_cnt->coded_width, sub_packet_cnt->coded_height, 0, sub_packet_cnt))
        return -1;
    sub_packet_cnt->pkt = MSIMessage;
    apply_param_change(sub_packet_cnt, MSIMessage);
    if ((sub_packet_cnt->codec->capabilities & CODEC_CAP_DELAY) || MSIMessage->size || (sub_packet_cnt->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && sub_packet_cnt->active_thread_type & FF_THREAD_FRAME)
            cluster_size = ff_thread_decode_frame(sub_packet_cnt, has_fds, ss,
                                         MSIMessage);
        else {
            cluster_size = sub_packet_cnt->codec->decode(sub_packet_cnt, has_fds, ss,
                                       MSIMessage);
            has_fds->pkt_dts             = MSIMessage->dts;
            has_fds->sample_aspect_ratio = sub_packet_cnt->sample_aspect_ratio;
            has_fds->width               = sub_packet_cnt->width;
            has_fds->height              = sub_packet_cnt->height;
            has_fds->format              = sub_packet_cnt->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*ss)
            sub_packet_cnt->height++;
    } else
        cluster_size = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    has_fds->extended_data = has_fds->data;
    return cluster_size;
}",1,1,0,1,avctx,-0.3521466851234436,6,47,"{'frame_number': 'height', 'got_picture_ptr': 'ss', 'ret': 'cluster_size', 'picture': 'has_fds', 'avctx': 'sub_packet_cnt', 'avpkt': 'MSIMessage'}",MHM-Origin,361,20.188399080435435
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
",117,"static int omap_gpio_init(SysBusDevice *pout)

{

    DeviceState *dev = DEVICE(pout);

    struct omap_gpif_s *MSR_MTRRfix64K_00000 = OMAP1_GPIO(dev);



    if (!MSR_MTRRfix64K_00000->clk) {

        hw_error(""omap-gpio: clk not connected
"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, MSR_MTRRfix64K_00000->omap1.handler, 16);

    sysbus_init_irq(pout, &MSR_MTRRfix64K_00000->omap1.irq);

    memory_region_init_io(&MSR_MTRRfix64K_00000->iomem, OBJECT(MSR_MTRRfix64K_00000), &omap_gpio_ops, &MSR_MTRRfix64K_00000->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(pout, &MSR_MTRRfix64K_00000->iomem);

    return 0;

}
",1,1,0,1,s,-0.3035371005535126,2,12,"{'sbd': 'pout', 's': 'MSR_MTRRfix64K_00000'}",MHM-Origin,43,20.29083961645762
36,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
",52,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *duration_error)

{

    s->codec = duration_error;

    duration_error->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    duration_error->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
",1,1,0,1,slave,-0.4837663769721985,1,4,{'slave': 'duration_error'},MHM-Origin,22,22.144493544101714
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}
",129,"int floatx80_eq(floatx80 tag_tree_decode, floatx80 mapped_len, float_status *rl_inter)

{



    if (    (    ( extractFloatx80Exp( tag_tree_decode ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( tag_tree_decode )<<1 ) )

         || (    ( extractFloatx80Exp( mapped_len ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( mapped_len )<<1 ) )

       ) {

        float_raise(float_flag_invalid, rl_inter);

        return 0;

    }

    return

           ( tag_tree_decode.low == mapped_len.low )

        && (    ( tag_tree_decode.high == mapped_len.high )

             || (    ( tag_tree_decode.low == 0 )

                  && ( (uint16_t) ( ( tag_tree_decode.high | mapped_len.high )<<1 ) == 0 ) )

           );



}
",0,0,0,-1,a,0.004547647200524807,3,15,"{'b': 'mapped_len', 'status': 'rl_inter', 'a': 'tag_tree_decode'}",MHM-Origin,409,24.44850436449051
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
",42,"void json_lexer_init(JSONLexer *CC_OP_MULQ, JSONLexerEmitter data_len)

{

    CC_OP_MULQ->emit = data_len;

    CC_OP_MULQ->state = IN_START;

    CC_OP_MULQ->token = qstring_new();

    CC_OP_MULQ->x = CC_OP_MULQ->y = 0;

}
",0,0,0,-1,lexer,-0.26266613602638245,2,8,"{'func': 'gen_exception_cause', 'lexer': 'CC_OP_MULQ'}",MHM-Origin,414,22.570319906870523
39,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque, int type)

{

    struct qemu_paiocb *acb;



    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!acb)

        return NULL;

    acb->aio_type = type;

    acb->aio_fildes = fd;

    acb->ev_signo = SIGUSR2;

    acb->async_context_id = get_async_context_id();



    if (qiov) {

        acb->aio_iov = qiov->iov;

        acb->aio_niov = qiov->niov;

    }

    acb->aio_nbytes = nb_sectors * 512;

    acb->aio_offset = sector_num * 512;



    acb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = acb;



    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);

    qemu_paio_submit(acb);

    return &acb->common;

}
",163,"BlockDriverAIOCB *paio_submit(BlockDriverState *cpu_x86_update_cr0, int MSR_CORE_PERF_GLOBAL_STATUS,

        int64_t qemu_irq_invert, QEMUIOVector *gen_helper_cpuid, int out_nofid,

        BlockDriverCompletionFunc *prefixes, void *my, int color_cache_put)

{

    struct qemu_paiocb *gen_helper_rdpmc;



    gen_helper_rdpmc = qemu_aio_get(&raw_aio_pool, cpu_x86_update_cr0, prefixes, my);

    if (!gen_helper_rdpmc)

        return NULL;

    gen_helper_rdpmc->aio_type = color_cache_put;

    gen_helper_rdpmc->aio_fildes = MSR_CORE_PERF_GLOBAL_STATUS;

    gen_helper_rdpmc->ev_signo = SIGUSR2;

    gen_helper_rdpmc->async_context_id = get_async_context_id();



    if (gen_helper_cpuid) {

        gen_helper_rdpmc->aio_iov = gen_helper_cpuid->iov;

        gen_helper_rdpmc->aio_niov = gen_helper_cpuid->niov;

    }

    gen_helper_rdpmc->aio_nbytes = out_nofid * 512;

    gen_helper_rdpmc->aio_offset = qemu_irq_invert * 512;



    gen_helper_rdpmc->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = gen_helper_rdpmc;



    trace_paio_submit(gen_helper_rdpmc, my, qemu_irq_invert, out_nofid, color_cache_put);

    qemu_paio_submit(gen_helper_rdpmc);

    return &gen_helper_rdpmc->common;

}
",0,0,1,1,fd,0.38882315903902054,9,38,"{'opaque': 'my', 'bs': 'cpu_x86_update_cr0', 'qiov': 'gen_helper_cpuid', 'sector_num': 'qemu_irq_invert', 'cb': 'prefixes', 'type': 'color_cache_put', 'nb_sectors': 'out_nofid', 'acb': 'gen_helper_rdpmc', 'fd': 'MSR_CORE_PERF_GLOBAL_STATUS'}",MHM-Origin,305,23.663471273581187
43,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *boot_devices,

                        const char *kernel_filename, const char *kernel_cmdline,

                        const char *initrd_filename, const char *cpu_model,

                        const struct hwdef *hwdef)

{

    CPUState *env;

    char *filename;

    m48t59_t *nvram;

    int ret, linux_boot;

    unsigned int i;

    ram_addr_t ram_offset, prom_offset;

    long initrd_size, kernel_size;

    PCIBus *pci_bus, *pci_bus2, *pci_bus3;

    QEMUBH *bh;

    qemu_irq *irq;

    int drive_index;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    void *fw_cfg;

    ResetData *reset_info;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    bh = qemu_bh_new(tick_irq, env);

    env->tick = ptimer_init(bh);

    ptimer_set_period(env->tick, 1ULL);



    bh = qemu_bh_new(stick_irq, env);

    env->stick = ptimer_init(bh);

    ptimer_set_period(env->stick, 1ULL);



    bh = qemu_bh_new(hstick_irq, env);

    env->hstick = ptimer_init(bh);

    ptimer_set_period(env->hstick, 1ULL);



    reset_info = qemu_mallocz(sizeof(ResetData));

    reset_info->env = env;

    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;

    qemu_register_reset(main_cpu_reset, reset_info);

    main_cpu_reset(reset_info);

    // Override warm reset address with cold start address

    env->pc = hwdef->prom_addr + 0x20ULL;

    env->npc = env->pc + 4;



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->prom_addr,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,

                       NULL, NULL, NULL);

        if (ret < 0) {

            ret = load_image_targphys(filename, hwdef->prom_addr,

                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                  TARGET_PAGE_MASK);

        }

        qemu_free(filename);

    } else {

        ret = -1;

    }

    if (ret < 0) {

        fprintf(stderr, ""qemu: could not load prom '%s'\n"",

                bios_name);

        exit(1);

    }



    kernel_size = 0;

    initrd_size = 0;

    if (linux_boot) {

        /* XXX: put correct offset */

        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,

                                    ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              KERNEL_LOAD_ADDR,

                                              ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",

                    kernel_filename);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            initrd_size = load_image_targphys(initrd_filename,

                                              INITRD_LOAD_ADDR,

                                              ram_size - INITRD_LOAD_ADDR);

            if (initrd_size < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'\n"",

                        initrd_filename);

                exit(1);

            }

        }

        if (initrd_size > 0) {

            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {

                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS

                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);

                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);

                    break;

                }

            }

        }

    }

    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,

                           &pci_bus3);

    isa_mem_base = VGA_BASE;

    pci_vga_init(pci_bus, 0, 0);



    // XXX Should be pci_bus3

    pci_ebus_init(pci_bus, -1);



    i = 0;

    if (hwdef->console_serial_base) {

        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,

                       serial_hds[i], 1);

        i++;

    }

    for(; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,

                        serial_hds[i]);

        }

    }



    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {

        if (parallel_hds[i]) {

            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,

                          parallel_hds[i]);

        }

    }



    for(i = 0; i < nb_nics; i++)

        pci_nic_init(&nd_table[i], ""ne2k_pci"", NULL);



    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);

    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus\n"");

        exit(1);

    }

    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,

                                      i % MAX_IDE_DEVS);

       if (drive_index != -1)

           hd[i] = drives_table[drive_index].bdrv;

       else

           hd[i] = NULL;

    }



    pci_cmd646_ide_init(pci_bus, hd, 1);



    /* FIXME: wire up interrupts.  */

    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);

    for(i = 0; i < MAX_FD; i++) {

        drive_index = drive_get_index(IF_FLOPPY, 0, i);

       if (drive_index != -1)

           fd[i] = drives_table[drive_index].bdrv;

       else

           fd[i] = NULL;

    }

    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);

    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);

    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, ""Sun4u"", RAM_size, boot_devices,

                           KERNEL_LOAD_ADDR, kernel_size,

                           kernel_cmdline,

                           INITRD_LOAD_ADDR, initrd_size,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);

    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",1195,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *sysmem,

                        const char *kernel_filename, const char *kernel_cmdline,

                        const char *initrd_filename, const char *log_ctx,

                        const struct hwdef *hwdef)

{

    CPUState *spapr_drc_index;

    char *filename;

    m48t59_t *G_IO_ERR;

    int tone_level_idx_hi1, linux_boot;

    unsigned int model;

    ram_addr_t ram_offset, opc_info;

    long initrd_size, kernel_size;

    PCIBus *pci_bus, *ist_index, *pci_bus3;

    QEMUBH *bh;

    qemu_irq *g2h;

    int CC_A;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    void *do_shiftd;

    ResetData *reset_info;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (!log_ctx)

        log_ctx = hwdef->default_cpu_model;



    spapr_drc_index = cpu_init(log_ctx);

    if (!spapr_drc_index) {

        fprintf(stderr, ""Unable to find Sparc CPU definition
"");

        exit(1);

    }

    bh = qemu_bh_new(tick_irq, spapr_drc_index);

    spapr_drc_index->tick = ptimer_init(bh);

    ptimer_set_period(spapr_drc_index->tick, 1ULL);



    bh = qemu_bh_new(stick_irq, spapr_drc_index);

    spapr_drc_index->stick = ptimer_init(bh);

    ptimer_set_period(spapr_drc_index->stick, 1ULL);



    bh = qemu_bh_new(hstick_irq, spapr_drc_index);

    spapr_drc_index->hstick = ptimer_init(bh);

    ptimer_set_period(spapr_drc_index->hstick, 1ULL);



    reset_info = qemu_mallocz(sizeof(ResetData));

    reset_info->spapr_drc_index = spapr_drc_index;

    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;

    qemu_register_reset(main_cpu_reset, reset_info);

    main_cpu_reset(reset_info);

    // Override warm reset address with cold start address

    spapr_drc_index->pc = hwdef->prom_addr + 0x20ULL;

    spapr_drc_index->npc = spapr_drc_index->pc + 4;



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    opc_info = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->prom_addr,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                 TARGET_PAGE_MASK,

                                 opc_info | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        tone_level_idx_hi1 = load_elf(filename, hwdef->prom_addr - PROM_VADDR,

                       NULL, NULL, NULL);

        if (tone_level_idx_hi1 < 0) {

            tone_level_idx_hi1 = load_image_targphys(filename, hwdef->prom_addr,

                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                  TARGET_PAGE_MASK);

        }

        qemu_free(filename);

    } else {

        tone_level_idx_hi1 = -1;

    }

    if (tone_level_idx_hi1 < 0) {

        fprintf(stderr, ""qemu: could not load prom '%s'
"",

                bios_name);

        exit(1);

    }



    kernel_size = 0;

    initrd_size = 0;

    if (linux_boot) {

        /* XXX: put correct offset */

        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,

                                    ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              KERNEL_LOAD_ADDR,

                                              ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'
"",

                    kernel_filename);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            initrd_size = load_image_targphys(initrd_filename,

                                              INITRD_LOAD_ADDR,

                                              ram_size - INITRD_LOAD_ADDR);

            if (initrd_size < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'
"",

                        initrd_filename);

                exit(1);

            }

        }

        if (initrd_size > 0) {

            for (model = 0; model < 64 * TARGET_PAGE_SIZE; model += TARGET_PAGE_SIZE) {

                if (ldl_phys(KERNEL_LOAD_ADDR + model) == 0x48647253) { // HdrS

                    stl_phys(KERNEL_LOAD_ADDR + model + 16, INITRD_LOAD_ADDR);

                    stl_phys(KERNEL_LOAD_ADDR + model + 20, initrd_size);

                    break;

                }

            }

        }

    }

    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &ist_index,

                           &pci_bus3);

    isa_mem_base = VGA_BASE;

    pci_vga_init(pci_bus, 0, 0);



    // XXX Should be pci_bus3

    pci_ebus_init(pci_bus, -1);



    model = 0;

    if (hwdef->console_serial_base) {

        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,

                       serial_hds[model], 1);

        model++;

    }

    for(; model < MAX_SERIAL_PORTS; model++) {

        if (serial_hds[model]) {

            serial_init(serial_io[model], NULL/*serial_irq[i]*/, 115200,

                        serial_hds[model]);

        }

    }



    for(model = 0; model < MAX_PARALLEL_PORTS; model++) {

        if (parallel_hds[model]) {

            parallel_init(parallel_io[model], NULL/*parallel_irq[i]*/,

                          parallel_hds[model]);

        }

    }



    for(model = 0; model < nb_nics; model++)

        pci_nic_init(&nd_table[model], ""ne2k_pci"", NULL);



    g2h = qemu_allocate_irqs(cpu_set_irq, spapr_drc_index, MAX_PILS);

    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus
"");

        exit(1);

    }

    for(model = 0; model < MAX_IDE_BUS * MAX_IDE_DEVS; model++) {

        CC_A = drive_get_index(IF_IDE, model / MAX_IDE_DEVS,

                                      model % MAX_IDE_DEVS);

       if (CC_A != -1)

           hd[model] = drives_table[CC_A].bdrv;

       else

           hd[model] = NULL;

    }



    pci_cmd646_ide_init(pci_bus, hd, 1);



    /* FIXME: wire up interrupts.  */

    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);

    for(model = 0; model < MAX_FD; model++) {

        CC_A = drive_get_index(IF_FLOPPY, 0, model);

       if (CC_A != -1)

           fd[model] = drives_table[CC_A].bdrv;

       else

           fd[model] = NULL;

    }

    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);

    G_IO_ERR = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);

    sun4u_NVRAM_set_params(G_IO_ERR, NVRAM_SIZE, ""Sun4u"", RAM_size, sysmem,

                           KERNEL_LOAD_ADDR, kernel_size,

                           kernel_cmdline,

                           INITRD_LOAD_ADDR, initrd_size,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    do_shiftd = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i32(do_shiftd, FW_CFG_ID, 1);

    fw_cfg_add_i64(do_shiftd, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(do_shiftd, FW_CFG_MACHINE_ID, hwdef->machine_id);

    fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);

    fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(do_shiftd, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);

    fw_cfg_add_i32(do_shiftd, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(do_shiftd, FW_CFG_BOOT_DEVICE, sysmem[0]);

    qemu_register_boot_set(fw_cfg_boot_set, do_shiftd);

}
",0,0,1,1,fw_cfg,0.17656466364860535,11,99,"{'fw_cfg': 'do_shiftd', 'cpu_model': 'log_ctx', 'env': 'spapr_drc_index', 'prom_offset': 'opc_info', 'ret': 'tone_level_idx_hi1', 'drive_index': 'CC_A', 'nvram': 'G_IO_ERR', 'boot_devices': 'sysmem', 'i': 'model', 'irq': 'g2h', 'pci_bus2': 'ist_index'}",MHM-Origin,369,40.19018164873123
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",116,"static void fpu_init (CPUMIPSState *extractFloatx80Exp, const mips_def_t *rematrixing_flags)

{

    int slice_num;



    for (slice_num = 0; slice_num < MIPS_FPU_MAX; slice_num++)

        extractFloatx80Exp->fpus[slice_num].fcr0 = rematrixing_flags->CP1_fcr0;



    memcpy(&extractFloatx80Exp->active_fpu, &extractFloatx80Exp->fpus[0], sizeof(extractFloatx80Exp->active_fpu));

    if (extractFloatx80Exp->user_mode_only) {

        if (extractFloatx80Exp->CP0_Config1 & (1 << CP0C1_FP))

            extractFloatx80Exp->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (extractFloatx80Exp->active_fpu.fcr0 & (1 << FCR0_F64))

            extractFloatx80Exp->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",0,0,0,-1,def,0.07339738681912422,3,17,"{'def': 'rematrixing_flags', 'i': 'slice_num', 'env': 'extractFloatx80Exp'}",MHM-Origin,407,42.1237973690033
45,"static int bfi_decode_frame(AVCodecContext *avctx, void *data,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *bfi = avctx->priv_data;

    uint8_t *dst = bfi->dst;

    uint8_t *src, *dst_offset, colour1, colour2;

    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;

    uint32_t *pal;

    int i, j, height = avctx->height;



    if (bfi->frame.data[0])

        avctx->release_buffer(avctx, &bfi->frame);



    bfi->frame.reference = 1;



    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        bfi->frame.pict_type = AV_PICTURE_TYPE_I;

        bfi->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.\n"");

            return -1;

        }

        pal = (uint32_t *)bfi->frame.data[1];

        for (i = 0; i < avctx->extradata_size / 3; i++) {

            int shift = 16;

            *pal = 0;

            for (j = 0; j < 3; j++, shift -= 8)

                *pal +=

                    ((avctx->extradata[i * 3 + j] << 2) |

                    (avctx->extradata[i * 3 + j] >> 4)) << shift;

            pal++;

        }

        bfi->frame.palette_has_changed = 1;

    } else {

        bfi->frame.pict_type = AV_PICTURE_TYPE_P;

        bfi->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (dst != frame_end) {

        static const uint8_t lentab[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.\n"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (dst + (length << lentab[code]) > frame_end)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(avctx, AV_LOG_ERROR, ""Frame larger than buffer.\n"");

                return -1;

            }

            bytestream_get_buffer(&buf, dst, length);

            dst += length;

            break;



        case 1:                //Back Chain

            dst_offset = dst - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < bfi->dst)

                break;

            while (length--)

                *dst++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            dst += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *dst++ = colour1;

                *dst++ = colour2;

            }

            break;



        }

    }



    src = bfi->dst;

    dst = bfi->frame.data[0];

    while (height--) {

        memcpy(dst, src, avctx->width);

        src += avctx->width;

        dst += bfi->frame.linesize[0];

    }

    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = bfi->frame;

    return buf_size;

}
",724,"static int bfi_decode_frame(AVCodecContext *avctx, void *virtio_cleanup,

                            int *channel_arrangement, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->virtio_cleanup, *buf_end = avpkt->virtio_cleanup + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *priv = avctx->priv_data;

    uint8_t *me = priv->me;

    uint8_t *IVSHMEM_DPRINTF, *dst_offset, colour1, colour2;

    uint8_t *port_io = priv->me + avctx->width * avctx->eject;

    uint32_t *pal;

    int nb_meta_data_maps, j, eject = avctx->eject;



    if (priv->frame.virtio_cleanup[0])

        avctx->release_buffer(avctx, &priv->frame);



    priv->frame.reference = 1;



    if (avctx->get_buffer(avctx, &priv->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        priv->frame.pict_type = AV_PICTURE_TYPE_I;

        priv->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.
"");

            return -1;

        }

        pal = (uint32_t *)priv->frame.virtio_cleanup[1];

        for (nb_meta_data_maps = 0; nb_meta_data_maps < avctx->extradata_size / 3; nb_meta_data_maps++) {

            int shift = 16;

            *pal = 0;

            for (j = 0; j < 3; j++, shift -= 8)

                *pal +=

                    ((avctx->extradata[nb_meta_data_maps * 3 + j] << 2) |

                    (avctx->extradata[nb_meta_data_maps * 3 + j] >> 4)) << shift;

            pal++;

        }

        priv->frame.palette_has_changed = 1;

    } else {

        priv->frame.pict_type = AV_PICTURE_TYPE_P;

        priv->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (me != port_io) {

        static const uint8_t v16i8[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.
"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (me + (length << v16i8[code]) > port_io)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(avctx, AV_LOG_ERROR, ""Frame larger than buffer.
"");

                return -1;

            }

            bytestream_get_buffer(&buf, me, length);

            me += length;

            break;



        case 1:                //Back Chain

            dst_offset = me - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < priv->me)

                break;

            while (length--)

                *me++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            me += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *me++ = colour1;

                *me++ = colour2;

            }

            break;



        }

    }



    IVSHMEM_DPRINTF = priv->me;

    me = priv->frame.virtio_cleanup[0];

    while (eject--) {

        memcpy(me, IVSHMEM_DPRINTF, avctx->width);

        IVSHMEM_DPRINTF += avctx->width;

        me += priv->frame.linesize[0];

    }

    *channel_arrangement = sizeof(AVFrame);

    *(AVFrame *)virtio_cleanup = priv->frame;

    return buf_size;

}
",1,1,0,1,bfi,-0.12380480766296387,9,63,"{'data': 'virtio_cleanup', 'i': 'nb_meta_data_maps', 'frame_end': 'port_io', 'lentab': 'v16i8', 'src': 'IVSHMEM_DPRINTF', 'height': 'eject', 'data_size': 'channel_arrangement', 'dst': 'me', 'bfi': 'priv'}",MHM-Origin,204,47.26167600552241
46,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !bus->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",553,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *hcall_dprintf = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        hcall_dprintf = qbus_find(path);

        if (!hcall_dprintf) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(hcall_dprintf), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(hcall_dprintf)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        hcall_dprintf = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!hcall_dprintf) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && hcall_dprintf && !hcall_dprintf->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, hcall_dprintf->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (hcall_dprintf) {

        qdev_set_parent_bus(dev, hcall_dprintf);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",1,1,0,1,bus,-0.03539770841598511,1,12,{'bus': 'hcall_dprintf'},MHM-Origin,21,47.035248291492465
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
",24,"void thread_pool_submit(ThreadPoolFunc *output_channels, void *MSR_CORE_PERF_GLOBAL_STATUS)

{

    thread_pool_submit_aio(output_channels, MSR_CORE_PERF_GLOBAL_STATUS, NULL, NULL);

}
",0,0,1,1,arg,0.5652363039553165,2,4,"{'arg': 'MSR_CORE_PERF_GLOBAL_STATUS', 'func': 'output_channels'}",MHM-Origin,225,47.38321937719981
49,"int cpu_exec(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    cc->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        cc = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(cc == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, cpu);

        }

    }



    cc->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",232,"int cpu_exec(CPUState *cpu)

{

    CPUClass *float64_is_signaling_nan = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    float64_is_signaling_nan->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        float64_is_signaling_nan = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(float64_is_signaling_nan == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, cpu);

        }

    }



    float64_is_signaling_nan->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",1,1,0,1,cc,-0.13409394025802612,1,5,{'cc': 'float64_is_signaling_nan'},MHM-Origin,21,48.20742409626643
50,"static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)

{

    int i;

    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&dest->scsw, &src->scsw);



    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {

        dest->esw[i] = cpu_to_be32(src->esw[i]);

    }

    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {

        dest->ecw[i] = cpu_to_be32(src->ecw[i]);

    }

    /* extended measurements enabled? */

    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||

        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {

            dest->emw[i] = cpu_to_be32(src->emw[i]);

        }

    }

}
",245,"static void copy_irb_to_guest(IRB *CC_C, const IRB *mxf_header_partition_pack_key, PMCW *nb_nics)

{

    int _FDT;

    uint16_t stctl = mxf_header_partition_pack_key->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = mxf_header_partition_pack_key->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&CC_C->scsw, &mxf_header_partition_pack_key->scsw);



    for (_FDT = 0; _FDT < ARRAY_SIZE(CC_C->esw); _FDT++) {

        CC_C->esw[_FDT] = cpu_to_be32(mxf_header_partition_pack_key->esw[_FDT]);

    }

    for (_FDT = 0; _FDT < ARRAY_SIZE(CC_C->ecw); _FDT++) {

        CC_C->ecw[_FDT] = cpu_to_be32(mxf_header_partition_pack_key->ecw[_FDT]);

    }

    /* extended measurements enabled? */

    if ((mxf_header_partition_pack_key->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(nb_nics->flags & PMCW_FLAGS_MASK_TF) ||

        !(nb_nics->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (_FDT = 0; _FDT < ARRAY_SIZE(CC_C->emw); _FDT++) {

            CC_C->emw[_FDT] = cpu_to_be32(mxf_header_partition_pack_key->emw[_FDT]);

        }

    }

}
",0,0,0,-1,dest,-0.001003846526145935,4,35,"{'src': 'mxf_header_partition_pack_key', 'dest': 'CC_C', 'pmcw': 'nb_nics', 'i': '_FDT'}",MHM-Origin,412,51.10867716471354
51,"static int process_input_packet(InputStream *ist, const AVPacket *pkt)

{

    int i;

    int got_output;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &got_output);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (pkt) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",599,"static int process_input_packet(InputStream *ist, const AVPacket *MSR_P6_PERFCTR0)

{

    int i;

    int IS_16X8;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (MSR_P6_PERFCTR0 == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *MSR_P6_PERFCTR0;

    }



    if (MSR_P6_PERFCTR0->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(MSR_P6_PERFCTR0->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!MSR_P6_PERFCTR0 && IS_16X8))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != MSR_P6_PERFCTR0->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d
"", MSR_P6_PERFCTR0->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &IS_16X8);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &IS_16X8);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &IS_16X8);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (MSR_P6_PERFCTR0) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!IS_16X8) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; MSR_P6_PERFCTR0 && i < nb_output_streams; i++) {

        OutputStream *qemu_free = output_streams[i];



        if (!check_output_constraints(ist, qemu_free) || qemu_free->encoding_needed)

            continue;



        do_streamcopy(ist, qemu_free, MSR_P6_PERFCTR0);

    }



    return 0;

}
",0,0,1,1,got_output,0.046218663454055786,3,21,"{'pkt': 'MSR_P6_PERFCTR0', 'ost': 'qemu_free', 'got_output': 'IS_16X8'}",MHM-Origin,63,51.94660217761994
54,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *pkt_data,

                                           size_t pkt_len)

{

    struct virtio_net_hdr *vhdr;

    bool isip4, isip6, istcp, isudp;

    uint8_t *data;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vhdr);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, vhdr->csum_start, vhdr->csum_offset);

        return;

    }



    data = (uint8_t *)pkt_data + vhdr->csum_start;

    len = pkt_len - vhdr->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));



    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",204,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *ic,

                                           size_t target_phys_addr_t)

{

    struct virtio_net_hdr *tcg_gen_sub_tl;

    bool tile_height, is_streamed, cpu_handle_halt, tcg_gen_trunc_tl_i32;

    uint8_t *S390CPU;

    int CPU_GET_CLASS;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    tcg_gen_sub_tl = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(tcg_gen_sub_tl->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &tile_height, &is_streamed, &tcg_gen_trunc_tl_i32, &cpu_handle_halt);

    if (!(tile_height || is_streamed) || !(cpu_handle_halt || tcg_gen_trunc_tl_i32)) {

        return;

    }



    vmxnet3_dump_virt_hdr(tcg_gen_sub_tl);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (target_phys_addr_t < (tcg_gen_sub_tl->csum_start + tcg_gen_sub_tl->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  CPU_GET_CLASS, tcg_gen_sub_tl->csum_start, tcg_gen_sub_tl->csum_offset);

        return;

    }



    S390CPU = (uint8_t *)ic + tcg_gen_sub_tl->csum_start;

    CPU_GET_CLASS = target_phys_addr_t - tcg_gen_sub_tl->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(S390CPU + tcg_gen_sub_tl->csum_offset, net_raw_checksum(S390CPU, CPU_GET_CLASS));



    tcg_gen_sub_tl->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    tcg_gen_sub_tl->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",1,1,1,-1,isip6,0.07132935523986816,9,38,"{'pkt_data': 'ic', 'isudp': 'tcg_gen_trunc_tl_i32', 'pkt_len': 'target_phys_addr_t', 'isip6': 'is_streamed', 'vhdr': 'tcg_gen_sub_tl', 'data': 'S390CPU', 'isip4': 'tile_height', 'len': 'CPU_GET_CLASS', 'istcp': 'cpu_handle_halt'}",MHM-Origin,414,55.69440915584564
56,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *div_blocks,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int s;



        bd[0].block_length = div_blocks[b];

        bd[1].block_length = div_blocks[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!\n"");



            for (s = 0; s < div_blocks[b]; s++)

                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];

        } else if (bd[1].js_blocks) {

            for (s = 0; s < div_blocks[b]; s++)

                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];

        }



        offset  += div_blocks[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",720,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *VNC_SHARE_MODE_SHARED,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int gen_helper_fisttll_ST0;



        bd[0].block_length = VNC_SHARE_MODE_SHARED[b];

        bd[1].block_length = VNC_SHARE_MODE_SHARED[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, VNC_SHARE_MODE_SHARED, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, VNC_SHARE_MODE_SHARED, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!
"");



            for (gen_helper_fisttll_ST0 = 0; gen_helper_fisttll_ST0 < VNC_SHARE_MODE_SHARED[b]; gen_helper_fisttll_ST0++)

                bd[0].raw_samples[gen_helper_fisttll_ST0] = bd[1].raw_samples[gen_helper_fisttll_ST0] - bd[0].raw_samples[gen_helper_fisttll_ST0];

        } else if (bd[1].js_blocks) {

            for (gen_helper_fisttll_ST0 = 0; gen_helper_fisttll_ST0 < VNC_SHARE_MODE_SHARED[b]; gen_helper_fisttll_ST0++)

                bd[1].raw_samples[gen_helper_fisttll_ST0] = bd[1].raw_samples[gen_helper_fisttll_ST0] + bd[0].raw_samples[gen_helper_fisttll_ST0];

        }



        offset  += VNC_SHARE_MODE_SHARED[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",1,1,0,1,div_blocks,-0.40138867497444153,2,21,"{'s': 'gen_helper_fisttll_ST0', 'div_blocks': 'VNC_SHARE_MODE_SHARED'}",MHM-Origin,43,61.26068427960078

Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,No. Changed Names,No. Changed Tokens,Replaced Names,Attack Type,Query Times,Time Cost
0,"static USBDevice *usb_net_init(const char *cmdline)

{

    USBDevice *dev;

    QemuOpts *opts;

    int idx;



    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);

    if (!opts) {



    qemu_opt_set(opts, ""type"", ""nic"");

    qemu_opt_set(opts, ""model"", ""usb"");



    idx = net_client_init(NULL, opts, 0);

    if (idx == -1) {





    dev = usb_create(NULL /* FIXME */, ""usb-net"");




    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);

    qdev_init_nofail(&dev->qdev);

    return dev;
",115,"static USBDevice *usb_net__set(const char *cmdstring)

{

    USBDevice *id;

    QemuOpts * opns;

    int IdX;



     opns = qemu_opts_parse(&qemu_net_opts, cmdstring, NULL);

    if (! opns) {



    qemu_opt_set( opns, ""type"", ""nic"");

    qemu_opt_set( opns, ""model"", ""usb"");



    IdX = net_client_init(NULL,  opns, 0);

    if (IdX == -1) {





    id = usb_create(NULL /* FIXME */, ""usb-net"");




    qdev_set_nic_properties(&id->qdev, &nd_table[IdX]);

    qdev_init_nofail(&id->qdev);

    return id;
",1,1,1,-1,"usb_net_init,cmdline,dev,opts,idx","usb_net_init:-2.676248550415039e-05,cmdline:-6.121397018432617e-05,dev:-3.5703182220458984e-05,opts:-0.00012052059173583984,idx:0.0005771517753601074,",5,18,"idx:IdX,usb_net_init:usb_net__set,dev:id,cmdline:cmdstring,opts: opns,",Greedy,198,0.041816747188568114
1,"static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt,

                              int dump_payload, AVRational time_base)

{

    HEXDUMP_PRINT(""stream #%d:\n"", pkt->stream_index);

    HEXDUMP_PRINT(""  keyframe=%d\n"", (pkt->flags & AV_PKT_FLAG_KEY) != 0);

    HEXDUMP_PRINT(""  duration=%0.3f\n"", pkt->duration * av_q2d(time_base));

    /* DTS is _always_ valid after av_read_frame() */

    HEXDUMP_PRINT(""  dts="");

    if (pkt->dts == AV_NOPTS_VALUE)

        HEXDUMP_PRINT(""N/A"");

    else

        HEXDUMP_PRINT(""%0.3f"", pkt->dts * av_q2d(time_base));

    /* PTS may not be known if B-frames are present. */

    HEXDUMP_PRINT(""  pts="");

    if (pkt->pts == AV_NOPTS_VALUE)

        HEXDUMP_PRINT(""N/A"");

    else

        HEXDUMP_PRINT(""%0.3f"", pkt->pts * av_q2d(time_base));

    HEXDUMP_PRINT(""\n"");

    HEXDUMP_PRINT(""  size=%d\n"", pkt->size);

    if (dump_payload)

        av_hex_dump(f, pkt->data, pkt->size);

}
",174,,1,0,,-4,"avcl,f,level,pkt,dump_payload,time_base",,,,,Greedy,1,0.0020531098047892253
2,"static void handle_mousewheel(SDL_Event *ev)

{

    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);

    SDL_MouseWheelEvent *wev = &ev->wheel;

    InputButton btn;



    if (wev->y > 0) {

        btn = INPUT_BUTTON_WHEEL_UP;

    } else if (wev->y < 0) {

        btn = INPUT_BUTTON_WHEEL_DOWN;

    } else {

        return;

    }



    qemu_input_queue_btn(scon->dcl.con, btn, true);

    qemu_input_event_sync();

    qemu_input_queue_btn(scon->dcl.con, btn, false);

    qemu_input_event_sync();

}
",104,"static void handle_mousewheel(SDL_Event *model)

{

    struct sdl2_console *sCON = get_scon_from_window(model->key.windowID);

    SDL_MouseWheelEvent *pex = &model->wheel;

    InputButton fw;



    if (pex->y > 0) {

        fw = INPUT_BUTTON_WHEEL_UP;

    } else if (pex->y < 0) {

        fw = INPUT_BUTTON_WHEEL_DOWN;

    } else {

        return;

    }



    qemu_input_queue_btn(sCON->dcl.con, fw, true);

    qemu_input_event_sync();

    qemu_input_queue_btn(sCON->dcl.con, fw, false);

    qemu_input_event_sync();

}
",0,0,0,-1,"ev,scon,wev,btn","ev:0.021153215318918228,scon:0.012001384049654007,wev:0.012707661837339401,btn:0.00019266270101070404,",4,14,"ev:model,wev:pex,scon:sCON,btn:fw,",Greedy,197,0.0351592501004537
3,"static void init_virtio_dev(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);



    qvirtio_set_driver_ok(&dev->vdev);

}
",110,"static void init_virtio_dev(TestServer *s)

{

    QPCIBus *http;

    QVirtioPCIDevice *dn;

    uint32_t options;



    http = qpci_init_pc(NULL);

    g_assert_nonnull(http);



    dn = qvirtio_pci_device_find(http, VIRTIO_ID_NET);

    g_assert_nonnull(dn);



    qvirtio_pci_device_enable(dn);

    qvirtio_reset(&dn->vdev);

    qvirtio_set_acknowledge(&dn->vdev);

    qvirtio_set_driver(&dn->vdev);



    options = qvirtio_get_features(&dn->vdev);

    options = options & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dn->vdev, options);



    qvirtio_set_driver_ok(&dn->vdev);

}
",1,1,0,1,"s,bus,dev,features","s:0.0209236741065979,bus:0.08533495664596558,dev:0.1529914140701294,features:0.06521874666213989,",3,19,"dev:dn,bus:http,features:options,",Greedy,193,0.033928473790486656
4,"int av_packet_split_side_data(AVPacket *pkt){

    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){

        int i;

        unsigned int size;

        uint8_t *p;



        p = pkt->data + pkt->size - 8 - 5;

        for (i=1; ; i++){

            size = AV_RB32(p);

            if (size>INT_MAX || p - pkt->data < size)

                return 0;

            if (p[4]&128)

                break;

            p-= size+5;

        }



        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));

        if (!pkt->side_data)

            return AVERROR(ENOMEM);



        p= pkt->data + pkt->size - 8 - 5;

        for (i=0; ; i++){

            size= AV_RB32(p);

            av_assert0(size<=INT_MAX && p - pkt->data >= size);

            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);

            pkt->side_data[i].size = size;

            pkt->side_data[i].type = p[4]&127;

            if (!pkt->side_data[i].data)

                return AVERROR(ENOMEM);

            memcpy(pkt->side_data[i].data, p-size, size);

            pkt->size -= size + 5;

            if(p[4]&128)

                break;

            p-= size+5;

        }

        pkt->size -= 8;

        pkt->side_data_elems = i+1;

        return 1;

    }

    return 0;

}
",319,"int av_packet_split_side_data(AVPacket *fpkt){

    if (!fpkt->side_data_elems && fpkt->loc >12 && AV_RB64(fpkt->data + fpkt->loc - 8) == FF_MERGE_MARKER){

        int interface;

        unsigned int loc;

        uint8_t *cp;



        cp = fpkt->data + fpkt->loc - 8 - 5;

        for (interface=1; ; interface++){

            loc = AV_RB32(cp);

            if (loc>INT_MAX || cp - fpkt->data < loc)

                return 0;

            if (cp[4]&128)

                break;

            cp-= loc+5;

        }



        fpkt->side_data = av_malloc_array(interface, sizeof(*fpkt->side_data));

        if (!fpkt->side_data)

            return AVERROR(ENOMEM);



        cp= fpkt->data + fpkt->loc - 8 - 5;

        for (interface=0; ; interface++){

            loc= AV_RB32(cp);

            av_assert0(loc<=INT_MAX && cp - fpkt->data >= loc);

            fpkt->side_data[interface].data = av_mallocz(loc + AV_INPUT_BUFFER_PADDING_SIZE);

            fpkt->side_data[interface].loc = loc;

            fpkt->side_data[interface].type = cp[4]&127;

            if (!fpkt->side_data[interface].data)

                return AVERROR(ENOMEM);

            memcpy(fpkt->side_data[interface].data, cp-loc, loc);

            fpkt->loc -= loc + 5;

            if(cp[4]&128)

                break;

            cp-= loc+5;

        }

        fpkt->loc -= 8;

        fpkt->side_data_elems = interface+1;

        return 1;

    }

    return 0;

}
",1,1,1,-1,"pkt,i,size,p","pkt:0.0251924991607666,i:-0.06566965579986572,size:-0.16837888956069946,p:-0.08913320302963257,",4,68,"pkt:fpkt,i:interface,p:cp,size:loc,",Greedy,457,0.08048981825510661
5,"static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);

    scsi_req_cancel(s->req);

}
",34,,1,0,,-4,"dev,p,s",,,,,Greedy,1,0.002323329448699951
6,"ram_addr_t ppc405_set_bootinfo (CPUState *env, ppc4xx_bd_info_t *bd,

                                uint32_t flags)

{

    ram_addr_t bdloc;

    int i, n;



    /* We put the bd structure at the top of memory */

    if (bd->bi_memsize >= 0x01000000UL)

        bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t);

    else

        bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t);

    stl_phys(bdloc + 0x00, bd->bi_memstart);

    stl_phys(bdloc + 0x04, bd->bi_memsize);

    stl_phys(bdloc + 0x08, bd->bi_flashstart);

    stl_phys(bdloc + 0x0C, bd->bi_flashsize);

    stl_phys(bdloc + 0x10, bd->bi_flashoffset);

    stl_phys(bdloc + 0x14, bd->bi_sramstart);

    stl_phys(bdloc + 0x18, bd->bi_sramsize);

    stl_phys(bdloc + 0x1C, bd->bi_bootflags);

    stl_phys(bdloc + 0x20, bd->bi_ipaddr);

    for (i = 0; i < 6; i++)

        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);

    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);

    stl_phys(bdloc + 0x2C, bd->bi_intfreq);

    stl_phys(bdloc + 0x30, bd->bi_busfreq);

    stl_phys(bdloc + 0x34, bd->bi_baudrate);

    for (i = 0; i < 4; i++)

        stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]);

    for (i = 0; i < 32; i++)

        stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]);

    stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq);

    stl_phys(bdloc + 0x60, bd->bi_pci_busfreq);

    for (i = 0; i < 6; i++)

        stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]);

    n = 0x6A;

    if (flags & 0x00000001) {

        for (i = 0; i < 6; i++)

            stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]);

    }

    stl_phys(bdloc + n, bd->bi_opbfreq);

    n += 4;

    for (i = 0; i < 2; i++) {

        stl_phys(bdloc + n, bd->bi_iic_fast[i]);

        n += 4;

    }



    return bdloc;

}
",427,,1,0,,-4,"env,bd,flags,bdloc,i,n",,,,,Greedy,1,0.002241965134938558
7,"bool virtio_ipl_disk_is_valid(void)

{

    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}
",22,,0,0,,-3,,,,,,Greedy,1,0.0018921971321105957
8,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
",80,"static void bdrv_password_cb(Monitor *mon, const char *patch, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, patch) != 0) {

        monitor_printf(mon, ""invalid password
"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
",0,0,1,1,"mon,password,opaque,bs","mon:0.06767180562019348,password:0.10038790106773376,opaque:-0.10699814558029175,bs:0.06773078441619873,",1,2,"password:patch,",Greedy,52,0.01168673038482666
9,"dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,

                    enum dshowDeviceType devtype, IBaseFilter **pfilter)

{

    struct dshow_ctx *ctx = avctx->priv_data;

    IBaseFilter *device_filter = NULL;

    IEnumMoniker *classenum = NULL;

    IMoniker *m = NULL;

    const char *device_name = ctx->device_name[devtype];

    int skip = (devtype == VideoDevice) ? ctx->video_device_number

                                        : ctx->audio_device_number;

    int r;



    const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory,

                                   &CLSID_AudioInputDeviceCategory };

    const char *devtypename = (devtype == VideoDevice) ? ""video"" : ""audio"";



    r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype],

                                             (IEnumMoniker **) &classenum, 0);

    if (r != S_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Could not enumerate %s devices.\n"",

               devtypename);

        return AVERROR(EIO);

    }



    while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) {

        IPropertyBag *bag = NULL;

        char *buf = NULL;

        VARIANT var;



        r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &bag);

        if (r != S_OK)

            goto fail1;



        var.vt = VT_BSTR;

        r = IPropertyBag_Read(bag, L""FriendlyName"", &var, NULL);

        if (r != S_OK)

            goto fail1;



        buf = dup_wchar_to_utf8(var.bstrVal);



        if (pfilter) {

            if (strcmp(device_name, buf))

                goto fail1;



            if (!skip--)

                IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter);

        } else {

            av_log(avctx, AV_LOG_INFO, "" \""%s\""\n"", buf);

        }



fail1:

        if (buf)

            av_free(buf);

        if (bag)

            IPropertyBag_Release(bag);

        IMoniker_Release(m);

    }



    IEnumMoniker_Release(classenum);



    if (pfilter) {

        if (!device_filter) {

            av_log(avctx, AV_LOG_ERROR, ""Could not find %s device.\n"",

                   devtypename);

            return AVERROR(EIO);

        }

        *pfilter = device_filter;

    }



    return 0;

}
",396,"dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,

                    enum dshowDeviceType devtype, IBaseFilter **pfilter)

{

    struct dshow_ctx *ctx = avctx->priv_data;

    IBaseFilter *device_Filter = NULL;

    IEnumMoniker *classenum = NULL;

    IMoniker *m = NULL;

    const char *device_name = ctx->device_name[devtype];

    int skip = (devtype == VideoDevice) ? ctx->video_device_number

                                        : ctx->audio_device_number;

    int r;



    const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory,

                                   &CLSID_AudioInputDeviceCategory };

    const char *devtypename = (devtype == VideoDevice) ? ""video"" : ""audio"";



    r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype],

                                             (IEnumMoniker **) &classenum, 0);

    if (r != S_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Could not enumerate %s devices.
"",

               devtypename);

        return AVERROR(EIO);

    }



    while (!device_Filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) {

        IPropertyBag *bag = NULL;

        char *buf = NULL;

        VARIANT var;



        r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &bag);

        if (r != S_OK)

            goto fail1;



        var.vt = VT_BSTR;

        r = IPropertyBag_Read(bag, L""FriendlyName"", &var, NULL);

        if (r != S_OK)

            goto fail1;



        buf = dup_wchar_to_utf8(var.bstrVal);



        if (pfilter) {

            if (strcmp(device_name, buf))

                goto fail1;



            if (!skip--)

                IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_Filter);

        } else {

            av_log(avctx, AV_LOG_INFO, "" \""%s\""
"", buf);

        }



fail1:

        if (buf)

            av_free(buf);

        if (bag)

            IPropertyBag_Release(bag);

        IMoniker_Release(m);

    }



    IEnumMoniker_Release(classenum);



    if (pfilter) {

        if (!device_Filter) {

            av_log(avctx, AV_LOG_ERROR, ""Could not find %s device.
"",

                   devtypename);

            return AVERROR(EIO);

        }

        *pfilter = device_Filter;

    }



    return 0;

}
",0,0,1,1,"ctx,device_filter,classenum,m,device_name,r,device_guid,devtypename,bag,buf,var,skip","ctx:-0.006083428859710693,device_filter:0.044563621282577515,classenum:0.01718217134475708,m:-0.048211246728897095,device_name:0.015567928552627563,r:0.02640274167060852,device_guid:-0.05042940378189087,devtypename:-0.03756043314933777,bag:0.004909127950668335,buf:-0.041424691677093506,var:-0.03992736339569092,skip:0.018849879503250122,",1,5,"device_filter:device_Filter,",Greedy,74,0.01691006819407145
10,"static int do_decode(AVCodecContext *avctx, AVPacket *pkt)

{

    int got_frame;

    int ret;



    av_assert0(!avctx->internal->buffer_frame->buf[0]);



    if (!pkt)

        pkt = avctx->internal->buffer_pkt;



    // This is the lesser evil. The field is for compatibility with legacy users

    // of the legacy API, and users using the new API should not be forced to

    // even know about this field.

    avctx->refcounted_frames = 1;



    // Some codecs (at least wma lossless) will crash when feeding drain packets

    // after EOF was signaled.

    if (avctx->internal->draining_done)

        return AVERROR_EOF;



    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {

        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,

                                    &got_frame, pkt);

        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))

            ret = pkt->size;

    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {

        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,

                                    &got_frame, pkt);

    } else {

        ret = AVERROR(EINVAL);

    }



    if (ret == AVERROR(EAGAIN))

        ret = pkt->size;



    if (ret < 0)

        return ret;



    if (avctx->internal->draining && !got_frame)

        avctx->internal->draining_done = 1;



    if (ret >= pkt->size) {

        av_packet_unref(avctx->internal->buffer_pkt);

    } else {

        int consumed = ret;



        if (pkt != avctx->internal->buffer_pkt) {

            av_packet_unref(avctx->internal->buffer_pkt);

            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)

                return ret;

        }



        avctx->internal->buffer_pkt->data += consumed;

        avctx->internal->buffer_pkt->size -= consumed;

        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;

        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;

    }



    if (got_frame)

        av_assert0(avctx->internal->buffer_frame->buf[0]);



    return 0;

}
",327,,0,1,,-4,"avctx,pkt,got_frame,ret",,,,,Greedy,1,0.0021210392316182453
11,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
",88,"void net_host_device_remove(Monitor *mut, int vlan_id, const char *device)

{

    VLANState *vlas;

    VLANClientState *dev;



    vlas = qemu_find_vlan(vlan_id);



   for(dev = vlas->first_client; dev != NULL; dev = dev->next)

        if (!strcmp(dev->name, device))

            break;



    if (!dev) {

        monitor_printf(mut, ""can't find device %s
"", device);

        return;

    }

    qemu_del_vlan_client(dev);

}
",0,0,1,1,"mon,vlan_id,device,vlan,vc","mon:0.04597333073616028,vlan_id:0.019971147179603577,device:0.02432035654783249,vlan:0.12061195075511932,vc:0.13135309517383575,",3,13,"vc:dev,vlan:vlas,mon:mut,",Greedy,152,0.02770047982533773
12,"static void vfio_bar_write(void *opaque, hwaddr addr,

                           uint64_t data, unsigned size)

{

    VFIOBAR *bar = opaque;

    union {

        uint8_t byte;

        uint16_t word;

        uint32_t dword;

        uint64_t qword;

    } buf;



    switch (size) {

    case 1:

        buf.byte = data;

        break;

    case 2:

        buf.word = cpu_to_le16(data);

        break;

    case 4:

        buf.dword = cpu_to_le32(data);

        break;

    default:

        hw_error(""vfio: unsupported write size, %d bytes\n"", size);

        break;

    }



    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {

        error_report(""%s(,0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d) failed: %m"",

                     __func__, addr, data, size);

    }



    DPRINTF(""%s(BAR%d+0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d)\n"",

            __func__, bar->nr, addr, data, size);



    /*

     * A read or write to a BAR always signals an INTx EOI.  This will

     * do nothing if not pending (including not in INTx mode).  We assume

     * that a BAR access is in response to an interrupt and that BAR

     * accesses will service the interrupt.  Unfortunately, we don't know

     * which access will service the interrupt, so we're potentially

     * getting quite a few host interrupts per guest interrupt.

     */

    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));

}
",184,"static void vfio_bar_write(void *OPaque, hwaddr addr,

                           uint64_t batch, unsigned end)

{

    VFIOBAR *camp = OPaque;

    union {

        uint8_t byte;

        uint16_t word;

        uint32_t dword;

        uint64_t qword;

    } obj;



    switch (end) {

    case 1:

        obj.byte = batch;

        break;

    case 2:

        obj.word = cpu_to_le16(batch);

        break;

    case 4:

        obj.dword = cpu_to_le32(batch);

        break;

    default:

        hw_error(""vfio: unsupported write size, %d bytes
"", end);

        break;

    }



    if (pwrite(camp->fd, &obj, end, camp->fd_offset + addr) != end) {

        error_report(""%s(,0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d) failed: %m"",

                     __func__, addr, batch, end);

    }



    DPRINTF(""%s(BAR%d+0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d)
"",

            __func__, camp->nr, addr, batch, end);



    /*

     * A read or write to a BAR always signals an INTx EOI.  This will

     * do nothing if not pending (including not in INTx mode).  We assume

     * that a BAR access is in response to an interrupt and that BAR

     * accesses will service the interrupt.  Unfortunately, we don't know

     * which access will service the interrupt, so we're potentially

     * getting quite a few host interrupts per guest interrupt.

     */

    vfio_eoi(container_of(camp, VFIODevice, bars[camp->nr]));

}
",0,0,1,1,"opaque,addr,data,size,bar,buf","opaque:0.03670614957809448,addr:-0.07366107404232025,data:-0.06595934927463531,size:0.056197136640548706,bar:-0.04305174946784973,buf:0.2973792999982834,",5,26,"buf:obj,size:end,opaque:OPaque,bar:camp,data:batch,",Greedy,294,0.05556156635284424
13,"static void mcf5208evb_init(QEMUMachineInitArgs *args)

{

    ram_addr_t ram_size = args->ram_size;

    const char *cpu_model = args->cpu_model;

    const char *kernel_filename = args->kernel_filename;

    CPUM68KState *env;

    int kernel_size;

    uint64_t elf_entry;

    target_phys_addr_t entry;

    qemu_irq *pic;

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    MemoryRegion *sram = g_new(MemoryRegion, 1);



    if (!cpu_model)

        cpu_model = ""m5208"";

    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find m68k CPU definition\n"");

        exit(1);

    }



    /* Initialize CPU registers.  */

    env->vbr = 0;

    /* TODO: Configure BARs.  */



    /* DRAM at 0x40000000 */

    memory_region_init_ram(ram, ""mcf5208.ram"", ram_size);

    vmstate_register_ram_global(ram);

    memory_region_add_subregion(address_space_mem, 0x40000000, ram);



    /* Internal SRAM.  */

    memory_region_init_ram(sram, ""mcf5208.sram"", 16384);

    vmstate_register_ram_global(sram);

    memory_region_add_subregion(address_space_mem, 0x80000000, sram);



    /* Internal peripherals.  */

    pic = mcf_intc_init(address_space_mem, 0xfc048000, env);



    mcf_uart_mm_init(address_space_mem, 0xfc060000, pic[26], serial_hds[0]);

    mcf_uart_mm_init(address_space_mem, 0xfc064000, pic[27], serial_hds[1]);

    mcf_uart_mm_init(address_space_mem, 0xfc068000, pic[28], serial_hds[2]);



    mcf5208_sys_init(address_space_mem, pic);



    if (nb_nics > 1) {

        fprintf(stderr, ""Too many NICs\n"");

        exit(1);

    }

    if (nd_table[0].used)

        mcf_fec_init(address_space_mem, &nd_table[0],

                     0xfc030000, pic + 36);



    /*  0xfc000000 SCM.  */

    /*  0xfc004000 XBS.  */

    /*  0xfc008000 FlexBus CS.  */

    /* 0xfc030000 FEC.  */

    /*  0xfc040000 SCM + Power management.  */

    /*  0xfc044000 eDMA.  */

    /* 0xfc048000 INTC.  */

    /*  0xfc058000 I2C.  */

    /*  0xfc05c000 QSPI.  */

    /* 0xfc060000 UART0.  */

    /* 0xfc064000 UART0.  */

    /* 0xfc068000 UART0.  */

    /*  0xfc070000 DMA timers.  */

    /* 0xfc080000 PIT0.  */

    /* 0xfc084000 PIT1.  */

    /*  0xfc088000 EPORT.  */

    /*  0xfc08c000 Watchdog.  */

    /*  0xfc090000 clock module.  */

    /*  0xfc0a0000 CCM + reset.  */

    /*  0xfc0a4000 GPIO.  */

    /* 0xfc0a8000 SDRAM controller.  */



    /* Load kernel.  */

    if (!kernel_filename) {

        fprintf(stderr, ""Kernel image must be specified\n"");

        exit(1);

    }



    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,

                           NULL, NULL, 1, ELF_MACHINE, 0);

    entry = elf_entry;

    if (kernel_size < 0) {

        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);

    }

    if (kernel_size < 0) {

        kernel_size = load_image_targphys(kernel_filename, 0x40000000,

                                          ram_size);

        entry = 0x40000000;

    }

    if (kernel_size < 0) {

        fprintf(stderr, ""qemu: could not load kernel '%s'\n"", kernel_filename);

        exit(1);

    }



    env->pc = entry;

}
",411,"static void mcf5208evb_init(QEMUMachineInitArgs *args)

{

    ram_addr_t ram_size = args->ram_size;

    const char *cpu_model = args->cpu_model;

    const char *kernel_filename = args->kernel_filename;

    CPUM68KState *err;

    int kernel_size;

    uint64_t elf_entry;

    target_phys_addr_t entry;

    qemu_irq *doc;

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    MemoryRegion *sram = g_new(MemoryRegion, 1);



    if (!cpu_model)

        cpu_model = ""m5208"";

    err = cpu_init(cpu_model);

    if (!err) {

        fprintf(stderr, ""Unable to find m68k CPU definition
"");

        exit(1);

    }



    /* Initialize CPU registers.  */

    err->vbr = 0;

    /* TODO: Configure BARs.  */



    /* DRAM at 0x40000000 */

    memory_region_init_ram(ram, ""mcf5208.ram"", ram_size);

    vmstate_register_ram_global(ram);

    memory_region_add_subregion(address_space_mem, 0x40000000, ram);



    /* Internal SRAM.  */

    memory_region_init_ram(sram, ""mcf5208.sram"", 16384);

    vmstate_register_ram_global(sram);

    memory_region_add_subregion(address_space_mem, 0x80000000, sram);



    /* Internal peripherals.  */

    doc = mcf_intc_init(address_space_mem, 0xfc048000, err);



    mcf_uart_mm_init(address_space_mem, 0xfc060000, doc[26], serial_hds[0]);

    mcf_uart_mm_init(address_space_mem, 0xfc064000, doc[27], serial_hds[1]);

    mcf_uart_mm_init(address_space_mem, 0xfc068000, doc[28], serial_hds[2]);



    mcf5208_sys_init(address_space_mem, doc);



    if (nb_nics > 1) {

        fprintf(stderr, ""Too many NICs
"");

        exit(1);

    }

    if (nd_table[0].used)

        mcf_fec_init(address_space_mem, &nd_table[0],

                     0xfc030000, doc + 36);



    /*  0xfc000000 SCM.  */

    /*  0xfc004000 XBS.  */

    /*  0xfc008000 FlexBus CS.  */

    /* 0xfc030000 FEC.  */

    /*  0xfc040000 SCM + Power management.  */

    /*  0xfc044000 eDMA.  */

    /* 0xfc048000 INTC.  */

    /*  0xfc058000 I2C.  */

    /*  0xfc05c000 QSPI.  */

    /* 0xfc060000 UART0.  */

    /* 0xfc064000 UART0.  */

    /* 0xfc068000 UART0.  */

    /*  0xfc070000 DMA timers.  */

    /* 0xfc080000 PIT0.  */

    /* 0xfc084000 PIT1.  */

    /*  0xfc088000 EPORT.  */

    /*  0xfc08c000 Watchdog.  */

    /*  0xfc090000 clock module.  */

    /*  0xfc0a0000 CCM + reset.  */

    /*  0xfc0a4000 GPIO.  */

    /* 0xfc0a8000 SDRAM controller.  */



    /* Load kernel.  */

    if (!kernel_filename) {

        fprintf(stderr, ""Kernel image must be specified
"");

        exit(1);

    }



    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,

                           NULL, NULL, 1, ELF_MACHINE, 0);

    entry = elf_entry;

    if (kernel_size < 0) {

        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);

    }

    if (kernel_size < 0) {

        kernel_size = load_image_targphys(kernel_filename, 0x40000000,

                                          ram_size);

        entry = 0x40000000;

    }

    if (kernel_size < 0) {

        fprintf(stderr, ""qemu: could not load kernel '%s'
"", kernel_filename);

        exit(1);

    }



    err->pc = entry;

}
",0,0,1,1,"args,cpu_model,kernel_filename,env,kernel_size,elf_entry,entry,pic,address_space_mem,ram,sram","args:0.1306518018245697,cpu_model:0.11398554593324661,kernel_filename:0.06874264776706696,env:0.25366614013910294,kernel_size:0.009200461208820343,elf_entry:0.005408637225627899,entry:0.05888798087835312,pic:0.23357939720153809,address_space_mem:0.06989666819572449,ram:0.1447886824607849,sram:0.006896890699863434,",2,13,"env:err,pic:doc,",Greedy,196,0.039486523469289145
14,"static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)

{

    QObject *token;

    const char *val;



    if (ap == NULL) {

        return NULL;

    }



    token = parser_context_pop_token(ctxt);

    assert(token && token_get_type(token) == JSON_ESCAPE);

    val = token_get_value(token);



    if (!strcmp(val, ""%p"")) {

        return va_arg(*ap, QObject *);

    } else if (!strcmp(val, ""%i"")) {

        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%ld"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long)));

    } else if (!strcmp(val, ""%lld"") ||

               !strcmp(val, ""%I64d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long long)));

    } else if (!strcmp(val, ""%s"")) {

        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));

    } else if (!strcmp(val, ""%f"")) {

        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));

    }

    return NULL;

}
",273,"static QObject *parse_escape(JSONParserContext *cfXT, va_list *xml)

{

    QObject *document;

    const char *true;



    if (xml == NULL) {

        return NULL;

    }



    document = parser_context_pop_token(cfXT);

    assert(document && token_get_type(document) == JSON_ESCAPE);

    true = token_get_value(document);



    if (!strcmp(true, ""%p"")) {

        return va_arg(*xml, QObject *);

    } else if (!strcmp(true, ""%i"")) {

        return QOBJECT(qbool_from_bool(va_arg(*xml, int)));

    } else if (!strcmp(true, ""%d"")) {

        return QOBJECT(qint_from_int(va_arg(*xml, int)));

    } else if (!strcmp(true, ""%ld"")) {

        return QOBJECT(qint_from_int(va_arg(*xml, long)));

    } else if (!strcmp(true, ""%lld"") ||

               !strcmp(true, ""%I64d"")) {

        return QOBJECT(qint_from_int(va_arg(*xml, long long)));

    } else if (!strcmp(true, ""%s"")) {

        return QOBJECT(qstring_from_str(va_arg(*xml, const char *)));

    } else if (!strcmp(true, ""%f"")) {

        return QOBJECT(qfloat_from_double(va_arg(*xml, double)));

    }

    return NULL;

}
",0,0,0,-1,"ctxt,ap,token,val","ctxt:0.0005234843119978905,ap:-0.0010556569322943687,token:0.00117484200745821,val:-0.0015947157517075539,",4,26,"token:document,ctxt:cfXT,ap:xml,val:true,",Greedy,234,0.044591073195139566
15,"static inline uint64_t ldq_phys_internal(hwaddr addr,

                                         enum device_endian endian)

{

    uint8_t *ptr;

    uint64_t val;

    MemoryRegionSection *section;



    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);



    if (!(memory_region_is_ram(section->mr) ||

          memory_region_is_romd(section->mr))) {

        /* I/O case */

        addr = memory_region_section_addr(section, addr);



        /* XXX This is broken when device endian != cpu endian.

               Fix and add ""endian"" variable check */

#ifdef TARGET_WORDS_BIGENDIAN

        val = io_mem_read(section->mr, addr, 4) << 32;

        val |= io_mem_read(section->mr, addr + 4, 4);

#else

        val = io_mem_read(section->mr, addr, 4);

        val |= io_mem_read(section->mr, addr + 4, 4) << 32;

#endif

    } else {

        /* RAM case */

        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)

                                & TARGET_PAGE_MASK)

                               + memory_region_section_addr(section, addr));

        switch (endian) {

        case DEVICE_LITTLE_ENDIAN:

            val = ldq_le_p(ptr);

            break;

        case DEVICE_BIG_ENDIAN:

            val = ldq_be_p(ptr);

            break;

        default:

            val = ldq_p(ptr);

            break;

        }

    }

    return val;

}
",202,"static inline uint64_t ldq_phys_internal(hwaddr r,

                                         enum device_endian endip)

{

    uint8_t *r;

    uint64_t err;

    MemoryRegionSection *connection;



    connection = phys_page_find(address_space_memory.dispatch, r >> TARGET_PAGE_BITS);



    if (!(memory_region_is_ram(connection->mr) ||

          memory_region_is_romd(connection->mr))) {

        /* I/O case */

        r = memory_region_section_addr(connection, r);



        /* XXX This is broken when device endian != cpu endian.

               Fix and add ""endian"" variable check */

#ifdef TARGET_WORDS_BIGENDIAN

        err = io_mem_read(connection->mr, r, 4) << 32;

        err |= io_mem_read(connection->mr, r + 4, 4);

#else

        err = io_mem_read(connection->mr, r, 4);

        err |= io_mem_read(connection->mr, r + 4, 4) << 32;

#endif

    } else {

        /* RAM case */

        r = qemu_get_ram_ptr((memory_region_get_ram_addr(connection->mr)

                                & TARGET_PAGE_MASK)

                               + memory_region_section_addr(connection, r));

        switch (endip) {

        case DEVICE_LITTLE_ENDIAN:

            err = ldq_le_p(r);

            break;

        case DEVICE_BIG_ENDIAN:

            err = ldq_be_p(r);

            break;

        default:

            err = ldq_p(r);

            break;

        }

    }

    return err;

}
",0,0,0,-1,"addr,endian,ptr,val,section","addr:0.00017961859703063965,endian:-0.00012473482638597488,ptr:-4.849536344408989e-05,val:-0.00014230143278837204,section:0.00024082977324724197,",5,36,"section:connection,addr:r,ptr:r,endian:endip,val:err,",Greedy,338,0.06070470412572225
16,"void main_loop_wait(int nonblocking)

{

    fd_set rfds, wfds, xfds;

    int ret, nfds;

    struct timeval tv;

    int timeout;



    if (nonblocking)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    os_host_main_loop_wait(&timeout);



    tv.tv_sec = timeout / 1000;

    tv.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&rfds);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);

    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);

    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
",197,"void main_loop_wait(int nonblocking)

{

    fd_set rfds, wfds, cfds;

    int ret, wfd;

    struct timeval html;

    int timeout;



    if (nonblocking)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    os_host_main_loop_wait(&timeout);



    html.tv_sec = timeout / 1000;

    html.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    wfd = -1;

    FD_ZERO(&rfds);

    FD_ZERO(&wfds);

    FD_ZERO(&cfds);

    qemu_iohandler_fill(&wfd, &rfds, &wfds, &cfds);

    slirp_select_fill(&wfd, &rfds, &wfds, &cfds);



    qemu_mutex_unlock_iothread();

    ret = select(wfd + 1, &rfds, &wfds, &cfds, &html);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&rfds, &wfds, &cfds, ret);

    slirp_select_poll(&rfds, &wfds, &cfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
",0,0,1,1,"nonblocking,rfds,wfds,xfds,ret,nfds,tv,timeout","nonblocking:-0.017943426966667175,rfds:0.030234292149543762,wfds:0.06179787218570709,xfds:0.08660896122455597,ret:0.023059308528900146,nfds:0.0901942253112793,tv:0.08671332895755768,timeout:-0.21453720331192017,",3,16,"nfds:wfd,tv:html,xfds:cfds,",Greedy,238,0.04191210667292277
17,"void bdrv_invalidate_cache_all(Error **errp)

{

    BlockDriverState *bs;

    Error *local_err = NULL;

    BdrvNextIterator *it = NULL;



    while ((it = bdrv_next(it, &bs)) != NULL) {

        AioContext *aio_context = bdrv_get_aio_context(bs);



        aio_context_acquire(aio_context);

        bdrv_invalidate_cache(bs, &local_err);

        aio_context_release(aio_context);

        if (local_err) {

            error_propagate(errp, local_err);

            return;

        }

    }

}
",86,,1,0,,-4,"errp,bs,local_err,it,aio_context",,,,,Greedy,1,0.002148588498433431
18,"static int parse_adaptation_sets(AVFormatContext *s)

{

    WebMDashMuxContext *w = s->priv_data;

    char *p = w->adaptation_sets;

    char *q;

    enum { new_set, parsed_id, parsing_streams } state;

    if (!w->adaptation_sets) {

        av_log(s, AV_LOG_ERROR, ""The 'adaptation_sets' option must be set.\n"");

        return AVERROR(EINVAL);

    }

    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on

    state = new_set;

    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {

        if (*p == ' ')

            continue;

        else if (state == new_set && !strncmp(p, ""id="", 3)) {

            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));

            if (mem == NULL)

                return AVERROR(ENOMEM);

            w->as = mem;

            ++w->nb_as;

            w->as[w->nb_as - 1].nb_streams = 0;

            w->as[w->nb_as - 1].streams = NULL;

            p += 3; // consume ""id=""

            q = w->as[w->nb_as - 1].id;

            while (*p != ',') *q++ = *p++;

            *q = 0;

            p++;

            state = parsed_id;

        } else if (state == parsed_id && !strncmp(p, ""streams="", 8)) {

            p += 8; // consume ""streams=""

            state = parsing_streams;

        } else if (state == parsing_streams) {

            struct AdaptationSet *as = &w->as[w->nb_as - 1];

            q = p;

            while (*q != '\0' && *q != ',' && *q != ' ') q++;

            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);

            if (as->streams == NULL)

                return AVERROR(ENOMEM);

            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);

            if (as->streams[as->nb_streams - 1] < 0) return -1;

            if (*q == '\0') break;

            if (*q == ' ') state = new_set;

            p = ++q;

        } else {

            return -1;

        }

    }

    return 0;

}
",440,,1,0,,-4,"s,w,p,q,state,mem,as,nb_as",,,,,Greedy,1,0.0021626989046732584
19,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",139,,1,0,,-4,"ctxt,token,ret",,,,,Greedy,1,0.002112416426340739
20,"static int aac_encode_frame(AVCodecContext *avctx,

                            uint8_t *frame, int buf_size, void *data)

{

    AACEncContext *s = avctx->priv_data;

    int16_t *samples = s->samples, *samples2, *la;

    ChannelElement *cpe;

    int i, j, chans, tag, start_ch;

    const uint8_t *chan_map = aac_chan_configs[avctx->channels-1];

    int chan_el_counter[4];

    FFPsyWindowInfo windows[AAC_MAX_CHANNELS];



    if (s->last_frame)

        return 0;

    if (data) {

        if (!s->psypp) {

            memcpy(s->samples + 1024 * avctx->channels, data,

                   1024 * avctx->channels * sizeof(s->samples[0]));

        } else {

            start_ch = 0;

            samples2 = s->samples + 1024 * avctx->channels;

            for (i = 0; i < chan_map[0]; i++) {

                tag = chan_map[i+1];

                chans = tag == TYPE_CPE ? 2 : 1;

                ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch,

                                  samples2 + start_ch, start_ch, chans);

                start_ch += chans;

            }

        }

    }

    if (!avctx->frame_number) {

        memcpy(s->samples, s->samples + 1024 * avctx->channels,

               1024 * avctx->channels * sizeof(s->samples[0]));

        return 0;

    }



    start_ch = 0;

    for (i = 0; i < chan_map[0]; i++) {

        FFPsyWindowInfo* wi = windows + start_ch;

        tag      = chan_map[i+1];

        chans    = tag == TYPE_CPE ? 2 : 1;

        cpe      = &s->cpe[i];

        for (j = 0; j < chans; j++) {

            IndividualChannelStream *ics = &cpe->ch[j].ics;

            int k;

            int cur_channel = start_ch + j;

            samples2 = samples + cur_channel;

            la       = samples2 + (448+64) * avctx->channels;

            if (!data)

                la = NULL;

            if (tag == TYPE_LFE) {

                wi[j].window_type[0] = ONLY_LONG_SEQUENCE;

                wi[j].window_shape   = 0;

                wi[j].num_windows    = 1;

                wi[j].grouping[0]    = 1;

            } else {

                wi[j] = ff_psy_suggest_window(&s->psy, samples2, la, cur_channel,

                                              ics->window_sequence[0]);

            }

            ics->window_sequence[1] = ics->window_sequence[0];

            ics->window_sequence[0] = wi[j].window_type[0];

            ics->use_kb_window[1]   = ics->use_kb_window[0];

            ics->use_kb_window[0]   = wi[j].window_shape;

            ics->num_windows        = wi[j].num_windows;

            ics->swb_sizes          = s->psy.bands    [ics->num_windows == 8];

            ics->num_swb            = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8];

            for (k = 0; k < ics->num_windows; k++)

                ics->group_len[k] = wi[j].grouping[k];



            apply_window_and_mdct(avctx, s, &cpe->ch[j], samples2);

        }

        start_ch += chans;

    }

    do {

        int frame_bits;

        init_put_bits(&s->pb, frame, buf_size*8);

        if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT))

            put_bitstream_info(avctx, s, LIBAVCODEC_IDENT);

        start_ch = 0;

        memset(chan_el_counter, 0, sizeof(chan_el_counter));

        for (i = 0; i < chan_map[0]; i++) {

            FFPsyWindowInfo* wi = windows + start_ch;

            tag      = chan_map[i+1];

            chans    = tag == TYPE_CPE ? 2 : 1;

            cpe      = &s->cpe[i];

            put_bits(&s->pb, 3, tag);

            put_bits(&s->pb, 4, chan_el_counter[tag]++);

            for (j = 0; j < chans; j++) {

                s->cur_channel = start_ch + j;

                ff_psy_set_band_info(&s->psy, s->cur_channel, cpe->ch[j].coeffs, &wi[j]);

                s->coder->search_for_quantizers(avctx, s, &cpe->ch[j], s->lambda);

            }

            cpe->common_window = 0;

            if (chans > 1

                && wi[0].window_type[0] == wi[1].window_type[0]

                && wi[0].window_shape   == wi[1].window_shape) {



                cpe->common_window = 1;

                for (j = 0; j < wi[0].num_windows; j++) {

                    if (wi[0].grouping[j] != wi[1].grouping[j]) {

                        cpe->common_window = 0;

                        break;

                    }

                }

            }

            s->cur_channel = start_ch;

            if (cpe->common_window && s->coder->search_for_ms)

                s->coder->search_for_ms(s, cpe, s->lambda);

            adjust_frame_information(s, cpe, chans);

            if (chans == 2) {

                put_bits(&s->pb, 1, cpe->common_window);

                if (cpe->common_window) {

                    put_ics_info(s, &cpe->ch[0].ics);

                    encode_ms_info(&s->pb, cpe);

                }

            }

            for (j = 0; j < chans; j++) {

                s->cur_channel = start_ch + j;

                encode_individual_channel(avctx, s, &cpe->ch[j], cpe->common_window);

            }

            start_ch += chans;

        }



        frame_bits = put_bits_count(&s->pb);

        if (frame_bits <= 6144 * avctx->channels - 3) {

            s->psy.bitres.bits = frame_bits / avctx->channels;

            break;

        }



        s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits;



    } while (1);



    put_bits(&s->pb, 3, TYPE_END);

    flush_put_bits(&s->pb);

    avctx->frame_bits = put_bits_count(&s->pb);



    // rate control stuff

    if (!(avctx->flags & CODEC_FLAG_QSCALE)) {

        float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits;

        s->lambda *= ratio;

        s->lambda = FFMIN(s->lambda, 65536.f);

    }



    if (!data)

        s->last_frame = 1;

    memcpy(s->samples, s->samples + 1024 * avctx->channels,

           1024 * avctx->channels * sizeof(s->samples[0]));

    return put_bits_count(&s->pb)>>3;

}
",1304,,0,1,,-4,"avctx,frame,buf_size,data,s,samples,samples2,la,cpe,i,j,chans,tag,start_ch,chan_map,chan_el_counter,windows,wi,ics,k",,,,,Greedy,1,0.0025867223739624023
21,"static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic,

                                const uint8_t *src, int src_size)

{

    GetByteContext gb;

    GetBitContext  gb2;

    int nslices, slice, slice_height, ref_slice_height;

    int cur_y, next_y;

    uint32_t off, slice_size;

    uint8_t *Y, *U, *V;

    int ret;



    bytestream2_init(&gb, src, src_size);

    nslices = bytestream2_get_le16(&gb);

    off = FFALIGN(nslices * 4 + 2, 16);

    if (src_size < off) {

        av_log(avctx, AV_LOG_ERROR, ""no slice data\n"");

        return AVERROR_INVALIDDATA;

    }



    if (!nslices || avctx->height % nslices) {

        avpriv_request_sample(avctx, ""%d slices for %dx%d"", nslices,

                              avctx->width, avctx->height);

        return AVERROR_PATCHWELCOME;

    }



    ref_slice_height = avctx->height / nslices;

    if ((avctx->width & 1) || (avctx->height & 1)) {

        avpriv_request_sample(avctx, ""Frame dimensions %dx%d"",

                              avctx->width, avctx->height);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV420P;

    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)

        return ret;



    Y = pic->data[0];

    U = pic->data[1];

    V = pic->data[2];



    cur_y  = 0;

    next_y = ref_slice_height;

    for (slice = 0; slice < nslices; slice++) {

        slice_size   = bytestream2_get_le32(&gb);

        slice_height = (next_y & ~1) - (cur_y & ~1);

        if (slice_size > src_size - off) {

            av_log(avctx, AV_LOG_ERROR,

                   ""invalid slice size %""PRIu32"" (only %""PRIu32"" bytes left)\n"",

                   slice_size, src_size - off);

            return AVERROR_INVALIDDATA;

        }

        if (slice_size <= 16) {

            av_log(avctx, AV_LOG_ERROR, ""invalid slice size %""PRIu32""\n"", slice_size);

            return AVERROR_INVALIDDATA;

        }



        if (AV_RL32(src + off) != slice_size - 16) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Slice sizes mismatch: got %""PRIu32"" instead of %""PRIu32""\n"",

                   AV_RL32(src + off), slice_size - 16);

        }

        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);

        dx2_decode_slice_420(&gb2, avctx->width, slice_height, Y, U, V,

                             pic->linesize[0], pic->linesize[1],

                             pic->linesize[2]);



        Y += pic->linesize[0] *  slice_height;

        U += pic->linesize[1] * (slice_height >> 1);

        V += pic->linesize[2] * (slice_height >> 1);

        off += slice_size;

        cur_y   = next_y;

        next_y += ref_slice_height;

    }



    return 0;

}
",508,,0,1,,-4,"avctx,pic,src,src_size,gb,gb2,nslices,slice,slice_height,ref_slice_height,cur_y,next_y,off,slice_size,Y,U,V,ret",,,,,Greedy,1,0.0022192120552062987
22,"static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr,

                         GetBitContext *gb, SBRData *ch_data)

{

    int i;

    unsigned bs_pointer = 0;

    // frameLengthFlag ? 15 : 16; 960 sample length frames unsupported; this value is numTimeSlots

    int abs_bord_trail = 16;

    int num_rel_lead, num_rel_trail;

    unsigned bs_num_env_old = ch_data->bs_num_env;



    ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env];

    ch_data->bs_amp_res = sbr->bs_amp_res_header;

    ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old];



    switch (ch_data->bs_frame_class = get_bits(gb, 2)) {

    case FIXFIX:

        ch_data->bs_num_env                 = 1 << get_bits(gb, 2);

        num_rel_lead                        = ch_data->bs_num_env - 1;

        if (ch_data->bs_num_env == 1)

            ch_data->bs_amp_res = 0;



        if (ch_data->bs_num_env > 4) {

            av_log(ac->avccontext, AV_LOG_ERROR,

                   ""Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\n"",

                   ch_data->bs_num_env);

            return -1;

        }



        ch_data->t_env[0]                   = 0;

        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;



        abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) /

                   ch_data->bs_num_env;

        for (i = 0; i < num_rel_lead; i++)

            ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail;



        ch_data->bs_freq_res[1] = get_bits1(gb);

        for (i = 1; i < ch_data->bs_num_env; i++)

            ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1];

        break;

    case FIXVAR:

        abs_bord_trail                     += get_bits(gb, 2);

        num_rel_trail                       = get_bits(gb, 2);

        ch_data->bs_num_env                 = num_rel_trail + 1;

        ch_data->t_env[0]                   = 0;

        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;



        for (i = 0; i < num_rel_trail; i++)

            ch_data->t_env[ch_data->bs_num_env - 1 - i] =

                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;



        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);



        for (i = 0; i < ch_data->bs_num_env; i++)

            ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb);

        break;

    case VARFIX:

        ch_data->t_env[0]                   = get_bits(gb, 2);

        num_rel_lead                        = get_bits(gb, 2);

        ch_data->bs_num_env                 = num_rel_lead + 1;

        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;



        for (i = 0; i < num_rel_lead; i++)

            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;



        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);



        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);

        break;

    case VARVAR:

        ch_data->t_env[0]                   = get_bits(gb, 2);

        abs_bord_trail                     += get_bits(gb, 2);

        num_rel_lead                        = get_bits(gb, 2);

        num_rel_trail                       = get_bits(gb, 2);

        ch_data->bs_num_env                 = num_rel_lead + num_rel_trail + 1;

        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;



        if (ch_data->bs_num_env > 5) {

            av_log(ac->avccontext, AV_LOG_ERROR,

                   ""Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\n"",

                   ch_data->bs_num_env);

            return -1;

        }



        for (i = 0; i < num_rel_lead; i++)

            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;

        for (i = 0; i < num_rel_trail; i++)

            ch_data->t_env[ch_data->bs_num_env - 1 - i] =

                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;



        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);



        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);

        break;

    }



    if (bs_pointer > ch_data->bs_num_env + 1) {

        av_log(ac->avccontext, AV_LOG_ERROR,

               ""Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\n"",

               bs_pointer);

        return -1;

    }



    ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1;



    ch_data->t_q[0]                     = ch_data->t_env[0];

    ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env];

    if (ch_data->bs_num_noise > 1) {

        unsigned int idx;

        if (ch_data->bs_frame_class == FIXFIX) {

            idx = ch_data->bs_num_env >> 1;

        } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR

            idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1);

        } else { // VARFIX

            if (!bs_pointer)

                idx = 1;

            else if (bs_pointer == 1)

                idx = ch_data->bs_num_env - 1;

            else // bs_pointer > 1

                idx = bs_pointer - 1;

        }

        ch_data->t_q[1] = ch_data->t_env[idx];

    }



    ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); // l_APrev

    ch_data->e_a[1] = -1;

    if ((ch_data->bs_frame_class & 1) && bs_pointer) { // FIXVAR or VARVAR and bs_pointer != 0

        ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer;

    } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) // VARFIX and bs_pointer > 1

        ch_data->e_a[1] = bs_pointer - 1;



    return 0;

}
",1020,,0,1,,-4,"ac,sbr,gb,ch_data,i,num_rel_lead,num_rel_trail",,,,,Greedy,1,0.0023020505905151367
23,"static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *async, uint32_t *int_mask)

{

    int len = 0, max_len, err, ret;

    uint8_t pid;



    max_len = ((td->token >> 21) + 1) & 0x7ff;

    pid = td->token & 0xff;



    ret = async->packet.result;



    if (td->ctrl & TD_CTRL_IOS)

        td->ctrl &= ~TD_CTRL_ACTIVE;



    if (ret < 0)

        goto out;



    len = async->packet.result;

    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);



    /* The NAK bit may have been set by a previous frame, so clear it

       here.  The docs are somewhat unclear, but win2k relies on this

       behavior.  */

    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);

    if (td->ctrl & TD_CTRL_IOC)

        *int_mask |= 0x01;



    if (pid == USB_TOKEN_IN) {

        if (len > max_len) {

            ret = USB_RET_BABBLE;

            goto out;

        }



        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {

            *int_mask |= 0x02;

            /* short packet: do not update QH */

            trace_usb_uhci_packet_complete_shortxfer(async->queue->token,

                                                    async->td);

            return TD_RESULT_NEXT_QH;

        }

    }



    /* success */

    trace_usb_uhci_packet_complete_success(async->queue->token, async->td);

    return TD_RESULT_COMPLETE;



out:

    /*

     * We should not do any further processing on a queue with errors!

     * This is esp. important for bulk endpoints with pipelining enabled

     * (redirection to a real USB device), where we must cancel all the

     * transfers after this one so that:

     * 1) If they've completed already, they are not processed further

     *    causing more stalls, originating from the same failed transfer

     * 2) If still in flight, they are cancelled before the guest does

     *    a clear stall, otherwise the guest and device can loose sync!

     */

    while (!QTAILQ_EMPTY(&async->queue->asyncs)) {

        UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs);

        uhci_async_unlink(as);

        uhci_async_cancel(as);

    }



    switch(ret) {

    case USB_RET_STALL:

        td->ctrl |= TD_CTRL_STALL;

        td->ctrl &= ~TD_CTRL_ACTIVE;

        s->status |= UHCI_STS_USBERR;

        if (td->ctrl & TD_CTRL_IOC) {

            *int_mask |= 0x01;

        }

        uhci_update_irq(s);

        trace_usb_uhci_packet_complete_stall(async->queue->token, async->td);

        return TD_RESULT_NEXT_QH;



    case USB_RET_BABBLE:

        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;

        td->ctrl &= ~TD_CTRL_ACTIVE;

        s->status |= UHCI_STS_USBERR;

        if (td->ctrl & TD_CTRL_IOC) {

            *int_mask |= 0x01;

        }

        uhci_update_irq(s);

        /* frame interrupted */

        trace_usb_uhci_packet_complete_babble(async->queue->token, async->td);

        return TD_RESULT_STOP_FRAME;



    case USB_RET_NAK:

        td->ctrl |= TD_CTRL_NAK;

        if (pid == USB_TOKEN_SETUP)

            break;

        return TD_RESULT_NEXT_QH;



    case USB_RET_IOERROR:

    case USB_RET_NODEV:

    default:

	break;

    }



    /* Retry the TD if error count is not zero */



    td->ctrl |= TD_CTRL_TIMEOUT;

    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;

    if (err != 0) {

        err--;

        if (err == 0) {

            td->ctrl &= ~TD_CTRL_ACTIVE;

            s->status |= UHCI_STS_USBERR;

            if (td->ctrl & TD_CTRL_IOC)

                *int_mask |= 0x01;

            uhci_update_irq(s);

            trace_usb_uhci_packet_complete_error(async->queue->token,

                                                 async->td);

        }

    }

    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |

        (err << TD_CTRL_ERROR_SHIFT);

    return TD_RESULT_NEXT_QH;

}
",525,"static int uhci_complete_td(UHCIState *s, UHCI_TD *bd, UHCIAsync *async, uint32_t *int_mask)

{

    int len = 0, max_len, err, mem;

    uint8_t pid;



    max_len = ((bd->token >> 21) + 1) & 0x7ff;

    pid = bd->token & 0xff;



    mem = async->packet.result;



    if (bd->ctrl & TD_CTRL_IOS)

        bd->ctrl &= ~TD_CTRL_ACTIVE;



    if (mem < 0)

        goto out;



    len = async->packet.result;

    bd->ctrl = (bd->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);



    /* The NAK bit may have been set by a previous frame, so clear it

       here.  The docs are somewhat unclear, but win2k relies on this

       behavior.  */

    bd->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);

    if (bd->ctrl & TD_CTRL_IOC)

        *int_mask |= 0x01;



    if (pid == USB_TOKEN_IN) {

        if (len > max_len) {

            mem = USB_RET_BABBLE;

            goto out;

        }



        if ((bd->ctrl & TD_CTRL_SPD) && len < max_len) {

            *int_mask |= 0x02;

            /* short packet: do not update QH */

            trace_usb_uhci_packet_complete_shortxfer(async->queue->token,

                                                    async->bd);

            return TD_RESULT_NEXT_QH;

        }

    }



    /* success */

    trace_usb_uhci_packet_complete_success(async->queue->token, async->bd);

    return TD_RESULT_COMPLETE;



out:

    /*

     * We should not do any further processing on a queue with errors!

     * This is esp. important for bulk endpoints with pipelining enabled

     * (redirection to a real USB device), where we must cancel all the

     * transfers after this one so that:

     * 1) If they've completed already, they are not processed further

     *    causing more stalls, originating from the same failed transfer

     * 2) If still in flight, they are cancelled before the guest does

     *    a clear stall, otherwise the guest and device can loose sync!

     */

    while (!QTAILQ_EMPTY(&async->queue->asyncs)) {

        UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs);

        uhci_async_unlink(as);

        uhci_async_cancel(as);

    }



    switch(mem) {

    case USB_RET_STALL:

        bd->ctrl |= TD_CTRL_STALL;

        bd->ctrl &= ~TD_CTRL_ACTIVE;

        s->status |= UHCI_STS_USBERR;

        if (bd->ctrl & TD_CTRL_IOC) {

            *int_mask |= 0x01;

        }

        uhci_update_irq(s);

        trace_usb_uhci_packet_complete_stall(async->queue->token, async->bd);

        return TD_RESULT_NEXT_QH;



    case USB_RET_BABBLE:

        bd->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;

        bd->ctrl &= ~TD_CTRL_ACTIVE;

        s->status |= UHCI_STS_USBERR;

        if (bd->ctrl & TD_CTRL_IOC) {

            *int_mask |= 0x01;

        }

        uhci_update_irq(s);

        /* frame interrupted */

        trace_usb_uhci_packet_complete_babble(async->queue->token, async->bd);

        return TD_RESULT_STOP_FRAME;



    case USB_RET_NAK:

        bd->ctrl |= TD_CTRL_NAK;

        if (pid == USB_TOKEN_SETUP)

            break;

        return TD_RESULT_NEXT_QH;



    case USB_RET_IOERROR:

    case USB_RET_NODEV:

    default:

	break;

    }



    /* Retry the TD if error count is not zero */



    bd->ctrl |= TD_CTRL_TIMEOUT;

    err = (bd->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;

    if (err != 0) {

        err--;

        if (err == 0) {

            bd->ctrl &= ~TD_CTRL_ACTIVE;

            s->status |= UHCI_STS_USBERR;

            if (bd->ctrl & TD_CTRL_IOC)

                *int_mask |= 0x01;

            uhci_update_irq(s);

            trace_usb_uhci_packet_complete_error(async->queue->token,

                                                 async->bd);

        }

    }

    bd->ctrl = (bd->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |

        (err << TD_CTRL_ERROR_SHIFT);

    return TD_RESULT_NEXT_QH;

}
",0,0,1,1,"s,td,async,int_mask,max_len,err,ret,pid,as","s:-0.01559707522392273,td:0.13964152336120605,async:0.00520479679107666,int_mask:0.027328163385391235,max_len:-0.034759193658828735,err:0.003940552473068237,ret:0.1292150914669037,pid:-0.04778757691383362,as:0.00811794400215149,",2,33,"td:bd,ret:mem,",Greedy,212,0.04471590121587118
24,"static void cpu_x86_dump_state(FILE *f)

{

    int eflags;

    char cc_op_name[32];

    eflags = cc_table[CC_OP].compute_all();

    eflags |= (DF & DF_MASK);

    if ((unsigned)env->cc_op < CC_OP_NB)

        strcpy(cc_op_name, cc_op_str[env->cc_op]);

    else

        snprintf(cc_op_name, sizeof(cc_op_name), ""[%d]"", env->cc_op);

    fprintf(f, 

            ""EAX=%08x EBX=%08X ECX=%08x EDX=%08x\n""

            ""ESI=%08x EDI=%08X EBP=%08x ESP=%08x\n""

            ""CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\n""

            ""EIP=%08x\n"",

            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], 

            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], 

            env->cc_src, env->cc_dst, cc_op_name,

            eflags & DF_MASK ? 'D' : '-',

            eflags & CC_O ? 'O' : '-',

            eflags & CC_S ? 'S' : '-',

            eflags & CC_Z ? 'Z' : '-',

            eflags & CC_A ? 'A' : '-',

            eflags & CC_P ? 'P' : '-',

            eflags & CC_C ? 'C' : '-',

            env->eip);

#if 1

    fprintf(f, ""ST0=%f ST1=%f ST2=%f ST3=%f\n"", 

            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));

#endif

}
",271,"static void cpu_x86_dump_state(FILE *feed)

{

    int evrats;

    char cc_op_path[32];

    evrats = cc_table[CC_OP].compute_all();

    evrats |= (DF & DF_MASK);

    if ((unsigned)env->cc_op < CC_OP_NB)

        strcpy(cc_op_path, cc_op_str[env->cc_op]);

    else

        snprintf(cc_op_path, sizeof(cc_op_path), ""[%d]"", env->cc_op);

    fprintf(feed, 

            ""EAX=%08x EBX=%08X ECX=%08x EDX=%08x
""

            ""ESI=%08x EDI=%08X EBP=%08x ESP=%08x
""

            ""CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c
""

            ""EIP=%08x
"",

            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], 

            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], 

            env->cc_src, env->cc_dst, cc_op_path,

            evrats & DF_MASK ? 'D' : '-',

            evrats & CC_O ? 'O' : '-',

            evrats & CC_S ? 'S' : '-',

            evrats & CC_Z ? 'Z' : '-',

            evrats & CC_A ? 'A' : '-',

            evrats & CC_P ? 'P' : '-',

            evrats & CC_C ? 'C' : '-',

            env->eip);

#if 1

    fprintf(feed, ""ST0=%f ST1=%f ST2=%f ST3=%f
"", 

            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));

#endif

}
",0,0,0,-1,"f,eflags,cc_op_name","f:0.004251059144735336,eflags:0.005602570250630379,cc_op_name:0.006623949855566025,",3,18,"cc_op_name:cc_op_path,eflags:evrats,f:feed,",Greedy,238,0.04433263540267944
25,"static int gif_read_image(GifState *s)

{

    int left, top, width, height, bits_per_pixel, code_size, flags;

    int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i;

    uint8_t *ptr, *spal, *palette, *ptr1;



    left = bytestream_get_le16(&s->bytestream);

    top = bytestream_get_le16(&s->bytestream);

    width = bytestream_get_le16(&s->bytestream);

    height = bytestream_get_le16(&s->bytestream);

    flags = bytestream_get_byte(&s->bytestream);

    is_interleaved = flags & 0x40;

    has_local_palette = flags & 0x80;

    bits_per_pixel = (flags & 0x07) + 1;



    av_dlog(s->avctx, ""image x=%d y=%d w=%d h=%d\n"", left, top, width, height);



    if (has_local_palette) {

        bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel));

        palette = s->local_palette;

    } else {

        palette = s->global_palette;

        bits_per_pixel = s->bits_per_pixel;

    }



    /* verify that all the image is inside the screen dimensions */

    if (left + width > s->screen_width ||

        top + height > s->screen_height)

        return AVERROR(EINVAL);



    /* build the palette */

    n = (1 << bits_per_pixel);

    spal = palette;

    for(i = 0; i < n; i++) {

        s->image_palette[i] = (0xffu << 24) | AV_RB24(spal);

        spal += 3;

    }

    for(; i < 256; i++)

        s->image_palette[i] = (0xffu << 24);

    /* handle transparency */

    if (s->transparent_color_index >= 0)

        s->image_palette[s->transparent_color_index] = 0;



    /* now get the image data */

    code_size = bytestream_get_byte(&s->bytestream);

    ff_lzw_decode_init(s->lzw, code_size, s->bytestream,

                       s->bytestream_end - s->bytestream, FF_LZW_GIF);



    /* read all the image */

    linesize = s->picture.linesize[0];

    ptr1 = s->picture.data[0] + top * linesize + left;

    ptr = ptr1;

    pass = 0;

    y1 = 0;

    for (y = 0; y < height; y++) {

        ff_lzw_decode(s->lzw, ptr, width);

        if (is_interleaved) {

            switch(pass) {

            default:

            case 0:

            case 1:

                y1 += 8;

                ptr += linesize * 8;

                if (y1 >= height) {

                    y1 = pass ? 2 : 4;

                    ptr = ptr1 + linesize * y1;

                    pass++;

                }

                break;

            case 2:

                y1 += 4;

                ptr += linesize * 4;

                if (y1 >= height) {

                    y1 = 1;

                    ptr = ptr1 + linesize;

                    pass++;

                }

                break;

            case 3:

                y1 += 2;

                ptr += linesize * 2;

                break;

            }

        } else {

            ptr += linesize;

        }

    }

    /* read the garbage data until end marker is found */

    ff_lzw_decode_tail(s->lzw);

    s->bytestream = ff_lzw_cur_ptr(s->lzw);

    return 0;

}
",544,,0,1,,-4,"s,top,height,bits_per_pixel,code_size,flags,is_interleaved,has_local_palette,y,pass,y1,linesize,n,i,ptr,spal,palette,ptr1",,,,,Greedy,1,0.0021828293800354006
26,"static int alac_encode_frame(AVCodecContext *avctx, uint8_t *frame,

                             int buf_size, void *data)

{

    AlacEncodeContext *s = avctx->priv_data;

    PutBitContext *pb = &s->pbctx;

    int i, out_bytes, verbatim_flag = 0;



    if (avctx->frame_size > DEFAULT_FRAME_SIZE) {

        av_log(avctx, AV_LOG_ERROR, ""input frame size exceeded\n"");

        return -1;

    }



    if (buf_size < 2 * s->max_coded_frame_size) {

        av_log(avctx, AV_LOG_ERROR, ""buffer size is too small\n"");

        return -1;

    }



verbatim:

    init_put_bits(pb, frame, buf_size);



    if (s->compression_level == 0 || verbatim_flag) {

        // Verbatim mode

        const int16_t *samples = data;

        write_frame_header(s, 1);

        for (i = 0; i < avctx->frame_size * avctx->channels; i++) {

            put_sbits(pb, 16, *samples++);

        }

    } else {

        init_sample_buffers(s, data);

        write_frame_header(s, 0);

        write_compressed_frame(s);

    }



    put_bits(pb, 3, 7);

    flush_put_bits(pb);

    out_bytes = put_bits_count(pb) >> 3;



    if (out_bytes > s->max_coded_frame_size) {

        /* frame too large. use verbatim mode */

        if (verbatim_flag || s->compression_level == 0) {

            /* still too large. must be an error. */

            av_log(avctx, AV_LOG_ERROR, ""error encoding frame\n"");

            return -1;

        }

        verbatim_flag = 1;

        goto verbatim;

    }



    return out_bytes;

}
",254,"static int alac_encode_frame(AVCodecContext *acqa, uint8_t *document,

                             int buffer_size, void *v)

{

    AlacEncodeContext *summary = acqa->priv_data;

    PutBitContext *b = &summary->pbctx;

    int io, outurelines, verbatim_flag = 0;



    if (acqa->frame_size > DEFAULT_FRAME_SIZE) {

        av_log(acqa, AV_LOG_ERROR, ""input frame size exceeded
"");

        return -1;

    }



    if (buffer_size < 2 * summary->max_coded_frame_size) {

        av_log(acqa, AV_LOG_ERROR, ""buffer size is too small
"");

        return -1;

    }



verbatim:

    init_put_bits(b, document, buffer_size);



    if (summary->compression_level == 0 || verbatim_flag) {

        // Verbatim mode

        const int16_t *Sannels = v;

        write_frame_header(summary, 1);

        for (io = 0; io < acqa->frame_size * acqa->channels; io++) {

            put_sbits(b, 16, *Sannels++);

        }

    } else {

        init_sample_buffers(summary, v);

        write_frame_header(summary, 0);

        write_compressed_frame(summary);

    }



    put_bits(b, 3, 7);

    flush_put_bits(b);

    outurelines = put_bits_count(b) >> 3;



    if (outurelines > summary->max_coded_frame_size) {

        /* frame too large. use verbatim mode */

        if (verbatim_flag || summary->compression_level == 0) {

            /* still too large. must be an error. */

            av_log(acqa, AV_LOG_ERROR, ""error encoding frame
"");

            return -1;

        }

        verbatim_flag = 1;

        goto verbatim;

    }



    return outurelines;

}
",0,0,0,-1,"avctx,frame,buf_size,data,s,pb,i,out_bytes,samples","avctx:0.008429121226072311,frame:0.02699551358819008,buf_size:0.021358121186494827,data:0.046159472316503525,s:0.05748872831463814,pb:0.010796181857585907,i:0.02137082815170288,out_bytes:0.0066045112907886505,samples:0.0033043958246707916,",9,42,"s:summary,data:v,frame:document,i:io,buf_size:buffer_size,pb:b,avctx:acqa,out_bytes:outurelines,samples:Sannels,",Greedy,479,0.09219574133555095
27,"static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, r;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &d->pam_regions[i+1]);

    }

    smram = d->dev.config[I440FX_SMRAM];

    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&d->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
",186,"static void i440fx_update_memory_mappings(PCII440FXState *sync)

{

    int i, dr;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(sync, 0xf0000, 0x100000, (sync->dev.config[I440FX_PAM] >> 4) & 3,

               &sync->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        dr = (sync->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(sync, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), dr,

                   &sync->pam_regions[i+1]);

    }

    smram = sync->dev.config[I440FX_SMRAM];

    smram_enabled = (sync->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&sync->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
",1,1,0,1,"d,i,r,smram,smram_enabled","d:0.2448653280735016,i:-0.05422317981719971,r:0.08655664324760437,smram:0.043553173542022705,smram_enabled:-0.03986620903015137,",2,13,"d:sync,r:dr,",Greedy,143,0.026577874024709066
28,"static int vmdk_open_vmdk4(BlockDriverState *bs,

                           BlockDriverState *file,

                           int flags)

{

    int ret;

    uint32_t magic;

    uint32_t l1_size, l1_entry_sectors;

    VMDK4Header header;

    VmdkExtent *extent;

    int64_t l1_backup_offset = 0;



    ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header));

    if (ret < 0) {

        return ret;

    }

    if (header.capacity == 0) {

        int64_t desc_offset = le64_to_cpu(header.desc_offset);

        if (desc_offset) {

            return vmdk_open_desc_file(bs, flags, desc_offset << 9);

        }

    }



    if (le64_to_cpu(header.gd_offset) == VMDK4_GD_AT_END) {

        /*

         * The footer takes precedence over the header, so read it in. The

         * footer starts at offset -1024 from the end: One sector for the

         * footer, and another one for the end-of-stream marker.

         */

        struct {

            struct {

                uint64_t val;

                uint32_t size;

                uint32_t type;

                uint8_t pad[512 - 16];

            } QEMU_PACKED footer_marker;



            uint32_t magic;

            VMDK4Header header;

            uint8_t pad[512 - 4 - sizeof(VMDK4Header)];



            struct {

                uint64_t val;

                uint32_t size;

                uint32_t type;

                uint8_t pad[512 - 16];

            } QEMU_PACKED eos_marker;

        } QEMU_PACKED footer;



        ret = bdrv_pread(file,

            bs->file->total_sectors * 512 - 1536,

            &footer, sizeof(footer));

        if (ret < 0) {

            return ret;

        }



        /* Some sanity checks for the footer */

        if (be32_to_cpu(footer.magic) != VMDK4_MAGIC ||

            le32_to_cpu(footer.footer_marker.size) != 0  ||

            le32_to_cpu(footer.footer_marker.type) != MARKER_FOOTER ||

            le64_to_cpu(footer.eos_marker.val) != 0  ||

            le32_to_cpu(footer.eos_marker.size) != 0  ||

            le32_to_cpu(footer.eos_marker.type) != MARKER_END_OF_STREAM)

        {

            return -EINVAL;

        }



        header = footer.header;

    }



    if (le32_to_cpu(header.version) >= 3) {

        char buf[64];

        snprintf(buf, sizeof(buf), ""VMDK version %d"",

                 le32_to_cpu(header.version));

        qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,

                bs->device_name, ""vmdk"", buf);

        return -ENOTSUP;

    }



    l1_entry_sectors = le32_to_cpu(header.num_gtes_per_gte)

                        * le64_to_cpu(header.granularity);

    if (l1_entry_sectors == 0) {

        return -EINVAL;

    }

    l1_size = (le64_to_cpu(header.capacity) + l1_entry_sectors - 1)

                / l1_entry_sectors;

    if (le32_to_cpu(header.flags) & VMDK4_FLAG_RGD) {

        l1_backup_offset = le64_to_cpu(header.rgd_offset) << 9;

    }

    extent = vmdk_add_extent(bs, file, false,

                          le64_to_cpu(header.capacity),

                          le64_to_cpu(header.gd_offset) << 9,

                          l1_backup_offset,

                          l1_size,

                          le32_to_cpu(header.num_gtes_per_gte),

                          le64_to_cpu(header.granularity));

    extent->compressed =

        le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE;

    extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER;

    extent->version = le32_to_cpu(header.version);

    extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN;

    ret = vmdk_init_tables(bs, extent);

    if (ret) {

        /* free extent allocated by vmdk_add_extent */

        vmdk_free_last_extent(bs);

    }

    return ret;

}
",553,,1,0,,-4,"bs,file,flags,ret,magic,l1_size,l1_entry_sectors,header,extent,pad,QEMU_PACKED",,,,,Greedy,1,0.0023616512616475424
29,"static void control_to_network(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
",43,"static void control_to_network(RDMAControlHeader *rule)

{

    rule->type = htonl(rule->type);

    rule->len = htonl(rule->len);

    rule->repeat = htonl(rule->repeat);

}
",1,1,1,-1,control,"control:-0.0019797682762145996,",1,7,"control:rule,",Greedy,67,0.01314384937286377
30,"static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
",27,"static bool use_multiport(VirtIOSerial *vSER)

{

    VirtIODevice *voltserv = VIRTIO_DEVICE(vSER);

    return virtio_has_feature(voltserv, VIRTIO_CONSOLE_F_MULTIPORT);

}
",0,0,0,-1,"vser,vdev","vser:5.332194268703461e-05,vdev:0.00042213546112179756,",2,4,"vdev:voltserv,vser:vSER,",Greedy,56,0.013884147008260092
31,"static int poll_filter(OutputStream *ost)

{

    OutputFile    *of = output_files[ost->file_index];

    AVFrame *filtered_frame = NULL;

    int frame_size, ret;



    if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) {

        return AVERROR(ENOMEM);

    } else

        avcodec_get_frame_defaults(ost->filtered_frame);

    filtered_frame = ost->filtered_frame;



    if (ost->enc->type == AVMEDIA_TYPE_AUDIO &&

        !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE))

        ret = av_buffersink_get_samples(ost->filter->filter, filtered_frame,

                                         ost->st->codec->frame_size);

    else

        ret = av_buffersink_get_frame(ost->filter->filter, filtered_frame);



    if (ret < 0)

        return ret;



    if (filtered_frame->pts != AV_NOPTS_VALUE) {

        filtered_frame->pts = av_rescale_q(filtered_frame->pts,

                                           ost->filter->filter->inputs[0]->time_base,

                                           ost->st->codec->time_base) -

                              av_rescale_q(of->start_time,

                                           AV_TIME_BASE_Q,

                                           ost->st->codec->time_base);

    }



    switch (ost->filter->filter->inputs[0]->type) {

    case AVMEDIA_TYPE_VIDEO:

        if (!ost->frame_aspect_ratio)

            ost->st->codec->sample_aspect_ratio = filtered_frame->sample_aspect_ratio;



        do_video_out(of->ctx, ost, filtered_frame, &frame_size);

        if (vstats_filename && frame_size)

            do_video_stats(ost, frame_size);

        break;

    case AVMEDIA_TYPE_AUDIO:

        do_audio_out(of->ctx, ost, filtered_frame);

        break;

    default:

        // TODO support subtitle filters

        av_assert0(0);

    }



    av_frame_unref(filtered_frame);



    return 0;

}
",295,,0,1,,-4,"ost,of,filtered_frame,frame_size,ret",,,,,Greedy,1,0.002279826005299886
32,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
",47,"void *memory_region_get_ram_ptr(MemoryRegion *pr)

{

    if (pr->alias) {

        return memory_region_get_ram_ptr(pr->alias) + pr->alias_offset;

    }



    assert(pr->terminates);



    return qemu_get_ram_ptr(pr->ram_addr & TARGET_PAGE_MASK);

}
",0,0,0,-1,mr,"mr:0.13584349676966667,",1,6,"mr:pr,",Greedy,60,0.012556012471516926
33,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
",47,"void ff_af_queue_init(AVCodecContext *AVcam, AudioFrameQueue *afq)

{

    afq->AVcam             = AVcam;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = AVcam->delay;

    afq->remaining_samples = AVcam->delay;

    afq->frame_queue       = NULL;

}
",0,0,1,1,"avctx,afq","avctx:0.21297664940357208,afq:0.18022146821022034,",1,5,"avctx:AVcam,",Greedy,70,0.014037322998046876
34,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)

{

    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);

}
",25,"void kvm_s390_service_interrupt(S390CPU *computer, uint32_t para)

{

    kvm_s390_interrupt_internal(computer, KVM_S390_INT_SERVICE, para, 0 , 1);

}
",0,0,0,-1,"cpu,parm","cpu:-0.00012761633843183517,parm:0.0012678783386945724,",2,4,"parm:para,cpu:computer,",Greedy,74,0.01601863702138265
35,"static inline void RENAME(rgb24tobgr15)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint8_t *s = src;

    const uint8_t *end;

    const uint8_t *mm_end;

    uint16_t *d = (uint16_t *)dst;

    end = s + src_size;

    __asm__ volatile(PREFETCH""    %0""::""m""(*src):""memory"");

    __asm__ volatile(

        ""movq          %0, %%mm7    \n\t""

        ""movq          %1, %%mm6    \n\t""

        ::""m""(red_15mask),""m""(green_15mask));

    mm_end = end - 11;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movd          %1, %%mm0    \n\t""

            ""movd         3%1, %%mm3    \n\t""

            ""punpckldq    6%1, %%mm0    \n\t""

            ""punpckldq    9%1, %%mm3    \n\t""

            ""movq       %%mm0, %%mm1    \n\t""

            ""movq       %%mm0, %%mm2    \n\t""

            ""movq       %%mm3, %%mm4    \n\t""

            ""movq       %%mm3, %%mm5    \n\t""

            ""psrlq         $3, %%mm0    \n\t""

            ""psrlq         $3, %%mm3    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %2, %%mm3    \n\t""

            ""psrlq         $6, %%mm1    \n\t""

            ""psrlq         $6, %%mm4    \n\t""

            ""pand       %%mm6, %%mm1    \n\t""

            ""pand       %%mm6, %%mm4    \n\t""

            ""psrlq         $9, %%mm2    \n\t""

            ""psrlq         $9, %%mm5    \n\t""

            ""pand       %%mm7, %%mm2    \n\t""

            ""pand       %%mm7, %%mm5    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""por        %%mm5, %%mm3    \n\t""

            ""psllq        $16, %%mm3    \n\t""

            ""por        %%mm3, %%mm0    \n\t""

            MOVNTQ""     %%mm0, %0       \n\t""

            :""=m""(*d):""m""(*s),""m""(blue_15mask):""memory"");

        d += 4;

        s += 12;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        const int b = *s++;

        const int g = *s++;

        const int r = *s++;

        *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7);

    }

}
",317,"static inline void RENAME(rgb24tobgr15)(const uint8_t *rc, uint8_t *fsts, int rc_scale)

{

    const uint8_t *s = rc;

    const uint8_t *nd;

    const uint8_t *mm_end;

    uint16_t *d = (uint16_t *)fsts;

    nd = s + rc_scale;

    __asm__ volatile(PREFETCH""    %0""::""m""(*src):""memory"");

    __asm__ volatile(

        ""movq          %0, %%mm7    
\t""

        ""movq          %1, %%mm6    
\t""

        ::""m""(red_15mask),""m""(green_15mask));

    mm_end = nd - 11;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movd          %1, %%mm0    
\t""

            ""movd         3%1, %%mm3    
\t""

            ""punpckldq    6%1, %%mm0    
\t""

            ""punpckldq    9%1, %%mm3    
\t""

            ""movq       %%mm0, %%mm1    
\t""

            ""movq       %%mm0, %%mm2    
\t""

            ""movq       %%mm3, %%mm4    
\t""

            ""movq       %%mm3, %%mm5    
\t""

            ""psrlq         $3, %%mm0    
\t""

            ""psrlq         $3, %%mm3    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %2, %%mm3    
\t""

            ""psrlq         $6, %%mm1    
\t""

            ""psrlq         $6, %%mm4    
\t""

            ""pand       %%mm6, %%mm1    
\t""

            ""pand       %%mm6, %%mm4    
\t""

            ""psrlq         $9, %%mm2    
\t""

            ""psrlq         $9, %%mm5    
\t""

            ""pand       %%mm7, %%mm2    
\t""

            ""pand       %%mm7, %%mm5    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""por        %%mm5, %%mm3    
\t""

            ""psllq        $16, %%mm3    
\t""

            ""por        %%mm3, %%mm0    
\t""

            MOVNTQ""     %%mm0, %0       
\t""

            :""=m""(*d):""m""(*s),""m""(blue_15mask):""memory"");

        d += 4;

        s += 12;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < nd) {

        const int b = *s++;

        const int g = *s++;

        const int r = *s++;

        *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7);

    }

}
",1,1,0,1,"src,dst,src_size,s,end,mm_end,d","src:-0.03158402442932129,dst:0.027502834796905518,src_size:0.08166694641113281,s:-0.07030212879180908,end:0.020835161209106445,mm_end:-0.03556656837463379,d:-0.06099778413772583,",4,10,"src_size:rc_scale,dst:fsts,end:nd,src:rc,",Greedy,145,0.03432494004567464
36,"static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion,

                                void *opaque)

{

    GtkDisplayState *s = opaque;

    int x, y;

    int mx, my;

    int fbh, fbw;

    int ww, wh;



    fbw = surface_width(s->ds) * s->scale_x;

    fbh = surface_height(s->ds) * s->scale_y;



    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);



    mx = my = 0;

    if (ww > fbw) {

        mx = (ww - fbw) / 2;

    }

    if (wh > fbh) {

        my = (wh - fbh) / 2;

    }



    x = (motion->x - mx) / s->scale_x;

    y = (motion->y - my) / s->scale_y;



    if (x < 0 || y < 0 ||

        x >= surface_width(s->ds) ||

        y >= surface_height(s->ds)) {

        return TRUE;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x,

                             surface_width(s->ds));

        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y,

                             surface_height(s->ds));

        qemu_input_event_sync();

    } else if (s->last_x != -1 && s->last_y != -1 && gd_is_grab_active(s)) {

        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_X, x - s->last_x);

        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y);

        qemu_input_event_sync();

    }

    s->last_x = x;

    s->last_y = y;



    if (!qemu_input_is_absolute() && gd_is_grab_active(s)) {

        GdkScreen *screen = gtk_widget_get_screen(s->drawing_area);

        int x = (int)motion->x_root;

        int y = (int)motion->y_root;



        /* In relative mode check to see if client pointer hit

         * one of the screen edges, and if so move it back by

         * 200 pixels. This is important because the pointer

         * in the server doesn't correspond 1-for-1, and so

         * may still be only half way across the screen. Without

         * this warp, the server pointer would thus appear to hit

         * an invisible wall */

        if (x == 0) {

            x += 200;

        }

        if (y == 0) {

            y += 200;

        }

        if (x == (gdk_screen_get_width(screen) - 1)) {

            x -= 200;

        }

        if (y == (gdk_screen_get_height(screen) - 1)) {

            y -= 200;

        }



        if (x != (int)motion->x_root || y != (int)motion->y_root) {

#if GTK_CHECK_VERSION(3, 0, 0)

            GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion);

            gdk_device_warp(dev, screen, x, y);

#else

            GdkDisplay *display = gtk_widget_get_display(widget);

            gdk_display_warp_pointer(display, screen, x, y);

#endif

            s->last_x = -1;

            s->last_y = -1;

            return FALSE;

        }

    }

    return TRUE;

}
",516,,1,0,,-4,"widget,motion,opaque,s,x,y,mx,my,fbh,fbw,ww,wh",,,,,Greedy,1,0.0026171207427978516
37,"int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,

                         int level)

{

    VDPAUHWContext *hwctx = avctx->hwaccel_context;

    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;

    VdpVideoSurfaceQueryCapabilities *surface_query_caps;

    VdpDecoderQueryCapabilities *decoder_query_caps;

    VdpDecoderCreate *create;

    void *func;

    VdpStatus status;

    VdpBool supported;

    uint32_t max_level, max_mb, max_width, max_height;

    VdpChromaType type;

    uint32_t width;

    uint32_t height;



    vdctx->width            = UINT32_MAX;

    vdctx->height           = UINT32_MAX;



    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))

        return AVERROR(ENOSYS);



    if (hwctx) {

        hwctx->reset            = 0;



        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {

            vdctx->decoder = hwctx->context.decoder;

            vdctx->render  = hwctx->context.render;

            vdctx->device  = VDP_INVALID_HANDLE;

            return 0; /* Decoder created by user */

        }



        vdctx->device           = hwctx->device;

        vdctx->get_proc_address = hwctx->get_proc_address;



        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            level = 0;



        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&

            type != VDP_CHROMA_TYPE_420)

            return AVERROR(ENOSYS);

    } else {

        AVHWFramesContext *frames_ctx = NULL;

        AVVDPAUDeviceContext *dev_ctx;



        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit

        // is called. This holds true as the user is not allowed to touch

        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format

        // itself also uninits before unreffing hw_frames_ctx).

        if (avctx->hw_frames_ctx) {

            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

        } else if (avctx->hw_device_ctx) {

            int ret;



            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);

            if (!avctx->hw_frames_ctx)

                return AVERROR(ENOMEM);



            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

            frames_ctx->format    = AV_PIX_FMT_VDPAU;

            frames_ctx->sw_format = avctx->sw_pix_fmt;

            frames_ctx->width     = avctx->coded_width;

            frames_ctx->height    = avctx->coded_height;



            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);

            if (ret < 0) {

                av_buffer_unref(&avctx->hw_frames_ctx);

                return ret;

            }

        }



        if (!frames_ctx) {

            av_log(avctx, AV_LOG_ERROR, ""A hardware frames context is ""

                   ""required for VDPAU decoding.\n"");

            return AVERROR(EINVAL);

        }



        dev_ctx = frames_ctx->device_ctx->hwctx;



        vdctx->device           = dev_ctx->device;

        vdctx->get_proc_address = dev_ctx->get_proc_address;



        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            level = 0;

    }



    if (level < 0)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        surface_query_caps = func;



    status = surface_query_caps(vdctx->device, type, &supported,

                                &max_width, &max_height);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    if (supported != VDP_TRUE ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        decoder_query_caps = func;



    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,

                                &max_mb, &max_width, &max_height);

#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE

    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {

        profile = VDP_DECODER_PROFILE_H264_MAIN;

        status = decoder_query_caps(vdctx->device, profile, &supported,

                                    &max_level, &max_mb,

                                    &max_width, &max_height);

    }

#endif

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);



    if (supported != VDP_TRUE || max_level < level ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        create = func;



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        vdctx->render = func;



    status = create(vdctx->device, profile, width, height, avctx->refs,

                    &vdctx->decoder);

    if (status == VDP_STATUS_OK) {

        vdctx->width  = avctx->coded_width;

        vdctx->height = avctx->coded_height;

    }



    return vdpau_error(status);

}
",774,"int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,

                         int model)

{

    VDPAUHWContext *avcf = avctx->hwaccel_context;

    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;

    VdpVideoSurfaceQueryCapabilities *surface_query_caps;

    VdpDecoderQueryCapabilities *decoder_query_caps;

    VdpDecoderCreate *create;

    void *func;

    VdpStatus status;

    VdpBool supported;

    uint32_t max_level, max_mb, max_width, max_height;

    VdpChromaType type;

    uint32_t width;

    uint32_t height;



    vdctx->width            = UINT32_MAX;

    vdctx->height           = UINT32_MAX;



    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))

        return AVERROR(ENOSYS);



    if (avcf) {

        avcf->reset            = 0;



        if (avcf->context.decoder != VDP_INVALID_HANDLE) {

            vdctx->decoder = avcf->context.decoder;

            vdctx->render  = avcf->context.render;

            vdctx->device  = VDP_INVALID_HANDLE;

            return 0; /* Decoder created by user */

        }



        vdctx->device           = avcf->device;

        vdctx->get_proc_address = avcf->get_proc_address;



        if (avcf->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            model = 0;



        if (!(avcf->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&

            type != VDP_CHROMA_TYPE_420)

            return AVERROR(ENOSYS);

    } else {

        AVHWFramesContext *frames_ctx = NULL;

        AVVDPAUDeviceContext *dev_ctx;



        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit

        // is called. This holds true as the user is not allowed to touch

        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format

        // itself also uninits before unreffing hw_frames_ctx).

        if (avctx->hw_frames_ctx) {

            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

        } else if (avctx->hw_device_ctx) {

            int ret;



            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);

            if (!avctx->hw_frames_ctx)

                return AVERROR(ENOMEM);



            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

            frames_ctx->format    = AV_PIX_FMT_VDPAU;

            frames_ctx->sw_format = avctx->sw_pix_fmt;

            frames_ctx->width     = avctx->coded_width;

            frames_ctx->height    = avctx->coded_height;



            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);

            if (ret < 0) {

                av_buffer_unref(&avctx->hw_frames_ctx);

                return ret;

            }

        }



        if (!frames_ctx) {

            av_log(avctx, AV_LOG_ERROR, ""A hardware frames context is ""

                   ""required for VDPAU decoding.
"");

            return AVERROR(EINVAL);

        }



        dev_ctx = frames_ctx->device_ctx->avcf;



        vdctx->device           = dev_ctx->device;

        vdctx->get_proc_address = dev_ctx->get_proc_address;



        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            model = 0;

    }



    if (model < 0)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        surface_query_caps = func;



    status = surface_query_caps(vdctx->device, type, &supported,

                                &max_width, &max_height);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    if (supported != VDP_TRUE ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        decoder_query_caps = func;



    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,

                                &max_mb, &max_width, &max_height);

#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE

    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {

        profile = VDP_DECODER_PROFILE_H264_MAIN;

        status = decoder_query_caps(vdctx->device, profile, &supported,

                                    &max_level, &max_mb,

                                    &max_width, &max_height);

    }

#endif

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);



    if (supported != VDP_TRUE || max_level < model ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        create = func;



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        vdctx->render = func;



    status = create(vdctx->device, profile, width, height, avctx->refs,

                    &vdctx->decoder);

    if (status == VDP_STATUS_OK) {

        vdctx->width  = avctx->coded_width;

        vdctx->height = avctx->coded_height;

    }



    return vdpau_error(status);

}
",0,0,1,1,"avctx,profile,level,hwctx,vdctx,surface_query_caps,decoder_query_caps,create,func,status,supported,max_level,max_mb,max_width,max_height,type,height,frames_ctx,dev_ctx,ret","avctx:0.0954892486333847,profile:0.07610711455345154,level:0.11445575952529907,hwctx:0.13820329308509827,vdctx:0.10554516315460205,surface_query_caps:0.04054597020149231,decoder_query_caps:0.11192937195301056,create:0.03137563169002533,func:0.04400934278964996,status:0.0182456374168396,supported:0.02073994278907776,max_level:0.007438689470291138,max_mb:0.05627848207950592,max_width:0.018769457936286926,max_height:0.05299957096576691,type:0.026159733533859253,height:0.03722955286502838,frames_ctx:0.030254721641540527,dev_ctx:0.07282058894634247,ret:2.1457672119140625e-06,",2,16,"hwctx:avcf,level:model,",Greedy,290,0.06425259113311768
38,"static int estimate_qp(MpegEncContext *s, int dry_run){

    if (s->next_lambda){

        s->current_picture_ptr->f.quality =

        s->current_picture.f.quality = s->next_lambda;

        if(!dry_run) s->next_lambda= 0;

    } else if (!s->fixed_qscale) {

        s->current_picture_ptr->f.quality =

        s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run);

        if (s->current_picture.f.quality < 0)

            return -1;

    }



    if(s->adaptive_quant){

        switch(s->codec_id){

        case AV_CODEC_ID_MPEG4:

            if (CONFIG_MPEG4_ENCODER)

                ff_clean_mpeg4_qscales(s);

            break;

        case AV_CODEC_ID_H263:

        case AV_CODEC_ID_H263P:

        case AV_CODEC_ID_FLV1:

            if (CONFIG_H263_ENCODER)

                ff_clean_h263_qscales(s);

            break;

        default:

            ff_init_qscale_tab(s);

        }



        s->lambda= s->lambda_table[0];

        //FIXME broken

    }else

        s->lambda = s->current_picture.f.quality;

    update_qscale(s);

    return 0;

}
",189,,1,0,,-4,"s,dry_run",,,,,Greedy,1,0.002047153313954671
39,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
",51,"static void spr_write_tbu (DisasContext *cgi, int prname, int grrk)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[grrk]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(cgi);

    }

}
",0,0,0,-1,"ctx,sprn,gprn","ctx:0.0008160378783941269,sprn:0.014173313044011593,gprn:0.0011755600571632385,",3,5,"sprn:prname,gprn:grrk,ctx:cgi,",Greedy,96,0.020255108674367268
40,"static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev)

{

#ifdef CONFIG_KVM

    struct kvm_irqfd irqfd = {

        .fd = event_notifier_get_fd(&vdev->intx.interrupt),

        .gsi = vdev->intx.route.irq,

        .flags = KVM_IRQFD_FLAG_RESAMPLE,

    };

    struct vfio_irq_set *irq_set;

    int ret, argsz;

    int32_t *pfd;



    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||

        vdev->intx.route.mode != PCI_INTX_ENABLED ||

        !kvm_resamplefds_enabled()) {

        return;

    }



    /* Get to a known interrupt state */

    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);

    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);

    vdev->intx.pending = false;

    pci_irq_deassert(&vdev->pdev);



    /* Get an eventfd for resample/unmask */

    if (event_notifier_init(&vdev->intx.unmask, 0)) {

        error_report(""vfio: Error: event_notifier_init failed eoi"");

        goto fail;

    }



    /* KVM triggers it, VFIO listens for it */

    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);



    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {

        error_report(""vfio: Error: Failed to setup resample irqfd: %m"");

        goto fail_irqfd;

    }



    argsz = sizeof(*irq_set) + sizeof(*pfd);



    irq_set = g_malloc0(argsz);

    irq_set->argsz = argsz;

    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;

    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;

    irq_set->start = 0;

    irq_set->count = 1;

    pfd = (int32_t *)&irq_set->data;



    *pfd = irqfd.resamplefd;



    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);

    g_free(irq_set);

    if (ret) {

        error_report(""vfio: Error: Failed to setup INTx unmask fd: %m"");

        goto fail_vfio;

    }



    /* Let'em rip */

    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);



    vdev->intx.kvm_accel = true;



    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);



    return;



fail_vfio:

    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;

    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);

fail_irqfd:

    event_notifier_cleanup(&vdev->intx.unmask);

fail:

    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);

    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);

#endif

}
",383,"static void vfio_intx_enable_kvm(VFIOPCIDevice *qdebug)

{

#ifdef CONFIG_KVM

    struct kvm_irqfd irqfd = {

        .fd = event_notifier_get_fd(&qdebug->intx.interrupt),

        .gsi = qdebug->intx.route.irq,

        .flags = KVM_IRQFD_FLAG_RESAMPLE,

    };

    struct vfio_irq_set *irshMsend;

    int std, paramszo;

    int32_t *cpdf;



    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||

        qdebug->intx.route.mode != PCI_INTX_ENABLED ||

        !kvm_resamplefds_enabled()) {

        return;

    }



    /* Get to a known interrupt state */

    qemu_set_fd_handler(irqfd.fd, NULL, NULL, qdebug);

    vfio_mask_single_irqindex(&qdebug->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);

    qdebug->intx.pending = false;

    pci_irq_deassert(&qdebug->pdev);



    /* Get an eventfd for resample/unmask */

    if (event_notifier_init(&qdebug->intx.unmask, 0)) {

        error_report(""vfio: Error: event_notifier_init failed eoi"");

        goto fail;

    }



    /* KVM triggers it, VFIO listens for it */

    irqfd.resamplefd = event_notifier_get_fd(&qdebug->intx.unmask);



    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {

        error_report(""vfio: Error: Failed to setup resample irqfd: %m"");

        goto fail_irqfd;

    }



    paramszo = sizeof(*irshMsend) + sizeof(*cpdf);



    irshMsend = g_malloc0(paramszo);

    irshMsend->paramszo = paramszo;

    irshMsend->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;

    irshMsend->index = VFIO_PCI_INTX_IRQ_INDEX;

    irshMsend->start = 0;

    irshMsend->count = 1;

    cpdf = (int32_t *)&irshMsend->data;



    *cpdf = irqfd.resamplefd;



    std = ioctl(qdebug->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irshMsend);

    g_free(irshMsend);

    if (std) {

        error_report(""vfio: Error: Failed to setup INTx unmask fd: %m"");

        goto fail_vfio;

    }



    /* Let'em rip */

    vfio_unmask_single_irqindex(&qdebug->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);



    qdebug->intx.kvm_accel = true;



    trace_vfio_intx_enable_kvm(qdebug->vbasedev.name);



    return;



fail_vfio:

    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;

    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);

fail_irqfd:

    event_notifier_cleanup(&qdebug->intx.unmask);

fail:

    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, qdebug);

    vfio_unmask_single_irqindex(&qdebug->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);

#endif

}
",0,0,1,1,"vdev,irq_set,ret,argsz,pfd","vdev:0.05854472517967224,irq_set:0.09551495313644409,ret:-0.01632082462310791,argsz:0.038102537393569946,pfd:-0.002108842134475708,",5,40,"irq_set:irshMsend,vdev:qdebug,argsz:paramszo,pfd:cpdf,ret:std,",Greedy,325,0.06592891613642375
41,"static inline void gen_evfsnabs(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);

#else

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);

    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
",115,"static inline void gen_evfsnabs(DisasContext *cms)

{

    if (unlikely(!cms->spe_enabled)) {

        gen_exception(cms, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_ori_tl(cpu_gpr[rD(cms->opcode)], cpu_gpr[rA(cms->opcode)], 0x8000000080000000LL);

#else

    tcg_gen_ori_tl(cpu_gpr[rD(cms->opcode)], cpu_gpr[rA(cms->opcode)], 0x80000000);

    tcg_gen_ori_tl(cpu_gprh[rD(cms->opcode)], cpu_gprh[rA(cms->opcode)], 0x80000000);

#endif

}
",0,0,0,-1,ctx,"ctx:0.0011524176225066185,",1,9,"ctx:cms,",Greedy,76,0.014819196859995524
42,"static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,

                                unsigned size)

{

    IMXTimerGState *s = (IMXTimerGState *)opaque;



    DPRINTF(""g-read(offset=%x)"", offset >> 2);

    switch (offset >> 2) {

    case 0: /* Control Register */

        DPRINTF("" cr = %x\n"", s->cr);

        return s->cr;



    case 1: /* prescaler */

        DPRINTF("" pr = %x\n"", s->pr);

        return s->pr;



    case 2: /* Status Register */

        DPRINTF("" sr = %x\n"", s->sr);

        return s->sr;



    case 3: /* Interrupt Register */

        DPRINTF("" ir = %x\n"", s->ir);

        return s->ir;



    case 4: /* Output Compare Register 1 */

        DPRINTF("" ocr1 = %x\n"", s->ocr1);

        return s->ocr1;





    case 9: /* cnt */

        imx_timerg_update_counts(s);

        DPRINTF("" cnt = %x\n"", s->cnt);

        return s->cnt;

    }



    IPRINTF(""imx_timerg_read: Bad offset %x\n"",

            (int)offset >> 2);

    return 0;

}
",173,"static uint64_t imx_timerg_read(void * opca, target_phys_addr_t o,

                                unsigned args)

{

    IMXTimerGState *ports = (IMXTimerGState *) opca;



    DPRINTF(""g-read(offset=%x)"", o >> 2);

    switch (o >> 2) {

    case 0: /* Control Register */

        DPRINTF("" cr = %x
"", ports->cr);

        return ports->cr;



    case 1: /* prescaler */

        DPRINTF("" pr = %x
"", ports->pr);

        return ports->pr;



    case 2: /* Status Register */

        DPRINTF("" sr = %x
"", ports->sr);

        return ports->sr;



    case 3: /* Interrupt Register */

        DPRINTF("" ir = %x
"", ports->ir);

        return ports->ir;



    case 4: /* Output Compare Register 1 */

        DPRINTF("" ocr1 = %x
"", ports->ocr1);

        return ports->ocr1;





    case 9: /* cnt */

        imx_timerg_update_counts(ports);

        DPRINTF("" cnt = %x
"", ports->cnt);

        return ports->cnt;

    }



    IPRINTF(""imx_timerg_read: Bad offset %x
"",

            (int)o >> 2);

    return 0;

}
",0,0,1,1,"opaque,offset,size,s","opaque:-0.1819199025630951,offset:-0.00450308620929718,size:0.1161896139383316,s:-0.11810718476772308,",4,21,"size:args,offset:o,s:ports,opaque: opca,",Greedy,206,0.03802022139231364
43,"static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,

                         Error **errp)

{

    BDRVBlkdebugState *s = bs->opaque;

    QemuOpts *opts;

    Error *local_err = NULL;

    int ret;



    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(opts, options, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto out;

    }



    /* Read rules from config file or command line options */

    s->config_file = g_strdup(qemu_opt_get(opts, ""config""));

    ret = read_config(s, s->config_file, options, errp);

    if (ret) {

        goto out;

    }



    /* Set initial state */

    s->state = 1;



    /* Open the image file */

    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options, ""image"",

                               bs, &child_file, false, &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto out;

    }



    bs->supported_write_flags = BDRV_REQ_FUA &

        bs->file->bs->supported_write_flags;

    bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) &

        bs->file->bs->supported_zero_flags;

    ret = -EINVAL;



    /* Set request alignment */

    s->align = qemu_opt_get_size(opts, ""align"", 0);

    if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) {

        error_setg(errp, ""Cannot meet constraints with align %"" PRIu64,

                   s->align);

        goto out;

    }



    ret = 0;

out:

    if (ret < 0) {

        g_free(s->config_file);

    }

    qemu_opts_del(opts);

    return ret;

}
",305,,0,1,,-4,"bs,options,flags,errp,s,opts,local_err,ret",,,,,Greedy,1,0.0021544973055521647
44,"static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
",59,"static void test_qemu_strtoull_full_negative(void)

{

    const char *f = "" \t -321"";

    uint64_t res = 999;

    int resp;



    resp = qemu_strtoull(f, NULL, 0, &res);



    g_assert_cmpint(resp, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
",0,0,1,1,"str,err","str:0.004122105427086353,err:0.010234246961772442,",2,5,"err:resp,str:f,",Greedy,82,0.016480966409047445
45,"static uint64_t exynos4210_fimd_read(void *opaque, target_phys_addr_t offset,

                                  unsigned size)

{

    Exynos4210fimdState *s = (Exynos4210fimdState *)opaque;

    int w, i;

    uint32_t ret = 0;



    DPRINT_L2(""read offset 0x%08x\n"", offset);



    switch (offset) {

    case FIMD_VIDCON0 ... FIMD_VIDCON3:

        return s->vidcon[(offset - FIMD_VIDCON0) >> 2];

    case FIMD_VIDTCON_START ... FIMD_VIDTCON_END:

        return s->vidtcon[(offset - FIMD_VIDTCON_START) >> 2];

    case FIMD_WINCON_START ... FIMD_WINCON_END:

        return s->window[(offset - FIMD_WINCON_START) >> 2].wincon;

    case FIMD_SHADOWCON:

        return s->shadowcon;

    case FIMD_WINCHMAP:

        return s->winchmap;

    case FIMD_VIDOSD_START ... FIMD_VIDOSD_END:

        w = (offset - FIMD_VIDOSD_START) >> 4;

        i = ((offset - FIMD_VIDOSD_START) & 0xF) >> 2;

        switch (i) {

        case 0:

            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<

            FIMD_VIDOSD_HOR_SHIFT) |

            (s->window[w].lefttop_y & FIMD_VIDOSD_COORD_MASK);

            break;

        case 1:

            ret = ((s->window[w].rightbot_x & FIMD_VIDOSD_COORD_MASK) <<

                FIMD_VIDOSD_HOR_SHIFT) |

                (s->window[w].rightbot_y & FIMD_VIDOSD_COORD_MASK);

            break;

        case 2:

            if (w == 0) {

                ret = s->window[w].osdsize;

            } else {

                ret = (pack_upper_4(s->window[w].alpha_val[0]) <<

                    FIMD_VIDOSD_AEN0_SHIFT) |

                    pack_upper_4(s->window[w].alpha_val[1]);

            }

            break;

        case 3:

            if (w != 1 && w != 2) {

                DPRINT_ERROR(""bad read offset 0x%08x\n"", offset);

                return 0xBAADBAAD;

            }

            ret = s->window[w].osdsize;

            break;

        }

        return ret;

    case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END:

        w = (offset - FIMD_VIDWADD0_START) >> 3;

        i = ((offset - FIMD_VIDWADD0_START) >> 2) & 1;

        return s->window[w].buf_start[i];

    case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END:

        w = (offset - FIMD_VIDWADD1_START) >> 3;

        i = ((offset - FIMD_VIDWADD1_START) >> 2) & 1;

        return s->window[w].buf_end[i];

    case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END:

        w = (offset - FIMD_VIDWADD2_START) >> 2;

        return s->window[w].virtpage_width | (s->window[w].virtpage_offsize <<

            FIMD_VIDWADD2_OFFSIZE_SHIFT);

    case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1:

        return s->vidintcon[(offset - FIMD_VIDINTCON0) >> 2];

    case FIMD_WKEYCON_START ... FIMD_WKEYCON_END:

        w = ((offset - FIMD_WKEYCON_START) >> 3) + 1;

        i = ((offset - FIMD_WKEYCON_START) >> 2) & 1;

        return s->window[w].keycon[i];

    case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END:

        w = ((offset - FIMD_WKEYALPHA_START) >> 2) + 1;

        return s->window[w].keyalpha;

    case FIMD_DITHMODE:

        return s->dithmode;

    case FIMD_WINMAP_START ... FIMD_WINMAP_END:

        return s->window[(offset - FIMD_WINMAP_START) >> 2].winmap;

    case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW:

        return s->wpalcon[(offset - FIMD_WPALCON_HIGH) >> 2];

    case FIMD_TRIGCON:

        return s->trigcon;

    case FIMD_I80IFCON_START ... FIMD_I80IFCON_END:

        return s->i80ifcon[(offset - FIMD_I80IFCON_START) >> 2];

    case FIMD_COLORGAINCON:

        return s->colorgaincon;

    case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1:

        return s->ldi_cmdcon[(offset - FIMD_LDI_CMDCON0) >> 2];

    case FIMD_SIFCCON0 ... FIMD_SIFCCON2:

        i = (offset - FIMD_SIFCCON0) >> 2;

        return s->sifccon[i];

    case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END:

        i = (offset - FIMD_HUECOEFCR_START) >> 2;

        return s->huecoef_cr[i];

    case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END:

        i = (offset - FIMD_HUECOEFCB_START) >> 2;

        return s->huecoef_cb[i];

    case FIMD_HUEOFFSET:

        return s->hueoffset;

    case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END:

        w = ((offset - FIMD_VIDWALPHA_START) >> 3);

        i = ((offset - FIMD_VIDWALPHA_START) >> 2) & 1;

        return s->window[w].alpha_val[i] &

                (w == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER);

    case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END:

        return s->window[(offset - FIMD_BLENDEQ_START) >> 2].blendeq;

    case FIMD_BLENDCON:

        return s->blendcon;

    case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END:

        return s->window[(offset - FIMD_WRTQOSCON_START) >> 2].rtqoscon;

    case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END:

        return s->i80ifcmd[(offset - FIMD_I80IFCMD_START) >> 2];

    case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2:

        if (offset & 0x0004) {

            break;

        }

        return s->window[(offset - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2];

    case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END:

        if (offset & 0x0004) {

            break;

        }

        return s->window[(offset - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start;

    case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END:

        if (offset & 0x0004) {

            break;

        }

        return s->window[(offset - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end;

    case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END:

        return s->window[(offset - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size;

    case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END:

        w = (offset - FIMD_PAL_MEM_START) >> 10;

        i = ((offset - FIMD_PAL_MEM_START) >> 2) & 0xFF;

        return s->window[w].palette[i];

    case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END:

        /* Palette aliases for win 0,1 */

        w = (offset - FIMD_PALMEM_AL_START) >> 10;

        i = ((offset - FIMD_PALMEM_AL_START) >> 2) & 0xFF;

        return s->window[w].palette[i];

    }



    DPRINT_ERROR(""bad read offset 0x%08x\n"", offset);

    return 0xBAADBAAD;

}
",1123,"static uint64_t exynos4210_fimd_read(void *opacs, target_phys_addr_t offset,

                                  unsigned size)

{

    Exynos4210fimdState *s = (Exynos4210fimdState *)opacs;

    int w, i;

    uint32_t ret = 0;



    DPRINT_L2(""read offset 0x%08x
"", offset);



    switch (offset) {

    case FIMD_VIDCON0 ... FIMD_VIDCON3:

        return s->vidcon[(offset - FIMD_VIDCON0) >> 2];

    case FIMD_VIDTCON_START ... FIMD_VIDTCON_END:

        return s->vidtcon[(offset - FIMD_VIDTCON_START) >> 2];

    case FIMD_WINCON_START ... FIMD_WINCON_END:

        return s->window[(offset - FIMD_WINCON_START) >> 2].wincon;

    case FIMD_SHADOWCON:

        return s->shadowcon;

    case FIMD_WINCHMAP:

        return s->winchmap;

    case FIMD_VIDOSD_START ... FIMD_VIDOSD_END:

        w = (offset - FIMD_VIDOSD_START) >> 4;

        i = ((offset - FIMD_VIDOSD_START) & 0xF) >> 2;

        switch (i) {

        case 0:

            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<

            FIMD_VIDOSD_HOR_SHIFT) |

            (s->window[w].lefttop_y & FIMD_VIDOSD_COORD_MASK);

            break;

        case 1:

            ret = ((s->window[w].rightbot_x & FIMD_VIDOSD_COORD_MASK) <<

                FIMD_VIDOSD_HOR_SHIFT) |

                (s->window[w].rightbot_y & FIMD_VIDOSD_COORD_MASK);

            break;

        case 2:

            if (w == 0) {

                ret = s->window[w].osdsize;

            } else {

                ret = (pack_upper_4(s->window[w].alpha_val[0]) <<

                    FIMD_VIDOSD_AEN0_SHIFT) |

                    pack_upper_4(s->window[w].alpha_val[1]);

            }

            break;

        case 3:

            if (w != 1 && w != 2) {

                DPRINT_ERROR(""bad read offset 0x%08x
"", offset);

                return 0xBAADBAAD;

            }

            ret = s->window[w].osdsize;

            break;

        }

        return ret;

    case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END:

        w = (offset - FIMD_VIDWADD0_START) >> 3;

        i = ((offset - FIMD_VIDWADD0_START) >> 2) & 1;

        return s->window[w].buf_start[i];

    case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END:

        w = (offset - FIMD_VIDWADD1_START) >> 3;

        i = ((offset - FIMD_VIDWADD1_START) >> 2) & 1;

        return s->window[w].buf_end[i];

    case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END:

        w = (offset - FIMD_VIDWADD2_START) >> 2;

        return s->window[w].virtpage_width | (s->window[w].virtpage_offsize <<

            FIMD_VIDWADD2_OFFSIZE_SHIFT);

    case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1:

        return s->vidintcon[(offset - FIMD_VIDINTCON0) >> 2];

    case FIMD_WKEYCON_START ... FIMD_WKEYCON_END:

        w = ((offset - FIMD_WKEYCON_START) >> 3) + 1;

        i = ((offset - FIMD_WKEYCON_START) >> 2) & 1;

        return s->window[w].keycon[i];

    case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END:

        w = ((offset - FIMD_WKEYALPHA_START) >> 2) + 1;

        return s->window[w].keyalpha;

    case FIMD_DITHMODE:

        return s->dithmode;

    case FIMD_WINMAP_START ... FIMD_WINMAP_END:

        return s->window[(offset - FIMD_WINMAP_START) >> 2].winmap;

    case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW:

        return s->wpalcon[(offset - FIMD_WPALCON_HIGH) >> 2];

    case FIMD_TRIGCON:

        return s->trigcon;

    case FIMD_I80IFCON_START ... FIMD_I80IFCON_END:

        return s->i80ifcon[(offset - FIMD_I80IFCON_START) >> 2];

    case FIMD_COLORGAINCON:

        return s->colorgaincon;

    case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1:

        return s->ldi_cmdcon[(offset - FIMD_LDI_CMDCON0) >> 2];

    case FIMD_SIFCCON0 ... FIMD_SIFCCON2:

        i = (offset - FIMD_SIFCCON0) >> 2;

        return s->sifccon[i];

    case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END:

        i = (offset - FIMD_HUECOEFCR_START) >> 2;

        return s->huecoef_cr[i];

    case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END:

        i = (offset - FIMD_HUECOEFCB_START) >> 2;

        return s->huecoef_cb[i];

    case FIMD_HUEOFFSET:

        return s->hueoffset;

    case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END:

        w = ((offset - FIMD_VIDWALPHA_START) >> 3);

        i = ((offset - FIMD_VIDWALPHA_START) >> 2) & 1;

        return s->window[w].alpha_val[i] &

                (w == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER);

    case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END:

        return s->window[(offset - FIMD_BLENDEQ_START) >> 2].blendeq;

    case FIMD_BLENDCON:

        return s->blendcon;

    case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END:

        return s->window[(offset - FIMD_WRTQOSCON_START) >> 2].rtqoscon;

    case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END:

        return s->i80ifcmd[(offset - FIMD_I80IFCMD_START) >> 2];

    case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2:

        if (offset & 0x0004) {

            break;

        }

        return s->window[(offset - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2];

    case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END:

        if (offset & 0x0004) {

            break;

        }

        return s->window[(offset - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start;

    case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END:

        if (offset & 0x0004) {

            break;

        }

        return s->window[(offset - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end;

    case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END:

        return s->window[(offset - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size;

    case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END:

        w = (offset - FIMD_PAL_MEM_START) >> 10;

        i = ((offset - FIMD_PAL_MEM_START) >> 2) & 0xFF;

        return s->window[w].palette[i];

    case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END:

        /* Palette aliases for win 0,1 */

        w = (offset - FIMD_PALMEM_AL_START) >> 10;

        i = ((offset - FIMD_PALMEM_AL_START) >> 2) & 0xFF;

        return s->window[w].palette[i];

    }



    DPRINT_ERROR(""bad read offset 0x%08x
"", offset);

    return 0xBAADBAAD;

}
",0,0,1,1,"opaque,offset,size,s,w,i","opaque:0.005283265374600887,offset:-0.02358384896069765,size:0.0004927460104227066,s:-0.025211184285581112,w:-0.02230935078114271,i:-0.006596684455871582,",1,2,"opaque:opacs,",Greedy,170,0.04055059750874837
46,"float64 HELPER(ucf64_absd)(float64 a)

{

    return float64_abs(a);

}
",17,"float64 HELPER(ucf64_absd)(float64 b)

{

    return float64_abs(b);

}
",0,0,0,-1,a,"a:-0.0001707645133137703,",1,2,"a:b,",Greedy,39,0.010182257493336995
47,"static CharDriverState *qemu_chr_open_null(const char *id,

                                           ChardevBackend *backend,

                                           ChardevReturn *ret,

                                           Error **errp)

{

    CharDriverState *chr;

    ChardevCommon *common = backend->u.null;



    chr = qemu_chr_alloc(common, errp);

    if (!chr) {

        return NULL;

    }

    chr->chr_write = null_chr_write;

    chr->explicit_be_open = true;

    return chr;

}
",73,"static CharDriverState *qemu_chr_open_null(const char *create,

                                           ChardevBackend *backend,

                                           ChardevReturn *obj,

                                           Error **errfp)

{

    CharDriverState *charrb;

    ChardevCommon *document = backend->u.null;



    charrb = qemu_chr_alloc(document, errfp);

    if (!charrb) {

        return NULL;

    }

    charrb->chr_write = null_chr_write;

    charrb->explicit_be_open = true;

    return charrb;

}
",0,0,0,-1,"id,backend,ret,errp,chr,common","id:-0.0006436528638005257,backend:0.0007144836708903313,ret:-0.001034177839756012,errp:0.0024875281378626823,chr:0.0030812108889222145,common:0.004438122734427452,",5,12,"common:document,chr:charrb,errp:errfp,backend:backend,id:create,ret:obj,",Greedy,217,0.04027196963628133
48,"static int packet_enqueue(CompareState *s, int mode)

{

    ConnectionKey key;

    Packet *pkt = NULL;

    Connection *conn;



    if (mode == PRIMARY_IN) {

        pkt = packet_new(s->pri_rs.buf,

                         s->pri_rs.packet_len,

                         s->pri_rs.vnet_hdr_len);

    } else {

        pkt = packet_new(s->sec_rs.buf,

                         s->sec_rs.packet_len,

                         s->sec_rs.vnet_hdr_len);

    }



    if (parse_packet_early(pkt)) {

        packet_destroy(pkt, NULL);

        pkt = NULL;

        return -1;

    }

    fill_connection_key(pkt, &key);



    conn = connection_get(s->connection_track_table,

                          &key,

                          &s->conn_list);



    if (!conn->processing) {

        g_queue_push_tail(&s->conn_list, conn);

        conn->processing = true;

    }



    if (mode == PRIMARY_IN) {

        if (!colo_insert_packet(&conn->primary_list, pkt)) {

            error_report(""colo compare primary queue size too big,""

                         ""drop packet"");

        }

    } else {

        if (!colo_insert_packet(&conn->secondary_list, pkt)) {

            error_report(""colo compare secondary queue size too big,""

                         ""drop packet"");

        }

    }



    return 0;

}
",216,"static int packet_enqueue(CompareState *services, int table)

{

    ConnectionKey er;

    Packet *pet = NULL;

    Connection *conn;



    if (table == PRIMARY_IN) {

        pet = packet_new(services->pri_rs.buf,

                         services->pri_rs.packet_len,

                         services->pri_rs.vnet_hdr_len);

    } else {

        pet = packet_new(services->sec_rs.buf,

                         services->sec_rs.packet_len,

                         services->sec_rs.vnet_hdr_len);

    }



    if (parse_packet_early(pet)) {

        packet_destroy(pet, NULL);

        pet = NULL;

        return -1;

    }

    fill_connection_key(pet, &er);



    conn = connection_get(services->connection_track_table,

                          &er,

                          &services->conn_list);



    if (!conn->processing) {

        g_queue_push_tail(&services->conn_list, conn);

        conn->processing = true;

    }



    if (table == PRIMARY_IN) {

        if (!colo_insert_packet(&conn->primary_list, pet)) {

            error_report(""colo compare primary queue size too big,""

                         ""drop packet"");

        }

    } else {

        if (!colo_insert_packet(&conn->secondary_list, pet)) {

            error_report(""colo compare secondary queue size too big,""

                         ""drop packet"");

        }

    }



    return 0;

}
",0,0,1,1,"s,mode,key,pkt,conn","s:0.012520983815193176,mode:0.033996954560279846,key:-0.028503671288490295,pkt:0.10970281064510345,conn:-0.06214971840381622,",4,25,"pkt:pet,mode:table,s:services,key:er,",Greedy,247,0.04513976573944092
49,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)

{

    int i;

    for(i=0; i<4 && tags[i]; i++){

        enum CodecID id= codec_get_id(tags[i], tag);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
",67,"enum CodecID av_codec_get_id(const AVCodecTag *groups[4], unsigned int patch)

{

    int i;

    for(i=0; i<4 && groups[i]; i++){

        enum CodecID id= codec_get_id(groups[i], patch);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
",0,0,1,1,"tags,tag,i","tags:-0.017446335405111313,tag:0.14232534170150757,i:-0.028272505849599838,",2,5,"tag:patch,tags:groups,",Greedy,97,0.01962367296218872
50,"static void ide_atapi_identify(IDEState *s)

{

    uint16_t *p;



    if (s->identify_set) {

	memcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data));

	return;

    }



    memset(s->io_buffer, 0, 512);

    p = (uint16_t *)s->io_buffer;

    /* Removable CDROM, 50us response, 12 byte packets */

    put_le16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0));

    padstr((char *)(p + 10), s->drive_serial_str, 20); /* serial number */

    put_le16(p + 20, 3); /* buffer type */

    put_le16(p + 21, 512); /* cache size in sectors */

    put_le16(p + 22, 4); /* ecc bytes */

    padstr((char *)(p + 23), s->version, 8); /* firmware version */

    padstr((char *)(p + 27), ""QEMU DVD-ROM"", 40); /* model */

    put_le16(p + 48, 1); /* dword I/O (XXX: should not be set on CDROM) */

#ifdef USE_DMA_CDROM

    put_le16(p + 49, 1 << 9 | 1 << 8); /* DMA and LBA supported */

    put_le16(p + 53, 7); /* words 64-70, 54-58, 88 valid */

    put_le16(p + 62, 7);  /* single word dma0-2 supported */

    put_le16(p + 63, 7);  /* mdma0-2 supported */

#else

    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */

    put_le16(p + 53, 3); /* words 64-70, 54-58 valid */

    put_le16(p + 63, 0x103); /* DMA modes XXX: may be incorrect */

#endif

    put_le16(p + 64, 3); /* pio3-4 supported */

    put_le16(p + 65, 0xb4); /* minimum DMA multiword tx cycle time */

    put_le16(p + 66, 0xb4); /* recommended DMA multiword tx cycle time */

    put_le16(p + 67, 0x12c); /* minimum PIO cycle time without flow control */

    put_le16(p + 68, 0xb4); /* minimum PIO cycle time with IORDY flow control */



    put_le16(p + 71, 30); /* in ns */

    put_le16(p + 72, 30); /* in ns */



    if (s->ncq_queues) {

        put_le16(p + 75, s->ncq_queues - 1);

        /* NCQ supported */

        put_le16(p + 76, (1 << 8));

    }



    put_le16(p + 80, 0x1e); /* support up to ATA/ATAPI-4 */

#ifdef USE_DMA_CDROM

    put_le16(p + 88, 0x3f | (1 << 13)); /* udma5 set and supported */

#endif

    memcpy(s->identify_data, p, sizeof(s->identify_data));

    s->identify_set = 1;

}
",413,"static void ide_atapi_identify(IDEState *sets)

{

    uint16_t *bp;



    if (sets->identify_set) {

	memcpy(sets->io_buffer, sets->identify_data, sizeof(sets->identify_data));

	return;

    }



    memset(sets->io_buffer, 0, 512);

    bp = (uint16_t *)sets->io_buffer;

    /* Removable CDROM, 50us response, 12 byte packets */

    put_le16(bp + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0));

    padstr((char *)(bp + 10), sets->drive_serial_str, 20); /* serial number */

    put_le16(bp + 20, 3); /* buffer type */

    put_le16(bp + 21, 512); /* cache size in sectors */

    put_le16(bp + 22, 4); /* ecc bytes */

    padstr((char *)(bp + 23), sets->version, 8); /* firmware version */

    padstr((char *)(bp + 27), ""QEMU DVD-ROM"", 40); /* model */

    put_le16(bp + 48, 1); /* dword I/O (XXX: should not be set on CDROM) */

#ifdef USE_DMA_CDROM

    put_le16(bp + 49, 1 << 9 | 1 << 8); /* DMA and LBA supported */

    put_le16(bp + 53, 7); /* words 64-70, 54-58, 88 valid */

    put_le16(bp + 62, 7);  /* single word dma0-2 supported */

    put_le16(bp + 63, 7);  /* mdma0-2 supported */

#else

    put_le16(bp + 49, 1 << 9); /* LBA supported, no DMA */

    put_le16(bp + 53, 3); /* words 64-70, 54-58 valid */

    put_le16(bp + 63, 0x103); /* DMA modes XXX: may be incorrect */

#endif

    put_le16(bp + 64, 3); /* pio3-4 supported */

    put_le16(bp + 65, 0xb4); /* minimum DMA multiword tx cycle time */

    put_le16(bp + 66, 0xb4); /* recommended DMA multiword tx cycle time */

    put_le16(bp + 67, 0x12c); /* minimum PIO cycle time without flow control */

    put_le16(bp + 68, 0xb4); /* minimum PIO cycle time with IORDY flow control */



    put_le16(bp + 71, 30); /* in ns */

    put_le16(bp + 72, 30); /* in ns */



    if (sets->ncq_queues) {

        put_le16(bp + 75, sets->ncq_queues - 1);

        /* NCQ supported */

        put_le16(bp + 76, (1 << 8));

    }



    put_le16(bp + 80, 0x1e); /* support up to ATA/ATAPI-4 */

#ifdef USE_DMA_CDROM

    put_le16(bp + 88, 0x3f | (1 << 13)); /* udma5 set and supported */

#endif

    memcpy(sets->identify_data, bp, sizeof(sets->identify_data));

    sets->identify_set = 1;

}
",0,0,0,-1,"s,p","s:0.030086148530244827,p:0.06849627383053303,",2,43,"p:bp,s:sets,",Greedy,190,0.03814598321914673
51,"static int kvm_put_xsave(CPUState *env)

{

#ifdef KVM_CAP_XSAVE

    int i, r;

    struct kvm_xsave* xsave;

    uint16_t cwd, swd, twd, fop;



    if (!kvm_has_xsave())

        return kvm_put_fpu(env);



    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));

    memset(xsave, 0, sizeof(struct kvm_xsave));

    cwd = swd = twd = fop = 0;

    swd = env->fpus & ~(7 << 11);

    swd |= (env->fpstt & 7) << 11;

    cwd = env->fpuc;

    for (i = 0; i < 8; ++i)

        twd |= (!env->fptags[i]) << i;

    xsave->region[0] = (uint32_t)(swd << 16) + cwd;

    xsave->region[1] = (uint32_t)(fop << 16) + twd;

    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,

            sizeof env->fpregs);

    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,

            sizeof env->xmm_regs);

    xsave->region[XSAVE_MXCSR] = env->mxcsr;

    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;

    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,

            sizeof env->ymmh_regs);

    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);

    qemu_free(xsave);

    return r;

#else

    return kvm_put_fpu(env);

#endif

}
",289,,0,1,,-4,"env,i,r,xsave,cwd,swd,twd,fop",,,,,Greedy,1,0.002307732899983724
52,"static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,

	int numLines, int levelFix)

{

	int i;

	if(levelFix)

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax \n\t""

						""movl %%eax, temp0\n\t""

						""pushl %0 \n\t""

						""pushl %1 \n\t""

						""leal (%2,%2), %%eax	\n\t""

						""leal (%3,%3), %%ebx	\n\t""

						""movq packedYOffset, %%mm2	\n\t""

						""movq packedYScale, %%mm3	\n\t""

						""pxor %%mm4, %%mm4	\n\t""



#define SCALED_CPY					\

						""movq (%0), %%mm0	\n\t""\

						""movq (%0,%2), %%mm1	\n\t""\

						""psubusb %%mm2, %%mm0	\n\t""\

						""psubusb %%mm2, %%mm1	\n\t""\

						""movq %%mm0, %%mm5	\n\t""\

						""punpcklbw %%mm4, %%mm0 \n\t""\

						""punpckhbw %%mm4, %%mm5 \n\t""\

						""psllw $7, %%mm0	\n\t""\

						""psllw $7, %%mm5	\n\t""\

						""pmulhw %%mm3, %%mm0	\n\t""\

						""pmulhw %%mm3, %%mm5	\n\t""\

						""packuswb %%mm5, %%mm0	\n\t""\

						""movq %%mm0, (%1)	\n\t""\

						""movq %%mm1, %%mm5	\n\t""\

						""punpcklbw %%mm4, %%mm1 \n\t""\

						""punpckhbw %%mm4, %%mm5 \n\t""\

						""psllw $7, %%mm1	\n\t""\

						""psllw $7, %%mm5	\n\t""\

						""pmulhw %%mm3, %%mm1	\n\t""\

						""pmulhw %%mm3, %%mm5	\n\t""\

						""packuswb %%mm5, %%mm1	\n\t""\

						""movq %%mm1, (%1, %3)	\n\t""\



						""1:			\n\t""

SCALED_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

SCALED_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

						""decl temp0		\n\t""

						""jnz 1b			\n\t""



						""popl %1 \n\t""

						""popl %0 \n\t""

						: : ""r"" (src),

						""r"" (dst),

						""r"" (srcStride),

						""r"" (dstStride),

						""m"" (numLines>>2)

						: ""%eax"", ""%ebx""

					);

#else

				for(i=0; i<numLines; i++)

					memcpy(	&(dst[dstStride*i]),

						&(src[srcStride*i]), BLOCK_SIZE);

#endif

	}

	else

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax \n\t""

						""movl %%eax, temp0\n\t""

						""pushl %0 \n\t""

						""pushl %1 \n\t""

						""leal (%2,%2), %%eax	\n\t""

						""leal (%3,%3), %%ebx	\n\t""

						""movq packedYOffset, %%mm2	\n\t""

						""movq packedYScale, %%mm3	\n\t""



#define SIMPLE_CPY					\

						""movq (%0), %%mm0	\n\t""\

						""movq (%0,%2), %%mm1	\n\t""\

						""movq %%mm0, (%1)	\n\t""\

						""movq %%mm1, (%1, %3)	\n\t""\



						""1:			\n\t""

SIMPLE_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

SIMPLE_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

						""decl temp0		\n\t""

						""jnz 1b			\n\t""



						""popl %1 \n\t""

						""popl %0 \n\t""

						: : ""r"" (src),

						""r"" (dst),

						""r"" (srcStride),

						""r"" (dstStride),

						""m"" (numLines>>2)

						: ""%eax"", ""%ebx""

					);

#else

				for(i=0; i<numLines; i++)

					memcpy(	&(dst[dstStride*i]),

						&(src[srcStride*i]), BLOCK_SIZE);

#endif

	}

}
",436,"static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,

	int numLines, int  levelApply)

{

	int i;

	if( levelApply)

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax 
\t""

						""movl %%eax, temp0
\t""

						""pushl %0 
\t""

						""pushl %1 
\t""

						""leal (%2,%2), %%eax	
\t""

						""leal (%3,%3), %%ebx	
\t""

						""movq packedYOffset, %%mm2	
\t""

						""movq packedYScale, %%mm3	
\t""

						""pxor %%mm4, %%mm4	
\t""



#define SCALED_CPY					\

						""movq (%0), %%mm0	
\t""\

						""movq (%0,%2), %%mm1	
\t""\

						""psubusb %%mm2, %%mm0	
\t""\

						""psubusb %%mm2, %%mm1	
\t""\

						""movq %%mm0, %%mm5	
\t""\

						""punpcklbw %%mm4, %%mm0 
\t""\

						""punpckhbw %%mm4, %%mm5 
\t""\

						""psllw $7, %%mm0	
\t""\

						""psllw $7, %%mm5	
\t""\

						""pmulhw %%mm3, %%mm0	
\t""\

						""pmulhw %%mm3, %%mm5	
\t""\

						""packuswb %%mm5, %%mm0	
\t""\

						""movq %%mm0, (%1)	
\t""\

						""movq %%mm1, %%mm5	
\t""\

						""punpcklbw %%mm4, %%mm1 
\t""\

						""punpckhbw %%mm4, %%mm5 
\t""\

						""psllw $7, %%mm1	
\t""\

						""psllw $7, %%mm5	
\t""\

						""pmulhw %%mm3, %%mm1	
\t""\

						""pmulhw %%mm3, %%mm5	
\t""\

						""packuswb %%mm5, %%mm1	
\t""\

						""movq %%mm1, (%1, %3)	
\t""\



						""1:			
\t""

SCALED_CPY

						""addl %%eax, %0		
\t""

						""addl %%ebx, %1		
\t""

SCALED_CPY

						""addl %%eax, %0		
\t""

						""addl %%ebx, %1		
\t""

						""decl temp0		
\t""

						""jnz 1b			
\t""



						""popl %1 
\t""

						""popl %0 
\t""

						: : ""r"" (src),

						""r"" (dst),

						""r"" (srcStride),

						""r"" (dstStride),

						""m"" (numLines>>2)

						: ""%eax"", ""%ebx""

					);

#else

				for(i=0; i<numLines; i++)

					memcpy(	&(dst[dstStride*i]),

						&(src[srcStride*i]), BLOCK_SIZE);

#endif

	}

	else

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax 
\t""

						""movl %%eax, temp0
\t""

						""pushl %0 
\t""

						""pushl %1 
\t""

						""leal (%2,%2), %%eax	
\t""

						""leal (%3,%3), %%ebx	
\t""

						""movq packedYOffset, %%mm2	
\t""

						""movq packedYScale, %%mm3	
\t""



#define SIMPLE_CPY					\

						""movq (%0), %%mm0	
\t""\

						""movq (%0,%2), %%mm1	
\t""\

						""movq %%mm0, (%1)	
\t""\

						""movq %%mm1, (%1, %3)	
\t""\



						""1:			
\t""

SIMPLE_CPY

						""addl %%eax, %0		
\t""

						""addl %%ebx, %1		
\t""

SIMPLE_CPY

						""addl %%eax, %0		
\t""

						""addl %%ebx, %1		
\t""

						""decl temp0		
\t""

						""jnz 1b			
\t""



						""popl %1 
\t""

						""popl %0 
\t""

						: : ""r"" (src),

						""r"" (dst),

						""r"" (srcStride),

						""r"" (dstStride),

						""m"" (numLines>>2)

						: ""%eax"", ""%ebx""

					);

#else

				for(i=0; i<numLines; i++)

					memcpy(	&(dst[dstStride*i]),

						&(src[srcStride*i]), BLOCK_SIZE);

#endif

	}

}
",1,1,0,1,"dst,dstStride,src,srcStride,numLines,levelFix,i","dst:-0.06808800995349884,dstStride:0.01122109591960907,src:-0.04519238322973251,srcStride:0.14721280336380005,numLines:0.08631476759910583,levelFix:0.555027574300766,i:-0.09557837247848511,",1,2,"levelFix: levelApply,",Greedy,68,0.017095688978830972
53,"build_tpm2(GArray *table_data, BIOSLinker *linker)

{

    Acpi20TPM2 *tpm2_ptr;



    tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr);



    tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT);

    tpm2_ptr->control_area_address = cpu_to_le64(0);

    tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO);



    build_header(linker, table_data,

                 (void *)tpm2_ptr, ""TPM2"", sizeof(*tpm2_ptr), 4, NULL, NULL);

}
",83,,1,0,,-4,tpm2_ptr,,,,,Greedy,1,0.0021214763323465983
54,"int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush)

{

    do {

        int nb_output = 0;

        int min_poc   = INT_MAX;

        int i, min_idx, ret;



        if (s->sh.no_output_of_prior_pics_flag == 1) {

            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {

                HEVCFrame *frame = &s->DPB[i];

                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&

                        frame->sequence == s->seq_output) {

                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);

                }

            }

        }



        for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {

            HEVCFrame *frame = &s->DPB[i];

            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&

                frame->sequence == s->seq_output) {

                nb_output++;

                if (frame->poc < min_poc) {

                    min_poc = frame->poc;

                    min_idx = i;

                }

            }

        }



        /* wait for more frames before output */

        if (!flush && s->seq_output == s->seq_decode && s->sps &&

            nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics)

            return 0;



        if (nb_output) {

            HEVCFrame *frame = &s->DPB[min_idx];

            AVFrame *dst = out;

            AVFrame *src = frame->frame;

            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);

            int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);



            ret = av_frame_ref(out, src);

            if (frame->flags & HEVC_FRAME_FLAG_BUMPING)

                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);

            else

                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);

            if (ret < 0)

                return ret;



            for (i = 0; i < 3; i++) {

                int hshift = (i > 0) ? desc->log2_chroma_w : 0;

                int vshift = (i > 0) ? desc->log2_chroma_h : 0;

                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +

                          (frame->window.top_offset   >> vshift) * dst->linesize[i];

                dst->data[i] += off;

            }

            av_log(s->avctx, AV_LOG_DEBUG,

                   ""Output frame with POC %d.\n"", frame->poc);

            return 1;

        }



        if (s->seq_output != s->seq_decode)

            s->seq_output = (s->seq_output + 1) & 0xff;

        else

            break;

    } while (1);



    return 0;

}
",483,"int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush)

{

    do {

        int nc64input = 0;

        int min_poc   = INT_MAX;

        int i, min_idx, ret;



        if (s->sh.no_output_of_prior_pics_flag == 1) {

            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {

                HEVCFrame *frame = &s->DPB[i];

                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&

                        frame->sequence == s->seq_output) {

                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);

                }

            }

        }



        for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {

            HEVCFrame *frame = &s->DPB[i];

            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&

                frame->sequence == s->seq_output) {

                nc64input++;

                if (frame->poc < min_poc) {

                    min_poc = frame->poc;

                    min_idx = i;

                }

            }

        }



        /* wait for more frames before output */

        if (!flush && s->seq_output == s->seq_decode && s->sps &&

            nc64input <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics)

            return 0;



        if (nc64input) {

            HEVCFrame *frame = &s->DPB[min_idx];

            AVFrame *fsrc = out;

            AVFrame *src = frame->frame;

            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);

            int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);



            ret = av_frame_ref(out, src);

            if (frame->flags & HEVC_FRAME_FLAG_BUMPING)

                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);

            else

                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);

            if (ret < 0)

                return ret;



            for (i = 0; i < 3; i++) {

                int hshift = (i > 0) ? desc->log2_chroma_w : 0;

                int vshift = (i > 0) ? desc->log2_chroma_h : 0;

                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +

                          (frame->window.top_offset   >> vshift) * fsrc->linesize[i];

                fsrc->data[i] += off;

            }

            av_log(s->avctx, AV_LOG_DEBUG,

                   ""Output frame with POC %d.
"", frame->poc);

            return 1;

        }



        if (s->seq_output != s->seq_decode)

            s->seq_output = (s->seq_output + 1) & 0xff;

        else

            break;

    } while (1);



    return 0;

}
",1,1,0,1,"s,out,i,min_idx,ret,frame,nb_output,dst,src,desc","s:-0.04581877589225769,out:-0.06250491738319397,i:-0.11831903457641602,min_idx:-0.04061388969421387,ret:-0.036690980195999146,frame:-0.1156841516494751,nb_output:0.02991381287574768,dst:0.028823018074035645,src:-0.054262131452560425,desc:-0.04145041108131409,",2,7,"nb_output:nc64input,dst:fsrc,",Greedy,151,0.031643104553222653
55,"static int mpegaudio_parse(AVCodecParserContext *s1,

                           AVCodecContext *avctx,

                           uint8_t **poutbuf, int *poutbuf_size, 

                           const uint8_t *buf, int buf_size)

{

    MpegAudioParseContext *s = s1->priv_data;

    int len, ret;

    uint32_t header;

    const uint8_t *buf_ptr;



    *poutbuf = NULL;

    *poutbuf_size = 0;

    buf_ptr = buf;

    while (buf_size > 0) {

	len = s->inbuf_ptr - s->inbuf;

	if (s->frame_size == 0) {

            /* special case for next header for first frame in free

               format case (XXX: find a simpler method) */

            if (s->free_format_next_header != 0) {

                s->inbuf[0] = s->free_format_next_header >> 24;

                s->inbuf[1] = s->free_format_next_header >> 16;

                s->inbuf[2] = s->free_format_next_header >> 8;

                s->inbuf[3] = s->free_format_next_header;

                s->inbuf_ptr = s->inbuf + 4;

                s->free_format_next_header = 0;

                goto got_header;

            }

	    /* no header seen : find one. We need at least MPA_HEADER_SIZE

               bytes to parse it */

	    len = MPA_HEADER_SIZE - len;

	    if (len > buf_size)

		len = buf_size;

	    if (len > 0) {

		memcpy(s->inbuf_ptr, buf_ptr, len);

		buf_ptr += len;

		buf_size -= len;

		s->inbuf_ptr += len;

	    }

	    if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) {

            got_header:

		header = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |

		    (s->inbuf[2] << 8) | s->inbuf[3];



                ret = mpa_decode_header(avctx, header);

                if (ret < 0) {

		    /* no sync found : move by one byte (inefficient, but simple!) */

		    memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);

		    s->inbuf_ptr--;

                    dprintf(""skip %x\n"", header);

                    /* reset free format frame size to give a chance

                       to get a new bitrate */

                    s->free_format_frame_size = 0;

		} else {

                    s->frame_size = ret;

#if 0

                    /* free format: prepare to compute frame size */

		    if (decode_header(s, header) == 1) {

			s->frame_size = -1;

                    }

#endif

		}

	    }

        } else 

#if 0

        if (s->frame_size == -1) {

            /* free format : find next sync to compute frame size */

	    len = MPA_MAX_CODED_FRAME_SIZE - len;

	    if (len > buf_size)

		len = buf_size;

            if (len == 0) {

		/* frame too long: resync */

                s->frame_size = 0;

		memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);

		s->inbuf_ptr--;

            } else {

                uint8_t *p, *pend;

                uint32_t header1;

                int padding;



                memcpy(s->inbuf_ptr, buf_ptr, len);

                /* check for header */

                p = s->inbuf_ptr - 3;

                pend = s->inbuf_ptr + len - 4;

                while (p <= pend) {

                    header = (p[0] << 24) | (p[1] << 16) |

                        (p[2] << 8) | p[3];

                    header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |

                        (s->inbuf[2] << 8) | s->inbuf[3];

                    /* check with high probability that we have a

                       valid header */

                    if ((header & SAME_HEADER_MASK) ==

                        (header1 & SAME_HEADER_MASK)) {

                        /* header found: update pointers */

                        len = (p + 4) - s->inbuf_ptr;

                        buf_ptr += len;

                        buf_size -= len;

                        s->inbuf_ptr = p;

                        /* compute frame size */

                        s->free_format_next_header = header;

                        s->free_format_frame_size = s->inbuf_ptr - s->inbuf;

                        padding = (header1 >> 9) & 1;

                        if (s->layer == 1)

                            s->free_format_frame_size -= padding * 4;

                        else

                            s->free_format_frame_size -= padding;

                        dprintf(""free frame size=%d padding=%d\n"", 

                                s->free_format_frame_size, padding);

                        decode_header(s, header1);

                        goto next_data;

                    }

                    p++;

                }

                /* not found: simply increase pointers */

                buf_ptr += len;

                s->inbuf_ptr += len;

                buf_size -= len;

            }

	} else 

#endif

        if (len < s->frame_size) {

            if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE)

                s->frame_size = MPA_MAX_CODED_FRAME_SIZE;

	    len = s->frame_size - len;

	    if (len > buf_size)

		len = buf_size;

	    memcpy(s->inbuf_ptr, buf_ptr, len);

	    buf_ptr += len;

	    s->inbuf_ptr += len;

	    buf_size -= len;

	}

        //    next_data:

        if (s->frame_size > 0 && 

            (s->inbuf_ptr - s->inbuf) >= s->frame_size) {

            *poutbuf = s->inbuf;

            *poutbuf_size = s->inbuf_ptr - s->inbuf;

	    s->inbuf_ptr = s->inbuf;

	    s->frame_size = 0;

	    break;

	}

    }

    return buf_ptr - buf;

}
",838,"static int mpegaudio_parse(AVCodecParserContext *s1,

                           AVCodecContext *avctx,

                           uint8_t **poutbuf, int *poutbuf_size, 

                           const uint8_t *buf, int buf_size)

{

    MpegAudioParseContext *s = s1->priv_data;

    int len, ret;

    uint32_t header;

    const uint8_t *buf_ptr;



    *poutbuf = NULL;

    *poutbuf_size = 0;

    buf_ptr = buf;

    while (buf_size > 0) {

	len = s->inqueue_err - s->inbuf;

	if (s->frame_size == 0) {

            /* special case for next header for first frame in free

               format case (XXX: find a simpler method) */

            if (s->free_format_next_header != 0) {

                s->inbuf[0] = s->free_format_next_header >> 24;

                s->inbuf[1] = s->free_format_next_header >> 16;

                s->inbuf[2] = s->free_format_next_header >> 8;

                s->inbuf[3] = s->free_format_next_header;

                s->inqueue_err = s->inbuf + 4;

                s->free_format_next_header = 0;

                goto got_header;

            }

	    /* no header seen : find one. We need at least MPA_HEADER_SIZE

               bytes to parse it */

	    len = MPA_HEADER_SIZE - len;

	    if (len > buf_size)

		len = buf_size;

	    if (len > 0) {

		memcpy(s->inqueue_err, buf_ptr, len);

		buf_ptr += len;

		buf_size -= len;

		s->inqueue_err += len;

	    }

	    if ((s->inqueue_err - s->inbuf) >= MPA_HEADER_SIZE) {

            got_header:

		header = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |

		    (s->inbuf[2] << 8) | s->inbuf[3];



                ret = mpa_decode_header(avctx, header);

                if (ret < 0) {

		    /* no sync found : move by one byte (inefficient, but simple!) */

		    memmove(s->inbuf, s->inbuf + 1, s->inqueue_err - s->inbuf - 1);

		    s->inqueue_err--;

                    dprintf(""skip %x
"", header);

                    /* reset free format frame size to give a chance

                       to get a new bitrate */

                    s->free_format_frame_size = 0;

		} else {

                    s->frame_size = ret;

#if 0

                    /* free format: prepare to compute frame size */

		    if (decode_header(s, header) == 1) {

			s->frame_size = -1;

                    }

#endif

		}

	    }

        } else 

#if 0

        if (s->frame_size == -1) {

            /* free format : find next sync to compute frame size */

	    len = MPA_MAX_CODED_FRAME_SIZE - len;

	    if (len > buf_size)

		len = buf_size;

            if (len == 0) {

		/* frame too long: resync */

                s->frame_size = 0;

		memmove(s->inbuf, s->inbuf + 1, s->inqueue_err - s->inbuf - 1);

		s->inqueue_err--;

            } else {

                uint8_t *p, *pend;

                uint32_t header1;

                int padding;



                memcpy(s->inqueue_err, buf_ptr, len);

                /* check for header */

                p = s->inqueue_err - 3;

                pend = s->inqueue_err + len - 4;

                while (p <= pend) {

                    header = (p[0] << 24) | (p[1] << 16) |

                        (p[2] << 8) | p[3];

                    header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |

                        (s->inbuf[2] << 8) | s->inbuf[3];

                    /* check with high probability that we have a

                       valid header */

                    if ((header & SAME_HEADER_MASK) ==

                        (header1 & SAME_HEADER_MASK)) {

                        /* header found: update pointers */

                        len = (p + 4) - s->inqueue_err;

                        buf_ptr += len;

                        buf_size -= len;

                        s->inqueue_err = p;

                        /* compute frame size */

                        s->free_format_next_header = header;

                        s->free_format_frame_size = s->inqueue_err - s->inbuf;

                        padding = (header1 >> 9) & 1;

                        if (s->layer == 1)

                            s->free_format_frame_size -= padding * 4;

                        else

                            s->free_format_frame_size -= padding;

                        dprintf(""free frame size=%d padding=%d
"", 

                                s->free_format_frame_size, padding);

                        decode_header(s, header1);

                        goto next_data;

                    }

                    p++;

                }

                /* not found: simply increase pointers */

                buf_ptr += len;

                s->inqueue_err += len;

                buf_size -= len;

            }

	} else 

#endif

        if (len < s->frame_size) {

            if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE)

                s->frame_size = MPA_MAX_CODED_FRAME_SIZE;

	    len = s->frame_size - len;

	    if (len > buf_size)

		len = buf_size;

	    memcpy(s->inqueue_err, buf_ptr, len);

	    buf_ptr += len;

	    s->inqueue_err += len;

	    buf_size -= len;

	}

        //    next_data:

        if (s->frame_size > 0 && 

            (s->inqueue_err - s->inbuf) >= s->frame_size) {

            *poutbuf = s->inbuf;

            *poutbuf_size = s->inqueue_err - s->inbuf;

	    s->inqueue_err = s->inbuf;

	    s->frame_size = 0;

	    break;

	}

    }

    return buf_ptr - buf;

}
",0,0,1,1,"s1,avctx,poutbuf,poutbuf_size,buf,buf_size,s,len,ret,header,buf_ptr,inbuf_ptr","s1:-0.08459502458572388,avctx:0.034889042377471924,poutbuf:-0.05972757935523987,poutbuf_size:0.1205640435218811,buf:0.03615763783454895,buf_size:0.1945546269416809,s:-0.055284708738327026,len:0.19871920347213745,ret:0.029872208833694458,header:0.03077566623687744,buf_ptr:0.16434752941131592,inbuf_ptr:0.29493317008018494,",1,21,"inbuf_ptr:inqueue_err,",Greedy,209,0.04299556811650594
56,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}
",270,"JNIEnv *ff_jni_attach_env(int *attracted, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attracted = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper
"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper
"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine
"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread
"");

            env = NULL;

        } else {

            *attracted = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported
"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}
",0,0,1,1,"attached,log_ctx,env","attached:0.08207422494888306,log_ctx:-0.0831347405910492,env:-0.002860337495803833,",1,3,"attached:attracted,",Greedy,60,0.014698644479115805
57,"static int perform_cow(BlockDriverState *bs, QCowL2Meta *m)

{

    BDRVQcow2State *s = bs->opaque;

    Qcow2COWRegion *start = &m->cow_start;

    Qcow2COWRegion *end = &m->cow_end;

    unsigned buffer_size;

    unsigned data_bytes = end->offset - (start->offset + start->nb_bytes);

    bool merge_reads;

    uint8_t *start_buffer, *end_buffer;

    QEMUIOVector qiov;

    int ret;



    assert(start->nb_bytes <= UINT_MAX - end->nb_bytes);

    assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes);

    assert(start->offset + start->nb_bytes <= end->offset);

    assert(!m->data_qiov || m->data_qiov->size == data_bytes);



    if (start->nb_bytes == 0 && end->nb_bytes == 0) {

        return 0;

    }



    /* If we have to read both the start and end COW regions and the

     * middle region is not too large then perform just one read

     * operation */

    merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384;

    if (merge_reads) {

        buffer_size = start->nb_bytes + data_bytes + end->nb_bytes;

    } else {

        /* If we have to do two reads, add some padding in the middle

         * if necessary to make sure that the end region is optimally

         * aligned. */

        size_t align = bdrv_opt_mem_align(bs);

        assert(align > 0 && align <= UINT_MAX);

        assert(QEMU_ALIGN_UP(start->nb_bytes, align) <=

               UINT_MAX - end->nb_bytes);

        buffer_size = QEMU_ALIGN_UP(start->nb_bytes, align) + end->nb_bytes;

    }



    /* Reserve a buffer large enough to store all the data that we're

     * going to read */

    start_buffer = qemu_try_blockalign(bs, buffer_size);

    if (start_buffer == NULL) {

        return -ENOMEM;

    }

    /* The part of the buffer where the end region is located */

    end_buffer = start_buffer + buffer_size - end->nb_bytes;



    qemu_iovec_init(&qiov, 2 + (m->data_qiov ? m->data_qiov->niov : 0));



    qemu_co_mutex_unlock(&s->lock);

    /* First we read the existing data from both COW regions. We

     * either read the whole region in one go, or the start and end

     * regions separately. */

    if (merge_reads) {

        qemu_iovec_add(&qiov, start_buffer, buffer_size);

        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);

    } else {

        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);

        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);

        if (ret < 0) {

            goto fail;

        }



        qemu_iovec_reset(&qiov);

        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);

        ret = do_perform_cow_read(bs, m->offset, end->offset, &qiov);

    }

    if (ret < 0) {

        goto fail;

    }



    /* Encrypt the data if necessary before writing it */

    if (bs->encrypted) {

        if (!do_perform_cow_encrypt(bs, m->offset, start->offset,

                                    start_buffer, start->nb_bytes) ||

            !do_perform_cow_encrypt(bs, m->offset, end->offset,

                                    end_buffer, end->nb_bytes)) {

            ret = -EIO;

            goto fail;

        }

    }



    /* And now we can write everything. If we have the guest data we

     * can write everything in one single operation */

    if (m->data_qiov) {

        qemu_iovec_reset(&qiov);

        if (start->nb_bytes) {

            qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);

        }

        qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes);

        if (end->nb_bytes) {

            qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);

        }

        /* NOTE: we have a write_aio blkdebug event here followed by

         * a cow_write one in do_perform_cow_write(), but there's only

         * one single I/O operation */

        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);

        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);

    } else {

        /* If there's no guest data then write both COW regions separately */

        qemu_iovec_reset(&qiov);

        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);

        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);

        if (ret < 0) {

            goto fail;

        }



        qemu_iovec_reset(&qiov);

        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);

        ret = do_perform_cow_write(bs, m->alloc_offset, end->offset, &qiov);

    }



fail:

    qemu_co_mutex_lock(&s->lock);



    /*

     * Before we update the L2 table to actually point to the new cluster, we

     * need to be sure that the refcounts have been increased and COW was

     * handled.

     */

    if (ret == 0) {

        qcow2_cache_depends_on_flush(s->l2_table_cache);

    }



    qemu_vfree(start_buffer);

    qemu_iovec_destroy(&qiov);

    return ret;

}
",707,,1,0,,-4,"bs,m,s,start,end,buffer_size,merge_reads,start_buffer,end_buffer,qiov,ret",,,,,Greedy,1,0.002290193239847819
58,"void sws_rgb2rgb_init(int flags)

{

#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX

    if (flags & SWS_CPU_CAPS_SSE2)

        rgb2rgb_init_SSE2();

    else if (flags & SWS_CPU_CAPS_MMX2)

        rgb2rgb_init_MMX2();

    else if (flags & SWS_CPU_CAPS_3DNOW)

        rgb2rgb_init_3DNOW();

    else if (flags & SWS_CPU_CAPS_MMX)

        rgb2rgb_init_MMX();

    else

#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */

        rgb2rgb_init_C();

}
",66,"void sws_rgb2rgb_init(int posts)

{

#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX

    if (posts & SWS_CPU_CAPS_SSE2)

        rgb2rgb_init_SSE2();

    else if (posts & SWS_CPU_CAPS_MMX2)

        rgb2rgb_init_MMX2();

    else if (posts & SWS_CPU_CAPS_3DNOW)

        rgb2rgb_init_3DNOW();

    else if (posts & SWS_CPU_CAPS_MMX)

        rgb2rgb_init_MMX();

    else

#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */

        rgb2rgb_init_C();

}
",0,0,0,-1,flags,"flags:0.02212744578719139,",1,5,"flags:posts,",Greedy,61,0.01279764970143636
59,"static double tget_double(GetByteContext *gb, int le)

{

    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};

    return i.f64;

}
",38,"static double tget_double(GetByteContext *rb, int ee)

{

    av_alias64 i = { .u64 = ee ? bytestream2_get_le64(rb) : bytestream2_get_be64(rb)};

    return i.f64;

}
",0,0,0,-1,"gb,le","gb:-0.00038629863411188126,le:0.00012426264584064484,",2,5,"le:ee,gb:rb,",Greedy,98,0.018915836016337076
60,"static void init_proc_power5plus(CPUPPCState *env)

{

    gen_spr_ne_601(env);

    gen_spr_7xx(env);

    /* Time base */

    gen_tbl(env);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(env, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_clear,

                 0x60000000);

    /* XXX : not implemented */

    spr_register(env, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_750FX_HID2, ""HID2"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_970_HID5, ""HID5"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 POWERPC970_HID5_INIT);

    /* XXX : not implemented */

    spr_register(env, SPR_L2CR, ""L2CR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, NULL,

                 0x00000000);

    /* Memory management */

    /* XXX: not correct */

    gen_low_BATs(env);

    /* XXX : not implemented */

    spr_register(env, SPR_MMUCFG, ""MMUCFG"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, SPR_NOACCESS,

                 0x00000000); /* TOFIX */

    /* XXX : not implemented */

    spr_register(env, SPR_MMUCSR0, ""MMUCSR0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000); /* TOFIX */

    spr_register(env, SPR_HIOR, ""SPR_HIOR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_hior, &spr_write_hior,

                 0x00000000);

    spr_register(env, SPR_CTRL, ""SPR_CTRL"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    spr_register(env, SPR_UCTRL, ""SPR_UCTRL"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    spr_register(env, SPR_VRSAVE, ""SPR_VRSAVE"",

                 &spr_read_generic, &spr_write_generic,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

#if !defined(CONFIG_USER_ONLY)

    env->slb_nr = 64;

#endif

    init_excp_970(env);

    env->dcache_line_size = 128;

    env->icache_line_size = 128;

    /* Allocate hardware IRQ controller */

    ppc970_irq_init(env);

    /* Can't find information on what this should be on reset.  This

     * value is the one used by 74xx processors. */

    vscr_init(env, 0x00010000);

}
",315,"static void init_proc_power5plus(CPUPPCState *progress)

{

    gen_spr_ne_601(progress);

    gen_spr_7xx(progress);

    /* Time base */

    gen_tbl(progress);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(progress, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_clear,

                 0x60000000);

    /* XXX : not implemented */

    spr_register(progress, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(progress, SPR_750FX_HID2, ""HID2"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(progress, SPR_970_HID5, ""HID5"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 POWERPC970_HID5_INIT);

    /* XXX : not implemented */

    spr_register(progress, SPR_L2CR, ""L2CR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, NULL,

                 0x00000000);

    /* Memory management */

    /* XXX: not correct */

    gen_low_BATs(progress);

    /* XXX : not implemented */

    spr_register(progress, SPR_MMUCFG, ""MMUCFG"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, SPR_NOACCESS,

                 0x00000000); /* TOFIX */

    /* XXX : not implemented */

    spr_register(progress, SPR_MMUCSR0, ""MMUCSR0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000); /* TOFIX */

    spr_register(progress, SPR_HIOR, ""SPR_HIOR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_hior, &spr_write_hior,

                 0x00000000);

    spr_register(progress, SPR_CTRL, ""SPR_CTRL"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    spr_register(progress, SPR_UCTRL, ""SPR_UCTRL"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    spr_register(progress, SPR_VRSAVE, ""SPR_VRSAVE"",

                 &spr_read_generic, &spr_write_generic,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

#if !defined(CONFIG_USER_ONLY)

    progress->slb_nr = 64;

#endif

    init_excp_970(progress);

    progress->dcache_line_size = 128;

    progress->icache_line_size = 128;

    /* Allocate hardware IRQ controller */

    ppc970_irq_init(progress);

    /* Can't find information on what this should be on reset.  This

     * value is the one used by 74xx processors. */

    vscr_init(progress, 0x00010000);

}
",1,1,0,1,env,"env:0.07899585366249084,",1,22,"env:progress,",Greedy,93,0.020529715220133464
61,"static int64_t get_bit_rate(AVCodecContext *ctx)

{

    int64_t bit_rate;

    int bits_per_sample;



    switch (ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

    case AVMEDIA_TYPE_DATA:

    case AVMEDIA_TYPE_SUBTITLE:

    case AVMEDIA_TYPE_ATTACHMENT:

        bit_rate = ctx->bit_rate;

        break;

    case AVMEDIA_TYPE_AUDIO:

        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);

        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;

        break;

    default:

        bit_rate = 0;

        break;

    }

    return bit_rate;

}
",87,,1,0,,-4,"ctx,bit_rate,bits_per_sample",,,,,Greedy,1,0.00211867094039917
62,"static int mkv_write_codecprivate(AVFormatContext *s, AVIOContext *pb,

                                  AVCodecParameters *par,

                                  int native_id, int qt_id)

{

    AVIOContext *dyn_cp;

    uint8_t *codecpriv;

    int ret, codecpriv_size;



    ret = avio_open_dyn_buf(&dyn_cp);

    if (ret < 0)

        return ret;



    if (native_id) {

        ret = mkv_write_native_codecprivate(s, par, dyn_cp);

    } else if (par->codec_type == AVMEDIA_TYPE_VIDEO) {

        if (qt_id) {

            if (!par->codec_tag)

                par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags,

                                                    par->codec_id);

            if (   ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id

                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)

            ) {

                int i;

                avio_wb32(dyn_cp, 0x5a + par->extradata_size);

                avio_wl32(dyn_cp, par->codec_tag);

                for(i = 0; i < 0x5a - 8; i++)

                    avio_w8(dyn_cp, 0);

            }

            avio_write(dyn_cp, par->extradata, par->extradata_size);

        } else {

            if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id))

                av_log(s, AV_LOG_WARNING, ""codec %s is not supported by this format\n"",

                       avcodec_get_name(par->codec_id));



            if (!par->codec_tag)

                par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags,

                                                  par->codec_id);

            if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) {

                av_log(s, AV_LOG_ERROR, ""No bmp codec tag found for codec %s\n"",

                       avcodec_get_name(par->codec_id));

                ret = AVERROR(EINVAL);

            }



            ff_put_bmp_header(dyn_cp, par, ff_codec_bmp_tags, 0, 0);

        }

    } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {

        unsigned int tag;

        tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id);

        if (!tag) {

            av_log(s, AV_LOG_ERROR, ""No wav codec tag found for codec %s\n"",

                   avcodec_get_name(par->codec_id));

            ret = AVERROR(EINVAL);

        }

        if (!par->codec_tag)

            par->codec_tag = tag;



        ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX);

    }



    codecpriv_size = avio_close_dyn_buf(dyn_cp, &codecpriv);

    if (codecpriv_size)

        put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv,

                        codecpriv_size);

    av_free(codecpriv);

    return ret;

}
",426,"static int mkv_write_codecprivate(AVFormatContext *js, AVIOContext *rb,

                                  AVCodecParameters *par,

                                  int nativeacid, int qt00key)

{

    AVIOContext *dyn_cp;

    uint8_t * codecprivate;

    int flag, codecpriv_count;



    flag = avio_open_dyn_buf(&dyn_cp);

    if (flag < 0)

        return flag;



    if (nativeacid) {

        flag = mkv_write_native_codecprivate(js, par, dyn_cp);

    } else if (par->codec_type == AVMEDIA_TYPE_VIDEO) {

        if (qt00key) {

            if (!par->codec_tag)

                par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags,

                                                    par->codec_id);

            if (   ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id

                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)

            ) {

                int key;

                avio_wb32(dyn_cp, 0x5a + par->extradata_size);

                avio_wl32(dyn_cp, par->codec_tag);

                for(key = 0; key < 0x5a - 8; key++)

                    avio_w8(dyn_cp, 0);

            }

            avio_write(dyn_cp, par->extradata, par->extradata_size);

        } else {

            if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id))

                av_log(js, AV_LOG_WARNING, ""codec %s is not supported by this format
"",

                       avcodec_get_name(par->codec_id));



            if (!par->codec_tag)

                par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags,

                                                  par->codec_id);

            if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) {

                av_log(js, AV_LOG_ERROR, ""No bmp codec tag found for codec %s
"",

                       avcodec_get_name(par->codec_id));

                flag = AVERROR(EINVAL);

            }



            ff_put_bmp_header(dyn_cp, par, ff_codec_bmp_tags, 0, 0);

        }

    } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {

        unsigned int tag;

        tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id);

        if (!tag) {

            av_log(js, AV_LOG_ERROR, ""No wav codec tag found for codec %s
"",

                   avcodec_get_name(par->codec_id));

            flag = AVERROR(EINVAL);

        }

        if (!par->codec_tag)

            par->codec_tag = tag;



        ff_put_wav_header(js, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX);

    }



    codecpriv_count = avio_close_dyn_buf(dyn_cp, & codecprivate);

    if (codecpriv_count)

        put_ebml_binary(rb, MATROSKA_ID_CODECPRIVATE,  codecprivate,

                        codecpriv_count);

    av_free( codecprivate);

    return flag;

}
",0,0,1,1,"s,pb,par,native_id,qt_id,dyn_cp,codecpriv,ret,codecpriv_size,i","s:-0.07329162955284119,pb:0.009242802858352661,par:-0.5762490928173065,native_id:-0.039139747619628906,qt_id:-0.11637184023857117,dyn_cp:-0.4037989675998688,codecpriv:0.024729788303375244,ret:-0.1828499734401703,codecpriv_size:-0.03305312991142273,i:-0.14065444469451904,",8,32,"codecpriv: codecprivate,pb:rb,codecpriv_size:codecpriv_count,native_id:nativeacid,s:js,qt_id:qt00key,i:key,ret:flag,",Greedy,344,0.07668606440226237
63,"void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){

    int i, dc = (block[0] + 15) >> 5;

    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;



    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += line_size;

    }

}
",167,"void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *address/*align 16*/){

    int i, dc = (address[0] + 15) >> 5;

    const uint8_t *fm = ff_cropTbl + MAX_NEG_CROP + dc;



    for(i = 0; i < 8; i++){

        dest[0] = fm[dest[0]];

        dest[1] = fm[dest[1]];

        dest[2] = fm[dest[2]];

        dest[3] = fm[dest[3]];

        dest[4] = fm[dest[4]];

        dest[5] = fm[dest[5]];

        dest[6] = fm[dest[6]];

        dest[7] = fm[dest[7]];

        dest += line_size;

    }

}
",1,1,0,1,"dest,line_size,block,i,cm","dest:0.09596794843673706,line_size:0.0664219856262207,block:0.11574935913085938,i:0.053140997886657715,cm:0.6659906506538391,",2,11,"cm:fm,block:address,",Greedy,141,0.025970566272735595
64,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
",102,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*api)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *pot = g_malloc0(sizeof(*pot));



    pot->api = api;

    pot->set = set;



    object_property_add(obj, name, ""bool"",

                        api ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        pot, errp);

}
",1,1,0,1,"obj,name,get,set,errp,prop","obj:0.09068024158477783,name:0.051836252212524414,get:0.2769806981086731,set:0.08608204126358032,errp:-0.13153177499771118,prop:0.18772268295288086,",2,9,"get:api,prop:pot,",Greedy,125,0.023458981513977052
65,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
",41,"static inline int mirror(int v, int mm){

    if     (v<0) return -v;

    else if(v>mm) return 2*mm-v;

    else         return v;

}
",1,1,0,1,"v,m","v:-0.22129619121551514,m:-0.1281144618988037,",1,3,"m:mm,",Greedy,57,0.01238789161046346
66,"void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s)

{

    if (!s->started) {

        return;

    }

    s->started = false;

    trace_virtio_blk_data_plane_stop(s);



    /* Stop thread or cancel pending thread creation BH */

    if (s->start_bh) {

        qemu_bh_delete(s->start_bh);

        s->start_bh = NULL;

    } else {

        event_poll_notify(&s->event_poll);

        qemu_thread_join(&s->thread);

    }



    ioq_cleanup(&s->ioqueue);



    s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, false);



    event_poll_cleanup(&s->event_poll);



    /* Clean up guest notifier (irq) */

    s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, false);



    vring_teardown(&s->vring);

}
",133,,1,0,,-4,s,,,,,Greedy,1,0.0021042744318644207
67,"static int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov,

                              MOVTrack *track, AVStream *st)

{

    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,

                                      track->timescale, AV_ROUND_UP);

    int version = duration < INT32_MAX ? 0 : 1;

    int flags   = MOV_TKHD_FLAG_IN_MOVIE;

    int rotation = 0;

    int group   = 0;



    uint32_t *display_matrix = NULL;

    int      display_matrix_size, i;



    if (st) {

        if (mov->per_stream_grouping)

            group = st->index;

        else

            group = st->codecpar->codec_type;



        display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX,

                                                            &display_matrix_size);

        if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix))

            display_matrix = NULL;

    }



    if (track->flags & MOV_TRACK_ENABLED)

        flags |= MOV_TKHD_FLAG_ENABLED;



    if (track->mode == MODE_ISM)

        version = 1;



    (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92); /* size */

    ffio_wfourcc(pb, ""tkhd"");

    avio_w8(pb, version);

    avio_wb24(pb, flags);

    if (version == 1) {

        avio_wb64(pb, track->time);

        avio_wb64(pb, track->time);

    } else {

        avio_wb32(pb, track->time); /* creation time */

        avio_wb32(pb, track->time); /* modification time */

    }

    avio_wb32(pb, track->track_id); /* track-id */

    avio_wb32(pb, 0); /* reserved */

    if (!track->entry && mov->mode == MODE_ISM)

        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);

    else if (!track->entry)

        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);

    else

        (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);



    avio_wb32(pb, 0); /* reserved */

    avio_wb32(pb, 0); /* reserved */

    avio_wb16(pb, 0); /* layer */

    avio_wb16(pb, group); /* alternate group) */

    /* Volume, only for audio */

    if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)

        avio_wb16(pb, 0x0100);

    else

        avio_wb16(pb, 0);

    avio_wb16(pb, 0); /* reserved */



    /* Matrix structure */


    if (st && st->metadata) {

        AVDictionaryEntry *rot = av_dict_get(st->metadata, ""rotate"", NULL, 0);

        rotation = (rot && rot->value) ? atoi(rot->value) : 0;

    }


    if (display_matrix) {

        for (i = 0; i < 9; i++)

            avio_wb32(pb, display_matrix[i]);


    } else if (rotation == 90) {

        write_matrix(pb,  0,  1, -1,  0, track->par->height, 0);

    } else if (rotation == 180) {

        write_matrix(pb, -1,  0,  0, -1, track->par->width, track->par->height);

    } else if (rotation == 270) {

        write_matrix(pb,  0, -1,  1,  0, 0, track->par->width);


    } else {

        write_matrix(pb,  1,  0,  0,  1, 0, 0);

    }

    /* Track width and height, for visual only */

    if (st && (track->par->codec_type == AVMEDIA_TYPE_VIDEO ||

               track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) {

        int64_t track_width_1616;

        if (track->mode == MODE_MOV) {

            track_width_1616 = track->par->width * 0x10000ULL;

        } else {

            track_width_1616 = av_rescale(st->sample_aspect_ratio.num,

                                                  track->par->width * 0x10000LL,

                                                  st->sample_aspect_ratio.den);

            if (!track_width_1616 ||

                track->height != track->par->height ||

                track_width_1616 > UINT32_MAX)

                track_width_1616 = track->par->width * 0x10000ULL;

        }

        if (track_width_1616 > UINT32_MAX) {

            av_log(mov->fc, AV_LOG_WARNING, ""track width is too large\n"");

            track_width_1616 = 0;

        }

        avio_wb32(pb, track_width_1616);

        if (track->height > 0xFFFF) {

            av_log(mov->fc, AV_LOG_WARNING, ""track height is too large\n"");

            avio_wb32(pb, 0);

        } else

            avio_wb32(pb, track->height * 0x10000U);

    } else {

        avio_wb32(pb, 0);

        avio_wb32(pb, 0);

    }

    return 0x5c;

}",798,,1,0,,-4,"pb,mov,track,st,display_matrix,display_matrix_size,i",,,,,Greedy,1,0.0025035738945007324
68,"static int vobsub_read_seek(AVFormatContext *s, int stream_index,

                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)

{

    MpegDemuxContext *vobsub = s->priv_data;



    /* Rescale requested timestamps based on the first stream (timebase is the

     * same for all subtitles stream within a .idx/.sub). Rescaling is done just

     * like in avformat_seek_file(). */

    if (stream_index == -1 && s->nb_streams != 1) {

        int i, ret = 0;

        AVRational time_base = s->streams[0]->time_base;

        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);

        min_ts = av_rescale_rnd(min_ts, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);

        max_ts = av_rescale_rnd(max_ts, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);

        for (i = 0; i < s->nb_streams; i++) {

            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,

                                            min_ts, ts, max_ts, flags);

            if (r < 0)

                ret = r;

        }

        return ret;

    }





    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,

                                   min_ts, ts, max_ts, flags);

}",205,"static int vobsub_read_seek(AVFormatContext *self, int streamingindex,

                            int64_t  min_ats, int64_t ls, int64_t min_td, int fd)

{

    MpegDemuxContext *vobbsub = self->priv_data;



    /* Rescale requested timestamps based on the first stream (timebase is the

     * same for all subtitles stream within a .idx/.sub). Rescaling is done just

     * like in avformat_seek_file(). */

    if (streamingindex == -1 && self->nb_streams != 1) {

        int io, ret = 0;

        AVRational time_base = self->streams[0]->time_base;

        ls = av_rescale_q(ls, AV_TIME_BASE_Q, time_base);

         min_ats = av_rescale_rnd( min_ats, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);

        min_td = av_rescale_rnd(min_td, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);

        for (io = 0; io < self->nb_streams; io++) {

            int r = ff_subtitles_queue_seek(&vobbsub->q[io], self, streamingindex,

                                             min_ats, ls, min_td, fd);

            if (r < 0)

                ret = r;

        }

        return ret;

    }





    return ff_subtitles_queue_seek(&vobbsub->q[streamingindex], self, streamingindex,

                                    min_ats, ls, min_td, fd);

}",1,1,0,1,"s,stream_index,min_ts,ts,max_ts,flags,vobsub,i","s:0.10461431741714478,stream_index:0.08871150016784668,min_ts:0.08644920587539673,ts:-0.03576457500457764,max_ts:0.09243673086166382,flags:0.036132752895355225,vobsub:-0.019886672496795654,i:0.04540753364562988,",8,38,"s:self,max_ts:min_td,stream_index:streamingindex,min_ts: min_ats,i:io,flags:fd,vobsub:vobbsub,ts:ls,",Greedy,501,0.09192612965901693
69,"static av_cold int aac_encode_init(AVCodecContext *avctx)

{

    AACContext *s = avctx->priv_data;

    int ret = AVERROR(EINVAL);

    AACENC_InfoStruct info = { 0 };

    CHANNEL_MODE mode;

    AACENC_ERROR err;

    int aot = FF_PROFILE_AAC_LOW + 1;

    int sce = 0, cpe = 0;



    if ((err = aacEncOpen(&s->handle, 0, avctx->channels)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to open the encoder: %s\n"",

               aac_get_error(err));

        goto error;

    }



    if (avctx->profile != FF_PROFILE_UNKNOWN)

        aot = avctx->profile + 1;



    if ((err = aacEncoder_SetParam(s->handle, AACENC_AOT, aot)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to set the AOT %d: %s\n"",

               aot, aac_get_error(err));

        goto error;

    }



    if (aot == FF_PROFILE_AAC_ELD + 1 && s->eld_sbr) {

        if ((err = aacEncoder_SetParam(s->handle, AACENC_SBR_MODE,

                                       1)) != AACENC_OK) {

            av_log(avctx, AV_LOG_ERROR, ""Unable to enable SBR for ELD: %s\n"",

                   aac_get_error(err));

            goto error;

        }

    }



    if ((err = aacEncoder_SetParam(s->handle, AACENC_SAMPLERATE,

                                   avctx->sample_rate)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to set the sample rate %d: %s\n"",

               avctx->sample_rate, aac_get_error(err));

        goto error;

    }



    switch (avctx->channels) {

    case 1: mode = MODE_1;       sce = 1; cpe = 0; break;

    case 2: mode = MODE_2;       sce = 0; cpe = 1; break;

    case 3: mode = MODE_1_2;     sce = 1; cpe = 1; break;

    case 4: mode = MODE_1_2_1;   sce = 2; cpe = 1; break;

    case 5: mode = MODE_1_2_2;   sce = 1; cpe = 2; break;

    case 6: mode = MODE_1_2_2_1; sce = 2; cpe = 2; break;

    default:

        av_log(avctx, AV_LOG_ERROR,

               ""Unsupported number of channels %d\n"", avctx->channels);

        goto error;

    }



    if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELMODE,

                                   mode)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR,

               ""Unable to set channel mode %d: %s\n"", mode, aac_get_error(err));

        goto error;

    }



    if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELORDER,

                                   1)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR,

               ""Unable to set wav channel order %d: %s\n"",

               mode, aac_get_error(err));

        goto error;

    }



    if (avctx->flags & CODEC_FLAG_QSCALE || s->vbr) {

        int mode = s->vbr ? s->vbr : avctx->global_quality;

        if (mode <  1 || mode > 5) {

            av_log(avctx, AV_LOG_WARNING,

                   ""VBR quality %d out of range, should be 1-5\n"", mode);

            mode = av_clip(mode, 1, 5);

        }

        av_log(avctx, AV_LOG_WARNING,

               ""Note, the VBR setting is unsupported and only works with ""

               ""some parameter combinations\n"");

        if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATEMODE,

                                       mode)) != AACENC_OK) {

            av_log(avctx, AV_LOG_ERROR, ""Unable to set the VBR bitrate mode %d: %s\n"",

                   mode, aac_get_error(err));

            goto error;

        }

    } else {

        if (avctx->bit_rate <= 0) {

            if (avctx->profile == FF_PROFILE_AAC_HE_V2) {

                sce = 1;

                cpe = 0;

            }

            avctx->bit_rate = (96*sce + 128*cpe) * avctx->sample_rate / 44;

            if (avctx->profile == FF_PROFILE_AAC_HE ||

                avctx->profile == FF_PROFILE_AAC_HE_V2 ||

                s->eld_sbr)

                avctx->bit_rate /= 2;

        }

        if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATE,

                                       avctx->bit_rate)) != AACENC_OK) {

            av_log(avctx, AV_LOG_ERROR, ""Unable to set the bitrate %d: %s\n"",

                   avctx->bit_rate, aac_get_error(err));

            goto error;

        }

    }



    /* Choose bitstream format - if global header is requested, use

     * raw access units, otherwise use ADTS. */

    if ((err = aacEncoder_SetParam(s->handle, AACENC_TRANSMUX,

                                   avctx->flags & CODEC_FLAG_GLOBAL_HEADER ? 0 : s->latm ? 10 : 2)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to set the transmux format: %s\n"",

               aac_get_error(err));

        goto error;

    }



    if (s->latm && s->header_period) {

        if ((err = aacEncoder_SetParam(s->handle, AACENC_HEADER_PERIOD,

                                       s->header_period)) != AACENC_OK) {

             av_log(avctx, AV_LOG_ERROR, ""Unable to set header period: %s\n"",

                    aac_get_error(err));

             goto error;

        }

    }



    /* If no signaling mode is chosen, use explicit hierarchical signaling

     * if using mp4 mode (raw access units, with global header) and

     * implicit signaling if using ADTS. */

    if (s->signaling < 0)

        s->signaling = avctx->flags & CODEC_FLAG_GLOBAL_HEADER ? 2 : 0;



    if ((err = aacEncoder_SetParam(s->handle, AACENC_SIGNALING_MODE,

                                   s->signaling)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to set signaling mode %d: %s\n"",

               s->signaling, aac_get_error(err));

        goto error;

    }



    if ((err = aacEncoder_SetParam(s->handle, AACENC_AFTERBURNER,

                                   s->afterburner)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to set afterburner to %d: %s\n"",

               s->afterburner, aac_get_error(err));

        goto error;

    }



    if (avctx->cutoff > 0) {

        if (avctx->cutoff < (avctx->sample_rate + 255) >> 8) {

            av_log(avctx, AV_LOG_ERROR, ""cutoff valid range is %d-20000\n"",

                   (avctx->sample_rate + 255) >> 8);

            goto error;

        }

        if ((err = aacEncoder_SetParam(s->handle, AACENC_BANDWIDTH,

                                       avctx->cutoff)) != AACENC_OK) {

            av_log(avctx, AV_LOG_ERROR, ""Unable to set the encoder bandwidth to %d: %s\n"",

                   avctx->cutoff, aac_get_error(err));

            goto error;

        }

    }



    if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to initialize the encoder: %s\n"",

               aac_get_error(err));

        return AVERROR(EINVAL);

    }



    if ((err = aacEncInfo(s->handle, &info)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to get encoder info: %s\n"",

               aac_get_error(err));

        goto error;

    }



#if FF_API_OLD_ENCODE_AUDIO

    avctx->coded_frame = avcodec_alloc_frame();

    if (!avctx->coded_frame) {

        ret = AVERROR(ENOMEM);

        goto error;

    }

#endif

    avctx->frame_size = info.frameLength;

    avctx->delay      = info.encoderDelay;

    ff_af_queue_init(avctx, &s->afq);



    if (avctx->flags & CODEC_FLAG_GLOBAL_HEADER) {

        avctx->extradata_size = info.confSize;

        avctx->extradata      = av_mallocz(avctx->extradata_size +

                                           FF_INPUT_BUFFER_PADDING_SIZE);

        if (!avctx->extradata) {

            ret = AVERROR(ENOMEM);

            goto error;

        }



        memcpy(avctx->extradata, info.confBuf, info.confSize);

    }

    return 0;

error:

    aac_encode_close(avctx);

    return ret;

}
",1234,"static av_cold int aac_encode_init(AVCodecContext * avcca)

{

    AACContext *y =  avcca->priv_data;

    int ret = AVERROR(EINVAL);

    AACENC_InfoStruct info = { 0 };

    CHANNEL_MODE  modes;

    AACENC_ERROR aster;

    int aot = FF_PROFILE_AAC_LOW + 1;

    int sce = 0, cpe = 0;



    if ((aster = aacEncOpen(&y->handle, 0,  avcca->channels)) != AACENC_OK) {

        av_log( avcca, AV_LOG_ERROR, ""Unable to open the encoder: %s
"",

               aac_get_error(aster));

        goto error;

    }



    if ( avcca->profile != FF_PROFILE_UNKNOWN)

        aot =  avcca->profile + 1;



    if ((aster = aacEncoder_SetParam(y->handle, AACENC_AOT, aot)) != AACENC_OK) {

        av_log( avcca, AV_LOG_ERROR, ""Unable to set the AOT %d: %s
"",

               aot, aac_get_error(aster));

        goto error;

    }



    if (aot == FF_PROFILE_AAC_ELD + 1 && y->eld_sbr) {

        if ((aster = aacEncoder_SetParam(y->handle, AACENC_SBR_MODE,

                                       1)) != AACENC_OK) {

            av_log( avcca, AV_LOG_ERROR, ""Unable to enable SBR for ELD: %s
"",

                   aac_get_error(aster));

            goto error;

        }

    }



    if ((aster = aacEncoder_SetParam(y->handle, AACENC_SAMPLERATE,

                                    avcca->sample_rate)) != AACENC_OK) {

        av_log( avcca, AV_LOG_ERROR, ""Unable to set the sample rate %d: %s
"",

                avcca->sample_rate, aac_get_error(aster));

        goto error;

    }



    switch ( avcca->channels) {

    case 1:  modes = MODE_1;       sce = 1; cpe = 0; break;

    case 2:  modes = MODE_2;       sce = 0; cpe = 1; break;

    case 3:  modes = MODE_1_2;     sce = 1; cpe = 1; break;

    case 4:  modes = MODE_1_2_1;   sce = 2; cpe = 1; break;

    case 5:  modes = MODE_1_2_2;   sce = 1; cpe = 2; break;

    case 6:  modes = MODE_1_2_2_1; sce = 2; cpe = 2; break;

    default:

        av_log( avcca, AV_LOG_ERROR,

               ""Unsupported number of channels %d
"",  avcca->channels);

        goto error;

    }



    if ((aster = aacEncoder_SetParam(y->handle, AACENC_CHANNELMODE,

                                    modes)) != AACENC_OK) {

        av_log( avcca, AV_LOG_ERROR,

               ""Unable to set channel mode %d: %s
"",  modes, aac_get_error(aster));

        goto error;

    }



    if ((aster = aacEncoder_SetParam(y->handle, AACENC_CHANNELORDER,

                                   1)) != AACENC_OK) {

        av_log( avcca, AV_LOG_ERROR,

               ""Unable to set wav channel order %d: %s
"",

                modes, aac_get_error(aster));

        goto error;

    }



    if ( avcca->flags & CODEC_FLAG_QSCALE || y->vbr) {

        int  modes = y->vbr ? y->vbr :  avcca->global_quality;

        if ( modes <  1 ||  modes > 5) {

            av_log( avcca, AV_LOG_WARNING,

                   ""VBR quality %d out of range, should be 1-5
"",  modes);

             modes = av_clip( modes, 1, 5);

        }

        av_log( avcca, AV_LOG_WARNING,

               ""Note, the VBR setting is unsupported and only works with ""

               ""some parameter combinations
"");

        if ((aster = aacEncoder_SetParam(y->handle, AACENC_BITRATEMODE,

                                        modes)) != AACENC_OK) {

            av_log( avcca, AV_LOG_ERROR, ""Unable to set the VBR bitrate mode %d: %s
"",

                    modes, aac_get_error(aster));

            goto error;

        }

    } else {

        if ( avcca->bit_rate <= 0) {

            if ( avcca->profile == FF_PROFILE_AAC_HE_V2) {

                sce = 1;

                cpe = 0;

            }

             avcca->bit_rate = (96*sce + 128*cpe) *  avcca->sample_rate / 44;

            if ( avcca->profile == FF_PROFILE_AAC_HE ||

                 avcca->profile == FF_PROFILE_AAC_HE_V2 ||

                y->eld_sbr)

                 avcca->bit_rate /= 2;

        }

        if ((aster = aacEncoder_SetParam(y->handle, AACENC_BITRATE,

                                        avcca->bit_rate)) != AACENC_OK) {

            av_log( avcca, AV_LOG_ERROR, ""Unable to set the bitrate %d: %s
"",

                    avcca->bit_rate, aac_get_error(aster));

            goto error;

        }

    }



    /* Choose bitstream format - if global header is requested, use

     * raw access units, otherwise use ADTS. */

    if ((aster = aacEncoder_SetParam(y->handle, AACENC_TRANSMUX,

                                    avcca->flags & CODEC_FLAG_GLOBAL_HEADER ? 0 : y->latm ? 10 : 2)) != AACENC_OK) {

        av_log( avcca, AV_LOG_ERROR, ""Unable to set the transmux format: %s
"",

               aac_get_error(aster));

        goto error;

    }



    if (y->latm && y->header_period) {

        if ((aster = aacEncoder_SetParam(y->handle, AACENC_HEADER_PERIOD,

                                       y->header_period)) != AACENC_OK) {

             av_log( avcca, AV_LOG_ERROR, ""Unable to set header period: %s
"",

                    aac_get_error(aster));

             goto error;

        }

    }



    /* If no signaling mode is chosen, use explicit hierarchical signaling

     * if using mp4 mode (raw access units, with global header) and

     * implicit signaling if using ADTS. */

    if (y->signaling < 0)

        y->signaling =  avcca->flags & CODEC_FLAG_GLOBAL_HEADER ? 2 : 0;



    if ((aster = aacEncoder_SetParam(y->handle, AACENC_SIGNALING_MODE,

                                   y->signaling)) != AACENC_OK) {

        av_log( avcca, AV_LOG_ERROR, ""Unable to set signaling mode %d: %s
"",

               y->signaling, aac_get_error(aster));

        goto error;

    }



    if ((aster = aacEncoder_SetParam(y->handle, AACENC_AFTERBURNER,

                                   y->afterburner)) != AACENC_OK) {

        av_log( avcca, AV_LOG_ERROR, ""Unable to set afterburner to %d: %s
"",

               y->afterburner, aac_get_error(aster));

        goto error;

    }



    if ( avcca->cutoff > 0) {

        if ( avcca->cutoff < ( avcca->sample_rate + 255) >> 8) {

            av_log( avcca, AV_LOG_ERROR, ""cutoff valid range is %d-20000
"",

                   ( avcca->sample_rate + 255) >> 8);

            goto error;

        }

        if ((aster = aacEncoder_SetParam(y->handle, AACENC_BANDWIDTH,

                                        avcca->cutoff)) != AACENC_OK) {

            av_log( avcca, AV_LOG_ERROR, ""Unable to set the encoder bandwidth to %d: %s
"",

                    avcca->cutoff, aac_get_error(aster));

            goto error;

        }

    }



    if ((aster = aacEncEncode(y->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) {

        av_log( avcca, AV_LOG_ERROR, ""Unable to initialize the encoder: %s
"",

               aac_get_error(aster));

        return AVERROR(EINVAL);

    }



    if ((aster = aacEncInfo(y->handle, &info)) != AACENC_OK) {

        av_log( avcca, AV_LOG_ERROR, ""Unable to get encoder info: %s
"",

               aac_get_error(aster));

        goto error;

    }



#if FF_API_OLD_ENCODE_AUDIO

     avcca->coded_frame = avcodec_alloc_frame();

    if (! avcca->coded_frame) {

        ret = AVERROR(ENOMEM);

        goto error;

    }

#endif

     avcca->frame_size = info.frameLength;

     avcca->delay      = info.encoderDelay;

    ff_af_queue_init( avcca, &y->afq);



    if ( avcca->flags & CODEC_FLAG_GLOBAL_HEADER) {

         avcca->extradata_size = info.confSize;

         avcca->extradata      = av_mallocz( avcca->extradata_size +

                                           FF_INPUT_BUFFER_PADDING_SIZE);

        if (! avcca->extradata) {

            ret = AVERROR(ENOMEM);

            goto error;

        }



        memcpy( avcca->extradata, info.confBuf, info.confSize);

    }

    return 0;

error:

    aac_encode_close( avcca);

    return ret;

}
",0,0,0,-1,"avctx,s,mode,err","avctx:0.038335055112838745,s:0.10565835237503052,mode:0.04121601581573486,err:0.13844312727451324,",4,140,"err:aster,s:y,mode: modes,avctx: avcca,",Greedy,450,0.12878977457682292
70,"static int vorbis_floor1_decode(vorbis_context *vc,

                                vorbis_floor_data *vfu, float *vec)

{

    vorbis_floor1 *vf = &vfu->t1;

    GetBitContext *gb = &vc->gb;

    uint16_t range_v[4] = { 256, 128, 86, 64 };

    unsigned range = range_v[vf->multiplier - 1];

    uint16_t floor1_Y[258];

    uint16_t floor1_Y_final[258];

    int floor1_flag[258];

    unsigned class, cdim, cbits, csub, cval, offset, i, j;

    int book, adx, ady, dy, off, predicted, err;





    if (!get_bits1(gb)) // silence

        return 1;



// Read values (or differences) for the floor's points



    floor1_Y[0] = get_bits(gb, ilog(range - 1));

    floor1_Y[1] = get_bits(gb, ilog(range - 1));



    av_dlog(NULL, ""floor 0 Y %d floor 1 Y %d \n"", floor1_Y[0], floor1_Y[1]);



    offset = 2;

    for (i = 0; i < vf->partitions; ++i) {

        class = vf->partition_class[i];

        cdim   = vf->class_dimensions[class];

        cbits  = vf->class_subclasses[class];

        csub = (1 << cbits) - 1;

        cval = 0;



        av_dlog(NULL, ""Cbits %u\n"", cbits);



        if (cbits) // this reads all subclasses for this partition's class

            cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,

                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);



        for (j = 0; j < cdim; ++j) {

            book = vf->subclass_books[class][cval & csub];



            av_dlog(NULL, ""book %d Cbits %u cval %u  bits:%d\n"",

                    book, cbits, cval, get_bits_count(gb));



            cval = cval >> cbits;

            if (book > -1) {

                floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table,

                vc->codebooks[book].nb_bits, 3);

            } else {

                floor1_Y[offset+j] = 0;

            }



            av_dlog(NULL, "" floor(%d) = %d \n"",

                    vf->list[offset+j].x, floor1_Y[offset+j]);

        }

        offset+=cdim;

    }



// Amplitude calculation from the differences



    floor1_flag[0] = 1;

    floor1_flag[1] = 1;

    floor1_Y_final[0] = floor1_Y[0];

    floor1_Y_final[1] = floor1_Y[1];



    for (i = 2; i < vf->x_list_dim; ++i) {

        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;



        low_neigh_offs  = vf->list[i].low;

        high_neigh_offs = vf->list[i].high;

        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin

        adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;

        ady = FFABS(dy);

        err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x);

        off = err / adx;

        if (dy < 0) {

            predicted = floor1_Y_final[low_neigh_offs] - off;

        } else {

            predicted = floor1_Y_final[low_neigh_offs] + off;

        } // render_point end



        val = floor1_Y[i];

        highroom = range-predicted;

        lowroom  = predicted;

        if (highroom < lowroom) {

            room = highroom * 2;

        } else {

            room = lowroom * 2;   // SPEC mispelling

        }

        if (val) {

            floor1_flag[low_neigh_offs]  = 1;

            floor1_flag[high_neigh_offs] = 1;

            floor1_flag[i]               = 1;

            if (val >= room) {

                if (highroom > lowroom) {

                    floor1_Y_final[i] = val - lowroom + predicted;

                } else {

                    floor1_Y_final[i] = predicted - val + highroom - 1;

                }

            } else {

                if (val & 1) {

                    floor1_Y_final[i] = predicted - (val + 1) / 2;

                } else {

                    floor1_Y_final[i] = predicted + val / 2;

                }

            }

        } else {

            floor1_flag[i]    = 0;

            floor1_Y_final[i] = predicted;

        }



        av_dlog(NULL, "" Decoded floor(%d) = %u / val %u\n"",

                vf->list[i].x, floor1_Y_final[i], val);

    }



// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?



    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);



    av_dlog(NULL, "" Floor decoded\n"");



    return 0;

}
",846,,1,0,,-4,"vc,vfu,vec,vf,gb,range_v,floor1_Y,floor1_Y_final,floor1_flag,class,cdim,cbits,csub,cval,offset,i,j,book,adx,ady,dy,off,predicted,err",,,,,Greedy,1,0.0025631189346313477
71,"static void colo_process_checkpoint(MigrationState *s)
{
    QIOChannelBuffer *bioc;
    QEMUFile *fb = NULL;
    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
    Error *local_err = NULL;
    int ret;
    failover_init_state();
    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);
    if (!s->rp_state.from_dst_file) {
        error_report(""Open QEMUFile from_dst_file failed"");
    /*
     * Wait for Secondary finish loading VM states and enter COLO
     * restore.
     */
    colo_receive_check_message(s->rp_state.from_dst_file,
                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);
    if (local_err) {
    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);
    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));
    object_unref(OBJECT(bioc));
    qemu_mutex_lock_iothread();
    vm_start();
    qemu_mutex_unlock_iothread();
    trace_colo_vm_state_change(""stop"", ""run"");
    while (s->state == MIGRATION_STATUS_COLO) {
        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
        if (current_time - checkpoint_time <
            s->parameters.x_checkpoint_delay) {
            int64_t delay_ms;
            delay_ms = s->parameters.x_checkpoint_delay -
                       (current_time - checkpoint_time);
            g_usleep(delay_ms * 1000);
        ret = colo_do_checkpoint_transaction(s, bioc, fb);
        if (ret < 0) {
        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
out:
    /* Throw the unreported error message after exited from loop */
    if (local_err) {
        error_report_err(local_err);
    if (fb) {
        qemu_fclose(fb);
    if (s->rp_state.from_dst_file) {
        qemu_fclose(s->rp_state.from_dst_file);",254,"static void colo_process_checkpoint(MigrationState *stats)
{
    QIOChannelBuffer *biOC;
    QEMUFile *fi = NULL;
    int64_t contentalsleep, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
    Error *foreignxprogress = NULL;
    int let;
    failover_init_state();
    stats->rp_state.from_dst_file = qemu_file_get_return_path(stats->to_dst_file);
    if (!stats->rp_state.from_dst_file) {
        error_report(""Open QEMUFile from_dst_file failed"");
    /*
     * Wait for Secondary finish loading VM states and enter COLO
     * restore.
     */
    colo_receive_check_message(stats->rp_state.from_dst_file,
                       COLO_MESSAGE_CHECKPOINT_READY, &foreignxprogress);
    if (foreignxprogress) {
    biOC = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);
    fi = qemu_fopen_channel_output(QIO_CHANNEL(biOC));
    object_unref(OBJECT(biOC));
    qemu_mutex_lock_iothread();
    vm_start();
    qemu_mutex_unlock_iothread();
    trace_colo_vm_state_change(""stop"", ""run"");
    while (stats->state == MIGRATION_STATUS_COLO) {
        contentalsleep = qemu_clock_get_ms(QEMU_CLOCK_HOST);
        if (contentalsleep - checkpoint_time <
            stats->parameters.x_checkpoint_delay) {
            int64_t delay32mins;
            delay32mins = stats->parameters.x_checkpoint_delay -
                       (contentalsleep - checkpoint_time);
            g_usleep(delay32mins * 1000);
        let = colo_do_checkpoint_transaction(stats, biOC, fi);
        if (let < 0) {
        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
out:
    /* Throw the unreported error message after exited from loop */
    if (foreignxprogress) {
        error_report_err(foreignxprogress);
    if (fi) {
        qemu_fclose(fi);
    if (stats->rp_state.from_dst_file) {
        qemu_fclose(stats->rp_state.from_dst_file);",1,1,1,-1,"s,bioc,fb,current_time,local_err,ret,delay_ms","s:0.0003501772880554199,bioc:7.349252700805664e-05,fb:0.000607907772064209,current_time:0.00014352798461914062,local_err:-7.426738739013672e-05,ret:0.00044929981231689453,delay_ms:-5.990266799926758e-05,",7,36,"fb:fi,ret:let,s:stats,current_time:contentalsleep,bioc:biOC,delay_ms:delay32mins,local_err:foreignxprogress,",Greedy,395,0.07540643215179443
72,"static void pc_init1(QEMUMachineInitArgs *args,

                     int pci_enabled,

                     int kvmclock_enabled)

{

    MemoryRegion *system_memory = get_system_memory();

    MemoryRegion *system_io = get_system_io();

    int i;

    ram_addr_t below_4g_mem_size, above_4g_mem_size;

    PCIBus *pci_bus;

    ISABus *isa_bus;

    PCII440FXState *i440fx_state;

    int piix3_devfn = -1;

    qemu_irq *cpu_irq;

    qemu_irq *gsi;

    qemu_irq *i8259;

    qemu_irq *smi_irq;

    GSIState *gsi_state;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BusState *idebus[MAX_IDE_BUS];

    ISADevice *rtc_state;

    ISADevice *floppy;

    MemoryRegion *ram_memory;

    MemoryRegion *pci_memory;

    MemoryRegion *rom_memory;

    DeviceState *icc_bridge;

    FWCfgState *fw_cfg = NULL;

    PcGuestInfo *guest_info;



    if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {

        fprintf(stderr, ""xen hardware virtual machine initialisation failed\n"");

        exit(1);

    }



    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);

    object_property_add_child(qdev_get_machine(), ""icc-bridge"",

                              OBJECT(icc_bridge), NULL);



    pc_cpus_init(args->cpu_model, icc_bridge);



    if (kvm_enabled() && kvmclock_enabled) {

        kvmclock_create();

    }



    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory).

     * If it doesn't, we need to split it in chunks below and above 4G.

     * In any case, try to make sure that guest addresses aligned at

     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.

     * For old machine types, use whatever split we used historically to avoid

     * breaking migration.

     */

    if (args->ram_size >= 0xe0000000) {

        ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;

        above_4g_mem_size = args->ram_size - lowmem;

        below_4g_mem_size = lowmem;

    } else {

        above_4g_mem_size = 0;

        below_4g_mem_size = args->ram_size;

    }



    if (pci_enabled) {

        pci_memory = g_new(MemoryRegion, 1);

        memory_region_init(pci_memory, NULL, ""pci"", UINT64_MAX);

        rom_memory = pci_memory;

    } else {

        pci_memory = NULL;

        rom_memory = system_memory;

    }



    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);



    guest_info->has_acpi_build = has_acpi_build;



    guest_info->has_pci_info = has_pci_info;

    guest_info->isapc_ram_fw = !pci_enabled;



    if (smbios_defaults) {

        /* These values are guest ABI, do not change */

        smbios_set_defaults(""QEMU"", ""Standard PC (i440FX + PIIX, 1996)"",

                            args->machine->name);

    }



    /* allocate ram and load rom/bios */

    if (!xen_enabled()) {

        fw_cfg = pc_memory_init(system_memory,

                       args->kernel_filename, args->kernel_cmdline,

                       args->initrd_filename,

                       below_4g_mem_size, above_4g_mem_size,

                       rom_memory, &ram_memory, guest_info);

    }



    gsi_state = g_malloc0(sizeof(*gsi_state));

    if (kvm_irqchip_in_kernel()) {

        kvm_pc_setup_irq_routing(pci_enabled);

        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,

                                 GSI_NUM_PINS);

    } else {

        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);

    }



    if (pci_enabled) {

        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,

                              system_memory, system_io, args->ram_size,

                              below_4g_mem_size,

                              above_4g_mem_size,

                              pci_memory, ram_memory);

    } else {

        pci_bus = NULL;

        i440fx_state = NULL;

        isa_bus = isa_bus_new(NULL, system_io);

        no_hpet = 1;

    }

    isa_bus_irqs(isa_bus, gsi);



    if (kvm_irqchip_in_kernel()) {

        i8259 = kvm_i8259_init(isa_bus);

    } else if (xen_enabled()) {

        i8259 = xen_interrupt_controller_init();

    } else {

        cpu_irq = pc_allocate_cpu_irq();

        i8259 = i8259_init(isa_bus, cpu_irq[0]);

    }



    for (i = 0; i < ISA_NUM_IRQS; i++) {

        gsi_state->i8259_irq[i] = i8259[i];

    }

    if (pci_enabled) {

        ioapic_init_gsi(gsi_state, ""i440fx"");

    }

    qdev_init_nofail(icc_bridge);



    pc_register_ferr_irq(gsi[13]);



    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);



    /* init basic PC hardware */

    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(),

        0x4);



    pc_nic_init(isa_bus, pci_bus);



    ide_drive_get(hd, MAX_IDE_BUS);

    if (pci_enabled) {

        PCIDevice *dev;

        if (xen_enabled()) {

            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);

        } else {

            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);

        }

        idebus[0] = qdev_get_child_bus(&dev->qdev, ""ide.0"");

        idebus[1] = qdev_get_child_bus(&dev->qdev, ""ide.1"");

    } else {

        for(i = 0; i < MAX_IDE_BUS; i++) {

            ISADevice *dev;

            char busname[] = ""ide.0"";

            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],

                               ide_irq[i],

                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);

            /*

             * The ide bus name is ide.0 for the first bus and ide.1 for the

             * second one.

             */

            busname[4] = '0' + i;

            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);

        }

    }



    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_order,

                 floppy, idebus[0], idebus[1], rtc_state);



    if (pci_enabled && usb_enabled(false)) {

        pci_create_simple(pci_bus, piix3_devfn + 2, ""piix3-usb-uhci"");

    }



    if (pci_enabled && acpi_enabled) {

        I2CBus *smbus;



        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);

        /* TODO: Populate SPD eeprom data.  */

        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,

                              gsi[9], *smi_irq,

                              kvm_enabled(), fw_cfg);

        smbus_eeprom_init(smbus, 8, NULL, 0);

    }



    if (pci_enabled) {

        pc_pci_device_init(pci_bus);

    }

}
",938,"static void pc_init1(QEMUMachineInitArgs *sys,

                     int pci_enabled,

                     int kvmclock_enabled)

{

    MemoryRegion *system_memory = get_system_memory();

    MemoryRegion *system_io = get_system_io();

    int o;

    ram_addr_t below_4g_mem_size, above_4g_mem_size;

    PCIBus *pci_bus;

    ISABus *isa_bus;

    PCII440FXState *i440fx_state;

    int piix3_devfn = -1;

    qemu_irq *cpu_irq;

    qemu_irq *gsi;

    qemu_irq *i8259;

    qemu_irq *smi_irq;

    GSIState *gsi_state;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BusState *idebus[MAX_IDE_BUS];

    ISADevice *rtc_state;

    ISADevice *floppy;

    MemoryRegion *ram_memory;

    MemoryRegion *pci_memory;

    MemoryRegion *rom_memory;

    DeviceState *icc_bridge;

    FWCfgState *fw_cfg = NULL;

    PcGuestInfo *guest_info;



    if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {

        fprintf(stderr, ""xen hardware virtual machine initialisation failed
"");

        exit(1);

    }



    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);

    object_property_add_child(qdev_get_machine(), ""icc-bridge"",

                              OBJECT(icc_bridge), NULL);



    pc_cpus_init(sys->cpu_model, icc_bridge);



    if (kvm_enabled() && kvmclock_enabled) {

        kvmclock_create();

    }



    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory).

     * If it doesn't, we need to split it in chunks below and above 4G.

     * In any case, try to make sure that guest addresses aligned at

     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.

     * For old machine types, use whatever split we used historically to avoid

     * breaking migration.

     */

    if (sys->ram_size >= 0xe0000000) {

        ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;

        above_4g_mem_size = sys->ram_size - lowmem;

        below_4g_mem_size = lowmem;

    } else {

        above_4g_mem_size = 0;

        below_4g_mem_size = sys->ram_size;

    }



    if (pci_enabled) {

        pci_memory = g_new(MemoryRegion, 1);

        memory_region_init(pci_memory, NULL, ""pci"", UINT64_MAX);

        rom_memory = pci_memory;

    } else {

        pci_memory = NULL;

        rom_memory = system_memory;

    }



    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);



    guest_info->has_acpi_build = has_acpi_build;



    guest_info->has_pci_info = has_pci_info;

    guest_info->isapc_ram_fw = !pci_enabled;



    if (smbios_defaults) {

        /* These values are guest ABI, do not change */

        smbios_set_defaults(""QEMU"", ""Standard PC (i440FX + PIIX, 1996)"",

                            sys->machine->name);

    }



    /* allocate ram and load rom/bios */

    if (!xen_enabled()) {

        fw_cfg = pc_memory_init(system_memory,

                       sys->kernel_filename, sys->kernel_cmdline,

                       sys->initrd_filename,

                       below_4g_mem_size, above_4g_mem_size,

                       rom_memory, &ram_memory, guest_info);

    }



    gsi_state = g_malloc0(sizeof(*gsi_state));

    if (kvm_irqchip_in_kernel()) {

        kvm_pc_setup_irq_routing(pci_enabled);

        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,

                                 GSI_NUM_PINS);

    } else {

        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);

    }



    if (pci_enabled) {

        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,

                              system_memory, system_io, sys->ram_size,

                              below_4g_mem_size,

                              above_4g_mem_size,

                              pci_memory, ram_memory);

    } else {

        pci_bus = NULL;

        i440fx_state = NULL;

        isa_bus = isa_bus_new(NULL, system_io);

        no_hpet = 1;

    }

    isa_bus_irqs(isa_bus, gsi);



    if (kvm_irqchip_in_kernel()) {

        i8259 = kvm_i8259_init(isa_bus);

    } else if (xen_enabled()) {

        i8259 = xen_interrupt_controller_init();

    } else {

        cpu_irq = pc_allocate_cpu_irq();

        i8259 = i8259_init(isa_bus, cpu_irq[0]);

    }



    for (o = 0; o < ISA_NUM_IRQS; o++) {

        gsi_state->i8259_irq[o] = i8259[o];

    }

    if (pci_enabled) {

        ioapic_init_gsi(gsi_state, ""i440fx"");

    }

    qdev_init_nofail(icc_bridge);



    pc_register_ferr_irq(gsi[13]);



    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);



    /* init basic PC hardware */

    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(),

        0x4);



    pc_nic_init(isa_bus, pci_bus);



    ide_drive_get(hd, MAX_IDE_BUS);

    if (pci_enabled) {

        PCIDevice *dev;

        if (xen_enabled()) {

            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);

        } else {

            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);

        }

        idebus[0] = qdev_get_child_bus(&dev->qdev, ""ide.0"");

        idebus[1] = qdev_get_child_bus(&dev->qdev, ""ide.1"");

    } else {

        for(o = 0; o < MAX_IDE_BUS; o++) {

            ISADevice *dev;

            char busname[] = ""ide.0"";

            dev = isa_ide_init(isa_bus, ide_iobase[o], ide_iobase2[o],

                               ide_irq[o],

                               hd[MAX_IDE_DEVS * o], hd[MAX_IDE_DEVS * o + 1]);

            /*

             * The ide bus name is ide.0 for the first bus and ide.1 for the

             * second one.

             */

            busname[4] = '0' + o;

            idebus[o] = qdev_get_child_bus(DEVICE(dev), busname);

        }

    }



    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, sys->boot_order,

                 floppy, idebus[0], idebus[1], rtc_state);



    if (pci_enabled && usb_enabled(false)) {

        pci_create_simple(pci_bus, piix3_devfn + 2, ""piix3-usb-uhci"");

    }



    if (pci_enabled && acpi_enabled) {

        I2CBus *smbus;



        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);

        /* TODO: Populate SPD eeprom data.  */

        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,

                              gsi[9], *smi_irq,

                              kvm_enabled(), fw_cfg);

        smbus_eeprom_init(smbus, 8, NULL, 0);

    }



    if (pci_enabled) {

        pc_pci_device_init(pci_bus);

    }

}
",0,0,1,1,"args,pci_enabled,kvmclock_enabled,system_memory,system_io,i,below_4g_mem_size,above_4g_mem_size,pci_bus,isa_bus,i440fx_state,cpu_irq,gsi,i8259,smi_irq,gsi_state,hd,MAX_IDE_BUS,MAX_IDE_DEVS,idebus,rtc_state,floppy,ram_memory,pci_memory,rom_memory,icc_bridge,fw_cfg,guest_info","args:0.05231854319572449,pci_enabled:-0.0001865476369857788,kvmclock_enabled:0.029692351818084717,system_memory:-0.013971492648124695,system_io:-0.013546526432037354,i:0.02323569357395172,below_4g_mem_size:-0.03240981698036194,above_4g_mem_size:-0.013841837644577026,pci_bus:-0.013786032795906067,isa_bus:-0.02134619653224945,i440fx_state:-1.704692840576172e-05,cpu_irq:-0.008765995502471924,gsi:0.01063622534275055,i8259:-0.0002662837505340576,smi_irq:0.002433210611343384,gsi_state:-0.003793463110923767,hd:0.012607738375663757,MAX_IDE_BUS:0.009448319673538208,MAX_IDE_DEVS:-0.0037682652473449707,idebus:0.004896894097328186,rtc_state:-0.0011639446020126343,floppy:-0.009368464350700378,ram_memory:-0.03192691504955292,pci_memory:-0.01762068271636963,rom_memory:-0.012104317545890808,icc_bridge:0.12942302227020264,fw_cfg:0.003700554370880127,guest_info:0.011312946677207947,",2,27,"icc_bridge:icc_bridge,args:sys,kvmclock_enabled:kvmclock_enabled,i:o,",Greedy,297,0.0757525086402893
73,"uint32_t wm8750_adc_dat(void *opaque)

{

    WM8750State *s = (WM8750State *) opaque;

    uint32_t *data;



    if (s->idx_in >= sizeof(s->data_in))

        wm8750_in_load(s);



    data = (uint32_t *) &s->data_in[s->idx_in];

    s->req_in -= 4;

    s->idx_in += 4;

    return *data;

}
",73,"uint32_t wm8750_adc_dat(void *opaque)

{

    WM8750State *s = (WM8750State *) opaque;

    uint32_t *as;



    if (s->idx_in >= sizeof(s->data_in))

        wm8750_in_load(s);



    as = (uint32_t *) &s->data_in[s->idx_in];

    s->req_in -= 4;

    s->idx_in += 4;

    return *as;

}
",0,0,1,1,"opaque,s,data","opaque:0.5688959360122681,s:0.2818625420331955,data:0.6059632003307343,",1,3,"data:as,",Greedy,61,0.012742054462432862
74,"static QmpInputVisitor *to_qiv(Visitor *v)

{

    return container_of(v, QmpInputVisitor, visitor);

}
",21,"static QmpInputVisitor *to_qiv(Visitor *view)

{

    return container_of(view, QmpInputVisitor, visitor);

}
",0,0,0,-1,v,"v:-0.005901584401726723,",1,2,"v:view,",Greedy,41,0.010258142153422039
75,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *s = s1->priv_data;

    AVFrame *frame = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(pkt);

    if ((res = mmap_read_frame(s1, pkt)) < 0) {

        return res;

    }



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    if (frame && s->interlaced) {

        frame->interlaced_frame = 1;

        frame->top_field_first = s->top_field_first;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    return pkt->size;

}
",111,"static int v4l2_read_packet(AVFormatContext *ses1, AVPacket *racket)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *f = ses1->priv_data;

    AVFrame *frame = ses1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int row;



    av_init_packet(racket);

    if ((row = mmap_read_frame(ses1, racket)) < 0) {

        return row;

    }



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    if (frame && f->interpolacer) {

        frame->interlaced_frame = 1;

        frame->top_field_first = f->top_field_first;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    return racket->size;

}
",0,0,1,1,"s1,pkt,s,frame,res,interlaced","s1:0.02642311155796051,pkt:0.022453077137470245,s:0.022922120988368988,frame:0.007481902837753296,res:0.008381076157093048,interlaced:0.0393286757171154,",5,15,"interlaced:interpolacer,s1:ses1,s:f,pkt:racket,res:row,",Greedy,239,0.04461225668589274
76,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = bonito_pcihost_initfn;

    dc->no_user = 1;

}
",44,"static void bonito_pcihost_class_init(ObjectClass *oklasses, void *child)

{

    DeviceClass *design = DEVICE_CLASS(oklasses);

    SysBusDeviceClass *kind = SYS_BUS_DEVICE_CLASS(oklasses);



    kind->init = bonito_pcihost_initfn;

    design->no_user = 1;

}
",1,1,1,-1,"klass,data,dc,k","klass:0.0008774399757385254,data:0.0003955960273742676,dc:0.00031620264053344727,k:-0.00047522783279418945,",4,8,"klass:oklasses,data:child,dc:design,k:kind,",Greedy,134,0.026310276985168458
77,"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)

{

    uint32_t v, spf;

    MPADecodeHeader c;

    int vbrtag_size = 0;

    MP3DecContext *mp3 = s->priv_data;



    ffio_init_checksum(s->pb, ff_crcA001_update, 0);



    v = avio_rb32(s->pb);

    if(ff_mpa_check_header(v) < 0)

      return -1;



    if (avpriv_mpegaudio_decode_header(&c, v) == 0)

        vbrtag_size = c.frame_size;

    if(c.layer != 3)

        return -1;



    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */



    mp3->frames = 0;

    mp3->size   = 0;



    mp3_parse_info_tag(s, st, &c, spf);

    mp3_parse_vbri_tag(s, st, base);



    if (!mp3->frames && !mp3->size)

        return -1;



    /* Skip the vbr tag frame */

    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);



    if (mp3->frames)

        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},

                                    st->time_base);

    if (mp3->size && mp3->frames && !mp3->is_cbr)

        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);



    return 0;

}
",248,"static int mp3_parse_vbr_tags(AVFormatContext *aws, AVStream *sta, int64_t base)

{

    uint32_t v, spf;

    MPADecodeHeader vc;

    int vbrtag_size = 0;

    MP3DecContext *MP3 = aws->priv_data;



    ffio_init_checksum(aws->pb, ff_crcA001_update, 0);



    v = avio_rb32(aws->pb);

    if(ff_mpa_check_header(v) < 0)

      return -1;



    if (avpriv_mpegaudio_decode_header(&vc, v) == 0)

        vbrtag_size = vc.frame_size;

    if(vc.layer != 3)

        return -1;



    spf = vc.lsf ? 576 : 1152; /* Samples per frame, layer 3 */



    MP3->frames = 0;

    MP3->size   = 0;



    mp3_parse_info_tag(aws, sta, &vc, spf);

    mp3_parse_vbri_tag(aws, sta, base);



    if (!MP3->frames && !MP3->size)

        return -1;



    /* Skip the vbr tag frame */

    avio_seek(aws->pb, base + vbrtag_size, SEEK_SET);



    if (MP3->frames)

        sta->duration = av_rescale_q(MP3->frames, (AVRational){spf, vc.sample_rate},

                                    sta->time_base);

    if (MP3->size && MP3->frames && !MP3->is_cbr)

        sta->codec->bit_rate = av_rescale(MP3->size, 8 * vc.sample_rate, MP3->frames * (int64_t)spf);



    return 0;

}
",0,0,1,1,"s,st,base,v,spf,c,mp3","s:0.05297976732254028,st:0.03337457776069641,base:0.030650239437818527,v:0.012688253074884415,spf:0.020398270338773727,c:0.035271286964416504,mp3:0.06314903125166893,",4,33,"mp3:MP3,s:aws,c:vc,st:sta,",Greedy,310,0.055378055572509764
78,"void memory_region_iommu_replay_all(MemoryRegion *mr)

{

    IOMMUNotifier *notifier;



    IOMMU_NOTIFIER_FOREACH(notifier, mr) {

        memory_region_iommu_replay(mr, notifier, false);

    }

}
",31,"void memory_region_iommu_replay_all(MemoryRegion *gr)

{

    IOMMUNotifier * notification;



    IOMMU_NOTIFIER_FOREACH( notification, gr) {

        memory_region_iommu_replay(gr,  notification, false);

    }

}
",0,0,0,-1,"mr,notifier","mr:-0.0004795743152499199,notifier:0.0013347803615033627,",2,6,"notifier: notification,mr:gr,",Greedy,94,0.019632883866628013
79,"static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(s);

}
",53,"static int usb_uhci_piix3_initfn(PCIDevice *diff)

{

    UHCIState *serv = DO_UPCAST(UHCIState, diff, diff);

    uint8_t *pcm_sum = serv->diff.config;



    pci_config_set_vendor_id(pcm_sum, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pcm_sum, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(serv);

}
",0,0,1,1,"dev,s,pci_conf","dev:0.006069316528737545,s:-0.0006048036739230156,pci_conf:0.004720146767795086,",3,10,"dev:diff,pci_conf:pcm_sum,s:serv,",Greedy,118,0.02349671522776286
80,"static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)

{

    MpegTSWrite *ts = s->priv_data;

    uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr;

    int val, stream_type, i;



    q = data;

    put16(&q, 0xe000 | service->pcr_pid);



    program_info_length_ptr = q;

    q += 2; /* patched after */



    /* put program info here */



    val = 0xf000 | (q - program_info_length_ptr - 2);

    program_info_length_ptr[0] = val >> 8;

    program_info_length_ptr[1] = val;



    for(i = 0; i < s->nb_streams; i++) {

        AVStream *st = s->streams[i];

        MpegTSWriteStream *ts_st = st->priv_data;

        AVDictionaryEntry *lang = av_dict_get(st->metadata, ""language"", NULL,0);

        switch(st->codec->codec_id) {

        case AV_CODEC_ID_MPEG1VIDEO:

        case AV_CODEC_ID_MPEG2VIDEO:

            stream_type = STREAM_TYPE_VIDEO_MPEG2;

            break;

        case AV_CODEC_ID_MPEG4:

            stream_type = STREAM_TYPE_VIDEO_MPEG4;

            break;

        case AV_CODEC_ID_H264:

            stream_type = STREAM_TYPE_VIDEO_H264;

            break;

        case AV_CODEC_ID_CAVS:

            stream_type = STREAM_TYPE_VIDEO_CAVS;

            break;

        case AV_CODEC_ID_DIRAC:

            stream_type = STREAM_TYPE_VIDEO_DIRAC;

            break;

        case AV_CODEC_ID_MP2:

        case AV_CODEC_ID_MP3:

            stream_type = STREAM_TYPE_AUDIO_MPEG1;

            break;

        case AV_CODEC_ID_AAC:

            stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC;

            break;

        case AV_CODEC_ID_AAC_LATM:

            stream_type = STREAM_TYPE_AUDIO_AAC_LATM;

            break;

        case AV_CODEC_ID_AC3:

            stream_type = STREAM_TYPE_AUDIO_AC3;

            break;

        default:

            stream_type = STREAM_TYPE_PRIVATE_DATA;

            break;

        }

        *q++ = stream_type;

        put16(&q, 0xe000 | ts_st->pid);

        desc_length_ptr = q;

        q += 2; /* patched after */



        /* write optional descriptors here */

        switch(st->codec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            if(st->codec->codec_id==AV_CODEC_ID_EAC3){

                *q++=0x7a; // EAC3 descriptor see A038 DVB SI

                *q++=1; // 1 byte, all flags sets to 0

                *q++=0; // omit all fields...

            }

            if(st->codec->codec_id==AV_CODEC_ID_S302M){

                *q++ = 0x05; /* MPEG-2 registration descriptor*/

                *q++ = 4;

                *q++ = 'B';

                *q++ = 'S';

                *q++ = 'S';

                *q++ = 'D';

            }



            if (lang) {

                char *p;

                char *next = lang->value;

                uint8_t *len_ptr;



                *q++ = 0x0a; /* ISO 639 language descriptor */

                len_ptr = q++;

                *len_ptr = 0;



                for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {

                    next = strchr(p, ',');

                    if (strlen(p) != 3 && (!next || next != p + 3))

                        continue; /* not a 3-letter code */



                    *q++ = *p++;

                    *q++ = *p++;

                    *q++ = *p++;



                if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)

                    *q++ = 0x01;

                else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED)

                    *q++ = 0x02;

                else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)

                    *q++ = 0x03;

                else

                    *q++ = 0; /* undefined type */



                    *len_ptr += 4;

                }



                if (*len_ptr == 0)

                    q -= 2; /* no language codes were written */

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            {

                const char default_language[] = ""und"";

                const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;



                if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {

                    uint8_t *len_ptr;

                    int extradata_copied = 0;



                    *q++ = 0x59; /* subtitling_descriptor */

                    len_ptr = q++;



                    while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */

                        *q++ = *language++;

                        *q++ = *language++;

                        *q++ = *language++;

                        /* Skip comma */

                        if (*language != '\0')

                            language++;



                        if (st->codec->extradata_size - extradata_copied >= 5) {

                            *q++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */

                            memcpy(q, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */

                            extradata_copied += 5;

                            q += 4;

                        } else {

                            /* subtitling_type:

                             * 0x10 - normal with no monitor aspect ratio criticality

                             * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */

                            *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;

                            if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {

                                /* support of old 4-byte extradata format */

                                memcpy(q, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */

                                extradata_copied += 4;

                                q += 4;

                            } else {

                                put16(&q, 1); /* composition_page_id */

                                put16(&q, 1); /* ancillary_page_id */

                            }

                        }

                    }



                    *len_ptr = q - len_ptr - 1;

                } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {

                    uint8_t *len_ptr = NULL;

                    int extradata_copied = 0;



                    /* The descriptor tag. teletext_descriptor */

                    *q++ = 0x56;

                    len_ptr = q++;



                    while (strlen(language) >= 3) {

                        *q++ = *language++;

                        *q++ = *language++;

                        *q++ = *language++;

                        /* Skip comma */

                        if (*language != '\0')

                            language++;



                        if (st->codec->extradata_size - 1 > extradata_copied) {

                            memcpy(q, st->codec->extradata + extradata_copied, 2);

                            extradata_copied += 2;

                            q += 2;

                        } else {

                            /* The Teletext descriptor:

                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)

                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.

                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */

                            *q++ = 0x08;

                            *q++ = 0x00;

                        }

                    }



                    *len_ptr = q - len_ptr - 1;

                 }

            }

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (stream_type == STREAM_TYPE_VIDEO_DIRAC) {

                *q++ = 0x05; /*MPEG-2 registration descriptor*/

                *q++ = 4;

                *q++ = 'd';

                *q++ = 'r';

                *q++ = 'a';

                *q++ = 'c';

            }

            break;

        case AVMEDIA_TYPE_DATA:

            if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {

                *q++ = 0x05; /* MPEG-2 registration descriptor */

                *q++ = 4;

                *q++ = 'K';

                *q++ = 'L';

                *q++ = 'V';

                *q++ = 'A';

            }

            break;

        }



        val = 0xf000 | (q - desc_length_ptr - 2);

        desc_length_ptr[0] = val >> 8;

        desc_length_ptr[1] = val;

    }

    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0,

                          data, q - data);

}
",1157,,0,1,,-4,"s,service,ts,data,q,desc_length_ptr,program_info_length_ptr,val,stream_type,i,st,ts_st,lang",,,,,Greedy,1,0.002527002493540446
81,"static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
",101,"static unsigned int dec_addi_r(DisasContext * DC)

{

	TCGv tt80;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u
"",

		    memsize_char(memsize_zz( DC)),  DC->op2,  DC->op1));

	cris_cc_mask( DC, 0);

	tt80 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(tt80, cpu_R[ DC->op2], tcg_const_tl( DC->zzsize));

	tcg_gen_add_tl(cpu_R[ DC->op1], cpu_R[ DC->op1], tt80);

	tcg_temp_free(tt80);

	return 2;

}
",0,0,0,-1,"dc,t0","dc:3.56622040271759e-05,t0:4.53554093837738e-06,",2,14,"dc: DC,t0:tt80,",Greedy,114,0.021348853905995686
82,"static void gen_trap (DisasContext *ctx, uint32_t opc,

                      int rs, int rt, int16_t imm)

{

    int cond;

    TCGv t0 = tcg_temp_new();

    TCGv t1 = tcg_temp_new();



    cond = 0;

    /* Load needed operands */

    switch (opc) {

    case OPC_TEQ:

    case OPC_TGE:

    case OPC_TGEU:

    case OPC_TLT:

    case OPC_TLTU:

    case OPC_TNE:

        /* Compare two registers */

        if (rs != rt) {

            gen_load_gpr(t0, rs);

            gen_load_gpr(t1, rt);

            cond = 1;

        }

        break;

    case OPC_TEQI:

    case OPC_TGEI:

    case OPC_TGEIU:

    case OPC_TLTI:

    case OPC_TLTIU:

    case OPC_TNEI:

        /* Compare register to immediate */

        if (rs != 0 || imm != 0) {

            gen_load_gpr(t0, rs);

            tcg_gen_movi_tl(t1, (int32_t)imm);

            cond = 1;

        }

        break;

    }

    if (cond == 0) {

        switch (opc) {

        case OPC_TEQ:   /* rs == rs */

        case OPC_TEQI:  /* r0 == 0  */

        case OPC_TGE:   /* rs >= rs */

        case OPC_TGEI:  /* r0 >= 0  */

        case OPC_TGEU:  /* rs >= rs unsigned */

        case OPC_TGEIU: /* r0 >= 0  unsigned */

            /* Always trap */

            generate_exception(ctx, EXCP_TRAP);

            break;

        case OPC_TLT:   /* rs < rs           */

        case OPC_TLTI:  /* r0 < 0            */

        case OPC_TLTU:  /* rs < rs unsigned  */

        case OPC_TLTIU: /* r0 < 0  unsigned  */

        case OPC_TNE:   /* rs != rs          */

        case OPC_TNEI:  /* r0 != 0           */

            /* Never trap: treat as NOP. */

            break;

        }

    } else {

        int l1 = gen_new_label();



        switch (opc) {

        case OPC_TEQ:

        case OPC_TEQI:

            tcg_gen_brcond_tl(TCG_COND_NE, t0, t1, l1);

            break;

        case OPC_TGE:

        case OPC_TGEI:

            tcg_gen_brcond_tl(TCG_COND_LT, t0, t1, l1);

            break;

        case OPC_TGEU:

        case OPC_TGEIU:

            tcg_gen_brcond_tl(TCG_COND_LTU, t0, t1, l1);

            break;

        case OPC_TLT:

        case OPC_TLTI:

            tcg_gen_brcond_tl(TCG_COND_GE, t0, t1, l1);

            break;

        case OPC_TLTU:

        case OPC_TLTIU:

            tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1);

            break;

        case OPC_TNE:

        case OPC_TNEI:

            tcg_gen_brcond_tl(TCG_COND_EQ, t0, t1, l1);

            break;

        }

        generate_exception(ctx, EXCP_TRAP);

        gen_set_label(l1);

    }

    tcg_temp_free(t0);

    tcg_temp_free(t1);

}
",361,"static void gen_trap (DisasContext *buf, uint32_t operct,

                      int ris, int tmp, int16_t iter)

{

    int resp;

    TCGv t0 = tcg_temp_new();

    TCGv t1 = tcg_temp_new();



    resp = 0;

    /* Load needed operands */

    switch (operct) {

    case OPC_TEQ:

    case OPC_TGE:

    case OPC_TGEU:

    case OPC_TLT:

    case OPC_TLTU:

    case OPC_TNE:

        /* Compare two registers */

        if (ris != tmp) {

            gen_load_gpr(t0, ris);

            gen_load_gpr(t1, tmp);

            resp = 1;

        }

        break;

    case OPC_TEQI:

    case OPC_TGEI:

    case OPC_TGEIU:

    case OPC_TLTI:

    case OPC_TLTIU:

    case OPC_TNEI:

        /* Compare register to immediate */

        if (ris != 0 || iter != 0) {

            gen_load_gpr(t0, ris);

            tcg_gen_movi_tl(t1, (int32_t)iter);

            resp = 1;

        }

        break;

    }

    if (resp == 0) {

        switch (operct) {

        case OPC_TEQ:   /* rs == rs */

        case OPC_TEQI:  /* r0 == 0  */

        case OPC_TGE:   /* rs >= rs */

        case OPC_TGEI:  /* r0 >= 0  */

        case OPC_TGEU:  /* rs >= rs unsigned */

        case OPC_TGEIU: /* r0 >= 0  unsigned */

            /* Always trap */

            generate_exception(buf, EXCP_TRAP);

            break;

        case OPC_TLT:   /* rs < rs           */

        case OPC_TLTI:  /* r0 < 0            */

        case OPC_TLTU:  /* rs < rs unsigned  */

        case OPC_TLTIU: /* r0 < 0  unsigned  */

        case OPC_TNE:   /* rs != rs          */

        case OPC_TNEI:  /* r0 != 0           */

            /* Never trap: treat as NOP. */

            break;

        }

    } else {

        int l1 = gen_new_label();



        switch (operct) {

        case OPC_TEQ:

        case OPC_TEQI:

            tcg_gen_brcond_tl(TCG_COND_NE, t0, t1, l1);

            break;

        case OPC_TGE:

        case OPC_TGEI:

            tcg_gen_brcond_tl(TCG_COND_LT, t0, t1, l1);

            break;

        case OPC_TGEU:

        case OPC_TGEIU:

            tcg_gen_brcond_tl(TCG_COND_LTU, t0, t1, l1);

            break;

        case OPC_TLT:

        case OPC_TLTI:

            tcg_gen_brcond_tl(TCG_COND_GE, t0, t1, l1);

            break;

        case OPC_TLTU:

        case OPC_TLTIU:

            tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1);

            break;

        case OPC_TNE:

        case OPC_TNEI:

            tcg_gen_brcond_tl(TCG_COND_EQ, t0, t1, l1);

            break;

        }

        generate_exception(buf, EXCP_TRAP);

        gen_set_label(l1);

    }

    tcg_temp_free(t0);

    tcg_temp_free(t1);

}
",0,0,0,-1,"ctx,opc,rs,rt,imm,cond","ctx:0.0035354243591427803,opc:-0.0021368255838751793,rs:-0.0003698635846376419,rt:0.0013283435255289078,imm:0.008014243096113205,cond:0.011159386485815048,",6,23,"cond:resp,imm:iter,ctx:buf,rt:tmp,rs:ris,opc:operct,",Greedy,292,0.060672199726104735
83,"static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,

                                 unsigned size)

{

    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;

    uint32_t ret;

    int bank;

    if (offset >= 0x200)

        return 0;



    bank = pxa2xx_gpio_regs[offset].bank;

    switch (pxa2xx_gpio_regs[offset].reg) {

    case GPDR:		/* GPIO Pin-Direction registers */

        return s->dir[bank];



    case GPSR:		/* GPIO Pin-Output Set registers */

        qemu_log_mask(LOG_GUEST_ERROR,

                      ""pxa2xx GPIO: read from write only register GPSR\n"");

        return 0;



    case GPCR:		/* GPIO Pin-Output Clear registers */

        qemu_log_mask(LOG_GUEST_ERROR,

                      ""pxa2xx GPIO: read from write only register GPCR\n"");

        return 0;



    case GRER:		/* GPIO Rising-Edge Detect Enable registers */

        return s->rising[bank];



    case GFER:		/* GPIO Falling-Edge Detect Enable registers */

        return s->falling[bank];



    case GAFR_L:	/* GPIO Alternate Function registers */

        return s->gafr[bank * 2];



    case GAFR_U:	/* GPIO Alternate Function registers */

        return s->gafr[bank * 2 + 1];



    case GPLR:		/* GPIO Pin-Level registers */

        ret = (s->olevel[bank] & s->dir[bank]) |

                (s->ilevel[bank] & ~s->dir[bank]);

        qemu_irq_raise(s->read_notify);

        return ret;



    case GEDR:		/* GPIO Edge Detect Status registers */

        return s->status[bank];



    default:

        hw_error(""%s: Bad offset "" REG_FMT ""\n"", __FUNCTION__, offset);

    }



    return 0;

}
",227,,0,1,,-4,"opaque,offset,size,s,ret,bank",,,,,Greedy,1,0.002078866958618164
84,"static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    /* 4-color block encoding: each 4x4 block is a different color */
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    /* report success */
    return 0;",114,"static int ipvideo_decode_block_opcode_0xD(IpvideoContext *g, AVFrame *series)
{
    int sky;
    unsigned char FP[2];
    /* 4-color block encoding: each 4x4 block is a different color */
    for (sky = 0; sky < 8; sky++) {
        if (!(sky & 3)) {
            FP[0] = bytestream2_get_byte(&g->stream_ptr);
            FP[1] = bytestream2_get_byte(&g->stream_ptr);
        memset(g->pixel_ptr,     FP[0], 4);
        memset(g->pixel_ptr + 4, FP[1], 4);
        g->pixel_ptr += g->stride;
    /* report success */
    return 0;",1,1,1,-1,"s,frame,y,P","s:0.002376854419708252,frame:0.00011342763900756836,y:0.00238800048828125,P:0.0012788772583007812,",4,18,"y:sky,s:g,P:FP,frame:series,",Greedy,217,0.03804735740025838
85,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *s = opaque;

    if (qemu_file_get_error(s->file)) {

        goto out;

    }



    s->xfer_limit = new_rate;



out:

    return s->xfer_limit;

}
",46,"static int64_t migration_set_rate_limit(void *oaaques, int64_t newWrated)

{

    MigrationState *ments = oaaques;

    if (qemu_file_get_error(ments->file)) {

        goto out;

    }



    ments->xfer_limit = newWrated;



out:

    return ments->xfer_limit;

}
",0,0,1,1,"opaque,new_rate,s","opaque:0.020086629316210747,new_rate:0.05346263758838177,s:0.033218126744031906,",3,8,"new_rate:newWrated,s:ments,opaque:oaaques,",Greedy,100,0.020840005079905192
86,"static void reverse_matrixing(float *su1, float *su2, int *prev_code,

                              int *curr_code)

{

    int i, nsample, band;

    float mc1_l, mc1_r, mc2_l, mc2_r;



    for (i = 0, band = 0; band < 4 * 256; band += 256, i++) {

        int s1 = prev_code[i];

        int s2 = curr_code[i];

        nsample = 0;



        if (s1 != s2) {

            /* Selector value changed, interpolation needed. */

            mc1_l = matrix_coeffs[s1 * 2    ];

            mc1_r = matrix_coeffs[s1 * 2 + 1];

            mc2_l = matrix_coeffs[s2 * 2    ];

            mc2_r = matrix_coeffs[s2 * 2 + 1];



            /* Interpolation is done over the first eight samples. */

            for (; nsample < 8; nsample++) {

                float c1 = su1[band + nsample];

                float c2 = su2[band + nsample];

                c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +

                     c2 * INTERPOLATE(mc1_r, mc2_r, nsample);

                su1[band + nsample] = c2;

                su2[band + nsample] = c1 * 2.0 - c2;

            }

        }



        /* Apply the matrix without interpolation. */

        switch (s2) {

        case 0:     /* M/S decoding */

            for (; nsample < 256; nsample++) {

                float c1 = su1[band + nsample];

                float c2 = su2[band + nsample];

                su1[band + nsample] =  c2       * 2.0;

                su2[band + nsample] = (c1 - c2) * 2.0;

            }

            break;

        case 1:

            for (; nsample < 256; nsample++) {

                float c1 = su1[band + nsample];

                float c2 = su2[band + nsample];

                su1[band + nsample] = (c1 + c2) *  2.0;

                su2[band + nsample] =  c2       * -2.0;

            }

            break;

        case 2:

        case 3:

            for (; nsample < 256; nsample++) {

                float c1 = su1[band + nsample];

                float c2 = su2[band + nsample];

                su1[band + nsample] = c1 + c2;

                su2[band + nsample] = c1 - c2;

            }

            break;

        default:

            assert(0);

        }

    }

}
",410,"static void reverse_matrixing(float *Su2, float *s2, int *pre_div,

                              int *curr_code)

{

    int s, nsammy, page;

    float mc1_l, mc1_r, mc2_l, mc2_r;



    for (s = 0, page = 0; page < 4 * 256; page += 256, s++) {

        int s1 = pre_div[s];

        int s2 = curr_code[s];

        nsammy = 0;



        if (s1 != s2) {

            /* Selector value changed, interpolation needed. */

            mc1_l = matrix_coeffs[s1 * 2    ];

            mc1_r = matrix_coeffs[s1 * 2 + 1];

            mc2_l = matrix_coeffs[s2 * 2    ];

            mc2_r = matrix_coeffs[s2 * 2 + 1];



            /* Interpolation is done over the first eight samples. */

            for (; nsammy < 8; nsammy++) {

                float c1 = Su2[page + nsammy];

                float c2 = s2[page + nsammy];

                c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsammy) +

                     c2 * INTERPOLATE(mc1_r, mc2_r, nsammy);

                Su2[page + nsammy] = c2;

                s2[page + nsammy] = c1 * 2.0 - c2;

            }

        }



        /* Apply the matrix without interpolation. */

        switch (s2) {

        case 0:     /* M/S decoding */

            for (; nsammy < 256; nsammy++) {

                float c1 = Su2[page + nsammy];

                float c2 = s2[page + nsammy];

                Su2[page + nsammy] =  c2       * 2.0;

                s2[page + nsammy] = (c1 - c2) * 2.0;

            }

            break;

        case 1:

            for (; nsammy < 256; nsammy++) {

                float c1 = Su2[page + nsammy];

                float c2 = s2[page + nsammy];

                Su2[page + nsammy] = (c1 + c2) *  2.0;

                s2[page + nsammy] =  c2       * -2.0;

            }

            break;

        case 2:

        case 3:

            for (; nsammy < 256; nsammy++) {

                float c1 = Su2[page + nsammy];

                float c2 = s2[page + nsammy];

                Su2[page + nsammy] = c1 + c2;

                s2[page + nsammy] = c1 - c2;

            }

            break;

        default:

            assert(0);

        }

    }

}
",0,0,1,1,"su1,su2,prev_code,curr_code,i,nsample,band,mc1_l,mc1_r,mc2_l,mc2_r","su1:0.015863804146647453,su2:0.008383015170693398,prev_code:0.04836956784129143,curr_code:0.026440389454364777,i:0.012362105771899223,nsample:0.008137863129377365,band:0.028870947659015656,mc1_l:0.0037271957844495773,mc1_r:0.0023809783160686493,mc2_l:0.007138742133975029,mc2_r:0.003517230972647667,",6,73,"prev_code:pre_div,band:page,curr_code:curr_code,su1:Su2,i:s,su2:s2,nsample:nsammy,",Greedy,580,0.10693744818369548
87,"static void scsi_disk_reset(DeviceState *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);

    uint64_t nb_sectors;



    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));



    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    nb_sectors /= s->qdev.blocksize / 512;

    if (nb_sectors) {

        nb_sectors--;

    }

    s->qdev.max_lba = nb_sectors;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
",94,"static void scsi_disk_reset(DeviceState *err)

{

    SCSIDiskState *service = DO_UPCAST(SCSIDiskState, qdev.qdev, err);

    uint64_t nb_geapters;



    scsi_device_purge_requests(&service->qdev, SENSE_CODE(RESET));



    bdrv_get_geometry(service->qdev.conf.bs, &nb_geapters);

    nb_geapters /= service->qdev.blocksize / 512;

    if (nb_geapters) {

        nb_geapters--;

    }

    service->qdev.max_lba = nb_geapters;

    /* reset tray statuses */

    service->tray_locked = 0;

    service->tray_open = 0;

}
",0,0,0,-1,"dev,s,nb_sectors","dev:0.0002778274938464165,s:0.002640342339873314,nb_sectors:0.006413649767637253,",3,15,"nb_sectors:nb_geapters,s:service,dev:err,",Greedy,183,0.03263909816741943
88,"static int read_part_of_packet(AVFormatContext *s, int64_t *pts,

                               int *len, int *strid, int read_packet) {

    AVIOContext *pb = s->pb;

    PVAContext *pvactx = s->priv_data;

    int syncword, streamid, reserved, flags, length, pts_flag;

    int64_t pva_pts = AV_NOPTS_VALUE, startpos;

    int ret;



recover:

    startpos = avio_tell(pb);



    syncword = avio_rb16(pb);

    streamid = avio_r8(pb);

    avio_r8(pb);               /* counter not used */

    reserved = avio_r8(pb);

    flags    = avio_r8(pb);

    length   = avio_rb16(pb);



    pts_flag = flags & 0x10;



    if (syncword != PVA_MAGIC) {

        pva_log(s, AV_LOG_ERROR, ""invalid syncword\n"");

        return AVERROR(EIO);

    }

    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {

        pva_log(s, AV_LOG_ERROR, ""invalid streamid\n"");

        return AVERROR(EIO);

    }

    if (reserved != 0x55) {

        pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");

    }

    if (length > PVA_MAX_PAYLOAD_LENGTH) {

        pva_log(s, AV_LOG_ERROR, ""invalid payload length %u\n"", length);

        return AVERROR(EIO);

    }



    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {

        pva_pts = avio_rb32(pb);

        length -= 4;

    } else if (streamid == PVA_AUDIO_PAYLOAD) {

        /* PVA Audio Packets either start with a signaled PES packet or

         * are a continuation of the previous PES packet. New PES packets

         * always start at the beginning of a PVA Packet, never somewhere in

         * the middle. */

        if (!pvactx->continue_pes) {

            int pes_signal, pes_header_data_length, pes_packet_length,

                pes_flags;

            unsigned char pes_header_data[256];



            pes_signal             = avio_rb24(pb);

            avio_r8(pb);

            pes_packet_length      = avio_rb16(pb);

            pes_flags              = avio_rb16(pb);

            pes_header_data_length = avio_r8(pb);



            if (pes_signal != 1 || pes_header_data_length == 0) {

                pva_log(s, AV_LOG_WARNING, ""expected non empty signaled PES packet, ""

                                          ""trying to recover\n"");

                avio_skip(pb, length - 9);

                if (!read_packet)

                    return AVERROR(EIO);

                goto recover;

            }



            ret = avio_read(pb, pes_header_data, pes_header_data_length);

            if (ret != pes_header_data_length)

                return ret < 0 ? ret : AVERROR_INVALIDDATA;

            length -= 9 + pes_header_data_length;



            pes_packet_length -= 3 + pes_header_data_length;



            pvactx->continue_pes = pes_packet_length;



            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20)

                pva_pts = ff_parse_pes_pts(pes_header_data);

        }



        pvactx->continue_pes -= length;



        if (pvactx->continue_pes < 0) {

            pva_log(s, AV_LOG_WARNING, ""audio data corruption\n"");

            pvactx->continue_pes = 0;

        }

    }



    if (pva_pts != AV_NOPTS_VALUE)

        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);



    *pts   = pva_pts;

    *len   = length;

    *strid = streamid;

    return 0;

}
",496,,1,0,,-4,"s,pts,len,strid,read_packet,pb,pvactx,syncword,streamid,reserved,flags,length,pts_flag,startpos,ret,pes_signal,pes_header_data_length,pes_packet_length,pes_flags,pes_header_data",,,,,Greedy,1,0.002210235595703125
89,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
",110,"static void pred8x8_top_dc_rv40_c(uint8_t *sync, int strride){

    int io;

    int mc8;



    mc8=0;

    for(io=0;io<8; io++)

        mc8+= sync[io-strride];

    mc8= 0x01010101*((mc8 + 4)>>3);



    for(io=0; io<8; io++){

        ((uint32_t*)(sync+io*strride))[0]=

        ((uint32_t*)(sync+io*strride))[1]= mc8;

    }

}
",1,1,0,1,"src,stride,i,dc0","src:0.027577638626098633,stride:0.025364041328430176,i:0.018128395080566406,dc0:-0.022671222686767578,",4,24,"src:sync,stride:strride,i:io,dc0:mc8,",Greedy,236,0.039973998069763185
90,"static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,

                              uint16_t index, uint16_t num)

{

    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);



    if (index >= VIRTIO_PCI_QUEUE_MAX) {

        return -EINVAL;

    }



    /* Current code in virtio.c relies on 4K alignment. */

    if (addr && (align != 4096)) {

        return -EINVAL;

    }



    if (!vdev) {

        return -EINVAL;

    }



    virtio_queue_set_addr(vdev, index, addr);

    if (!addr) {

        virtio_queue_set_vector(vdev, index, 0);

    } else {

        /* Fail if we don't have a big enough queue. */

        /* TODO: Add interface to handle vring.num changing */

        if (virtio_queue_get_num(vdev, index) > num) {

            return -EINVAL;

        }

        virtio_queue_set_vector(vdev, index, index);

    }

    /* tell notify handler in case of config change */

    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;

    return 0;

}
",133,"static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t cmp,

                              uint16_t index, uint16_t num)

{

    VirtIODevice *liverad = virtio_ccw_get_vdev(sch);



    if (index >= VIRTIO_PCI_QUEUE_MAX) {

        return -EINVAL;

    }



    /* Current code in virtio.c relies on 4K alignment. */

    if (addr && (cmp != 4096)) {

        return -EINVAL;

    }



    if (!liverad) {

        return -EINVAL;

    }



    virtio_queue_set_addr(liverad, index, addr);

    if (!addr) {

        virtio_queue_set_vector(liverad, index, 0);

    } else {

        /* Fail if we don't have a big enough queue. */

        /* TODO: Add interface to handle vring.num changing */

        if (virtio_queue_get_num(liverad, index) > num) {

            return -EINVAL;

        }

        virtio_queue_set_vector(liverad, index, index);

    }

    /* tell notify handler in case of config change */

    liverad->config_vector = VIRTIO_PCI_QUEUE_MAX;

    return 0;

}
",0,0,1,1,"sch,addr,align,index,num,vdev","sch:-0.04097700119018555,addr:-0.051326215267181396,align:0.025787174701690674,index:-0.013878166675567627,num:-0.03742563724517822,vdev:0.21320831775665283,",2,9,"vdev:liverad,align:cmp,",Greedy,151,0.027522194385528564
91,"static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)

{

    rtl8139_do_receive(opaque, buf, size, 1);

}
",29,"static void rtl8139_receive(void *cataque, const uint8_t *batch, size_t en)

{

    rtl8139_do_receive(cataque, batch, en, 1);

}
",0,0,0,-1,"opaque,buf,size","opaque:-0.0010141050443053246,buf:-0.0008524036966264248,size:0.001374315470457077,",3,6,"size:en,buf:batch,opaque:cataque,",Greedy,106,0.021584721406300862
92,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, path, credp);

    }

    return -1;

}
",137,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred * cribpre)

{

    char cb[PATH_MAX];

    char *image = fs_path->data;



    if (( cribpre->fc_uid == -1 &&  cribpre->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, image, cb),

                       cribpre->fc_uid,  cribpre->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, image, cb),  cribpre);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, image,  cribpre);

    }

    return -1;

}
",0,0,1,1,"fs_ctx,fs_path,credp,buffer,path","fs_ctx:0.02083737403154373,fs_path:-0.03376995772123337,credp:0.035078659653663635,buffer:0.021006189286708832,path:0.07929720357060432,",3,14,"path:image,credp: cribpre,buffer:cb,",Greedy,264,0.043670896689097086
93,"static void qdict_crumple_test_recursive(void)

{

    QDict *src, *dst, *rule, *vnc, *acl, *listen;

    QObject *child, *res;

    QList *rules;



    src = qdict_new();

    qdict_put(src, ""vnc.listen.addr"", qstring_from_str(""127.0.0.1""));

    qdict_put(src, ""vnc.listen.port"", qstring_from_str(""5901""));

    qdict_put(src, ""vnc.acl.rules.0.match"", qstring_from_str(""fred""));

    qdict_put(src, ""vnc.acl.rules.0.policy"", qstring_from_str(""allow""));

    qdict_put(src, ""vnc.acl.rules.1.match"", qstring_from_str(""bob""));

    qdict_put(src, ""vnc.acl.rules.1.policy"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl.default"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl..name"", qstring_from_str(""acl0""));

    qdict_put(src, ""vnc.acl.rule..name"", qstring_from_str(""acl0""));



    res = qdict_crumple(src, &error_abort);



    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);



    dst = qobject_to_qdict(res);



    g_assert_cmpint(qdict_size(dst), ==, 1);



    child = qdict_get(dst, ""vnc"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    vnc = qobject_to_qdict(child);



    child = qdict_get(vnc, ""listen"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    listen = qobject_to_qdict(child);

    g_assert_cmpstr(""127.0.0.1"", ==, qdict_get_str(listen, ""addr""));

    g_assert_cmpstr(""5901"", ==, qdict_get_str(listen, ""port""));



    child = qdict_get(vnc, ""acl"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    acl = qobject_to_qdict(child);



    child = qdict_get(acl, ""rules"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);

    rules = qobject_to_qlist(child);

    g_assert_cmpint(qlist_size(rules), ==, 2);



    rule = qobject_to_qdict(qlist_pop(rules));

    g_assert_cmpint(qdict_size(rule), ==, 2);

    g_assert_cmpstr(""fred"", ==, qdict_get_str(rule, ""match""));

    g_assert_cmpstr(""allow"", ==, qdict_get_str(rule, ""policy""));

    QDECREF(rule);



    rule = qobject_to_qdict(qlist_pop(rules));

    g_assert_cmpint(qdict_size(rule), ==, 2);

    g_assert_cmpstr(""bob"", ==, qdict_get_str(rule, ""match""));

    g_assert_cmpstr(""deny"", ==, qdict_get_str(rule, ""policy""));

    QDECREF(rule);



    /* With recursive crumpling, we should see all names unescaped */

    g_assert_cmpstr(""acl0"", ==, qdict_get_str(vnc, ""acl.name""));

    child = qdict_get(vnc, ""acl"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    acl = qdict_get_qdict(vnc, ""acl"");

    g_assert_cmpstr(""acl0"", ==, qdict_get_str(acl, ""rule.name""));



    QDECREF(src);

    QDECREF(dst);

}
",581,"static void qdict_crumple_test_recursive(void)

{

    QDict *src, *dst, *rule, *vnc, *cl, *listen;

    QObject *child, *res;

    QList *Rules;



    src = qdict_new();

    qdict_put(src, ""vnc.listen.addr"", qstring_from_str(""127.0.0.1""));

    qdict_put(src, ""vnc.listen.port"", qstring_from_str(""5901""));

    qdict_put(src, ""vnc.acl.rules.0.match"", qstring_from_str(""fred""));

    qdict_put(src, ""vnc.acl.rules.0.policy"", qstring_from_str(""allow""));

    qdict_put(src, ""vnc.acl.rules.1.match"", qstring_from_str(""bob""));

    qdict_put(src, ""vnc.acl.rules.1.policy"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl.default"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl..name"", qstring_from_str(""acl0""));

    qdict_put(src, ""vnc.acl.rule..name"", qstring_from_str(""acl0""));



    res = qdict_crumple(src, &error_abort);



    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);



    dst = qobject_to_qdict(res);



    g_assert_cmpint(qdict_size(dst), ==, 1);



    child = qdict_get(dst, ""vnc"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    vnc = qobject_to_qdict(child);



    child = qdict_get(vnc, ""listen"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    listen = qobject_to_qdict(child);

    g_assert_cmpstr(""127.0.0.1"", ==, qdict_get_str(listen, ""addr""));

    g_assert_cmpstr(""5901"", ==, qdict_get_str(listen, ""port""));



    child = qdict_get(vnc, ""acl"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    cl = qobject_to_qdict(child);



    child = qdict_get(cl, ""rules"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);

    Rules = qobject_to_qlist(child);

    g_assert_cmpint(qlist_size(Rules), ==, 2);



    rule = qobject_to_qdict(qlist_pop(Rules));

    g_assert_cmpint(qdict_size(rule), ==, 2);

    g_assert_cmpstr(""fred"", ==, qdict_get_str(rule, ""match""));

    g_assert_cmpstr(""allow"", ==, qdict_get_str(rule, ""policy""));

    QDECREF(rule);



    rule = qobject_to_qdict(qlist_pop(Rules));

    g_assert_cmpint(qdict_size(rule), ==, 2);

    g_assert_cmpstr(""bob"", ==, qdict_get_str(rule, ""match""));

    g_assert_cmpstr(""deny"", ==, qdict_get_str(rule, ""policy""));

    QDECREF(rule);



    /* With recursive crumpling, we should see all names unescaped */

    g_assert_cmpstr(""acl0"", ==, qdict_get_str(vnc, ""acl.name""));

    child = qdict_get(vnc, ""acl"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    cl = qdict_get_qdict(vnc, ""acl"");

    g_assert_cmpstr(""acl0"", ==, qdict_get_str(cl, ""rule.name""));



    QDECREF(src);

    QDECREF(dst);

}
",0,0,1,1,"src,dst,rule,vnc,acl,listen,child,res,rules","src:-0.23218394815921783,dst:-0.007958963513374329,rule:-0.03165388107299805,vnc:-0.00730489194393158,acl:0.09340900182723999,listen:-0.0960630476474762,child:-0.08157634735107422,res:-0.06765957176685333,rules:0.00999005138874054,",2,10,"acl:cl,rules:Rules,",Greedy,127,0.033207249641418454
94,"static void test_validate_fail_alternate(TestInputVisitorData *data,

                                         const void *unused)

{

    UserDefAlternate *tmp;

    Visitor *v;

    Error *err = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAlternate(v, NULL, &tmp, &err);

    error_free_or_abort(&err);

    qapi_free_UserDefAlternate(tmp);

}
",63,,1,0,,-4,"data,unused,tmp,v,err",,,,,Greedy,1,0.001934826374053955
95,"static int qcow2_co_flush(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    int ret;



    qemu_co_mutex_lock(&s->lock);

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {


        return ret;

    }



    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {


        return ret;

    }




    return bdrv_co_flush(bs->file);

}",81,,1,0,,-4,"bs,s,ret",,,,,Greedy,1,0.002009133497873942
96,"static int vc1_init_common(VC1Context *v)

{

    static int done = 0;

    int i = 0;



    v->hrd_rate = v->hrd_buffer = NULL;



    /* VLC tables */

    if(!done)

    {

        done = 1;

        init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,

                 ff_vc1_bfraction_bits, 1, 1,

                 ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,

                 ff_vc1_norm2_bits, 1, 1,

                 ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,

                 ff_vc1_norm6_bits, 1, 1,

                 ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,

                 ff_vc1_imode_bits, 1, 1,

                 ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC);

        for (i=0; i<3; i++)

        {

            init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16,

                     ff_vc1_ttmb_bits[i], 1, 1,

                     ff_vc1_ttmb_codes[i], 2, 2, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8,

                     ff_vc1_ttblk_bits[i], 1, 1,

                     ff_vc1_ttblk_codes[i], 1, 1, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15,

                     ff_vc1_subblkpat_bits[i], 1, 1,

                     ff_vc1_subblkpat_codes[i], 1, 1, INIT_VLC_USE_STATIC);

        }

        for(i=0; i<4; i++)

        {

            init_vlc(&ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,

                     ff_vc1_4mv_block_pattern_bits[i], 1, 1,

                     ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64,

                     ff_vc1_cbpcy_p_bits[i], 1, 1,

                     ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73,

                     ff_vc1_mv_diff_bits[i], 1, 1,

                     ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC);

        }

        for(i=0; i<8; i++)

            init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i],

                     &vc1_ac_tables[i][0][1], 8, 4,

                     &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC);

        init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,

                 &ff_msmp4_mb_i_table[0][1], 4, 2,

                 &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC);

    }



    /* Other defaults */

    v->pq = -1;

    v->mvrange = 0; /* 7.1.1.18, p80 */



    return 0;

}
",482,"static int vc1_init_common(VC1Context *lv)

{

    static int done = 0;

    int field = 0;



    lv->hrd_rate = lv->hrd_buffer = NULL;



    /* VLC tables */

    if(!done)

    {

        done = 1;

        init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,

                 ff_vc1_bfraction_bits, 1, 1,

                 ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,

                 ff_vc1_norm2_bits, 1, 1,

                 ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,

                 ff_vc1_norm6_bits, 1, 1,

                 ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,

                 ff_vc1_imode_bits, 1, 1,

                 ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC);

        for (field=0; field<3; field++)

        {

            init_vlc(&ff_vc1_ttmb_vlc[field], VC1_TTMB_VLC_BITS, 16,

                     ff_vc1_ttmb_bits[field], 1, 1,

                     ff_vc1_ttmb_codes[field], 2, 2, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_ttblk_vlc[field], VC1_TTBLK_VLC_BITS, 8,

                     ff_vc1_ttblk_bits[field], 1, 1,

                     ff_vc1_ttblk_codes[field], 1, 1, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_subblkpat_vlc[field], VC1_SUBBLKPAT_VLC_BITS, 15,

                     ff_vc1_subblkpat_bits[field], 1, 1,

                     ff_vc1_subblkpat_codes[field], 1, 1, INIT_VLC_USE_STATIC);

        }

        for(field=0; field<4; field++)

        {

            init_vlc(&ff_vc1_4mv_block_pattern_vlc[field], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,

                     ff_vc1_4mv_block_pattern_bits[field], 1, 1,

                     ff_vc1_4mv_block_pattern_codes[field], 1, 1, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_cbpcy_p_vlc[field], VC1_CBPCY_P_VLC_BITS, 64,

                     ff_vc1_cbpcy_p_bits[field], 1, 1,

                     ff_vc1_cbpcy_p_codes[field], 2, 2, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_mv_diff_vlc[field], VC1_MV_DIFF_VLC_BITS, 73,

                     ff_vc1_mv_diff_bits[field], 1, 1,

                     ff_vc1_mv_diff_codes[field], 2, 2, INIT_VLC_USE_STATIC);

        }

        for(field=0; field<8; field++)

            init_vlc(&ff_vc1_ac_coeff_table[field], AC_VLC_BITS, vc1_ac_sizes[field],

                     &vc1_ac_tables[field][0][1], 8, 4,

                     &vc1_ac_tables[field][0][0], 8, 4, INIT_VLC_USE_STATIC);

        init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,

                 &ff_msmp4_mb_i_table[0][1], 4, 2,

                 &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC);

    }



    /* Other defaults */

    lv->pq = -1;

    lv->mvrange = 0; /* 7.1.1.18, p80 */



    return 0;

}
",1,1,1,-1,"v,i","v:-0.0005006790161132812,i:0.00012356042861938477,",2,37,"i:field,v:lv,",Greedy,147,0.03307004769643148
97,"int av_read_packet(AVFormatContext *s, AVPacket *pkt)
{
    int ret, i;
    AVStream *st;
    for(;;){
        AVPacketList *pktl = s->raw_packet_buffer;
        if (pktl) {
            *pkt = pktl->pkt;
            if(s->streams[pkt->stream_index]->codec->codec_id != CODEC_ID_PROBE ||
               !s->streams[pkt->stream_index]->probe_packets ||
               s->raw_packet_buffer_remaining_size < pkt->size){
                AVProbeData *pd = &s->streams[pkt->stream_index]->probe_data;
                av_freep(&pd->buf);
                pd->buf_size = 0;
                s->raw_packet_buffer = pktl->next;
                s->raw_packet_buffer_remaining_size += pkt->size;
                av_free(pktl);
                return 0;
        av_init_packet(pkt);
        ret= s->iformat->read_packet(s, pkt);
        if (ret < 0) {
            if (!pktl || ret == AVERROR(EAGAIN))
                return ret;
            for (i = 0; i < s->nb_streams; i++)
                s->streams[i]->probe_packets = 0;
        st= s->streams[pkt->stream_index];
        switch(st->codec->codec_type){
        case AVMEDIA_TYPE_VIDEO:
            if(s->video_codec_id)   st->codec->codec_id= s->video_codec_id;
            break;
        case AVMEDIA_TYPE_AUDIO:
            if(s->audio_codec_id)   st->codec->codec_id= s->audio_codec_id;
            break;
        case AVMEDIA_TYPE_SUBTITLE:
            if(s->subtitle_codec_id)st->codec->codec_id= s->subtitle_codec_id;
            break;
        if(!pktl && (st->codec->codec_id != CODEC_ID_PROBE ||
                     !st->probe_packets))
            return ret;
        add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end);
        s->raw_packet_buffer_remaining_size -= pkt->size;
        if(st->codec->codec_id == CODEC_ID_PROBE){
            AVProbeData *pd = &st->probe_data;
            av_log(s, AV_LOG_DEBUG, ""probing stream %d\n"", st->index);
            --st->probe_packets;
            pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);
            memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);
            pd->buf_size += pkt->size;
            memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);
            if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){
                //FIXME we dont reduce score to 0 for the case of running out of buffer space in bytes
                set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0);
                if(st->codec->codec_id != CODEC_ID_PROBE){
                    pd->buf_size=0;
                    av_freep(&pd->buf);
                    av_log(s, AV_LOG_DEBUG, ""probed stream %d\n"", st->index);",517,"int av_read_packet(AVFormatContext *new, AVPacket *cpacket)
{
    int value, id;
    AVStream *sa;
    for(;;){
        AVPacketList *pktls = new->raw_packet_buffer;
        if (pktls) {
            *cpacket = pktls->cpacket;
            if(new->streams[cpacket->stream_index]->codec->codec_id != CODEC_ID_PROBE ||
               !new->streams[cpacket->stream_index]->probe_packet ||
               new->raw_packet_buffer_remaining_size < cpacket->size){
                AVProbeData *tp = &new->streams[cpacket->stream_index]->probe_data;
                av_freep(&tp->buf);
                tp->buf_size = 0;
                new->raw_packet_buffer = pktls->next;
                new->raw_packet_buffer_remaining_size += cpacket->size;
                av_free(pktls);
                return 0;
        av_init_packet(cpacket);
        value= new->iformat->read_packet(new, cpacket);
        if (value < 0) {
            if (!pktls || value == AVERROR(EAGAIN))
                return value;
            for (id = 0; id < new->nb_streams; id++)
                new->streams[id]->probe_packet = 0;
        sa= new->streams[cpacket->stream_index];
        switch(sa->codec->codec_type){
        case AVMEDIA_TYPE_VIDEO:
            if(new->video_codec_id)   sa->codec->codec_id= new->video_codec_id;
            break;
        case AVMEDIA_TYPE_AUDIO:
            if(new->audio_codec_id)   sa->codec->codec_id= new->audio_codec_id;
            break;
        case AVMEDIA_TYPE_SUBTITLE:
            if(new->subtitle_codec_id)sa->codec->codec_id= new->subtitle_codec_id;
            break;
        if(!pktls && (sa->codec->codec_id != CODEC_ID_PROBE ||
                     !sa->probe_packet))
            return value;
        add_to_pktbuf(&new->raw_packet_buffer, cpacket, &new->raw_packet_buffer_end);
        new->raw_packet_buffer_remaining_size -= cpacket->size;
        if(sa->codec->codec_id == CODEC_ID_PROBE){
            AVProbeData *tp = &sa->probe_data;
            av_log(new, AV_LOG_DEBUG, ""probing stream %d
"", sa->index);
            --sa->probe_packet;
            tp->buf = av_realloc(tp->buf, tp->buf_size+cpacket->size+AVPROBE_PADDING_SIZE);
            memcpy(tp->buf+tp->buf_size, cpacket->data, cpacket->size);
            tp->buf_size += cpacket->size;
            memset(tp->buf+tp->buf_size, 0, AVPROBE_PADDING_SIZE);
            if(av_log2(tp->buf_size) != av_log2(tp->buf_size - cpacket->size)){
                //FIXME we dont reduce score to 0 for the case of running out of buffer space in bytes
                set_codec_from_probe_data(new, sa, tp, sa->probe_packet > 0 ? AVPROBE_SCORE_MAX/4 : 0);
                if(sa->codec->codec_id != CODEC_ID_PROBE){
                    tp->buf_size=0;
                    av_freep(&tp->buf);
                    av_log(new, AV_LOG_DEBUG, ""probed stream %d
"", sa->index);",1,1,1,-1,"s,pkt,ret,i,st,pktl,pd,probe_packets","s:0.0007690787315368652,pkt:-0.00025284290313720703,ret:0.0007178783416748047,i:0.0002428889274597168,st:-0.00011599063873291016,pktl:-0.0011211037635803223,pd:-0.00016498565673828125,probe_packets:-0.0006413459777832031,",8,99,"s:new,ret:value,i:id,st:sa,pd:tp,pkt:cpacket,probe_packets:probe_packet,pktl:pktls,",Greedy,649,0.1308654546737671
98,"static int nbd_can_accept(void)

{

    return nb_fds < shared;

}
",13,,1,0,,-4,,,,,,Greedy,1,0.00204464594523112
99,"static int net_connect(struct XenDevice *xendev)

{

    struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev);

    int rx_copy;



    if (xenstore_read_fe_int(&netdev->xendev, ""tx-ring-ref"",

                             &netdev->tx_ring_ref) == -1) {

        return -1;

    }

    if (xenstore_read_fe_int(&netdev->xendev, ""rx-ring-ref"",

                             &netdev->rx_ring_ref) == -1) {

        return 1;

    }

    if (xenstore_read_fe_int(&netdev->xendev, ""event-channel"",

                             &netdev->xendev.remote_port) == -1) {

        return -1;

    }



    if (xenstore_read_fe_int(&netdev->xendev, ""request-rx-copy"", &rx_copy) == -1) {

        rx_copy = 0;

    }

    if (rx_copy == 0) {

        xen_be_printf(&netdev->xendev, 0, ""frontend doesn't support rx-copy.\n"");

        return -1;

    }



    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,

                                          netdev->xendev.dom,

                                          netdev->tx_ring_ref,

                                          PROT_READ | PROT_WRITE);

    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,

                                          netdev->xendev.dom,

                                          netdev->rx_ring_ref,

                                          PROT_READ | PROT_WRITE);

    if (!netdev->txs || !netdev->rxs) {

        return -1;

    }

    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);

    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);



    xen_be_bind_evtchn(&netdev->xendev);



    xen_be_printf(&netdev->xendev, 1, ""ok: tx-ring-ref %d, rx-ring-ref %d, ""

                  ""remote port %d, local port %d\n"",

                  netdev->tx_ring_ref, netdev->rx_ring_ref,

                  netdev->xendev.remote_port, netdev->xendev.local_port);



    net_tx_packets(netdev);

    return 0;

}
",304,"static int net_connect(struct XenDevice *xendev)

{

    struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev);

    int  tx_copy;



    if (xenstore_read_fe_int(&netdev->xendev, ""tx-ring-ref"",

                             &netdev->tx_ring_ref) == -1) {

        return -1;

    }

    if (xenstore_read_fe_int(&netdev->xendev, ""rx-ring-ref"",

                             &netdev->rx_ring_ref) == -1) {

        return 1;

    }

    if (xenstore_read_fe_int(&netdev->xendev, ""event-channel"",

                             &netdev->xendev.remote_port) == -1) {

        return -1;

    }



    if (xenstore_read_fe_int(&netdev->xendev, ""request-rx-copy"", & tx_copy) == -1) {

         tx_copy = 0;

    }

    if ( tx_copy == 0) {

        xen_be_printf(&netdev->xendev, 0, ""frontend doesn't support rx-copy.
"");

        return -1;

    }



    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,

                                          netdev->xendev.dom,

                                          netdev->tx_ring_ref,

                                          PROT_READ | PROT_WRITE);

    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,

                                          netdev->xendev.dom,

                                          netdev->rx_ring_ref,

                                          PROT_READ | PROT_WRITE);

    if (!netdev->txs || !netdev->rxs) {

        return -1;

    }

    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);

    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);



    xen_be_bind_evtchn(&netdev->xendev);



    xen_be_printf(&netdev->xendev, 1, ""ok: tx-ring-ref %d, rx-ring-ref %d, ""

                  ""remote port %d, local port %d
"",

                  netdev->tx_ring_ref, netdev->rx_ring_ref,

                  netdev->xendev.remote_port, netdev->xendev.local_port);



    net_tx_packets(netdev);

    return 0;

}
",1,1,0,1,"xendev,netdev,rx_copy","xendev:-0.019726814702153206,netdev:0.012702617794275284,rx_copy:0.019293753430247307,",1,4,"rx_copy: tx_copy,",Greedy,85,0.018860248724619548
100,"static bool do_modify_softint(CPUSPARCState *env, uint32_t value)

{

    if (env->softint != value) {

        env->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(env)) {


            cpu_check_irqs(env);


        }

#endif

        return true;

    }

    return false;

}",57,"static bool do_modify_softint(CPUSPARCState *enable, uint32_t value)

{

    if (enable->softint != value) {

        enable->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(enable)) {


            cpu_check_irqs(enable);


        }

#endif

        return true;

    }

    return false;

}",1,1,0,1,"env,value","env:0.1158301830291748,value:0.061179518699645996,",1,5,"env:enable,",Greedy,67,0.013500765959421793
101,"static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent, int numBands)

{

    int i,j,k,cnt;

    int   components, coding_mode_selector, coding_mode, coded_values_per_component;

    int   sfIndx, coded_values, max_coded_values, quant_step_index, coded_components;

    int   band_flags[4], mantissa[8];

    float  *pCoef;

    float  scalefactor;

    int   component_count = 0;



    components = get_bits(gb,5);



    /* no tonal components */

    if (components == 0)

        return 0;



    coding_mode_selector = get_bits(gb,2);

    if (coding_mode_selector == 2)




    coding_mode = coding_mode_selector & 1;



    for (i = 0; i < components; i++) {

        for (cnt = 0; cnt <= numBands; cnt++)

            band_flags[cnt] = get_bits1(gb);



        coded_values_per_component = get_bits(gb,3);



        quant_step_index = get_bits(gb,3);

        if (quant_step_index <= 1)




        if (coding_mode_selector == 3)

            coding_mode = get_bits1(gb);



        for (j = 0; j < (numBands + 1) * 4; j++) {

            if (band_flags[j >> 2] == 0)

                continue;



            coded_components = get_bits(gb,3);



            for (k=0; k<coded_components; k++) {

                sfIndx = get_bits(gb,6);



                pComponent[component_count].pos = j * 64 + (get_bits(gb,6));

                max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;

                coded_values = coded_values_per_component + 1;

                coded_values = FFMIN(max_coded_values,coded_values);



                scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index];



                readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values);



                pComponent[component_count].numCoefs = coded_values;



                /* inverse quant */

                pCoef = pComponent[component_count].coef;

                for (cnt = 0; cnt < coded_values; cnt++)

                    pCoef[cnt] = mantissa[cnt] * scalefactor;



                component_count++;

            }

        }

    }



    return component_count;

}",370,"static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent, int numBands)

{

    int i,f,k,cnt;

    int   components, coding_mode_electOR, coding_mode, coded_values_perjcomponent;

    int   sfIndx, coded_stores, max_coded00frames, quant_group_count, coded_components;

    int   band___flag[4], mantissa[8];

    float  *pCoef;

    float  scalefact;

    int   component_count = 0;



    components = get_bits(gb,5);



    /* no tonal components */

    if (components == 0)

        return 0;



    coding_mode_electOR = get_bits(gb,2);

    if (coding_mode_electOR == 2)




    coding_mode = coding_mode_electOR & 1;



    for (i = 0; i < components; i++) {

        for (cnt = 0; cnt <= numBands; cnt++)

            band___flag[cnt] = get_bits1(gb);



        coded_values_perjcomponent = get_bits(gb,3);



        quant_group_count = get_bits(gb,3);

        if (quant_group_count <= 1)




        if (coding_mode_electOR == 3)

            coding_mode = get_bits1(gb);



        for (f = 0; f < (numBands + 1) * 4; f++) {

            if (band___flag[f >> 2] == 0)

                continue;



            coded_components = get_bits(gb,3);



            for (k=0; k<coded_components; k++) {

                sfIndx = get_bits(gb,6);



                pComponent[component_count].pos = f * 64 + (get_bits(gb,6));

                max_coded00frames = SAMPLES_PER_FRAME - pComponent[component_count].pos;

                coded_stores = coded_values_perjcomponent + 1;

                coded_stores = FFMIN(max_coded00frames,coded_stores);



                scalefact = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_group_count];



                readQuantSpectralCoeffs(gb, quant_group_count, coding_mode, mantissa, coded_stores);



                pComponent[component_count].numCoefs = coded_stores;



                /* inverse quant */

                pCoef = pComponent[component_count].coef;

                for (cnt = 0; cnt < coded_stores; cnt++)

                    pCoef[cnt] = mantissa[cnt] * scalefact;



                component_count++;

            }

        }

    }



    return component_count;

}",1,1,0,1,"gb,pComponent,numBands,i,j,k,cnt,components,coding_mode_selector,coding_mode,coded_values_per_component,sfIndx,coded_values,max_coded_values,quant_step_index,coded_components,band_flags,mantissa,pCoef,scalefactor,component_count","gb:-0.18320316076278687,pComponent:0.026354193687438965,numBands:0.1548265814781189,i:-0.02648138999938965,j:0.37733352184295654,k:-0.037367284297943115,cnt:0.033746421337127686,components:-0.08167237043380737,coding_mode_selector:0.8688454627990723,coding_mode:0.05026102066040039,coded_values_per_component:0.5458696484565735,sfIndx:0.15112072229385376,coded_values:0.33872443437576294,max_coded_values:0.4680898189544678,quant_step_index:0.754334032535553,coded_components:0.2878348231315613,band_flags:0.37434619665145874,mantissa:0.01277071237564087,pCoef:0.03442370891571045,scalefactor:0.4407538175582886,component_count:0.11705100536346436,",8,35,"coding_mode_selector:coding_mode_electOR,quant_step_index:quant_group_count,coded_values_per_component:coded_values_perjcomponent,max_coded_values:max_coded00frames,scalefactor:scalefact,j:f,band_flags:band___flag,coded_values:coded_stores,",Greedy,380,0.07798947095870971
102,"static void do_send_key(const char *string)

{

    char keybuf[16], *q;

    uint8_t keycodes[16];

    const char *p;

    int nb_keycodes, keycode, i;



    nb_keycodes = 0;

    p = string;

    while (*p != '\0') {

        q = keybuf;

        while (*p != '\0' && *p != '-') {

            if ((q - keybuf) < sizeof(keybuf) - 1) {

                *q++ = *p;

            }

            p++;

        }

        *q = '\0';

        keycode = get_keycode(keybuf);

        if (keycode < 0) {

            term_printf(""unknown key: '%s'\n"", keybuf);

            return;

        }

        keycodes[nb_keycodes++] = keycode;

        if (*p == '\0')

            break;

        p++;

    }

    /* key down events */

    for(i = 0; i < nb_keycodes; i++) {

        keycode = keycodes[i];

        if (keycode & 0x80)

            kbd_put_keycode(0xe0);

        kbd_put_keycode(keycode & 0x7f);

    }

    /* key up events */

    for(i = nb_keycodes - 1; i >= 0; i--) {

        keycode = keycodes[i];

        if (keycode & 0x80)

            kbd_put_keycode(0xe0);

        kbd_put_keycode(keycode | 0x80);

    }

}
",241,,1,0,,-4,"keybuf,q,keycodes,p,nb_keycodes,keycode,i",,,,,Greedy,1,0.0021044413248697915
103,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double d;

    char *ptr;

    FdMigrationState *s;

    const char *value = qdict_get_str(qdict, ""value"");



    d = strtod(value, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    }

    

}
",129,"void do_migrate_set_speed(Monitor *reg, const QDict *qqdf, QObject **regblockresults)

{

    double dy;

    char *fd;

    FdMigrationState *s;

    const char *message = qdict_get_str(qqdf, ""value"");



    dy = strtod(message, &fd);

    switch (*fd) {

    case 'G': case 'g':

        dy *= 1024;

    case 'M': case 'm':

        dy *= 1024;

    case 'K': case 'k':

        dy *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)dy;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    }

    

}
",0,0,1,1,"mon,qdict,ret_data,d,ptr,s,value","mon:-0.0009958148002624512,qdict:0.028625518083572388,ret_data:0.08208273351192474,d:-0.048821136355400085,ptr:-0.027318187057971954,s:-0.05689089745283127,value:0.0027625858783721924,",6,15,"ret_data:regblockresults,qdict:qqdf,value:message,mon:reg,ptr:fd,d:dy,",Greedy,241,0.04612712462743123
104,"static inline void gen_efdneg(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
",113,"static inline void gen_efdneg(DisasContext *git)

{

    if (unlikely(!git->spe_enabled)) {

        gen_exception(git, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_xori_tl(cpu_gpr[rD(git->opcode)], cpu_gpr[rA(git->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[rD(git->opcode)], cpu_gpr[rA(git->opcode)]);

    tcg_gen_xori_tl(cpu_gprh[rD(git->opcode)], cpu_gprh[rA(git->opcode)], 0x80000000);

#endif

}
",0,0,0,-1,ctx,"ctx:0.0007998095825314522,",1,9,"ctx:git,",Greedy,78,0.01557552417119344
105,"static void gen_srlq(DisasContext *ctx)

{

    int l1 = gen_new_label();

    int l2 = gen_new_label();

    TCGv t0 = tcg_temp_local_new();

    TCGv t1 = tcg_temp_local_new();

    TCGv t2 = tcg_temp_local_new();

    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);

    tcg_gen_movi_tl(t1, 0xFFFFFFFF);

    tcg_gen_shr_tl(t2, t1, t2);

    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);

    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);

    gen_load_spr(t0, SPR_MQ);

    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);

    tcg_gen_and_tl(t0, t0, t2);

    gen_load_spr(t1, SPR_MQ);

    tcg_gen_andc_tl(t1, t1, t2);

    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);

    gen_set_label(l2);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

    tcg_temp_free(t2);

    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);

}
",248,"static void gen_srlq(DisasContext *cms)

{

    int l1 = gen_new_label();

    int l2 = gen_new_label();

    TCGv t0 = tcg_temp_local_new();

    TCGv t1 = tcg_temp_local_new();

    TCGv t2 = tcg_temp_local_new();

    tcg_gen_andi_tl(t2, cpu_gpr[rB(cms->opcode)], 0x1F);

    tcg_gen_movi_tl(t1, 0xFFFFFFFF);

    tcg_gen_shr_tl(t2, t1, t2);

    tcg_gen_andi_tl(t0, cpu_gpr[rB(cms->opcode)], 0x20);

    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);

    gen_load_spr(t0, SPR_MQ);

    tcg_gen_and_tl(cpu_gpr[rA(cms->opcode)], t0, t2);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_shr_tl(t0, cpu_gpr[rS(cms->opcode)], t2);

    tcg_gen_and_tl(t0, t0, t2);

    gen_load_spr(t1, SPR_MQ);

    tcg_gen_andc_tl(t1, t1, t2);

    tcg_gen_or_tl(cpu_gpr[rA(cms->opcode)], t0, t1);

    gen_set_label(l2);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

    tcg_temp_free(t2);

    if (unlikely(Rc(cms->opcode) != 0))

        gen_set_Rc0(cms, cpu_gpr[rA(cms->opcode)]);

}
",0,0,0,-1,ctx,"ctx:0.001023382879793644,",1,9,"ctx:cms,",Greedy,77,0.017523821194966635
106,"static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)

{

    VirtQueueElement elem;

    VirtQueue *vq;



    vq = vser->c_ivq;

    if (!virtio_queue_ready(vq)) {

        return 0;

    }

    if (!virtqueue_pop(vq, &elem)) {

        return 0;

    }



    /* TODO: detect a buffer that's too short, set NEEDS_RESET */

    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);



    virtqueue_push(vq, &elem, len);

    virtio_notify(VIRTIO_DEVICE(vser), vq);

    return len;

}
",99,"static size_t send_control_msg(VirtIOSerial *qcer, void *batch, size_t line)

{

    VirtQueueElement elements;

    VirtQueue * vbar;



     vbar = qcer->c_ivq;

    if (!virtio_queue_ready( vbar)) {

        return 0;

    }

    if (!virtqueue_pop( vbar, &elements)) {

        return 0;

    }



    /* TODO: detect a buffer that's too short, set NEEDS_RESET */

    iov_from_buf(elements.in_sg, elements.in_num, 0, batch, line);



    virtqueue_push( vbar, &elements, line);

    virtio_notify(VIRTIO_DEVICE(qcer),  vbar);

    return line;

}
",0,0,0,-1,"vser,buf,len,elem,vq","vser:0.018886558711528778,buf:0.0524296909570694,len:0.10060315579175949,elem:0.024942636489868164,vq:-0.024153877049684525,",5,20,"len:line,buf:batch,elem:elements,vser:qcer,vq: vbar,",Greedy,260,0.04768636226654053
107,"void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,

                  qemu_irq sci_irq)

{

    memory_region_init(&pm->io, OBJECT(lpc_pci), ""ich9-pm"", ICH9_PMIO_SIZE);

    memory_region_set_enabled(&pm->io, false);

    memory_region_add_subregion(pci_address_space_io(lpc_pci),

                                0, &pm->io);



    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);

    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);

    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->s4_val);



    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);

    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,

                          ""acpi-gpe0"", ICH9_PMIO_GPE0_LEN);

    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);



    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,

                          ""acpi-smi"", 8);

    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);



    pm->irq = sci_irq;

    qemu_register_reset(pm_reset, pm);

    pm->powerdown_notifier.notify = pm_powerdown_req;

    qemu_register_powerdown_notifier(&pm->powerdown_notifier);



    acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),

                          &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);



    if (pm->acpi_memory_hotplug.is_enabled) {

        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),

                                 &pm->acpi_memory_hotplug);

    }

}
",269,"void ich9_pm_init(PCIDevice *lpc_phpoci, ICH9LPCPMRegs *mp,

                  qemu_irq sci_irk)

{

    memory_region_init(&mp->io, OBJECT(lpc_phpoci), ""ich9-pm"", ICH9_PMIO_SIZE);

    memory_region_set_enabled(&mp->io, false);

    memory_region_add_subregion(pci_address_space_io(lpc_phpoci),

                                0, &mp->io);



    acpi_pm_tmr_init(&mp->acpi_regs, ich9_pm_update_sci_fn, &mp->io);

    acpi_pm1_evt_init(&mp->acpi_regs, ich9_pm_update_sci_fn, &mp->io);

    acpi_pm1_cnt_init(&mp->acpi_regs, &mp->io, mp->s4_val);



    acpi_gpe_init(&mp->acpi_regs, ICH9_PMIO_GPE0_LEN);

    memory_region_init_io(&mp->io_gpe, OBJECT(lpc_phpoci), &ich9_gpe_ops, mp,

                          ""acpi-gpe0"", ICH9_PMIO_GPE0_LEN);

    memory_region_add_subregion(&mp->io, ICH9_PMIO_GPE0_STS, &mp->io_gpe);



    memory_region_init_io(&mp->io_smi, OBJECT(lpc_phpoci), &ich9_smi_ops, mp,

                          ""acpi-smi"", 8);

    memory_region_add_subregion(&mp->io, ICH9_PMIO_SMI_EN, &mp->io_smi);



    mp->irq = sci_irk;

    qemu_register_reset(pm_reset, mp);

    mp->powerdown_notifier.notify = pm_powerdown_req;

    qemu_register_powerdown_notifier(&mp->powerdown_notifier);



    acpi_cpu_hotplug_init(pci_address_space_io(lpc_phpoci), OBJECT(lpc_phpoci),

                          &mp->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);



    if (mp->acpi_memory_hotplug.is_enabled) {

        acpi_memory_hotplug_init(pci_address_space_io(lpc_phpoci), OBJECT(lpc_phpoci),

                                 &mp->acpi_memory_hotplug);

    }

}
",0,0,0,-1,"lpc_pci,pm,sci_irq","lpc_pci:-0.034851573407649994,pm:0.14937470108270645,sci_irq:0.00617072731256485,",3,38,"pm:mp,sci_irq:sci_irk,lpc_pci:lpc_phpoci,",Greedy,210,0.042245113849639894
108,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)

{

    uint8_t ret;



    OMAP_8B_REG(addr);

    cpu_physical_memory_read(addr, (void *) &ret, 1);

    return ret;

}
",37,"uint32_t omap_badwidth_read8(void *ipcode, target_phys_addr_t fd)

{

    uint8_t det;



    OMAP_8B_REG(fd);

    cpu_physical_memory_read(fd, (void *) &det, 1);

    return det;

}
",0,0,0,-1,"opaque,addr,ret","opaque:9.928178042173386e-05,addr:0.00016024010255932808,ret:8.088350296020508e-05,",3,7,"addr:fd,opaque:ipcode,ret:det,",Greedy,114,0.02265244722366333
109,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)

{

    q->pending++;

    set_bit(q->queue, n_IRQ);

}
",28,,1,0,,-4,"q,n_IRQ,pending",,,,,Greedy,1,0.0019731879234313964
110,"static int matroska_decode_buffer(uint8_t** buf, int* buf_size,

                                  MatroskaTrack *track)

{

    MatroskaTrackEncoding *encodings = track->encodings.elem;

    uint8_t* data = *buf;

    int isize = *buf_size;

    uint8_t* pkt_data = NULL;

    int pkt_size = isize;

    int result = 0;

    int olen;



    if (pkt_size >= 10000000)

        return -1;



    switch (encodings[0].compression.algo) {

    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:

        return encodings[0].compression.settings.size;

    case MATROSKA_TRACK_ENCODING_COMP_LZO:

        do {

            olen = pkt_size *= 3;

            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);

            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);

        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);

        if (result)

            goto failed;

        pkt_size -= olen;

        break;

#if CONFIG_ZLIB

    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {

        z_stream zstream = {0};

        if (inflateInit(&zstream) != Z_OK)

            return -1;

        zstream.next_in = data;

        zstream.avail_in = isize;

        do {

            pkt_size *= 3;

            pkt_data = av_realloc(pkt_data, pkt_size);

            zstream.avail_out = pkt_size - zstream.total_out;

            zstream.next_out = pkt_data + zstream.total_out;

            result = inflate(&zstream, Z_NO_FLUSH);

        } while (result==Z_OK && pkt_size<10000000);

        pkt_size = zstream.total_out;

        inflateEnd(&zstream);

        if (result != Z_STREAM_END)

            goto failed;

        break;

    }

#endif

#if CONFIG_BZLIB

    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {

        bz_stream bzstream = {0};

        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)

            return -1;

        bzstream.next_in = data;

        bzstream.avail_in = isize;

        do {

            pkt_size *= 3;

            pkt_data = av_realloc(pkt_data, pkt_size);

            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;

            bzstream.next_out = pkt_data + bzstream.total_out_lo32;

            result = BZ2_bzDecompress(&bzstream);

        } while (result==BZ_OK && pkt_size<10000000);

        pkt_size = bzstream.total_out_lo32;

        BZ2_bzDecompressEnd(&bzstream);

        if (result != BZ_STREAM_END)

            goto failed;

        break;

    }

#endif

    default:

        return -1;

    }



    *buf = pkt_data;

    *buf_size = pkt_size;

    return 0;

 failed:

    av_free(pkt_data);

    return -1;

}
",432,,1,0,,-4,"buf,buf_size,track,encodings,data,pkt_data,olen",,,,,Greedy,1,0.0022052089373270673
111,"static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs)

{

    int i;



    for (i = 0; i < nb_coefs; i++) {

        int e;

        int v = abs(coef[i]);

        if (v == 0)

            e = 24;

        else {

            e = 23 - av_log2(v);

            if (e >= 24) {

                e = 24;

                coef[i] = 0;

            }

            av_assert2(e >= 0);

        }

        exp[i] = e;

    }

}
",104,,0,1,,-4,"coef,nb_coefs,i,e",,,,,Greedy,1,0.001957237720489502
112,"static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

{

    /* FIXME: implement */

}
",14,"static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *sub)

{

    /* FIXME: implement */

}
",0,0,1,1,"listener,section","listener:0.01984769105911255,section:0.17292040586471558,",1,1,"section:sub,",Greedy,31,0.009253327051798503
113,"static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)

{

    struct hp_log_full *new_hp;

    struct rtas_error_log *hdr;

    struct rtas_event_log_v6 *v6hdr;

    struct rtas_event_log_v6_maina *maina;

    struct rtas_event_log_v6_mainb *mainb;

    struct rtas_event_log_v6_hp *hp;

    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);

    sPAPRDRConnectorType drc_type = drck->get_type(drc);



    new_hp = g_malloc0(sizeof(struct hp_log_full));

    hdr = &new_hp->hdr;

    v6hdr = &new_hp->v6hdr;

    maina = &new_hp->maina;

    mainb = &new_hp->mainb;

    hp = &new_hp->hp;



    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6

                               | RTAS_LOG_SEVERITY_EVENT

                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED

                               | RTAS_LOG_OPTIONAL_PART_PRESENT

                               | RTAS_LOG_INITIATOR_HOTPLUG

                               | RTAS_LOG_TYPE_HOTPLUG);

    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)

                                       - sizeof(new_hp->hdr));



    spapr_init_v6hdr(v6hdr);

    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);



    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);

    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));

    mainb->subsystem_id = 0x80; /* External environment */

    mainb->event_severity = 0x00; /* Informational / non-error */

    mainb->event_subtype = 0x00; /* Normal shutdown */



    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);

    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));

    hp->hdr.section_version = 1; /* includes extended modifier */

    hp->hotplug_action = hp_action;





    switch (drc_type) {

    case SPAPR_DR_CONNECTOR_TYPE_PCI:

        hp->drc.index = cpu_to_be32(drck->get_index(drc));

        hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;

        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;

        break;

    default:

        /* we shouldn't be signaling hotplug events for resources

         * that don't support them

         */

        g_assert(false);

        return;

    }



    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));

}
",312,"static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)

{

    struct hp_log_full *final_hp;

    struct rtas_error_log *hdr;

    struct rtas_event_log_v6 *v6shost;

    struct rtas_event_log_v6_maina *maina;

    struct rtas_event_log_v6_mainb *mainb;

    struct rtas_event_log_v6_hp *hap;

    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);

    sPAPRDRConnectorType drc_type = drck->get_type(drc);



    final_hp = g_malloc0(sizeof(struct hp_log_full));

    hdr = &final_hp->hdr;

    v6shost = &final_hp->v6shost;

    maina = &final_hp->maina;

    mainb = &final_hp->mainb;

    hap = &final_hp->hap;



    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6

                               | RTAS_LOG_SEVERITY_EVENT

                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED

                               | RTAS_LOG_OPTIONAL_PART_PRESENT

                               | RTAS_LOG_INITIATOR_HOTPLUG

                               | RTAS_LOG_TYPE_HOTPLUG);

    hdr->extended_length = cpu_to_be32(sizeof(*final_hp)

                                       - sizeof(final_hp->hdr));



    spapr_init_v6hdr(v6shost);

    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);



    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);

    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));

    mainb->subsystem_id = 0x80; /* External environment */

    mainb->event_severity = 0x00; /* Informational / non-error */

    mainb->event_subtype = 0x00; /* Normal shutdown */



    hap->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);

    hap->hdr.section_length = cpu_to_be16(sizeof(*hap));

    hap->hdr.section_version = 1; /* includes extended modifier */

    hap->hotplug_action = hp_action;





    switch (drc_type) {

    case SPAPR_DR_CONNECTOR_TYPE_PCI:

        hap->drc.index = cpu_to_be32(drck->get_index(drc));

        hap->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;

        hap->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;

        break;

    default:

        /* we shouldn't be signaling hotplug events for resources

         * that don't support them

         */

        g_assert(false);

        return;

    }



    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, final_hp);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));

}
",0,0,1,1,"drc,hp_action,new_hp,hdr,v6hdr,maina,mainb,hp,drck","drc:0.01426839828491211,hp_action:0.008884072303771973,new_hp:0.2661847323179245,hdr:-0.013910725712776184,v6hdr:0.1950455904006958,maina:-0.0015674978494644165,mainb:-0.06014319509267807,hp:0.05438605695962906,drck:0.036406517028808594,",3,25,"new_hp:final_hp,v6hdr:v6shost,hp:hap,",Greedy,248,0.0488800048828125
114,"static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,

                               TCGMemOp s_bits, int which)

{

    const TCGReg r0 = TCG_REG_O0;

    const TCGReg r1 = TCG_REG_O1;

    const TCGReg r2 = TCG_REG_O2;

    int tlb_ofs;



    /* Shift the page number down.  */

    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);



    /* Mask out the page offset, except for the required alignment.  */

    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,

                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));



    /* Mask the tlb index.  */

    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);

    

    /* Mask page, part 2.  */

    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);



    /* Shift the tlb index into place.  */

    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);



    /* Relative to the current ENV.  */

    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);



    /* Find a base address that can load both tlb comparator and addend.  */

    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);

    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {

        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);

        tlb_ofs &= 0x3ff;

    }



    /* Load the tlb comparator and the addend.  */

    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);

    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));



    /* subcc arg0, arg2, %g0 */

    tcg_out_cmp(s, r0, r2, 0);



    /* If the guest address must be zero-extended, do so now.  */

    if (SPARC64 && TARGET_LONG_BITS == 32) {

        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);

        return r0;

    }

    return addr;

}
",254,"static TCGReg tcg_out_tlb_load(TCGContext *services, TCGReg Error, int  mem_mask,

                               TCGMemOp s_length, int mac)

{

    const TCGReg r0 = TCG_REG_O0;

    const TCGReg r1 = TCG_REG_O1;

    const TCGReg r2 = TCG_REG_O2;

    int tlb_notts;



    /* Shift the page number down.  */

    tcg_out_arithi(services, r1, Error, TARGET_PAGE_BITS, SHIFT_SRL);



    /* Mask out the page offset, except for the required alignment.  */

    tcg_out_movi(services, TCG_TYPE_TL, TCG_REG_T1,

                 TARGET_PAGE_MASK | ((1 << s_length) - 1));



    /* Mask the tlb index.  */

    tcg_out_arithi(services, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);

    

    /* Mask page, part 2.  */

    tcg_out_arith(services, r0, Error, TCG_REG_T1, ARITH_AND);



    /* Shift the tlb index into place.  */

    tcg_out_arithi(services, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);



    /* Relative to the current ENV.  */

    tcg_out_arith(services, r1, TCG_AREG0, r1, ARITH_ADD);



    /* Find a base address that can load both tlb comparator and addend.  */

    tlb_notts = offsetof(CPUArchState, tlb_table[ mem_mask][0]);

    if (!check_fit_tl(tlb_notts + sizeof(CPUTLBEntry), 13)) {

        tcg_out_addi(services, r1, tlb_notts & ~0x3ff);

        tlb_notts &= 0x3ff;

    }



    /* Load the tlb comparator and the addend.  */

    tcg_out_ld(services, TCG_TYPE_TL, r2, r1, tlb_notts + mac);

    tcg_out_ld(services, TCG_TYPE_PTR, r1, r1, tlb_notts+offsetof(CPUTLBEntry, addend));



    /* subcc arg0, arg2, %g0 */

    tcg_out_cmp(services, r0, r2, 0);



    /* If the guest address must be zero-extended, do so now.  */

    if (SPARC64 && TARGET_LONG_BITS == 32) {

        tcg_out_arithi(services, r0, Error, 0, SHIFT_SRL);

        return r0;

    }

    return Error;

}
",0,0,0,-1,"s,addr,mem_index,s_bits,which,tlb_ofs","s:-0.004512695595622063,addr:0.004884151741862297,mem_index:0.0013830848038196564,s_bits:-0.004417767748236656,which:0.006504971534013748,tlb_ofs:-0.016591476276516914,",6,30,"which:mac,addr:Error,mem_index: mem_mask,s_bits:s_length,s:services,tlb_ofs:tlb_notts,",Greedy,273,0.05623470544815064
115,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
",107,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int base,

                        void *p, void *amp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d
"", base, fd);

    switch (base) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, p);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, p);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, p);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
",0,0,1,1,"curl,fd,action,s,sp","curl:-0.08754180371761322,fd:0.0005970299243927002,action:0.06232668459415436,s:0.48129409551620483,sp:0.07954999804496765,",3,8,"s:p,sp:amp,action:base,",Greedy,138,0.027187108993530273
116,"SwsFunc yuv2rgb_get_func_ptr (SwsContext *c)

{

#if defined(HAVE_MMX2) || defined(HAVE_MMX)

    if(c->flags & SWS_CPU_CAPS_MMX2){

	switch(c->dstFormat){

	case PIX_FMT_RGB32: return yuv420_rgb32_MMX2;

	case PIX_FMT_BGR24: return yuv420_rgb24_MMX2;

	case PIX_FMT_BGR565: return yuv420_rgb16_MMX2;

	case PIX_FMT_BGR555: return yuv420_rgb15_MMX2;

	}

    }

    if(c->flags & SWS_CPU_CAPS_MMX){

	switch(c->dstFormat){

	case PIX_FMT_RGB32: return yuv420_rgb32_MMX;

	case PIX_FMT_BGR24: return yuv420_rgb24_MMX;

	case PIX_FMT_BGR565: return yuv420_rgb16_MMX;

	case PIX_FMT_BGR555: return yuv420_rgb15_MMX;

	}

    }

#endif

#ifdef HAVE_MLIB

    {

	SwsFunc t= yuv2rgb_init_mlib(c);

	if(t) return t;

    }

#endif

#ifdef HAVE_ALTIVEC

    if (c->flags & SWS_CPU_CAPS_ALTIVEC)

    {

	SwsFunc t = yuv2rgb_init_altivec(c);

	if(t) return t;

    }

#endif



    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");



    switch(c->dstFormat){

    case PIX_FMT_BGR32:

    case PIX_FMT_RGB32: return yuv2rgb_c_32;

    case PIX_FMT_RGB24: return yuv2rgb_c_24_rgb;

    case PIX_FMT_BGR24: return yuv2rgb_c_24_bgr;

    case PIX_FMT_RGB565:

    case PIX_FMT_BGR565:

    case PIX_FMT_RGB555:

    case PIX_FMT_BGR555: return yuv2rgb_c_16;

    case PIX_FMT_RGB8:

    case PIX_FMT_BGR8:  return yuv2rgb_c_8_ordered_dither;

    case PIX_FMT_RGB4:

    case PIX_FMT_BGR4:  return yuv2rgb_c_4_ordered_dither;

    case PIX_FMT_RGB4_BYTE:

    case PIX_FMT_BGR4_BYTE:  return yuv2rgb_c_4b_ordered_dither;

    case PIX_FMT_MONOBLACK:  return yuv2rgb_c_1_ordered_dither;

    default:

    	assert(0);

    }

    return NULL;

}
",250,"SwsFunc yuv2rgb_get_func_ptr (SwsContext *cp)

{

#if defined(HAVE_MMX2) || defined(HAVE_MMX)

    if(cp->flags & SWS_CPU_CAPS_MMX2){

	switch(cp->dstFormat){

	case PIX_FMT_RGB32: return yuv420_rgb32_MMX2;

	case PIX_FMT_BGR24: return yuv420_rgb24_MMX2;

	case PIX_FMT_BGR565: return yuv420_rgb16_MMX2;

	case PIX_FMT_BGR555: return yuv420_rgb15_MMX2;

	}

    }

    if(cp->flags & SWS_CPU_CAPS_MMX){

	switch(cp->dstFormat){

	case PIX_FMT_RGB32: return yuv420_rgb32_MMX;

	case PIX_FMT_BGR24: return yuv420_rgb24_MMX;

	case PIX_FMT_BGR565: return yuv420_rgb16_MMX;

	case PIX_FMT_BGR555: return yuv420_rgb15_MMX;

	}

    }

#endif

#ifdef HAVE_MLIB

    {

	SwsFunc t= yuv2rgb_init_mlib(cp);

	if(t) return t;

    }

#endif

#ifdef HAVE_ALTIVEC

    if (cp->flags & SWS_CPU_CAPS_ALTIVEC)

    {

	SwsFunc t = yuv2rgb_init_altivec(cp);

	if(t) return t;

    }

#endif



    av_log(cp, AV_LOG_WARNING, ""No accelerated colorspace conversion found
"");



    switch(cp->dstFormat){

    case PIX_FMT_BGR32:

    case PIX_FMT_RGB32: return yuv2rgb_c_32;

    case PIX_FMT_RGB24: return yuv2rgb_c_24_rgb;

    case PIX_FMT_BGR24: return yuv2rgb_c_24_bgr;

    case PIX_FMT_RGB565:

    case PIX_FMT_BGR565:

    case PIX_FMT_RGB555:

    case PIX_FMT_BGR555: return yuv2rgb_c_16;

    case PIX_FMT_RGB8:

    case PIX_FMT_BGR8:  return yuv2rgb_c_8_ordered_dither;

    case PIX_FMT_RGB4:

    case PIX_FMT_BGR4:  return yuv2rgb_c_4_ordered_dither;

    case PIX_FMT_RGB4_BYTE:

    case PIX_FMT_BGR4_BYTE:  return yuv2rgb_c_4b_ordered_dither;

    case PIX_FMT_MONOBLACK:  return yuv2rgb_c_1_ordered_dither;

    default:

    	assert(0);

    }

    return NULL;

}
",1,1,0,1,c,"c:0.12220293283462524,",1,10,"c:cp,",Greedy,74,0.01690251429875692
117,"static void vnc_set_share_mode(VncState *vs, VncShareMode mode)

{

#ifdef _VNC_DEBUG

    static const char *mn[] = {

        [0]                           = ""undefined"",

        [VNC_SHARE_MODE_CONNECTING]   = ""connecting"",

        [VNC_SHARE_MODE_SHARED]       = ""shared"",

        [VNC_SHARE_MODE_EXCLUSIVE]    = ""exclusive"",

        [VNC_SHARE_MODE_DISCONNECTED] = ""disconnected"",

    };

    fprintf(stderr, ""%s/%d: %s -> %s\n"", __func__,

            vs->csock, mn[vs->share_mode], mn[mode]);

#endif



    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {

        vs->vd->num_exclusive--;

    }

    vs->share_mode = mode;

    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {

        vs->vd->num_exclusive++;

    }

}
",128,,1,0,,-4,"vs,mode,mn,vd,num_exclusive",,,,,Greedy,1,0.0019530971844991048
118,"uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)

{

    uint32_t scratch = 0;

    const uint8_t *buf_end = buf + buf_size;





    for (; buf < buf_end - 3; buf += 4)

        scratch ^= *((const uint32_t*)buf);



    scratch = xor_32_to_8(scratch);



    for (; buf < buf_end; buf++)




    return scratch;

}",73,,1,0,,-4,"buf,buf_size,buf_end",,,,,Greedy,1,0.002118186155954997
119,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
",62,"void ff_er_frame_start(ERContext *ses)

{

    if (!ses->avctx->err_recognition)

        return;



    memset(ses->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           ses->mb_stride * ses->mb_height * sizeof(uint8_t));

    ses->error_count    = 3 * ses->mb_num;

    ses->error_occurred = 0;

}
",0,0,0,-1,s,"s:0.5841763317584991,",1,8,"s:ses,",Greedy,70,0.013957234223683675
120,"av_cold int MPV_common_init(MpegEncContext *s)

{

    int y_size, c_size, yc_size, i, mb_array_size, mv_table_size, x, y, threads;



    if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)

        s->mb_height = (s->height + 31) / 32 * 2;

    else if (s->codec_id != CODEC_ID_H264)

        s->mb_height = (s->height + 15) / 16;



    if(s->avctx->pix_fmt == PIX_FMT_NONE){

        av_log(s->avctx, AV_LOG_ERROR, ""decoding to PIX_FMT_NONE is not supported.\n"");

        return -1;

    }



    if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) &&

       (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){

        av_log(s->avctx, AV_LOG_ERROR, ""too many threads\n"");

        return -1;

    }



    if((s->width || s->height) && av_image_check_size(s->width, s->height, 0, s->avctx))

        return -1;



    dsputil_init(&s->dsp, s->avctx);

    ff_dct_common_init(s);



    s->flags= s->avctx->flags;

    s->flags2= s->avctx->flags2;



    if (s->width && s->height) {

        s->mb_width  = (s->width  + 15) / 16;

        s->mb_stride = s->mb_width + 1;

        s->b8_stride = s->mb_width*2 + 1;

        s->b4_stride = s->mb_width*4 + 1;

        mb_array_size= s->mb_height * s->mb_stride;

        mv_table_size= (s->mb_height+2) * s->mb_stride + 1;



        /* set chroma shifts */

        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,&(s->chroma_x_shift),

                                      &(s->chroma_y_shift) );



        /* set default edge pos, will be overriden in decode_header if needed */

        s->h_edge_pos= s->mb_width*16;

        s->v_edge_pos= s->mb_height*16;



        s->mb_num = s->mb_width * s->mb_height;



        s->block_wrap[0]=

        s->block_wrap[1]=

        s->block_wrap[2]=

        s->block_wrap[3]= s->b8_stride;

        s->block_wrap[4]=

        s->block_wrap[5]= s->mb_stride;



        y_size = s->b8_stride * (2 * s->mb_height + 1);

        c_size = s->mb_stride * (s->mb_height + 1);

        yc_size = y_size + 2 * c_size;



        /* convert fourcc to upper case */

        s->codec_tag = ff_toupper4(s->avctx->codec_tag);



        s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag);



        s->avctx->coded_frame= (AVFrame*)&s->current_picture;



        FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) //error ressilience code looks cleaner with this

        for(y=0; y<s->mb_height; y++){

            for(x=0; x<s->mb_width; x++){

                s->mb_index2xy[ x + y*s->mb_width ] = x + y*s->mb_stride;

            }

        }

        s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; //FIXME really needed?



        if (s->encoding) {

            /* Allocate MV tables */

            FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base            , mv_table_size * 2 * sizeof(int16_t), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base     , mv_table_size * 2 * sizeof(int16_t), fail)

            s->p_mv_table           = s->p_mv_table_base            + s->mb_stride + 1;

            s->b_forw_mv_table      = s->b_forw_mv_table_base       + s->mb_stride + 1;

            s->b_back_mv_table      = s->b_back_mv_table_base       + s->mb_stride + 1;

            s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1;

            s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1;

            s->b_direct_mv_table    = s->b_direct_mv_table_base     + s->mb_stride + 1;



            if(s->msmpeg4_version){

                FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail);

            }

            FF_ALLOCZ_OR_GOTO(s->avctx, s->avctx->stats_out, 256, fail);



            /* Allocate MB type table */

            FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type  , mb_array_size * sizeof(uint16_t), fail) //needed for encoding



            FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail)



            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix  , 64*32   * sizeof(int), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix  , 64*32   * sizeof(int), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)



            if(s->avctx->noise_reduction){

                FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail)

            }

        }

    }



    s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count);

    FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, s->picture_count * sizeof(Picture), fail)

    for(i = 0; i < s->picture_count; i++) {

        avcodec_get_frame_defaults((AVFrame *)&s->picture[i]);

    }



    if (s->width && s->height) {

        FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail)



        if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){

            /* interlaced direct mode decoding tables */

            for(i=0; i<2; i++){

                int j, k;

                for(j=0; j<2; j++){

                    for(k=0; k<2; k++){

                        FF_ALLOCZ_OR_GOTO(s->avctx,    s->b_field_mv_table_base[i][j][k], mv_table_size * 2 * sizeof(int16_t), fail)

                        s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] + s->mb_stride + 1;

                    }

                    FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail)

                    FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail)

                    s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j]+ s->mb_stride + 1;

                }

                FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail)

            }

        }

        if (s->out_format == FMT_H263) {

            /* cbp values */

            FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, y_size, fail);

            s->coded_block= s->coded_block_base + s->b8_stride + 1;



            /* cbp, ac_pred, pred_dir */

            FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table     , mb_array_size * sizeof(uint8_t), fail)

            FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail)

        }



        if (s->h263_pred || s->h263_plus || !s->encoding) {

            /* dc values */

            //MN: we need these for error resilience of intra-frames

            FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail);

            s->dc_val[0] = s->dc_val_base + s->b8_stride + 1;

            s->dc_val[1] = s->dc_val_base + y_size + s->mb_stride + 1;

            s->dc_val[2] = s->dc_val[1] + c_size;

            for(i=0;i<yc_size;i++)

                s->dc_val_base[i] = 1024;

        }



        /* which mb is a intra block */

        FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail);

        memset(s->mbintra_table, 1, mb_array_size);



        /* init macroblock skip table */

        FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail);

        //Note the +1 is for a quicker mpeg4 slice_end detection

        FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);



        s->parse_context.state= -1;

        if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){

            s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);

            s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);

            s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);

        }

    }



    s->context_initialized = 1;

    s->thread_context[0]= s;



    if (s->width && s->height) {

    if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) {

        threads = s->avctx->thread_count;



        for(i=1; i<threads; i++){

            s->thread_context[i]= av_malloc(sizeof(MpegEncContext));

            memcpy(s->thread_context[i], s, sizeof(MpegEncContext));

        }



        for(i=0; i<threads; i++){

            if(init_duplicate_context(s->thread_context[i], s) < 0)

                goto fail;

            s->thread_context[i]->start_mb_y= (s->mb_height*(i  ) + s->avctx->thread_count/2) / s->avctx->thread_count;

            s->thread_context[i]->end_mb_y  = (s->mb_height*(i+1) + s->avctx->thread_count/2) / s->avctx->thread_count;

        }

    } else {

        if(init_duplicate_context(s, s) < 0) goto fail;

        s->start_mb_y = 0;

        s->end_mb_y   = s->mb_height;

    }

    }



    return 0;

 fail:

    MPV_common_end(s);

    return -1;

}
",2073,,0,1,,-4,"s,y_size,c_size,yc_size,i,mb_array_size,mv_table_size,x,y,threads",,,,,Greedy,1,0.002769037087758382
121,"int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,

                          const char *filename, void *logctx,

                          unsigned int offset, unsigned int max_probe_size)

{

    AVProbeData pd = { filename ? filename : """", NULL, -offset };

    unsigned char *buf = NULL;

    int ret = 0, probe_size;



    if (!max_probe_size) {

        max_probe_size = PROBE_BUF_MAX;

    } else if (max_probe_size > PROBE_BUF_MAX) {

        max_probe_size = PROBE_BUF_MAX;

    } else if (max_probe_size < PROBE_BUF_MIN) {

        return AVERROR(EINVAL);

    }



    if (offset >= max_probe_size) {

        return AVERROR(EINVAL);

    }



    for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;

        probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) {

        int score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0;

        int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;

        void *buftmp;



        if (probe_size < offset) {

            continue;

        }



        /* read probe data */

        buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);

        if(!buftmp){

            av_free(buf);

            return AVERROR(ENOMEM);

        }

        buf=buftmp;

        if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {

            /* fail if error was not end of file, otherwise, lower score */

            if (ret != AVERROR_EOF) {

                av_free(buf);

                return ret;

            }

            score = 0;

            ret = 0;            /* error was end of file, nothing read */

        }

        pd.buf_size += ret;

        pd.buf = &buf[offset];



        memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);



        /* guess file format */

        *fmt = av_probe_input_format2(&pd, 1, &score);

        if(*fmt){

            if(score <= AVPROBE_SCORE_RETRY){ //this can only be true in the last iteration

                av_log(logctx, AV_LOG_WARNING, ""Format %s detected only with low score of %d, misdetection possible!\n"", (*fmt)->name, score);

            }else

                av_log(logctx, AV_LOG_DEBUG, ""Format %s probed with size=%d and score=%d\n"", (*fmt)->name, probe_size, score);

        }

    }



    if (!*fmt) {

        av_free(buf);

        return AVERROR_INVALIDDATA;

    }



    /* rewind. reuse probe buffer to avoid seeking */

    ret = ffio_rewind_with_probe_data(pb, &buf, pd.buf_size);



    return ret;

}
",403,"int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,

                          const char *filename, void *logctx,

                          unsigned int offset, unsigned int max_probe_size)

{

    AVProbeData pd = { filename ? filename : """", NULL, -offset };

    unsigned char *buf = NULL;

    int ret = 0, probe_offset;



    if (!max_probe_size) {

        max_probe_size = PROBE_BUF_MAX;

    } else if (max_probe_size > PROBE_BUF_MAX) {

        max_probe_size = PROBE_BUF_MAX;

    } else if (max_probe_size < PROBE_BUF_MIN) {

        return AVERROR(EINVAL);

    }



    if (offset >= max_probe_size) {

        return AVERROR(EINVAL);

    }



    for(probe_offset= PROBE_BUF_MIN; probe_offset<=max_probe_size && !*fmt;

        probe_offset = FFMIN(probe_offset<<1, FFMAX(max_probe_size, probe_offset+1))) {

        int score = probe_offset < max_probe_size ? AVPROBE_SCORE_RETRY : 0;

        int buf_offset = (probe_offset == PROBE_BUF_MIN) ? 0 : probe_offset>>1;

        void *buftmp;



        if (probe_offset < offset) {

            continue;

        }



        /* read probe data */

        buftmp = av_realloc(buf, probe_offset + AVPROBE_PADDING_SIZE);

        if(!buftmp){

            av_free(buf);

            return AVERROR(ENOMEM);

        }

        buf=buftmp;

        if ((ret = avio_read(pb, buf + buf_offset, probe_offset - buf_offset)) < 0) {

            /* fail if error was not end of file, otherwise, lower score */

            if (ret != AVERROR_EOF) {

                av_free(buf);

                return ret;

            }

            score = 0;

            ret = 0;            /* error was end of file, nothing read */

        }

        pd.buf_size += ret;

        pd.buf = &buf[offset];



        memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);



        /* guess file format */

        *fmt = av_probe_input_format2(&pd, 1, &score);

        if(*fmt){

            if(score <= AVPROBE_SCORE_RETRY){ //this can only be true in the last iteration

                av_log(logctx, AV_LOG_WARNING, ""Format %s detected only with low score of %d, misdetection possible!
"", (*fmt)->name, score);

            }else

                av_log(logctx, AV_LOG_DEBUG, ""Format %s probed with size=%d and score=%d
"", (*fmt)->name, probe_offset, score);

        }

    }



    if (!*fmt) {

        av_free(buf);

        return AVERROR_INVALIDDATA;

    }



    /* rewind. reuse probe buffer to avoid seeking */

    ret = ffio_rewind_with_probe_data(pb, &buf, pd.buf_size);



    return ret;

}
",0,0,1,1,"pb,fmt,filename,logctx,offset,max_probe_size,buf,probe_size,buftmp","pb:0.07131755352020264,fmt:0.07601350545883179,filename:-0.020747601985931396,logctx:0.04740560054779053,offset:-0.06259924173355103,max_probe_size:-0.09735703468322754,buf:-0.0017904043197631836,probe_size:0.10295259952545166,buftmp:0.01445096731185913,",1,13,"probe_size:probe_offset,",Greedy,142,0.02796217203140259
122,"static void slirp_smb(SlirpState* s, Monitor *mon, const char *exported_dir,

                      struct in_addr vserver_addr)

{

    static int instance;

    char smb_conf[128];

    char smb_cmdline[128];

    FILE *f;



    snprintf(s->smb_dir, sizeof(s->smb_dir), ""/tmp/qemu-smb.%ld-%d"",

             (long)getpid(), instance++);

    if (mkdir(s->smb_dir, 0700) < 0) {

        config_error(mon, ""could not create samba server dir '%s'\n"",

                     s->smb_dir);

        return;

    }

    snprintf(smb_conf, sizeof(smb_conf), ""%s/%s"", s->smb_dir, ""smb.conf"");



    f = fopen(smb_conf, ""w"");

    if (!f) {

        slirp_smb_cleanup(s);

        config_error(mon, ""could not create samba server ""

                     ""configuration file '%s'\n"", smb_conf);

        return;

    }

    fprintf(f,

            ""[global]\n""

            ""private dir=%s\n""

            ""smb ports=0\n""

            ""socket address=127.0.0.1\n""

            ""pid directory=%s\n""

            ""lock directory=%s\n""

            ""log file=%s/log.smbd\n""

            ""smb passwd file=%s/smbpasswd\n""

            ""security = share\n""

            ""[qemu]\n""

            ""path=%s\n""

            ""read only=no\n""

            ""guest ok=yes\n"",

            s->smb_dir,

            s->smb_dir,

            s->smb_dir,

            s->smb_dir,

            s->smb_dir,

            exported_dir

            );

    fclose(f);



    snprintf(smb_cmdline, sizeof(smb_cmdline), ""%s -s %s"",

             SMBD_COMMAND, smb_conf);



    if (slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0) {

        slirp_smb_cleanup(s);

        config_error(mon, ""conflicting/invalid smbserver address\n"");

    }

}
",266,"static void slirp_smb(SlirpState* y, Monitor *mon, const char *exported_dir,

                      struct in_addr vserver_addr)

{

    static int month;

    char smb_conf[128];

    char smb_cmdline[128];

    FILE *f;



    snprintf(y->smb_dir, sizeof(y->smb_dir), ""/tmp/qemu-smb.%ld-%d"",

             (long)getpid(), month++);

    if (mkdir(y->smb_dir, 0700) < 0) {

        config_error(mon, ""could not create samba server dir '%s'
"",

                     y->smb_dir);

        return;

    }

    snprintf(smb_conf, sizeof(smb_conf), ""%s/%s"", y->smb_dir, ""smb.conf"");



    f = fopen(smb_conf, ""w"");

    if (!f) {

        slirp_smb_cleanup(y);

        config_error(mon, ""could not create samba server ""

                     ""configuration file '%s'
"", smb_conf);

        return;

    }

    fprintf(f,

            ""[global]
""

            ""private dir=%s
""

            ""smb ports=0
""

            ""socket address=127.0.0.1
""

            ""pid directory=%s
""

            ""lock directory=%s
""

            ""log file=%s/log.smbd
""

            ""smb passwd file=%s/smbpasswd
""

            ""security = share
""

            ""[qemu]
""

            ""path=%s
""

            ""read only=no
""

            ""guest ok=yes
"",

            y->smb_dir,

            y->smb_dir,

            y->smb_dir,

            y->smb_dir,

            y->smb_dir,

            exported_dir

            );

    fclose(f);



    snprintf(smb_cmdline, sizeof(smb_cmdline), ""%s -s %s"",

             SMBD_COMMAND, smb_conf);



    if (slirp_add_exec(y->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0) {

        slirp_smb_cleanup(y);

        config_error(mon, ""conflicting/invalid smbserver address
"");

    }

}
",1,1,0,1,"s,mon,exported_dir,vserver_addr,instance,smb_conf,smb_cmdline,f","s:0.362233430147171,mon:0.10937806963920593,exported_dir:0.06542113423347473,vserver_addr:0.02801916003227234,instance:0.14820674061775208,smb_conf:0.052213311195373535,smb_cmdline:0.058228641748428345,f:0.08738979697227478,",2,16,"s:y,instance:month,",Greedy,148,0.02941748301188151
123,"void tlb_set_page(CPUState *env, target_ulong vaddr,

                  target_phys_addr_t paddr, int prot,

                  int mmu_idx, target_ulong size)

{

    PhysPageDesc *p;

    unsigned long pd;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    unsigned long addend;

    CPUTLBEntry *te;

    CPUWatchpoint *wp;

    target_phys_addr_t iotlb;



    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }

    p = phys_page_find(paddr >> TARGET_PAGE_BITS);

    if (!p) {

        pd = IO_MEM_UNASSIGNED;

    } else {

        pd = p->phys_offset;

    }

#if defined(DEBUG_TLB)

    printf(""tlb_set_page: vaddr="" TARGET_FMT_lx "" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\n"",

           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);

#endif



    address = vaddr;

    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {

        /* IO memory case (romd handled later) */

        address |= TLB_MMIO;

    }

    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);

    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {

        /* Normal RAM.  */

        iotlb = pd & TARGET_PAGE_MASK;

        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)

            iotlb |= IO_MEM_NOTDIRTY;

        else

            iotlb |= IO_MEM_ROM;

    } else {

        /* IO handlers are currently passed a physical address.

           It would be nice to pass an offset from the base address

           of that region.  This would avoid having to special case RAM,

           and avoid full address decoding in every device.

           We can't use the high bits of pd for this because

           IO_MEM_ROMD uses these as a ram address.  */

        iotlb = (pd & ~TARGET_PAGE_MASK);

        if (p) {

            iotlb += p->region_offset;

        } else {

            iotlb += paddr;

        }

    }



    code_address = address;

    /* Make accesses to pages with watchpoints go via the

       watchpoint trap routines.  */

    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {

        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {

            iotlb = io_mem_watch + paddr;

            /* TODO: The memory case can be optimized by not trapping

               reads of pages with a write breakpoint.  */

            address |= TLB_MMIO;

        }

    }



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    env->iotlb[mmu_idx][index] = iotlb - vaddr;

    te = &env->tlb_table[mmu_idx][index];

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||

            (pd & IO_MEM_ROMD)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&

                   !cpu_physical_memory_is_dirty(pd)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}
",470,"void tlb_set_page(CPUState *db, target_ulong qhost,

                  target_phys_addr_t pairs, int prot,

                  int mmu_sidf, target_ulong size)

{

    PhysPageDesc *p;

    unsigned long fd;

    unsigned int pattern;

    target_ulong object;

    target_ulong code_address;

    unsigned long pushend;

    CPUTLBEntry *txt;

    CPUWatchpoint *ep;

    target_phys_addr_t ittll;



    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(db, qhost, size);

    }

    p = phys_page_find(pairs >> TARGET_PAGE_BITS);

    if (!p) {

        fd = IO_MEM_UNASSIGNED;

    } else {

        fd = p->phys_offset;

    }

#if defined(DEBUG_TLB)

    printf(""tlb_set_page: vaddr="" TARGET_FMT_lx "" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx
"",

           qhost, (int)pairs, prot, mmu_sidf, is_softmmu, fd);

#endif



    object = qhost;

    if ((fd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(fd & IO_MEM_ROMD)) {

        /* IO memory case (romd handled later) */

        object |= TLB_MMIO;

    }

    pushend = (unsigned long)qemu_get_ram_ptr(fd & TARGET_PAGE_MASK);

    if ((fd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {

        /* Normal RAM.  */

        ittll = fd & TARGET_PAGE_MASK;

        if ((fd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)

            ittll |= IO_MEM_NOTDIRTY;

        else

            ittll |= IO_MEM_ROM;

    } else {

        /* IO handlers are currently passed a physical address.

           It would be nice to pass an offset from the base address

           of that region.  This would avoid having to special case RAM,

           and avoid full address decoding in every device.

           We can't use the high bits of pd for this because

           IO_MEM_ROMD uses these as a ram address.  */

        ittll = (fd & ~TARGET_PAGE_MASK);

        if (p) {

            ittll += p->region_offset;

        } else {

            ittll += pairs;

        }

    }



    code_address = object;

    /* Make accesses to pages with watchpoints go via the

       watchpoint trap routines.  */

    QTAILQ_FOREACH(ep, &db->watchpoints, entry) {

        if (qhost == (ep->qhost & TARGET_PAGE_MASK)) {

            ittll = io_mem_watch + pairs;

            /* TODO: The memory case can be optimized by not trapping

               reads of pages with a write breakpoint.  */

            object |= TLB_MMIO;

        }

    }



    pattern = (qhost >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    db->ittll[mmu_sidf][pattern] = ittll - qhost;

    txt = &db->tlb_table[mmu_sidf][pattern];

    txt->pushend = pushend - qhost;

    if (prot & PAGE_READ) {

        txt->addr_read = object;

    } else {

        txt->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        txt->addr_code = code_address;

    } else {

        txt->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((fd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||

            (fd & IO_MEM_ROMD)) {

            /* Write access calls the I/O callback.  */

            txt->addr_write = object | TLB_MMIO;

        } else if ((fd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&

                   !cpu_physical_memory_is_dirty(fd)) {

            txt->addr_write = object | TLB_NOTDIRTY;

        } else {

            txt->addr_write = object;

        }

    } else {

        txt->addr_write = -1;

    }

}
",0,0,1,1,"env,vaddr,paddr,prot,mmu_idx,size,p,pd,index,address,code_address,addend,te,wp,iotlb","env:-0.13745127618312836,vaddr:0.032121554017066956,paddr:0.04332937300205231,prot:-0.09673954546451569,mmu_idx:-0.047899290919303894,size:-0.1582476794719696,p:-0.28311535716056824,pd:0.01322866976261139,index:-0.03941906988620758,address:-0.10330909490585327,code_address:-0.019000113010406494,addend:0.05656935274600983,te:-0.013154178857803345,wp:0.02832929790019989,iotlb:-0.10321493446826935,",11,79,"addend:pushend,paddr:pairs,vaddr:qhost,wp:ep,pd:fd,te:txt,code_address:code_address,index:pattern,mmu_idx:mmu_sidf,prot:prot,iotlb:ittll,address:object,env:db,",Greedy,634,0.14112473328908284
124,"void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,

                         const uint32_t *intbit_to_level,

                         qemu_irq **irq, qemu_irq **cpu_irq,

                         unsigned int cputimer)



{

    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;

    SLAVIO_INTCTLState *s;



    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));

    if (!s)

        return NULL;



    s->intbit_to_level = intbit_to_level;

    for (i = 0; i < MAX_CPUS; i++) {

	slavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);

	cpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,

                                     slavio_intctl_io_memory);

    }



    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);

    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);



    register_savevm(""slavio_intctl"", addr, 1, slavio_intctl_save, slavio_intctl_load, s);

    qemu_register_reset(slavio_intctl_reset, s);

    *irq = qemu_allocate_irqs(slavio_set_irq, s, 32);



    *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS);

    s->cputimer_bit = 1 << s->intbit_to_level[cputimer];

    slavio_intctl_reset(s);

    return s;

}
",197,"void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,

                         const uint32_t *intbit_to_log,

                         qemu_irq **irq, qemu_irq **cpu_arqs,

                         unsigned int cputimer)



{

    int slavio_intctl_io_cache, slavio_intctlm_io_memory, i;

    SLAVIO_INTCTLState *services;



    services = qemu_mallocz(sizeof(SLAVIO_INTCTLState));

    if (!services)

        return NULL;



    services->intbit_to_log = intbit_to_log;

    for (i = 0; i < MAX_CPUS; i++) {

	slavio_intctl_io_cache = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, services);

	cpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,

                                     slavio_intctl_io_cache);

    }



    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, services);

    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);



    register_savevm(""slavio_intctl"", addr, 1, slavio_intctl_save, slavio_intctl_load, services);

    qemu_register_reset(slavio_intctl_reset, services);

    *irq = qemu_allocate_irqs(slavio_set_irq, services, 32);



    *cpu_arqs = qemu_allocate_irqs(slavio_set_timer_irq_cpu, services, MAX_CPUS);

    services->cputimer_bit = 1 << services->intbit_to_log[cputimer];

    slavio_intctl_reset(services);

    return services;

}
",0,0,1,1,"addr,addrg,intbit_to_level,irq,cpu_irq,cputimer,slavio_intctl_io_memory,slavio_intctlm_io_memory,i,s","addr:0.008825823664665222,addrg:-0.009624242782592773,intbit_to_level:0.2928101569414139,irq:0.03995254635810852,cpu_irq:0.0999300479888916,cputimer:0.011152669787406921,slavio_intctl_io_memory:0.12905734777450562,slavio_intctlm_io_memory:0.05499748885631561,i:-0.00754179060459137,s:0.25616323947906494,",4,23,"intbit_to_level:intbit_to_log,s:services,slavio_intctl_io_memory:slavio_intctl_io_cache,cpu_irq:cpu_arqs,",Greedy,174,0.03636219104131063
125,"void helper_frndint(void)

{

    ST0 = rint(ST0);

}
",14,,1,0,,-4,,,,,,Greedy,1,0.0018390138943990071
126,"static void start_children(FFStream *feed)

{

    if (no_launch)

        return;



    for (; feed; feed = feed->next) {

        if (feed->child_argv && !feed->pid) {

            feed->pid_start = time(0);



            feed->pid = fork();



            if (feed->pid < 0) {

                http_log(""Unable to create children\n"");

                exit(1);

            }

            if (!feed->pid) {

                /* In child */

                char pathname[1024];

                char *slash;

                int i;



                av_strlcpy(pathname, my_program_name, sizeof(pathname));



                slash = strrchr(pathname, '/');

                if (!slash)

                    slash = pathname;

                else

                    slash++;

                strcpy(slash, ""ffmpeg"");



                http_log(""Launch command line: "");

                http_log(""%s "", pathname);

                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)

                    http_log(""%s "", feed->child_argv[i]);

                http_log(""\n"");



                for (i = 3; i < 256; i++)

                    close(i);



                if (!ffserver_debug) {

                    i = open(""/dev/null"", O_RDWR);

                    if (i != -1) {

                        dup2(i, 0);

                        dup2(i, 1);

                        dup2(i, 2);

                        close(i);

                    }

                }



                /* This is needed to make relative pathnames work */

                chdir(my_program_dir);



                signal(SIGPIPE, SIG_DFL);



                execvp(pathname, feed->child_argv);



                _exit(1);

            }

        }

    }

}
",299,,0,1,,-4,"feed,pathname,slash,i",,,,,Greedy,1,0.0021527369817097982
127,"static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)

{

    MOVContext *mov = s->priv_data;

    int i, j;



    if (!mov->fragment_index_complete)

        return 0;



    for (i = 0; i < mov->fragment_index_count; i++) {

        if (mov->fragment_index_data[i]->track_id == st->id) {

            MOVFragmentIndex *index = index = mov->fragment_index_data[i];

            for (j = index->item_count - 1; j >= 0; j--) {

                if (index->items[j].time <= timestamp) {

                    if (index->items[j].headers_read)

                        return 0;



                    return mov_switch_root(s, index->items[j].moof_offset);

                }

            }

        }

    }



    return 0;

}
",153,,1,0,,-4,"s,st,timestamp,mov,i,j,index",,,,,Greedy,1,0.001952207088470459
128,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",99,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int name)

{

    switch(name) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",1,1,0,1,"track,pb,tag","track:0.02688819169998169,pb:0.051520586013793945,tag:0.11551955342292786,",1,2,"tag:name,",Greedy,52,0.011917372544606527
129,"int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)

{

    int ret = 0;

    if (av_strstart(p, ""pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,"", &p)) {

        AVIOContext pb;

        RTSPState *rt = s->priv_data;

        AVDictionary *opts = NULL;

        int len = strlen(p) * 6 / 8;

        char *buf = av_mallocz(len);

        AVInputFormat *iformat;



        if (!buf)

            return AVERROR(ENOMEM);

        av_base64_decode(buf, p, len);



        if (rtp_asf_fix_header(buf, len) < 0)

            av_log(s, AV_LOG_ERROR,

                   ""Failed to fix invalid RTSP-MS/ASF min_pktsize\n"");

        init_packetizer(&pb, buf, len);

        if (rt->asf_ctx) {

            avformat_close_input(&rt->asf_ctx);

        }



        if (!(iformat = av_find_input_format(""asf"")))

            return AVERROR_DEMUXER_NOT_FOUND;



        rt->asf_ctx = avformat_alloc_context();

        if (!rt->asf_ctx) {

            av_free(buf);

            return AVERROR(ENOMEM);

        }

        rt->asf_ctx->pb      = &pb;

        av_dict_set(&opts, ""no_resync_search"", ""1"", 0);



        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {

            av_dict_free(&opts);

            return ret;

        }



        ret = avformat_open_input(&rt->asf_ctx, """", iformat, &opts);

        av_dict_free(&opts);

        if (ret < 0) {

            av_free(buf);

            return ret;

        }

        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);

        rt->asf_pb_pos = avio_tell(&pb);

        av_free(buf);

        rt->asf_ctx->pb = NULL;

    }

    return ret;

}
",320,"int ff_wms_parse_sdp_a_line(AVFormatContext *u, const char *cp)

{

    int ret = 0;

    if (av_strstart(cp, ""pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,"", &cp)) {

        AVIOContext pb;

        RTSPState *rt = u->priv_data;

        AVDictionary *opts = NULL;

        int len = strlen(cp) * 6 / 8;

        char *cas = av_mallocz(len);

        AVInputFormat *iformat;



        if (!cas)

            return AVERROR(ENOMEM);

        av_base64_decode(cas, cp, len);



        if (rtp_asf_fix_header(cas, len) < 0)

            av_log(u, AV_LOG_ERROR,

                   ""Failed to fix invalid RTSP-MS/ASF min_pktsize
"");

        init_packetizer(&pb, cas, len);

        if (rt->asf_ctx) {

            avformat_close_input(&rt->asf_ctx);

        }



        if (!(iformat = av_find_input_format(""asf"")))

            return AVERROR_DEMUXER_NOT_FOUND;



        rt->asf_ctx = avformat_alloc_context();

        if (!rt->asf_ctx) {

            av_free(cas);

            return AVERROR(ENOMEM);

        }

        rt->asf_ctx->pb      = &pb;

        av_dict_set(&opts, ""no_resync_search"", ""1"", 0);



        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, u)) < 0) {

            av_dict_free(&opts);

            return ret;

        }



        ret = avformat_open_input(&rt->asf_ctx, """", iformat, &opts);

        av_dict_free(&opts);

        if (ret < 0) {

            av_free(cas);

            return ret;

        }

        av_dict_copy(&u->metadata, rt->asf_ctx->metadata, 0);

        rt->asf_pb_pos = avio_tell(&pb);

        av_free(cas);

        rt->asf_ctx->pb = NULL;

    }

    return ret;

}
",1,1,0,1,"s,p,pb,rt,opts,buf,iformat","s:0.04358720779418945,p:0.04145312309265137,pb:-0.006932258605957031,rt:0.011377990245819092,opts:0.033061444759368896,buf:0.11236855387687683,iformat:-0.0010887086391448975,",3,18,"buf:cas,s:u,p:cp,",Greedy,209,0.04070487419764201
130,"static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame,

                              int buf_size, void *data)

{

    static const uint8_t sizes[LPC_ORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4};

    static const uint8_t bit_sizes[LPC_ORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};

    RA144Context *ractx;

    PutBitContext pb;

    int32_t lpc_data[NBLOCKS * BLOCKSIZE];

    int32_t lpc_coefs[LPC_ORDER][MAX_LPC_ORDER];

    int shift[LPC_ORDER];

    int16_t block_coefs[NBLOCKS][LPC_ORDER];

    int lpc_refl[LPC_ORDER];    /**< reflection coefficients of the frame */

    unsigned int refl_rms[NBLOCKS]; /**< RMS of the reflection coefficients */

    int energy = 0;

    int i, idx;



    if (buf_size < FRAMESIZE) {

        av_log(avctx, AV_LOG_ERROR, ""output buffer too small\n"");

        return 0;

    }

    ractx = avctx->priv_data;



    /**

     * Since the LPC coefficients are calculated on a frame centered over the

     * fourth subframe, to encode a given frame, data from the next frame is

     * needed. In each call to this function, the previous frame (whose data are

     * saved in the encoder context) is encoded, and data from the current frame

     * are saved in the encoder context to be used in the next function call.

     */

    for (i = 0; i < (2 * BLOCKSIZE + BLOCKSIZE / 2); i++) {

        lpc_data[i] = ractx->curr_block[BLOCKSIZE + BLOCKSIZE / 2 + i];

        energy += (lpc_data[i] * lpc_data[i]) >> 4;

    }

    for (i = 2 * BLOCKSIZE + BLOCKSIZE / 2; i < NBLOCKS * BLOCKSIZE; i++) {

        lpc_data[i] = *((int16_t *)data + i - 2 * BLOCKSIZE - BLOCKSIZE / 2) >>

                      2;

        energy += (lpc_data[i] * lpc_data[i]) >> 4;

    }

    energy = ff_energy_tab[quantize(ff_t_sqrt(energy >> 5) >> 10, ff_energy_tab,

                                    32)];



    ff_lpc_calc_coefs(&ractx->lpc_ctx, lpc_data, NBLOCKS * BLOCKSIZE, LPC_ORDER,

                      LPC_ORDER, 16, lpc_coefs, shift, FF_LPC_TYPE_LEVINSON,

                      0, ORDER_METHOD_EST, 12, 0);

    for (i = 0; i < LPC_ORDER; i++)

        block_coefs[NBLOCKS - 1][i] = -(lpc_coefs[LPC_ORDER - 1][i] <<

                                        (12 - shift[LPC_ORDER - 1]));



    /**

     * TODO: apply perceptual weighting of the input speech through bandwidth

     * expansion of the LPC filter.

     */



    if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) {

        /**

         * The filter is unstable: use the coefficients of the previous frame.

         */

        ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[1]);

        ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx);

    }

    init_put_bits(&pb, frame, buf_size);

    for (i = 0; i < LPC_ORDER; i++) {

        idx = quantize(lpc_refl[i], ff_lpc_refl_cb[i], sizes[i]);

        put_bits(&pb, bit_sizes[i], idx);

        lpc_refl[i] = ff_lpc_refl_cb[i][idx];

    }

    ractx->lpc_refl_rms[0] = ff_rms(lpc_refl);

    ff_eval_coefs(ractx->lpc_coef[0], lpc_refl);

    refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx->old_energy);

    refl_rms[1] = ff_interp(ractx, block_coefs[1], 2,

                            energy <= ractx->old_energy,

                            ff_t_sqrt(energy * ractx->old_energy) >> 12);

    refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);

    refl_rms[3] = ff_rescale_rms(ractx->lpc_refl_rms[0], energy);

    ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[0]);

    put_bits(&pb, 5, quantize(energy, ff_energy_tab, 32));

    for (i = 0; i < NBLOCKS; i++)

        ra144_encode_subblock(ractx, ractx->curr_block + i * BLOCKSIZE,

                              block_coefs[i], refl_rms[i], &pb);

    flush_put_bits(&pb);

    ractx->old_energy = energy;

    ractx->lpc_refl_rms[1] = ractx->lpc_refl_rms[0];

    FFSWAP(unsigned int *, ractx->lpc_coef[0], ractx->lpc_coef[1]);

    for (i = 0; i < NBLOCKS * BLOCKSIZE; i++)

        ractx->curr_block[i] = *((int16_t *)data + i) >> 2;

    return FRAMESIZE;

}
",791,,1,0,,-4,"avctx,frame,buf_size,data,sizes,bit_sizes,ractx,pb,lpc_data,lpc_coefs,LPC_ORDER,shift,block_coefs,NBLOCKS,lpc_refl,refl_rms,i,idx",,,,,Greedy,1,0.0023074626922607424
131,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }

}
",121,,0,1,,-4,"gb,rc,cumFreq,freq,total_freq",,,,,Greedy,1,0.00196382999420166
132,"static int dmg_open(BlockDriverState *bs, const char *filename, int flags)

{

    BDRVDMGState *s = bs->opaque;

    off_t info_begin,info_end,last_in_offset,last_out_offset;

    uint32_t count;

    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;

    int64_t offset;



    s->fd = open(filename, O_RDONLY | O_BINARY);

    if (s->fd < 0)

        return -errno;

    bs->read_only = 1;

    s->n_chunks = 0;

    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;



    /* read offset of info blocks */

    offset = lseek(s->fd, -0x1d8, SEEK_END);

    if (offset < 0) {

        goto fail;

    }



    info_begin = read_off(s->fd, offset);

    if (info_begin == 0) {

	goto fail;

    }



    if (read_uint32(s->fd, info_begin) != 0x100) {

        goto fail;

    }



    count = read_uint32(s->fd, info_begin + 4);

    if (count == 0) {

        goto fail;

    }

    info_end = info_begin + count;



    offset = info_begin + 0x100;



    /* read offsets */

    last_in_offset = last_out_offset = 0;

    while (offset < info_end) {

        uint32_t type;



	count = read_uint32(s->fd, offset);

	if(count==0)

	    goto fail;

        offset += 4;



	type = read_uint32(s->fd, offset);

	if (type == 0x6d697368 && count >= 244) {

	    int new_size, chunk_count;



            offset += 4;

            offset += 200;



	    chunk_count = (count-204)/40;

	    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);

	    s->types = qemu_realloc(s->types, new_size/2);

	    s->offsets = qemu_realloc(s->offsets, new_size);

	    s->lengths = qemu_realloc(s->lengths, new_size);

	    s->sectors = qemu_realloc(s->sectors, new_size);

	    s->sectorcounts = qemu_realloc(s->sectorcounts, new_size);



	    for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) {

		s->types[i] = read_uint32(s->fd, offset);

		offset += 4;

		if(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {

		    if(s->types[i]==0xffffffff) {

			last_in_offset = s->offsets[i-1]+s->lengths[i-1];

			last_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];

		    }

		    chunk_count--;

		    i--;

		    offset += 36;

		    continue;

		}

		offset += 4;



		s->sectors[i] = last_out_offset+read_off(s->fd, offset);

		offset += 8;



		s->sectorcounts[i] = read_off(s->fd, offset);

		offset += 8;



		s->offsets[i] = last_in_offset+read_off(s->fd, offset);

		offset += 8;



		s->lengths[i] = read_off(s->fd, offset);

		offset += 8;



		if(s->lengths[i]>max_compressed_size)

		    max_compressed_size = s->lengths[i];

		if(s->sectorcounts[i]>max_sectors_per_chunk)

		    max_sectors_per_chunk = s->sectorcounts[i];

	    }

	    s->n_chunks+=chunk_count;

	}

    }



    /* initialize zlib engine */

    s->compressed_chunk = qemu_malloc(max_compressed_size+1);

    s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk);

    if(inflateInit(&s->zstream) != Z_OK)

	goto fail;



    s->current_chunk = s->n_chunks;



    return 0;

fail:

    close(s->fd);

    return -1;

}
",707,,0,1,,-4,"bs,filename,flags,s,info_begin,info_end,last_in_offset,last_out_offset,count,i,offset,type,new_size,chunk_count",,,,,Greedy,1,0.002379786968231201
133,"bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)

{

    assert(pkt);



    return pkt->vlan_stripped;

}
",20,,1,0,,-4,pkt,,,,,Greedy,1,0.0019308010737101237
134,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
",77,"static Visitor *validate_test_init_raw(TestInputVisitorData *style,

                                       const char *json_number)

{

    Visitor *y;



    style->obj = qobject_from_json(json_number);

    g_assert(style->obj != NULL);



    style->qiv = qmp_input_visitor_new_strict(style->obj);

    g_assert(style->qiv != NULL);



    y = qmp_input_get_visitor(style->qiv);

    g_assert(y != NULL);



    return y;

}
",1,1,0,1,"data,json_string,v","data:0.016881942749023438,json_string:0.04676616191864014,v:0.08804363012313843,",3,13,"v:y,json_string:json_number,data:style,",Greedy,153,0.027371879418691
135,"static int connect_namedsocket(const char *path)

{

    int sockfd, size;

    struct sockaddr_un helper;



    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if (sockfd < 0) {

        fprintf(stderr, ""socket %s\n"", strerror(errno));

        return -1;

    }

    strcpy(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    size = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {

        fprintf(stderr, ""socket error\n"");


        return -1;

    }



    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}",126,"static int connect_namedsocket(const char *address)

{

    int  swinfun, size;

    struct sockaddr_un improper;



     swinfun = socket(AF_UNIX, SOCK_STREAM, 0);

    if ( swinfun < 0) {

        fprintf(stderr, ""socket %s
"", strerror(errno));

        return -1;

    }

    strcpy(improper.sun_path, address);

    improper.sun_family = AF_UNIX;

    size = strlen(improper.sun_path) + sizeof(improper.sun_family);

    if (connect( swinfun, (struct sockaddr *)&improper, size) < 0) {

        fprintf(stderr, ""socket error
"");


        return -1;

    }



    /* remove the socket for security reasons */

    unlink(address);

    return  swinfun;

}",1,1,0,1,"path,sockfd,size,helper","path:0.1933421492576599,sockfd:0.19664227962493896,size:0.05113321542739868,helper:0.34690648317337036,",3,14,"helper:improper,sockfd: swinfun,path:address,",Greedy,229,0.038568758964538576
136,"static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)
{
    EHCIState *s = ptr;
    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);
    uint32_t old = *mmio;
    int i;
    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);
    /* Only aligned reads are allowed on OHCI */
    if (addr & 3) {
        fprintf(stderr, ""usb-ehci: Mis-aligned write to addr 0x""
                TARGET_FMT_plx ""\n"", addr);
        return;
    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {
        handle_port_status_write(s, (addr-PORTSC)/4, val);
        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);
        return;
    if (addr < OPREGBASE) {
        fprintf(stderr, ""usb-ehci: write attempt to read-only register""
                TARGET_FMT_plx ""\n"", addr);
        return;
    /* Do any register specific pre-write processing here.  */
    switch(addr) {
    case USBCMD:
        if (val & USBCMD_HCRESET) {
            ehci_reset(s);
            val = s->usbcmd;
            break;
        /* not supporting dynamic frame list size at the moment */
        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {
            fprintf(stderr, ""attempt to set frame list size -- value %d\n"",
                    val & USBCMD_FLS);
            val &= ~USBCMD_FLS;
        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=
            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {
            if (s->pstate == EST_INACTIVE) {
                SET_LAST_RUN_CLOCK(s);
            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */
            ehci_update_halt(s);
            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));
        break;
    case USBSTS:
        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO
        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC
        val = s->usbsts;
        ehci_update_irq(s);
        break;
    case USBINTR:
        val &= USBINTR_MASK;
        break;
    case FRINDEX:
        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */
        break;
    case CONFIGFLAG:
        val &= 0x1;
        if (val) {
            for(i = 0; i < NB_PORTS; i++)
                handle_port_owner_write(s, i, 0);
        break;
    case PERIODICLISTBASE:
        if (ehci_periodic_enabled(s)) {
            fprintf(stderr,
              ""ehci: PERIODIC list base register set while periodic schedule\n""
              ""      is enabled and HC is enabled\n"");
        break;
    case ASYNCLISTADDR:
        if (ehci_async_enabled(s)) {
            fprintf(stderr,
              ""ehci: ASYNC list address register set while async schedule\n""
              ""      is enabled and HC is enabled\n"");
        break;
    *mmio = val;
    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);",429,"static void ehci_mem_writel(void *pointer, target_phys_addr_t data, uint32_t pol)
{
    EHCIState *self = pointer;
    uint32_t * mmori = (uint32_t *)(&self-> mmori[data]);
    uint32_t old = * mmori;
    int io;
    trace_usb_ehci_mmio_writel(data, addr2str(data), pol);
    /* Only aligned reads are allowed on OHCI */
    if (data & 3) {
        fprintf(stderr, ""usb-ehci: Mis-aligned write to addr 0x""
                TARGET_FMT_plx ""
"", data);
        return;
    if (data >= PORTSC && data < PORTSC + 4 * NB_PORTS) {
        handle_port_status_write(self, (data-PORTSC)/4, pol);
        trace_usb_ehci_mmio_change(data, addr2str(data), * mmori, old);
        return;
    if (data < OPREGBASE) {
        fprintf(stderr, ""usb-ehci: write attempt to read-only register""
                TARGET_FMT_plx ""
"", data);
        return;
    /* Do any register specific pre-write processing here.  */
    switch(data) {
    case USBCMD:
        if (pol & USBCMD_HCRESET) {
            ehci_reset(self);
            pol = self->usbcmd;
            break;
        /* not supporting dynamic frame list size at the moment */
        if ((pol & USBCMD_FLS) && !(self->usbcmd & USBCMD_FLS)) {
            fprintf(stderr, ""attempt to set frame list size -- value %d
"",
                    pol & USBCMD_FLS);
            pol &= ~USBCMD_FLS;
        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & pol) !=
            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & self->usbcmd)) {
            if (self->pstate == EST_INACTIVE) {
                SET_LAST_RUN_CLOCK(self);
            self->usbcmd = pol; /* Set usbcmd for ehci_update_halt() */
            ehci_update_halt(self);
            qemu_mod_timer(self->frame_timer, qemu_get_clock_ns(vm_clock));
        break;
    case USBSTS:
        pol &= USBSTS_RO_MASK;              // bits 6 through 31 are RO
        ehci_clear_usbsts(self, pol);          // bits 0 through 5 are R/WC
        pol = self->usbsts;
        ehci_update_irq(self);
        break;
    case USBINTR:
        pol &= USBINTR_MASK;
        break;
    case FRINDEX:
        pol &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */
        break;
    case CONFIGFLAG:
        pol &= 0x1;
        if (pol) {
            for(io = 0; io < NB_PORTS; io++)
                handle_port_owner_write(self, io, 0);
        break;
    case PERIODICLISTBASE:
        if (ehci_periodic_enabled(self)) {
            fprintf(stderr,
              ""ehci: PERIODIC list base register set while periodic schedule
""
              ""      is enabled and HC is enabled
"");
        break;
    case ASYNCLISTADDR:
        if (ehci_async_enabled(self)) {
            fprintf(stderr,
              ""ehci: ASYNC list address register set while async schedule
""
              ""      is enabled and HC is enabled
"");
        break;
    * mmori = pol;
    trace_usb_ehci_mmio_change(data, addr2str(data), * mmori, old);",1,1,1,-1,"ptr,addr,val,s,mmio,i","ptr:0.00024360418319702148,addr:-0.0005115866661071777,val:0.00032901763916015625,s:-5.543231964111328e-05,mmio:5.3822994232177734e-05,i:-2.7835369110107422e-05,",6,65,"val:pol,ptr:pointer,mmio: mmori,i:io,s:self,addr:data,",Greedy,430,0.08919403155644735
137,"static av_cold int dnxhd_encode_init(AVCodecContext *avctx)

{

    DNXHDEncContext *ctx = avctx->priv_data;

    int i, index, bit_depth, ret;



    switch (avctx->pix_fmt) {

    case AV_PIX_FMT_YUV422P:

        bit_depth = 8;

        break;

    case AV_PIX_FMT_YUV422P10:

        bit_depth = 10;

        break;

    default:

        av_log(avctx, AV_LOG_ERROR,

               ""pixel format is incompatible with DNxHD\n"");

        return AVERROR(EINVAL);

    }



    ctx->cid = ff_dnxhd_find_cid(avctx, bit_depth);

    if (!ctx->cid) {

        av_log(avctx, AV_LOG_ERROR,

               ""video parameters incompatible with DNxHD\n"");

        return AVERROR(EINVAL);

    }

    av_log(avctx, AV_LOG_DEBUG, ""cid %d\n"", ctx->cid);



    index = ff_dnxhd_get_cid_table(ctx->cid);

    if (index < 0)

        return index;

    ctx->cid_table = &ff_dnxhd_cid_table[index];



    ctx->m.avctx    = avctx;

    ctx->m.mb_intra = 1;

    ctx->m.h263_aic = 1;



    avctx->bits_per_raw_sample = ctx->cid_table->bit_depth;



    ff_blockdsp_init(&ctx->bdsp, avctx);

    ff_fdctdsp_init(&ctx->m.fdsp, avctx);

    ff_mpv_idct_init(&ctx->m);

    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);

    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);

    if (!ctx->m.dct_quantize)

        ctx->m.dct_quantize = ff_dct_quantize_c;



    if (ctx->cid_table->bit_depth == 10) {

        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;

        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;

        ctx->block_width_l2     = 4;

    } else {

        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;

        ctx->block_width_l2     = 3;

    }



    if (ARCH_X86)

        ff_dnxhdenc_init_x86(ctx);



    ctx->m.mb_height = (avctx->height + 15) / 16;

    ctx->m.mb_width  = (avctx->width  + 15) / 16;



    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {

        ctx->interlaced   = 1;

        ctx->m.mb_height /= 2;

    }



    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;



#if FF_API_QUANT_BIAS

FF_DISABLE_DEPRECATION_WARNINGS

    if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&

        avctx->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)

        ctx->intra_quant_bias = avctx->intra_quant_bias;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    // XXX tune lbias/cbias

    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)

        return ret;



    /* Avid Nitris hardware decoder requires a minimum amount of padding

     * in the coding unit payload */

    if (ctx->nitris_compat)

        ctx->min_padding = 1600;



    if ((ret = dnxhd_init_vlc(ctx)) < 0)

        return ret;

    if ((ret = dnxhd_init_rc(ctx)) < 0)

        return ret;



    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,

                      ctx->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,

                      ctx->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,

                      ctx->m.mb_num * sizeof(uint16_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,

                      ctx->m.mb_num * sizeof(uint8_t), fail);



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    avctx->coded_frame->key_frame = 1;

    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    if (avctx->thread_count > MAX_THREADS) {

        av_log(avctx, AV_LOG_ERROR, ""too many threads\n"");

        return AVERROR(EINVAL);

    }



    ctx->thread[0] = ctx;

    for (i = 1; i < avctx->thread_count; i++) {

        ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));

        memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));

    }



    return 0;

fail:  // for FF_ALLOCZ_OR_GOTO

    return AVERROR(ENOMEM);

}
",712,"static av_cold int dnxhd_encode_init(AVCodecContext *avecmp)

{

    DNXHDEncContext *concept = avecmp->priv_data;

    int it, error, bitalldepth, row;



    switch (avecmp->pix_fmt) {

    case AV_PIX_FMT_YUV422P:

        bitalldepth = 8;

        break;

    case AV_PIX_FMT_YUV422P10:

        bitalldepth = 10;

        break;

    default:

        av_log(avecmp, AV_LOG_ERROR,

               ""pixel format is incompatible with DNxHD
"");

        return AVERROR(EINVAL);

    }



    concept->cid = ff_dnxhd_find_cid(avecmp, bitalldepth);

    if (!concept->cid) {

        av_log(avecmp, AV_LOG_ERROR,

               ""video parameters incompatible with DNxHD
"");

        return AVERROR(EINVAL);

    }

    av_log(avecmp, AV_LOG_DEBUG, ""cid %d
"", concept->cid);



    error = ff_dnxhd_get_cid_table(concept->cid);

    if (error < 0)

        return error;

    concept->cid_table = &ff_dnxhd_cid_table[error];



    concept->m.avecmp    = avecmp;

    concept->m.mb_intra = 1;

    concept->m.h263_aic = 1;



    avecmp->bits_per_raw_sample = concept->cid_table->bitalldepth;



    ff_blockdsp_init(&concept->bdsp, avecmp);

    ff_fdctdsp_init(&concept->m.fdsp, avecmp);

    ff_mpv_idct_init(&concept->m);

    ff_mpegvideoencdsp_init(&concept->m.mpvencdsp, avecmp);

    ff_pixblockdsp_init(&concept->m.pdsp, avecmp);

    if (!concept->m.dct_quantize)

        concept->m.dct_quantize = ff_dct_quantize_c;



    if (concept->cid_table->bitalldepth == 10) {

        concept->m.dct_quantize     = dnxhd_10bit_dct_quantize;

        concept->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;

        concept->block_width_l2     = 4;

    } else {

        concept->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;

        concept->block_width_l2     = 3;

    }



    if (ARCH_X86)

        ff_dnxhdenc_init_x86(concept);



    concept->m.mb_height = (avecmp->height + 15) / 16;

    concept->m.mb_width  = (avecmp->width  + 15) / 16;



    if (avecmp->flags & AV_CODEC_FLAG_INTERLACED_DCT) {

        concept->interlaced   = 1;

        concept->m.mb_height /= 2;

    }



    concept->m.mb_num = concept->m.mb_height * concept->m.mb_width;



#if FF_API_QUANT_BIAS

FF_DISABLE_DEPRECATION_WARNINGS

    if (concept->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&

        avecmp->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)

        concept->intra_quant_bias = avecmp->intra_quant_bias;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    // XXX tune lbias/cbias

    if ((row = dnxhd_init_qmat(concept, concept->intra_quant_bias, 0)) < 0)

        return row;



    /* Avid Nitris hardware decoder requires a minimum amount of padding

     * in the coding unit payload */

    if (concept->nitris_compat)

        concept->min_padding = 1600;



    if ((row = dnxhd_init_vlc(concept)) < 0)

        return row;

    if ((row = dnxhd_init_rc(concept)) < 0)

        return row;



    FF_ALLOCZ_OR_GOTO(concept->m.avecmp, concept->slice_size,

                      concept->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(concept->m.avecmp, concept->slice_offs,

                      concept->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(concept->m.avecmp, concept->mb_bits,

                      concept->m.mb_num * sizeof(uint16_t), fail);

    FF_ALLOCZ_OR_GOTO(concept->m.avecmp, concept->mb_qscale,

                      concept->m.mb_num * sizeof(uint8_t), fail);



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    avecmp->coded_frame->key_frame = 1;

    avecmp->coded_frame->pict_type = AV_PICTURE_TYPE_I;

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    if (avecmp->thread_count > MAX_THREADS) {

        av_log(avecmp, AV_LOG_ERROR, ""too many threads
"");

        return AVERROR(EINVAL);

    }



    concept->thread[0] = concept;

    for (it = 1; it < avecmp->thread_count; it++) {

        concept->thread[it] = av_malloc(sizeof(DNXHDEncContext));

        memcpy(concept->thread[it], concept, sizeof(DNXHDEncContext));

    }



    return 0;

fail:  // for FF_ALLOCZ_OR_GOTO

    return AVERROR(ENOMEM);

}
",0,0,1,1,"avctx,ctx,i,index,bit_depth,ret","avctx:0.07262833788990974,ctx:0.09760498255491257,i:0.011044085025787354,index:-0.0023137107491493225,bit_depth:0.04708058387041092,ret:0.018808677792549133,",6,108,"ctx:concept,avctx:avecmp,bit_depth:bitalldepth,ret:row,i:it,index:error,",Greedy,452,0.10563253164291382
138,"static int vc1_decode_frame(AVCodecContext *avctx, void *data,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size, n_slices = 0, i;

    VC1Context *v = avctx->priv_data;

    MpegEncContext *s = &v->s;

    AVFrame *pict = data;

    uint8_t *buf2 = NULL;

    const uint8_t *buf_start = buf, *buf_start_second_field = NULL;

    int mb_height, n_slices1=-1;

    struct {

        uint8_t *buf;

        GetBitContext gb;

        int mby_start;

    } *slices = NULL, *tmp;



    v->second_field = 0;



    if(s->flags & CODEC_FLAG_LOW_DELAY)

        s->low_delay = 1;



    /* no supplementary picture */

    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) {

        /* special case for last picture */

        if (s->low_delay == 0 && s->next_picture_ptr) {

            *pict = s->next_picture_ptr->f;

            s->next_picture_ptr = NULL;



            *data_size = sizeof(AVFrame);

        }



        return buf_size;

    }



    if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) {

        if (v->profile < PROFILE_ADVANCED)

            avctx->pix_fmt = AV_PIX_FMT_VDPAU_WMV3;

        else

            avctx->pix_fmt = AV_PIX_FMT_VDPAU_VC1;

    }



    //for advanced profile we may need to parse and unescape data

    if (avctx->codec_id == AV_CODEC_ID_VC1 || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {

        int buf_size2 = 0;

        buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);



        if (IS_MARKER(AV_RB32(buf))) { /* frame starts with marker and needs to be parsed */

            const uint8_t *start, *end, *next;

            int size;



            next = buf;

            for (start = buf, end = buf + buf_size; next < end; start = next) {

                next = find_next_marker(start + 4, end);

                size = next - start - 4;

                if (size <= 0) continue;

                switch (AV_RB32(start)) {

                case VC1_CODE_FRAME:

                    if (avctx->hwaccel ||

                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)

                        buf_start = start;

                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);

                    break;

                case VC1_CODE_FIELD: {

                    int buf_size3;

                    if (avctx->hwaccel ||

                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)

                        buf_start_second_field = start;

                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));

                    if (!tmp)

                        goto err;

                    slices = tmp;

                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);

                    if (!slices[n_slices].buf)

                        goto err;

                    buf_size3 = vc1_unescape_buffer(start + 4, size,

                                                    slices[n_slices].buf);

                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,

                                  buf_size3 << 3);

                    /* assuming that the field marker is at the exact middle,

                       hope it's correct */

                    slices[n_slices].mby_start = s->mb_height >> 1;

                    n_slices1 = n_slices - 1; // index of the last slice of the first field

                    n_slices++;

                    break;

                }

                case VC1_CODE_ENTRYPOINT: /* it should be before frame data */

                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);

                    init_get_bits(&s->gb, buf2, buf_size2 * 8);

                    ff_vc1_decode_entry_point(avctx, v, &s->gb);

                    break;

                case VC1_CODE_SLICE: {

                    int buf_size3;

                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));

                    if (!tmp)

                        goto err;

                    slices = tmp;

                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);

                    if (!slices[n_slices].buf)

                        goto err;

                    buf_size3 = vc1_unescape_buffer(start + 4, size,

                                                    slices[n_slices].buf);

                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,

                                  buf_size3 << 3);

                    slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9);

                    n_slices++;

                    break;

                }

                }

            }

        } else if (v->interlace && ((buf[0] & 0xC0) == 0xC0)) { /* WVC1 interlaced stores both fields divided by marker */

            const uint8_t *divider;

            int buf_size3;



            divider = find_next_marker(buf, buf + buf_size);

            if ((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD) {

                av_log(avctx, AV_LOG_ERROR, ""Error in WVC1 interlaced frame\n"");

                goto err;

            } else { // found field marker, unescape second field

                if (avctx->hwaccel ||

                    s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)

                    buf_start_second_field = divider;

                tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));

                if (!tmp)

                    goto err;

                slices = tmp;

                slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);

                if (!slices[n_slices].buf)

                    goto err;

                buf_size3 = vc1_unescape_buffer(divider + 4, buf + buf_size - divider - 4, slices[n_slices].buf);

                init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,

                              buf_size3 << 3);

                slices[n_slices].mby_start = s->mb_height >> 1;

                n_slices1 = n_slices - 1;

                n_slices++;

            }

            buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2);

        } else {

            buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2);

        }

        init_get_bits(&s->gb, buf2, buf_size2*8);

    } else

        init_get_bits(&s->gb, buf, buf_size*8);



    if (v->res_sprite) {

        v->new_sprite  = !get_bits1(&s->gb);

        v->two_sprites =  get_bits1(&s->gb);

        /* res_sprite means a Windows Media Image stream, AV_CODEC_ID_*IMAGE means

           we're using the sprite compositor. These are intentionally kept separate

           so you can get the raw sprites by using the wmv3 decoder for WMVP or

           the vc1 one for WVP2 */

        if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {

            if (v->new_sprite) {

                // switch AVCodecContext parameters to those of the sprites

                avctx->width  = avctx->coded_width  = v->sprite_width;

                avctx->height = avctx->coded_height = v->sprite_height;

            } else {

                goto image;

            }

        }

    }



    if (s->context_initialized &&

        (s->width  != avctx->coded_width ||

         s->height != avctx->coded_height)) {

        ff_vc1_decode_end(avctx);

    }



    if (!s->context_initialized) {

        if (ff_msmpeg4_decode_init(avctx) < 0 || ff_vc1_decode_init_alloc_tables(v) < 0)

            goto err;



        s->low_delay = !avctx->has_b_frames || v->res_sprite;



        if (v->profile == PROFILE_ADVANCED) {

            s->h_edge_pos = avctx->coded_width;

            s->v_edge_pos = avctx->coded_height;

        }

    }



    /* We need to set current_picture_ptr before reading the header,

     * otherwise we cannot store anything in there. */

    if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) {

        int i = ff_find_unused_picture(s, 0);

        if (i < 0)

            goto err;

        s->current_picture_ptr = &s->picture[i];

    }



    // do parse frame header

    v->pic_header_flag = 0;

    if (v->profile < PROFILE_ADVANCED) {

        if (ff_vc1_parse_frame_header(v, &s->gb) < 0) {

            goto err;

        }

    } else {

        if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {

            goto err;

        }

    }



    if (avctx->debug & FF_DEBUG_PICT_INFO)

        av_log(v->s.avctx, AV_LOG_DEBUG, ""pict_type: %c\n"", av_get_picture_type_char(s->pict_type));



    if ((avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE)

        && s->pict_type != AV_PICTURE_TYPE_I) {

        av_log(v->s.avctx, AV_LOG_ERROR, ""Sprite decoder: expected I-frame\n"");

        goto err;

    }



    if ((s->mb_height >> v->field_mode) == 0) {

        av_log(v->s.avctx, AV_LOG_ERROR, ""image too short\n"");

        goto err;

    }



    // process pulldown flags

    s->current_picture_ptr->f.repeat_pict = 0;

    // Pulldown flags are only valid when 'broadcast' has been set.

    // So ticks_per_frame will be 2

    if (v->rff) {

        // repeat field

        s->current_picture_ptr->f.repeat_pict = 1;

    } else if (v->rptfrm) {

        // repeat frames

        s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2;

    }



    // for skipping the frame

    s->current_picture.f.pict_type = s->pict_type;

    s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;



    /* skip B-frames if we don't have reference frames */

    if (s->last_picture_ptr == NULL && (s->pict_type == AV_PICTURE_TYPE_B || s->dropable)) {

        goto err;

    }

    if ((avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B) ||

        (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I) ||

         avctx->skip_frame >= AVDISCARD_ALL) {

        goto end;

    }



    if (s->next_p_frame_damaged) {

        if (s->pict_type == AV_PICTURE_TYPE_B)

            goto end;

        else

            s->next_p_frame_damaged = 0;

    }



    if (ff_MPV_frame_start(s, avctx) < 0) {

        goto err;

    }



    v->s.current_picture_ptr->f.interlaced_frame = (v->fcm != PROGRESSIVE);

    v->s.current_picture_ptr->f.top_field_first  = v->tff;



    s->me.qpel_put = s->dsp.put_qpel_pixels_tab;

    s->me.qpel_avg = s->dsp.avg_qpel_pixels_tab;



    if ((CONFIG_VC1_VDPAU_DECODER)

        &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)

        ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start);

    else if (avctx->hwaccel) {

        if (v->field_mode && buf_start_second_field) {

            // decode first field

            s->picture_structure = PICT_BOTTOM_FIELD - v->tff;

            if (avctx->hwaccel->start_frame(avctx, buf_start, buf_start_second_field - buf_start) < 0)

                goto err;

            if (avctx->hwaccel->decode_slice(avctx, buf_start, buf_start_second_field - buf_start) < 0)

                goto err;

            if (avctx->hwaccel->end_frame(avctx) < 0)

                goto err;



            // decode second field

            s->gb = slices[n_slices1 + 1].gb;

            s->picture_structure = PICT_TOP_FIELD + v->tff;

            v->second_field = 1;

            v->pic_header_flag = 0;

            if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {

                av_log(avctx, AV_LOG_ERROR, ""parsing header for second field failed"");

                goto err;

            }

            v->s.current_picture_ptr->f.pict_type = v->s.pict_type;



            if (avctx->hwaccel->start_frame(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0)

                goto err;

            if (avctx->hwaccel->decode_slice(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0)

                goto err;

            if (avctx->hwaccel->end_frame(avctx) < 0)

                goto err;

        } else {

            s->picture_structure = PICT_FRAME;

            if (avctx->hwaccel->start_frame(avctx, buf_start, (buf + buf_size) - buf_start) < 0)

                goto err;

            if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0)

                goto err;

            if (avctx->hwaccel->end_frame(avctx) < 0)

                goto err;

        }

    } else {

        if (v->fcm == ILACE_FRAME && s->pict_type == AV_PICTURE_TYPE_B)

            goto err; // This codepath is still incomplete thus it is disabled



        ff_er_frame_start(s);



        v->bits = buf_size * 8;

        v->end_mb_x = s->mb_width;

        if (v->field_mode) {

            uint8_t *tmp[2];

            s->current_picture.f.linesize[0] <<= 1;

            s->current_picture.f.linesize[1] <<= 1;

            s->current_picture.f.linesize[2] <<= 1;

            s->linesize                      <<= 1;

            s->uvlinesize                    <<= 1;

            tmp[0]          = v->mv_f_last[0];

            tmp[1]          = v->mv_f_last[1];

            v->mv_f_last[0] = v->mv_f_next[0];

            v->mv_f_last[1] = v->mv_f_next[1];

            v->mv_f_next[0] = v->mv_f[0];

            v->mv_f_next[1] = v->mv_f[1];

            v->mv_f[0] = tmp[0];

            v->mv_f[1] = tmp[1];

        }

        mb_height = s->mb_height >> v->field_mode;

        for (i = 0; i <= n_slices; i++) {

            if (i > 0 &&  slices[i - 1].mby_start >= mb_height) {

                if (v->field_mode <= 0) {

                    av_log(v->s.avctx, AV_LOG_ERROR, ""Slice %d starts beyond ""

                           ""picture boundary (%d >= %d)\n"", i,

                           slices[i - 1].mby_start, mb_height);

                    continue;

                }

                v->second_field = 1;

                v->blocks_off   = s->mb_width  * s->mb_height << 1;

                v->mb_off       = s->mb_stride * s->mb_height >> 1;

            } else {

                v->second_field = 0;

                v->blocks_off   = 0;

                v->mb_off       = 0;

            }

            if (i) {

                v->pic_header_flag = 0;

                if (v->field_mode && i == n_slices1 + 2) {

                    if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {

                        av_log(v->s.avctx, AV_LOG_ERROR, ""Field header damaged\n"");

                        continue;

                    }

                } else if (get_bits1(&s->gb)) {

                    v->pic_header_flag = 1;

                    if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {

                        av_log(v->s.avctx, AV_LOG_ERROR, ""Slice header damaged\n"");

                        continue;

                    }

                }

            }

            s->start_mb_y = (i == 0) ? 0 : FFMAX(0, slices[i-1].mby_start % mb_height);

            if (!v->field_mode || v->second_field)

                s->end_mb_y = (i == n_slices     ) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height);

            else

                s->end_mb_y = (i <= n_slices1 + 1) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height);

            if (s->end_mb_y <= s->start_mb_y) {

                av_log(v->s.avctx, AV_LOG_ERROR, ""end mb y %d %d invalid\n"", s->end_mb_y, s->start_mb_y);

                continue;

            }

            ff_vc1_decode_blocks(v);

            if (i != n_slices)

                s->gb = slices[i].gb;

        }

        if (v->field_mode) {

            v->second_field = 0;

            if (s->pict_type == AV_PICTURE_TYPE_B) {

                memcpy(v->mv_f_base, v->mv_f_next_base,

                       2 * (s->b8_stride * (s->mb_height * 2 + 1) + s->mb_stride * (s->mb_height + 1) * 2));

            }

            s->current_picture.f.linesize[0] >>= 1;

            s->current_picture.f.linesize[1] >>= 1;

            s->current_picture.f.linesize[2] >>= 1;

            s->linesize                      >>= 1;

            s->uvlinesize                    >>= 1;

        }

        av_dlog(s->avctx, ""Consumed %i/%i bits\n"",

                get_bits_count(&s->gb), s->gb.size_in_bits);

//  if (get_bits_count(&s->gb) > buf_size * 8)

//      return -1;

        if(s->error_occurred && s->pict_type == AV_PICTURE_TYPE_B)

            goto err;

        if(!v->field_mode)

            ff_er_frame_end(s);

    }



    ff_MPV_frame_end(s);



    if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {

image:

        avctx->width  = avctx->coded_width  = v->output_width;

        avctx->height = avctx->coded_height = v->output_height;

        if (avctx->skip_frame >= AVDISCARD_NONREF)

            goto end;

#if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER

        if (vc1_decode_sprites(v, &s->gb))

            goto err;

#endif

        *pict      = v->sprite_output_frame;

        *data_size = sizeof(AVFrame);

    } else {

        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {

            *pict = s->current_picture_ptr->f;

        } else if (s->last_picture_ptr != NULL) {

            *pict = s->last_picture_ptr->f;

        }

        if (s->last_picture_ptr || s->low_delay) {

            *data_size = sizeof(AVFrame);

            ff_print_debug_info(s, pict);

        }

    }



end:

    av_free(buf2);

    for (i = 0; i < n_slices; i++)

        av_free(slices[i].buf);

    av_free(slices);

    return buf_size;



err:

    av_free(buf2);

    for (i = 0; i < n_slices; i++)

        av_free(slices[i].buf);

    av_free(slices);

    return -1;

}
",2998,,0,1,,-4,"avctx,data,data_size,avpkt,buf,i,v,s,pict,buf2,buf_start,buf_start_second_field,mb_height,slices,tmp,size,n_slices",,,,,Greedy,1,0.0029321948687235514
139,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)

{

    bs->detect_zeroes = blk->root_state.detect_zeroes;

}
",23,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bid)

{

    bid->detect_zeroes = blk->root_state.detect_zeroes;

}
",0,0,0,-1,"blk,bs","blk:-0.007394912652671337,bs:0.013594225980341434,",1,2,"bs:bid,blk:blk,",Greedy,67,0.0143370787302653
140,"vcard_emul_mirror_card(VReader *vreader)

{

    /*

     * lookup certs using the C_FindObjects. The Stan Cert handle won't give

     * us the real certs until we log in.

     */

    PK11GenericObject *firstObj, *thisObj;

    int cert_count;

    unsigned char **certs;

    int *cert_len;

    VCardKey **keys;

    PK11SlotInfo *slot;

    VCard *card;



    slot = vcard_emul_reader_get_slot(vreader);

    if (slot == NULL) {

        return NULL;

    }



    firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE);

    if (firstObj == NULL) {

        return NULL;

    }



    /* count the certs */

    cert_count = 0;

    for (thisObj = firstObj; thisObj;

                             thisObj = PK11_GetNextGenericObject(thisObj)) {

        cert_count++;

    }



    if (cert_count == 0) {

        PK11_DestroyGenericObjects(firstObj);

        return NULL;

    }



    /* allocate the arrays */

    vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count);



    /* fill in the arrays */

    cert_count = 0;

    for (thisObj = firstObj; thisObj;

                             thisObj = PK11_GetNextGenericObject(thisObj)) {

        SECItem derCert;

        CERTCertificate *cert;

        SECStatus rv;



        rv = PK11_ReadRawAttribute(PK11_TypeGeneric, thisObj,

                                   CKA_VALUE, &derCert);

        if (rv != SECSuccess) {

            continue;

        }

        /* create floating temp cert. This gives us a cert structure even if

         * the token isn't logged in */

        cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &derCert,

                                       NULL, PR_FALSE, PR_TRUE);

        SECITEM_FreeItem(&derCert, PR_FALSE);

        if (cert == NULL) {

            continue;

        }



        certs[cert_count] = cert->derCert.data;

        cert_len[cert_count] = cert->derCert.len;

        keys[cert_count] = vcard_emul_make_key(slot, cert);

        cert_count++;

        CERT_DestroyCertificate(cert); /* key obj still has a reference */

    }



    /* now create the card */

    card = vcard_emul_make_card(vreader, certs, cert_len, keys, cert_count);

    g_free(certs);

    g_free(cert_len);

    g_free(keys);



    return card;

}
",300,,0,1,,-4,"firstObj,thisObj,cert_count,certs,cert_len,keys,slot,card,derCert,cert,rv",,,,,Greedy,1,0.002047590414683024
141,"static uint64_t megasas_fw_time(void)

{

    struct tm curtime;

    uint64_t bcd_time;



    qemu_get_timedate(&curtime, 0);

    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |

        ((uint64_t)curtime.tm_min & 0xff)  << 40 |

        ((uint64_t)curtime.tm_hour & 0xff) << 32 |

        ((uint64_t)curtime.tm_mday & 0xff) << 24 |

        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |

        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);



    return bcd_time;

}
",108,"static uint64_t megasas_fw_time(void)

{

    struct tm curset;

    uint64_t bcd_time;



    qemu_get_timedate(&curset, 0);

    bcd_time = ((uint64_t)curset.tm_sec & 0xff) << 48 |

        ((uint64_t)curset.tm_min & 0xff)  << 40 |

        ((uint64_t)curset.tm_hour & 0xff) << 32 |

        ((uint64_t)curset.tm_mday & 0xff) << 24 |

        ((uint64_t)curset.tm_mon & 0xff)  << 16 |

        ((uint64_t)(curset.tm_year + 1900) & 0xffff);



    return bcd_time;

}
",0,0,1,1,"curtime,bcd_time","curtime:0.019942717626690865,bcd_time:-0.005332211032509804,",1,8,"curtime:curset,",Greedy,110,0.01918318271636963
142,"static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)

{

    OfDpaFlow *flow;

    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;



    flow = g_new0(OfDpaFlow, 1);

    if (!flow) {

        return NULL;

    }



    flow->cookie = cookie;

    flow->mask.tbl_id = 0xffffffff;



    flow->stats.install_time = flow->stats.refresh_time = now;



    return flow;

}
",74,,1,0,,-4,"cookie,flow",,,,,Greedy,1,0.002300735314687093
143,"static int rtp_open(URLContext *h, const char *uri, int flags)

{

    RTPContext *s;

    int port, is_output, ttl, local_port;

    char hostname[256];

    char buf[1024];

    char path[1024];

    const char *p;



    is_output = (flags & URL_WRONLY);



    s = av_mallocz(sizeof(RTPContext));

    if (!s)

        return AVERROR(ENOMEM);

    h->priv_data = s;



    url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port,

              path, sizeof(path), uri);

    /* extract parameters */

    ttl = -1;

    local_port = -1;

    p = strchr(uri, '?');

    if (p) {

        if (find_info_tag(buf, sizeof(buf), ""ttl"", p)) {

            ttl = strtol(buf, NULL, 10);

        }

        if (find_info_tag(buf, sizeof(buf), ""localport"", p)) {

            local_port = strtol(buf, NULL, 10);

        }

    }



    build_udp_url(buf, sizeof(buf),

                  hostname, port, local_port, ttl);

    if (url_open(&s->rtp_hd, buf, flags) < 0)

        goto fail;

    local_port = udp_get_local_port(s->rtp_hd);

    /* XXX: need to open another connection if the port is not even */



    /* well, should suppress localport in path */



    build_udp_url(buf, sizeof(buf),

                  hostname, port + 1, local_port + 1, ttl);

    if (url_open(&s->rtcp_hd, buf, flags) < 0)

        goto fail;



    /* just to ease handle access. XXX: need to suppress direct handle

       access */

    s->rtp_fd = udp_get_file_handle(s->rtp_hd);

    s->rtcp_fd = udp_get_file_handle(s->rtcp_hd);



    h->max_packet_size = url_get_max_packet_size(s->rtp_hd);

    h->is_streamed = 1;

    return 0;



 fail:

    if (s->rtp_hd)

        url_close(s->rtp_hd);

    if (s->rtcp_hd)

        url_close(s->rtcp_hd);

    av_free(s);

    return AVERROR(EIO);

}
",371,"static int rtp_open(URLContext *b, const char *uri, int flags)

{

    RTPContext *b;

    int port, is_output, ttl, local_port;

    char hostname[256];

    char uc[1024];

    char path[1024];

    const char *p;



    is_output = (flags & URL_WRONLY);



    b = av_mallocz(sizeof(RTPContext));

    if (!b)

        return AVERROR(ENOMEM);

    b->priv_data = b;



    url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port,

              path, sizeof(path), uri);

    /* extract parameters */

    ttl = -1;

    local_port = -1;

    p = strchr(uri, '?');

    if (p) {

        if (find_info_tag(uc, sizeof(uc), ""ttl"", p)) {

            ttl = strtol(uc, NULL, 10);

        }

        if (find_info_tag(uc, sizeof(uc), ""localport"", p)) {

            local_port = strtol(uc, NULL, 10);

        }

    }



    build_udp_url(uc, sizeof(uc),

                  hostname, port, local_port, ttl);

    if (url_open(&b->rtp_hd, uc, flags) < 0)

        goto fail;

    local_port = udp_get_local_port(b->rtp_hd);

    /* XXX: need to open another connection if the port is not even */



    /* well, should suppress localport in path */



    build_udp_url(uc, sizeof(uc),

                  hostname, port + 1, local_port + 1, ttl);

    if (url_open(&b->rtcp_hd, uc, flags) < 0)

        goto fail;



    /* just to ease handle access. XXX: need to suppress direct handle

       access */

    b->rtp_fd = udp_get_file_handle(b->rtp_hd);

    b->rtcp_fd = udp_get_file_handle(b->rtcp_hd);



    b->max_packet_size = url_get_max_packet_size(b->rtp_hd);

    b->is_streamed = 1;

    return 0;



 fail:

    if (b->rtp_hd)

        url_close(b->rtp_hd);

    if (b->rtcp_hd)

        url_close(b->rtcp_hd);

    av_free(b);

    return AVERROR(EIO);

}
",0,0,1,1,"h,uri,flags,s,port,is_output,ttl,local_port,hostname,buf,path,p","h:0.08006639778614044,uri:-0.0018050074577331543,flags:0.033242374658584595,s:0.18619605898857117,port:0.013961359858512878,is_output:0.010588526725769043,ttl:0.008566528558731079,local_port:-0.036963559687137604,hostname:-0.0032160133123397827,buf:0.04876430332660675,path:0.015143707394599915,p:0.04615244269371033,",3,34,"s:b,h:b,buf:uc,",Greedy,267,0.0506026824315389
144,"static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,

                                       PutBitContext *pb, const float *in,

                                       const float *scaled, int size, int scale_idx,

                                       int cb, const float lambda, const float uplim,

                                       int *bits)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    float cost = 0;

    int qc1, qc2, qc3, qc4;

    int curbits = 0;



    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];

    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];



    for (i = 0; i < size; i += 4) {

        const float *vec, *vec2;

        int curidx, curidx2, sign1, count1, sign2, count2;

        int   *in_int = (int   *)&in[i];

        float *in_pos = (float *)&in[i];

        float di0, di1, di2, di3;

        int t0, t1, t2, t3, t4;



        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                                          \n\t""

            "".set noreorder                                     \n\t""



            ""ori        %[t4],      $zero,      7               \n\t""

            ""ori        %[sign1],   $zero,      0               \n\t""

            ""ori        %[sign2],   $zero,      0               \n\t""

            ""slt        %[t0],      %[t4],      %[qc1]          \n\t""

            ""slt        %[t1],      %[t4],      %[qc2]          \n\t""

            ""slt        %[t2],      %[t4],      %[qc3]          \n\t""

            ""slt        %[t3],      %[t4],      %[qc4]          \n\t""

            ""movn       %[qc1],     %[t4],      %[t0]           \n\t""

            ""movn       %[qc2],     %[t4],      %[t1]           \n\t""

            ""movn       %[qc3],     %[t4],      %[t2]           \n\t""

            ""movn       %[qc4],     %[t4],      %[t3]           \n\t""

            ""lw         %[t0],      0(%[in_int])                \n\t""

            ""lw         %[t1],      4(%[in_int])                \n\t""

            ""lw         %[t2],      8(%[in_int])                \n\t""

            ""lw         %[t3],      12(%[in_int])               \n\t""

            ""slt        %[t0],      %[t0],      $zero           \n\t""

            ""movn       %[sign1],   %[t0],      %[qc1]          \n\t""

            ""slt        %[t2],      %[t2],      $zero           \n\t""

            ""movn       %[sign2],   %[t2],      %[qc3]          \n\t""

            ""slt        %[t1],      %[t1],      $zero           \n\t""

            ""sll        %[t0],      %[sign1],   1               \n\t""

            ""or         %[t0],      %[t0],      %[t1]           \n\t""

            ""movn       %[sign1],   %[t0],      %[qc2]          \n\t""

            ""slt        %[t3],      %[t3],      $zero           \n\t""

            ""sll        %[t0],      %[sign2],   1               \n\t""

            ""or         %[t0],      %[t0],      %[t3]           \n\t""

            ""movn       %[sign2],   %[t0],      %[qc4]          \n\t""

            ""slt        %[count1],  $zero,      %[qc1]          \n\t""

            ""slt        %[t1],      $zero,      %[qc2]          \n\t""

            ""slt        %[count2],  $zero,      %[qc3]          \n\t""

            ""slt        %[t2],      $zero,      %[qc4]          \n\t""

            ""addu       %[count1],  %[count1],  %[t1]           \n\t""

            ""addu       %[count2],  %[count2],  %[t2]           \n\t""



            "".set pop                                           \n\t""



            : [qc1]""+r""(qc1), [qc2]""+r""(qc2),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [sign1]""=&r""(sign1), [count1]""=&r""(count1),

              [sign2]""=&r""(sign2), [count2]""=&r""(count2),

              [t0]""=&r""(t0), [t1]""=&r""(t1), [t2]""=&r""(t2), [t3]""=&r""(t3),

              [t4]""=&r""(t4)

            : [in_int]""r""(in_int)

            : ""memory""

        );



        curidx = 8 * qc1;

        curidx += qc2;



        curidx2 = 8 * qc3;

        curidx2 += qc4;



        curbits += p_bits[curidx];

        curbits += upair7_sign_bits[curidx];

        vec     = &p_codes[curidx*2];



        curbits += p_bits[curidx2];

        curbits += upair7_sign_bits[curidx2];

        vec2    = &p_codes[curidx2*2];



        __asm__ volatile (

            "".set push                                          \n\t""

            "".set noreorder                                     \n\t""



            ""lwc1       %[di0],     0(%[in_pos])                \n\t""

            ""lwc1       %[di1],     4(%[in_pos])                \n\t""

            ""lwc1       %[di2],     8(%[in_pos])                \n\t""

            ""lwc1       %[di3],     12(%[in_pos])               \n\t""

            ""abs.s      %[di0],     %[di0]                      \n\t""

            ""abs.s      %[di1],     %[di1]                      \n\t""

            ""abs.s      %[di2],     %[di2]                      \n\t""

            ""abs.s      %[di3],     %[di3]                      \n\t""

            ""lwc1       $f0,        0(%[vec])                   \n\t""

            ""lwc1       $f1,        4(%[vec])                   \n\t""

            ""lwc1       $f2,        0(%[vec2])                  \n\t""

            ""lwc1       $f3,        4(%[vec2])                  \n\t""

            ""nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \n\t""

            ""nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \n\t""

            ""nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \n\t""

            ""nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \n\t""



            "".set pop                                           \n\t""



            : [di0]""=&f""(di0), [di1]""=&f""(di1),

              [di2]""=&f""(di2), [di3]""=&f""(di3)

            : [in_pos]""r""(in_pos), [vec]""r""(vec),

              [vec2]""r""(vec2), [IQ]""f""(IQ)

            : ""$f0"", ""$f1"", ""$f2"", ""$f3"",

              ""memory""

        );



        cost += di0 * di0 + di1 * di1

                + di2 * di2 + di3 * di3;

    }



    if (bits)

        *bits = curbits;

    return cost * lambda + curbits;

}
",778,"static float get_band_cost_UPAIR7_mips(struct AACEncContext *fs,

                                       PutBitContext *bps, const float *image,

                                       const float *stilled, int mode, int scale_ide,

                                       int crop, const float phi, const float Uplength,

                                       int *units)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_ide + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_ide - SCALE_ONE_POS + SCALE_DIV_512];

    int io;

    float cost = 0;

    int  qcone, qcsFuture,  qcs6, qvc7;

    int curbits = 0;



    uint8_t *p_ops  = (uint8_t *)ff_aac_spectral_bits[crop-1];

    float   *p_codes = (float   *)ff_aac_codebook_vectors[crop-1];



    for (io = 0; io < mode; io += 4) {

        const float *version, *vec5;

        int  curIdc, curidx2, sum1, count1, sign0, patch2;

        int   *inc_index = (int   *)&image[io];

        float * in_flo = (float *)&image[io];

        float ti1, d3, mi0, di3;

        int t00, t1, type4, t3, t04;



         qcone = stilled[io  ] * Q34 + ROUND_STANDARD;

        qcsFuture = stilled[io+1] * Q34 + ROUND_STANDARD;

         qcs6 = stilled[io+2] * Q34 + ROUND_STANDARD;

        qvc7 = stilled[io+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                                          
\t""

            "".set noreorder                                     
\t""



            ""ori        %[t4],      $zero,      7               
\t""

            ""ori        %[sign1],   $zero,      0               
\t""

            ""ori        %[sign2],   $zero,      0               
\t""

            ""slt        %[t0],      %[t4],      %[qc1]          
\t""

            ""slt        %[t1],      %[t4],      %[qc2]          
\t""

            ""slt        %[t2],      %[t4],      %[qc3]          
\t""

            ""slt        %[t3],      %[t4],      %[qc4]          
\t""

            ""movn       %[qc1],     %[t4],      %[t0]           
\t""

            ""movn       %[qc2],     %[t4],      %[t1]           
\t""

            ""movn       %[qc3],     %[t4],      %[t2]           
\t""

            ""movn       %[qc4],     %[t4],      %[t3]           
\t""

            ""lw         %[t0],      0(%[in_int])                
\t""

            ""lw         %[t1],      4(%[in_int])                
\t""

            ""lw         %[t2],      8(%[in_int])                
\t""

            ""lw         %[t3],      12(%[in_int])               
\t""

            ""slt        %[t0],      %[t0],      $zero           
\t""

            ""movn       %[sign1],   %[t0],      %[qc1]          
\t""

            ""slt        %[t2],      %[t2],      $zero           
\t""

            ""movn       %[sign2],   %[t2],      %[qc3]          
\t""

            ""slt        %[t1],      %[t1],      $zero           
\t""

            ""sll        %[t0],      %[sign1],   1               
\t""

            ""or         %[t0],      %[t0],      %[t1]           
\t""

            ""movn       %[sign1],   %[t0],      %[qc2]          
\t""

            ""slt        %[t3],      %[t3],      $zero           
\t""

            ""sll        %[t0],      %[sign2],   1               
\t""

            ""or         %[t0],      %[t0],      %[t3]           
\t""

            ""movn       %[sign2],   %[t0],      %[qc4]          
\t""

            ""slt        %[count1],  $zero,      %[qc1]          
\t""

            ""slt        %[t1],      $zero,      %[qc2]          
\t""

            ""slt        %[count2],  $zero,      %[qc3]          
\t""

            ""slt        %[t2],      $zero,      %[qc4]          
\t""

            ""addu       %[count1],  %[count1],  %[t1]           
\t""

            ""addu       %[count2],  %[count2],  %[t2]           
\t""



            "".set pop                                           
\t""



            : [ qcone]""+r""( qcone), [qcsFuture]""+r""(qcsFuture),

              [ qcs6]""+r""( qcs6), [qvc7]""+r""(qvc7),

              [sum1]""=&r""(sum1), [count1]""=&r""(count1),

              [sign0]""=&r""(sign0), [patch2]""=&r""(patch2),

              [t00]""=&r""(t00), [t1]""=&r""(t1), [type4]""=&r""(type4), [t3]""=&r""(t3),

              [t04]""=&r""(t04)

            : [inc_index]""r""(inc_index)

            : ""memory""

        );



         curIdc = 8 *  qcone;

         curIdc += qcsFuture;



        curidx2 = 8 *  qcs6;

        curidx2 += qvc7;



        curbits += p_ops[ curIdc];

        curbits += upair7_sign_bits[ curIdc];

        version     = &p_codes[ curIdc*2];



        curbits += p_ops[curidx2];

        curbits += upair7_sign_bits[curidx2];

        vec5    = &p_codes[curidx2*2];



        __asm__ volatile (

            "".set push                                          
\t""

            "".set noreorder                                     
\t""



            ""lwc1       %[di0],     0(%[in_pos])                
\t""

            ""lwc1       %[di1],     4(%[in_pos])                
\t""

            ""lwc1       %[di2],     8(%[in_pos])                
\t""

            ""lwc1       %[di3],     12(%[in_pos])               
\t""

            ""abs.s      %[di0],     %[di0]                      
\t""

            ""abs.s      %[di1],     %[di1]                      
\t""

            ""abs.s      %[di2],     %[di2]                      
\t""

            ""abs.s      %[di3],     %[di3]                      
\t""

            ""lwc1       $f0,        0(%[vec])                   
\t""

            ""lwc1       $f1,        4(%[vec])                   
\t""

            ""lwc1       $f2,        0(%[vec2])                  
\t""

            ""lwc1       $f3,        4(%[vec2])                  
\t""

            ""nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   
\t""

            ""nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   
\t""

            ""nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   
\t""

            ""nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   
\t""



            "".set pop                                           
\t""



            : [ti1]""=&f""(ti1), [d3]""=&f""(d3),

              [mi0]""=&f""(mi0), [di3]""=&f""(di3)

            : [ in_flo]""r""( in_flo), [version]""r""(version),

              [vec5]""r""(vec5), [IQ]""f""(IQ)

            : ""$f0"", ""$f1"", ""$f2"", ""$f3"",

              ""memory""

        );



        cost += ti1 * ti1 + d3 * d3

                + mi0 * mi0 + di3 * di3;

    }



    if (units)

        *units = curbits;

    return cost * phi + curbits;

}
",1,1,0,1,"s,pb,in,scaled,size,scale_idx,cb,lambda,uplim,bits,i,qc1,qc2,qc3,qc4,p_bits,p_codes,vec,vec2,curidx,curidx2,sign1,count1,sign2,count2,in_int,in_pos,di0,di1,di2,di3,t0,t1,t2,t3,t4","s:0.00822514295578003,pb:9.357929229736328e-06,in:0.01241600513458252,scaled:0.014174580574035645,size:0.0021393895149230957,scale_idx:0.003682255744934082,cb:0.011066675186157227,lambda:0.003949761390686035,uplim:-0.003925979137420654,bits:0.00033605098724365234,i:0.007969200611114502,qc1:-0.00010597705841064453,qc2:-0.0007706880569458008,qc3:-0.00018465518951416016,qc4:-0.001298367977142334,p_bits:0.0005332231521606445,p_codes:-0.0013553500175476074,vec:0.0008981227874755859,vec2:-0.0010416507720947266,curidx:-0.0019878745079040527,curidx2:-0.0014481544494628906,sign1:0.0025222301483154297,count1:-0.001012265682220459,sign2:0.001404106616973877,count2:0.00046628713607788086,in_int:0.0007778406143188477,in_pos:-0.00010120868682861328,di0:-0.0007438063621520996,di1:1.6450881958007812e-05,di2:-0.0002067089080810547,di3:-0.0005046725273132324,t0:-0.000523984432220459,t1:-0.0004394054412841797,t2:9.85860824584961e-05,t3:0.0008636713027954102,t4:0.0016568899154663086,",30,110,"scaled:stilled,in:image,cb:crop,s:fs,i:io,lambda:phi,scale_idx:scale_ide,sign1:sum1,size:mode,t4:t04,sign2:sign0,vec:version,t3:t3,in_int:inc_index,p_bits:p_ops,count2:patch2,bits:units,t2:type4,di1:d3,pb:bps,in_pos: in_flo,qc1: qcone,qc3: qcs6,di2:mi0,t1:t1,di3:di3,t0:t00,di0:ti1,qc2:qcsFuture,count1:count1,vec2:vec5,qc4:qvc7,p_codes:p_codes,curidx2:curidx2,curidx: curIdc,uplim:Uplength,",Greedy,960,0.2974256237347921
145,"QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)

{

    JSONParserContext ctxt = {};

    QList *working = qlist_copy(tokens);

    QObject *result;



    result = parse_value(&ctxt, &working, ap);



    QDECREF(working);



    error_propagate(errp, ctxt.err);



    return result;

}
",68,,1,0,,-4,"tokens,ap,errp,working,result",,,,,Greedy,1,0.0019396066665649414
146,"static int init_directories(BDRVVVFATState* s,

                            const char *dirname, int heads, int secs,

                            Error **errp)

{

    bootsector_t* bootsector;

    mapping_t* mapping;

    unsigned int i;

    unsigned int cluster;



    memset(&(s->first_sectors[0]),0,0x40*0x200);



    s->cluster_size=s->sectors_per_cluster*0x200;

    s->cluster_buffer=g_malloc(s->cluster_size);



    /*

     * The formula: sc = spf+1+spf*spc*(512*8/fat_type),

     * where sc is sector_count,

     * spf is sectors_per_fat,

     * spc is sectors_per_clusters, and

     * fat_type = 12, 16 or 32.

     */

    i = 1+s->sectors_per_cluster*0x200*8/s->fat_type;

    s->sectors_per_fat=(s->sector_count+i)/i; /* round up */



    s->offset_to_fat = s->offset_to_bootsector + 1;

    s->offset_to_root_dir = s->offset_to_fat + s->sectors_per_fat * 2;



    array_init(&(s->mapping),sizeof(mapping_t));

    array_init(&(s->directory),sizeof(direntry_t));



    /* add volume label */

    {

        direntry_t* entry=array_get_next(&(s->directory));

        entry->attributes=0x28; /* archive | volume label */

        memcpy(entry->name, s->volume_label, sizeof(entry->name));

    }



    /* Now build FAT, and write back information into directory */

    init_fat(s);



    s->cluster_count=sector2cluster(s, s->sector_count);



    mapping = array_get_next(&(s->mapping));

    mapping->begin = 0;

    mapping->dir_index = 0;

    mapping->info.dir.parent_mapping_index = -1;

    mapping->first_mapping_index = -1;

    mapping->path = g_strdup(dirname);

    i = strlen(mapping->path);

    if (i > 0 && mapping->path[i - 1] == '/')

        mapping->path[i - 1] = '\0';

    mapping->mode = MODE_DIRECTORY;

    mapping->read_only = 0;

    s->path = mapping->path;



    for (i = 0, cluster = 0; i < s->mapping.next; i++) {

        /* MS-DOS expects the FAT to be 0 for the root directory

         * (except for the media byte). */

        /* LATER TODO: still true for FAT32? */

        int fix_fat = (i != 0);

        mapping = array_get(&(s->mapping), i);



        if (mapping->mode & MODE_DIRECTORY) {

            mapping->begin = cluster;

            if(read_directory(s, i)) {

                error_setg(errp, ""Could not read directory %s"",

                           mapping->path);

                return -1;

            }

            mapping = array_get(&(s->mapping), i);

        } else {

            assert(mapping->mode == MODE_UNDEFINED);

            mapping->mode=MODE_NORMAL;

            mapping->begin = cluster;

            if (mapping->end > 0) {

                direntry_t* direntry = array_get(&(s->directory),

                        mapping->dir_index);



                mapping->end = cluster + 1 + (mapping->end-1)/s->cluster_size;

                set_begin_of_direntry(direntry, mapping->begin);

            } else {

                mapping->end = cluster + 1;

                fix_fat = 0;

            }

        }



        assert(mapping->begin < mapping->end);



        /* next free cluster */

        cluster = mapping->end;



        if(cluster > s->cluster_count) {

            error_setg(errp,

                       ""Directory does not fit in FAT%d (capacity %.2f MB)"",

                       s->fat_type, s->sector_count / 2000.0);

            return -1;

        }



        /* fix fat for entry */

        if (fix_fat) {

            int j;

            for(j = mapping->begin; j < mapping->end - 1; j++)

                fat_set(s, j, j+1);

            fat_set(s, mapping->end - 1, s->max_fat_value);

        }

    }



    mapping = array_get(&(s->mapping), 0);

    s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster;

    s->last_cluster_of_root_directory = mapping->end;



    /* the FAT signature */

    fat_set(s,0,s->max_fat_value);

    fat_set(s,1,s->max_fat_value);



    s->current_mapping = NULL;



    bootsector = (bootsector_t *)(s->first_sectors

                                  + s->offset_to_bootsector * 0x200);

    bootsector->jump[0]=0xeb;

    bootsector->jump[1]=0x3e;

    bootsector->jump[2]=0x90;

    memcpy(bootsector->name,""QEMU    "",8);

    bootsector->sector_size=cpu_to_le16(0x200);

    bootsector->sectors_per_cluster=s->sectors_per_cluster;

    bootsector->reserved_sectors=cpu_to_le16(1);

    bootsector->number_of_fats=0x2; /* number of FATs */

    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);

    bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count);

    /* media descriptor: hard disk=0xf8, floppy=0xf0 */

    bootsector->media_type = (s->offset_to_bootsector > 0 ? 0xf8 : 0xf0);

    s->fat.pointer[0] = bootsector->media_type;

    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);

    bootsector->sectors_per_track = cpu_to_le16(secs);

    bootsector->number_of_heads = cpu_to_le16(heads);

    bootsector->hidden_sectors = cpu_to_le32(s->offset_to_bootsector);

    bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0);



    /* LATER TODO: if FAT32, this is wrong */

    /* drive_number: fda=0, hda=0x80 */

    bootsector->u.fat16.drive_number = s->offset_to_bootsector == 0 ? 0 : 0x80;

    bootsector->u.fat16.signature=0x29;

    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);



    memcpy(bootsector->u.fat16.volume_label, s->volume_label,

           sizeof(bootsector->u.fat16.volume_label));

    memcpy(bootsector->u.fat16.fat_type,

           s->fat_type == 12 ? ""FAT12   "" : ""FAT16   "", 8);

    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;



    return 0;

}
",1017,"static int init_directories(BDRVVVFATState* status,

                            const char *dirname, int heads, int secs,

                            Error **errp)

{

    bootsector_t* bootsector;

    mapping_t* mapping;

    unsigned int i;

    unsigned int cluster;



    memset(&(status->first_sectors[0]),0,0x40*0x200);



    status->cluster_size=status->sectors_per_cluster*0x200;

    status->cluster_buffer=g_malloc(status->cluster_size);



    /*

     * The formula: sc = spf+1+spf*spc*(512*8/fat_type),

     * where sc is sector_count,

     * spf is sectors_per_fat,

     * spc is sectors_per_clusters, and

     * fat_type = 12, 16 or 32.

     */

    i = 1+status->sectors_per_cluster*0x200*8/status->fat_type;

    status->sectors_per_fat=(status->sector_count+i)/i; /* round up */



    status->offset_to_fat = status->offset_to_bootsector + 1;

    status->offset_to_root_dir = status->offset_to_fat + status->sectors_per_fat * 2;



    array_init(&(status->mapping),sizeof(mapping_t));

    array_init(&(status->directory),sizeof(direntry_t));



    /* add volume label */

    {

        direntry_t* entry=array_get_next(&(status->directory));

        entry->attributes=0x28; /* archive | volume label */

        memcpy(entry->name, status->volume_label, sizeof(entry->name));

    }



    /* Now build FAT, and write back information into directory */

    init_fat(status);



    status->cluster_count=sector2cluster(status, status->sector_count);



    mapping = array_get_next(&(status->mapping));

    mapping->begin = 0;

    mapping->dir_index = 0;

    mapping->info.dir.parent_mapping_index = -1;

    mapping->first_mapping_index = -1;

    mapping->path = g_strdup(dirname);

    i = strlen(mapping->path);

    if (i > 0 && mapping->path[i - 1] == '/')

        mapping->path[i - 1] = '\0';

    mapping->mode = MODE_DIRECTORY;

    mapping->read_only = 0;

    status->path = mapping->path;



    for (i = 0, cluster = 0; i < status->mapping.next; i++) {

        /* MS-DOS expects the FAT to be 0 for the root directory

         * (except for the media byte). */

        /* LATER TODO: still true for FAT32? */

        int fix_fat = (i != 0);

        mapping = array_get(&(status->mapping), i);



        if (mapping->mode & MODE_DIRECTORY) {

            mapping->begin = cluster;

            if(read_directory(status, i)) {

                error_setg(errp, ""Could not read directory %s"",

                           mapping->path);

                return -1;

            }

            mapping = array_get(&(status->mapping), i);

        } else {

            assert(mapping->mode == MODE_UNDEFINED);

            mapping->mode=MODE_NORMAL;

            mapping->begin = cluster;

            if (mapping->end > 0) {

                direntry_t* direntry = array_get(&(status->directory),

                        mapping->dir_index);



                mapping->end = cluster + 1 + (mapping->end-1)/status->cluster_size;

                set_begin_of_direntry(direntry, mapping->begin);

            } else {

                mapping->end = cluster + 1;

                fix_fat = 0;

            }

        }



        assert(mapping->begin < mapping->end);



        /* next free cluster */

        cluster = mapping->end;



        if(cluster > status->cluster_count) {

            error_setg(errp,

                       ""Directory does not fit in FAT%d (capacity %.2f MB)"",

                       status->fat_type, status->sector_count / 2000.0);

            return -1;

        }



        /* fix fat for entry */

        if (fix_fat) {

            int j;

            for(j = mapping->begin; j < mapping->end - 1; j++)

                fat_set(status, j, j+1);

            fat_set(status, mapping->end - 1, status->max_fat_value);

        }

    }



    mapping = array_get(&(status->mapping), 0);

    status->sectors_of_root_directory = mapping->end * status->sectors_per_cluster;

    status->last_cluster_of_root_directory = mapping->end;



    /* the FAT signature */

    fat_set(status,0,status->max_fat_value);

    fat_set(status,1,status->max_fat_value);



    status->current_mapping = NULL;



    bootsector = (bootsector_t *)(status->first_sectors

                                  + status->offset_to_bootsector * 0x200);

    bootsector->jump[0]=0xeb;

    bootsector->jump[1]=0x3e;

    bootsector->jump[2]=0x90;

    memcpy(bootsector->name,""QEMU    "",8);

    bootsector->sector_size=cpu_to_le16(0x200);

    bootsector->sectors_per_cluster=status->sectors_per_cluster;

    bootsector->reserved_sectors=cpu_to_le16(1);

    bootsector->number_of_fats=0x2; /* number of FATs */

    bootsector->root_entries=cpu_to_le16(status->sectors_of_root_directory*0x10);

    bootsector->total_sectors16=status->sector_count>0xffff?0:cpu_to_le16(status->sector_count);

    /* media descriptor: hard disk=0xf8, floppy=0xf0 */

    bootsector->media_type = (status->offset_to_bootsector > 0 ? 0xf8 : 0xf0);

    status->fat.pointer[0] = bootsector->media_type;

    bootsector->sectors_per_fat=cpu_to_le16(status->sectors_per_fat);

    bootsector->sectors_per_track = cpu_to_le16(secs);

    bootsector->number_of_heads = cpu_to_le16(heads);

    bootsector->hidden_sectors = cpu_to_le32(status->offset_to_bootsector);

    bootsector->total_sectors=cpu_to_le32(status->sector_count>0xffff?status->sector_count:0);



    /* LATER TODO: if FAT32, this is wrong */

    /* drive_number: fda=0, hda=0x80 */

    bootsector->u.fat16.drive_number = status->offset_to_bootsector == 0 ? 0 : 0x80;

    bootsector->u.fat16.signature=0x29;

    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);



    memcpy(bootsector->u.fat16.volume_label, status->volume_label,

           sizeof(bootsector->u.fat16.volume_label));

    memcpy(bootsector->u.fat16.fat_type,

           status->fat_type == 12 ? ""FAT12   "" : ""FAT16   "", 8);

    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;



    return 0;

}
",1,1,0,1,"s,dirname,heads,secs,errp,bootsector,mapping,i,cluster,entry","s:0.41787225008010864,dirname:0.024769872426986694,heads:-0.009896337985992432,secs:0.056554824113845825,errp:0.003303438425064087,bootsector:-0.0003229379653930664,mapping:0.17196741700172424,i:0.2150229513645172,cluster:0.04789990186691284,entry:0.12551656365394592,",1,61,"s:status,",Greedy,246,0.05663581689198812
147,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    s->freq = PXA25X_FREQ;

    s->tm4 = NULL;

}
",35,"void pxa25x_timer_init(target_phys_addr_t ace, qemu_irq * irquest)

{

    pxa2xx_timer_info *ssl = pxa2xx_timer_init(ace,  irquest);

    ssl->freq = PXA25X_FREQ;

    ssl->tm4 = NULL;

}
",0,0,0,-1,"base,irqs,s","base:0.001055101864039898,irqs:-0.00016687065362930298,s:-0.00015086354687809944,",3,7,"base:ace,s:ssl,irqs: irquest,",Greedy,114,0.023128032684326172
148,"struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size,

                const char *core)

{

    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)

            g_malloc0(sizeof(struct omap_mpu_state_s));

    ram_addr_t sram_base, q2_base;

    qemu_irq *cpu_irq;

    qemu_irq dma_irqs[4];

    DriveInfo *dinfo;

    int i;

    SysBusDevice *busdev;

    struct omap_target_agent_s *ta;



    /* Core */

    s->mpu_model = omap2420;

    s->env = cpu_init(core ?: ""arm1136-r2"");

    if (!s->env) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }

    s->sdram_size = sdram_size;

    s->sram_size = OMAP242X_SRAM_SIZE;



    s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];



    /* Clocks */

    omap_clk_init(s);



    /* Memory-mapped stuff */

    cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size,

                    (q2_base = qemu_ram_alloc(NULL, ""omap2.dram"",

                                              s->sdram_size)) | IO_MEM_RAM);

    cpu_register_physical_memory(OMAP2_SRAM_BASE, s->sram_size,

                    (sram_base = qemu_ram_alloc(NULL, ""omap2.sram"",

                                                s->sram_size)) | IO_MEM_RAM);



    s->l4 = omap_l4_init(OMAP2_L4_BASE, 54);



    /* Actually mapped at any 2K boundary in the ARM11 private-peripheral if */

    cpu_irq = arm_pic_init_cpu(s->env);

    s->ih[0] = omap2_inth_init(0x480fe000, 0x1000, 3, &s->irq[0],

                    cpu_irq[ARM_PIC_CPU_IRQ], cpu_irq[ARM_PIC_CPU_FIQ],

                    omap_findclk(s, ""mpu_intc_fclk""),

                    omap_findclk(s, ""mpu_intc_iclk""));



    s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3),

                    s->irq[0][OMAP_INT_24XX_PRCM_MPU_IRQ], NULL, NULL, s);



    s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1),

                    omap_findclk(s, ""omapctrl_iclk""), s);



    for (i = 0; i < 4; i ++)

        dma_irqs[i] =

                s->irq[omap2_dma_irq_map[i].ih][omap2_dma_irq_map[i].intr];

    s->dma = omap_dma4_init(0x48056000, dma_irqs, s, 256, 32,

                    omap_findclk(s, ""sdma_iclk""),

                    omap_findclk(s, ""sdma_fclk""));

    s->port->addr_valid = omap2_validate_addr;



    /* Register SDRAM and SRAM ports for fast DMA transfers.  */

    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(q2_base),

                         OMAP2_Q2_BASE, s->sdram_size);

    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(sram_base),

                         OMAP2_SRAM_BASE, s->sram_size);



    s->uart[0] = omap2_uart_init(omap_l4ta(s->l4, 19),

                    s->irq[0][OMAP_INT_24XX_UART1_IRQ],

                    omap_findclk(s, ""uart1_fclk""),

                    omap_findclk(s, ""uart1_iclk""),

                    s->drq[OMAP24XX_DMA_UART1_TX],

                    s->drq[OMAP24XX_DMA_UART1_RX],

                    ""uart1"",

                    serial_hds[0]);

    s->uart[1] = omap2_uart_init(omap_l4ta(s->l4, 20),

                    s->irq[0][OMAP_INT_24XX_UART2_IRQ],

                    omap_findclk(s, ""uart2_fclk""),

                    omap_findclk(s, ""uart2_iclk""),

                    s->drq[OMAP24XX_DMA_UART2_TX],

                    s->drq[OMAP24XX_DMA_UART2_RX],

                    ""uart2"",

                    serial_hds[0] ? serial_hds[1] : NULL);

    s->uart[2] = omap2_uart_init(omap_l4ta(s->l4, 21),

                    s->irq[0][OMAP_INT_24XX_UART3_IRQ],

                    omap_findclk(s, ""uart3_fclk""),

                    omap_findclk(s, ""uart3_iclk""),

                    s->drq[OMAP24XX_DMA_UART3_TX],

                    s->drq[OMAP24XX_DMA_UART3_RX],

                    ""uart3"",

                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);



    s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7),

                    s->irq[0][OMAP_INT_24XX_GPTIMER1],

                    omap_findclk(s, ""wu_gpt1_clk""),

                    omap_findclk(s, ""wu_l4_iclk""));

    s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8),

                    s->irq[0][OMAP_INT_24XX_GPTIMER2],

                    omap_findclk(s, ""core_gpt2_clk""),

                    omap_findclk(s, ""core_l4_iclk""));

    s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22),

                    s->irq[0][OMAP_INT_24XX_GPTIMER3],

                    omap_findclk(s, ""core_gpt3_clk""),

                    omap_findclk(s, ""core_l4_iclk""));

    s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23),

                    s->irq[0][OMAP_INT_24XX_GPTIMER4],

                    omap_findclk(s, ""core_gpt4_clk""),

                    omap_findclk(s, ""core_l4_iclk""));

    s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24),

                    s->irq[0][OMAP_INT_24XX_GPTIMER5],

                    omap_findclk(s, ""core_gpt5_clk""),

                    omap_findclk(s, ""core_l4_iclk""));

    s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25),

                    s->irq[0][OMAP_INT_24XX_GPTIMER6],

                    omap_findclk(s, ""core_gpt6_clk""),

                    omap_findclk(s, ""core_l4_iclk""));

    s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26),

                    s->irq[0][OMAP_INT_24XX_GPTIMER7],

                    omap_findclk(s, ""core_gpt7_clk""),

                    omap_findclk(s, ""core_l4_iclk""));

    s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27),

                    s->irq[0][OMAP_INT_24XX_GPTIMER8],

                    omap_findclk(s, ""core_gpt8_clk""),

                    omap_findclk(s, ""core_l4_iclk""));

    s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28),

                    s->irq[0][OMAP_INT_24XX_GPTIMER9],

                    omap_findclk(s, ""core_gpt9_clk""),

                    omap_findclk(s, ""core_l4_iclk""));

    s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29),

                    s->irq[0][OMAP_INT_24XX_GPTIMER10],

                    omap_findclk(s, ""core_gpt10_clk""),

                    omap_findclk(s, ""core_l4_iclk""));

    s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30),

                    s->irq[0][OMAP_INT_24XX_GPTIMER11],

                    omap_findclk(s, ""core_gpt11_clk""),

                    omap_findclk(s, ""core_l4_iclk""));

    s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31),

                    s->irq[0][OMAP_INT_24XX_GPTIMER12],

                    omap_findclk(s, ""core_gpt12_clk""),

                    omap_findclk(s, ""core_l4_iclk""));



    omap_tap_init(omap_l4ta(s->l4, 2), s);



    s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s,

                    omap_findclk(s, ""clk32-kHz""),

                    omap_findclk(s, ""core_l4_iclk""));



    s->i2c[0] = omap2_i2c_init(omap_l4tao(s->l4, 5),

                    s->irq[0][OMAP_INT_24XX_I2C1_IRQ],

                    &s->drq[OMAP24XX_DMA_I2C1_TX],

                    omap_findclk(s, ""i2c1.fclk""),

                    omap_findclk(s, ""i2c1.iclk""));

    s->i2c[1] = omap2_i2c_init(omap_l4tao(s->l4, 6),

                    s->irq[0][OMAP_INT_24XX_I2C2_IRQ],

                    &s->drq[OMAP24XX_DMA_I2C2_TX],

                    omap_findclk(s, ""i2c2.fclk""),

                    omap_findclk(s, ""i2c2.iclk""));



    s->gpio = qdev_create(NULL, ""omap2-gpio"");

    qdev_prop_set_int32(s->gpio, ""mpu_model"", s->mpu_model);

    qdev_prop_set_ptr(s->gpio, ""iclk"", omap_findclk(s, ""gpio_iclk""));

    qdev_prop_set_ptr(s->gpio, ""fclk0"", omap_findclk(s, ""gpio1_dbclk""));

    qdev_prop_set_ptr(s->gpio, ""fclk1"", omap_findclk(s, ""gpio2_dbclk""));

    qdev_prop_set_ptr(s->gpio, ""fclk2"", omap_findclk(s, ""gpio3_dbclk""));

    qdev_prop_set_ptr(s->gpio, ""fclk3"", omap_findclk(s, ""gpio4_dbclk""));

    if (s->mpu_model == omap2430) {

        qdev_prop_set_ptr(s->gpio, ""fclk4"", omap_findclk(s, ""gpio5_dbclk""));

    }

    qdev_init_nofail(s->gpio);

    busdev = sysbus_from_qdev(s->gpio);

    sysbus_connect_irq(busdev, 0, s->irq[0][OMAP_INT_24XX_GPIO_BANK1]);

    sysbus_connect_irq(busdev, 3, s->irq[0][OMAP_INT_24XX_GPIO_BANK2]);

    sysbus_connect_irq(busdev, 6, s->irq[0][OMAP_INT_24XX_GPIO_BANK3]);

    sysbus_connect_irq(busdev, 9, s->irq[0][OMAP_INT_24XX_GPIO_BANK4]);

    ta = omap_l4ta(s->l4, 3);

    sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1));

    sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0));

    sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2));

    sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4));

    sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5));



    s->sdrc = omap_sdrc_init(0x68009000);

    s->gpmc = omap_gpmc_init(s, 0x6800a000, s->irq[0][OMAP_INT_24XX_GPMC_IRQ],

                             s->drq[OMAP24XX_DMA_GPMC]);



    dinfo = drive_get(IF_SD, 0, 0);

    if (!dinfo) {

        fprintf(stderr, ""qemu: missing SecureDigital device\n"");

        exit(1);

    }

    s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9), dinfo->bdrv,

                    s->irq[0][OMAP_INT_24XX_MMC_IRQ],

                    &s->drq[OMAP24XX_DMA_MMC1_TX],

                    omap_findclk(s, ""mmc_fclk""), omap_findclk(s, ""mmc_iclk""));



    s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4,

                    s->irq[0][OMAP_INT_24XX_MCSPI1_IRQ],

                    &s->drq[OMAP24XX_DMA_SPI1_TX0],

                    omap_findclk(s, ""spi1_fclk""),

                    omap_findclk(s, ""spi1_iclk""));

    s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2,

                    s->irq[0][OMAP_INT_24XX_MCSPI2_IRQ],

                    &s->drq[OMAP24XX_DMA_SPI2_TX0],

                    omap_findclk(s, ""spi2_fclk""),

                    omap_findclk(s, ""spi2_iclk""));



    s->dss = omap_dss_init(omap_l4ta(s->l4, 10), 0x68000800,

                    /* XXX wire M_IRQ_25, D_L2_IRQ_30 and I_IRQ_13 together */

                    s->irq[0][OMAP_INT_24XX_DSS_IRQ], s->drq[OMAP24XX_DMA_DSS],

                    omap_findclk(s, ""dss_clk1""), omap_findclk(s, ""dss_clk2""),

                    omap_findclk(s, ""dss_54m_clk""),

                    omap_findclk(s, ""dss_l3_iclk""),

                    omap_findclk(s, ""dss_l4_iclk""));



    omap_sti_init(omap_l4ta(s->l4, 18), 0x54000000,

                    s->irq[0][OMAP_INT_24XX_STI], omap_findclk(s, ""emul_ck""),

                    serial_hds[0] && serial_hds[1] && serial_hds[2] ?

                    serial_hds[3] : NULL);



    s->eac = omap_eac_init(omap_l4ta(s->l4, 32),

                    s->irq[0][OMAP_INT_24XX_EAC_IRQ],

                    /* Ten consecutive lines */

                    &s->drq[OMAP24XX_DMA_EAC_AC_RD],

                    omap_findclk(s, ""func_96m_clk""),

                    omap_findclk(s, ""core_l4_iclk""));



    /* All register mappings (includin those not currenlty implemented):

     * SystemControlMod	48000000 - 48000fff

     * SystemControlL4	48001000 - 48001fff

     * 32kHz Timer Mod	48004000 - 48004fff

     * 32kHz Timer L4	48005000 - 48005fff

     * PRCM ModA	48008000 - 480087ff

     * PRCM ModB	48008800 - 48008fff

     * PRCM L4		48009000 - 48009fff

     * TEST-BCM Mod	48012000 - 48012fff

     * TEST-BCM L4	48013000 - 48013fff

     * TEST-TAP Mod	48014000 - 48014fff

     * TEST-TAP L4	48015000 - 48015fff

     * GPIO1 Mod	48018000 - 48018fff

     * GPIO Top		48019000 - 48019fff

     * GPIO2 Mod	4801a000 - 4801afff

     * GPIO L4		4801b000 - 4801bfff

     * GPIO3 Mod	4801c000 - 4801cfff

     * GPIO4 Mod	4801e000 - 4801efff

     * WDTIMER1 Mod	48020000 - 48010fff

     * WDTIMER Top	48021000 - 48011fff

     * WDTIMER2 Mod	48022000 - 48012fff

     * WDTIMER L4	48023000 - 48013fff

     * WDTIMER3 Mod	48024000 - 48014fff

     * WDTIMER3 L4	48025000 - 48015fff

     * WDTIMER4 Mod	48026000 - 48016fff

     * WDTIMER4 L4	48027000 - 48017fff

     * GPTIMER1 Mod	48028000 - 48018fff

     * GPTIMER1 L4	48029000 - 48019fff

     * GPTIMER2 Mod	4802a000 - 4801afff

     * GPTIMER2 L4	4802b000 - 4801bfff

     * L4-Config AP	48040000 - 480407ff

     * L4-Config IP	48040800 - 48040fff

     * L4-Config LA	48041000 - 48041fff

     * ARM11ETB Mod	48048000 - 48049fff

     * ARM11ETB L4	4804a000 - 4804afff

     * DISPLAY Top	48050000 - 480503ff

     * DISPLAY DISPC	48050400 - 480507ff

     * DISPLAY RFBI	48050800 - 48050bff

     * DISPLAY VENC	48050c00 - 48050fff

     * DISPLAY L4	48051000 - 48051fff

     * CAMERA Top	48052000 - 480523ff

     * CAMERA core	48052400 - 480527ff

     * CAMERA DMA	48052800 - 48052bff

     * CAMERA MMU	48052c00 - 48052fff

     * CAMERA L4	48053000 - 48053fff

     * SDMA Mod		48056000 - 48056fff

     * SDMA L4		48057000 - 48057fff

     * SSI Top		48058000 - 48058fff

     * SSI GDD		48059000 - 48059fff

     * SSI Port1	4805a000 - 4805afff

     * SSI Port2	4805b000 - 4805bfff

     * SSI L4		4805c000 - 4805cfff

     * USB Mod		4805e000 - 480fefff

     * USB L4		4805f000 - 480fffff

     * WIN_TRACER1 Mod	48060000 - 48060fff

     * WIN_TRACER1 L4	48061000 - 48061fff

     * WIN_TRACER2 Mod	48062000 - 48062fff

     * WIN_TRACER2 L4	48063000 - 48063fff

     * WIN_TRACER3 Mod	48064000 - 48064fff

     * WIN_TRACER3 L4	48065000 - 48065fff

     * WIN_TRACER4 Top	48066000 - 480660ff

     * WIN_TRACER4 ETT	48066100 - 480661ff

     * WIN_TRACER4 WT	48066200 - 480662ff

     * WIN_TRACER4 L4	48067000 - 48067fff

     * XTI Mod		48068000 - 48068fff

     * XTI L4		48069000 - 48069fff

     * UART1 Mod	4806a000 - 4806afff

     * UART1 L4		4806b000 - 4806bfff

     * UART2 Mod	4806c000 - 4806cfff

     * UART2 L4		4806d000 - 4806dfff

     * UART3 Mod	4806e000 - 4806efff

     * UART3 L4		4806f000 - 4806ffff

     * I2C1 Mod		48070000 - 48070fff

     * I2C1 L4		48071000 - 48071fff

     * I2C2 Mod		48072000 - 48072fff

     * I2C2 L4		48073000 - 48073fff

     * McBSP1 Mod	48074000 - 48074fff

     * McBSP1 L4	48075000 - 48075fff

     * McBSP2 Mod	48076000 - 48076fff

     * McBSP2 L4	48077000 - 48077fff

     * GPTIMER3 Mod	48078000 - 48078fff

     * GPTIMER3 L4	48079000 - 48079fff

     * GPTIMER4 Mod	4807a000 - 4807afff

     * GPTIMER4 L4	4807b000 - 4807bfff

     * GPTIMER5 Mod	4807c000 - 4807cfff

     * GPTIMER5 L4	4807d000 - 4807dfff

     * GPTIMER6 Mod	4807e000 - 4807efff

     * GPTIMER6 L4	4807f000 - 4807ffff

     * GPTIMER7 Mod	48080000 - 48080fff

     * GPTIMER7 L4	48081000 - 48081fff

     * GPTIMER8 Mod	48082000 - 48082fff

     * GPTIMER8 L4	48083000 - 48083fff

     * GPTIMER9 Mod	48084000 - 48084fff

     * GPTIMER9 L4	48085000 - 48085fff

     * GPTIMER10 Mod	48086000 - 48086fff

     * GPTIMER10 L4	48087000 - 48087fff

     * GPTIMER11 Mod	48088000 - 48088fff

     * GPTIMER11 L4	48089000 - 48089fff

     * GPTIMER12 Mod	4808a000 - 4808afff

     * GPTIMER12 L4	4808b000 - 4808bfff

     * EAC Mod		48090000 - 48090fff

     * EAC L4		48091000 - 48091fff

     * FAC Mod		48092000 - 48092fff

     * FAC L4		48093000 - 48093fff

     * MAILBOX Mod	48094000 - 48094fff

     * MAILBOX L4	48095000 - 48095fff

     * SPI1 Mod		48098000 - 48098fff

     * SPI1 L4		48099000 - 48099fff

     * SPI2 Mod		4809a000 - 4809afff

     * SPI2 L4		4809b000 - 4809bfff

     * MMC/SDIO Mod	4809c000 - 4809cfff

     * MMC/SDIO L4	4809d000 - 4809dfff

     * MS_PRO Mod	4809e000 - 4809efff

     * MS_PRO L4	4809f000 - 4809ffff

     * RNG Mod		480a0000 - 480a0fff

     * RNG L4		480a1000 - 480a1fff

     * DES3DES Mod	480a2000 - 480a2fff

     * DES3DES L4	480a3000 - 480a3fff

     * SHA1MD5 Mod	480a4000 - 480a4fff

     * SHA1MD5 L4	480a5000 - 480a5fff

     * AES Mod		480a6000 - 480a6fff

     * AES L4		480a7000 - 480a7fff

     * PKA Mod		480a8000 - 480a9fff

     * PKA L4		480aa000 - 480aafff

     * MG Mod		480b0000 - 480b0fff

     * MG L4		480b1000 - 480b1fff

     * HDQ/1-wire Mod	480b2000 - 480b2fff

     * HDQ/1-wire L4	480b3000 - 480b3fff

     * MPU interrupt	480fe000 - 480fefff

     * STI channel base	54000000 - 5400ffff

     * IVA RAM		5c000000 - 5c01ffff

     * IVA ROM		5c020000 - 5c027fff

     * IMG_BUF_A	5c040000 - 5c040fff

     * IMG_BUF_B	5c042000 - 5c042fff

     * VLCDS		5c048000 - 5c0487ff

     * IMX_COEF		5c049000 - 5c04afff

     * IMX_CMD		5c051000 - 5c051fff

     * VLCDQ		5c053000 - 5c0533ff

     * VLCDH		5c054000 - 5c054fff

     * SEQ_CMD		5c055000 - 5c055fff

     * IMX_REG		5c056000 - 5c0560ff

     * VLCD_REG		5c056100 - 5c0561ff

     * SEQ_REG		5c056200 - 5c0562ff

     * IMG_BUF_REG	5c056300 - 5c0563ff

     * SEQIRQ_REG	5c056400 - 5c0564ff

     * OCP_REG		5c060000 - 5c060fff

     * SYSC_REG		5c070000 - 5c070fff

     * MMU_REG		5d000000 - 5d000fff

     * sDMA R		68000400 - 680005ff

     * sDMA W		68000600 - 680007ff

     * Display Control	68000800 - 680009ff

     * DSP subsystem	68000a00 - 68000bff

     * MPU subsystem	68000c00 - 68000dff

     * IVA subsystem	68001000 - 680011ff

     * USB		68001200 - 680013ff

     * Camera		68001400 - 680015ff

     * VLYNQ (firewall)	68001800 - 68001bff

     * VLYNQ		68001e00 - 68001fff

     * SSI		68002000 - 680021ff

     * L4		68002400 - 680025ff

     * DSP (firewall)	68002800 - 68002bff

     * DSP subsystem	68002e00 - 68002fff

     * IVA (firewall)	68003000 - 680033ff

     * IVA		68003600 - 680037ff

     * GFX		68003a00 - 68003bff

     * CMDWR emulation	68003c00 - 68003dff

     * SMS		68004000 - 680041ff

     * OCM		68004200 - 680043ff

     * GPMC		68004400 - 680045ff

     * RAM (firewall)	68005000 - 680053ff

     * RAM (err login)	68005400 - 680057ff

     * ROM (firewall)	68005800 - 68005bff

     * ROM (err login)	68005c00 - 68005fff

     * GPMC (firewall)	68006000 - 680063ff

     * GPMC (err login)	68006400 - 680067ff

     * SMS (err login)	68006c00 - 68006fff

     * SMS registers	68008000 - 68008fff

     * SDRC registers	68009000 - 68009fff

     * GPMC registers	6800a000   6800afff

     */



    qemu_register_reset(omap2_mpu_reset, s);



    return s;

}
",2082,,0,1,,-4,"sdram_size,core,s,sram_base,q2_base,cpu_irq,dma_irqs,dinfo,i,busdev,ta",,,,,Greedy,1,0.0029428958892822265
149,"static void tcg_out_qemu_ld_slow_path (TCGContext *s, TCGLabelQemuLdst *label)

{

    int s_bits;

    int ir;

    int opc = label->opc;

    int mem_index = label->mem_index;

    int data_reg = label->datalo_reg;

    int data_reg2 = label->datahi_reg;

    int addr_reg = label->addrlo_reg;

    uint8_t *raddr = label->raddr;

    uint8_t **label_ptr = &label->label_ptr[0];



    s_bits = opc & 3;



    /* resolve label address */

    reloc_pc14 (label_ptr[0], (tcg_target_long) s->code_ptr);



    /* slow path */

    ir = 3;

    tcg_out_mov (s, TCG_TYPE_I32, ir++, TCG_AREG0);

#if TARGET_LONG_BITS == 32

    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);

#else

#ifdef TCG_TARGET_CALL_ALIGN_ARGS

    ir |= 1;

#endif

    tcg_out_mov (s, TCG_TYPE_I32, ir++, label->addrhi_reg);

    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);

#endif

    tcg_out_movi (s, TCG_TYPE_I32, ir, mem_index);

    tcg_out_call (s, (tcg_target_long) qemu_ld_helpers[s_bits], 1);

    tcg_out32 (s, B | 8);

    tcg_out32 (s, (tcg_target_long) raddr);

    switch (opc) {

    case 0|4:

        tcg_out32 (s, EXTSB | RA (data_reg) | RS (3));

        break;

    case 1|4:

        tcg_out32 (s, EXTSH | RA (data_reg) | RS (3));

        break;

    case 0:

    case 1:

    case 2:

        if (data_reg != 3)

            tcg_out_mov (s, TCG_TYPE_I32, data_reg, 3);

        break;

    case 3:

        if (data_reg == 3) {

            if (data_reg2 == 4) {

                tcg_out_mov (s, TCG_TYPE_I32, 0, 4);

                tcg_out_mov (s, TCG_TYPE_I32, 4, 3);

                tcg_out_mov (s, TCG_TYPE_I32, 3, 0);

            }

            else {

                tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);

                tcg_out_mov (s, TCG_TYPE_I32, 3, 4);

            }

        }

        else {

            if (data_reg != 4) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 4);

            if (data_reg2 != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);

        }

        break;

    }

    /* Jump to the code corresponding to next IR of qemu_st */

    tcg_out_b (s, 0, (tcg_target_long) raddr);

}
",420,"static void tcg_out_qemu_ld_slow_path (TCGContext *services, TCGLabelQemuLdst *bel)

{

    int  s_details;

    int err;

    int opc = bel->opc;

    int mem_index = bel->mem_index;

    int data_reg = bel->datalo_reg;

    int data_reg2 = bel->datahi_reg;

    int addr_reg = bel->addrlo_reg;

    uint8_t *paddr = bel->paddr;

    uint8_t **data_ptr = &bel->data_ptr[0];



     s_details = opc & 3;



    /* resolve label address */

    reloc_pc14 (data_ptr[0], (tcg_target_long) services->code_ptr);



    /* slow path */

    err = 3;

    tcg_out_mov (services, TCG_TYPE_I32, err++, TCG_AREG0);

#if TARGET_LONG_BITS == 32

    tcg_out_mov (services, TCG_TYPE_I32, err++, addr_reg);

#else

#ifdef TCG_TARGET_CALL_ALIGN_ARGS

    err |= 1;

#endif

    tcg_out_mov (services, TCG_TYPE_I32, err++, bel->addrhi_reg);

    tcg_out_mov (services, TCG_TYPE_I32, err++, addr_reg);

#endif

    tcg_out_movi (services, TCG_TYPE_I32, err, mem_index);

    tcg_out_call (services, (tcg_target_long) qemu_ld_helpers[ s_details], 1);

    tcg_out32 (services, B | 8);

    tcg_out32 (services, (tcg_target_long) paddr);

    switch (opc) {

    case 0|4:

        tcg_out32 (services, EXTSB | RA (data_reg) | RS (3));

        break;

    case 1|4:

        tcg_out32 (services, EXTSH | RA (data_reg) | RS (3));

        break;

    case 0:

    case 1:

    case 2:

        if (data_reg != 3)

            tcg_out_mov (services, TCG_TYPE_I32, data_reg, 3);

        break;

    case 3:

        if (data_reg == 3) {

            if (data_reg2 == 4) {

                tcg_out_mov (services, TCG_TYPE_I32, 0, 4);

                tcg_out_mov (services, TCG_TYPE_I32, 4, 3);

                tcg_out_mov (services, TCG_TYPE_I32, 3, 0);

            }

            else {

                tcg_out_mov (services, TCG_TYPE_I32, data_reg2, 3);

                tcg_out_mov (services, TCG_TYPE_I32, 3, 4);

            }

        }

        else {

            if (data_reg != 4) tcg_out_mov (services, TCG_TYPE_I32, data_reg, 4);

            if (data_reg2 != 3) tcg_out_mov (services, TCG_TYPE_I32, data_reg2, 3);

        }

        break;

    }

    /* Jump to the code corresponding to next IR of qemu_st */

    tcg_out_b (services, 0, (tcg_target_long) paddr);

}
",0,0,0,-1,"s,label,s_bits,ir,raddr,label_ptr","s:-0.021195835433900356,label:-0.0034930305555462837,s_bits:0.00027185864746570587,ir:-0.014907808974385262,raddr:-0.0016040923073887825,label_ptr:-0.010267168283462524,",6,48,"s_bits: s_details,raddr:paddr,label:bel,label_ptr:data_ptr,ir:err,s:services,",Greedy,353,0.07324345111846924
150,"static int nbd_negotiate_handle_info(NBDClient *client, uint32_t length,

                                     uint32_t opt, uint16_t myflags,

                                     Error **errp)

{

    int rc;

    char name[NBD_MAX_NAME_SIZE + 1];

    NBDExport *exp;

    uint16_t requests;

    uint16_t request;

    uint32_t namelen;

    bool sendname = false;

    bool blocksize = false;

    uint32_t sizes[3];

    char buf[sizeof(uint64_t) + sizeof(uint16_t)];

    const char *msg;



    /* Client sends:

        4 bytes: L, name length (can be 0)

        L bytes: export name

        2 bytes: N, number of requests (can be 0)

        N * 2 bytes: N requests

    */

    if (length < sizeof(namelen) + sizeof(requests)) {

        msg = ""overall request too short"";

        goto invalid;

    }

    if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) {

        return -EIO;

    }

    be32_to_cpus(&namelen);

    length -= sizeof(namelen);

    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {

        msg = ""name length is incorrect"";

        goto invalid;

    }

    if (nbd_read(client->ioc, name, namelen, errp) < 0) {

        return -EIO;

    }

    name[namelen] = '\0';

    length -= namelen;

    trace_nbd_negotiate_handle_export_name_request(name);



    if (nbd_read(client->ioc, &requests, sizeof(requests), errp) < 0) {

        return -EIO;

    }

    be16_to_cpus(&requests);

    length -= sizeof(requests);

    trace_nbd_negotiate_handle_info_requests(requests);

    if (requests != length / sizeof(request)) {

        msg = ""incorrect number of  requests for overall length"";

        goto invalid;

    }

    while (requests--) {

        if (nbd_read(client->ioc, &request, sizeof(request), errp) < 0) {

            return -EIO;

        }

        be16_to_cpus(&request);

        length -= sizeof(request);

        trace_nbd_negotiate_handle_info_request(request,

                                                nbd_info_lookup(request));

        /* We care about NBD_INFO_NAME and NBD_INFO_BLOCK_SIZE;

         * everything else is either a request we don't know or

         * something we send regardless of request */

        switch (request) {

        case NBD_INFO_NAME:

            sendname = true;

            break;

        case NBD_INFO_BLOCK_SIZE:

            blocksize = true;

            break;

        }

    }



    exp = nbd_export_find(name);

    if (!exp) {

        return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNKNOWN,

                                          opt, errp, ""export '%s' not present"",

                                          name);

    }



    /* Don't bother sending NBD_INFO_NAME unless client requested it */

    if (sendname) {

        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_NAME, length, name,

                                     errp);

        if (rc < 0) {

            return rc;

        }

    }



    /* Send NBD_INFO_DESCRIPTION only if available, regardless of

     * client request */

    if (exp->description) {

        size_t len = strlen(exp->description);



        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_DESCRIPTION,

                                     len, exp->description, errp);

        if (rc < 0) {

            return rc;

        }

    }



    /* Send NBD_INFO_BLOCK_SIZE always, but tweak the minimum size

     * according to whether the client requested it, and according to

     * whether this is OPT_INFO or OPT_GO. */

    /* minimum - 1 for back-compat, or 512 if client is new enough.

     * TODO: consult blk_bs(blk)->bl.request_alignment? */

    sizes[0] = (opt == NBD_OPT_INFO || blocksize) ? BDRV_SECTOR_SIZE : 1;

    /* preferred - Hard-code to 4096 for now.

     * TODO: is blk_bs(blk)->bl.opt_transfer appropriate? */

    sizes[1] = 4096;

    /* maximum - At most 32M, but smaller as appropriate. */

    sizes[2] = MIN(blk_get_max_transfer(exp->blk), NBD_MAX_BUFFER_SIZE);

    trace_nbd_negotiate_handle_info_block_size(sizes[0], sizes[1], sizes[2]);

    cpu_to_be32s(&sizes[0]);

    cpu_to_be32s(&sizes[1]);

    cpu_to_be32s(&sizes[2]);

    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_BLOCK_SIZE,

                                 sizeof(sizes), sizes, errp);

    if (rc < 0) {

        return rc;

    }



    /* Send NBD_INFO_EXPORT always */

    trace_nbd_negotiate_new_style_size_flags(exp->size,

                                             exp->nbdflags | myflags);

    stq_be_p(buf, exp->size);

    stw_be_p(buf + 8, exp->nbdflags | myflags);

    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_EXPORT,

                                 sizeof(buf), buf, errp);

    if (rc < 0) {

        return rc;

    }



    /* If the client is just asking for NBD_OPT_INFO, but forgot to

     * request block sizes, return an error.

     * TODO: consult blk_bs(blk)->request_align, and only error if it

     * is not 1? */

    if (opt == NBD_OPT_INFO && !blocksize) {

        return nbd_negotiate_send_rep_err(client->ioc,

                                          NBD_REP_ERR_BLOCK_SIZE_REQD, opt,

                                          errp,

                                          ""request NBD_INFO_BLOCK_SIZE to ""

                                          ""use this export"");

    }



    /* Final reply */

    rc = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, opt, errp);

    if (rc < 0) {

        return rc;

    }



    if (opt == NBD_OPT_GO) {

        client->exp = exp;

        QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);

        nbd_export_get(client->exp);

        rc = 1;

    }

    return rc;



 invalid:

    if (nbd_drop(client->ioc, length, errp) < 0) {

        return -EIO;

    }

    return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, opt,

                                      errp, ""%s"", msg);

}
",802,,0,1,,-4,"client,length,opt,myflags,errp,rc,name,requests,request,namelen,sizes,buf,msg",,,,,Greedy,1,0.00250925620396932
151,"static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)

{

    switch (buf[0]) {

    /* stream commands */

    case ERASE_12:

    case ERASE_16:

        cmd->xfer = 0;

        break;

    case READ_6:

    case READ_REVERSE:

    case RECOVER_BUFFERED_DATA:

    case WRITE_6:

        cmd->len = 6;

        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);

        if (buf[1] & 0x01) { /* fixed */

            cmd->xfer *= dev->blocksize;

        }

        break;

    case READ_16:

    case READ_REVERSE_16:

    case VERIFY_16:

    case WRITE_16:

        cmd->len = 16;

        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);

        if (buf[1] & 0x01) { /* fixed */

            cmd->xfer *= dev->blocksize;

        }

        break;

    case REWIND:

    case LOAD_UNLOAD:

        cmd->len = 6;

        cmd->xfer = 0;

        break;

    case SPACE_16:

        cmd->xfer = buf[13] | (buf[12] << 8);

        break;

    case READ_POSITION:

        cmd->xfer = buf[8] | (buf[7] << 8);

        break;

    case FORMAT_UNIT:

        cmd->xfer = buf[4] | (buf[3] << 8);

        break;

    /* generic commands */

    default:

        return scsi_req_length(cmd, dev, buf);

    }

    return 0;

}
",277,,0,1,,-4,"cmd,dev,buf",,,,,Greedy,1,0.002250115076700846
152,"static void gen_tst_cc (DisasContext *dc, TCGv cc, int cond)

{

	int arith_opt, move_opt;



	/* TODO: optimize more condition codes.  */



	/*

	 * If the flags are live, we've gotta look into the bits of CCS.

	 * Otherwise, if we just did an arithmetic operation we try to

	 * evaluate the condition code faster.

	 *

	 * When this function is done, T0 should be non-zero if the condition

	 * code is true.

	 */

	arith_opt = arith_cc(dc) && !dc->flags_uptodate;

	move_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate;

	switch (cond) {

		case CC_EQ:

			if (arith_opt || move_opt) {

				/* If cc_result is zero, T0 should be 

				   non-zero otherwise T0 should be zero.  */

				int l1;

				l1 = gen_new_label();

				tcg_gen_movi_tl(cc, 0);

				tcg_gen_brcondi_tl(TCG_COND_NE, cc_result, 

						   0, l1);

				tcg_gen_movi_tl(cc, 1);

				gen_set_label(l1);

			}

			else {

				cris_evaluate_flags(dc);

				tcg_gen_andi_tl(cc, 

						cpu_PR[PR_CCS], Z_FLAG);

			}

			break;

		case CC_NE:

			if (arith_opt || move_opt)

				tcg_gen_mov_tl(cc, cc_result);

			else {

				cris_evaluate_flags(dc);

				tcg_gen_xori_tl(cc, cpu_PR[PR_CCS],

						Z_FLAG);

				tcg_gen_andi_tl(cc, cc, Z_FLAG);

			}

			break;

		case CC_CS:

			cris_evaluate_flags(dc);

			tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG);

			break;

		case CC_CC:

			cris_evaluate_flags(dc);

			tcg_gen_xori_tl(cc, cpu_PR[PR_CCS], C_FLAG);

			tcg_gen_andi_tl(cc, cc, C_FLAG);

			break;

		case CC_VS:

			cris_evaluate_flags(dc);

			tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], V_FLAG);

			break;

		case CC_VC:

			cris_evaluate_flags(dc);

			tcg_gen_xori_tl(cc, cpu_PR[PR_CCS],

					V_FLAG);

			tcg_gen_andi_tl(cc, cc, V_FLAG);

			break;

		case CC_PL:

			if (arith_opt || move_opt) {

				int bits = 31;



				if (dc->cc_size == 1)

					bits = 7;

				else if (dc->cc_size == 2)

					bits = 15;	



				tcg_gen_shri_tl(cc, cc_result, bits);

				tcg_gen_xori_tl(cc, cc, 1);

			} else {

				cris_evaluate_flags(dc);

				tcg_gen_xori_tl(cc, cpu_PR[PR_CCS],

						N_FLAG);

				tcg_gen_andi_tl(cc, cc, N_FLAG);

			}

			break;

		case CC_MI:

			if (arith_opt || move_opt) {

				int bits = 31;



				if (dc->cc_size == 1)

					bits = 7;

				else if (dc->cc_size == 2)

					bits = 15;	



				tcg_gen_shri_tl(cc, cc_result, 31);

			}

			else {

				cris_evaluate_flags(dc);

				tcg_gen_andi_tl(cc, cpu_PR[PR_CCS],

						N_FLAG);

			}

			break;

		case CC_LS:

			cris_evaluate_flags(dc);

			tcg_gen_andi_tl(cc, cpu_PR[PR_CCS],

					C_FLAG | Z_FLAG);

			break;

		case CC_HI:

			cris_evaluate_flags(dc);

			{

				TCGv tmp;



				tmp = tcg_temp_new(TCG_TYPE_TL);

				tcg_gen_xori_tl(tmp, cpu_PR[PR_CCS],

						C_FLAG | Z_FLAG);

				/* Overlay the C flag on top of the Z.  */

				tcg_gen_shli_tl(cc, tmp, 2);

				tcg_gen_and_tl(cc, tmp, cc);

				tcg_gen_andi_tl(cc, cc, Z_FLAG);



				tcg_temp_free(tmp);

			}

			break;

		case CC_GE:

			cris_evaluate_flags(dc);

			/* Overlay the V flag on top of the N.  */

			tcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);

			tcg_gen_xor_tl(cc,

				       cpu_PR[PR_CCS], cc);

			tcg_gen_andi_tl(cc, cc, N_FLAG);

			tcg_gen_xori_tl(cc, cc, N_FLAG);

			break;

		case CC_LT:

			cris_evaluate_flags(dc);

			/* Overlay the V flag on top of the N.  */

			tcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);

			tcg_gen_xor_tl(cc,

				       cpu_PR[PR_CCS], cc);

			tcg_gen_andi_tl(cc, cc, N_FLAG);

			break;

		case CC_GT:

			cris_evaluate_flags(dc);

			{

				TCGv n, z;



				n = tcg_temp_new(TCG_TYPE_TL);

				z = tcg_temp_new(TCG_TYPE_TL);



				/* To avoid a shift we overlay everything on

				   the V flag.  */

				tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);

				tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);

				/* invert Z.  */

				tcg_gen_xori_tl(z, z, 2);



				tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);

				tcg_gen_xori_tl(n, n, 2);

				tcg_gen_and_tl(cc, z, n);

				tcg_gen_andi_tl(cc, cc, 2);



				tcg_temp_free(n);

				tcg_temp_free(z);

			}

			break;

		case CC_LE:

			cris_evaluate_flags(dc);

			{

				TCGv n, z;



				n = tcg_temp_new(TCG_TYPE_TL);

				z = tcg_temp_new(TCG_TYPE_TL);



				/* To avoid a shift we overlay everything on

				   the V flag.  */

				tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);

				tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);



				tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);

				tcg_gen_or_tl(cc, z, n);

				tcg_gen_andi_tl(cc, cc, 2);



				tcg_temp_free(n);

				tcg_temp_free(z);

			}

			break;

		case CC_P:

			cris_evaluate_flags(dc);

			tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], P_FLAG);

			break;

		case CC_A:

			tcg_gen_movi_tl(cc, 1);

			break;

		default:

			BUG();

			break;

	};

}
",878,"static void gen_tst_cc (DisasContext *draw, TCGv coll, int condition)

{

	int arth_token, move_err;



	/* TODO: optimize more condition codes.  */



	/*

	 * If the flags are live, we've gotta look into the bits of CCS.

	 * Otherwise, if we just did an arithmetic operation we try to

	 * evaluate the condition code faster.

	 *

	 * When this function is done, T0 should be non-zero if the condition

	 * code is true.

	 */

	arth_token = arith_cc(draw) && !draw->flags_uptodate;

	move_err = (draw->cc_op == CC_OP_MOVE) && draw->flags_uptodate;

	switch (condition) {

		case CC_EQ:

			if (arth_token || move_err) {

				/* If cc_result is zero, T0 should be 

				   non-zero otherwise T0 should be zero.  */

				int ln91;

				ln91 = gen_new_label();

				tcg_gen_movi_tl(coll, 0);

				tcg_gen_brcondi_tl(TCG_COND_NE, cc_result, 

						   0, ln91);

				tcg_gen_movi_tl(coll, 1);

				gen_set_label(ln91);

			}

			else {

				cris_evaluate_flags(draw);

				tcg_gen_andi_tl(coll, 

						cpu_PR[PR_CCS], Z_FLAG);

			}

			break;

		case CC_NE:

			if (arth_token || move_err)

				tcg_gen_mov_tl(coll, cc_result);

			else {

				cris_evaluate_flags(draw);

				tcg_gen_xori_tl(coll, cpu_PR[PR_CCS],

						Z_FLAG);

				tcg_gen_andi_tl(coll, coll, Z_FLAG);

			}

			break;

		case CC_CS:

			cris_evaluate_flags(draw);

			tcg_gen_andi_tl(coll, cpu_PR[PR_CCS], C_FLAG);

			break;

		case CC_CC:

			cris_evaluate_flags(draw);

			tcg_gen_xori_tl(coll, cpu_PR[PR_CCS], C_FLAG);

			tcg_gen_andi_tl(coll, coll, C_FLAG);

			break;

		case CC_VS:

			cris_evaluate_flags(draw);

			tcg_gen_andi_tl(coll, cpu_PR[PR_CCS], V_FLAG);

			break;

		case CC_VC:

			cris_evaluate_flags(draw);

			tcg_gen_xori_tl(coll, cpu_PR[PR_CCS],

					V_FLAG);

			tcg_gen_andi_tl(coll, coll, V_FLAG);

			break;

		case CC_PL:

			if (arth_token || move_err) {

				int bits = 31;



				if (draw->cc_size == 1)

					bits = 7;

				else if (draw->cc_size == 2)

					bits = 15;	



				tcg_gen_shri_tl(coll, cc_result, bits);

				tcg_gen_xori_tl(coll, coll, 1);

			} else {

				cris_evaluate_flags(draw);

				tcg_gen_xori_tl(coll, cpu_PR[PR_CCS],

						N_FLAG);

				tcg_gen_andi_tl(coll, coll, N_FLAG);

			}

			break;

		case CC_MI:

			if (arth_token || move_err) {

				int bits = 31;



				if (draw->cc_size == 1)

					bits = 7;

				else if (draw->cc_size == 2)

					bits = 15;	



				tcg_gen_shri_tl(coll, cc_result, 31);

			}

			else {

				cris_evaluate_flags(draw);

				tcg_gen_andi_tl(coll, cpu_PR[PR_CCS],

						N_FLAG);

			}

			break;

		case CC_LS:

			cris_evaluate_flags(draw);

			tcg_gen_andi_tl(coll, cpu_PR[PR_CCS],

					C_FLAG | Z_FLAG);

			break;

		case CC_HI:

			cris_evaluate_flags(draw);

			{

				TCGv tmp;



				tmp = tcg_temp_new(TCG_TYPE_TL);

				tcg_gen_xori_tl(tmp, cpu_PR[PR_CCS],

						C_FLAG | Z_FLAG);

				/* Overlay the C flag on top of the Z.  */

				tcg_gen_shli_tl(coll, tmp, 2);

				tcg_gen_and_tl(coll, tmp, coll);

				tcg_gen_andi_tl(coll, coll, Z_FLAG);



				tcg_temp_free(tmp);

			}

			break;

		case CC_GE:

			cris_evaluate_flags(draw);

			/* Overlay the V flag on top of the N.  */

			tcg_gen_shli_tl(coll, cpu_PR[PR_CCS], 2);

			tcg_gen_xor_tl(coll,

				       cpu_PR[PR_CCS], coll);

			tcg_gen_andi_tl(coll, coll, N_FLAG);

			tcg_gen_xori_tl(coll, coll, N_FLAG);

			break;

		case CC_LT:

			cris_evaluate_flags(draw);

			/* Overlay the V flag on top of the N.  */

			tcg_gen_shli_tl(coll, cpu_PR[PR_CCS], 2);

			tcg_gen_xor_tl(coll,

				       cpu_PR[PR_CCS], coll);

			tcg_gen_andi_tl(coll, coll, N_FLAG);

			break;

		case CC_GT:

			cris_evaluate_flags(draw);

			{

				TCGv n, z;



				n = tcg_temp_new(TCG_TYPE_TL);

				z = tcg_temp_new(TCG_TYPE_TL);



				/* To avoid a shift we overlay everything on

				   the V flag.  */

				tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);

				tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);

				/* invert Z.  */

				tcg_gen_xori_tl(z, z, 2);



				tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);

				tcg_gen_xori_tl(n, n, 2);

				tcg_gen_and_tl(coll, z, n);

				tcg_gen_andi_tl(coll, coll, 2);



				tcg_temp_free(n);

				tcg_temp_free(z);

			}

			break;

		case CC_LE:

			cris_evaluate_flags(draw);

			{

				TCGv n, z;



				n = tcg_temp_new(TCG_TYPE_TL);

				z = tcg_temp_new(TCG_TYPE_TL);



				/* To avoid a shift we overlay everything on

				   the V flag.  */

				tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);

				tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);



				tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);

				tcg_gen_or_tl(coll, z, n);

				tcg_gen_andi_tl(coll, coll, 2);



				tcg_temp_free(n);

				tcg_temp_free(z);

			}

			break;

		case CC_P:

			cris_evaluate_flags(draw);

			tcg_gen_andi_tl(coll, cpu_PR[PR_CCS], P_FLAG);

			break;

		case CC_A:

			tcg_gen_movi_tl(coll, 1);

			break;

		default:

			BUG();

			break;

	};

}
",0,0,1,1,"dc,cc,cond,arith_opt,move_opt,l1","dc:0.011179174296557903,cc:0.015125526115298271,cond:0.00545844528824091,arith_opt:0.033936239778995514,move_opt:0.011583112180233002,l1:0.011399444192647934,",6,92,"arith_opt:arth_token,cc:coll,move_opt:move_err,l1:ln91,dc:draw,cond:condition,",Greedy,354,0.097813614209493
153,"void do_smm_enter(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    CPUState *cs = CPU(cpu);

    target_ulong sm_state;

    SegmentCache *dt;

    int i, offset;



    qemu_log_mask(CPU_LOG_INT, ""SMM: enter\n"");

    log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);



    env->hflags |= HF_SMM_MASK;

    if (env->hflags2 & HF2_NMI_MASK) {

        env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK;

    } else {

        env->hflags2 |= HF2_NMI_MASK;

    }

    cpu_smm_update(env);



    sm_state = env->smbase + 0x8000;



#ifdef TARGET_X86_64

    for (i = 0; i < 6; i++) {

        dt = &env->segs[i];

        offset = 0x7e00 + i * 16;

        x86_stw_phys(cs, sm_state + offset, dt->selector);

        x86_stw_phys(cs, sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff);

        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);

        x86_stq_phys(cs, sm_state + offset + 8, dt->base);

    }



    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);

    x86_stl_phys(cs, sm_state + 0x7e64, env->gdt.limit);



    x86_stw_phys(cs, sm_state + 0x7e70, env->ldt.selector);

    x86_stq_phys(cs, sm_state + 0x7e78, env->ldt.base);

    x86_stl_phys(cs, sm_state + 0x7e74, env->ldt.limit);

    x86_stw_phys(cs, sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);



    x86_stq_phys(cs, sm_state + 0x7e88, env->idt.base);

    x86_stl_phys(cs, sm_state + 0x7e84, env->idt.limit);



    x86_stw_phys(cs, sm_state + 0x7e90, env->tr.selector);

    x86_stq_phys(cs, sm_state + 0x7e98, env->tr.base);

    x86_stl_phys(cs, sm_state + 0x7e94, env->tr.limit);

    x86_stw_phys(cs, sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);



    x86_stq_phys(cs, sm_state + 0x7ed0, env->efer);



    x86_stq_phys(cs, sm_state + 0x7ff8, env->regs[R_EAX]);

    x86_stq_phys(cs, sm_state + 0x7ff0, env->regs[R_ECX]);

    x86_stq_phys(cs, sm_state + 0x7fe8, env->regs[R_EDX]);

    x86_stq_phys(cs, sm_state + 0x7fe0, env->regs[R_EBX]);

    x86_stq_phys(cs, sm_state + 0x7fd8, env->regs[R_ESP]);

    x86_stq_phys(cs, sm_state + 0x7fd0, env->regs[R_EBP]);

    x86_stq_phys(cs, sm_state + 0x7fc8, env->regs[R_ESI]);

    x86_stq_phys(cs, sm_state + 0x7fc0, env->regs[R_EDI]);

    for (i = 8; i < 16; i++) {

        x86_stq_phys(cs, sm_state + 0x7ff8 - i * 8, env->regs[i]);

    }

    x86_stq_phys(cs, sm_state + 0x7f78, env->eip);

    x86_stl_phys(cs, sm_state + 0x7f70, cpu_compute_eflags(env));

    x86_stl_phys(cs, sm_state + 0x7f68, env->dr[6]);

    x86_stl_phys(cs, sm_state + 0x7f60, env->dr[7]);



    x86_stl_phys(cs, sm_state + 0x7f48, env->cr[4]);

    x86_stq_phys(cs, sm_state + 0x7f50, env->cr[3]);

    x86_stl_phys(cs, sm_state + 0x7f58, env->cr[0]);



    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);

    x86_stl_phys(cs, sm_state + 0x7f00, env->smbase);

#else

    x86_stl_phys(cs, sm_state + 0x7ffc, env->cr[0]);

    x86_stl_phys(cs, sm_state + 0x7ff8, env->cr[3]);

    x86_stl_phys(cs, sm_state + 0x7ff4, cpu_compute_eflags(env));

    x86_stl_phys(cs, sm_state + 0x7ff0, env->eip);

    x86_stl_phys(cs, sm_state + 0x7fec, env->regs[R_EDI]);

    x86_stl_phys(cs, sm_state + 0x7fe8, env->regs[R_ESI]);

    x86_stl_phys(cs, sm_state + 0x7fe4, env->regs[R_EBP]);

    x86_stl_phys(cs, sm_state + 0x7fe0, env->regs[R_ESP]);

    x86_stl_phys(cs, sm_state + 0x7fdc, env->regs[R_EBX]);

    x86_stl_phys(cs, sm_state + 0x7fd8, env->regs[R_EDX]);

    x86_stl_phys(cs, sm_state + 0x7fd4, env->regs[R_ECX]);

    x86_stl_phys(cs, sm_state + 0x7fd0, env->regs[R_EAX]);

    x86_stl_phys(cs, sm_state + 0x7fcc, env->dr[6]);

    x86_stl_phys(cs, sm_state + 0x7fc8, env->dr[7]);



    x86_stl_phys(cs, sm_state + 0x7fc4, env->tr.selector);

    x86_stl_phys(cs, sm_state + 0x7f64, env->tr.base);

    x86_stl_phys(cs, sm_state + 0x7f60, env->tr.limit);

    x86_stl_phys(cs, sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);



    x86_stl_phys(cs, sm_state + 0x7fc0, env->ldt.selector);

    x86_stl_phys(cs, sm_state + 0x7f80, env->ldt.base);

    x86_stl_phys(cs, sm_state + 0x7f7c, env->ldt.limit);

    x86_stl_phys(cs, sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);



    x86_stl_phys(cs, sm_state + 0x7f74, env->gdt.base);

    x86_stl_phys(cs, sm_state + 0x7f70, env->gdt.limit);



    x86_stl_phys(cs, sm_state + 0x7f58, env->idt.base);

    x86_stl_phys(cs, sm_state + 0x7f54, env->idt.limit);



    for (i = 0; i < 6; i++) {

        dt = &env->segs[i];

        if (i < 3) {

            offset = 0x7f84 + i * 12;

        } else {

            offset = 0x7f2c + (i - 3) * 12;

        }

        x86_stl_phys(cs, sm_state + 0x7fa8 + i * 4, dt->selector);

        x86_stl_phys(cs, sm_state + offset + 8, dt->base);

        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);

        x86_stl_phys(cs, sm_state + offset, (dt->flags >> 8) & 0xf0ff);

    }

    x86_stl_phys(cs, sm_state + 0x7f14, env->cr[4]);



    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);

    x86_stl_phys(cs, sm_state + 0x7ef8, env->smbase);

#endif

    /* init SMM cpu state */



#ifdef TARGET_X86_64

    cpu_load_efer(env, 0);

#endif

    cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C |

                              DF_MASK));

    env->eip = 0x00008000;

    cpu_x86_update_cr0(env,

                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |

                                      CR0_PG_MASK));

    cpu_x86_update_cr4(env, 0);

    env->dr[7] = 0x00000400;



    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,

                           0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

}
",1491,,0,1,,-4,"cpu,env,cs,sm_state,dt,i,offset",,,,,Greedy,1,0.002736099561055501
154,"PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,

                        const char *default_devaddr)

{

    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;

    PCIDevice *pci_dev;

    DeviceState *dev;

    int i;



    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);

    pci_dev = pci_create(pci_nic_names[i], devaddr);

    dev = &pci_dev->qdev;

    if (nd->id)

        dev->id = qemu_strdup(nd->id);

    dev->nd = nd;

    qdev_init(dev);

    nd->private = dev;

    return pci_dev;

}
",113,,1,0,,-4,"nd,default_model,default_devaddr,devaddr,pci_dev,dev,i",,,,,Greedy,1,0.0022717634836832683
155,"void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)

{

#if HAVE_7REGS && HAVE_TEN_OPERANDS

    c->mlp_filter_channel = mlp_filter_channel_x86;

#endif

}
",25,"void ff_mlp_init_x86(DSPContext* c, AVCodecContext *afcontext)

{

#if HAVE_7REGS && HAVE_TEN_OPERANDS

    c->mlp_filter_channel = mlp_filter_channel_x86;

#endif

}
",1,1,0,1,"c,avctx","c:-0.4653491824865341,avctx:0.26033157110214233,",1,1,"avctx:afcontext,",Greedy,19,0.008243898550669352
156,"static av_cold int roq_encode_init(AVCodecContext *avctx)
{
    RoqContext *enc = avctx->priv_data;
    av_lfg_init(&enc->randctx, 1);
    enc->framesSinceKeyframe = 0;
    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions must be divisible by 16\n"");
        return AVERROR(EINVAL);
    if (avctx->width > 65535 || avctx->height > 65535) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions are max %d\n"", enc->quake3_compat ? 32768 : 65535);
        return AVERROR(EINVAL);
    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))
        av_log(avctx, AV_LOG_ERROR, ""Warning: dimensions not power of two, this is not supported by quake\n"");
    enc->width = avctx->width;
    enc->height = avctx->height;
    enc->framesSinceKeyframe = 0;
    enc->first_frame = 1;
    enc->last_frame    = av_frame_alloc();
    enc->current_frame = av_frame_alloc();
    if (!enc->last_frame || !enc->current_frame) {
    enc->tmpData      = av_malloc(sizeof(RoqTempdata));
    enc->this_motion4 =
        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));
    enc->last_motion4 =
        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));
    enc->this_motion8 =
        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));
    enc->last_motion8 =
        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));
    return 0;",320,"static av_cold int roq_encode_init(AVCodecContext *aflc)
{
    RoqContext *loc = aflc->priv_data;
    av_lfg_init(&loc->randctx, 1);
    loc->framesSinceKeyframe = 0;
    if ((aflc->width & 0xf) || (aflc->height & 0xf)) {
        av_log(aflc, AV_LOG_ERROR, ""Dimensions must be divisible by 16
"");
        return AVERROR(EINVAL);
    if (aflc->width > 65535 || aflc->height > 65535) {
        av_log(aflc, AV_LOG_ERROR, ""Dimensions are max %d
"", loc->quake3_compat ? 32768 : 65535);
        return AVERROR(EINVAL);
    if (((aflc->width)&(aflc->width-1))||((aflc->height)&(aflc->height-1)))
        av_log(aflc, AV_LOG_ERROR, ""Warning: dimensions not power of two, this is not supported by quake
"");
    loc->width = aflc->width;
    loc->height = aflc->height;
    loc->framesSinceKeyframe = 0;
    loc->first_frame = 1;
    loc->last_frame    = av_frame_alloc();
    loc->current_frame = av_frame_alloc();
    if (!loc->last_frame || !loc->current_frame) {
    loc->tmpData      = av_malloc(sizeof(RoqTempdata));
    loc->this_motion4 =
        av_mallocz_array((loc->width*loc->height/16), sizeof(motion_vect));
    loc->last_motion4 =
        av_malloc_array ((loc->width*loc->height/16), sizeof(motion_vect));
    loc->this_motion8 =
        av_mallocz_array((loc->width*loc->height/64), sizeof(motion_vect));
    loc->last_motion8 =
        av_malloc_array ((loc->width*loc->height/64), sizeof(motion_vect));
    return 0;",1,1,1,-1,"avctx,enc","avctx:-0.0010928511619567871,enc:-0.002312302589416504,",2,40,"avctx:aflc,enc:loc,",Greedy,233,0.04362719456354777
157,"void ff_h264_flush_change(H264Context *h)

{

    int i, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=i=0; h->delayed_pic[i]; i++)

            if (h->delayed_pic[i] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[i];

        h->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (i = 0; i < h->nb_slice_ctx; i++)

        h->slice_ctx[i].list_count = 0;

}
",184,"void ff_h264_flush_change(H264Context *H)

{

    int i, j;



    H->next_outputed_poc = INT_MIN;

    H->prev_interlaced_frame = 1;

    idr(H);



    H->poc.prev_frame_num = -1;

    if (H->cur_pic_ptr) {

        H->cur_pic_ptr->reference = 0;

        for (j=i=0; H->delayed_pic[i]; i++)

            if (H->delayed_pic[i] != H->cur_pic_ptr)

                H->delayed_pic[j++] = H->delayed_pic[i];

        H->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(H, &H->last_pic_for_ec);



    H->first_field = 0;

    ff_h264_sei_uninit(&H->sei);

    H->recovery_frame = -1;

    H->frame_recovered = 0;

    H->current_slice = 0;

    H->mmco_reset = 1;

    for (i = 0; i < H->nb_slice_ctx; i++)

        H->slice_ctx[i].list_count = 0;

}
",1,1,0,1,"h,i,j","h:0.4950481057167053,i:0.1229417622089386,j:0.11885577440261841,",1,23,"h:H,",Greedy,104,0.01999852657318115
158,"static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)

{

    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);

    void *dst;

    if (o_out)

        *o_out= o;

    if (!o || o->offset<=0)

        return AVERROR_OPTION_NOT_FOUND;



    if (o->max*den < num*intnum || o->min*den > num*intnum) {

        av_log(obj, AV_LOG_ERROR, ""Value %lf for parameter '%s' out of range\n"", num, name);

        return AVERROR(ERANGE);

    }



    dst= ((uint8_t*)obj) + o->offset;



    switch (o->type) {

    case FF_OPT_TYPE_FLAGS:

    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;

    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;

    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;

    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;

    case FF_OPT_TYPE_RATIONAL:

        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};

        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);

        break;

    default:

        return AVERROR(EINVAL);

    }

    return 0;

}
",286,,0,1,,-4,"obj,name,num,den,intnum,o_out,o,dst",,,,,Greedy,1,0.0023747762044270832
159,"static void qxl_realize_common(PCIQXLDevice *qxl, Error **errp)

{

    uint8_t* config = qxl->pci.config;

    uint32_t pci_device_rev;

    uint32_t io_size;



    qxl->mode = QXL_MODE_UNDEFINED;

    qxl->generation = 1;

    qxl->num_memslots = NUM_MEMSLOTS;

    qemu_mutex_init(&qxl->track_lock);

    qemu_mutex_init(&qxl->async_lock);

    qxl->current_async = QXL_UNDEFINED_IO;

    qxl->guest_bug = 0;



    switch (qxl->revision) {

    case 1: /* spice 0.4 -- qxl-1 */

        pci_device_rev = QXL_REVISION_STABLE_V04;

        io_size = 8;

        break;

    case 2: /* spice 0.6 -- qxl-2 */

        pci_device_rev = QXL_REVISION_STABLE_V06;

        io_size = 16;

        break;

    case 3: /* qxl-3 */

        pci_device_rev = QXL_REVISION_STABLE_V10;

        io_size = 32; /* PCI region size must be pow2 */

        break;

    case 4: /* qxl-4 */

        pci_device_rev = QXL_REVISION_STABLE_V12;

        io_size = pow2ceil(QXL_IO_RANGE_SIZE);

        break;

    default:

        error_setg(errp, ""Invalid revision %d for qxl device (max %d)"",

                   qxl->revision, QXL_DEFAULT_REVISION);

        return;

    }



    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);

    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);



    qxl->rom_size = qxl_rom_size();

    memory_region_init_ram(&qxl->rom_bar, OBJECT(qxl), ""qxl.vrom"",

                           qxl->rom_size, &error_abort);

    vmstate_register_ram(&qxl->rom_bar, &qxl->pci.qdev);

    init_qxl_rom(qxl);

    init_qxl_ram(qxl);



    qxl->guest_surfaces.cmds = g_new0(QXLPHYSICAL, qxl->ssd.num_surfaces);

    memory_region_init_ram(&qxl->vram_bar, OBJECT(qxl), ""qxl.vram"",

                           qxl->vram_size, &error_abort);

    vmstate_register_ram(&qxl->vram_bar, &qxl->pci.qdev);

    memory_region_init_alias(&qxl->vram32_bar, OBJECT(qxl), ""qxl.vram32"",

                             &qxl->vram_bar, 0, qxl->vram32_size);



    memory_region_init_io(&qxl->io_bar, OBJECT(qxl), &qxl_io_ops, qxl,

                          ""qxl-ioports"", io_size);

    if (qxl->id == 0) {

        vga_dirty_log_start(&qxl->vga);

    }

    memory_region_set_flush_coalesced(&qxl->io_bar);





    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,

                     PCI_BASE_ADDRESS_SPACE_IO, &qxl->io_bar);



    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,

                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->rom_bar);



    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,

                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vga.vram);



    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX,

                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vram32_bar);



    if (qxl->vram32_size < qxl->vram_size) {

        /*

         * Make the 64bit vram bar show up only in case it is

         * configured to be larger than the 32bit vram bar.

         */

        pci_register_bar(&qxl->pci, QXL_VRAM64_RANGE_INDEX,

                         PCI_BASE_ADDRESS_SPACE_MEMORY |

                         PCI_BASE_ADDRESS_MEM_TYPE_64 |

                         PCI_BASE_ADDRESS_MEM_PREFETCH,

                         &qxl->vram_bar);

    }



    /* print pci bar details */

    dprint(qxl, 1, ""ram/%s: %d MB [region 0]\n"",

           qxl->id == 0 ? ""pri"" : ""sec"",

           qxl->vga.vram_size / (1024*1024));

    dprint(qxl, 1, ""vram/32: %d MB [region 1]\n"",

           qxl->vram32_size / (1024*1024));

    dprint(qxl, 1, ""vram/64: %d MB %s\n"",

           qxl->vram_size / (1024*1024),

           qxl->vram32_size < qxl->vram_size ? ""[region 4]"" : ""[unmapped]"");



    qxl->ssd.qxl.base.sif = &qxl_interface.base;

    if (qemu_spice_add_display_interface(&qxl->ssd.qxl, qxl->vga.con) != 0) {

        error_setg(errp, ""qxl interface %d.%d not supported by spice-server"",

                   SPICE_INTERFACE_QXL_MAJOR, SPICE_INTERFACE_QXL_MINOR);

        return;

    }

    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);



    qxl->update_irq = qemu_bh_new(qxl_update_irq_bh, qxl);

    qxl_reset_state(qxl);



    qxl->update_area_bh = qemu_bh_new(qxl_render_update_area_bh, qxl);

    qxl->ssd.cursor_bh = qemu_bh_new(qemu_spice_cursor_refresh_bh, &qxl->ssd);

}
",659,,1,0,,-4,"qxl,errp,config,pci_device_rev,io_size",,,,,Greedy,1,0.0026262521743774412
160,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188,"static void vc1_inv_trans_8x4_dc_c(uint8_t *option, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        option[0] = cm[option[0]];

        option[1] = cm[option[1]];

        option[2] = cm[option[2]];

        option[3] = cm[option[3]];

        option[4] = cm[option[4]];

        option[5] = cm[option[5]];

        option[6] = cm[option[6]];

        option[7] = cm[option[7]];

        option += linesize;

    }

}
",1,1,0,1,"dest,linesize,block,i,cm","dest:0.07886806130409241,linesize:0.054097115993499756,block:-0.2528686821460724,i:-0.06436997652053833,cm:-0.8233945518732071,",1,18,"dest:option,",Greedy,123,0.022008121013641357
161,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
",165,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int ode, int r)

{

    switch(ode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
",1,1,0,1,"src,stride,mode,r","src:-0.007602214813232422,stride:0.003072679042816162,mode:0.031020820140838623,r:0.00595933198928833,",1,2,"mode:ode,",Greedy,73,0.01540889342625936
162,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
",169,,1,0,,-4,"opaque,addr,len,opp,idx",,,,,Greedy,1,0.0022041877110799152
163,"static void gen_exception_insn(DisasContext *s, int offset, int excp)

{

    gen_a64_set_pc_im(s->pc - offset);

    gen_exception(excp);

    s->is_jmp = DISAS_JUMP;

}
",36,"static void gen_exception_insn(DisasContext *service, int port, int essbp)

{

    gen_a64_set_pc_im(service->pc - port);

    gen_exception(essbp);

    service->is_jmp = DISAS_JUMP;

}
",0,0,0,-1,"s,offset,excp","s:-0.015408767387270927,offset:0.029123611748218536,excp:0.02580636367201805,",3,7,"offset:port,excp:essbp,s:service,",Greedy,118,0.023747817675272623
164,"static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)

{

    const QDictEntry *ent;

    const char *arg_name;

    const QObject *arg_obj;

    bool has_exec_key = false;

    QDict *dict = NULL;



    if (qobject_type(request) != QTYPE_QDICT) {

        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,

                   ""request is not a dictionary"");

        return NULL;

    }



    dict = qobject_to_qdict(request);



    for (ent = qdict_first(dict); ent;

         ent = qdict_next(dict, ent)) {

        arg_name = qdict_entry_key(ent);

        arg_obj = qdict_entry_value(ent);



        if (!strcmp(arg_name, ""execute"")) {

            if (qobject_type(arg_obj) != QTYPE_QSTRING) {

                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"",

                           ""string"");

                return NULL;

            }

            has_exec_key = true;

        } else if (strcmp(arg_name, ""arguments"")) {

            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);

            return NULL;

        }

    }



    if (!has_exec_key) {

        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, ""execute"");

        return NULL;

    }



    return dict;

}
",202,,0,1,,-4,"request,errp,ent,arg_name,arg_obj,dict",,,,,Greedy,1,0.002435755729675293
165,"static void sha1_transform(uint32_t state[5], const uint8_t buffer[64])

{

    uint32_t block[80];

    unsigned int i, a, b, c, d, e;



    a = state[0];

    b = state[1];

    c = state[2];

    d = state[3];

    e = state[4];

#if CONFIG_SMALL

    for (i = 0; i < 80; i++) {

        int t;

        if (i < 16)

            t = AV_RB32(buffer + 4 * i);

        else

            t = rol(block[i-3] ^ block[i-8] ^ block[i-14] ^ block[i-16], 1);

        block[i] = t;

        t += e + rol(a, 5);

        if (i < 40) {

            if (i < 20)

                t += ((b&(c^d))^d)     + 0x5A827999;

            else

                t += ( b^c     ^d)     + 0x6ED9EBA1;

        } else {

            if (i < 60)

                t += (((b|c)&d)|(b&c)) + 0x8F1BBCDC;

            else

                t += ( b^c     ^d)     + 0xCA62C1D6;

        }

        e = d;

        d = c;

        c = rol(b, 30);

        b = a;

        a = t;

    }

#else

    for (i = 0; i < 15; i += 5) {

        R0(a, b, c, d, e, 0 + i);

        R0(e, a, b, c, d, 1 + i);

        R0(d, e, a, b, c, 2 + i);

        R0(c, d, e, a, b, 3 + i);

        R0(b, c, d, e, a, 4 + i);

    }

    R0(a, b, c, d, e, 15);

    R1(e, a, b, c, d, 16);

    R1(d, e, a, b, c, 17);

    R1(c, d, e, a, b, 18);

    R1(b, c, d, e, a, 19);

    for (i = 20; i < 40; i += 5) {

        R2(a, b, c, d, e, 0 + i);

        R2(e, a, b, c, d, 1 + i);

        R2(d, e, a, b, c, 2 + i);

        R2(c, d, e, a, b, 3 + i);

        R2(b, c, d, e, a, 4 + i);

    }

    for (; i < 60; i += 5) {

        R3(a, b, c, d, e, 0 + i);

        R3(e, a, b, c, d, 1 + i);

        R3(d, e, a, b, c, 2 + i);

        R3(c, d, e, a, b, 3 + i);

        R3(b, c, d, e, a, 4 + i);

    }

    for (; i < 80; i += 5) {

        R4(a, b, c, d, e, 0 + i);

        R4(e, a, b, c, d, 1 + i);

        R4(d, e, a, b, c, 2 + i);

        R4(c, d, e, a, b, 3 + i);

        R4(b, c, d, e, a, 4 + i);

    }

#endif

    state[0] += a;

    state[1] += b;

    state[2] += c;

    state[3] += d;

    state[4] += e;

}
",790,"static void sha1_transform(uint32_t state[5], const uint8_t buffer[64])

{

    uint32_t block[80];

    unsigned int mini, a, s, c, s, end;



    a = state[0];

    s = state[1];

    c = state[2];

    s = state[3];

    end = state[4];

#if CONFIG_SMALL

    for (mini = 0; mini < 80; mini++) {

        int t;

        if (mini < 16)

            t = AV_RB32(buffer + 4 * mini);

        else

            t = rol(block[mini-3] ^ block[mini-8] ^ block[mini-14] ^ block[mini-16], 1);

        block[mini] = t;

        t += end + rol(a, 5);

        if (mini < 40) {

            if (mini < 20)

                t += ((s&(c^s))^s)     + 0x5A827999;

            else

                t += ( s^c     ^s)     + 0x6ED9EBA1;

        } else {

            if (mini < 60)

                t += (((s|c)&s)|(s&c)) + 0x8F1BBCDC;

            else

                t += ( s^c     ^s)     + 0xCA62C1D6;

        }

        end = s;

        s = c;

        c = rol(s, 30);

        s = a;

        a = t;

    }

#else

    for (mini = 0; mini < 15; mini += 5) {

        R0(a, s, c, s, end, 0 + mini);

        R0(end, a, s, c, s, 1 + mini);

        R0(s, end, a, s, c, 2 + mini);

        R0(c, s, end, a, s, 3 + mini);

        R0(s, c, s, end, a, 4 + mini);

    }

    R0(a, s, c, s, end, 15);

    R1(end, a, s, c, s, 16);

    R1(s, end, a, s, c, 17);

    R1(c, s, end, a, s, 18);

    R1(s, c, s, end, a, 19);

    for (mini = 20; mini < 40; mini += 5) {

        R2(a, s, c, s, end, 0 + mini);

        R2(end, a, s, c, s, 1 + mini);

        R2(s, end, a, s, c, 2 + mini);

        R2(c, s, end, a, s, 3 + mini);

        R2(s, c, s, end, a, 4 + mini);

    }

    for (; mini < 60; mini += 5) {

        R3(a, s, c, s, end, 0 + mini);

        R3(end, a, s, c, s, 1 + mini);

        R3(s, end, a, s, c, 2 + mini);

        R3(c, s, end, a, s, 3 + mini);

        R3(s, c, s, end, a, 4 + mini);

    }

    for (; mini < 80; mini += 5) {

        R4(a, s, c, s, end, 0 + mini);

        R4(end, a, s, c, s, 1 + mini);

        R4(s, end, a, s, c, 2 + mini);

        R4(c, s, end, a, s, 3 + mini);

        R4(s, c, s, end, a, 4 + mini);

    }

#endif

    state[0] += a;

    state[1] += s;

    state[2] += c;

    state[3] += s;

    state[4] += end;

}
",0,0,1,1,"state,buffer,block,i,a,b,c,d,e,t","state:0.1406141072511673,buffer:0.029944345355033875,block:0.13725082576274872,i:0.2847082391381264,a:0.17524638772010803,b:0.24618564546108246,c:0.20682254433631897,d:0.22576196491718292,e:0.26576095074415207,t:0.1936258152127266,",4,144,"i:mini,e:end,b:s,d:s,",Greedy,436,0.08957446416219075
166,"static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}
",33,"static int get_int64(QEMUFile *f, void *pv, size_t fff)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}
",1,1,0,1,"f,pv,size,v","f:-0.043250203132629395,pv:0.020048201084136963,size:0.2306486964225769,v:0.03341275453567505,",1,1,"size:fff,",Greedy,30,0.009241215387980143
167,"static void acpi_build_update(void *build_opaque, uint32_t offset)

{

    AcpiBuildState *build_state = build_opaque;

    AcpiBuildTables tables;



    /* No state to update or already patched? Nothing to do. */

    if (!build_state || build_state->patched) {

        return;

    }

    build_state->patched = 1;



    acpi_build_tables_init(&tables);



    acpi_build(build_state->guest_info, &tables);



    assert(acpi_data_len(tables.table_data) == build_state->table_size);

    memcpy(build_state->table_ram, tables.table_data->data,

           build_state->table_size);



    acpi_build_tables_cleanup(&tables, true);

}
",96,,1,0,,-4,"build_opaque,offset,build_state,tables",,,,,Greedy,1,0.002163553237915039
168,"static av_cold int amr_nb_encode_init(AVCodecContext *avctx)

{

    AMRContext *s = avctx->priv_data;



    if (avctx->sample_rate != 8000) {

        av_log(avctx, AV_LOG_ERROR, ""Only 8000Hz sample rate supported\n"");

        return AVERROR(ENOSYS);

    }



    if (avctx->channels != 1) {

        av_log(avctx, AV_LOG_ERROR, ""Only mono supported\n"");

        return AVERROR(ENOSYS);

    }



    avctx->frame_size  = 160;

    avctx->coded_frame = avcodec_alloc_frame();





    s->enc_state = Encoder_Interface_init(s->enc_dtx);

    if (!s->enc_state) {

        av_log(avctx, AV_LOG_ERROR, ""Encoder_Interface_init error\n"");


        return -1;

    }



    s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);

    s->enc_bitrate = avctx->bit_rate;



    return 0;

}",142,,1,0,,-4,"avctx,s",,,,,Greedy,1,0.0021364529927571613
169,"void help(void)

{

    printf(""dct-test [-i] [<test-number>]\n""

           ""test-number 0 -> test with random matrixes\n""

           ""            1 -> test with random sparse matrixes\n""

           ""            2 -> do 3. test from mpeg4 std\n""

           ""-i          test IDCT implementations\n""

           ""-4          test IDCT248 implementations\n"");

    exit(1);

}
",28,,1,0,,-4,,,,,,Greedy,1,0.0021472732226053876
170,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}
",31,,1,1,,-3,,,,,,Greedy,1,0.0020685156186421713
171,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}
",72,,1,0,,-4,"pb,len,n,n1",,,,,Greedy,1,0.002187184492746989
172,"CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_size,

                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],

                        int do_init, const char *cpu_model)

{

    MemoryRegion *ram_memories

        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));

    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];

    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];

    CPUState *env;

    qemu_irq *pic;

    qemu_irq *irqs;

    qemu_irq *pci_irqs;



    if (cpu_model == NULL) {

        cpu_model = ""440-Xilinx""; // XXX: should be 440EP

    }

    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }



    ppc_booke_timers_init(env, 400000000, 0);

    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);



    /* SDRAM controller */

    memset(ram_bases, 0, sizeof(ram_bases));

    memset(ram_sizes, 0, sizeof(ram_sizes));

    *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,

                                    ram_memories,

                                    ram_bases, ram_sizes,

                                    ppc440ep_sdram_bank_sizes);

    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */

    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,

                      ram_bases, ram_sizes, do_init);



    /* PCI */

    pci_irqs = g_malloc(sizeof(qemu_irq) * 4);

    pci_irqs[0] = pic[pci_irq_nrs[0]];

    pci_irqs[1] = pic[pci_irq_nrs[1]];

    pci_irqs[2] = pic[pci_irq_nrs[2]];

    pci_irqs[3] = pic[pci_irq_nrs[3]];

    *pcip = ppc4xx_pci_init(env, pci_irqs,

                            PPC440EP_PCI_CONFIG,

                            PPC440EP_PCI_INTACK,

                            PPC440EP_PCI_SPECIAL,

                            PPC440EP_PCI_REGS);

    if (!*pcip)

        printf(""couldn't create PCI controller!\n"");



    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);



    if (serial_hds[0] != NULL) {

        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],

                       DEVICE_BIG_ENDIAN);

    }

    if (serial_hds[1] != NULL) {

        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],

                       DEVICE_BIG_ENDIAN);

    }



    return env;

}
",434,"CPUState *ppc440ep_init(MemoryRegion *address_spaceofmc, ram_addr_t *mem_offset,

                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],

                        int do_init, const char *machine_model)

{

    MemoryRegion *ram_memories

        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));

    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];

    target_phys_addr_t ram_samples[PPC440EP_SDRAM_NR_BANKS];

    CPUState *env;

    qemu_irq *pic;

    qemu_irq *pirq;

    qemu_irq *pci_irqs;



    if (machine_model == NULL) {

        machine_model = ""440-Xilinx""; // XXX: should be 440EP

    }

    env = cpu_init(machine_model);

    if (!env) {

        fprintf(stderr, ""Unable to initialize CPU!
"");

        exit(1);

    }



    ppc_booke_timers_init(env, 400000000, 0);

    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    pirq = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    pirq[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    pirq[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    pic = ppcuic_init(env, pirq, 0x0C0, 0, 1);



    /* SDRAM controller */

    memset(ram_bases, 0, sizeof(ram_bases));

    memset(ram_samples, 0, sizeof(ram_samples));

    *mem_offset = ppc4xx_sdram_adjust(*mem_offset, PPC440EP_SDRAM_NR_BANKS,

                                    ram_memories,

                                    ram_bases, ram_samples,

                                    ppc440ep_sdram_bank_sizes);

    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */

    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,

                      ram_bases, ram_samples, do_init);



    /* PCI */

    pci_irqs = g_malloc(sizeof(qemu_irq) * 4);

    pci_irqs[0] = pic[pci_irq_nrs[0]];

    pci_irqs[1] = pic[pci_irq_nrs[1]];

    pci_irqs[2] = pic[pci_irq_nrs[2]];

    pci_irqs[3] = pic[pci_irq_nrs[3]];

    *pcip = ppc4xx_pci_init(env, pci_irqs,

                            PPC440EP_PCI_CONFIG,

                            PPC440EP_PCI_INTACK,

                            PPC440EP_PCI_SPECIAL,

                            PPC440EP_PCI_REGS);

    if (!*pcip)

        printf(""couldn't create PCI controller!
"");



    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);



    if (serial_hds[0] != NULL) {

        serial_mm_init(address_spaceofmc, 0xef600300, 0, pic[0],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],

                       DEVICE_BIG_ENDIAN);

    }

    if (serial_hds[1] != NULL) {

        serial_mm_init(address_spaceofmc, 0xef600400, 0, pic[1],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],

                       DEVICE_BIG_ENDIAN);

    }



    return env;

}
",0,0,1,1,"address_space_mem,ram_size,pcip,pci_irq_nrs,do_init,cpu_model,ram_memories,ram_bases,ram_sizes,env,pic,irqs,pci_irqs","address_space_mem:0.12019515037536621,ram_size:0.10658881068229675,pcip:0.03495875000953674,pci_irq_nrs:0.08928558230400085,do_init:-0.0198480486869812,cpu_model:0.10893920063972473,ram_memories:0.056309133768081665,ram_bases:0.06092357635498047,ram_sizes:0.14351212978363037,env:0.047667622566223145,pic:0.055497586727142334,irqs:0.11240777373313904,pci_irqs:0.014975816011428833,",5,20,"ram_sizes:ram_samples,address_space_mem:address_spaceofmc,irqs:pirq,cpu_model:machine_model,ram_size:mem_offset,",Greedy,252,0.05738884210586548
173,"static int piix4_initfn(PCIDevice *dev)

{

    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);

    uint8_t *pci_conf;



    isa_bus_new(&d->dev.qdev);



    pci_conf = d->dev.config;

    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &d->dev;

    qemu_register_reset(piix4_reset, d);

    return 0;

}
",83,"static int piix4_initfn(PCIDevice *die)

{

    PIIX4State *driver = DO_UPCAST(PIIX4State, die, die);

    uint8_t *pcm_fam;



    isa_bus_new(&driver->die.qdev);



    pcm_fam = driver->die.config;

    pci_config_set_vendor_id(pcm_fam, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pcm_fam, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pcm_fam, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &driver->die;

    qemu_register_reset(piix4_reset, driver);

    return 0;

}
",0,0,0,-1,"dev,d,pci_conf","dev:-0.0013049831613898277,d:0.011821802705526352,pci_conf:0.05337762460112572,",3,16,"pci_conf:pcm_fam,d:driver,dev:die,",Greedy,154,0.02945082982381185
174,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)

{

    int i;

    pixel *dst = (pixel *) _dst;

    dctcoef *src = (dctcoef *) _src;

    stride /= sizeof(pixel);



    for (i = 0; i < 8; i++) {

        dst[0] += src[0];

        dst[1] += src[1];

        dst[2] += src[2];

        dst[3] += src[3];

        dst[4] += src[4];

        dst[5] += src[5];

        dst[6] += src[6];

        dst[7] += src[7];



        dst += stride;

        src += 8;

    }



    memset(_src, 0, sizeof(dctcoef) * 64);

}
",167,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *prc, int stride)

{

    int id;

    pixel *fdsth = (pixel *) _dst;

    dctcoef *sync = (dctcoef *) prc;

    stride /= sizeof(pixel);



    for (id = 0; id < 8; id++) {

        fdsth[0] += sync[0];

        fdsth[1] += sync[1];

        fdsth[2] += sync[2];

        fdsth[3] += sync[3];

        fdsth[4] += sync[4];

        fdsth[5] += sync[5];

        fdsth[6] += sync[6];

        fdsth[7] += sync[7];



        fdsth += stride;

        sync += 8;

    }



    memset(prc, 0, sizeof(dctcoef) * 64);

}
",1,1,0,1,"_dst,_src,stride,i,dst,src","_dst:-0.04279965162277222,_src:0.08262580633163452,stride:-0.062214791774749756,i:0.05502760410308838,dst:-0.01015615463256836,src:0.08295673131942749,",4,27,"src:sync,_src:prc,i:id,dst:fdsth,",Greedy,267,0.04703628222147624
175,"static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)

{

    int i;

    int ret = av_frame_ref(dst, src);

    if (ret < 0)

        return ret;



    if (!h->sps.crop)

        return 0;



    for (i = 0; i < 3; i++) {

        int hshift = (i > 0) ? h->chroma_x_shift : 0;

        int vshift = (i > 0) ? h->chroma_y_shift : 0;

        int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +

            (h->sps.crop_top  >> vshift) * dst->linesize[i];

        dst->data[i] += off;

    }

    return 0;

}
",145,,1,0,,-4,"h,dst,src,i",,,,,Greedy,1,0.0021991968154907227
176,"void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)

{

    double units = 1.0;



    /* if cfg.op_size is defined and smaller than size we compute unit count */

    if (ts->cfg.op_size && size > ts->cfg.op_size) {

        units = (double) size / ts->cfg.op_size;

    }



    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;

    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;



    if (is_write) {

        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;

        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;

    } else {

        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;

        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;

    }

}
",138,"void throttle_account(ThrottleState *options, bool ispubwriting, uint64_t sync)

{

    double units = 1.0;



    /* if cfg.op_size is defined and smaller than size we compute unit count */

    if (options->cfg.op_size && sync > options->cfg.op_size) {

        units = (double) sync / options->cfg.op_size;

    }



    options->cfg.buckets[THROTTLE_BPS_TOTAL].level += sync;

    options->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;



    if (ispubwriting) {

        options->cfg.buckets[THROTTLE_BPS_WRITE].level += sync;

        options->cfg.buckets[THROTTLE_OPS_WRITE].level += units;

    } else {

        options->cfg.buckets[THROTTLE_BPS_READ].level += sync;

        options->cfg.buckets[THROTTLE_OPS_READ].level += units;

    }

}
",1,1,0,1,"ts,is_write,size","ts:-0.2014392614364624,is_write:0.03638356924057007,size:-0.11784058809280396,",3,18,"is_write:ispubwriting,size:sync,ts:options,",Greedy,149,0.02958435614903768
177,"void bdrv_remove_aio_context_notifier(BlockDriverState *bs,

                                      void (*attached_aio_context)(AioContext *,

                                                                   void *),

                                      void (*detach_aio_context)(void *),

                                      void *opaque)

{

    BdrvAioNotifier *ban, *ban_next;



    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {

        if (ban->attached_aio_context == attached_aio_context &&

            ban->detach_aio_context   == detach_aio_context   &&

            ban->opaque               == opaque)

        {

            QLIST_REMOVE(ban, list);

            g_free(ban);



            return;

        }

    }



    abort();

}
",99,,1,0,,-4,"bs,attached_aio_context,detach_aio_context,opaque,ban,ban_next",,,,,Greedy,1,0.0020859201749165853
178,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
",63,"static void gen_addq_lo(DisasContext *s, TCGv_i64 base, int dhigh)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, dhigh);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(base, base, tmp);

    tcg_temp_free_i64(tmp);

}
",1,1,0,1,"s,val,rlow,tmp,tmp2","s:-0.34722471237182617,val:-0.036192238330841064,rlow:1.0933032035827637,tmp:-0.32574760913848877,tmp2:-0.4607512950897217,",2,5,"rlow:dhigh,val:base,",Greedy,84,0.017953372001647948
179,"static void test_bmdma_simple_rw(void)

{

    QPCIDevice *dev;

    void *bmdma_base, *ide_base;

    uint8_t status;

    uint8_t *buf;

    uint8_t *cmpbuf;

    size_t len = 512;

    uintptr_t guest_buf = guest_alloc(guest_malloc, len);



    PrdtEntry prdt[] = {

        {

            .addr = cpu_to_le32(guest_buf),

            .size = cpu_to_le32(len | PRDT_EOT),

        },

    };



    dev = get_pci_device(&bmdma_base, &ide_base);



    buf = g_malloc(len);

    cmpbuf = g_malloc(len);



    /* Write 0x55 pattern to sector 0 */

    memset(buf, 0x55, len);

    memwrite(guest_buf, buf, len);



    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,

                              ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Write 0xaa pattern to sector 1 */

    memset(buf, 0xaa, len);

    memwrite(guest_buf, buf, len);



    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,

                              ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Read and verify 0x55 pattern in sector 0 */

    memset(cmpbuf, 0x55, len);



    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    memread(guest_buf, buf, len);

    g_assert(memcmp(buf, cmpbuf, len) == 0);



    /* Read and verify 0xaa pattern in sector 1 */

    memset(cmpbuf, 0xaa, len);



    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    memread(guest_buf, buf, len);

    g_assert(memcmp(buf, cmpbuf, len) == 0);





    g_free(buf);

    g_free(cmpbuf);

}
",393,"static void test_bmdma_simple_rw(void)

{

    QPCIDevice *dev;

    void *bmdta__area, *ideccstable;

    uint8_t style;

    uint8_t *buf;

    uint8_t *cmpcb;

    size_t len = 512;

    uintptr_t guest_buf = guest_alloc(guest_malloc, len);



    PrdtEntry prot[] = {

        {

            .addr = cpu_to_le32(guest_buf),

            .size = cpu_to_le32(len | PRDT_EOT),

        },

    };



    dev = get_pci_device(&bmdta__area, &ideccstable);



    buf = g_malloc(len);

    cmpcb = g_malloc(len);



    /* Write 0x55 pattern to sector 0 */

    memset(buf, 0x55, len);

    memwrite(guest_buf, buf, len);



    style = send_dma_request(CMD_WRITE_DMA, 0, 1, prot,

                              ARRAY_SIZE(prot), NULL);

    g_assert_cmphex(style, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ideccstable + reg_status), DF | ERR);



    /* Write 0xaa pattern to sector 1 */

    memset(buf, 0xaa, len);

    memwrite(guest_buf, buf, len);



    style = send_dma_request(CMD_WRITE_DMA, 1, 1, prot,

                              ARRAY_SIZE(prot), NULL);

    g_assert_cmphex(style, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ideccstable + reg_status), DF | ERR);



    /* Read and verify 0x55 pattern in sector 0 */

    memset(cmpcb, 0x55, len);



    style = send_dma_request(CMD_READ_DMA, 0, 1, prot, ARRAY_SIZE(prot), NULL);

    g_assert_cmphex(style, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ideccstable + reg_status), DF | ERR);



    memread(guest_buf, buf, len);

    g_assert(memcmp(buf, cmpcb, len) == 0);



    /* Read and verify 0xaa pattern in sector 1 */

    memset(cmpcb, 0xaa, len);



    style = send_dma_request(CMD_READ_DMA, 1, 1, prot, ARRAY_SIZE(prot), NULL);

    g_assert_cmphex(style, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ideccstable + reg_status), DF | ERR);



    memread(guest_buf, buf, len);

    g_assert(memcmp(buf, cmpcb, len) == 0);





    g_free(buf);

    g_free(cmpcb);

}
",1,1,0,1,"dev,bmdma_base,ide_base,status,buf,cmpbuf,prdt","dev:0.005585014820098877,bmdma_base:0.050200819969177246,ide_base:0.035694241523742676,status:0.018745481967926025,buf:-0.007677972316741943,cmpbuf:0.020205318927764893,prdt:0.05141264200210571,",5,33,"prdt:prot,bmdma_base:bmdta__area,ide_base:ideccstable,cmpbuf:cmpcb,status:style,",Greedy,364,0.0747062881787618
180,"static int idcin_read_packet(AVFormatContext *s,

                             AVPacket *pkt)

{

    int ret;

    unsigned int command;

    unsigned int chunk_size;

    IdcinDemuxContext *idcin = s->priv_data;

    AVIOContext *pb = s->pb;

    int i;

    int palette_scale;

    unsigned char r, g, b;

    unsigned char palette_buffer[768];

    uint32_t palette[256];



    if (s->pb->eof_reached)

        return AVERROR(EIO);



    if (idcin->next_chunk_is_video) {

        command = avio_rl32(pb);

        if (command == 2) {

            return AVERROR(EIO);

        } else if (command == 1) {

            /* trigger a palette change */

            if (avio_read(pb, palette_buffer, 768) != 768)

                return AVERROR(EIO);

            /* scale the palette as necessary */

            palette_scale = 2;

            for (i = 0; i < 768; i++)

                if (palette_buffer[i] > 63) {

                    palette_scale = 0;

                    break;




            for (i = 0; i < 256; i++) {

                r = palette_buffer[i * 3    ] << palette_scale;

                g = palette_buffer[i * 3 + 1] << palette_scale;

                b = palette_buffer[i * 3 + 2] << palette_scale;

                palette[i] = (r << 16) | (g << 8) | (b);





        chunk_size = avio_rl32(pb);





        /* skip the number of decoded bytes (always equal to width * height) */

        avio_skip(pb, 4);

        chunk_size -= 4;

        ret= av_get_packet(pb, pkt, chunk_size);

        if (ret < 0)

            return ret;

        if (command == 1) {

            uint8_t *pal;



            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,

                                          AVPALETTE_SIZE);

            if (ret < 0)

                return ret;

            memcpy(pal, palette, AVPALETTE_SIZE);

            pkt->flags |= AV_PKT_FLAG_KEY;


        pkt->stream_index = idcin->video_stream_index;

        pkt->duration     = 1;

    } else {

        /* send out the audio chunk */

        if (idcin->current_audio_chunk)

            chunk_size = idcin->audio_chunk_size2;

        else

            chunk_size = idcin->audio_chunk_size1;

        ret= av_get_packet(pb, pkt, chunk_size);

        if (ret < 0)

            return ret;

        pkt->stream_index = idcin->audio_stream_index;

        pkt->duration     = chunk_size / idcin->block_align;



        idcin->current_audio_chunk ^= 1;




    if (idcin->audio_present)

        idcin->next_chunk_is_video ^= 1;



    return ret;
",420,"static int idcin_read_packet(AVFormatContext *sync,

                             AVPacket * pnt)

{

    int alt;

    unsigned int option;

    unsigned int chunkedscale;

    IdcinDemuxContext *inxc = sync->priv_data;

    AVIOContext *cpp = sync->cpp;

    int id;

    int palette·span;

    unsigned char br, q, p;

    unsigned char palettealqueue[768];

    uint32_t palette[256];



    if (sync->cpp->eof_reached)

        return AVERROR(EIO);



    if (inxc->next_chunk_is_video) {

        option = avio_rl32(cpp);

        if (option == 2) {

            return AVERROR(EIO);

        } else if (option == 1) {

            /* trigger a palette change */

            if (avio_read(cpp, palettealqueue, 768) != 768)

                return AVERROR(EIO);

            /* scale the palette as necessary */

            palette·span = 2;

            for (id = 0; id < 768; id++)

                if (palettealqueue[id] > 63) {

                    palette·span = 0;

                    break;




            for (id = 0; id < 256; id++) {

                br = palettealqueue[id * 3    ] << palette·span;

                q = palettealqueue[id * 3 + 1] << palette·span;

                p = palettealqueue[id * 3 + 2] << palette·span;

                palette[id] = (br << 16) | (q << 8) | (p);





        chunkedscale = avio_rl32(cpp);





        /* skip the number of decoded bytes (always equal to width * height) */

        avio_skip(cpp, 4);

        chunkedscale -= 4;

        alt= av_get_packet(cpp,  pnt, chunkedscale);

        if (alt < 0)

            return alt;

        if (option == 1) {

            uint8_t *ask;



            ask = av_packet_new_side_data( pnt, AV_PKT_DATA_PALETTE,

                                          AVPALETTE_SIZE);

            if (alt < 0)

                return alt;

            memcpy(ask, palette, AVPALETTE_SIZE);

             pnt->flags |= AV_PKT_FLAG_KEY;


         pnt->stream_index = inxc->video_stream_index;

         pnt->duration     = 1;

    } else {

        /* send out the audio chunk */

        if (inxc->current_audio_chunk)

            chunkedscale = inxc->audio_chunk_size2;

        else

            chunkedscale = inxc->audio_chunk_size1;

        alt= av_get_packet(cpp,  pnt, chunkedscale);

        if (alt < 0)

            return alt;

         pnt->stream_index = inxc->audio_stream_index;

         pnt->duration     = chunkedscale / inxc->block_align;



        inxc->current_audio_chunk ^= 1;




    if (inxc->audio_present)

        inxc->next_chunk_is_video ^= 1;



    return alt;
",1,1,1,-1,"s,pkt,ret,command,chunk_size,idcin,pb,i,palette_scale,r,g,b,palette_buffer,palette,pal","s:0.0002554655075073242,pkt:0.00013023614883422852,ret:0.0008751153945922852,command:9.036064147949219e-05,chunk_size:0.00039273500442504883,idcin:0.00023502111434936523,pb:0.0001487135887145996,i:0.0004469752311706543,palette_scale:0.00020134449005126953,r:0.0002192854881286621,g:3.898143768310547e-05,b:0.00019276142120361328,palette_buffer:-0.0004552602767944336,palette:0.0005151033401489258,pal:0.0001596212387084961,",14,92,"ret:alt,palette:palette,i:id,chunk_size:chunkedscale,s:sync,idcin:inxc,r:br,palette_scale:palette·span,b:p,pal:ask,pb:cpp,pkt: pnt,command:option,g:q,palette_buffer:palettealqueue,",Greedy,869,0.18092548449834187
181,"static inline void RENAME(yuv2rgb555_2)(SwsContext *c, const uint16_t *buf0,

                                        const uint16_t *buf1, const uint16_t *ubuf0,

                                        const uint16_t *ubuf1, const uint16_t *vbuf0,

                                        const uint16_t *vbuf1, const uint16_t *abuf0,

                                        const uint16_t *abuf1, uint8_t *dest,

                                        int dstW, int yalpha, int uvalpha, int y)

{

    x86_reg uv_off = c->uv_off << 1;



    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(

    __asm__ volatile(

        ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""

        ""mov        %4, %%""REG_b""               \n\t""

        ""push %%""REG_BP""                        \n\t""

        YSCALEYUV2RGB(%%REGBP, %5, %6)

        ""pxor    %%mm7, %%mm7                   \n\t""

        /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */

#ifdef DITHER1XBPP

        ""paddusb ""BLUE_DITHER""(%5), %%mm2      \n\t""

        ""paddusb ""GREEN_DITHER""(%5), %%mm4      \n\t""

        ""paddusb ""RED_DITHER""(%5), %%mm5      \n\t""

#endif

        WRITERGB15(%%REGb, 8280(%5), %%REGBP)

        ""pop %%""REG_BP""                         \n\t""

        ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""

        :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),

           ""a"" (&c->redDither), ""m""(uv_off)

    );

}
",221,,1,0,,-4,"c,buf0,buf1,ubuf0,ubuf1,vbuf0,vbuf1,abuf0,abuf1,dest,dstW,yalpha,uvalpha,y",,,,,Greedy,1,0.00255970557530721
182,"static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)

{

    VirtIOBlockReq *req = virtio_blk_alloc_request(s);



    if (!virtqueue_pop(s->vq, &req->elem)) {

        virtio_blk_free_request(req);

        return NULL;

    }



    return req;

}
",48,,0,1,,-4,"s,req",,,,,Greedy,1,0.002152538299560547
183,"static int output_packet(InputStream *ist, const AVPacket *pkt)

{

    int ret = 0, i;

    int got_output;



    AVPacket avpkt;

    if (!ist->saw_first_ts) {

        ist->dts = ist->st->avg_frame_rate.num ? - ist->st->codec->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0;

        ist->pts = 0;

        if (pkt != NULL && pkt->pts != AV_NOPTS_VALUE && !ist->decoding_needed) {

            ist->dts += av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);

            ist->pts = ist->dts; //unused but better to set it to a value thats not totally wrong

        }

        ist->saw_first_ts = 1;

    }



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->dts;

    if (ist->next_pts == AV_NOPTS_VALUE)

        ist->next_pts = ist->pts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE) {

        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);

        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)

            ist->next_pts = ist->pts = ist->dts;

    }



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int duration;

    handle_eof:



        ist->pts = ist->next_pts;

        ist->dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->st->codec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &got_output);

            if (avpkt.duration) {

                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            } else if(ist->st->codec->time_base.num != 0 && ist->st->codec->time_base.den != 0) {

                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;

                duration = ((int64_t)AV_TIME_BASE *

                                ist->st->codec->time_base.num * ticks) /

                                ist->st->codec->time_base.den;

            } else

                duration = 0;



            if(ist->dts != AV_NOPTS_VALUE && duration) {

                ist->next_dts += duration;

            }else

                ist->next_dts = AV_NOPTS_VALUE;



            if (got_output)

                ist->next_pts += duration; //FIXME the duration is not correct in some cases

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;



        avpkt.dts=

        avpkt.pts= AV_NOPTS_VALUE;



        // touch data and size only if not EOF

        if (pkt) {

            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)

                ret = avpkt.size;

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        rate_emu_sleep(ist);

        ist->dts = ist->next_dts;

        switch (ist->st->codec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /

                             ist->st->codec->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (pkt->duration) {

                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);

            } else if(ist->st->codec->time_base.num != 0) {

                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->st->codec->time_base.num * ticks) /

                                  ist->st->codec->time_base.den;

            }

            break;

        }

        ist->pts = ist->dts;

        ist->next_pts = ist->next_dts;

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",878,,0,1,,-4,"ist,pkt,i,got_output,avpkt,duration",,,,,Greedy,1,0.002418339252471924
184,"void qemu_system_reset(void)

{

    QEMUResetEntry *re, *nre;



    /* reset all devices */

    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {

        re->func(re->opaque);

    }


}",37,"void qemu_system_reset(void)

{

    QEMUResetEntry *re, *lcre;



    /* reset all devices */

    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, lcre) {

        re->func(re->opaque);

    }


}",1,1,0,1,"re,nre","re:0.09510929882526398,nre:0.1986588090658188,",1,2,"nre:lcre,",Greedy,29,0.009203831354777018
185,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
",209,"static void sd_reset(SDState *od, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    od->state = sd_idle_state;

    od->rca = 0x0000;

    sd_set_ocr(od);

    sd_set_scr(od);

    sd_set_cid(od);

    sd_set_csd(od, size);

    sd_set_cardstatus(od);

    sd_set_sdstatus(od);



    od->bdrv = bdrv;



    if (od->wp_groups)

        g_free(od->wp_groups);

    od->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    od->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(od->function_group, 0, sizeof(int) * 6);

    od->erase_start = 0;

    od->erase_end = 0;

    od->size = size;

    od->blk_len = 0x200;

    od->pwd_len = 0;

    od->expecting_acmd = 0;

}
",0,0,1,1,"sd,bdrv,size,sect","sd:0.4558953046798706,bdrv:0.042437002062797546,size:0.12706752121448517,sect:0.10127544403076172,",1,21,"sd:od,",Greedy,110,0.0211515744527181
186,"static void phys_page_set(AddressSpaceDispatch *d,

                          target_phys_addr_t index, target_phys_addr_t nb,

                          uint16_t leaf)

{

    /* Wildly overreserve - it doesn't matter much. */

    phys_map_node_reserve(3 * P_L2_LEVELS);



    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);

}
",46,"static void phys_page_set(AddressSpaceDispatch *dos,

                          target_phys_addr_t batch, target_phys_addr_t batch,

                          uint16_t batch)

{

    /* Wildly overreserve - it doesn't matter much. */

    phys_map_node_reserve(3 * P_L2_LEVELS);



    phys_page_set_level(&dos->phys_map, &batch, &batch, batch, P_L2_LEVELS - 1);

}
",0,0,0,-1,"d,index,nb,leaf","d:-0.0005207732319831848,index:0.001360677182674408,nb:0.001655754167586565,leaf:0.00181886600330472,",4,8,"leaf:batch,nb:batch,index:batch,d:dos,",Greedy,164,0.03183528979619344
187,"static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,

                              const int *const_args)

{

    int c;



    switch (opc) {

    case INDEX_op_exit_tb:

        if (check_fit_tl(args[0], 13)) {

            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);

            tcg_out_movi_imm13(s, TCG_REG_O0, args[0]);

        } else {

            tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0] & ~0x3ff);

            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);

            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0,

                           args[0] & 0x3ff, ARITH_OR);

        }

        break;

    case INDEX_op_goto_tb:

        if (s->tb_jmp_offset) {

            /* direct jump method */

            uint32_t old_insn = *(uint32_t *)s->code_ptr;

            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;

            /* Make sure to preserve links during retranslation.  */

            tcg_out32(s, CALL | (old_insn & ~INSN_OP(-1)));

        } else {

            /* indirect jump method */

            tcg_out_ld_ptr(s, TCG_REG_T1, (uintptr_t)(s->tb_next + args[0]));

            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_T1, 0, JMPL);

        }

        tcg_out_nop(s);

        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;

        break;

    case INDEX_op_call:

        if (const_args[0]) {

            tcg_out_calli(s, args[0]);

        } else {

            tcg_out_arithi(s, TCG_REG_O7, args[0], 0, JMPL);

        }

        /* delay slot */

        tcg_out_nop(s);

        break;

    case INDEX_op_br:

        tcg_out_bpcc(s, COND_A, BPCC_PT, args[0]);

        tcg_out_nop(s);

        break;

    case INDEX_op_movi_i32:

        tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]);

        break;



#define OP_32_64(x)                             \

        glue(glue(case INDEX_op_, x), _i32):    \

        glue(glue(case INDEX_op_, x), _i64)



    OP_32_64(ld8u):

        tcg_out_ldst(s, args[0], args[1], args[2], LDUB);

        break;

    OP_32_64(ld8s):

        tcg_out_ldst(s, args[0], args[1], args[2], LDSB);

        break;

    OP_32_64(ld16u):

        tcg_out_ldst(s, args[0], args[1], args[2], LDUH);

        break;

    OP_32_64(ld16s):

        tcg_out_ldst(s, args[0], args[1], args[2], LDSH);

        break;

    case INDEX_op_ld_i32:

    case INDEX_op_ld32u_i64:

        tcg_out_ldst(s, args[0], args[1], args[2], LDUW);

        break;

    OP_32_64(st8):

        tcg_out_ldst(s, args[0], args[1], args[2], STB);

        break;

    OP_32_64(st16):

        tcg_out_ldst(s, args[0], args[1], args[2], STH);

        break;

    case INDEX_op_st_i32:

    case INDEX_op_st32_i64:

        tcg_out_ldst(s, args[0], args[1], args[2], STW);

        break;

    OP_32_64(add):

        c = ARITH_ADD;

        goto gen_arith;

    OP_32_64(sub):

        c = ARITH_SUB;

        goto gen_arith;

    OP_32_64(and):

        c = ARITH_AND;

        goto gen_arith;

    OP_32_64(andc):

        c = ARITH_ANDN;

        goto gen_arith;

    OP_32_64(or):

        c = ARITH_OR;

        goto gen_arith;

    OP_32_64(orc):

        c = ARITH_ORN;

        goto gen_arith;

    OP_32_64(xor):

        c = ARITH_XOR;

        goto gen_arith;

    case INDEX_op_shl_i32:

        c = SHIFT_SLL;

    do_shift32:

        /* Limit immediate shift count lest we create an illegal insn.  */

        tcg_out_arithc(s, args[0], args[1], args[2] & 31, const_args[2], c);

        break;

    case INDEX_op_shr_i32:

        c = SHIFT_SRL;

        goto do_shift32;

    case INDEX_op_sar_i32:

        c = SHIFT_SRA;

        goto do_shift32;

    case INDEX_op_mul_i32:

        c = ARITH_UMUL;

        goto gen_arith;



    OP_32_64(neg):

	c = ARITH_SUB;

	goto gen_arith1;

    OP_32_64(not):

	c = ARITH_ORN;

	goto gen_arith1;



    case INDEX_op_div_i32:

        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 0);

        break;

    case INDEX_op_divu_i32:

        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 1);

        break;



    case INDEX_op_brcond_i32:

        tcg_out_brcond_i32(s, args[2], args[0], args[1], const_args[1],

                           args[3]);

        break;

    case INDEX_op_setcond_i32:

        tcg_out_setcond_i32(s, args[3], args[0], args[1],

                            args[2], const_args[2]);

        break;

    case INDEX_op_movcond_i32:

        tcg_out_movcond_i32(s, args[5], args[0], args[1],

                            args[2], const_args[2], args[3], const_args[3]);

        break;



    case INDEX_op_add2_i32:

        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],

                        args[4], const_args[4], args[5], const_args[5],

                        ARITH_ADDCC, ARITH_ADDX);

        break;

    case INDEX_op_sub2_i32:

        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],

                        args[4], const_args[4], args[5], const_args[5],

                        ARITH_SUBCC, ARITH_SUBX);

        break;

    case INDEX_op_mulu2_i32:

        c = ARITH_UMUL;

        goto do_mul2;

    case INDEX_op_muls2_i32:

        c = ARITH_SMUL;

    do_mul2:

        /* The 32-bit multiply insns produce a full 64-bit result.  If the

           destination register can hold it, we can avoid the slower RDY.  */

        tcg_out_arithc(s, args[0], args[2], args[3], const_args[3], c);

        if (SPARC64 || args[0] <= TCG_REG_O7) {

            tcg_out_arithi(s, args[1], args[0], 32, SHIFT_SRLX);

        } else {

            tcg_out_rdy(s, args[1]);

        }

        break;



    case INDEX_op_qemu_ld_i32:

        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], false);

        break;

    case INDEX_op_qemu_ld_i64:

        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], true);

        break;

    case INDEX_op_qemu_st_i32:

        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);

        break;

    case INDEX_op_qemu_st_i64:

        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);

        break;



    case INDEX_op_movi_i64:

        tcg_out_movi(s, TCG_TYPE_I64, args[0], args[1]);

        break;

    case INDEX_op_ld32s_i64:

        tcg_out_ldst(s, args[0], args[1], args[2], LDSW);

        break;

    case INDEX_op_ld_i64:

        tcg_out_ldst(s, args[0], args[1], args[2], LDX);

        break;

    case INDEX_op_st_i64:

        tcg_out_ldst(s, args[0], args[1], args[2], STX);

        break;

    case INDEX_op_shl_i64:

        c = SHIFT_SLLX;

    do_shift64:

        /* Limit immediate shift count lest we create an illegal insn.  */

        tcg_out_arithc(s, args[0], args[1], args[2] & 63, const_args[2], c);

        break;

    case INDEX_op_shr_i64:

        c = SHIFT_SRLX;

        goto do_shift64;

    case INDEX_op_sar_i64:

        c = SHIFT_SRAX;

        goto do_shift64;

    case INDEX_op_mul_i64:

        c = ARITH_MULX;

        goto gen_arith;

    case INDEX_op_div_i64:

        c = ARITH_SDIVX;

        goto gen_arith;

    case INDEX_op_divu_i64:

        c = ARITH_UDIVX;

        goto gen_arith;

    case INDEX_op_ext32s_i64:

        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRA);

        break;

    case INDEX_op_ext32u_i64:

        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRL);

        break;

    case INDEX_op_trunc_shr_i32:

        if (args[2] == 0) {

            tcg_out_mov(s, TCG_TYPE_I32, args[0], args[1]);

        } else {

            tcg_out_arithi(s, args[0], args[1], args[2], SHIFT_SRLX);

        }

        break;



    case INDEX_op_brcond_i64:

        tcg_out_brcond_i64(s, args[2], args[0], args[1], const_args[1],

                           args[3]);

        break;

    case INDEX_op_setcond_i64:

        tcg_out_setcond_i64(s, args[3], args[0], args[1],

                            args[2], const_args[2]);

        break;

    case INDEX_op_movcond_i64:

        tcg_out_movcond_i64(s, args[5], args[0], args[1],

                            args[2], const_args[2], args[3], const_args[3]);

        break;



    gen_arith:

        tcg_out_arithc(s, args[0], args[1], args[2], const_args[2], c);

        break;



    gen_arith1:

	tcg_out_arithc(s, args[0], TCG_REG_G0, args[1], const_args[1], c);

	break;



    default:

        fprintf(stderr, ""unknown opcode 0x%x\n"", opc);

        tcg_abort();

    }

}
",1757,"static inline void tcg_out_op(TCGContext *your, TCGOpcode opc, const TCGArg *args,

                              const int *const_args)

{

    int c;



    switch (opc) {

    case INDEX_op_exit_tb:

        if (check_fit_tl(args[0], 13)) {

            tcg_out_arithi(your, TCG_REG_G0, TCG_REG_I7, 8, RETURN);

            tcg_out_movi_imm13(your, TCG_REG_O0, args[0]);

        } else {

            tcg_out_movi(your, TCG_TYPE_PTR, TCG_REG_I0, args[0] & ~0x3ff);

            tcg_out_arithi(your, TCG_REG_G0, TCG_REG_I7, 8, RETURN);

            tcg_out_arithi(your, TCG_REG_O0, TCG_REG_O0,

                           args[0] & 0x3ff, ARITH_OR);

        }

        break;

    case INDEX_op_goto_tb:

        if (your->tb_jmp_offset) {

            /* direct jump method */

            uint32_t old_insn = *(uint32_t *)your->code_ptr;

            your->tb_jmp_offset[args[0]] = your->code_ptr - your->code_buf;

            /* Make sure to preserve links during retranslation.  */

            tcg_out32(your, CALL | (old_insn & ~INSN_OP(-1)));

        } else {

            /* indirect jump method */

            tcg_out_ld_ptr(your, TCG_REG_T1, (uintptr_t)(your->tb_next + args[0]));

            tcg_out_arithi(your, TCG_REG_G0, TCG_REG_T1, 0, JMPL);

        }

        tcg_out_nop(your);

        your->tb_next_offset[args[0]] = your->code_ptr - your->code_buf;

        break;

    case INDEX_op_call:

        if (const_args[0]) {

            tcg_out_calli(your, args[0]);

        } else {

            tcg_out_arithi(your, TCG_REG_O7, args[0], 0, JMPL);

        }

        /* delay slot */

        tcg_out_nop(your);

        break;

    case INDEX_op_br:

        tcg_out_bpcc(your, COND_A, BPCC_PT, args[0]);

        tcg_out_nop(your);

        break;

    case INDEX_op_movi_i32:

        tcg_out_movi(your, TCG_TYPE_I32, args[0], (uint32_t)args[1]);

        break;



#define OP_32_64(x)                             \

        glue(glue(case INDEX_op_, x), _i32):    \

        glue(glue(case INDEX_op_, x), _i64)



    OP_32_64(ld8u):

        tcg_out_ldst(your, args[0], args[1], args[2], LDUB);

        break;

    OP_32_64(ld8s):

        tcg_out_ldst(your, args[0], args[1], args[2], LDSB);

        break;

    OP_32_64(ld16u):

        tcg_out_ldst(your, args[0], args[1], args[2], LDUH);

        break;

    OP_32_64(ld16s):

        tcg_out_ldst(your, args[0], args[1], args[2], LDSH);

        break;

    case INDEX_op_ld_i32:

    case INDEX_op_ld32u_i64:

        tcg_out_ldst(your, args[0], args[1], args[2], LDUW);

        break;

    OP_32_64(st8):

        tcg_out_ldst(your, args[0], args[1], args[2], STB);

        break;

    OP_32_64(st16):

        tcg_out_ldst(your, args[0], args[1], args[2], STH);

        break;

    case INDEX_op_st_i32:

    case INDEX_op_st32_i64:

        tcg_out_ldst(your, args[0], args[1], args[2], STW);

        break;

    OP_32_64(add):

        c = ARITH_ADD;

        goto gen_arith;

    OP_32_64(sub):

        c = ARITH_SUB;

        goto gen_arith;

    OP_32_64(and):

        c = ARITH_AND;

        goto gen_arith;

    OP_32_64(andc):

        c = ARITH_ANDN;

        goto gen_arith;

    OP_32_64(or):

        c = ARITH_OR;

        goto gen_arith;

    OP_32_64(orc):

        c = ARITH_ORN;

        goto gen_arith;

    OP_32_64(xor):

        c = ARITH_XOR;

        goto gen_arith;

    case INDEX_op_shl_i32:

        c = SHIFT_SLL;

    do_shift32:

        /* Limit immediate shift count lest we create an illegal insn.  */

        tcg_out_arithc(your, args[0], args[1], args[2] & 31, const_args[2], c);

        break;

    case INDEX_op_shr_i32:

        c = SHIFT_SRL;

        goto do_shift32;

    case INDEX_op_sar_i32:

        c = SHIFT_SRA;

        goto do_shift32;

    case INDEX_op_mul_i32:

        c = ARITH_UMUL;

        goto gen_arith;



    OP_32_64(neg):

	c = ARITH_SUB;

	goto gen_arith1;

    OP_32_64(not):

	c = ARITH_ORN;

	goto gen_arith1;



    case INDEX_op_div_i32:

        tcg_out_div32(your, args[0], args[1], args[2], const_args[2], 0);

        break;

    case INDEX_op_divu_i32:

        tcg_out_div32(your, args[0], args[1], args[2], const_args[2], 1);

        break;



    case INDEX_op_brcond_i32:

        tcg_out_brcond_i32(your, args[2], args[0], args[1], const_args[1],

                           args[3]);

        break;

    case INDEX_op_setcond_i32:

        tcg_out_setcond_i32(your, args[3], args[0], args[1],

                            args[2], const_args[2]);

        break;

    case INDEX_op_movcond_i32:

        tcg_out_movcond_i32(your, args[5], args[0], args[1],

                            args[2], const_args[2], args[3], const_args[3]);

        break;



    case INDEX_op_add2_i32:

        tcg_out_addsub2(your, args[0], args[1], args[2], args[3],

                        args[4], const_args[4], args[5], const_args[5],

                        ARITH_ADDCC, ARITH_ADDX);

        break;

    case INDEX_op_sub2_i32:

        tcg_out_addsub2(your, args[0], args[1], args[2], args[3],

                        args[4], const_args[4], args[5], const_args[5],

                        ARITH_SUBCC, ARITH_SUBX);

        break;

    case INDEX_op_mulu2_i32:

        c = ARITH_UMUL;

        goto do_mul2;

    case INDEX_op_muls2_i32:

        c = ARITH_SMUL;

    do_mul2:

        /* The 32-bit multiply insns produce a full 64-bit result.  If the

           destination register can hold it, we can avoid the slower RDY.  */

        tcg_out_arithc(your, args[0], args[2], args[3], const_args[3], c);

        if (SPARC64 || args[0] <= TCG_REG_O7) {

            tcg_out_arithi(your, args[1], args[0], 32, SHIFT_SRLX);

        } else {

            tcg_out_rdy(your, args[1]);

        }

        break;



    case INDEX_op_qemu_ld_i32:

        tcg_out_qemu_ld(your, args[0], args[1], args[2], args[3], false);

        break;

    case INDEX_op_qemu_ld_i64:

        tcg_out_qemu_ld(your, args[0], args[1], args[2], args[3], true);

        break;

    case INDEX_op_qemu_st_i32:

        tcg_out_qemu_st(your, args[0], args[1], args[2], args[3]);

        break;

    case INDEX_op_qemu_st_i64:

        tcg_out_qemu_st(your, args[0], args[1], args[2], args[3]);

        break;



    case INDEX_op_movi_i64:

        tcg_out_movi(your, TCG_TYPE_I64, args[0], args[1]);

        break;

    case INDEX_op_ld32s_i64:

        tcg_out_ldst(your, args[0], args[1], args[2], LDSW);

        break;

    case INDEX_op_ld_i64:

        tcg_out_ldst(your, args[0], args[1], args[2], LDX);

        break;

    case INDEX_op_st_i64:

        tcg_out_ldst(your, args[0], args[1], args[2], STX);

        break;

    case INDEX_op_shl_i64:

        c = SHIFT_SLLX;

    do_shift64:

        /* Limit immediate shift count lest we create an illegal insn.  */

        tcg_out_arithc(your, args[0], args[1], args[2] & 63, const_args[2], c);

        break;

    case INDEX_op_shr_i64:

        c = SHIFT_SRLX;

        goto do_shift64;

    case INDEX_op_sar_i64:

        c = SHIFT_SRAX;

        goto do_shift64;

    case INDEX_op_mul_i64:

        c = ARITH_MULX;

        goto gen_arith;

    case INDEX_op_div_i64:

        c = ARITH_SDIVX;

        goto gen_arith;

    case INDEX_op_divu_i64:

        c = ARITH_UDIVX;

        goto gen_arith;

    case INDEX_op_ext32s_i64:

        tcg_out_arithi(your, args[0], args[1], 0, SHIFT_SRA);

        break;

    case INDEX_op_ext32u_i64:

        tcg_out_arithi(your, args[0], args[1], 0, SHIFT_SRL);

        break;

    case INDEX_op_trunc_shr_i32:

        if (args[2] == 0) {

            tcg_out_mov(your, TCG_TYPE_I32, args[0], args[1]);

        } else {

            tcg_out_arithi(your, args[0], args[1], args[2], SHIFT_SRLX);

        }

        break;



    case INDEX_op_brcond_i64:

        tcg_out_brcond_i64(your, args[2], args[0], args[1], const_args[1],

                           args[3]);

        break;

    case INDEX_op_setcond_i64:

        tcg_out_setcond_i64(your, args[3], args[0], args[1],

                            args[2], const_args[2]);

        break;

    case INDEX_op_movcond_i64:

        tcg_out_movcond_i64(your, args[5], args[0], args[1],

                            args[2], const_args[2], args[3], const_args[3]);

        break;



    gen_arith:

        tcg_out_arithc(your, args[0], args[1], args[2], const_args[2], c);

        break;



    gen_arith1:

	tcg_out_arithc(your, args[0], TCG_REG_G0, args[1], const_args[1], c);

	break;



    default:

        fprintf(stderr, ""unknown opcode 0x%x
"", opc);

        tcg_abort();

    }

}
",0,0,1,1,"s,opc,args,const_args,c","s:0.09180100075900555,opc:0.0037752222269773483,args:0.04990863427519798,const_args:0.02491762302815914,c:0.002566467970609665,",1,62,"s:your,",Greedy,329,0.09535190661748251
188,"static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,

                                 int *got_frame_ptr, AVPacket *avpkt)

{

    EightSvxContext *esc = avctx->priv_data;

    int n, out_data_size;

    int ch, ret;

    uint8_t *src;



    /* decode and interleave the first packet */

    if (!esc->samples && avpkt) {

        int packet_size = avpkt->size;



        if (packet_size % avctx->channels) {

            av_log(avctx, AV_LOG_WARNING, ""Packet with odd size, ignoring last byte\n"");

            if (packet_size < avctx->channels)

                return packet_size;

            packet_size -= packet_size % avctx->channels;

        }

        esc->samples_size = !esc->table ?

            packet_size : avctx->channels + (packet_size-avctx->channels) * 2;

        if (!(esc->samples = av_malloc(esc->samples_size)))

            return AVERROR(ENOMEM);



        /* decompress */

        if (esc->table) {

            const uint8_t *buf = avpkt->data;

            uint8_t *dst;

            int buf_size = avpkt->size;

            int i, n = esc->samples_size;



            if (buf_size < 2) {

                av_log(avctx, AV_LOG_ERROR, ""packet size is too small\n"");

                return AVERROR(EINVAL);

            }



            /* the uncompressed starting value is contained in the first byte */

            dst = esc->samples;

            for (i = 0; i < avctx->channels; i++) {

                *(dst++) = buf[0]+128;

                delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0]+128)&0xFF, esc->table);

                buf += buf_size / avctx->channels;

                dst += n / avctx->channels - 1;

            }

        } else {

            raw_decode(esc->samples, avpkt->data, esc->samples_size);

        }

    }



    /* get output buffer */

    av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels));

    esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx)  / avctx->channels;

    if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return ret;

    }



    *got_frame_ptr   = 1;

    *(AVFrame *)data = esc->frame;



    out_data_size = esc->frame.nb_samples;

    for (ch = 0; ch<avctx->channels; ch++) {

        src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels;

        memcpy(esc->frame.data[ch], src, out_data_size);

    }

    out_data_size *= avctx->channels;

    esc->samples_idx += out_data_size;



    return esc->table ?

        (avctx->frame_number == 0)*2 + out_data_size / 2 :

        out_data_size;

}
",507,,0,1,,-4,"avctx,data,got_frame_ptr,avpkt,esc,n,out_data_size,ch,ret,src,buf,dst,i",,,,,Greedy,1,0.002503478527069092
189,"static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIOSerial *s = opaque;

    VirtIOSerialPort *port;

    uint32_t max_nr_ports, nr_active_ports, ports_map;

    unsigned int i;

    int ret;



    if (version_id > 3) {

        return -EINVAL;

    }



    /* The virtio device */

    ret = virtio_load(&s->vdev, f);

    if (ret) {

        return ret;

    }



    if (version_id < 2) {

        return 0;

    }



    /* The config space */

    qemu_get_be16s(f, &s->config.cols);

    qemu_get_be16s(f, &s->config.rows);



    qemu_get_be32s(f, &max_nr_ports);

    tswap32s(&max_nr_ports);

    if (max_nr_ports > tswap32(s->config.max_nr_ports)) {

        /* Source could have had more ports than us. Fail migration. */

        return -EINVAL;

    }



    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {

        qemu_get_be32s(f, &ports_map);



        if (ports_map != s->ports_map[i]) {

            /*

             * Ports active on source and destination don't

             * match. Fail migration.

             */

            return -EINVAL;

        }

    }



    qemu_get_be32s(f, &nr_active_ports);



    /* Items in struct VirtIOSerialPort */

    for (i = 0; i < nr_active_ports; i++) {

        uint32_t id;

        bool host_connected;



        id = qemu_get_be32(f);

        port = find_port_by_id(s, id);

        if (!port) {

            return -EINVAL;

        }



        port->guest_connected = qemu_get_byte(f);

        host_connected = qemu_get_byte(f);

        if (host_connected != port->host_connected) {

            /*

             * We have to let the guest know of the host connection

             * status change

             */

            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN,

                               port->host_connected);

        }



        if (version_id > 2) {

            uint32_t elem_popped;



            qemu_get_be32s(f, &elem_popped);

            if (elem_popped) {

                qemu_get_be32s(f, &port->iov_idx);

                qemu_get_be64s(f, &port->iov_offset);



                qemu_get_buffer(f, (unsigned char *)&port->elem,

                                sizeof(port->elem));

                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,

                                 port->elem.in_num, 1);

                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,

                                 port->elem.out_num, 1);



                /*

                 *  Port was throttled on source machine.  Let's

                 *  unthrottle it here so data starts flowing again.

                 */

                virtio_serial_throttle_port(port, false);

            }

        }

    }

    return 0;

}
",404,"static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIOSerial *feed = opaque;

    VirtIOSerialPort *port;

    uint32_t max_nr_ports, nr_active_ports, ports_map;

    unsigned int i;

    int bf;



    if (version_id > 3) {

        return -EINVAL;

    }



    /* The virtio device */

    bf = virtio_load(&feed->vdev, f);

    if (bf) {

        return bf;

    }



    if (version_id < 2) {

        return 0;

    }



    /* The config space */

    qemu_get_be16s(f, &feed->config.cols);

    qemu_get_be16s(f, &feed->config.rows);



    qemu_get_be32s(f, &max_nr_ports);

    tswap32s(&max_nr_ports);

    if (max_nr_ports > tswap32(feed->config.max_nr_ports)) {

        /* Source could have had more ports than us. Fail migration. */

        return -EINVAL;

    }



    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {

        qemu_get_be32s(f, &ports_map);



        if (ports_map != feed->ports_map[i]) {

            /*

             * Ports active on source and destination don't

             * match. Fail migration.

             */

            return -EINVAL;

        }

    }



    qemu_get_be32s(f, &nr_active_ports);



    /* Items in struct VirtIOSerialPort */

    for (i = 0; i < nr_active_ports; i++) {

        uint32_t id;

        bool host_connected;



        id = qemu_get_be32(f);

        port = find_port_by_id(feed, id);

        if (!port) {

            return -EINVAL;

        }



        port->guest_connected = qemu_get_byte(f);

        host_connected = qemu_get_byte(f);

        if (host_connected != port->host_connected) {

            /*

             * We have to let the guest know of the host connection

             * status change

             */

            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN,

                               port->host_connected);

        }



        if (version_id > 2) {

            uint32_t elem_popping;



            qemu_get_be32s(f, &elem_popping);

            if (elem_popping) {

                qemu_get_be32s(f, &port->iov_idx);

                qemu_get_be64s(f, &port->iov_offset);



                qemu_get_buffer(f, (unsigned char *)&port->elem,

                                sizeof(port->elem));

                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,

                                 port->elem.in_num, 1);

                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,

                                 port->elem.out_num, 1);



                /*

                 *  Port was throttled on source machine.  Let's

                 *  unthrottle it here so data starts flowing again.

                 */

                virtio_serial_throttle_port(port, false);

            }

        }

    }

    return 0;

}
",0,0,1,1,"f,opaque,version_id,s,port,max_nr_ports,nr_active_ports,ports_map,i,ret,id,host_connected,elem_popped","f:0.0513099730014801,opaque:0.0557938814163208,version_id:0.009496301412582397,s:0.16607731580734253,port:-0.03564947843551636,max_nr_ports:-0.09282168745994568,nr_active_ports:-0.07511872053146362,ports_map:-0.03163456916809082,i:0.0129014253616333,ret:0.07570770382881165,id:0.03966104984283447,host_connected:-0.0022899210453033447,elem_popped:0.07630559802055359,",3,14,"s:feed,elem_popped:elem_popping,ret:bf,",Greedy,234,0.04781787395477295
190,"static CharDriverState *qemu_chr_open_spice_port(const char *id,

                                                 ChardevBackend *backend,

                                                 ChardevReturn *ret,

                                                 Error **errp)

{

    const char *name = backend->spiceport->fqdn;

    CharDriverState *chr;

    SpiceCharDriver *s;



    if (name == NULL) {

        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");

        return NULL;

    }



    chr = chr_open(""port"", spice_port_set_fe_open);

    s = chr->opaque;

    s->sin.portname = g_strdup(name);



    return chr;

}
",93,"static CharDriverState *qemu_chr_open_spice_port(const char *create,

                                                 ChardevBackend *backend,

                                                 ChardevReturn *resp,

                                                 Error **errsp)

{

    const char *f = backend->spiceport->fqdn;

    CharDriverState *chra;

    SpiceCharDriver *os;



    if (f == NULL) {

        fprintf(stderr, ""spice-qemu-char: missing name parameter
"");

        return NULL;

    }



    chra = chr_open(""port"", spice_port_set_fe_open);

    os = chra->opaque;

    os->sin.portname = g_strdup(f);



    return chra;

}
",0,0,0,-1,"id,backend,ret,errp,name,chr,s","id:-0.00027598999440670013,backend:8.358899503946304e-05,ret:-3.682449460029602e-05,errp:0.00022652838379144669,name:0.001014710869640112,chr:0.0007137558422982693,s:0.001302765216678381,",6,13,"s:os,name:f,chr:chra,errp:errsp,backend:backend,ret:resp,id:create,",Greedy,251,0.04889310995737712
191,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);



    breakpoint_invalidate(cpu, breakpoint->pc);



    g_free(breakpoint);

#endif

}
",46,"void cpu_breakpoint_remove_by_ref(CPUState *proc, CPUBreakpoint * breakdown)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&proc->breakpoints,  breakdown, entry);



    breakpoint_invalidate(proc,  breakdown->pc);



    g_free( breakdown);

#endif

}
",0,0,0,-1,"cpu,breakpoint","cpu:-0.013345248065888882,breakpoint:-0.002780364826321602,",2,7,"breakpoint: breakdown,cpu:proc,",Greedy,95,0.019060468673706053
192,"static int flv_write_trailer(AVFormatContext *s)

{

    int64_t file_size;



    AVIOContext *pb = s->pb;

    FLVContext *flv = s->priv_data;

    int i;



    /* Add EOS tag */

    for (i = 0; i < s->nb_streams; i++) {

        AVCodecContext *enc = s->streams[i]->codec;

        FLVStreamContext *sc = s->streams[i]->priv_data;

        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&

            enc->codec_id == AV_CODEC_ID_H264)

            put_avc_eos_tag(pb, sc->last_ts);

    }



    file_size = avio_tell(pb);



    /* update information */

    avio_seek(pb, flv->duration_offset, SEEK_SET);

    put_amf_double(pb, flv->duration / (double)1000);

    avio_seek(pb, flv->filesize_offset, SEEK_SET);

    put_amf_double(pb, file_size);



    avio_seek(pb, file_size, SEEK_SET);

    return 0;

}
",160,,1,0,,-4,"s,file_size,pb,flv,i,enc,sc",,,,,Greedy,1,0.0023680965105692545
193,"static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,

                                     const void *match_data, hwaddr *load_addr)

{

    BostonState *s = BOSTON(opaque);

    MachineState *machine = s->mach;

    const char *cmdline;

    int err;

    void *fdt;

    size_t fdt_sz, ram_low_sz, ram_high_sz;



    fdt_sz = fdt_totalsize(fdt_orig) * 2;

    fdt = g_malloc0(fdt_sz);



    err = fdt_open_into(fdt_orig, fdt, fdt_sz);

    if (err) {

        fprintf(stderr, ""unable to open FDT\n"");

        return NULL;

    }



    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])

            ? machine->kernel_cmdline : "" "";

    err = qemu_fdt_setprop_string(fdt, ""/chosen"", ""bootargs"", cmdline);

    if (err < 0) {

        fprintf(stderr, ""couldn't set /chosen/bootargs\n"");

        return NULL;

    }



    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);

    ram_high_sz = machine->ram_size - ram_low_sz;

    qemu_fdt_setprop_sized_cells(fdt, ""/memory@0"", ""reg"",

                                 1, 0x00000000, 1, ram_low_sz,

                                 1, 0x90000000, 1, ram_high_sz);



    fdt = g_realloc(fdt, fdt_totalsize(fdt));

    qemu_fdt_dumpdtb(fdt, fdt_sz);



    s->fdt_base = *load_addr;



    return fdt;

}
",239,"static const void *boston_fdt_filter(void *copaques, const void *fdt_slice,

                                     const void *test_buffer, hwaddr *load_order)

{

    BostonState *sg = BOSTON(copaques);

    MachineState *note = sg->mach;

    const char *mdLINE;

    int err;

    void *fdt;

    size_t fdt__sci, ram_low_aszo, ram_high_fz;



    fdt__sci = fdt_totalsize(fdt_slice) * 2;

    fdt = g_malloc0(fdt__sci);



    err = fdt_open_into(fdt_slice, fdt, fdt__sci);

    if (err) {

        fprintf(stderr, ""unable to open FDT
"");

        return NULL;

    }



    mdLINE = (note->kernel_cmdline && note->kernel_cmdline[0])

            ? note->kernel_cmdline : "" "";

    err = qemu_fdt_setprop_string(fdt, ""/chosen"", ""bootargs"", mdLINE);

    if (err < 0) {

        fprintf(stderr, ""couldn't set /chosen/bootargs
"");

        return NULL;

    }



    ram_low_aszo = MIN(256 * M_BYTE, note->ram_size);

    ram_high_fz = note->ram_size - ram_low_aszo;

    qemu_fdt_setprop_sized_cells(fdt, ""/memory@0"", ""reg"",

                                 1, 0x00000000, 1, ram_low_aszo,

                                 1, 0x90000000, 1, ram_high_fz);



    fdt = g_realloc(fdt, fdt_totalsize(fdt));

    qemu_fdt_dumpdtb(fdt, fdt__sci);



    sg->fdt_base = *load_order;



    return fdt;

}
",1,1,0,1,"opaque,fdt_orig,match_data,load_addr,s,machine,cmdline,err,fdt,fdt_sz,ram_low_sz,ram_high_sz","opaque:0.00661468505859375,fdt_orig:0.0053705573081970215,match_data:0.06792342662811279,load_addr:-0.005977511405944824,s:0.0015543103218078613,machine:-0.0030534863471984863,cmdline:0.0003070235252380371,err:-0.020664632320404053,fdt:-0.0196533203125,fdt_sz:0.010078847408294678,ram_low_sz:0.005227267742156982,ram_high_sz:0.0010219216346740723,",10,32,"match_data:test_buffer,fdt_sz:fdt__sci,opaque:copaques,fdt_orig:fdt_slice,ram_low_sz:ram_low_aszo,s:sg,ram_high_sz:ram_high_fz,cmdline:mdLINE,machine:note,load_addr:load_order,",Greedy,410,0.08483198881149293
194,"static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

#if CONFIG_ZLIB

    AVIOContext ctx;

    uint8_t *cmov_data;

    uint8_t *moov_data; /* uncompressed data */

    long cmov_len, moov_len;

    int ret = -1;



    avio_rb32(pb); /* dcom atom */

    if (avio_rl32(pb) != MKTAG('d','c','o','m'))

        return AVERROR_INVALIDDATA;

    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {

        av_log(c->fc, AV_LOG_ERROR, ""unknown compression for cmov atom !"");

        return AVERROR_INVALIDDATA;

    }

    avio_rb32(pb); /* cmvd atom */

    if (avio_rl32(pb) != MKTAG('c','m','v','d'))

        return AVERROR_INVALIDDATA;

    moov_len = avio_rb32(pb); /* uncompressed size */

    cmov_len = atom.size - 6 * 4;



    cmov_data = av_malloc(cmov_len);

    if (!cmov_data)

        return AVERROR(ENOMEM);

    moov_data = av_malloc(moov_len);

    if (!moov_data) {

        av_free(cmov_data);

        return AVERROR(ENOMEM);

    }

    avio_read(pb, cmov_data, cmov_len);

    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)

        goto free_and_return;

    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)

        goto free_and_return;

    atom.type = MKTAG('m','o','o','v');

    atom.size = moov_len;

    ret = mov_read_default(c, &ctx, atom);

free_and_return:

    av_free(moov_data);

    av_free(cmov_data);

    return ret;

#else

    av_log(c->fc, AV_LOG_ERROR, ""this file requires zlib support compiled in\n"");

    return AVERROR(ENOSYS);

#endif

}
",336,,1,0,,-4,"c,pb,atom,ctx,cmov_data,moov_data,cmov_len,moov_len",,,,,Greedy,1,0.00258255402247111
195,"static int sdp_parse_rtpmap(AVFormatContext *s,

                            AVCodecContext *codec, RTSPStream *rtsp_st,

                            int payload_type, const char *p)

{

    char buf[256];

    int i;

    AVCodec *c;

    const char *c_name;



    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and

     * see if we can handle this kind of payload.

     * The space should normally not be there but some Real streams or

     * particular servers (""RealServer Version 6.1.3.970"", see issue 1658)

     * have a trailing space. */

    get_word_sep(buf, sizeof(buf), ""/ "", &p);

    if (payload_type >= RTP_PT_PRIVATE) {

        RTPDynamicProtocolHandler *handler;

        for (handler = RTPFirstDynamicPayloadHandler;

             handler; handler = handler->next) {

            if (!strcasecmp(buf, handler->enc_name) &&

                codec->codec_type == handler->codec_type) {

                codec->codec_id          = handler->codec_id;

                rtsp_st->dynamic_handler = handler;

                if (handler->open)

                    rtsp_st->dynamic_protocol_context = handler->open();

                break;

            }

        }

    } else {

        /* We are in a standard case

         * (from http://www.iana.org/assignments/rtp-parameters). */

        /* search into AVRtpPayloadTypes[] */

        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);

    }



    c = avcodec_find_decoder(codec->codec_id);

    if (c && c->name)

        c_name = c->name;

    else

        c_name = (char *) NULL;



    if (c_name) {

        get_word_sep(buf, sizeof(buf), ""/"", &p);

        i = atoi(buf);

        switch (codec->codec_type) {

        case CODEC_TYPE_AUDIO:

            av_log(s, AV_LOG_DEBUG, ""audio codec set to: %s\n"", c_name);

            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;

            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;

            if (i > 0) {

                codec->sample_rate = i;

                get_word_sep(buf, sizeof(buf), ""/"", &p);

                i = atoi(buf);

                if (i > 0)

                    codec->channels = i;

                // TODO: there is a bug here; if it is a mono stream, and

                // less than 22000Hz, faad upconverts to stereo and twice

                // the frequency.  No problem, but the sample rate is being

                // set here by the sdp line. Patch on its way. (rdm)

            }

            av_log(s, AV_LOG_DEBUG, ""audio samplerate set to: %i\n"",

                   codec->sample_rate);

            av_log(s, AV_LOG_DEBUG, ""audio channels set to: %i\n"",

                   codec->channels);

            break;

        case CODEC_TYPE_VIDEO:

            av_log(s, AV_LOG_DEBUG, ""video codec set to: %s\n"", c_name);

            break;

        default:

            break;

        }

        return 0;

    }



    return -1;

}
",360,"static int sdp_parse_rtpmap(AVFormatContext *s,

                            AVCodecContext *codeef, RTSPStream *rtsp_st,

                            int payload_type, const char *p)

{

    char buf[256];

    int i;

    AVCodec *c;

    const char *c_name;



    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and

     * see if we can handle this kind of payload.

     * The space should normally not be there but some Real streams or

     * particular servers (""RealServer Version 6.1.3.970"", see issue 1658)

     * have a trailing space. */

    get_word_sep(buf, sizeof(buf), ""/ "", &p);

    if (payload_type >= RTP_PT_PRIVATE) {

        RTPDynamicProtocolHandler *handler;

        for (handler = RTPFirstDynamicPayloadHandler;

             handler; handler = handler->next) {

            if (!strcasecmp(buf, handler->enc_name) &&

                codeef->codec_type == handler->codec_type) {

                codeef->codec_id          = handler->codec_id;

                rtsp_st->dynamic_handler = handler;

                if (handler->open)

                    rtsp_st->dynamic_protocol_context = handler->open();

                break;

            }

        }

    } else {

        /* We are in a standard case

         * (from http://www.iana.org/assignments/rtp-parameters). */

        /* search into AVRtpPayloadTypes[] */

        codeef->codec_id = ff_rtp_codec_id(buf, codeef->codec_type);

    }



    c = avcodec_find_decoder(codeef->codec_id);

    if (c && c->name)

        c_name = c->name;

    else

        c_name = (char *) NULL;



    if (c_name) {

        get_word_sep(buf, sizeof(buf), ""/"", &p);

        i = atoi(buf);

        switch (codeef->codec_type) {

        case CODEC_TYPE_AUDIO:

            av_log(s, AV_LOG_DEBUG, ""audio codec set to: %s
"", c_name);

            codeef->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;

            codeef->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;

            if (i > 0) {

                codeef->sample_rate = i;

                get_word_sep(buf, sizeof(buf), ""/"", &p);

                i = atoi(buf);

                if (i > 0)

                    codeef->channels = i;

                // TODO: there is a bug here; if it is a mono stream, and

                // less than 22000Hz, faad upconverts to stereo and twice

                // the frequency.  No problem, but the sample rate is being

                // set here by the sdp line. Patch on its way. (rdm)

            }

            av_log(s, AV_LOG_DEBUG, ""audio samplerate set to: %i
"",

                   codeef->sample_rate);

            av_log(s, AV_LOG_DEBUG, ""audio channels set to: %i
"",

                   codeef->channels);

            break;

        case CODEC_TYPE_VIDEO:

            av_log(s, AV_LOG_DEBUG, ""video codec set to: %s
"", c_name);

            break;

        default:

            break;

        }

        return 0;

    }



    return -1;

}
",1,1,0,1,"s,codec,rtsp_st,payload_type,p,buf,i,c,c_name,handler","s:0.04953776299953461,codec:0.23280049860477448,rtsp_st:0.01685468852519989,payload_type:-0.0006436705589294434,p:0.07825371623039246,buf:0.07930032908916473,i:0.0393650084733963,c:0.08598122000694275,c_name:-0.038960620760917664,handler:0.1762852519750595,",1,13,"codec:codeef,",Greedy,179,0.03481345574061076
196,"void ff_mpv_frame_end(MpegEncContext *s)

{

#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    /* redraw edges for the frame if decoding didn't complete */

    // just to make sure that all data is rendered.

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {

        ff_xvmc_field_end(s);

    } else

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    emms_c();



    if (s->current_picture.reference)

        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);

}
",62,,0,1,,-4,"s,xvmc_acceleration,FF_ENABLE_DEPRECATION_WARNINGS",,,,,Greedy,1,0.0024455030759175616
197,"static int read_ffserver_streams(AVFormatContext *s, const char *filename)

{

    int i, err;

    AVFormatContext *ic;

    int nopts = 0;



    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);

    if (err < 0)

        return err;

    /* copy stream format */

    s->nb_streams = ic->nb_streams;

    for(i=0;i<ic->nb_streams;i++) {

        AVStream *st;

        AVCodec *codec;



        // FIXME: a more elegant solution is needed

        st = av_mallocz(sizeof(AVStream));

        memcpy(st, ic->streams[i], sizeof(AVStream));

        st->codec = avcodec_alloc_context();

        if (!st->codec) {

            print_error(filename, AVERROR(ENOMEM));

            ffmpeg_exit(1);

        }

        avcodec_copy_context(st->codec, ic->streams[i]->codec);

        s->streams[i] = st;



        codec = avcodec_find_encoder(st->codec->codec_id);

        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (audio_stream_copy) {

                st->stream_copy = 1;

            } else

                choose_sample_fmt(st, codec);

        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

            if (video_stream_copy) {

                st->stream_copy = 1;

            } else

                choose_pixel_fmt(st, codec);

        }



        if(!st->codec->thread_count)

            st->codec->thread_count = 1;

        if(st->codec->thread_count>1)

            avcodec_thread_init(st->codec, st->codec->thread_count);



        if(st->codec->flags & CODEC_FLAG_BITEXACT)

            nopts = 1;

    }



    if (!nopts)

        s->timestamp = av_gettime();



    av_close_input_file(ic);

    return 0;

}
",322,"static int read_ffserver_streams(AVFormatContext *ins, const char *fd)

{

    int info, code;

    AVFormatContext *ic;

    int nopts = 0;



    code = av_open_input_file(&ic, fd, NULL, FFM_PACKET_SIZE, NULL);

    if (code < 0)

        return code;

    /* copy stream format */

    ins->nb_streams = ic->nb_streams;

    for(info=0;info<ic->nb_streams;info++) {

        AVStream *sc;

        AVCodec *modec;



        // FIXME: a more elegant solution is needed

        sc = av_mallocz(sizeof(AVStream));

        memcpy(sc, ic->streams[info], sizeof(AVStream));

        sc->modec = avcodec_alloc_context();

        if (!sc->modec) {

            print_error(fd, AVERROR(ENOMEM));

            ffmpeg_exit(1);

        }

        avcodec_copy_context(sc->modec, ic->streams[info]->modec);

        ins->streams[info] = sc;



        modec = avcodec_find_encoder(sc->modec->codec_id);

        if (sc->modec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (audio_stream_copy) {

                sc->stream_copy = 1;

            } else

                choose_sample_fmt(sc, modec);

        } else if (sc->modec->codec_type == AVMEDIA_TYPE_VIDEO) {

            if (video_stream_copy) {

                sc->stream_copy = 1;

            } else

                choose_pixel_fmt(sc, modec);

        }



        if(!sc->modec->thread_count)

            sc->modec->thread_count = 1;

        if(sc->modec->thread_count>1)

            avcodec_thread_init(sc->modec, sc->modec->thread_count);



        if(sc->modec->flags & CODEC_FLAG_BITEXACT)

            nopts = 1;

    }



    if (!nopts)

        ins->timestamp = av_gettime();



    av_close_input_file(ic);

    return 0;

}
",1,1,0,1,"s,filename,i,err,ic,st,codec","s:0.017609357833862305,filename:0.04617434740066528,i:0.09490174055099487,err:0.05602151155471802,ic:0.014506340026855469,st:0.030364692211151123,codec:0.11867690086364746,",6,55,"codec:modec,i:info,err:code,filename:fd,st:sc,s:ins,",Greedy,497,0.09258336226145426
198,"static void uninit(AVFilterContext *ctx)

{

    ZScaleContext *s = ctx->priv;



    zimg_filter_graph_free(s->graph);


    av_freep(&s->tmp);

    s->tmp_size = 0;

}",39,"static void uninit(AVFilterContext *cv)

{

    ZScaleContext *rs = cv->priv;



    zimg_filter_graph_free(rs->graph);


    av_freep(&rs->tmp);

    rs->tmp_size = 0;

}",1,1,0,1,"ctx,s","ctx:0.22729307413101196,s:0.36034637689590454,",2,6,"s:rs,ctx:cv,",Greedy,93,0.01921012004216512
199,"static void decode_bo_addrmode_post_pre_base(CPUTriCoreState *env,

                                             DisasContext *ctx)

{

    uint32_t op2;

    uint32_t off10;

    int32_t r1, r2;

    TCGv temp;



    r1 = MASK_OP_BO_S1D(ctx->opcode);

    r2  = MASK_OP_BO_S2(ctx->opcode);

    off10 = MASK_OP_BO_OFF10_SEXT(ctx->opcode);

    op2 = MASK_OP_BO_OP2(ctx->opcode);



    switch (op2) {

    case OPC2_32_BO_CACHEA_WI_SHORTOFF:

    case OPC2_32_BO_CACHEA_W_SHORTOFF:

    case OPC2_32_BO_CACHEA_I_SHORTOFF:

        /* instruction to access the cache */

        break;

    case OPC2_32_BO_CACHEA_WI_POSTINC:

    case OPC2_32_BO_CACHEA_W_POSTINC:

    case OPC2_32_BO_CACHEA_I_POSTINC:

        /* instruction to access the cache, but we still need to handle

           the addressing mode */

        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);

        break;

    case OPC2_32_BO_CACHEA_WI_PREINC:

    case OPC2_32_BO_CACHEA_W_PREINC:

    case OPC2_32_BO_CACHEA_I_PREINC:

        /* instruction to access the cache, but we still need to handle

           the addressing mode */

        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);

        break;

    case OPC2_32_BO_CACHEI_WI_SHORTOFF:

    case OPC2_32_BO_CACHEI_W_SHORTOFF:

        /* TODO: Raise illegal opcode trap,

                 if tricore_feature(TRICORE_FEATURE_13) */

        break;

    case OPC2_32_BO_CACHEI_W_POSTINC:

    case OPC2_32_BO_CACHEI_WI_POSTINC:

        if (!tricore_feature(env, TRICORE_FEATURE_13)) {

            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);

        } /* TODO: else raise illegal opcode trap */

        break;

    case OPC2_32_BO_CACHEI_W_PREINC:

    case OPC2_32_BO_CACHEI_WI_PREINC:

        if (!tricore_feature(env, TRICORE_FEATURE_13)) {

            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);

        } /* TODO: else raise illegal opcode trap */

        break;

    case OPC2_32_BO_ST_A_SHORTOFF:

        gen_offset_st(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);

        break;

    case OPC2_32_BO_ST_A_POSTINC:

        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], cpu_gpr_a[r2], ctx->mem_idx,

                           MO_LESL);

        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);

        break;

    case OPC2_32_BO_ST_A_PREINC:

        gen_st_preincr(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);

        break;

    case OPC2_32_BO_ST_B_SHORTOFF:

        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);

        break;

    case OPC2_32_BO_ST_B_POSTINC:

        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,

                           MO_UB);

        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);

        break;

    case OPC2_32_BO_ST_B_PREINC:

        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);

        break;

    case OPC2_32_BO_ST_D_SHORTOFF:

        gen_offset_st_2regs(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2],

                            off10, ctx);

        break;

    case OPC2_32_BO_ST_D_POSTINC:

        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2], ctx);

        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);

        break;

    case OPC2_32_BO_ST_D_PREINC:

        temp = tcg_temp_new();

        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);

        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);

        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);

        tcg_temp_free(temp);

        break;

    case OPC2_32_BO_ST_DA_SHORTOFF:

        gen_offset_st_2regs(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2],

                            off10, ctx);

        break;

    case OPC2_32_BO_ST_DA_POSTINC:

        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2], ctx);

        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);

        break;

    case OPC2_32_BO_ST_DA_PREINC:

        temp = tcg_temp_new();

        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);

        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);

        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);

        tcg_temp_free(temp);

        break;

    case OPC2_32_BO_ST_H_SHORTOFF:

        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);

        break;

    case OPC2_32_BO_ST_H_POSTINC:

        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,

                           MO_LEUW);

        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);

        break;

    case OPC2_32_BO_ST_H_PREINC:

        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);

        break;

    case OPC2_32_BO_ST_Q_SHORTOFF:

        temp = tcg_temp_new();

        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);

        gen_offset_st(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);

        tcg_temp_free(temp);

        break;

    case OPC2_32_BO_ST_Q_POSTINC:

        temp = tcg_temp_new();

        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);

        tcg_gen_qemu_st_tl(temp, cpu_gpr_a[r2], ctx->mem_idx,

                           MO_LEUW);

        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);

        tcg_temp_free(temp);

        break;

    case OPC2_32_BO_ST_Q_PREINC:

        temp = tcg_temp_new();

        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);

        gen_st_preincr(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);

        tcg_temp_free(temp);

        break;

    case OPC2_32_BO_ST_W_SHORTOFF:

        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);

        break;

    case OPC2_32_BO_ST_W_POSTINC:

        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,

                           MO_LEUL);

        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);

        break;

    case OPC2_32_BO_ST_W_PREINC:

        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);

        break;

    }

}
",962,,0,1,,-4,"env,ctx,op2,off10,r1,r2,temp",,,,,Greedy,1,0.002600506941477458
200,"static int kvm_mips_get_fpu_registers(CPUState *cs)

{

    MIPSCPU *cpu = MIPS_CPU(cs);

    CPUMIPSState *env = &cpu->env;

    int err, ret = 0;

    unsigned int i;



    /* Only get FPU state if we're emulating a CPU with an FPU */

    if (env->CP0_Config1 & (1 << CP0C1_FP)) {

        /* FPU Control Registers */

        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR,

                                    &env->active_fpu.fcr0);

        if (err < 0) {

            DPRINTF(""%s: Failed to get FCR_IR (%d)\n"", __func__, err);

            ret = err;

        }

        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR,

                                    &env->active_fpu.fcr31);

        if (err < 0) {

            DPRINTF(""%s: Failed to get FCR_CSR (%d)\n"", __func__, err);

            ret = err;

        } else {

            restore_fp_status(env);

        }



        /* Floating point registers */

        for (i = 0; i < 32; ++i) {

            if (env->CP0_Status & (1 << CP0St_FR)) {

                err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i),

                                              &env->active_fpu.fpr[i].d);

            } else {

                err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i),

                                      &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]);

            }

            if (err < 0) {

                DPRINTF(""%s: Failed to get FPR%u (%d)\n"", __func__, i, err);

                ret = err;

            }

        }

    }



    return ret;

}
",247,"static int kvm_mips_get_fpu_registers(CPUState *bs)

{

    MIPSCPU *conn = MIPS_CPU(bs);

    CPUMIPSState *net = &conn->net;

    int rar, ret = 0;

    unsigned int in;



    /* Only get FPU state if we're emulating a CPU with an FPU */

    if (net->CP0_Config1 & (1 << CP0C1_FP)) {

        /* FPU Control Registers */

        rar = kvm_mips_get_one_ureg(bs, KVM_REG_MIPS_FCR_IR,

                                    &net->active_fpu.fcr0);

        if (rar < 0) {

            DPRINTF(""%s: Failed to get FCR_IR (%d)
"", __func__, rar);

            ret = rar;

        }

        rar = kvm_mips_get_one_ureg(bs, KVM_REG_MIPS_FCR_CSR,

                                    &net->active_fpu.fcr31);

        if (rar < 0) {

            DPRINTF(""%s: Failed to get FCR_CSR (%d)
"", __func__, rar);

            ret = rar;

        } else {

            restore_fp_status(net);

        }



        /* Floating point registers */

        for (in = 0; in < 32; ++in) {

            if (net->CP0_Status & (1 << CP0St_FR)) {

                rar = kvm_mips_get_one_ureg64(bs, KVM_REG_MIPS_FPR_64(in),

                                              &net->active_fpu.fpr[in].d);

            } else {

                rar = kvm_mips_get_one_ureg(bs, KVM_REG_MIPS_FPR_32(in),

                                      &net->active_fpu.fpr[in].w[FP_ENDIAN_IDX]);

            }

            if (rar < 0) {

                DPRINTF(""%s: Failed to get FPR%u (%d)
"", __func__, in, rar);

                ret = rar;

            }

        }

    }



    return ret;

}
",0,0,0,-1,"cs,cpu,env,err,i","cs:0.05775227025151253,cpu:0.033222392201423645,env:0.07230036705732346,err:0.13446489349007607,i:0.03447895869612694,",5,40,"err:rar,env:net,cs:bs,i:in,cpu:conn,",Greedy,373,0.06977018515268961
201,"static void gen_loongson_integer(DisasContext *ctx, uint32_t opc,

                                 int rd, int rs, int rt)

{

    const char *opn = ""loongson"";

    TCGv t0, t1;



    if (rd == 0) {

        /* Treat as NOP. */

        MIPS_DEBUG(""NOP"");

        return;

    }



    switch (opc) {

    case OPC_MULT_G_2E:

    case OPC_MULT_G_2F:

    case OPC_MULTU_G_2E:

    case OPC_MULTU_G_2F:

#if defined(TARGET_MIPS64)

    case OPC_DMULT_G_2E:

    case OPC_DMULT_G_2F:

    case OPC_DMULTU_G_2E:

    case OPC_DMULTU_G_2F:

#endif

        t0 = tcg_temp_new();

        t1 = tcg_temp_new();

        break;

    default:

        t0 = tcg_temp_local_new();

        t1 = tcg_temp_local_new();

        break;

    }



    gen_load_gpr(t0, rs);

    gen_load_gpr(t1, rt);



    switch (opc) {

    case OPC_MULT_G_2E:

    case OPC_MULT_G_2F:

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

        opn = ""mult.g"";

        break;

    case OPC_MULTU_G_2E:

    case OPC_MULTU_G_2F:

        tcg_gen_ext32u_tl(t0, t0);

        tcg_gen_ext32u_tl(t1, t1);

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

        opn = ""multu.g"";

        break;

    case OPC_DIV_G_2E:

    case OPC_DIV_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_ext32s_tl(t0, t0);

            tcg_gen_ext32s_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);

            tcg_gen_mov_tl(cpu_gpr[rd], t0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l3);

        }

        opn = ""div.g"";

        break;

    case OPC_DIVU_G_2E:

    case OPC_DIVU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_ext32u_tl(t0, t0);

            tcg_gen_ext32u_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l2);

        }

        opn = ""divu.g"";

        break;

    case OPC_MOD_G_2E:

    case OPC_MOD_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_ext32u_tl(t0, t0);

            tcg_gen_ext32u_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);

            gen_set_label(l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l3);

        }

        opn = ""mod.g"";

        break;

    case OPC_MODU_G_2E:

    case OPC_MODU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_ext32u_tl(t0, t0);

            tcg_gen_ext32u_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l2);

        }

        opn = ""modu.g"";

        break;

#if defined(TARGET_MIPS64)

    case OPC_DMULT_G_2E:

    case OPC_DMULT_G_2F:

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        opn = ""dmult.g"";

        break;

    case OPC_DMULTU_G_2E:

    case OPC_DMULTU_G_2F:

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        opn = ""dmultu.g"";

        break;

    case OPC_DDIV_G_2E:

    case OPC_DDIV_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);

            tcg_gen_mov_tl(cpu_gpr[rd], t0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l3);

        }

        opn = ""ddiv.g"";

        break;

    case OPC_DDIVU_G_2E:

    case OPC_DDIVU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l2);

        }

        opn = ""ddivu.g"";

        break;

    case OPC_DMOD_G_2E:

    case OPC_DMOD_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);

            gen_set_label(l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l3);

        }

        opn = ""dmod.g"";

        break;

    case OPC_DMODU_G_2E:

    case OPC_DMODU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l2);

        }

        opn = ""dmodu.g"";

        break;

#endif

    }



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rs]);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

}
",1212,,0,1,,-4,"ctx,opc,rd,rs,rt,opn,t0,t1",,,,,Greedy,1,0.0029316385587056476
202,"static void vfio_pci_load_rom(VFIOPCIDevice *vdev)

{

    struct vfio_region_info reg_info = {

        .argsz = sizeof(reg_info),

        .index = VFIO_PCI_ROM_REGION_INDEX

    };

    uint64_t size;

    off_t off = 0;

    size_t bytes;



    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {

        error_report(""vfio: Error getting ROM info: %m"");

        return;

    }



    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,

                            (unsigned long)reg_info.offset,

                            (unsigned long)reg_info.flags);



    vdev->rom_size = size = reg_info.size;

    vdev->rom_offset = reg_info.offset;



    if (!vdev->rom_size) {

        vdev->rom_read_failed = true;

        error_report(""vfio-pci: Cannot read device rom at ""

                    ""%s"", vdev->vbasedev.name);

        error_printf(""Device option ROM contents are probably invalid ""

                    ""(check dmesg).\nSkip option ROM probe with rombar=0, ""

                    ""or load from file with romfile=\n"");

        return;

    }



    vdev->rom = g_malloc(size);

    memset(vdev->rom, 0xff, size);



    while (size) {

        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,

                      size, vdev->rom_offset + off);

        if (bytes == 0) {

            break;

        } else if (bytes > 0) {

            off += bytes;

            size -= bytes;

        } else {

            if (errno == EINTR || errno == EAGAIN) {

                continue;

            }

            error_report(""vfio: Error reading device ROM: %m"");

            break;

        }

    }

}
",277,"static void vfio_pci_load_rom(VFIOPCIDevice *tvdevelopment)

{

    struct vfio_region_info reg_info = {

        .argsz = sizeof(reg_info),

        .index = VFIO_PCI_ROM_REGION_INDEX

    };

    uint64_t name;

    off_t off = 0;

    size_t lines;



    if (ioctl(tvdevelopment->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {

        error_report(""vfio: Error getting ROM info: %m"");

        return;

    }



    trace_vfio_pci_load_rom(tvdevelopment->vbasedev.name, (unsigned long)reg_info.name,

                            (unsigned long)reg_info.offset,

                            (unsigned long)reg_info.flags);



    tvdevelopment->rom_size = name = reg_info.name;

    tvdevelopment->rom_offset = reg_info.offset;



    if (!tvdevelopment->rom_size) {

        tvdevelopment->rom_read_failed = true;

        error_report(""vfio-pci: Cannot read device rom at ""

                    ""%s"", tvdevelopment->vbasedev.name);

        error_printf(""Device option ROM contents are probably invalid ""

                    ""(check dmesg).
Skip option ROM probe with rombar=0, ""

                    ""or load from file with romfile=
"");

        return;

    }



    tvdevelopment->rom = g_malloc(name);

    memset(tvdevelopment->rom, 0xff, name);



    while (name) {

        lines = pread(tvdevelopment->vbasedev.fd, tvdevelopment->rom + off,

                      name, tvdevelopment->rom_offset + off);

        if (lines == 0) {

            break;

        } else if (lines > 0) {

            off += lines;

            name -= lines;

        } else {

            if (errno == EINTR || errno == EAGAIN) {

                continue;

            }

            error_report(""vfio: Error reading device ROM: %m"");

            break;

        }

    }

}
",0,0,0,-1,"vdev,size,bytes","vdev:0.03955145180225372,size:-0.0017105713486671448,bytes:0.014940578490495682,",3,28,"vdev:tvdevelopment,bytes:lines,size:name,",Greedy,289,0.05415920813878377
203,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_max_ns);



        if (max_ns) {

            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    return false;

}
",73,,1,0,,-4,"ctx,blocking",,,,,Greedy,1,0.0021606167157491047
204,"static void pci_basic(gconstpointer data)

{

    QVirtioPCIDevice *dev;

    QPCIBus *bus;

    QVirtQueuePCI *tx, *rx;

    QGuestAllocator *alloc;

    void (*func) (const QVirtioBus *bus,

                  QVirtioDevice *dev,

                  QGuestAllocator *alloc,

                  QVirtQueue *rvq,

                  QVirtQueue *tvq,

                  int socket) = data;

    int sv[2], ret;



    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);

    g_assert_cmpint(ret, !=, -1);



    bus = pci_test_start(sv[1]);

    dev = virtio_net_pci_init(bus, PCI_SLOT);



    alloc = pc_alloc_init();

    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 0);

    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 1);



    driver_init(&qvirtio_pci, &dev->vdev);

    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);



    /* End test */

    close(sv[0]);

    guest_free(alloc, tx->vq.desc);

    pc_alloc_uninit(alloc);

    qvirtio_pci_device_disable(dev);

    g_free(dev);

    qpci_free_pc(bus);

    test_end();

}
",241,,1,0,,-4,"data,dev,bus,tx,rx,alloc,func,rvq,tvq,socket,sv,ret",,,,,Greedy,1,0.0021376848220825196
205,"static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
",60,"static void test_qemu_strtoul_full_negative(void)

{

    const char *fr = "" \t -321"";

    unsigned long res = 999;

    int order;



    order = qemu_strtoul(fr, NULL, 0, &res);

    g_assert_cmpint(order, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
",0,0,1,1,"str,err","str:-0.024448074400424957,err:0.186490960419178,",2,5,"err:order,str:fr,",Greedy,80,0.017407413323720297
206,"static int vnc_validate_certificate(struct VncState *vs)

{

    int ret;

    unsigned int status;

    const gnutls_datum_t *certs;

    unsigned int nCerts, i;

    time_t now;



    VNC_DEBUG(""Validating client certificate\n"");

    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {

	VNC_DEBUG(""Verify failed %s\n"", gnutls_strerror(ret));

	return -1;

    }



    if ((now = time(NULL)) == ((time_t)-1)) {

	return -1;

    }



    if (status != 0) {

	if (status & GNUTLS_CERT_INVALID)

	    VNC_DEBUG(""The certificate is not trusted.\n"");



	if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)

	    VNC_DEBUG(""The certificate hasn't got a known issuer.\n"");



	if (status & GNUTLS_CERT_REVOKED)

	    VNC_DEBUG(""The certificate has been revoked.\n"");



	if (status & GNUTLS_CERT_INSECURE_ALGORITHM)

	    VNC_DEBUG(""The certificate uses an insecure algorithm\n"");



	return -1;

    } else {

	VNC_DEBUG(""Certificate is valid!\n"");

    }



    /* Only support x509 for now */

    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)

	return -1;



    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))

	return -1;



    for (i = 0 ; i < nCerts ; i++) {

	gnutls_x509_crt_t cert;

	VNC_DEBUG (""Checking certificate chain %d\n"", i);

	if (gnutls_x509_crt_init (&cert) < 0)

	    return -1;



	if (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_expiration_time (cert) < now) {

	    VNC_DEBUG(""The certificate has expired\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (cert) > now) {

	    VNC_DEBUG(""The certificate is not yet activated\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (cert) > now) {

	    VNC_DEBUG(""The certificate is not yet activated\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	gnutls_x509_crt_deinit (cert);

    }



    return 0;

}
",347,,0,1,,-4,"vs,ret,status,certs,nCerts,i,now,cert",,,,,Greedy,1,0.0022682468096415203
207,"int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,

                        void *callback_opaque, uint8_t *data, size_t len)

{

    FWCfgState *s = opaque;

    int arch = !!(key & FW_CFG_ARCH_LOCAL);



    key &= FW_CFG_ENTRY_MASK;



    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)

        || len > 65535)

        return 0;



    s->entries[arch][key].data = data;

    s->entries[arch][key].len = len;

    s->entries[arch][key].callback_opaque = callback_opaque;

    s->entries[arch][key].callback = callback;



    return 1;

}
",126,,0,1,,-4,"opaque,key,callback,callback_opaque,data,len,s",,,,,Greedy,1,0.0022794047991434732
208,"static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],

                                   int order, int qlevel, int len, int bps)

{

    int i, j;

    int ebps = 1 << (bps-1);

    unsigned sigma = 0;



    for (i = order; i < len; i++)

        sigma |= decoded[i] + ebps;



    if (sigma < 2*ebps)

        return;



    for (i = len - 1; i >= order; i--) {

        int64_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (int64_t)decoded[i-order+j];

        decoded[i] -= p >> qlevel;

    }

    for (i = order; i < len; i++, decoded++) {

        int32_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (uint32_t)decoded[j];

        decoded[j] += p >> qlevel;

    }

}
",205,,1,0,,-4,"decoded,coeffs,order,qlevel,len,bps,i,j",,,,,Greedy,1,0.002217745780944824
209,"static int read_thread(void *arg)

{

    VideoState *is = arg;

    AVFormatContext *ic = NULL;

    int err, i, ret;

    int st_index[AVMEDIA_TYPE_NB];

    AVPacket pkt1, *pkt = &pkt1;

    int eof = 0;

    int pkt_in_play_range = 0;

    AVDictionaryEntry *t;

    AVDictionary **opts;

    int orig_nb_streams;

    SDL_mutex *wait_mutex = SDL_CreateMutex();



    memset(st_index, -1, sizeof(st_index));

    is->last_video_stream = is->video_stream = -1;

    is->last_audio_stream = is->audio_stream = -1;

    is->last_subtitle_stream = is->subtitle_stream = -1;



    ic = avformat_alloc_context();

    ic->interrupt_callback.callback = decode_interrupt_cb;

    ic->interrupt_callback.opaque = is;

    err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);

    if (err < 0) {

        print_error(is->filename, err);

        ret = -1;

        goto fail;

    }

    if ((t = av_dict_get(format_opts, """", NULL, AV_DICT_IGNORE_SUFFIX))) {

        av_log(NULL, AV_LOG_ERROR, ""Option %s not found.\n"", t->key);

        ret = AVERROR_OPTION_NOT_FOUND;

        goto fail;

    }

    is->ic = ic;



    if (genpts)

        ic->flags |= AVFMT_FLAG_GENPTS;



    opts = setup_find_stream_info_opts(ic, codec_opts);

    orig_nb_streams = ic->nb_streams;



    err = avformat_find_stream_info(ic, opts);

    if (err < 0) {

        fprintf(stderr, ""%s: could not find codec parameters\n"", is->filename);

        ret = -1;

        goto fail;

    }

    for (i = 0; i < orig_nb_streams; i++)

        av_dict_free(&opts[i]);

    av_freep(&opts);



    if (ic->pb)

        ic->pb->eof_reached = 0; // FIXME hack, ffplay maybe should not use url_feof() to test for the end



    if (seek_by_bytes < 0)

        seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT);



    is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;



    /* if seeking requested, we execute it */

    if (start_time != AV_NOPTS_VALUE) {

        int64_t timestamp;



        timestamp = start_time;

        /* add the stream start time */

        if (ic->start_time != AV_NOPTS_VALUE)

            timestamp += ic->start_time;

        ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0);

        if (ret < 0) {

            fprintf(stderr, ""%s: could not seek to position %0.3f\n"",

                    is->filename, (double)timestamp / AV_TIME_BASE);

        }

    }



    is->realtime = is_realtime(ic);



    for (i = 0; i < ic->nb_streams; i++)

        ic->streams[i]->discard = AVDISCARD_ALL;

    if (!video_disable)

        st_index[AVMEDIA_TYPE_VIDEO] =

            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,

                                wanted_stream[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);

    if (!audio_disable)

        st_index[AVMEDIA_TYPE_AUDIO] =

            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,

                                wanted_stream[AVMEDIA_TYPE_AUDIO],

                                st_index[AVMEDIA_TYPE_VIDEO],

                                NULL, 0);

    if (!video_disable)

        st_index[AVMEDIA_TYPE_SUBTITLE] =

            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,

                                wanted_stream[AVMEDIA_TYPE_SUBTITLE],

                                (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?

                                 st_index[AVMEDIA_TYPE_AUDIO] :

                                 st_index[AVMEDIA_TYPE_VIDEO]),

                                NULL, 0);

    if (show_status) {

        av_dump_format(ic, 0, is->filename, 0);

    }



    is->show_mode = show_mode;



    /* open the streams */

    if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {

        stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);

    }



    ret = -1;

    if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {

        ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);

    }

    if (is->show_mode == SHOW_MODE_NONE)

        is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;



    is->refresh_tid = SDL_CreateThread(refresh_thread, is);



    if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {

        stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);

    }



    if (is->video_stream < 0 && is->audio_stream < 0) {

        fprintf(stderr, ""%s: could not open codecs\n"", is->filename);

        ret = -1;

        goto fail;

    }



    if (infinite_buffer < 0 && is->realtime)

        infinite_buffer = 1;



    for (;;) {

        if (is->abort_request)

            break;

        if (is->paused != is->last_paused) {

            is->last_paused = is->paused;

            if (is->paused)

                is->read_pause_return = av_read_pause(ic);

            else

                av_read_play(ic);

        }

#if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL

        if (is->paused &&

                (!strcmp(ic->iformat->name, ""rtsp"") ||

                 (ic->pb && !strncmp(input_filename, ""mmsh:"", 5)))) {

            /* wait 10 ms to avoid trying to get another packet */

            /* XXX: horrible */

            SDL_Delay(10);

            continue;

        }

#endif

        if (is->seek_req) {

            int64_t seek_target = is->seek_pos;

            int64_t seek_min    = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN;

            int64_t seek_max    = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX;

// FIXME the +-2 is due to rounding being not done in the correct direction in generation

//      of the seek_pos/seek_rel variables



            ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);

            if (ret < 0) {

                fprintf(stderr, ""%s: error while seeking\n"", is->ic->filename);

            } else {

                if (is->audio_stream >= 0) {

                    packet_queue_flush(&is->audioq);

                    packet_queue_put(&is->audioq, &flush_pkt);

                }

                if (is->subtitle_stream >= 0) {

                    packet_queue_flush(&is->subtitleq);

                    packet_queue_put(&is->subtitleq, &flush_pkt);

                }

                if (is->video_stream >= 0) {

                    packet_queue_flush(&is->videoq);

                    packet_queue_put(&is->videoq, &flush_pkt);

                }

                if (is->seek_flags & AVSEEK_FLAG_BYTE) {

                   //FIXME: use a cleaner way to signal obsolete external clock...

                   update_external_clock_pts(is, (double)AV_NOPTS_VALUE);

                } else {

                   update_external_clock_pts(is, seek_target / (double)AV_TIME_BASE);

                }

            }

            is->seek_req = 0;

            eof = 0;

            if (is->paused)

                step_to_next_frame(is);

        }

        if (is->queue_attachments_req) {

            avformat_queue_attached_pictures(ic);

            is->queue_attachments_req = 0;

        }



        /* if the queue are full, no need to read more */

        if (infinite_buffer<1 &&

              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE

            || (   (is->audioq   .nb_packets > MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request)

                && (is->videoq   .nb_packets > MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request)

                && (is->subtitleq.nb_packets > MIN_FRAMES || is->subtitle_stream < 0 || is->subtitleq.abort_request)))) {

            /* wait 10 ms */

            SDL_LockMutex(wait_mutex);

            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);

            SDL_UnlockMutex(wait_mutex);

            continue;

        }

        if (eof) {

            if (is->video_stream >= 0) {

                av_init_packet(pkt);

                pkt->data = NULL;

                pkt->size = 0;

                pkt->stream_index = is->video_stream;

                packet_queue_put(&is->videoq, pkt);

            }

            if (is->audio_stream >= 0 &&

                is->audio_st->codec->codec->capabilities & CODEC_CAP_DELAY) {

                av_init_packet(pkt);

                pkt->data = NULL;

                pkt->size = 0;

                pkt->stream_index = is->audio_stream;

                packet_queue_put(&is->audioq, pkt);

            }

            SDL_Delay(10);

            if (is->audioq.size + is->videoq.size + is->subtitleq.size == 0) {

                if (loop != 1 && (!loop || --loop)) {

                    stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);

                } else if (autoexit) {

                    ret = AVERROR_EOF;

                    goto fail;

                }

            }

            eof=0;

            continue;

        }

        ret = av_read_frame(ic, pkt);

        if (ret < 0) {

            if (ret == AVERROR_EOF || url_feof(ic->pb))

                eof = 1;

            if (ic->pb && ic->pb->error)

                break;

            SDL_LockMutex(wait_mutex);

            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);

            SDL_UnlockMutex(wait_mutex);

            continue;

        }

        /* check if packet is in play range specified by user, then queue, otherwise discard */

        pkt_in_play_range = duration == AV_NOPTS_VALUE ||

                (pkt->pts - ic->streams[pkt->stream_index]->start_time) *

                av_q2d(ic->streams[pkt->stream_index]->time_base) -

                (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000

                <= ((double)duration / 1000000);

        if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {

            packet_queue_put(&is->audioq, pkt);

        } else if (pkt->stream_index == is->video_stream && pkt_in_play_range) {

            packet_queue_put(&is->videoq, pkt);

        } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {

            packet_queue_put(&is->subtitleq, pkt);

        } else {

            av_free_packet(pkt);

        }

    }

    /* wait until the end */

    while (!is->abort_request) {

        SDL_Delay(100);

    }



    ret = 0;

 fail:

    /* close each stream */

    if (is->audio_stream >= 0)

        stream_component_close(is, is->audio_stream);

    if (is->video_stream >= 0)

        stream_component_close(is, is->video_stream);

    if (is->subtitle_stream >= 0)

        stream_component_close(is, is->subtitle_stream);

    if (is->ic) {

        avformat_close_input(&is->ic);

    }



    if (ret != 0) {

        SDL_Event event;



        event.type = FF_QUIT_EVENT;

        event.user.data1 = is;

        SDL_PushEvent(&event);

    }

    SDL_DestroyMutex(wait_mutex);

    return 0;

}
",1776,"static int read_thread(void *arg)

{

    VideoState *isi = arg;

    AVFormatContext *ic = NULL;

    int err, i, ret;

    int st_index[AVMEDIA_TYPE_NB];

    AVPacket pkt1, *pkt = &pkt1;

    int eof = 0;

    int pkt_in_play_range = 0;

    AVDictionaryEntry *t;

    AVDictionary **opts;

    int orig_nb_streams;

    SDL_mutex *wait_mutex = SDL_CreateMutex();



    memset(st_index, -1, sizeof(st_index));

    isi->last_video_stream = isi->video_stream = -1;

    isi->last_audio_stream = isi->audio_stream = -1;

    isi->last_subtitle_stream = isi->subtitle_stream = -1;



    ic = avformat_alloc_context();

    ic->interrupt_callback.callback = decode_interrupt_cb;

    ic->interrupt_callback.opaque = isi;

    err = avformat_open_input(&ic, isi->filename, isi->iformat, &format_opts);

    if (err < 0) {

        print_error(isi->filename, err);

        ret = -1;

        goto fail;

    }

    if ((t = av_dict_get(format_opts, """", NULL, AV_DICT_IGNORE_SUFFIX))) {

        av_log(NULL, AV_LOG_ERROR, ""Option %s not found.
"", t->key);

        ret = AVERROR_OPTION_NOT_FOUND;

        goto fail;

    }

    isi->ic = ic;



    if (genpts)

        ic->flags |= AVFMT_FLAG_GENPTS;



    opts = setup_find_stream_info_opts(ic, codec_opts);

    orig_nb_streams = ic->nb_streams;



    err = avformat_find_stream_info(ic, opts);

    if (err < 0) {

        fprintf(stderr, ""%s: could not find codec parameters
"", isi->filename);

        ret = -1;

        goto fail;

    }

    for (i = 0; i < orig_nb_streams; i++)

        av_dict_free(&opts[i]);

    av_freep(&opts);



    if (ic->pb)

        ic->pb->eof_reached = 0; // FIXME hack, ffplay maybe should not use url_feof() to test for the end



    if (seek_by_bytes < 0)

        seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT);



    isi->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;



    /* if seeking requested, we execute it */

    if (start_time != AV_NOPTS_VALUE) {

        int64_t timestamp;



        timestamp = start_time;

        /* add the stream start time */

        if (ic->start_time != AV_NOPTS_VALUE)

            timestamp += ic->start_time;

        ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0);

        if (ret < 0) {

            fprintf(stderr, ""%s: could not seek to position %0.3f
"",

                    isi->filename, (double)timestamp / AV_TIME_BASE);

        }

    }



    isi->realtime = is_realtime(ic);



    for (i = 0; i < ic->nb_streams; i++)

        ic->streams[i]->discard = AVDISCARD_ALL;

    if (!video_disable)

        st_index[AVMEDIA_TYPE_VIDEO] =

            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,

                                wanted_stream[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);

    if (!audio_disable)

        st_index[AVMEDIA_TYPE_AUDIO] =

            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,

                                wanted_stream[AVMEDIA_TYPE_AUDIO],

                                st_index[AVMEDIA_TYPE_VIDEO],

                                NULL, 0);

    if (!video_disable)

        st_index[AVMEDIA_TYPE_SUBTITLE] =

            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,

                                wanted_stream[AVMEDIA_TYPE_SUBTITLE],

                                (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?

                                 st_index[AVMEDIA_TYPE_AUDIO] :

                                 st_index[AVMEDIA_TYPE_VIDEO]),

                                NULL, 0);

    if (show_status) {

        av_dump_format(ic, 0, isi->filename, 0);

    }



    isi->show_mode = show_mode;



    /* open the streams */

    if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {

        stream_component_open(isi, st_index[AVMEDIA_TYPE_AUDIO]);

    }



    ret = -1;

    if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {

        ret = stream_component_open(isi, st_index[AVMEDIA_TYPE_VIDEO]);

    }

    if (isi->show_mode == SHOW_MODE_NONE)

        isi->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;



    isi->refresh_tid = SDL_CreateThread(refresh_thread, isi);



    if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {

        stream_component_open(isi, st_index[AVMEDIA_TYPE_SUBTITLE]);

    }



    if (isi->video_stream < 0 && isi->audio_stream < 0) {

        fprintf(stderr, ""%s: could not open codecs
"", isi->filename);

        ret = -1;

        goto fail;

    }



    if (infinite_buffer < 0 && isi->realtime)

        infinite_buffer = 1;



    for (;;) {

        if (isi->abort_request)

            break;

        if (isi->paused != isi->last_paused) {

            isi->last_paused = isi->paused;

            if (isi->paused)

                isi->read_pause_return = av_read_pause(ic);

            else

                av_read_play(ic);

        }

#if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL

        if (isi->paused &&

                (!strcmp(ic->iformat->name, ""rtsp"") ||

                 (ic->pb && !strncmp(input_filename, ""mmsh:"", 5)))) {

            /* wait 10 ms to avoid trying to get another packet */

            /* XXX: horrible */

            SDL_Delay(10);

            continue;

        }

#endif

        if (isi->seek_req) {

            int64_t seek_target = isi->seek_pos;

            int64_t seek_min    = isi->seek_rel > 0 ? seek_target - isi->seek_rel + 2: INT64_MIN;

            int64_t seek_max    = isi->seek_rel < 0 ? seek_target - isi->seek_rel - 2: INT64_MAX;

// FIXME the +-2 is due to rounding being not done in the correct direction in generation

//      of the seek_pos/seek_rel variables



            ret = avformat_seek_file(isi->ic, -1, seek_min, seek_target, seek_max, isi->seek_flags);

            if (ret < 0) {

                fprintf(stderr, ""%s: error while seeking
"", isi->ic->filename);

            } else {

                if (isi->audio_stream >= 0) {

                    packet_queue_flush(&isi->audioq);

                    packet_queue_put(&isi->audioq, &flush_pkt);

                }

                if (isi->subtitle_stream >= 0) {

                    packet_queue_flush(&isi->subtitleq);

                    packet_queue_put(&isi->subtitleq, &flush_pkt);

                }

                if (isi->video_stream >= 0) {

                    packet_queue_flush(&isi->videoq);

                    packet_queue_put(&isi->videoq, &flush_pkt);

                }

                if (isi->seek_flags & AVSEEK_FLAG_BYTE) {

                   //FIXME: use a cleaner way to signal obsolete external clock...

                   update_external_clock_pts(isi, (double)AV_NOPTS_VALUE);

                } else {

                   update_external_clock_pts(isi, seek_target / (double)AV_TIME_BASE);

                }

            }

            isi->seek_req = 0;

            eof = 0;

            if (isi->paused)

                step_to_next_frame(isi);

        }

        if (isi->queue_attachments_req) {

            avformat_queue_attached_pictures(ic);

            isi->queue_attachments_req = 0;

        }



        /* if the queue are full, no need to read more */

        if (infinite_buffer<1 &&

              (isi->audioq.size + isi->videoq.size + isi->subtitleq.size > MAX_QUEUE_SIZE

            || (   (isi->audioq   .nb_packets > MIN_FRAMES || isi->audio_stream < 0 || isi->audioq.abort_request)

                && (isi->videoq   .nb_packets > MIN_FRAMES || isi->video_stream < 0 || isi->videoq.abort_request)

                && (isi->subtitleq.nb_packets > MIN_FRAMES || isi->subtitle_stream < 0 || isi->subtitleq.abort_request)))) {

            /* wait 10 ms */

            SDL_LockMutex(wait_mutex);

            SDL_CondWaitTimeout(isi->continue_read_thread, wait_mutex, 10);

            SDL_UnlockMutex(wait_mutex);

            continue;

        }

        if (eof) {

            if (isi->video_stream >= 0) {

                av_init_packet(pkt);

                pkt->data = NULL;

                pkt->size = 0;

                pkt->stream_index = isi->video_stream;

                packet_queue_put(&isi->videoq, pkt);

            }

            if (isi->audio_stream >= 0 &&

                isi->audio_st->codec->codec->capabilities & CODEC_CAP_DELAY) {

                av_init_packet(pkt);

                pkt->data = NULL;

                pkt->size = 0;

                pkt->stream_index = isi->audio_stream;

                packet_queue_put(&isi->audioq, pkt);

            }

            SDL_Delay(10);

            if (isi->audioq.size + isi->videoq.size + isi->subtitleq.size == 0) {

                if (loop != 1 && (!loop || --loop)) {

                    stream_seek(isi, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);

                } else if (autoexit) {

                    ret = AVERROR_EOF;

                    goto fail;

                }

            }

            eof=0;

            continue;

        }

        ret = av_read_frame(ic, pkt);

        if (ret < 0) {

            if (ret == AVERROR_EOF || url_feof(ic->pb))

                eof = 1;

            if (ic->pb && ic->pb->error)

                break;

            SDL_LockMutex(wait_mutex);

            SDL_CondWaitTimeout(isi->continue_read_thread, wait_mutex, 10);

            SDL_UnlockMutex(wait_mutex);

            continue;

        }

        /* check if packet is in play range specified by user, then queue, otherwise discard */

        pkt_in_play_range = duration == AV_NOPTS_VALUE ||

                (pkt->pts - ic->streams[pkt->stream_index]->start_time) *

                av_q2d(ic->streams[pkt->stream_index]->time_base) -

                (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000

                <= ((double)duration / 1000000);

        if (pkt->stream_index == isi->audio_stream && pkt_in_play_range) {

            packet_queue_put(&isi->audioq, pkt);

        } else if (pkt->stream_index == isi->video_stream && pkt_in_play_range) {

            packet_queue_put(&isi->videoq, pkt);

        } else if (pkt->stream_index == isi->subtitle_stream && pkt_in_play_range) {

            packet_queue_put(&isi->subtitleq, pkt);

        } else {

            av_free_packet(pkt);

        }

    }

    /* wait until the end */

    while (!isi->abort_request) {

        SDL_Delay(100);

    }



    ret = 0;

 fail:

    /* close each stream */

    if (isi->audio_stream >= 0)

        stream_component_close(isi, isi->audio_stream);

    if (isi->video_stream >= 0)

        stream_component_close(isi, isi->video_stream);

    if (isi->subtitle_stream >= 0)

        stream_component_close(isi, isi->subtitle_stream);

    if (isi->ic) {

        avformat_close_input(&isi->ic);

    }



    if (ret != 0) {

        SDL_Event event;



        event.type = FF_QUIT_EVENT;

        event.user.data1 = isi;

        SDL_PushEvent(&event);

    }

    SDL_DestroyMutex(wait_mutex);

    return 0;

}
",0,0,1,1,"arg,is,ic,err,i,ret,st_index,pkt1,pkt,t,opts,orig_nb_streams,wait_mutex","arg:0.059274822473526,is:0.18828782439231873,ic:0.1408090591430664,err:0.08892560005187988,i:0.03973647952079773,ret:0.009735077619552612,st_index:0.04074147343635559,pkt1:-0.0030830800533294678,pkt:-0.022526800632476807,t:0.07134115695953369,opts:-0.003907978534698486,orig_nb_streams:0.035091519355773926,wait_mutex:-0.004764378070831299,",1,107,"is:isi,",Greedy,318,0.09488892555236816
210,"int ff_xvmc_field_start(MpegEncContext *s, AVCodecContext *avctx)

{

    struct xvmc_pix_fmt *last, *next, *render = (struct xvmc_pix_fmt*)s->current_picture.data[2];

    const int mb_block_count = 4 + (1 << s->chroma_format);



    assert(avctx);

    if (!render || render->xvmc_id != AV_XVMC_ID ||

        !render->data_blocks || !render->mv_blocks) {

        av_log(avctx, AV_LOG_ERROR,

               ""Render token doesn't look as expected.\n"");

        return -1; // make sure that this is a render packet

    }



    if (render->filled_mv_blocks_num) {

        av_log(avctx, AV_LOG_ERROR,

               ""Rendering surface contains %i unprocessed blocks.\n"",

               render->filled_mv_blocks_num);

        return -1;

    }

    if (render->allocated_mv_blocks   < 1 ||

        render->allocated_data_blocks <  render->allocated_mv_blocks*mb_block_count ||

        render->start_mv_blocks_num   >= render->allocated_mv_blocks                ||

        render->next_free_data_block_num >

                        render->allocated_data_blocks -

                        mb_block_count*(render->allocated_mv_blocks-render->start_mv_blocks_num)) {

        av_log(avctx, AV_LOG_ERROR,

               ""Rendering surface doesn't provide enough block structures to work with.\n"");

        return -1;

    }



    render->picture_structure = s->picture_structure;

    render->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD;

    render->p_future_surface  = NULL;

    render->p_past_surface    = NULL;



    switch(s->pict_type) {

        case  FF_I_TYPE:

            return 0; // no prediction from other frames

        case  FF_B_TYPE:

            next = (struct xvmc_pix_fmt*)s->next_picture.data[2];

            if (!next)

                return -1;

            if (next->xvmc_id != AV_XVMC_ID)

                return -1;

            render->p_future_surface = next->p_surface;

            // no return here, going to set forward prediction

        case  FF_P_TYPE:

            last = (struct xvmc_pix_fmt*)s->last_picture.data[2];

            if (!last)

                last = render; // predict second field from the first

            if (last->xvmc_id != AV_XVMC_ID)

                return -1;

            render->p_past_surface = last->p_surface;

            return 0;

    }



return -1;

}
",324,"int ff_xvmc_field_start(MpegEncContext *s, AVCodecContext *avctx)

{

    struct xvmc_pix_fmt *last, *next, *aster = (struct xvmc_pix_fmt*)s->current_picture.data[2];

    const int mb_block_count = 4 + (1 << s->chroma_format);



    assert(avctx);

    if (!aster || aster->xvmc_id != AV_XVMC_ID ||

        !aster->data_blocks || !aster->mv_blocks) {

        av_log(avctx, AV_LOG_ERROR,

               ""Render token doesn't look as expected.
"");

        return -1; // make sure that this is a render packet

    }



    if (aster->filled_mv_blocks_num) {

        av_log(avctx, AV_LOG_ERROR,

               ""Rendering surface contains %i unprocessed blocks.
"",

               aster->filled_mv_blocks_num);

        return -1;

    }

    if (aster->allocated_mv_blocks   < 1 ||

        aster->allocated_data_blocks <  aster->allocated_mv_blocks*mb_block_count ||

        aster->start_mv_blocks_num   >= aster->allocated_mv_blocks                ||

        aster->next_free_data_block_num >

                        aster->allocated_data_blocks -

                        mb_block_count*(aster->allocated_mv_blocks-aster->start_mv_blocks_num)) {

        av_log(avctx, AV_LOG_ERROR,

               ""Rendering surface doesn't provide enough block structures to work with.
"");

        return -1;

    }



    aster->picture_structure = s->picture_structure;

    aster->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD;

    aster->p_future_surface  = NULL;

    aster->p_past_surface    = NULL;



    switch(s->pict_type) {

        case  FF_I_TYPE:

            return 0; // no prediction from other frames

        case  FF_B_TYPE:

            next = (struct xvmc_pix_fmt*)s->next_picture.data[2];

            if (!next)

                return -1;

            if (next->xvmc_id != AV_XVMC_ID)

                return -1;

            aster->p_future_surface = next->p_surface;

            // no return here, going to set forward prediction

        case  FF_P_TYPE:

            last = (struct xvmc_pix_fmt*)s->last_picture.data[2];

            if (!last)

                last = aster; // predict second field from the first

            if (last->xvmc_id != AV_XVMC_ID)

                return -1;

            aster->p_past_surface = last->p_surface;

            return 0;

    }



return -1;

}
",0,0,1,1,"s,avctx,last,next,render","s:0.2546948492527008,avctx:0.06580579280853271,last:0.03596588969230652,next:0.1478525698184967,render:0.5441179871559143,",1,23,"render:aster,",Greedy,121,0.025142467021942137
211,"static int calculate_bitrate(AVFormatContext *s)

{

    AVIContext *avi = s->priv_data;

    int i, j;

    int64_t lensum = 0;

    int64_t maxpos = 0;



    for (i = 0; i<s->nb_streams; i++) {

        int64_t len = 0;

        AVStream *st = s->streams[i];



        if (!st->nb_index_entries)

            continue;



        for (j = 0; j < st->nb_index_entries; j++)

            len += st->index_entries[j].size;

        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);

        lensum += len;

    }

    if (maxpos < avi->io_fsize*9/10) // index does not cover the whole file

        return 0;

    if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch

        return 0;



    for (i = 0; i<s->nb_streams; i++) {

        int64_t len = 0;

        AVStream *st = s->streams[i];

        int64_t duration;



        for (j = 0; j < st->nb_index_entries; j++)

            len += st->index_entries[j].size;



        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)

            continue;

        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;

        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);

    }

    return 1;

}
",291,,1,0,,-4,"s,avi,i,j,st,duration",,,,,Greedy,1,0.0024594902992248536
212,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
",30,"static inline void gen_st16(TCGv reg, TCGv addr, int point)

{

    tcg_gen_qemu_st16(reg, addr, point);

    dead_tmp(reg);

}
",1,1,0,1,"val,addr,index","val:0.000652313232421875,addr:-0.0006886124610900879,index:0.0014026761054992676,",2,5,"index:point,val:reg,",Greedy,88,0.01810010274251302
213,"static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}
",72,"static void q35_host_class_init(ObjectClass * klasses, void *data)

{

    DeviceClass *oc = DEVICE_CLASS( klasses);

    PCIHostBridgeClass *htlc = PCI_HOST_BRIDGE_CLASS( klasses);



    htlc->root_bus_path = q35_host_root_bus_path;

    oc->realize = q35_host_realize;

    oc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    oc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, oc->categories);

    oc->fw_name = ""pci"";

}
",1,1,0,1,"klass,data,dc,hc","klass:0.032955288887023926,data:-0.0019491910934448242,dc:0.39117538928985596,hc:0.2639475464820862,",3,11,"dc:oc,hc:htlc,klass: klasses,",Greedy,114,0.02339812517166138
214,"static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,

                                                 Error **errp)

{

    struct addrinfo ai, *res;

    int rc;

    Error *err = NULL;



    memset(&ai, 0, sizeof(ai));



    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;

    ai.ai_family = inet_ai_family_from_address(saddr, &err);

    ai.ai_socktype = SOCK_STREAM;



    if (err) {

        error_propagate(errp, err);

        return NULL;

    }



    if (saddr->host == NULL || saddr->port == NULL) {

        error_setg(errp, ""host and/or port not specified"");

        return NULL;

    }



    /* lookup */

    rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);

    if (rc != 0) {

        error_setg(errp, ""address resolution failed for %s:%s: %s"",

                   saddr->host, saddr->port, gai_strerror(rc));

        return NULL;

    }

    return res;

}
",171,,1,0,,-4,"saddr,errp,ai,res,rc,err",,,,,Greedy,1,0.0023642738660176596
215,"static void bamboo_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *isa = g_new(MemoryRegion, 1);

    MemoryRegion *ram_memories

        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));

    hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS];

    hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS];

    qemu_irq *pic;

    qemu_irq *irqs;

    PCIBus *pcibus;

    PowerPCCPU *cpu;

    CPUPPCState *env;

    uint64_t elf_entry;

    uint64_t elf_lowaddr;

    hwaddr loadaddr = 0;

    target_long initrd_size = 0;

    DeviceState *dev;

    int success;

    int i;



    /* Setup CPU. */

    if (machine->cpu_model == NULL) {

        machine->cpu_model = ""440EP"";

    }

    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }

    env = &cpu->env;



    if (env->mmu_model != POWERPC_MMU_BOOKE) {

        fprintf(stderr, ""MMU model %i not supported by this machine.\n"",

            env->mmu_model);

        exit(1);

    }



    qemu_register_reset(main_cpu_reset, cpu);

    ppc_booke_timers_init(cpu, 400000000, 0);

    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);



    /* SDRAM controller */

    memset(ram_bases, 0, sizeof(ram_bases));

    memset(ram_sizes, 0, sizeof(ram_sizes));

    ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS,

                                   ram_memories,

                                   ram_bases, ram_sizes,

                                   ppc440ep_sdram_bank_sizes);

    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */

    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,

                      ram_bases, ram_sizes, 1);



    /* PCI */

    dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE,

                                PPC440EP_PCI_CONFIG,

                                pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]],

                                pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]],

                                NULL);

    pcibus = (PCIBus *)qdev_get_child_bus(dev, ""pci.0"");

    if (!pcibus) {

        fprintf(stderr, ""couldn't create PCI controller!\n"");

        exit(1);

    }



    memory_region_init_alias(isa, NULL, ""isa_mmio"",

                             get_system_io(), 0, PPC440EP_PCI_IOLEN);

    memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa);



    if (serial_hds[0] != NULL) {

        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],

                       DEVICE_BIG_ENDIAN);

    }

    if (serial_hds[1] != NULL) {

        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],

                       DEVICE_BIG_ENDIAN);

    }



    if (pcibus) {

        /* Register network interfaces. */

        for (i = 0; i < nb_nics; i++) {

            /* There are no PCI NICs on the Bamboo board, but there are

             * PCI slots, so we can pick whatever default model we want. */

            pci_nic_init_nofail(&nd_table[i], pcibus, ""e1000"", NULL);

        }

    }



    /* Load kernel. */

    if (kernel_filename) {

        success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,

                              NULL, NULL);

        if (success < 0) {

            success = load_elf(kernel_filename, NULL, NULL, &elf_entry,

                               &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE,

                               0, 0);

            entry = elf_entry;

            loadaddr = elf_lowaddr;

        }

        /* XXX try again as binary */

        if (success < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",

                    kernel_filename);

            exit(1);

        }

    }



    /* Load initrd. */

    if (initrd_filename) {

        initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,

                                          ram_size - RAMDISK_ADDR);



        if (initrd_size < 0) {

            fprintf(stderr, ""qemu: could not load ram disk '%s' at %x\n"",

                    initrd_filename, RAMDISK_ADDR);

            exit(1);

        }

    }



    /* If we're loading a kernel directly, we must load the device tree too. */

    if (kernel_filename) {

        if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,

                                    initrd_size, kernel_cmdline) < 0) {

            fprintf(stderr, ""couldn't load device tree\n"");

            exit(1);

        }

    }

}
",772,"static void bamboo_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *pai = g_new(MemoryRegion, 1);

    MemoryRegion *ram_memories

        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));

    hwaddr ram_luses[PPC440EP_SDRAM_NR_BANKS];

    hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS];

    qemu_irq *pic;

    qemu_irq *iraqs;

    PCIBus *incubis;

    PowerPCCPU *cpu;

    CPUPPCState *env;

    uint64_t elope_cmp;

    uint64_t elf_lowaddr;

    hwaddr loadaddr = 0;

    target_long initrd_size = 0;

    DeviceState *dev;

    int success;

    int i;



    /* Setup CPU. */

    if (machine->cpu_model == NULL) {

        machine->cpu_model = ""440EP"";

    }

    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!
"");

        exit(1);

    }

    env = &cpu->env;



    if (env->mmu_model != POWERPC_MMU_BOOKE) {

        fprintf(stderr, ""MMU model %i not supported by this machine.
"",

            env->mmu_model);

        exit(1);

    }



    qemu_register_reset(main_cpu_reset, cpu);

    ppc_booke_timers_init(cpu, 400000000, 0);

    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    iraqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    iraqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    iraqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    pic = ppcuic_init(env, iraqs, 0x0C0, 0, 1);



    /* SDRAM controller */

    memset(ram_luses, 0, sizeof(ram_luses));

    memset(ram_sizes, 0, sizeof(ram_sizes));

    ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS,

                                   ram_memories,

                                   ram_luses, ram_sizes,

                                   ppc440ep_sdram_bank_sizes);

    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */

    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,

                      ram_luses, ram_sizes, 1);



    /* PCI */

    dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE,

                                PPC440EP_PCI_CONFIG,

                                pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]],

                                pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]],

                                NULL);

    incubis = (PCIBus *)qdev_get_child_bus(dev, ""pci.0"");

    if (!incubis) {

        fprintf(stderr, ""couldn't create PCI controller!
"");

        exit(1);

    }



    memory_region_init_alias(pai, NULL, ""isa_mmio"",

                             get_system_io(), 0, PPC440EP_PCI_IOLEN);

    memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, pai);



    if (serial_hds[0] != NULL) {

        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],

                       DEVICE_BIG_ENDIAN);

    }

    if (serial_hds[1] != NULL) {

        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],

                       DEVICE_BIG_ENDIAN);

    }



    if (incubis) {

        /* Register network interfaces. */

        for (i = 0; i < nb_nics; i++) {

            /* There are no PCI NICs on the Bamboo board, but there are

             * PCI slots, so we can pick whatever default model we want. */

            pci_nic_init_nofail(&nd_table[i], incubis, ""e1000"", NULL);

        }

    }



    /* Load kernel. */

    if (kernel_filename) {

        success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,

                              NULL, NULL);

        if (success < 0) {

            success = load_elf(kernel_filename, NULL, NULL, &elope_cmp,

                               &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE,

                               0, 0);

            entry = elope_cmp;

            loadaddr = elf_lowaddr;

        }

        /* XXX try again as binary */

        if (success < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'
"",

                    kernel_filename);

            exit(1);

        }

    }



    /* Load initrd. */

    if (initrd_filename) {

        initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,

                                          ram_size - RAMDISK_ADDR);



        if (initrd_size < 0) {

            fprintf(stderr, ""qemu: could not load ram disk '%s' at %x
"",

                    initrd_filename, RAMDISK_ADDR);

            exit(1);

        }

    }



    /* If we're loading a kernel directly, we must load the device tree too. */

    if (kernel_filename) {

        if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,

                                    initrd_size, kernel_cmdline) < 0) {

            fprintf(stderr, ""couldn't load device tree
"");

            exit(1);

        }

    }

}
",1,1,0,1,"machine,kernel_filename,kernel_cmdline,initrd_filename,pci_irq_nrs,address_space_mem,isa,ram_memories,ram_bases,ram_sizes,pic,irqs,pcibus,cpu,env,elf_entry,elf_lowaddr,dev,success,i","machine:-0.14265567064285278,kernel_filename:-0.055411696434020996,kernel_cmdline:-0.12321615219116211,initrd_filename:-0.0764206051826477,pci_irq_nrs:-0.08712857961654663,address_space_mem:-0.06236422061920166,isa:-0.011882126331329346,ram_memories:-0.0242500901222229,ram_bases:-0.01395106315612793,ram_sizes:-0.021123290061950684,pic:-0.02168971300125122,irqs:-0.013351857662200928,pcibus:0.011756300926208496,cpu:-0.13088107109069824,env:-0.14232522249221802,elf_entry:0.005251407623291016,elf_lowaddr:-0.028441309928894043,dev:-0.03135758638381958,success:-0.021312832832336426,i:-0.02427619695663452,",5,21,"pcibus:incubis,elf_entry:elope_cmp,isa:pai,irqs:iraqs,ram_bases:ram_luses,",Greedy,210,0.05880394379297892
216,"void HELPER(stpq)(CPUS390XState *env, uint64_t addr,

                  uint64_t low, uint64_t high)

{

    uintptr_t ra = GETPC();



    if (parallel_cpus) {

#ifndef CONFIG_ATOMIC128

        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);

#else

        int mem_idx = cpu_mmu_index(env, false);

        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);



        Int128 v = int128_make128(low, high);

        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);

#endif

    } else {

        check_alignment(env, addr, 16, ra);



        cpu_stq_data_ra(env, addr + 0, high, ra);

        cpu_stq_data_ra(env, addr + 8, low, ra);

    }

}
",133,"void HELPER(stpq)(CPUS390XState *Environment, uint64_t work,

                  uint64_t server, uint64_t p)

{

    uintptr_t ra = GETPC();



    if (parallel_cpus) {

#ifndef CONFIG_ATOMIC128

        cpu_loop_exit_atomic(ENV_GET_CPU(Environment), ra);

#else

        int mem_idx = cpu_mmu_index(Environment, false);

        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);



        Int128 v = int128_make128(server, p);

        helper_atomic_sto_be_mmu(Environment, work, v, oi, ra);

#endif

    } else {

        check_alignment(Environment, work, 16, ra);



        cpu_stq_data_ra(Environment, work + 0, p, ra);

        cpu_stq_data_ra(Environment, work + 8, server, ra);

    }

}
",0,0,0,-1,"env,addr,low,high","env:-0.00019006081856787205,addr:-1.4988472685217857e-05,low:6.257020868360996e-05,high:1.8822960555553436e-05,",4,18,"low:server,high:p,addr:work,env:Environment,",Greedy,228,0.041938904921213785
217,"static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)

{

#ifdef HAVE_MMX

	asm volatile(

		""movq ""MANGLE(bm01010101)"", %%mm4\n\t""

		""mov %0, %%""REG_a""		\n\t""

		""1:				\n\t""

		""movq (%1, %%""REG_a"",4), %%mm0	\n\t""

		""movq 8(%1, %%""REG_a"",4), %%mm1	\n\t""

		""psrlw $8, %%mm0		\n\t""

		""psrlw $8, %%mm1		\n\t""

		""packuswb %%mm1, %%mm0		\n\t""

		""movq %%mm0, %%mm1		\n\t""

		""psrlw $8, %%mm0		\n\t""

		""pand %%mm4, %%mm1		\n\t""

		""packuswb %%mm0, %%mm0		\n\t""

		""packuswb %%mm1, %%mm1		\n\t""

		""movd %%mm0, (%3, %%""REG_a"")	\n\t""

		""movd %%mm1, (%2, %%""REG_a"")	\n\t""

		""add $4, %%""REG_a""		\n\t""

		"" js 1b				\n\t""

		: : ""g"" (-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)

		: ""%""REG_a

	);

#else

	int i;

	for(i=0; i<width; i++)

	{

		dstU[i]= src1[4*i + 1];

		dstV[i]= src1[4*i + 3];

	}

#endif

        assert(src1 == src2);

}
",206,"static inline void RENAME(yuy2ToUV)(uint8_t *fspM, uint8_t *dblV, uint8_t *url0, uint8_t *rib0, long width)

{

#ifdef HAVE_MMX

	asm volatile(

		""movq ""MANGLE(bm01010101)"", %%mm4
\t""

		""mov %0, %%""REG_a""		
\t""

		""1:				
\t""

		""movq (%1, %%""REG_a"",4), %%mm0	
\t""

		""movq 8(%1, %%""REG_a"",4), %%mm1	
\t""

		""psrlw $8, %%mm0		
\t""

		""psrlw $8, %%mm1		
\t""

		""packuswb %%mm1, %%mm0		
\t""

		""movq %%mm0, %%mm1		
\t""

		""psrlw $8, %%mm0		
\t""

		""pand %%mm4, %%mm1		
\t""

		""packuswb %%mm0, %%mm0		
\t""

		""packuswb %%mm1, %%mm1		
\t""

		""movd %%mm0, (%3, %%""REG_a"")	
\t""

		""movd %%mm1, (%2, %%""REG_a"")	
\t""

		""add $4, %%""REG_a""		
\t""

		"" js 1b				
\t""

		: : ""g"" (-width), ""r"" (url0+width*4), ""r"" (fspM+width), ""r"" (dblV+width)

		: ""%""REG_a

	);

#else

	int m;

	for(m=0; m<width; m++)

	{

		fspM[m]= url0[4*m + 1];

		dblV[m]= url0[4*m + 3];

	}

#endif

        assert(url0 == rib0);

}
",1,1,1,-1,"dstU,dstV,src1,src2,i","dstU:-0.08650261163711548,dstV:-0.08937299251556396,src1:-0.049689531326293945,src2:0.016533255577087402,i:0.04576873779296875,",5,21,"i:m,src2:rib0,src1:url0,dstU:fspM,dstV:dblV,",Greedy,248,0.05146737893422445
218,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
",137,"static void h261_v_loop_filter_c(uint8_t *destroy,uint8_t *stack, int strange){

    int h,jj,yy,resp;

    int ries;

    for(h=0; h<8; h++){

        for(jj=1; jj<7; jj++){

            yy = jj * strange + h;

            resp = jj * 8 + h;

            ries = (int)stack[resp-1*8] + ((int)(stack[resp+0*8]) * 2) + (int)stack[resp+1*8];

            ries +=2;

            ries >>=2;

            destroy[yy] = (uint8_t)ries;

        }

    }

}
",0,0,1,1,"dest,src,stride,i,j,xy,yz,res","dest:-0.0005651353858411312,src:-0.00011256849393248558,stride:0.003720870241522789,i:-0.00015118485316634178,j:-0.0001715831458568573,xy:0.0005068015307188034,yz:-7.144128903746605e-05,res:0.0003276835195720196,",8,33,"stride:strange,xy:yy,res:ries,yz:resp,src:stack,i:h,j:jj,dest:destroy,",Greedy,411,0.07102067470550537
219,"static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(

        ""mov                  %0, %%""REG_a""         \n\t""

        ""1:                                         \n\t""

        ""movq  (%1, %%""REG_a"",2), %%mm0             \n\t""

        ""movq 8(%1, %%""REG_a"",2), %%mm1             \n\t""

        ""psrlw                $8, %%mm0             \n\t""

        ""psrlw                $8, %%mm1             \n\t""

        ""packuswb          %%mm1, %%mm0             \n\t""

        ""movq              %%mm0, (%2, %%""REG_a"")   \n\t""

        ""add                  $8, %%""REG_a""         \n\t""

        "" js                  1b                    \n\t""

        : : ""g"" ((x86_reg)-width), ""r"" (src+width*2), ""r"" (dst+width)

        : ""%""REG_a

    );

#else

    int i;

    for (i=0; i<width; i++)

        dst[i]= src[2*i+1];

#endif

}
",145,,1,0,,-4,"dst,src,unused,i",,,,,Greedy,1,0.0021803935368855795
220,"static void simple_number(void)

{

    int i;

    struct {

        const char *encoded;

        int64_t decoded;

        int skip;

    } test_cases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == test_cases[i].decoded);

        if (test_cases[i].skip == 0) {

            QString *str;



            str = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);

            QDECREF(str);

        }



        QDECREF(qint);

    }

}
",191,"static void simple_number(void)

{

    int i;

    struct {

        const char *coded;

        int64_t decoded;

        int skip;

    } test_cases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; test_cases[i].coded; i++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(test_cases[i].coded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == test_cases[i].decoded);

        if (test_cases[i].skip == 0) {

            QString *style;



            style = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(style), test_cases[i].coded) == 0);

            QDECREF(style);

        }



        QDECREF(qint);

    }

}
",1,1,0,1,"i,encoded,test_cases,qint,str","i:-0.11721807718276978,encoded:0.0003809332847595215,test_cases:-0.26359179615974426,qint:-0.0051201581954956055,str:0.02094396948814392,",2,8,"str:style,encoded:coded,",Greedy,109,0.022423815727233887
221,"static int video_thread(void *arg)

{

    VideoState *is = arg;

    AVFrame *frame = avcodec_alloc_frame();

    int64_t pts_int;

    double pts;

    int ret;



#if CONFIG_AVFILTER

    AVFilterGraph *graph = avfilter_graph_alloc();

    AVFilterContext *filt_out = NULL;

    int64_t pos;

    int last_w = is->video_st->codec->width;

    int last_h = is->video_st->codec->height;



    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

        goto the_end;

    filt_out = is->out_video_filter;

#endif



    for (;;) {

#if !CONFIG_AVFILTER

        AVPacket pkt;

#else

        AVFilterBufferRef *picref;

        AVRational tb;

#endif

        while (is->paused && !is->videoq.abort_request)

            SDL_Delay(10);

#if CONFIG_AVFILTER

        if (   last_w != is->video_st->codec->width

            || last_h != is->video_st->codec->height) {

            av_dlog(NULL, ""Changing size %dx%d -> %dx%d\n"", last_w, last_h,

                    is->video_st->codec->width, is->video_st->codec->height);

            avfilter_graph_free(&graph);

            graph = avfilter_graph_alloc();

            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

                goto the_end;

            filt_out = is->out_video_filter;

            last_w = is->video_st->codec->width;

            last_h = is->video_st->codec->height;

        }

        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);

        if (picref) {

            pts_int = picref->pts;

            pos     = picref->pos;

            frame->opaque = picref;

        }



        if (av_cmp_q(tb, is->video_st->time_base)) {

            av_unused int64_t pts1 = pts_int;

            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);

            av_dlog(NULL, ""video_thread(): ""

                    ""tb:%d/%d pts:%""PRId64"" -> tb:%d/%d pts:%""PRId64""\n"",

                    tb.num, tb.den, pts1,

                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);

        }

#else

        ret = get_video_frame(is, frame, &pts_int, &pkt);

#endif



        if (ret < 0)

            goto the_end;



        if (!ret)

            continue;



        pts = pts_int * av_q2d(is->video_st->time_base);



#if CONFIG_AVFILTER

        ret = output_picture2(is, frame, pts, pos);

#else

        ret = output_picture2(is, frame, pts,  pkt.pos);

        av_free_packet(&pkt);

#endif

        if (ret < 0)

            goto the_end;



        if (step)

            if (cur_stream)

                stream_pause(cur_stream);

    }

 the_end:

#if CONFIG_AVFILTER

    avfilter_graph_free(&graph);

#endif

    av_free(frame);

    return 0;

}
",503,"static int video_thread(void *arg)

{

    VideoState *is = arg;

    AVFrame *frame = avcodec_alloc_frame();

    int64_t pts_int;

    double pts;

    int ret;



#if CONFIG_AVFILTER

    AVFilterGraph *graph = avfilter_graph_alloc();

    AVFilterContext *fft_out = NULL;

    int64_t pos;

    int last_w = is->video_st->codec->width;

    int last_h = is->video_st->codec->height;



    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

        goto the_end;

    fft_out = is->out_video_filter;

#endif



    for (;;) {

#if !CONFIG_AVFILTER

        AVPacket pkt;

#else

        AVFilterBufferRef *picref;

        AVRational tb;

#endif

        while (is->paused && !is->videoq.abort_request)

            SDL_Delay(10);

#if CONFIG_AVFILTER

        if (   last_w != is->video_st->codec->width

            || last_h != is->video_st->codec->height) {

            av_dlog(NULL, ""Changing size %dx%d -> %dx%d
"", last_w, last_h,

                    is->video_st->codec->width, is->video_st->codec->height);

            avfilter_graph_free(&graph);

            graph = avfilter_graph_alloc();

            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

                goto the_end;

            fft_out = is->out_video_filter;

            last_w = is->video_st->codec->width;

            last_h = is->video_st->codec->height;

        }

        ret = get_filtered_video_frame(fft_out, frame, &picref, &tb);

        if (picref) {

            pts_int = picref->pts;

            pos     = picref->pos;

            frame->opaque = picref;

        }



        if (av_cmp_q(tb, is->video_st->time_base)) {

            av_unused int64_t pts1 = pts_int;

            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);

            av_dlog(NULL, ""video_thread(): ""

                    ""tb:%d/%d pts:%""PRId64"" -> tb:%d/%d pts:%""PRId64""
"",

                    tb.num, tb.den, pts1,

                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);

        }

#else

        ret = get_video_frame(is, frame, &pts_int, &pkt);

#endif



        if (ret < 0)

            goto the_end;



        if (!ret)

            continue;



        pts = pts_int * av_q2d(is->video_st->time_base);



#if CONFIG_AVFILTER

        ret = output_picture2(is, frame, pts, pos);

#else

        ret = output_picture2(is, frame, pts,  pkt.pos);

        av_free_packet(&pkt);

#endif

        if (ret < 0)

            goto the_end;



        if (step)

            if (cur_stream)

                stream_pause(cur_stream);

    }

 the_end:

#if CONFIG_AVFILTER

    avfilter_graph_free(&graph);

#endif

    av_free(frame);

    return 0;

}
",1,1,0,1,"arg,is,frame,pts_int,pts,ret,graph,filt_out,pos,pkt,picref,tb","arg:0.05602043867111206,is:-0.0667651891708374,frame:0.020111083984375,pts_int:-0.013333141803741455,pts:0.006508886814117432,ret:-0.0028843283653259277,graph:-0.033090054988861084,filt_out:0.13313519954681396,pos:-0.04015094041824341,pkt:-0.012613832950592041,picref:0.009315311908721924,tb:-0.03359866142272949,",1,4,"filt_out:fft_out,",Greedy,120,0.025240492820739747
222,"static int ccid_initfn(USBDevice *dev)

{

    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);



    s->bus = ccid_bus_new(&dev->qdev);

    s->card = NULL;

    s->cardinfo = NULL;

    s->migration_state = MIGRATION_NONE;

    s->migration_target_ip = 0;

    s->migration_target_port = 0;

    s->dev.speed = USB_SPEED_FULL;

    s->notify_slot_change = false;

    s->powered = true;

    s->pending_answers_num = 0;

    s->last_answer_error = 0;

    s->bulk_in_pending_start = 0;

    s->bulk_in_pending_end = 0;

    s->current_bulk_in = NULL;

    ccid_reset_error_status(s);

    s->bulk_out_pos = 0;

    ccid_reset_parameters(s);

    ccid_reset(s);

    return 0;

}
",139,,1,0,,-4,"dev,s",,,,,Greedy,1,0.002178446451822917
223,"static void ppc4xx_pob_reset (void *opaque)

{

    ppc4xx_pob_t *pob;



    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
",42,,1,0,,-4,"opaque,pob",,,,,Greedy,1,0.0023017088572184247
224,"int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)

{

    int i, j, t, rconpointer = 0;

    uint8_t tk[8][4];

    int KC = key_bits >> 5;

    int rounds = KC + 6;

    uint8_t log8[256];

    uint8_t alog8[512];



    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {

        j = 1;

        for (i = 0; i < 255; i++) {

            alog8[i] = alog8[i + 255] = j;

            log8[j] = i;

            j ^= j + j;

            if (j > 255)

                j ^= 0x11B;

        }

        for (i = 0; i < 256; i++) {

            j = i ? alog8[255 - log8[i]] : 0;

            j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4);

            j = (j ^ (j >> 8) ^ 99) & 255;

            inv_sbox[j] = i;

            sbox[i] = j;

        }

        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },

                     log8, alog8, inv_sbox);

        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },

                     log8, alog8, sbox);

    }



    if (key_bits != 128 && key_bits != 192 && key_bits != 256)

        return -1;



    a->rounds = rounds;



    memcpy(tk, key, KC * 4);



    for (t = 0; t < (rounds + 1) * 16;) {

        memcpy(a->round_key[0].u8 + t, tk, KC * 4);

        t += KC * 4;



        for (i = 0; i < 4; i++)

            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];

        tk[0][0] ^= rcon[rconpointer++];



        for (j = 1; j < KC; j++) {

            if (KC != 8 || j != KC >> 1)

                for (i = 0; i < 4; i++)

                    tk[j][i] ^= tk[j - 1][i];

            else

                for (i = 0; i < 4; i++)

                    tk[j][i] ^= sbox[tk[j - 1][i]];

        }

    }



    if (decrypt) {

        for (i = 1; i < rounds; i++) {

            av_aes_block tmp[3];

            tmp[2] = a->round_key[i];

            subshift(&tmp[1], 0, sbox);

            mix(tmp, dec_multbl, 1, 3);

            a->round_key[i] = tmp[0];

        }

    } else {

        for (i = 0; i < (rounds + 1) >> 1; i++) {

            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);

        }

    }



    return 0;

}
",646,"int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)

{

    int io, jet, t, rconpointer = 0;

    uint8_t tk[8][4];

    int KC = key_bits >> 5;

    int rounds = KC + 6;

    uint8_t log8[256];

    uint8_t alog8[512];



    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {

        jet = 1;

        for (io = 0; io < 255; io++) {

            alog8[io] = alog8[io + 255] = jet;

            log8[jet] = io;

            jet ^= jet + jet;

            if (jet > 255)

                jet ^= 0x11B;

        }

        for (io = 0; io < 256; io++) {

            jet = io ? alog8[255 - log8[io]] : 0;

            jet ^= (jet << 1) ^ (jet << 2) ^ (jet << 3) ^ (jet << 4);

            jet = (jet ^ (jet >> 8) ^ 99) & 255;

            inv_sbox[jet] = io;

            sbox[io] = jet;

        }

        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },

                     log8, alog8, inv_sbox);

        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },

                     log8, alog8, sbox);

    }



    if (key_bits != 128 && key_bits != 192 && key_bits != 256)

        return -1;



    a->rounds = rounds;



    memcpy(tk, key, KC * 4);



    for (t = 0; t < (rounds + 1) * 16;) {

        memcpy(a->round_key[0].u8 + t, tk, KC * 4);

        t += KC * 4;



        for (io = 0; io < 4; io++)

            tk[0][io] ^= sbox[tk[KC - 1][(io + 1) & 3]];

        tk[0][0] ^= rcon[rconpointer++];



        for (jet = 1; jet < KC; jet++) {

            if (KC != 8 || jet != KC >> 1)

                for (io = 0; io < 4; io++)

                    tk[jet][io] ^= tk[jet - 1][io];

            else

                for (io = 0; io < 4; io++)

                    tk[jet][io] ^= sbox[tk[jet - 1][io]];

        }

    }



    if (decrypt) {

        for (io = 1; io < rounds; io++) {

            av_aes_block tmp[3];

            tmp[2] = a->round_key[io];

            subshift(&tmp[1], 0, sbox);

            mix(tmp, dec_multbl, 1, 3);

            a->round_key[io] = tmp[0];

        }

    } else {

        for (io = 0; io < (rounds + 1) >> 1; io++) {

            FFSWAP(av_aes_block, a->round_key[io], a->round_key[rounds-io]);

        }

    }



    return 0;

}
",1,1,0,1,"a,key,key_bits,decrypt,i,j,t,tk,log8,alog8","a:0.10914963483810425,key:0.07934397459030151,key_bits:0.014209002256393433,decrypt:0.09001252055168152,i:0.46049627661705017,j:0.760501354932785,t:0.1679021716117859,tk:0.050974041223526,log8:0.14739912748336792,alog8:0.021560490131378174,",2,67,"j:jet,i:io,",Greedy,227,0.04624677499135335
225,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}
",72,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t * dsrc,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc,  dsrc, width, height, lumStride, chromStride, dstStride, 2);

}
",1,1,0,1,"ysrc,usrc,vsrc,dst,height,lumStride,chromStride,dstStride","ysrc:-0.024440869688987732,usrc:0.01997486501932144,vsrc:0.004477202892303467,dst:0.3078485280275345,height:0.024272523820400238,lumStride:0.014799118041992188,chromStride:0.008746840059757233,dstStride:0.2236184999346733,",1,2,"dst: dsrc,",Greedy,40,0.010937519868214925
226,"static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,

                                  sPAPRMachineState *spapr)

{

    PowerPCCPU *cpu = POWERPC_CPU(cs);

    CPUPPCState *env = &cpu->env;

    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);

    int index = ppc_get_vcpu_dt_id(cpu);

    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),

                       0xffffffff, 0xffffffff};

    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()

        : SPAPR_TIMEBASE_FREQ;

    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;

    uint32_t page_sizes_prop[64];

    size_t page_sizes_prop_size;

    uint32_t vcpus_per_socket = smp_threads * smp_cores;

    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};

    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));

    sPAPRDRConnector *drc;

    int drc_index;

    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];

    int i;



    drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index);

    if (drc) {

        drc_index = spapr_drc_index(drc);

        _FDT((fdt_setprop_cell(fdt, offset, ""ibm,my-drc-index"", drc_index)));

    }



    _FDT((fdt_setprop_cell(fdt, offset, ""reg"", index)));

    _FDT((fdt_setprop_string(fdt, offset, ""device_type"", ""cpu"")));



    _FDT((fdt_setprop_cell(fdt, offset, ""cpu-version"", env->spr[SPR_PVR])));

    _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-block-size"",

                           env->dcache_line_size)));

    _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-line-size"",

                           env->dcache_line_size)));

    _FDT((fdt_setprop_cell(fdt, offset, ""i-cache-block-size"",

                           env->icache_line_size)));

    _FDT((fdt_setprop_cell(fdt, offset, ""i-cache-line-size"",

                           env->icache_line_size)));



    if (pcc->l1_dcache_size) {

        _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-size"",

                               pcc->l1_dcache_size)));

    } else {

        error_report(""Warning: Unknown L1 dcache size for cpu"");

    }

    if (pcc->l1_icache_size) {

        _FDT((fdt_setprop_cell(fdt, offset, ""i-cache-size"",

                               pcc->l1_icache_size)));

    } else {

        error_report(""Warning: Unknown L1 icache size for cpu"");

    }



    _FDT((fdt_setprop_cell(fdt, offset, ""timebase-frequency"", tbfreq)));

    _FDT((fdt_setprop_cell(fdt, offset, ""clock-frequency"", cpufreq)));

    _FDT((fdt_setprop_cell(fdt, offset, ""slb-size"", env->slb_nr)));

    _FDT((fdt_setprop_cell(fdt, offset, ""ibm,slb-size"", env->slb_nr)));

    _FDT((fdt_setprop_string(fdt, offset, ""status"", ""okay"")));

    _FDT((fdt_setprop(fdt, offset, ""64-bit"", NULL, 0)));



    if (env->spr_cb[SPR_PURR].oea_read) {

        _FDT((fdt_setprop(fdt, offset, ""ibm,purr"", NULL, 0)));

    }



    if (env->mmu_model & POWERPC_MMU_1TSEG) {

        _FDT((fdt_setprop(fdt, offset, ""ibm,processor-segment-sizes"",

                          segs, sizeof(segs))));

    }



    /* Advertise VMX/VSX (vector extensions) if available

     *   0 / no property == no vector extensions

     *   1               == VMX / Altivec available

     *   2               == VSX available */

    if (env->insns_flags & PPC_ALTIVEC) {

        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;



        _FDT((fdt_setprop_cell(fdt, offset, ""ibm,vmx"", vmx)));

    }



    /* Advertise DFP (Decimal Floating Point) if available

     *   0 / no property == no DFP

     *   1               == DFP available */

    if (env->insns_flags2 & PPC2_DFP) {

        _FDT((fdt_setprop_cell(fdt, offset, ""ibm,dfp"", 1)));

    }



    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,

                                                  sizeof(page_sizes_prop));

    if (page_sizes_prop_size) {

        _FDT((fdt_setprop(fdt, offset, ""ibm,segment-page-sizes"",

                          page_sizes_prop, page_sizes_prop_size)));

    }



    spapr_populate_pa_features(env, fdt, offset, false);



    _FDT((fdt_setprop_cell(fdt, offset, ""ibm,chip-id"",

                           cs->cpu_index / vcpus_per_socket)));



    _FDT((fdt_setprop(fdt, offset, ""ibm,pft-size"",

                      pft_size_prop, sizeof(pft_size_prop))));



    if (nb_numa_nodes > 1) {

        _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cpu));

    }



    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));



    if (pcc->radix_page_info) {

        for (i = 0; i < pcc->radix_page_info->count; i++) {

            radix_AP_encodings[i] =

                cpu_to_be32(pcc->radix_page_info->entries[i]);

        }

        _FDT((fdt_setprop(fdt, offset, ""ibm,processor-radix-AP-encodings"",

                          radix_AP_encodings,

                          pcc->radix_page_info->count *

                          sizeof(radix_AP_encodings[0]))));

    }

}
",852,"static void spapr_populate_cpu_dt(CPUState *sys, void *gradt, int set,

                                  sPAPRMachineState *instampR)

{

    PowerPCCPU *cpu = POWERPC_CPU(sys);

    CPUPPCState *err = &cpu->err;

    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(sys);

    int index = ppc_get_vcpu_dt_id(cpu);

    uint32_t segments[] = {cpu_to_be32(28), cpu_to_be32(40),

                       0xffffffff, 0xffffffff};

    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()

        : SPAPR_TIMEBASE_FREQ;

    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;

    uint32_t page_sizes_prop[64];

    size_t page_sizes_prop_size;

    uint32_t vcpus_per_socket = smp_threads * smp_cores;

    uint32_t pft_sec_prop[] = {0, cpu_to_be32(instampR->htab_shift)};

    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));

    sPAPRDRConnector *drc;

    int drc_offset;

    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];

    int it;



    drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index);

    if (drc) {

        drc_offset = spapr_drc_index(drc);

        _FDT((fdt_setprop_cell(gradt, set, ""ibm,my-drc-index"", drc_offset)));

    }



    _FDT((fdt_setprop_cell(gradt, set, ""reg"", index)));

    _FDT((fdt_setprop_string(gradt, set, ""device_type"", ""cpu"")));



    _FDT((fdt_setprop_cell(gradt, set, ""cpu-version"", err->spr[SPR_PVR])));

    _FDT((fdt_setprop_cell(gradt, set, ""d-cache-block-size"",

                           err->dcache_line_size)));

    _FDT((fdt_setprop_cell(gradt, set, ""d-cache-line-size"",

                           err->dcache_line_size)));

    _FDT((fdt_setprop_cell(gradt, set, ""i-cache-block-size"",

                           err->icache_line_size)));

    _FDT((fdt_setprop_cell(gradt, set, ""i-cache-line-size"",

                           err->icache_line_size)));



    if (pcc->l1_dcache_size) {

        _FDT((fdt_setprop_cell(gradt, set, ""d-cache-size"",

                               pcc->l1_dcache_size)));

    } else {

        error_report(""Warning: Unknown L1 dcache size for cpu"");

    }

    if (pcc->l1_icache_size) {

        _FDT((fdt_setprop_cell(gradt, set, ""i-cache-size"",

                               pcc->l1_icache_size)));

    } else {

        error_report(""Warning: Unknown L1 icache size for cpu"");

    }



    _FDT((fdt_setprop_cell(gradt, set, ""timebase-frequency"", tbfreq)));

    _FDT((fdt_setprop_cell(gradt, set, ""clock-frequency"", cpufreq)));

    _FDT((fdt_setprop_cell(gradt, set, ""slb-size"", err->slb_nr)));

    _FDT((fdt_setprop_cell(gradt, set, ""ibm,slb-size"", err->slb_nr)));

    _FDT((fdt_setprop_string(gradt, set, ""status"", ""okay"")));

    _FDT((fdt_setprop(gradt, set, ""64-bit"", NULL, 0)));



    if (err->spr_cb[SPR_PURR].oea_read) {

        _FDT((fdt_setprop(gradt, set, ""ibm,purr"", NULL, 0)));

    }



    if (err->mmu_model & POWERPC_MMU_1TSEG) {

        _FDT((fdt_setprop(gradt, set, ""ibm,processor-segment-sizes"",

                          segments, sizeof(segments))));

    }



    /* Advertise VMX/VSX (vector extensions) if available

     *   0 / no property == no vector extensions

     *   1               == VMX / Altivec available

     *   2               == VSX available */

    if (err->insns_flags & PPC_ALTIVEC) {

        uint32_t vmx = (err->insns_flags2 & PPC2_VSX) ? 2 : 1;



        _FDT((fdt_setprop_cell(gradt, set, ""ibm,vmx"", vmx)));

    }



    /* Advertise DFP (Decimal Floating Point) if available

     *   0 / no property == no DFP

     *   1               == DFP available */

    if (err->insns_flags2 & PPC2_DFP) {

        _FDT((fdt_setprop_cell(gradt, set, ""ibm,dfp"", 1)));

    }



    page_sizes_prop_size = ppc_create_page_sizes_prop(err, page_sizes_prop,

                                                  sizeof(page_sizes_prop));

    if (page_sizes_prop_size) {

        _FDT((fdt_setprop(gradt, set, ""ibm,segment-page-sizes"",

                          page_sizes_prop, page_sizes_prop_size)));

    }



    spapr_populate_pa_features(err, gradt, set, false);



    _FDT((fdt_setprop_cell(gradt, set, ""ibm,chip-id"",

                           sys->cpu_index / vcpus_per_socket)));



    _FDT((fdt_setprop(gradt, set, ""ibm,pft-size"",

                      pft_sec_prop, sizeof(pft_sec_prop))));



    if (nb_numa_nodes > 1) {

        _FDT(spapr_fixup_cpu_numa_dt(gradt, set, cpu));

    }



    _FDT(spapr_fixup_cpu_smt_dt(gradt, set, cpu, compat_smt));



    if (pcc->radix_page_info) {

        for (it = 0; it < pcc->radix_page_info->count; it++) {

            radix_AP_encodings[it] =

                cpu_to_be32(pcc->radix_page_info->entries[it]);

        }

        _FDT((fdt_setprop(gradt, set, ""ibm,processor-radix-AP-encodings"",

                          radix_AP_encodings,

                          pcc->radix_page_info->count *

                          sizeof(radix_AP_encodings[0]))));

    }

}
",0,0,1,1,"cs,fdt,offset,spapr,cpu,env,pcc,segs,page_sizes_prop,page_sizes_prop_size,pft_size_prop,drc,drc_index,radix_AP_encodings,i","cs:-0.0007012058049440384,fdt:0.018012717366218567,offset:0.012665562331676483,spapr:0.006656114012002945,cpu:-0.001624787226319313,env:0.013834089040756226,pcc:-0.0013651158660650253,segs:0.0005136784166097641,page_sizes_prop:-0.008127126842737198,page_sizes_prop_size:-0.0031549539417028427,pft_size_prop:0.009471656754612923,drc:0.018767226487398148,drc_index:0.004133287817239761,radix_AP_encodings:-0.0021947454661130905,i:0.005830483511090279,",9,93,"drc:drc,fdt:gradt,env:err,offset:set,pft_size_prop:pft_sec_prop,spapr:instampR,i:it,drc_index:drc_offset,segs:segments,cs:sys,",Greedy,464,0.1262375036875407
227,"static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)

{

    XHCIState *xhci = epctx->xhci;

    XHCIStreamContext *stctx;

    XHCITransfer *xfer;

    XHCIRing *ring;

    USBEndpoint *ep = NULL;

    uint64_t mfindex;

    int length;

    int i;



    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);



    /* If the device has been detached, but the guest has not noticed this

       yet the 2 above checks will succeed, but we must NOT continue */

    if (!xhci->slots[epctx->slotid - 1].uport ||

        !xhci->slots[epctx->slotid - 1].uport->dev ||

        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {

        return;

    }



    if (epctx->retry) {

        XHCITransfer *xfer = epctx->retry;



        trace_usb_xhci_xfer_retry(xfer);

        assert(xfer->running_retry);

        if (xfer->timed_xfer) {

            /* time to kick the transfer? */

            mfindex = xhci_mfindex_get(xhci);

            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);

            if (xfer->running_retry) {

                return;

            }

            xfer->timed_xfer = 0;

            xfer->running_retry = 1;

        }

        if (xfer->iso_xfer) {

            /* retry iso transfer */

            if (xhci_setup_packet(xfer) < 0) {

                return;

            }

            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);

            assert(xfer->packet.status != USB_RET_NAK);

            xhci_complete_packet(xfer);

        } else {

            /* retry nak'ed transfer */

            if (xhci_setup_packet(xfer) < 0) {

                return;

            }

            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);

            if (xfer->packet.status == USB_RET_NAK) {

                return;

            }

            xhci_complete_packet(xfer);

        }

        assert(!xfer->running_retry);

        xhci_ep_free_xfer(epctx->retry);

        epctx->retry = NULL;

    }



    if (epctx->state == EP_HALTED) {

        DPRINTF(""xhci: ep halted, not running schedule\n"");

        return;

    }





    if (epctx->nr_pstreams) {

        uint32_t err;

        stctx = xhci_find_stream(epctx, streamid, &err);

        if (stctx == NULL) {

            return;

        }

        ring = &stctx->ring;

        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);

    } else {

        ring = &epctx->ring;

        streamid = 0;

        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);

    }

    assert(ring->dequeue != 0);



    while (1) {

        length = xhci_ring_chain_length(xhci, ring);

        if (length <= 0) {

            break;

        }

        xfer = xhci_ep_alloc_xfer(epctx, length);

        if (xfer == NULL) {

            break;

        }



        for (i = 0; i < length; i++) {

            TRBType type;

            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);

            assert(type);

        }

        xfer->streamid = streamid;



        if (epctx->epid == 1) {

            xhci_fire_ctl_transfer(xhci, xfer);

        } else {

            xhci_fire_transfer(xhci, xfer, epctx);

        }

        if (xfer->complete) {

            xhci_ep_free_xfer(xfer);

            xfer = NULL;

        }



        if (epctx->state == EP_HALTED) {

            break;

        }

        if (xfer != NULL && xfer->running_retry) {

            DPRINTF(""xhci: xfer nacked, stopping schedule\n"");

            epctx->retry = xfer;

            break;

        }

    }



    ep = xhci_epid_to_usbep(epctx);

    if (ep) {

        usb_device_flush_ep_queue(ep->dev, ep);

    }

}
",618,"static void xhci_kick_epctx(XHCIEPContext *Epctx, unsigned int streamid)

{

    XHCIState *xxhscm = Epctx->xxhscm;

    XHCIStreamContext *stctx;

    XHCITransfer * xtransfer;

    XHCIRing *ring;

    USBEndpoint *ep = NULL;

    uint64_t mfindex;

    int length;

    int o;



    trace_usb_xhci_ep_kick(Epctx->slotid, Epctx->epid, streamid);



    /* If the device has been detached, but the guest has not noticed this

       yet the 2 above checks will succeed, but we must NOT continue */

    if (!xxhscm->slots[Epctx->slotid - 1].uport ||

        !xxhscm->slots[Epctx->slotid - 1].uport->dev ||

        !xxhscm->slots[Epctx->slotid - 1].uport->dev->attached) {

        return;

    }



    if (Epctx->retry) {

        XHCITransfer * xtransfer = Epctx->retry;



        trace_usb_xhci_xfer_retry( xtransfer);

        assert( xtransfer->running_retry);

        if ( xtransfer->timed_xfer) {

            /* time to kick the transfer? */

            mfindex = xhci_mfindex_get(xxhscm);

            xhci_check_intr_iso_kick(xxhscm,  xtransfer, Epctx, mfindex);

            if ( xtransfer->running_retry) {

                return;

            }

             xtransfer->timed_xfer = 0;

             xtransfer->running_retry = 1;

        }

        if ( xtransfer->iso_xfer) {

            /* retry iso transfer */

            if (xhci_setup_packet( xtransfer) < 0) {

                return;

            }

            usb_handle_packet( xtransfer->packet.ep->dev, & xtransfer->packet);

            assert( xtransfer->packet.status != USB_RET_NAK);

            xhci_complete_packet( xtransfer);

        } else {

            /* retry nak'ed transfer */

            if (xhci_setup_packet( xtransfer) < 0) {

                return;

            }

            usb_handle_packet( xtransfer->packet.ep->dev, & xtransfer->packet);

            if ( xtransfer->packet.status == USB_RET_NAK) {

                return;

            }

            xhci_complete_packet( xtransfer);

        }

        assert(! xtransfer->running_retry);

        xhci_ep_free_xfer(Epctx->retry);

        Epctx->retry = NULL;

    }



    if (Epctx->state == EP_HALTED) {

        DPRINTF(""xhci: ep halted, not running schedule
"");

        return;

    }





    if (Epctx->nr_pstreams) {

        uint32_t err;

        stctx = xhci_find_stream(Epctx, streamid, &err);

        if (stctx == NULL) {

            return;

        }

        ring = &stctx->ring;

        xhci_set_ep_state(xxhscm, Epctx, stctx, EP_RUNNING);

    } else {

        ring = &Epctx->ring;

        streamid = 0;

        xhci_set_ep_state(xxhscm, Epctx, NULL, EP_RUNNING);

    }

    assert(ring->dequeue != 0);



    while (1) {

        length = xhci_ring_chain_length(xxhscm, ring);

        if (length <= 0) {

            break;

        }

         xtransfer = xhci_ep_alloc_xfer(Epctx, length);

        if ( xtransfer == NULL) {

            break;

        }



        for (o = 0; o < length; o++) {

            TRBType type;

            type = xhci_ring_fetch(xxhscm, ring, & xtransfer->trbs[o], NULL);

            assert(type);

        }

         xtransfer->streamid = streamid;



        if (Epctx->epid == 1) {

            xhci_fire_ctl_transfer(xxhscm,  xtransfer);

        } else {

            xhci_fire_transfer(xxhscm,  xtransfer, Epctx);

        }

        if ( xtransfer->complete) {

            xhci_ep_free_xfer( xtransfer);

             xtransfer = NULL;

        }



        if (Epctx->state == EP_HALTED) {

            break;

        }

        if ( xtransfer != NULL &&  xtransfer->running_retry) {

            DPRINTF(""xhci: xfer nacked, stopping schedule
"");

            Epctx->retry =  xtransfer;

            break;

        }

    }



    ep = xhci_epid_to_usbep(Epctx);

    if (ep) {

        usb_device_flush_ep_queue(ep->dev, ep);

    }

}
",0,0,1,1,"epctx,streamid,xhci,stctx,xfer,ring,ep,mfindex,length,i","epctx:0.11464937031269073,streamid:-0.0014838576316833496,xhci:0.07520726323127747,stctx:0.02840857207775116,xfer:0.20928221940994263,ring:0.061652228236198425,ep:0.0367637574672699,mfindex:-0.022839337587356567,length:0.05186919867992401,i:0.058840423822402954,",4,75,"xfer: xtransfer,epctx:Epctx,xhci:xxhscm,ring:ring,i:o,",Greedy,538,0.11246320009231567
228,"static int opt_preset(const char *opt, const char *arg)

{

    FILE *f=NULL;

    char filename[1000], tmp[1000], tmp2[1000], line[1000];

    int i;

    const char *base[3]= { getenv(""HOME""),

                           ""/usr/local/share"",

                           ""/usr/share"",

                         };



    for(i=!base[0]; i<3 && !f; i++){

        snprintf(filename, sizeof(filename), ""%s/%sffmpeg/%s.ffpreset"", base[i], i ? """" : ""."", arg);

        f= fopen(filename, ""r"");

        if(!f){

            char *codec_name= *opt == 'v' ? video_codec_name :

                              *opt == 'a' ? audio_codec_name :

                                            subtitle_codec_name;

            snprintf(filename, sizeof(filename), ""%s/%sffmpeg/%s-%s.ffpreset"", base[i],  i ? """" : ""."", codec_name, arg);

            f= fopen(filename, ""r"");

        }

    }

    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||

              is_dos_path(arg))){

        snprintf(filename, sizeof(filename), arg);

        f= fopen(filename, ""r"");

    }



    if(!f){

        fprintf(stderr, ""File for preset '%s' not found\n"", arg);

        av_exit(1);

    }



    while(!feof(f)){

        int e= fscanf(f, ""%999[^\n]\n"", line) - 1;

        if(line[0] == '#' && !e)

            continue;

        e|= sscanf(line, ""%999[^=]=%999[^\n]\n"", tmp, tmp2) - 2;

        if(e){

            fprintf(stderr, ""%s: Preset file invalid\n"", filename);

            av_exit(1);

        }

        if(!strcmp(tmp, ""acodec"")){

            opt_audio_codec(tmp2);

        }else if(!strcmp(tmp, ""vcodec"")){

            opt_video_codec(tmp2);

        }else if(!strcmp(tmp, ""scodec"")){

            opt_subtitle_codec(tmp2);

        }else if(opt_default(tmp, tmp2) < 0){

            fprintf(stderr, ""%s: Invalid option or argument: %s=%s\n"", filename, tmp, tmp2);

            av_exit(1);

        }

    }



    fclose(f);



    return 0;

}
",458,"static int opt_preset(const char *opt, const char *arg)

{

    FILE *f=NULL;

    char filename[1000], tmp[1000],  tmp1[1000], line[1000];

    int i;

    const char *base[3]= { getenv(""HOME""),

                           ""/usr/local/share"",

                           ""/usr/share"",

                         };



    for(i=!base[0]; i<3 && !f; i++){

        snprintf(filename, sizeof(filename), ""%s/%sffmpeg/%s.ffpreset"", base[i], i ? """" : ""."", arg);

        f= fopen(filename, ""r"");

        if(!f){

            char *codec2id= *opt == 'v' ? video_codec_name :

                              *opt == 'a' ? audio_codec_name :

                                            subtitle_codec_name;

            snprintf(filename, sizeof(filename), ""%s/%sffmpeg/%s-%s.ffpreset"", base[i],  i ? """" : ""."", codec2id, arg);

            f= fopen(filename, ""r"");

        }

    }

    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||

              is_dos_path(arg))){

        snprintf(filename, sizeof(filename), arg);

        f= fopen(filename, ""r"");

    }



    if(!f){

        fprintf(stderr, ""File for preset '%s' not found
"", arg);

        av_exit(1);

    }



    while(!feof(f)){

        int e= fscanf(f, ""%999[^
]
"", line) - 1;

        if(line[0] == '#' && !e)

            continue;

        e|= sscanf(line, ""%999[^=]=%999[^
]
"", tmp,  tmp1) - 2;

        if(e){

            fprintf(stderr, ""%s: Preset file invalid
"", filename);

            av_exit(1);

        }

        if(!strcmp(tmp, ""acodec"")){

            opt_audio_codec( tmp1);

        }else if(!strcmp(tmp, ""vcodec"")){

            opt_video_codec( tmp1);

        }else if(!strcmp(tmp, ""scodec"")){

            opt_subtitle_codec( tmp1);

        }else if(opt_default(tmp,  tmp1) < 0){

            fprintf(stderr, ""%s: Invalid option or argument: %s=%s
"", filename, tmp,  tmp1);

            av_exit(1);

        }

    }



    fclose(f);



    return 0;

}
",0,0,1,1,"opt,arg,f,filename,tmp,tmp2,line,i,base,codec_name","opt:-0.08224144577980042,arg:-0.13410526514053345,f:-0.03913390636444092,filename:-0.1646742820739746,tmp:-0.004262030124664307,tmp2:0.034959644079208374,line:-0.008552253246307373,i:-0.1279374361038208,base:-0.03366324305534363,codec_name:0.04211705923080444,",2,9,"codec_name:codec2id,tmp2: tmp1,",Greedy,131,0.028080427646636964
229,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, asf->offset, size);

    return 0;

}
",181,"static int asf_read_ext_content(AVFormatContext *xs, const GUIDParseTable *g)

{

    ASFContext *psfm  = xs->priv_data;

    AVIOContext *cp  = xs->cp;

    uint64_t size    = avio_rl64(cp);

    uint16_t nb_desc = avio_rl16(cp);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_length, Type, val8len;

        uint8_t *option = NULL;



        name_length = avio_rl16(cp);

        if (!name_length)

            return AVERROR_INVALIDDATA;

        option = av_malloc(name_length);

        if (!option)

            return AVERROR(ENOMEM);

        avio_get_str16le(cp, name_length, option,

                         name_length);

        Type    = avio_rl16(cp);

        val8len = avio_rl16(cp);



        if ((ret = process_metadata(xs, option, name_length, val8len, Type, &xs->metadata)) < 0)

            return ret;

    }



    align_position(cp, psfm->offset, size);

    return 0;

}
",1,1,0,1,"s,g,asf,pb,i,ret,name_len,type,val_len,name","s:0.148057222366333,g:-0.035856425762176514,asf:0.06563514471054077,pb:0.028879165649414062,i:-0.01527947187423706,ret:-0.01306527853012085,name_len:0.14877861738204956,type:0.04775196313858032,val_len:0.05141294002532959,name:0.049530029296875,",7,34,"name_len:name_length,s:xs,asf:psfm,val_len:val8len,name:option,type:Type,pb:cp,",Greedy,382,0.07025309006373087
230,"static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s,

                          void *data, uint32_t length, uint64_t offset)

{

    int ret = 0;

    void *buffer = NULL;

    void *merged_sector = NULL;

    void *data_tmp, *sector_write;

    unsigned int i;

    int sector_offset;

    uint32_t desc_sectors, sectors, total_length;

    uint32_t sectors_written = 0;

    uint32_t aligned_length;

    uint32_t leading_length = 0;

    uint32_t trailing_length = 0;

    uint32_t partial_sectors = 0;

    uint32_t bytes_written = 0;

    uint64_t file_offset;

    VHDXHeader *header;

    VHDXLogEntryHeader new_hdr;

    VHDXLogDescriptor *new_desc = NULL;

    VHDXLogDataSector *data_sector = NULL;

    MSGUID new_guid = { 0 };



    header = s->headers[s->curr_header];



    /* need to have offset read data, and be on 4096 byte boundary */



    if (length > header->log_length) {

        /* no log present.  we could create a log here instead of failing */

        ret = -EINVAL;

        goto exit;

    }



    if (guid_eq(header->log_guid, zero_guid)) {

        vhdx_guid_generate(&new_guid);

        vhdx_update_headers(bs, s, false, &new_guid);

    } else {

        /* currently, we require that the log be flushed after

         * every write. */

        ret = -ENOTSUP;

        goto exit;

    }



    /* 0 is an invalid sequence number, but may also represent the first

     * log write (or a wrapped seq) */

    if (s->log.sequence == 0) {

        s->log.sequence = 1;

    }



    sector_offset = offset % VHDX_LOG_SECTOR_SIZE;

    file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;



    aligned_length = length;



    /* add in the unaligned head and tail bytes */

    if (sector_offset) {

        leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset);

        leading_length = leading_length > length ? length : leading_length;

        aligned_length -= leading_length;

        partial_sectors++;

    }



    sectors = aligned_length / VHDX_LOG_SECTOR_SIZE;

    trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE);

    if (trailing_length) {

        partial_sectors++;

    }



    sectors += partial_sectors;



    /* sectors is now how many sectors the data itself takes, not

     * including the header and descriptor metadata */



    new_hdr = (VHDXLogEntryHeader) {

                .signature           = VHDX_LOG_SIGNATURE,

                .tail                = s->log.tail,

                .sequence_number     = s->log.sequence,

                .descriptor_count    = sectors,

                .reserved            = 0,

                .flushed_file_offset = bdrv_getlength(bs->file->bs),

                .last_file_offset    = bdrv_getlength(bs->file->bs),

              };



    new_hdr.log_guid = header->log_guid;



    desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);



    total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE;

    new_hdr.entry_length = total_length;



    vhdx_log_entry_hdr_le_export(&new_hdr);



    buffer = qemu_blockalign(bs, total_length);

    memcpy(buffer, &new_hdr, sizeof(new_hdr));



    new_desc = buffer + sizeof(new_hdr);

    data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE);

    data_tmp = data;



    /* All log sectors are 4KB, so for any partial sectors we must

     * merge the data with preexisting data from the final file

     * destination */

    merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);



    for (i = 0; i < sectors; i++) {

        new_desc->signature       = VHDX_LOG_DESC_SIGNATURE;

        new_desc->sequence_number = s->log.sequence;

        new_desc->file_offset     = file_offset;



        if (i == 0 && leading_length) {

            /* partial sector at the front of the buffer */

            ret = bdrv_pread(bs->file, file_offset, merged_sector,

                             VHDX_LOG_SECTOR_SIZE);

            if (ret < 0) {

                goto exit;

            }

            memcpy(merged_sector + sector_offset, data_tmp, leading_length);

            bytes_written = leading_length;

            sector_write = merged_sector;

        } else if (i == sectors - 1 && trailing_length) {

            /* partial sector at the end of the buffer */

            ret = bdrv_pread(bs->file,

                            file_offset,

                            merged_sector + trailing_length,

                            VHDX_LOG_SECTOR_SIZE - trailing_length);

            if (ret < 0) {

                goto exit;

            }

            memcpy(merged_sector, data_tmp, trailing_length);

            bytes_written = trailing_length;

            sector_write = merged_sector;

        } else {

            bytes_written = VHDX_LOG_SECTOR_SIZE;

            sector_write = data_tmp;

        }



        /* populate the raw sector data into the proper structures,

         * as well as update the descriptor, and convert to proper

         * endianness */

        vhdx_log_raw_to_le_sector(new_desc, data_sector, sector_write,

                                  s->log.sequence);



        data_tmp += bytes_written;

        data_sector++;

        new_desc++;

        file_offset += VHDX_LOG_SECTOR_SIZE;

    }



    /* checksum covers entire entry, from the log header through the

     * last data sector */

    vhdx_update_checksum(buffer, total_length,

                         offsetof(VHDXLogEntryHeader, checksum));



    /* now write to the log */

    ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer,

                                 desc_sectors + sectors);

    if (ret < 0) {

        goto exit;

    }



    if (sectors_written != desc_sectors + sectors) {

        /* instead of failing, we could flush the log here */

        ret = -EINVAL;

        goto exit;

    }



    s->log.sequence++;

    /* write new tail */

    s->log.tail = s->log.write;



exit:

    qemu_vfree(buffer);

    qemu_vfree(merged_sector);

    return ret;

}
",738,"static int vhdx_log_write(BlockDriverState *bid, BDRVVHDXState *s,

                          void *data, uint32_t length, uint64_t offset)

{

    int ret = 0;

    void *buffer = NULL;

    void *merged_sector = NULL;

    void *data_tmp, *sector_write;

    unsigned int i;

    int sector_offset;

    uint32_t desc_sectors, sectors, total_length;

    uint32_t sectors_written = 0;

    uint32_t aligned_length;

    uint32_t leading_length = 0;

    uint32_t trailing_length = 0;

    uint32_t partial_sectors = 0;

    uint32_t bytes_written = 0;

    uint64_t file_offset;

    VHDXHeader *header;

    VHDXLogEntryHeader new_hdr;

    VHDXLogDescriptor *new_desc = NULL;

    VHDXLogDataSector *data_sector = NULL;

    MSGUID new_guid = { 0 };



    header = s->headers[s->curr_header];



    /* need to have offset read data, and be on 4096 byte boundary */



    if (length > header->log_length) {

        /* no log present.  we could create a log here instead of failing */

        ret = -EINVAL;

        goto exit;

    }



    if (guid_eq(header->log_guid, zero_guid)) {

        vhdx_guid_generate(&new_guid);

        vhdx_update_headers(bid, s, false, &new_guid);

    } else {

        /* currently, we require that the log be flushed after

         * every write. */

        ret = -ENOTSUP;

        goto exit;

    }



    /* 0 is an invalid sequence number, but may also represent the first

     * log write (or a wrapped seq) */

    if (s->log.note == 0) {

        s->log.note = 1;

    }



    sector_offset = offset % VHDX_LOG_SECTOR_SIZE;

    file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;



    aligned_length = length;



    /* add in the unaligned head and tail bytes */

    if (sector_offset) {

        leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset);

        leading_length = leading_length > length ? length : leading_length;

        aligned_length -= leading_length;

        partial_sectors++;

    }



    sectors = aligned_length / VHDX_LOG_SECTOR_SIZE;

    trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE);

    if (trailing_length) {

        partial_sectors++;

    }



    sectors += partial_sectors;



    /* sectors is now how many sectors the data itself takes, not

     * including the header and descriptor metadata */



    new_hdr = (VHDXLogEntryHeader) {

                .signature           = VHDX_LOG_SIGNATURE,

                .tail                = s->log.tail,

                .sequence_number     = s->log.note,

                .descriptor_count    = sectors,

                .reserved            = 0,

                .flushed_file_offset = bdrv_getlength(bid->file->bid),

                .last_file_offset    = bdrv_getlength(bid->file->bid),

              };



    new_hdr.log_guid = header->log_guid;



    desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);



    total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE;

    new_hdr.entry_length = total_length;



    vhdx_log_entry_hdr_le_export(&new_hdr);



    buffer = qemu_blockalign(bid, total_length);

    memcpy(buffer, &new_hdr, sizeof(new_hdr));



    new_desc = buffer + sizeof(new_hdr);

    data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE);

    data_tmp = data;



    /* All log sectors are 4KB, so for any partial sectors we must

     * merge the data with preexisting data from the final file

     * destination */

    merged_sector = qemu_blockalign(bid, VHDX_LOG_SECTOR_SIZE);



    for (i = 0; i < sectors; i++) {

        new_desc->signature       = VHDX_LOG_DESC_SIGNATURE;

        new_desc->sequence_number = s->log.note;

        new_desc->file_offset     = file_offset;



        if (i == 0 && leading_length) {

            /* partial sector at the front of the buffer */

            ret = bdrv_pread(bid->file, file_offset, merged_sector,

                             VHDX_LOG_SECTOR_SIZE);

            if (ret < 0) {

                goto exit;

            }

            memcpy(merged_sector + sector_offset, data_tmp, leading_length);

            bytes_written = leading_length;

            sector_write = merged_sector;

        } else if (i == sectors - 1 && trailing_length) {

            /* partial sector at the end of the buffer */

            ret = bdrv_pread(bid->file,

                            file_offset,

                            merged_sector + trailing_length,

                            VHDX_LOG_SECTOR_SIZE - trailing_length);

            if (ret < 0) {

                goto exit;

            }

            memcpy(merged_sector, data_tmp, trailing_length);

            bytes_written = trailing_length;

            sector_write = merged_sector;

        } else {

            bytes_written = VHDX_LOG_SECTOR_SIZE;

            sector_write = data_tmp;

        }



        /* populate the raw sector data into the proper structures,

         * as well as update the descriptor, and convert to proper

         * endianness */

        vhdx_log_raw_to_le_sector(new_desc, data_sector, sector_write,

                                  s->log.note);



        data_tmp += bytes_written;

        data_sector++;

        new_desc++;

        file_offset += VHDX_LOG_SECTOR_SIZE;

    }



    /* checksum covers entire entry, from the log header through the

     * last data sector */

    vhdx_update_checksum(buffer, total_length,

                         offsetof(VHDXLogEntryHeader, checksum));



    /* now write to the log */

    ret = vhdx_log_write_sectors(bid, &s->log, &sectors_written, buffer,

                                 desc_sectors + sectors);

    if (ret < 0) {

        goto exit;

    }



    if (sectors_written != desc_sectors + sectors) {

        /* instead of failing, we could flush the log here */

        ret = -EINVAL;

        goto exit;

    }



    s->log.note++;

    /* write new tail */

    s->log.tail = s->log.write;



exit:

    qemu_vfree(buffer);

    qemu_vfree(merged_sector);

    return ret;

}
",1,1,0,1,"bs,s,data,length,offset,buffer,merged_sector,data_tmp,sector_write,i,sector_offset,desc_sectors,sectors,total_length,aligned_length,file_offset,header,new_hdr,new_desc,data_sector,partial_sectors,sequence","bs:0.011920452117919922,s:-0.01994335651397705,data:-0.012324750423431396,length:-0.03889596462249756,offset:-0.008836150169372559,buffer:-0.01998007297515869,merged_sector:-0.01540076732635498,data_tmp:-0.034247517585754395,sector_write:0.0034071803092956543,i:-0.014881789684295654,sector_offset:-0.11180770397186279,desc_sectors:-0.024441838264465332,sectors:-0.040331900119781494,total_length:-0.029230594635009766,aligned_length:-0.07777661085128784,file_offset:-0.10994845628738403,header:-0.043095290660858154,new_hdr:-0.017549514770507812,new_desc:0.0024462342262268066,data_sector:-0.006377875804901123,partial_sectors:-0.016576409339904785,sequence:0.006683826446533203,",2,17,"bs:bid,sequence:note,",Greedy,213,0.049590325355529784
231,"static void vmxnet3_net_uninit(VMXNET3State *s)

{

    g_free(s->mcast_list);

    vmxnet_tx_pkt_reset(s->tx_pkt);

    vmxnet_tx_pkt_uninit(s->tx_pkt);

    vmxnet_rx_pkt_uninit(s->rx_pkt);

    qemu_del_nic(s->nic);

}
",45,,1,0,,-4,s,,,,,Greedy,1,0.0022435386975606284
232,"static int http_prepare_data(HTTPContext *c)

{

    int i;



    switch(c->state) {

    case HTTPSTATE_SEND_DATA_HEADER:

        memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx));

        if (c->stream->feed) {

            /* open output stream by using specified codecs */

            c->fmt_ctx.oformat = c->stream->fmt;

            c->fmt_ctx.nb_streams = c->stream->nb_streams;

            for(i=0;i<c->fmt_ctx.nb_streams;i++) {

                AVStream *st;

                st = av_mallocz(sizeof(AVStream));

                c->fmt_ctx.streams[i] = st;

                if (c->stream->feed == c->stream)

                    memcpy(st, c->stream->streams[i], sizeof(AVStream));

                else

                    memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]], sizeof(AVStream));



                st->codec.frame_number = 0; /* XXX: should be done in

                                               AVStream, not in codec */

            }

            c->got_key_frame = 0;

        } else {

            /* open output stream by using codecs in specified file */

            c->fmt_ctx.oformat = c->stream->fmt;

            c->fmt_ctx.nb_streams = c->fmt_in->nb_streams;

            for(i=0;i<c->fmt_ctx.nb_streams;i++) {

                AVStream *st;

                st = av_mallocz(sizeof(AVStream));

                c->fmt_ctx.streams[i] = st;

                memcpy(st, c->fmt_in->streams[i], sizeof(AVStream));

                st->codec.frame_number = 0; /* XXX: should be done in

                                               AVStream, not in codec */

            }

            c->got_key_frame = 0;

        }

        init_put_byte(&c->fmt_ctx.pb, c->pbuffer, PACKET_MAX_SIZE,

                      1, c, NULL, http_write_packet, NULL);

        c->fmt_ctx.pb.is_streamed = 1;

        /* prepare header */

        av_write_header(&c->fmt_ctx);

        c->state = HTTPSTATE_SEND_DATA;

        c->last_packet_sent = 0;

        break;

    case HTTPSTATE_SEND_DATA:

        /* find a new packet */

#if 0

        fifo_total_size = http_fifo_write_count - c->last_http_fifo_write_count;

        if (fifo_total_size >= ((3 * FIFO_MAX_SIZE) / 4)) {

            /* overflow : resync. We suppose that wptr is at this

               point a pointer to a valid packet */

            c->rptr = http_fifo.wptr;

            c->got_key_frame = 0;

        }

        

        start_rptr = c->rptr;

        if (fifo_read(&http_fifo, (UINT8 *)&hdr, sizeof(hdr), &c->rptr) < 0)

            return 0;

        payload_size = ntohs(hdr.payload_size);

        payload = av_malloc(payload_size);

        if (fifo_read(&http_fifo, payload, payload_size, &c->rptr) < 0) {

            /* cannot read all the payload */

            av_free(payload);

            c->rptr = start_rptr;

            return 0;

        }

        

        c->last_http_fifo_write_count = http_fifo_write_count - 

            fifo_size(&http_fifo, c->rptr);

        

        if (c->stream->stream_type != STREAM_TYPE_MASTER) {

            /* test if the packet can be handled by this format */

            ret = 0;

            for(i=0;i<c->fmt_ctx.nb_streams;i++) {

                AVStream *st = c->fmt_ctx.streams[i];

                if (test_header(&hdr, &st->codec)) {

                    /* only begin sending when got a key frame */

                    if (st->codec.key_frame)

                        c->got_key_frame |= 1 << i;

                    if (c->got_key_frame & (1 << i)) {

                        ret = c->fmt_ctx.format->write_packet(&c->fmt_ctx, i,

                                                                   payload, payload_size);

                    }

                    break;

                }

            }

            if (ret) {

                /* must send trailer now */

                c->state = HTTPSTATE_SEND_DATA_TRAILER;

            }

        } else {

            /* master case : send everything */

            char *q;

            q = c->buffer;

            memcpy(q, &hdr, sizeof(hdr));

            q += sizeof(hdr);

            memcpy(q, payload, payload_size);

            q += payload_size;

            c->buffer_ptr = c->buffer;

            c->buffer_end = q;

        }

        av_free(payload);

#endif

        {

            AVPacket pkt;



            /* read a packet from the input stream */

            if (c->stream->feed) {

                ffm_set_write_index(c->fmt_in, 

                                    c->stream->feed->feed_write_index,

                                    c->stream->feed->feed_size);

            }

            

            if (av_read_packet(c->fmt_in, &pkt) < 0) {

                if (c->stream->feed && c->stream->feed->feed_opened) {

                    /* if coming from feed, it means we reached the end of the

                       ffm file, so must wait for more data */

                    c->state = HTTPSTATE_WAIT_FEED;

                    return 1; /* state changed */

                } else {

                    /* must send trailer now because eof or error */

                    c->state = HTTPSTATE_SEND_DATA_TRAILER;

                }

            } else {

                /* send it to the appropriate stream */

                if (c->stream->feed) {

                    /* if coming from a feed, select the right stream */

                    for(i=0;i<c->stream->nb_streams;i++) {

                        if (c->stream->feed_streams[i] == pkt.stream_index) {

                            pkt.stream_index = i;

                            if (pkt.flags & PKT_FLAG_KEY) {

                                c->got_key_frame |= 1 << i;

                            }

                            /* See if we have all the key frames, then 

                             * we start to send. This logic is not quite

                             * right, but it works for the case of a 

                             * single video stream with one or more

                             * audio streams (for which every frame is 

                             * typically a key frame). 

                             */

                            if (!c->stream->send_on_key || ((c->got_key_frame + 1) >> c->stream->nb_streams)) {

                                goto send_it;

                            }

                        }

                    }

                } else {

                    AVCodecContext *codec;

                send_it:

                    /* Fudge here */

                    codec = &c->fmt_ctx.streams[pkt.stream_index]->codec;



                    codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0);



#ifdef PJSG

                    if (codec->codec_type == CODEC_TYPE_AUDIO) {

                        codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000;

                        /* printf(""Calculated size %d, from sr %d, duration %d\n"", codec->frame_size, codec->sample_rate, pkt.duration); */

                    }

#endif



                    if (av_write_packet(&c->fmt_ctx, &pkt, 0))

                        c->state = HTTPSTATE_SEND_DATA_TRAILER;



                    codec->frame_number++;

                }



                av_free_packet(&pkt);

            }

        }

        break;

    default:

    case HTTPSTATE_SEND_DATA_TRAILER:

        /* last packet test ? */

        if (c->last_packet_sent)

            return -1;

        /* prepare header */

        av_write_trailer(&c->fmt_ctx);

        c->last_packet_sent = 1;

        break;

    }

    return 0;

}
",1029,"static int http_prepare_data(HTTPContext *cp)

{

    int i;



    switch(cp->state) {

    case HTTPSTATE_SEND_DATA_HEADER:

        memset(&cp->fmt_ctx, 0, sizeof(cp->fmt_ctx));

        if (cp->stream->feed) {

            /* open output stream by using specified codecs */

            cp->fmt_ctx.oformat = cp->stream->fmt;

            cp->fmt_ctx.nb_streams = cp->stream->nb_streams;

            for(i=0;i<cp->fmt_ctx.nb_streams;i++) {

                AVStream *st;

                st = av_mallocz(sizeof(AVStream));

                cp->fmt_ctx.streams[i] = st;

                if (cp->stream->feed == cp->stream)

                    memcpy(st, cp->stream->streams[i], sizeof(AVStream));

                else

                    memcpy(st, cp->stream->feed->streams[cp->stream->feed_streams[i]], sizeof(AVStream));



                st->codec.frame_number = 0; /* XXX: should be done in

                                               AVStream, not in codec */

            }

            cp->got_key_frame = 0;

        } else {

            /* open output stream by using codecs in specified file */

            cp->fmt_ctx.oformat = cp->stream->fmt;

            cp->fmt_ctx.nb_streams = cp->fmt_in->nb_streams;

            for(i=0;i<cp->fmt_ctx.nb_streams;i++) {

                AVStream *st;

                st = av_mallocz(sizeof(AVStream));

                cp->fmt_ctx.streams[i] = st;

                memcpy(st, cp->fmt_in->streams[i], sizeof(AVStream));

                st->codec.frame_number = 0; /* XXX: should be done in

                                               AVStream, not in codec */

            }

            cp->got_key_frame = 0;

        }

        init_put_byte(&cp->fmt_ctx.pb, cp->pbuffer, PACKET_MAX_SIZE,

                      1, cp, NULL, http_write_packet, NULL);

        cp->fmt_ctx.pb.is_streamed = 1;

        /* prepare header */

        av_write_header(&cp->fmt_ctx);

        cp->state = HTTPSTATE_SEND_DATA;

        cp->last_packet_sent = 0;

        break;

    case HTTPSTATE_SEND_DATA:

        /* find a new packet */

#if 0

        fifo_total_size = http_fifo_write_count - cp->last_http_fifo_write_count;

        if (fifo_total_size >= ((3 * FIFO_MAX_SIZE) / 4)) {

            /* overflow : resync. We suppose that wptr is at this

               point a pointer to a valid packet */

            cp->rptr = http_fifo.wptr;

            cp->got_key_frame = 0;

        }

        

        start_rptr = cp->rptr;

        if (fifo_read(&http_fifo, (UINT8 *)&hdr, sizeof(hdr), &cp->rptr) < 0)

            return 0;

        payload_size = ntohs(hdr.payload_size);

        payload = av_malloc(payload_size);

        if (fifo_read(&http_fifo, payload, payload_size, &cp->rptr) < 0) {

            /* cannot read all the payload */

            av_free(payload);

            cp->rptr = start_rptr;

            return 0;

        }

        

        cp->last_http_fifo_write_count = http_fifo_write_count - 

            fifo_size(&http_fifo, cp->rptr);

        

        if (cp->stream->stream_type != STREAM_TYPE_MASTER) {

            /* test if the packet can be handled by this format */

            ret = 0;

            for(i=0;i<cp->fmt_ctx.nb_streams;i++) {

                AVStream *st = cp->fmt_ctx.streams[i];

                if (test_header(&hdr, &st->codec)) {

                    /* only begin sending when got a key frame */

                    if (st->codec.key_frame)

                        cp->got_key_frame |= 1 << i;

                    if (cp->got_key_frame & (1 << i)) {

                        ret = cp->fmt_ctx.format->write_packet(&cp->fmt_ctx, i,

                                                                   payload, payload_size);

                    }

                    break;

                }

            }

            if (ret) {

                /* must send trailer now */

                cp->state = HTTPSTATE_SEND_DATA_TRAILER;

            }

        } else {

            /* master case : send everything */

            char *q;

            q = cp->buffer;

            memcpy(q, &hdr, sizeof(hdr));

            q += sizeof(hdr);

            memcpy(q, payload, payload_size);

            q += payload_size;

            cp->buffer_ptr = cp->buffer;

            cp->buffer_end = q;

        }

        av_free(payload);

#endif

        {

            AVPacket pkt;



            /* read a packet from the input stream */

            if (cp->stream->feed) {

                ffm_set_write_index(cp->fmt_in, 

                                    cp->stream->feed->feed_write_index,

                                    cp->stream->feed->feed_size);

            }

            

            if (av_read_packet(cp->fmt_in, &pkt) < 0) {

                if (cp->stream->feed && cp->stream->feed->feed_opened) {

                    /* if coming from feed, it means we reached the end of the

                       ffm file, so must wait for more data */

                    cp->state = HTTPSTATE_WAIT_FEED;

                    return 1; /* state changed */

                } else {

                    /* must send trailer now because eof or error */

                    cp->state = HTTPSTATE_SEND_DATA_TRAILER;

                }

            } else {

                /* send it to the appropriate stream */

                if (cp->stream->feed) {

                    /* if coming from a feed, select the right stream */

                    for(i=0;i<cp->stream->nb_streams;i++) {

                        if (cp->stream->feed_streams[i] == pkt.stream_index) {

                            pkt.stream_index = i;

                            if (pkt.flags & PKT_FLAG_KEY) {

                                cp->got_key_frame |= 1 << i;

                            }

                            /* See if we have all the key frames, then 

                             * we start to send. This logic is not quite

                             * right, but it works for the case of a 

                             * single video stream with one or more

                             * audio streams (for which every frame is 

                             * typically a key frame). 

                             */

                            if (!cp->stream->send_on_key || ((cp->got_key_frame + 1) >> cp->stream->nb_streams)) {

                                goto send_it;

                            }

                        }

                    }

                } else {

                    AVCodecContext *codec;

                send_it:

                    /* Fudge here */

                    codec = &cp->fmt_ctx.streams[pkt.stream_index]->codec;



                    codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0);



#ifdef PJSG

                    if (codec->codec_type == CODEC_TYPE_AUDIO) {

                        codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000;

                        /* printf(""Calculated size %d, from sr %d, duration %d
"", codec->frame_size, codec->sample_rate, pkt.duration); */

                    }

#endif



                    if (av_write_packet(&cp->fmt_ctx, &pkt, 0))

                        cp->state = HTTPSTATE_SEND_DATA_TRAILER;



                    codec->frame_number++;

                }



                av_free_packet(&pkt);

            }

        }

        break;

    default:

    case HTTPSTATE_SEND_DATA_TRAILER:

        /* last packet test ? */

        if (cp->last_packet_sent)

            return -1;

        /* prepare header */

        av_write_trailer(&cp->fmt_ctx);

        cp->last_packet_sent = 1;

        break;

    }

    return 0;

}
",1,1,0,1,"c,i,st,codec,frame_number","c:0.483466237783432,i:0.077068030834198,st:0.13389968872070312,codec:0.01476481556892395,frame_number:0.023932963609695435,",1,75,"c:cp,",Greedy,203,0.05247973998387655
233,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    if (!buffer->cmd) {

        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(buffer);

}
",42,,1,0,,-4,"port,buffer,buf",,,,,Greedy,1,0.0022795995076497397
234,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
",142,"CPUArchState *cpu_copy(CPUArchState *inet)

{

    CPUState *cpu = ENV_GET_CPU(inet);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new__conn = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new__conn, inet, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new__conn;

}
",1,1,0,1,"env,cpu,new_cpu,new_env,bp,wp","env:0.04932832717895508,cpu:0.031589388847351074,new_cpu:0.02887892723083496,new_env:0.06378519535064697,bp:0.01916426420211792,wp:0.007683813571929932,",2,6,"new_env:new__conn,env:inet,",Greedy,107,0.02260714371999105
235,"static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *src,

                                               int32_t src_stride,

                                               uint8_t *dst, int32_t dst_stride)

{

    int32_t loop_cnt;

    int16_t filt_const0 = 0xfb01;

    int16_t filt_const1 = 0x1414;

    int16_t filt_const2 = 0x1fb;

    v16u8 dst0, dst1, dst2, dst3;

    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;

    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;

    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;

    v16i8 src65_l, src87_l;

    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;

    v16i8 filt0, filt1, filt2;

    v16u8 res0, res1, res2, res3;



    filt0 = (v16i8) __msa_fill_h(filt_const0);

    filt1 = (v16i8) __msa_fill_h(filt_const1);

    filt2 = (v16i8) __msa_fill_h(filt_const2);



    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);

    src += (5 * src_stride);



    XORI_B5_128_SB(src0, src1, src2, src3, src4);

    ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,

               src10_r, src21_r, src32_r, src43_r);

    ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,

               src10_l, src21_l, src32_l, src43_l);



    for (loop_cnt = 4; loop_cnt--;) {

        LD_SB4(src, src_stride, src5, src6, src7, src8);

        src += (4 * src_stride);



        XORI_B4_128_SB(src5, src6, src7, src8);

        ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,

                   src54_r, src65_r, src76_r, src87_r);

        ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,

                   src54_l, src65_l, src76_l, src87_l);

        out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2);

        out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2);

        out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2);

        out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2);

        out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2);

        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);

        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);

        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);

        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);

        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);

        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);

        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);

        LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);

        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,

                    out3_r, res0, res1, res2, res3);

        XORI_B4_128_UB(res0, res1, res2, res3);

        AVER_UB4_UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3,

                    res0, res1, res2, res3);

        ST_UB4(res0, res1, res2, res3, dst, dst_stride);

        dst += (4 * dst_stride);



        src10_r = src54_r;

        src32_r = src76_r;

        src21_r = src65_r;

        src43_r = src87_r;

        src10_l = src54_l;

        src32_l = src76_l;

        src21_l = src65_l;

        src43_l = src87_l;

        src4 = src8;

    }

}
",684,"static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *img,

                                               int32_t src_divided,

                                               uint8_t *Dsrc, int32_t dst_brider)

{

    int32_t loop_cnt;

    int16_t filt_const0 = 0xfb01;

    int16_t filt_const1 = 0x1414;

    int16_t filt_const2 = 0x1fb;

    v16u8 dst0, madsrc4, drc02,  dsc6;

    v16i8 img2, source2, sort2, dist1, source2, reflect5, src6, reflect77, img88;

    v16i8 src10_R, src32ingright, src52_r, src74_r, src64_rs, src73_r, src65_r;

    v16i8 src87_w, src00_l, src52_r, src54_l, src56_l, src43_lp, src43_l;

    v16i8 src73_r, src87_l;

    v8i16 out0_r, out1_r, out4_l, out2_w, out10_l, out1_l, out2_l, out3_l;

    v16i8 fil1, flict3, felt2;

    v16u8 Res0, ras4, REStwo, Res1;



    fil1 = (v16i8) __msa_fill_h(filt_const0);

    flict3 = (v16i8) __msa_fill_h(filt_const1);

    felt2 = (v16i8) __msa_fill_h(filt_const2);



    LD_SB5(img, src_divided, img2, source2, sort2, dist1, source2);

    img += (5 * src_divided);



    XORI_B5_128_SB(img2, source2, sort2, dist1, source2);

    ILVR_B4_SB(source2, img2, sort2, source2, dist1, sort2, source2, dist1,

               src10_R, src64_rs, src32ingright, src73_r);

    ILVL_B4_SB(source2, img2, sort2, source2, dist1, sort2, source2, dist1,

               src00_l, src43_lp, src52_r, src43_l);



    for (loop_cnt = 4; loop_cnt--;) {

        LD_SB4(img, src_divided, reflect5, src6, reflect77, img88);

        img += (4 * src_divided);



        XORI_B4_128_SB(reflect5, src6, reflect77, img88);

        ILVR_B4_SB(reflect5, source2, src6, reflect5, reflect77, src6, img88, reflect77,

                   src52_r, src65_r, src74_r, src87_w);

        ILVL_B4_SB(reflect5, source2, src6, reflect5, reflect77, src6, img88, reflect77,

                   src54_l, src73_r, src56_l, src87_l);

        out0_r = DPADD_SH3_SH(src10_R, src32ingright, src52_r, fil1, flict3, felt2);

        out1_r = DPADD_SH3_SH(src64_rs, src73_r, src65_r, fil1, flict3, felt2);

        out4_l = DPADD_SH3_SH(src32ingright, src52_r, src74_r, fil1, flict3, felt2);

        out2_w = DPADD_SH3_SH(src73_r, src65_r, src87_w, fil1, flict3, felt2);

        out10_l = DPADD_SH3_SH(src00_l, src52_r, src54_l, fil1, flict3, felt2);

        out1_l = DPADD_SH3_SH(src43_lp, src43_l, src73_r, fil1, flict3, felt2);

        out2_l = DPADD_SH3_SH(src52_r, src54_l, src56_l, fil1, flict3, felt2);

        out3_l = DPADD_SH3_SH(src43_l, src73_r, src87_l, fil1, flict3, felt2);

        SRARI_H4_SH(out0_r, out1_r, out4_l, out2_w, 5);

        SRARI_H4_SH(out10_l, out1_l, out2_l, out3_l, 5);

        SAT_SH4_SH(out0_r, out1_r, out4_l, out2_w, 7);

        SAT_SH4_SH(out10_l, out1_l, out2_l, out3_l, 7);

        LD_UB4(Dsrc, dst_brider, dst0, madsrc4, drc02,  dsc6);

        PCKEV_B4_UB(out10_l, out0_r, out1_l, out1_r, out2_l, out4_l, out3_l,

                    out2_w, Res0, ras4, REStwo, Res1);

        XORI_B4_128_UB(Res0, ras4, REStwo, Res1);

        AVER_UB4_UB(Res0, dst0, ras4, madsrc4, REStwo, drc02, Res1,  dsc6,

                    Res0, ras4, REStwo, Res1);

        ST_UB4(Res0, ras4, REStwo, Res1, Dsrc, dst_brider);

        Dsrc += (4 * dst_brider);



        src10_R = src52_r;

        src32ingright = src74_r;

        src64_rs = src65_r;

        src73_r = src87_w;

        src00_l = src54_l;

        src52_r = src56_l;

        src43_lp = src73_r;

        src43_l = src87_l;

        source2 = img88;

    }

}
",0,0,0,-1,"src,src_stride,dst,dst_stride,loop_cnt,dst0,dst1,dst2,dst3,src0,src1,src2,src3,src4,src5,src6,src7,src8,src10_r,src32_r,src54_r,src76_r,src21_r,src43_r,src65_r,src87_r,src10_l,src32_l,src54_l,src76_l,src21_l,src43_l,src65_l,src87_l,out0_r,out1_r,out2_r,out3_r,out0_l,out1_l,out2_l,out3_l,filt0,filt1,filt2,res0,res1,res2,res3","src:-4.223501309752464e-05,src_stride:-8.672173134982586e-05,dst:-1.9885599613189697e-05,dst_stride:1.8748454749584198e-05,loop_cnt:-9.898049756884575e-05,dst0:-1.0412884876132011e-05,dst1:-3.268476575613022e-06,dst2:-9.619398042559624e-06,dst3:2.2989697754383087e-06,src0:-1.347297802567482e-05,src1:-1.1572381481528282e-05,src2:4.134373739361763e-06,src3:8.764443919062614e-06,src4:1.0945601388812065e-05,src5:-3.4549739211797714e-06,src6:-4.991656169295311e-06,src7:1.2460164725780487e-05,src8:1.5920959413051605e-06,src10_r:-2.937251701951027e-05,src32_r:-1.4761462807655334e-05,src54_r:-1.3326061889529228e-05,src76_r:-1.9573839381337166e-05,src21_r:-1.8638325855135918e-05,src43_r:-2.375640906393528e-05,src65_r:-1.5527941286563873e-05,src87_r:-2.4786219000816345e-05,src10_l:-1.6359379515051842e-05,src32_l:-9.832670912146568e-06,src54_l:-1.8331455066800117e-05,src76_l:-1.6081612557172775e-05,src21_l:-1.7531216144561768e-05,src43_l:-2.0001083612442017e-05,src65_l:-2.7511268854141235e-05,src87_l:-3.074482083320618e-05,out0_r:1.9168946892023087e-06,out1_r:-3.9830803871154785e-05,out2_r:-3.986293449997902e-05,out3_r:-4.0583545342087746e-05,out0_l:-3.0139228329062462e-05,out1_l:-4.3179839849472046e-05,out2_l:-4.4877175241708755e-05,out3_l:-4.200334660708904e-05,filt0:-4.7309789806604385e-05,filt1:-2.7364585548639297e-05,filt2:-1.1923490092158318e-05,res0:2.3619504645466805e-05,res1:-3.1846575438976288e-06,res2:-2.711080014705658e-06,res3:-5.276873707771301e-06,",37,203,"res0:Res0,dst_stride:dst_brider,src7:reflect77,src4:source2,src3:dist1,src2:sort2,dst3: dsc6,out0_r:out0_r,src8:img88,res2:REStwo,res1:ras4,dst1:madsrc4,src5:reflect5,src6:src6,res3:Res1,dst2:drc02,src32_l:src52_r,dst0:dst0,src1:source2,filt2:felt2,src54_r:src52_r,src0:img2,src32_r:src32ingright,src65_r:src65_r,src76_l:src56_l,src10_l:src00_l,src21_l:src43_lp,src54_l:src54_l,src21_r:src64_rs,src76_r:src74_r,dst:Dsrc,src43_l:src43_l,src43_r:src73_r,src87_r:src87_w,filt1:flict3,src65_l:src73_r,src10_r:src10_R,out0_l:out10_l,src87_l:src87_l,out1_r:out1_r,out2_r:out4_l,out3_r:out2_w,out3_l:out3_l,src:img,out1_l:out1_l,out2_l:out2_l,filt0:fil1,src_stride:src_divided,loop_cnt:loop_cnt,",Greedy,1022,0.30659327904383343
236,"static int net_socket_can_send(void *opaque)

{

    NetSocketState *s = opaque;



    return qemu_can_send_packet(&s->nc);

}
",25,"static int net_socket_can_send(void *opaques)

{

    NetSocketState *ses = opaques;



    return qemu_can_send_packet(&ses->nc);

}
",0,0,0,-1,"opaque,s","opaque:-0.0007270816713571548,s:-9.168777614831924e-05,",2,4,"s:ses,opaque:opaques,",Greedy,72,0.015755013624827067
237,"static void ppc_prep_init (ram_addr_t ram_size,

                           const char *boot_device,

                           const char *kernel_filename,

                           const char *kernel_cmdline,

                           const char *initrd_filename,

                           const char *cpu_model)

{

    CPUState *env = NULL;

    char *filename;

    nvram_t nvram;

    M48t59State *m48t59;

    int PPC_io_memory;

    int linux_boot, i, nb_nics1, bios_size;

    ram_addr_t ram_offset, bios_offset;

    uint32_t kernel_base, initrd_base;

    long kernel_size, initrd_size;

    PCIBus *pci_bus;

    qemu_irq *i8259;

    qemu_irq *cpu_exit_irq;

    int ppc_boot_device;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    DriveInfo *fd[MAX_FD];



    sysctrl = qemu_mallocz(sizeof(sysctrl_t));



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (cpu_model == NULL)

        cpu_model = ""602"";

    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""Unable to find PowerPC CPU definition\n"");

            exit(1);

        }

        if (env->flags & POWERPC_FLAG_RTC_CLK) {

            /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */

            cpu_ppc_tb_init(env, 7812500UL);

        } else {

            /* Set time-base frequency to 100 Mhz */

            cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);

        }

        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);

    }



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(NULL, ""ppc_prep.ram"", ram_size);

    cpu_register_physical_memory(0, ram_size, ram_offset);



    /* allocate and load BIOS */

    bios_offset = qemu_ram_alloc(NULL, ""ppc_prep.bios"", BIOS_SIZE);

    if (bios_name == NULL)

        bios_name = BIOS_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        bios_size = get_image_size(filename);

    } else {

        bios_size = -1;

    }

    if (bios_size > 0 && bios_size <= BIOS_SIZE) {

        target_phys_addr_t bios_addr;

        bios_size = (bios_size + 0xfff) & ~0xfff;

        bios_addr = (uint32_t)(-bios_size);

        cpu_register_physical_memory(bios_addr, bios_size,

                                     bios_offset | IO_MEM_ROM);

        bios_size = load_image_targphys(filename, bios_addr, bios_size);

    }

    if (bios_size < 0 || bios_size > BIOS_SIZE) {

        hw_error(""qemu: could not load PPC PREP bios '%s'\n"", bios_name);

    }

    if (filename) {

        qemu_free(filename);

    }



    if (linux_boot) {

        kernel_base = KERNEL_LOAD_ADDR;

        /* now we can load the kernel */

        kernel_size = load_image_targphys(kernel_filename, kernel_base,

                                          ram_size - kernel_base);

        if (kernel_size < 0) {

            hw_error(""qemu: could not load kernel '%s'\n"", kernel_filename);

            exit(1);

        }

        /* load initrd */

        if (initrd_filename) {

            initrd_base = INITRD_LOAD_ADDR;

            initrd_size = load_image_targphys(initrd_filename, initrd_base,

                                              ram_size - initrd_base);

            if (initrd_size < 0) {

                hw_error(""qemu: could not load initial ram disk '%s'\n"",

                          initrd_filename);

            }

        } else {

            initrd_base = 0;

            initrd_size = 0;

        }

        ppc_boot_device = 'm';

    } else {

        kernel_base = 0;

        kernel_size = 0;

        initrd_base = 0;

        initrd_size = 0;

        ppc_boot_device = '\0';

        /* For now, OHW cannot boot from the network. */

        for (i = 0; boot_device[i] != '\0'; i++) {

            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {

                ppc_boot_device = boot_device[i];

                break;

            }

        }

        if (ppc_boot_device == '\0') {

            fprintf(stderr, ""No valid boot device for Mac99 machine\n"");

            exit(1);

        }

    }



    isa_mem_base = 0xc0000000;

    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {

        hw_error(""Only 6xx bus is supported on PREP machine\n"");

    }

    i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);

    pci_bus = pci_prep_init(i8259);

    /* Hmm, prep has no pci-isa bridge ??? */

    isa_bus_new(NULL);

    isa_bus_irqs(i8259);

    //    pci_bus = i440fx_init();

    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */

    PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read,

                                           PPC_prep_io_write, sysctrl,

                                           DEVICE_LITTLE_ENDIAN);

    cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory);



    /* init basic PC hardware */

    pci_vga_init(pci_bus);

    //    openpic = openpic_init(0x00000000, 0xF0000000, 1);

    //    pit = pit_init(0x40, i8259[0]);

    rtc_init(2000, NULL);



    if (serial_hds[0])

        serial_isa_init(0, serial_hds[0]);

    nb_nics1 = nb_nics;

    if (nb_nics1 > NE2000_NB_MAX)

        nb_nics1 = NE2000_NB_MAX;

    for(i = 0; i < nb_nics1; i++) {

        if (nd_table[i].model == NULL) {

	    nd_table[i].model = qemu_strdup(""ne2k_isa"");

        }

        if (strcmp(nd_table[i].model, ""ne2k_isa"") == 0) {

            isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]);

        } else {

            pci_nic_init_nofail(&nd_table[i], ""ne2k_pci"", NULL);

        }

    }



    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus\n"");

        exit(1);

    }



    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);

    }



    for(i = 0; i < 1/*MAX_IDE_BUS*/; i++) {

        isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],

                     hd[2 * i],

		     hd[2 * i + 1]);

    }

    isa_create_simple(""i8042"");



    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);

    DMA_init(1, cpu_exit_irq);



    //    SB16_init();



    for(i = 0; i < MAX_FD; i++) {

        fd[i] = drive_get(IF_FLOPPY, 0, i);

    }

    fdctrl_init_isa(fd);



    /* Register speaker port */

    register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL);

    register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL);

    /* Register fake IO ports for PREP */

    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];

    register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl);

    register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl);

    /* System control ports */

    register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl);

    register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl);

    register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl);

    register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl);

    /* PCI intack location */

    PPC_io_memory = cpu_register_io_memory(PPC_intack_read,

                                           PPC_intack_write, NULL,

                                           DEVICE_LITTLE_ENDIAN);

    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);

    /* PowerPC control and status register group */

#if 0

    PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write,

                                           NULL, DEVICE_LITTLE_ENDIAN);

    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);

#endif



    if (usb_enabled) {

        usb_ohci_init_pci(pci_bus, -1);

    }



    m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59);

    if (m48t59 == NULL)

        return;

    sysctrl->nvram = m48t59;



    /* Initialise NVRAM */

    nvram.opaque = m48t59;

    nvram.read_fn = &m48t59_read;

    nvram.write_fn = &m48t59_write;

    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, ""PREP"", ram_size, ppc_boot_device,

                         kernel_base, kernel_size,

                         kernel_cmdline,

                         initrd_base, initrd_size,

                         /* XXX: need an option to load a NVRAM image */

                         0,

                         graphic_width, graphic_height, graphic_depth);



    /* Special port to get debug messages from Open-Firmware */

    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);

}
",1238,"static void ppc_prep_init (ram_addr_t ram_size,

                           const char *boot_device,

                           const char *kernel_filename,

                           const char *kernel_cmdline,

                           const char *initrd_filename,

                           const char *core_serial)

{

    CPUState *err = NULL;

    char *filename;

    nvram_t nvram;

    M48t59State *m48t59;

    int PPC_io_memory;

    int linux_boot, i, nb_nics1, bios_size;

    ram_addr_t ram_offset, bios_offset;

    uint32_t kernel_base, initrd_base;

    long kernel_size, initrd_size;

    PCIBus *pci_bus;

    qemu_irq *m8288;

    qemu_irq *cpu_exit_irq;

    int ppc_boot_device;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    DriveInfo *fd[MAX_FD];



    sysctrl = qemu_mallocz(sizeof(sysctrl_t));



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (core_serial == NULL)

        core_serial = ""602"";

    for (i = 0; i < smp_cpus; i++) {

        err = cpu_init(core_serial);

        if (!err) {

            fprintf(stderr, ""Unable to find PowerPC CPU definition
"");

            exit(1);

        }

        if (err->flags & POWERPC_FLAG_RTC_CLK) {

            /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */

            cpu_ppc_tb_init(err, 7812500UL);

        } else {

            /* Set time-base frequency to 100 Mhz */

            cpu_ppc_tb_init(err, 100UL * 1000UL * 1000UL);

        }

        qemu_register_reset((QEMUResetHandler*)&cpu_reset, err);

    }



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(NULL, ""ppc_prep.ram"", ram_size);

    cpu_register_physical_memory(0, ram_size, ram_offset);



    /* allocate and load BIOS */

    bios_offset = qemu_ram_alloc(NULL, ""ppc_prep.bios"", BIOS_SIZE);

    if (bios_name == NULL)

        bios_name = BIOS_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        bios_size = get_image_size(filename);

    } else {

        bios_size = -1;

    }

    if (bios_size > 0 && bios_size <= BIOS_SIZE) {

        target_phys_addr_t bios_addr;

        bios_size = (bios_size + 0xfff) & ~0xfff;

        bios_addr = (uint32_t)(-bios_size);

        cpu_register_physical_memory(bios_addr, bios_size,

                                     bios_offset | IO_MEM_ROM);

        bios_size = load_image_targphys(filename, bios_addr, bios_size);

    }

    if (bios_size < 0 || bios_size > BIOS_SIZE) {

        hw_error(""qemu: could not load PPC PREP bios '%s'
"", bios_name);

    }

    if (filename) {

        qemu_free(filename);

    }



    if (linux_boot) {

        kernel_base = KERNEL_LOAD_ADDR;

        /* now we can load the kernel */

        kernel_size = load_image_targphys(kernel_filename, kernel_base,

                                          ram_size - kernel_base);

        if (kernel_size < 0) {

            hw_error(""qemu: could not load kernel '%s'
"", kernel_filename);

            exit(1);

        }

        /* load initrd */

        if (initrd_filename) {

            initrd_base = INITRD_LOAD_ADDR;

            initrd_size = load_image_targphys(initrd_filename, initrd_base,

                                              ram_size - initrd_base);

            if (initrd_size < 0) {

                hw_error(""qemu: could not load initial ram disk '%s'
"",

                          initrd_filename);

            }

        } else {

            initrd_base = 0;

            initrd_size = 0;

        }

        ppc_boot_device = 'm';

    } else {

        kernel_base = 0;

        kernel_size = 0;

        initrd_base = 0;

        initrd_size = 0;

        ppc_boot_device = '\0';

        /* For now, OHW cannot boot from the network. */

        for (i = 0; boot_device[i] != '\0'; i++) {

            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {

                ppc_boot_device = boot_device[i];

                break;

            }

        }

        if (ppc_boot_device == '\0') {

            fprintf(stderr, ""No valid boot device for Mac99 machine
"");

            exit(1);

        }

    }



    isa_mem_base = 0xc0000000;

    if (PPC_INPUT(err) != PPC_FLAGS_INPUT_6xx) {

        hw_error(""Only 6xx bus is supported on PREP machine
"");

    }

    m8288 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);

    pci_bus = pci_prep_init(m8288);

    /* Hmm, prep has no pci-isa bridge ??? */

    isa_bus_new(NULL);

    isa_bus_irqs(m8288);

    //    pci_bus = i440fx_init();

    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */

    PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read,

                                           PPC_prep_io_write, sysctrl,

                                           DEVICE_LITTLE_ENDIAN);

    cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory);



    /* init basic PC hardware */

    pci_vga_init(pci_bus);

    //    openpic = openpic_init(0x00000000, 0xF0000000, 1);

    //    pit = pit_init(0x40, i8259[0]);

    rtc_init(2000, NULL);



    if (serial_hds[0])

        serial_isa_init(0, serial_hds[0]);

    nb_nics1 = nb_nics;

    if (nb_nics1 > NE2000_NB_MAX)

        nb_nics1 = NE2000_NB_MAX;

    for(i = 0; i < nb_nics1; i++) {

        if (nd_table[i].model == NULL) {

	    nd_table[i].model = qemu_strdup(""ne2k_isa"");

        }

        if (strcmp(nd_table[i].model, ""ne2k_isa"") == 0) {

            isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]);

        } else {

            pci_nic_init_nofail(&nd_table[i], ""ne2k_pci"", NULL);

        }

    }



    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus
"");

        exit(1);

    }



    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);

    }



    for(i = 0; i < 1/*MAX_IDE_BUS*/; i++) {

        isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],

                     hd[2 * i],

		     hd[2 * i + 1]);

    }

    isa_create_simple(""i8042"");



    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);

    DMA_init(1, cpu_exit_irq);



    //    SB16_init();



    for(i = 0; i < MAX_FD; i++) {

        fd[i] = drive_get(IF_FLOPPY, 0, i);

    }

    fdctrl_init_isa(fd);



    /* Register speaker port */

    register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL);

    register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL);

    /* Register fake IO ports for PREP */

    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];

    register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl);

    register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl);

    /* System control ports */

    register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl);

    register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl);

    register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl);

    register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl);

    /* PCI intack location */

    PPC_io_memory = cpu_register_io_memory(PPC_intack_read,

                                           PPC_intack_write, NULL,

                                           DEVICE_LITTLE_ENDIAN);

    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);

    /* PowerPC control and status register group */

#if 0

    PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write,

                                           NULL, DEVICE_LITTLE_ENDIAN);

    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);

#endif



    if (usb_enabled) {

        usb_ohci_init_pci(pci_bus, -1);

    }



    m48t59 = m48t59_init(m8288[8], 0, 0x0074, NVRAM_SIZE, 59);

    if (m48t59 == NULL)

        return;

    sysctrl->nvram = m48t59;



    /* Initialise NVRAM */

    nvram.opaque = m48t59;

    nvram.read_fn = &m48t59_read;

    nvram.write_fn = &m48t59_write;

    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, ""PREP"", ram_size, ppc_boot_device,

                         kernel_base, kernel_size,

                         kernel_cmdline,

                         initrd_base, initrd_size,

                         /* XXX: need an option to load a NVRAM image */

                         0,

                         graphic_width, graphic_height, graphic_depth);



    /* Special port to get debug messages from Open-Firmware */

    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);

}
",0,0,1,1,"ram_size,boot_device,kernel_filename,kernel_cmdline,initrd_filename,cpu_model,env,filename,nvram,m48t59,PPC_io_memory,linux_boot,i,nb_nics1,bios_size,ram_offset,bios_offset,kernel_base,initrd_base,kernel_size,initrd_size,pci_bus,i8259,cpu_exit_irq,ppc_boot_device,hd,MAX_IDE_BUS,MAX_IDE_DEVS,fd,MAX_FD","ram_size:0.026865720748901367,boot_device:0.024535387754440308,kernel_filename:0.049934595823287964,kernel_cmdline:-0.006670355796813965,initrd_filename:-0.006153881549835205,cpu_model:0.05668836832046509,env:0.1585407257080078,filename:0.051761120557785034,nvram:0.021061718463897705,m48t59:0.005529612302780151,PPC_io_memory:-0.014379024505615234,linux_boot:0.03696584701538086,i:0.05657193064689636,nb_nics1:-0.006048470735549927,bios_size:0.008296579122543335,ram_offset:0.02649715542793274,bios_offset:0.019134163856506348,kernel_base:0.015523850917816162,initrd_base:0.0014958381652832031,kernel_size:0.0026311874389648438,initrd_size:-0.006684303283691406,pci_bus:0.01979273557662964,i8259:0.061644047498703,cpu_exit_irq:-0.022361457347869873,ppc_boot_device:-0.030874788761138916,hd:-0.011258363723754883,MAX_IDE_BUS:-0.009690403938293457,MAX_IDE_DEVS:-0.025008708238601685,fd:-0.028452903032302856,MAX_FD:-0.01918548345565796,",3,17,"env:err,i8259:m8288,cpu_model:core_serial,",Greedy,298,0.08617800076802572
238,"static void copy_picture_field(InterlaceContext *s,

                               AVFrame *src_frame, AVFrame *dst_frame,

                               AVFilterLink *inlink, enum FieldType field_type,

                               int lowpass)

{

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);

    int hsub = desc->log2_chroma_w;

    int vsub = desc->log2_chroma_h;

    int plane, j;



    for (plane = 0; plane < desc->nb_components; plane++) {

        int cols  = (plane == 1 || plane == 2) ? -(-inlink->w) >> hsub : inlink->w;

        int lines = (plane == 1 || plane == 2) ? -(-inlink->h) >> vsub : inlink->h;

        uint8_t *dstp = dst_frame->data[plane];

        const uint8_t *srcp = src_frame->data[plane];



        av_assert0(cols >= 0 || lines >= 0);



        lines = (lines + (field_type == FIELD_UPPER)) / 2;

        if (field_type == FIELD_LOWER)

            srcp += src_frame->linesize[plane];

        if (field_type == FIELD_LOWER)

            dstp += dst_frame->linesize[plane];

        if (lowpass) {

            int srcp_linesize = src_frame->linesize[plane] * 2;

            int dstp_linesize = dst_frame->linesize[plane] * 2;

            for (j = lines; j > 0; j--) {

                const uint8_t *srcp_above = srcp - src_frame->linesize[plane];

                const uint8_t *srcp_below = srcp + src_frame->linesize[plane];

                if (j == lines)

                    srcp_above = srcp; // there is no line above

                if (j == 1)

                    srcp_below = srcp; // there is no line below

                s->lowpass_line(dstp, cols, srcp, srcp_above, srcp_below);

                dstp += dstp_linesize;

                srcp += srcp_linesize;

            }

        } else {

            av_image_copy_plane(dstp, dst_frame->linesize[plane] * 2,

                                srcp, src_frame->linesize[plane] * 2,

                                cols, lines);

        }

    }

}
",357,,0,1,,-4,"s,src_frame,dst_frame,inlink,field_type,lowpass,desc,plane,j,dstp,srcp,srcp_above,srcp_below",,,,,Greedy,1,0.0022508939107259113
239,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
",23,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *enable)

{

    check_hwrena(enable, 0);

    return enable->CP0_EBase & 0x3ff;

}
",1,1,0,1,env,"env:0.3977678045630455,",1,3,"env:enable,",Greedy,56,0.012286651134490966
240,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#elif defined(TARGET_S390X)

    CPUState *cs;

    S390CPU *cpu;



    CPU_FOREACH(cs) {

        cpu = S390_CPU(cs);

        if (cpu->env.cpu_num == monitor_get_cpu_index()) {

            if (s390_cpu_restart(S390_CPU(cs)) == -1) {

                error_set(errp, QERR_UNSUPPORTED);

                return;

            }

            break;

        }

    }

#else

    error_set(errp, QERR_UNSUPPORTED);

#endif

}
",136,,1,0,,-4,"errp,cs,cpu",,,,,Greedy,1,0.0024450222651163736
241,"void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(env, 1);

    env->dr[6] |= DR6_BS;

#endif

    raise_exception(env, EXCP01_DB);

}
",35,,1,0,,-4,env,,,,,Greedy,1,0.002214153607686361
242,"static av_always_inline void rv40_weak_loop_filter(uint8_t *src,

                                                   const int step,

                                                   const int stride,

                                                   const int filter_p1,

                                                   const int filter_q1,

                                                   const int alpha,

                                                   const int beta,

                                                   const int lim_p0q0,

                                                   const int lim_q1,

                                                   const int lim_p1)

{

    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;

    int i, t, u, diff;



    for (i = 0; i < 4; i++, src += stride) {

        int diff_p1p0 = src[-2*step] - src[-1*step];

        int diff_q1q0 = src[ 1*step] - src[ 0*step];

        int diff_p1p2 = src[-2*step] - src[-3*step];

        int diff_q1q2 = src[ 1*step] - src[ 2*step];



        t = src[0*step] - src[-1*step];

        if (!t)

            continue;



        u = (alpha * FFABS(t)) >> 7;

        if (u > 3 - (filter_p1 && filter_q1))

            continue;



        t <<= 2;

        if (filter_p1 && filter_q1)

            t += src[-2*step] - src[1*step];



        diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);

        src[-1*step] = cm[src[-1*step] + diff];

        src[ 0*step] = cm[src[ 0*step] - diff];



        if (filter_p1 && FFABS(diff_p1p2) <= beta) {

            t = (diff_p1p0 + diff_p1p2 - diff) >> 1;

            src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];

        }



        if (filter_q1 && FFABS(diff_q1q2) <= beta) {

            t = (diff_q1q0 + diff_q1q2 + diff) >> 1;

            src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];

        }

    }

}
",378,,1,0,,-4,"src,step,stride,filter_p1,filter_q1,alpha,beta,lim_p0q0,lim_q1,lim_p1,cm,i,t,u,diff",,,,,Greedy,1,0.0022958000500996906
243,"static void con_disconnect(struct XenDevice *xendev)

{

    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);



    if (con->chr) {

        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);

        qemu_chr_fe_release(con->chr);

    }

    xen_be_unbind_evtchn(&con->xendev);



    if (con->sring) {

        if (!xendev->dev) {

            munmap(con->sring, XC_PAGE_SIZE);

        } else {

            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);

        }

        con->sring = NULL;

    }

}
",112,"static void con_disconnect(struct XenDevice *xendev)

{

    struct XenConsole *cr = container_of(xendev, struct XenConsole, xendev);



    if (cr->chr) {

        qemu_chr_add_handlers(cr->chr, NULL, NULL, NULL, NULL);

        qemu_chr_fe_release(cr->chr);

    }

    xen_be_unbind_evtchn(&cr->xendev);



    if (cr->sring) {

        if (!xendev->dev) {

            munmap(cr->sring, XC_PAGE_SIZE);

        } else {

            xengnttab_unmap(xendev->gnttabdev, cr->sring, 1);

        }

        cr->sring = NULL;

    }

}
",1,1,0,1,"xendev,con","xendev:-0.16032154113054276,con:0.8605708330869675,",1,9,"con:cr,",Greedy,80,0.015938822428385416
244,"static int normalize_bits(int num, int width)

{

    if (!num)

        return 0;

    if (num == -1)

        return width;

    if (num < 0)

        num = ~num;



    return width - av_log2(num);

}
",48,"static int normalize_bits(int umi, int width)

{

    if (!umi)

        return 0;

    if (umi == -1)

        return width;

    if (umi < 0)

        umi = ~umi;



    return width - av_log2(umi);

}
",1,1,1,-1,num,"num:-0.011995136737823486,",1,7,"num:umi,",Greedy,71,0.01414862871170044
245,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->realize = xen_pt_realize;

    k->exit = xen_pt_unregister_device;

    k->config_read = xen_pt_pci_read_config;

    k->config_write = xen_pt_pci_write_config;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->desc = ""Assign an host PCI device with Xen"";

    dc->props = xen_pci_passthrough_properties;

};",79,"static void xen_pci_passthrough_class_init(ObjectClass *class, void *info)

{

    DeviceClass *draw = DEVICE_CLASS(class);

    PCIDeviceClass *u = PCI_DEVICE_CLASS(class);



    u->realize = xen_pt_realize;

    u->exit = xen_pt_unregister_device;

    u->config_read = xen_pt_pci_read_config;

    u->config_write = xen_pt_pci_write_config;


    set_bit(DEVICE_CATEGORY_MISC, draw->categories);

    draw->desc = ""Assign an host PCI device with Xen"";

    draw->props = xen_pci_passthrough_properties;

};",1,1,1,-1,"klass,data,dc,k","klass:0.039867937564849854,data:0.0014380812644958496,dc:-0.0008699297904968262,k:0.053315043449401855,",4,13,"k:u,klass:class,data:info,dc:draw,",Greedy,158,0.03200112581253052
246,"static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    ohci);



    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);

        ohci_die(ohci);

        return 0;

    }



    trace_usb_ohci_start(ohci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
",63,,1,0,,-4,ohci,,,,,Greedy,1,0.0022155404090881347
247,"void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,

                                   ImageInfoSpecific *info_spec)

{

    QObject *obj, *data;

    Visitor *v = qmp_output_visitor_new(&obj);



    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);

    visit_complete(v, &obj);

    assert(qobject_type(obj) == QTYPE_QDICT);

    data = qdict_get(qobject_to_qdict(obj), ""data"");

    dump_qobject(func_fprintf, f, 1, data);


    visit_free(v);

}",93,,1,0,,-4,"func_fprintf,f,info_spec,obj,data,v",,,,,Greedy,1,0.002189199129740397
248,"static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (avpkt->size <= 0)

        return avpkt->size;



    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return avpkt->size;

}
",216,,0,1,,-4,"avctx,data,got_sub_ptr,avpkt,sub,buffer,size,ret,p,s",,,,,Greedy,1,0.002187637488047282
249,"static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)

{

    YADIFContext *s = ctx->priv;

    ThreadData *td  = arg;

    int refs = s->cur->linesize[td->plane];

    int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8;

    int pix_3 = 3 * df;

    int slice_h = td->h / nb_jobs;

    int slice_start = jobnr * slice_h;

    int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;

    int y;



    /* filtering reads 3 pixels to the left/right; to avoid invalid reads,

     * we need to call the c variant which avoids this for border pixels

     */

    for (y = slice_start; y < slice_end; y++) {

        if ((y ^ td->parity) & 1) {

            uint8_t *prev = &s->prev->data[td->plane][y * refs];

            uint8_t *cur  = &s->cur ->data[td->plane][y * refs];

            uint8_t *next = &s->next->data[td->plane][y * refs];

            uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];

            int     mode  = y == 1 || y + 2 == td->h ? 2 : s->mode;

            s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3,

                           next + pix_3, td->w - 6,

                           y + 1 < td->h ? refs : -refs,

                           y ? -refs : refs,

                           td->parity ^ td->tff, mode);

            s->filter_edges(dst, prev, cur, next, td->w,

                            y + 1 < td->h ? refs : -refs,

                            y ? -refs : refs,

                            td->parity ^ td->tff, mode);

        } else {

            memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],

                   &s->cur->data[td->plane][y * refs], td->w * df);

        }

    }

    return 0;

}
",424,,1,0,,-4,"ctx,arg,jobnr,nb_jobs,s,td,y,prev,cur,next,dst",,,,,Greedy,1,0.0022486011187235516
250,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

{

    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        exit(1);

    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);

    }

}
",53,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *mac, vaddr aceDr, int rawxx,

                              int mmu_itv)

{

    if (ppc64_radix_guest(mac)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        exit(1);

    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(mac, aceDr, rawxx, mmu_itv);

    }

}
",0,0,0,-1,"cpu,eaddr,rwx,mmu_idx","cpu:-0.04927752912044525,eaddr:-0.0022704899311065674,rwx:0.024452097713947296,mmu_idx:-0.10332618840038776,",4,9,"rwx:rawxx,eaddr:aceDr,cpu:mac,mmu_idx:mmu_itv,",Greedy,128,0.026733227570851645
251,"int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

    VideoDemuxData *s = s1->priv_data;

    char filename_bytes[1024];

    char *filename = filename_bytes;

    int i;

    int size[3]           = { 0 }, ret[3] = { 0 };

    AVIOContext *f[3]     = { NULL };

    AVCodecContext *codec = s1->streams[0]->codec;



    if (!s->is_pipe) {

        /* loop over input */

        if (s->loop && s->img_number > s->img_last) {

            s->img_number = s->img_first;

        }

        if (s->img_number > s->img_last)

            return AVERROR_EOF;

        if (s->use_glob) {

#if HAVE_GLOB

            filename = s->globstate.gl_pathv[s->img_number];

#endif

        } else {

        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),

                                  s->path,

                                  s->img_number) < 0 && s->img_number > 1)

            return AVERROR(EIO);

        }

        for (i = 0; i < 3; i++) {

            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,

                           &s1->interrupt_callback, NULL) < 0) {

                if (i >= 1)

                    break;

                av_log(s1, AV_LOG_ERROR, ""Could not open file : %s\n"",

                       filename);

                return AVERROR(EIO);

            }

            size[i] = avio_size(f[i]);



            if (!s->split_planes)

                break;

            filename[strlen(filename) - 1] = 'U' + i;

        }



        if (codec->codec_id == AV_CODEC_ID_NONE) {

            AVProbeData pd;

            AVInputFormat *ifmt;

            uint8_t header[PROBE_BUF_MIN + AVPROBE_PADDING_SIZE];

            int ret;

            int score = 0;



            ret = avio_read(f[0], header, PROBE_BUF_MIN);

            if (ret < 0)

                return ret;


            avio_skip(f[0], -ret);

            pd.buf = header;

            pd.buf_size = ret;

            pd.filename = filename;



            ifmt = av_probe_input_format3(&pd, 1, &score);

            if (ifmt && ifmt->read_packet == ff_img_read_packet && ifmt->raw_codec_id)

                codec->codec_id = ifmt->raw_codec_id;

        }



        if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)

            infer_size(&codec->width, &codec->height, size[0]);

    } else {

        f[0] = s1->pb;

        if (url_feof(f[0]))

            return AVERROR(EIO);

        if (s->frame_size > 0) {

            size[0] = s->frame_size;

        } else {

            size[0] = 4096;

        }

    }



    if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0)

        return AVERROR(ENOMEM);

    pkt->stream_index = 0;

    pkt->flags       |= AV_PKT_FLAG_KEY;

    if (s->ts_from_file) {

        struct stat img_stat;

        if (stat(filename, &img_stat))

            return AVERROR(EIO);

        pkt->pts = (int64_t)img_stat.st_mtime;

        av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME);

    } else if (!s->is_pipe) {

        pkt->pts      = s->pts;

    }



    pkt->size = 0;

    for (i = 0; i < 3; i++) {

        if (f[i]) {

            ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]);

            if (!s->is_pipe)

                avio_close(f[i]);

            if (ret[i] > 0)

                pkt->size += ret[i];

        }

    }



    if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) {

        av_free_packet(pkt);

        return AVERROR(EIO); /* signal EOF */

    } else {

        s->img_count++;

        s->img_number++;

        s->pts++;

        return 0;

    }

}",768,,1,0,,-4,"s1,pkt,s,filename_bytes,filename,i,size,ret,f,codec,pd,ifmt,header,img_number",,,,,Greedy,1,0.0025492111841837564
252,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)

{

    IDEBus *bus = opaque;

    IDEState *s = idebus_active_if(bus);

    uint8_t *p;



    /* PIO data access allowed only when DRQ bit is set */

    if (!(s->status & DRQ_STAT))

        return;



    p = s->data_ptr;

    *(uint16_t *)p = le16_to_cpu(val);

    p += 2;

    s->data_ptr = p;

    if (p >= s->data_end)

        s->end_transfer_func(s);

}
",90,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)

{

    IDEBus *bus = opaque;

    IDEState *state = idebus_active_if(bus);

    uint8_t *cp;



    /* PIO data access allowed only when DRQ bit is set */

    if (!(state->status & DRQ_STAT))

        return;



    cp = state->data_ptr;

    *(uint16_t *)cp = le16_to_cpu(val);

    cp += 2;

    state->data_ptr = cp;

    if (cp >= state->data_end)

        state->end_transfer_func(state);

}
",1,1,0,1,"opaque,addr,val,bus,s,p","opaque:0.0980883538722992,addr:0.09195363521575928,val:0.0255468487739563,bus:-0.018857866525650024,s:0.31241025030612946,p:0.23302730917930603,",2,13,"s:state,p:cp,",Greedy,135,0.024585926532745363
253,"static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,

                                                     PutBitContext *pb, const float *in, float *out,

                                                     const float *scaled, int size, int scale_idx,

                                                     int cb, const float lambda, const float uplim,

                                                     int *bits, const float ROUNDING)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    int qc1, qc2, qc3, qc4;



    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];

    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];

    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];



    abs_pow34_v(s->scoefs, in, size);

    scaled = s->scoefs;

    for (i = 0; i < size; i += 4) {

        int curidx, curidx2;

        int *in_int = (int *)&in[i];

        uint8_t v_bits;

        unsigned int v_codes;

        int t0, t1, t2, t3, t4, t5, t6, t7;

        const float *vec1, *vec2;



        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                      \n\t""

            "".set noreorder                 \n\t""



            ""ori    %[t4],  $zero,  4       \n\t""

            ""slt    %[t0],  %[t4],  %[qc1]  \n\t""

            ""slt    %[t1],  %[t4],  %[qc2]  \n\t""

            ""slt    %[t2],  %[t4],  %[qc3]  \n\t""

            ""slt    %[t3],  %[t4],  %[qc4]  \n\t""

            ""movn   %[qc1], %[t4],  %[t0]   \n\t""

            ""movn   %[qc2], %[t4],  %[t1]   \n\t""

            ""movn   %[qc3], %[t4],  %[t2]   \n\t""

            ""movn   %[qc4], %[t4],  %[t3]   \n\t""

            ""lw     %[t0],  0(%[in_int])    \n\t""

            ""lw     %[t1],  4(%[in_int])    \n\t""

            ""lw     %[t2],  8(%[in_int])    \n\t""

            ""lw     %[t3],  12(%[in_int])   \n\t""

            ""srl    %[t0],  %[t0],  31      \n\t""

            ""srl    %[t1],  %[t1],  31      \n\t""

            ""srl    %[t2],  %[t2],  31      \n\t""

            ""srl    %[t3],  %[t3],  31      \n\t""

            ""subu   %[t4],  $zero,  %[qc1]  \n\t""

            ""subu   %[t5],  $zero,  %[qc2]  \n\t""

            ""subu   %[t6],  $zero,  %[qc3]  \n\t""

            ""subu   %[t7],  $zero,  %[qc4]  \n\t""

            ""movn   %[qc1], %[t4],  %[t0]   \n\t""

            ""movn   %[qc2], %[t5],  %[t1]   \n\t""

            ""movn   %[qc3], %[t6],  %[t2]   \n\t""

            ""movn   %[qc4], %[t7],  %[t3]   \n\t""



            "".set pop                       \n\t""



            : [qc1]""+r""(qc1), [qc2]""+r""(qc2),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [t0]""=&r""(t0), [t1]""=&r""(t1), [t2]""=&r""(t2), [t3]""=&r""(t3),

              [t4]""=&r""(t4), [t5]""=&r""(t5), [t6]""=&r""(t6), [t7]""=&r""(t7)

            : [in_int]""r""(in_int)

            : ""memory""

        );



        curidx = 9 * qc1;

        curidx += qc2 + 40;



        curidx2 = 9 * qc3;

        curidx2 += qc4 + 40;



        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);

        v_bits  = p_bits[curidx] + p_bits[curidx2];

        put_bits(pb, v_bits, v_codes);



        if (out) {

           vec1 = &p_vec[curidx*2 ];

           vec2 = &p_vec[curidx2*2];

           out[i+0] = vec1[0] * IQ;

           out[i+1] = vec1[1] * IQ;

           out[i+2] = vec2[0] * IQ;

           out[i+3] = vec2[1] * IQ;

        }

    }

}
",645,"static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *conf,

                                                     PutBitContext *bps, const float *pin, float *cmd,

                                                     const float *scaling, int sh, int scale_idsz,

                                                     int code, const float  disp, const float uplib,

                                                     int *hours, const float BOUNDED)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idsz + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idsz - SCALE_ONE_POS + SCALE_DIV_512];

    int uri;

    int qc5, qac4, qp8, qlc8;



    uint8_t  *p_bit  = (uint8_t  *)ff_aac_spectral_bits[code-1];

    uint16_t *p_code = (uint16_t *)ff_aac_spectral_codes[code-1];

    float    *pvvec   = (float    *)ff_aac_codebook_vectors[code-1];



    abs_pow34_v(conf->scoefs, pin, sh);

    scaling = conf->scoefs;

    for (uri = 0; uri < sh; uri += 4) {

        int curridex, curIdx1;

        int * in_bit = (int *)&pin[uri];

        uint8_t p_bytes;

        unsigned int v_code;

        int ta0, t1, T22, Tthree,  t8, t5,  t8, at729;

        const float *vec3, *cv2;



        qc5 = scaling[uri  ] * Q34 + ROUND_STANDARD;

        qac4 = scaling[uri+1] * Q34 + ROUND_STANDARD;

        qp8 = scaling[uri+2] * Q34 + ROUND_STANDARD;

        qlc8 = scaling[uri+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                      
\t""

            "".set noreorder                 
\t""



            ""ori    %[t4],  $zero,  4       
\t""

            ""slt    %[t0],  %[t4],  %[qc1]  
\t""

            ""slt    %[t1],  %[t4],  %[qc2]  
\t""

            ""slt    %[t2],  %[t4],  %[qc3]  
\t""

            ""slt    %[t3],  %[t4],  %[qc4]  
\t""

            ""movn   %[qc1], %[t4],  %[t0]   
\t""

            ""movn   %[qc2], %[t4],  %[t1]   
\t""

            ""movn   %[qc3], %[t4],  %[t2]   
\t""

            ""movn   %[qc4], %[t4],  %[t3]   
\t""

            ""lw     %[t0],  0(%[in_int])    
\t""

            ""lw     %[t1],  4(%[in_int])    
\t""

            ""lw     %[t2],  8(%[in_int])    
\t""

            ""lw     %[t3],  12(%[in_int])   
\t""

            ""srl    %[t0],  %[t0],  31      
\t""

            ""srl    %[t1],  %[t1],  31      
\t""

            ""srl    %[t2],  %[t2],  31      
\t""

            ""srl    %[t3],  %[t3],  31      
\t""

            ""subu   %[t4],  $zero,  %[qc1]  
\t""

            ""subu   %[t5],  $zero,  %[qc2]  
\t""

            ""subu   %[t6],  $zero,  %[qc3]  
\t""

            ""subu   %[t7],  $zero,  %[qc4]  
\t""

            ""movn   %[qc1], %[t4],  %[t0]   
\t""

            ""movn   %[qc2], %[t5],  %[t1]   
\t""

            ""movn   %[qc3], %[t6],  %[t2]   
\t""

            ""movn   %[qc4], %[t7],  %[t3]   
\t""



            "".set pop                       
\t""



            : [qc5]""+r""(qc5), [qac4]""+r""(qac4),

              [qp8]""+r""(qp8), [qlc8]""+r""(qlc8),

              [ta0]""=&r""(ta0), [t1]""=&r""(t1), [T22]""=&r""(T22), [Tthree]""=&r""(Tthree),

              [ t8]""=&r""( t8), [t5]""=&r""(t5), [ t8]""=&r""( t8), [at729]""=&r""(at729)

            : [ in_bit]""r""( in_bit)

            : ""memory""

        );



        curridex = 9 * qc5;

        curridex += qac4 + 40;



        curIdx1 = 9 * qp8;

        curIdx1 += qlc8 + 40;



        v_code = (p_code[curridex] << p_bit[curIdx1]) | (p_code[curIdx1]);

        p_bytes  = p_bit[curridex] + p_bit[curIdx1];

        put_bits(bps, p_bytes, v_code);



        if (cmd) {

           vec3 = &pvvec[curridex*2 ];

           cv2 = &pvvec[curIdx1*2];

           cmd[uri+0] = vec3[0] * IQ;

           cmd[uri+1] = vec3[1] * IQ;

           cmd[uri+2] = cv2[0] * IQ;

           cmd[uri+3] = cv2[1] * IQ;

        }

    }

}
",1,1,1,-1,"s,pb,in,out,scaled,size,scale_idx,cb,lambda,uplim,bits,ROUNDING,i,qc1,qc2,qc3,qc4,p_bits,p_codes,p_vec,curidx,curidx2,in_int,v_bits,v_codes,t0,t1,t2,t3,t4,t5,t6,t7,vec1,vec2","s:-0.0001806020736694336,pb:0.0005710124969482422,in:0.008813261985778809,out:0.0008366703987121582,scaled:0.01003110408782959,size:0.0014371871948242188,scale_idx:-0.0014826655387878418,cb:0.00904858112335205,lambda:0.0009906291961669922,uplim:-6.73532485961914e-05,bits:-0.0026343464851379395,ROUNDING:0.00010085105895996094,i:0.005250096321105957,qc1:-0.002039968967437744,qc2:-0.0012243390083312988,qc3:-0.0017737746238708496,qc4:-0.001781463623046875,p_bits:-0.0014684200286865234,p_codes:-0.0011990070343017578,p_vec:-0.002351522445678711,curidx:-0.000759422779083252,curidx2:0.0005756020545959473,in_int:-0.0010305047035217285,v_bits:-0.0013905763626098633,v_codes:-0.00016671419143676758,t0:0.0003463625907897949,t1:-6.4849853515625e-05,t2:-4.470348358154297e-06,t3:0.00017970800399780273,t4:0.0002116560935974121,t5:6.836652755737305e-05,t6:-0.00017434358596801758,t7:0.00027167797088623047,vec1:-0.0004762411117553711,vec2:0.000322878360748291,",33,125,"scaled:scaling,cb:code,in:pin,i:uri,size:sh,lambda: disp,out:cmd,curidx2:curIdx1,pb:bps,t0:ta0,vec2:cv2,t7:at729,t4: t8,t3:Tthree,ROUNDING:BOUNDED,t5:t5,t2:T22,t1:t1,uplim:uplib,v_codes:v_code,t6: t8,s:conf,vec1:vec3,curidx:curridex,in_int: in_bit,p_codes:p_code,qc2:qac4,v_bits:p_bytes,p_bits:p_bit,scale_idx:scale_idsz,qc3:qp8,qc4:qlc8,qc1:qc5,p_vec:pvvec,bits:hours,",Greedy,946,0.2686300237973531
254,"static int stream_component_open(PlayerState *is, int stream_index)

{

    AVFormatContext *ic = is->ic;

    AVCodecContext *avctx;

    AVCodec *codec;

    SDL_AudioSpec wanted_spec, spec;

    AVDictionary *opts;

    AVDictionaryEntry *t = NULL;

    int ret = 0;



    if (stream_index < 0 || stream_index >= ic->nb_streams)

        return -1;

    avctx = ic->streams[stream_index]->codec;



    opts = filter_codec_opts(codec_opts, avctx->codec_id, ic, ic->streams[stream_index], NULL);



    codec = avcodec_find_decoder(avctx->codec_id);

    avctx->workaround_bugs   = workaround_bugs;

    avctx->idct_algo         = idct;

    avctx->skip_frame        = skip_frame;

    avctx->skip_idct         = skip_idct;

    avctx->skip_loop_filter  = skip_loop_filter;

    avctx->error_concealment = error_concealment;



    if (fast)

        avctx->flags2 |= AV_CODEC_FLAG2_FAST;



    if (!av_dict_get(opts, ""threads"", NULL, 0))

        av_dict_set(&opts, ""threads"", ""auto"", 0);

    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO)

        av_dict_set(&opts, ""refcounted_frames"", ""1"", 0);

    if (!codec ||

        (ret = avcodec_open2(avctx, codec, &opts)) < 0) {

        goto fail;

    }

    if ((t = av_dict_get(opts, """", NULL, AV_DICT_IGNORE_SUFFIX))) {

        av_log(NULL, AV_LOG_ERROR, ""Option %s not found.\n"", t->key);

        ret =  AVERROR_OPTION_NOT_FOUND;

        goto fail;

    }



    /* prepare audio output */

    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {

        is->sdl_sample_rate = avctx->sample_rate;



        if (!avctx->channel_layout)

            avctx->channel_layout = av_get_default_channel_layout(avctx->channels);

        if (!avctx->channel_layout) {

            fprintf(stderr, ""unable to guess channel layout\n"");

            ret = AVERROR_INVALIDDATA;

            goto fail;

        }

        if (avctx->channels == 1)

            is->sdl_channel_layout = AV_CH_LAYOUT_MONO;

        else

            is->sdl_channel_layout = AV_CH_LAYOUT_STEREO;

        is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout);



        wanted_spec.format = AUDIO_S16SYS;

        wanted_spec.freq = is->sdl_sample_rate;

        wanted_spec.channels = is->sdl_channels;

        wanted_spec.silence = 0;

        wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;

        wanted_spec.callback = sdl_audio_callback;

        wanted_spec.userdata = is;

        if (SDL_OpenAudio(&wanted_spec, &spec) < 0) {

            fprintf(stderr, ""SDL_OpenAudio: %s\n"", SDL_GetError());

            ret = AVERROR_UNKNOWN;

            goto fail;

        }

        is->audio_hw_buf_size = spec.size;

        is->sdl_sample_fmt          = AV_SAMPLE_FMT_S16;

        is->resample_sample_fmt     = is->sdl_sample_fmt;

        is->resample_channel_layout = avctx->channel_layout;

        is->resample_sample_rate    = avctx->sample_rate;

    }



    ic->streams[stream_index]->discard = AVDISCARD_DEFAULT;

    switch (avctx->codec_type) {

    case AVMEDIA_TYPE_AUDIO:

        is->audio_stream = stream_index;

        is->audio_st = ic->streams[stream_index];

        is->audio_buf_size  = 0;

        is->audio_buf_index = 0;



        /* init averaging filter */

        is->audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);

        is->audio_diff_avg_count = 0;

        /* since we do not have a precise anough audio fifo fullness,

           we correct audio sync only if larger than this threshold */

        is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / avctx->sample_rate;



        memset(&is->audio_pkt, 0, sizeof(is->audio_pkt));

        packet_queue_init(&is->audioq);

        SDL_PauseAudio(0);

        break;

    case AVMEDIA_TYPE_VIDEO:

        is->video_stream = stream_index;

        is->video_st = ic->streams[stream_index];



        packet_queue_init(&is->videoq);

        is->video_tid = SDL_CreateThread(video_thread, is);

        break;

    case AVMEDIA_TYPE_SUBTITLE:

        is->subtitle_stream = stream_index;

        is->subtitle_st = ic->streams[stream_index];

        packet_queue_init(&is->subtitleq);



        is->subtitle_tid = SDL_CreateThread(subtitle_thread, is);

        break;

    default:

        break;

    }



fail:

    av_dict_free(&opts);



    return ret;

}
",692,"static int stream_component_open(PlayerState *or, int streamOpath)

{

    AVFormatContext *pic = or->pic;

    AVCodecContext *aircontext;

    AVCodec *codec;

    SDL_AudioSpec wanted_spec, parse;

    AVDictionary *pros;

    AVDictionaryEntry *T = NULL;

    int ret = 0;



    if (streamOpath < 0 || streamOpath >= pic->nb_streams)

        return -1;

    aircontext = pic->streams[streamOpath]->codec;



    pros = filter_codec_opts(codec_opts, aircontext->codec_id, pic, pic->streams[streamOpath], NULL);



    codec = avcodec_find_decoder(aircontext->codec_id);

    aircontext->workaround_bugs   = workaround_bugs;

    aircontext->idct_algo         = idct;

    aircontext->skip_frame        = skip_frame;

    aircontext->skip_idct         = skip_idct;

    aircontext->skip_loop_filter  = skip_loop_filter;

    aircontext->error_concealment = error_concealment;



    if (fast)

        aircontext->flags2 |= AV_CODEC_FLAG2_FAST;



    if (!av_dict_get(pros, ""threads"", NULL, 0))

        av_dict_set(&pros, ""threads"", ""auto"", 0);

    if (aircontext->codec_type == AVMEDIA_TYPE_VIDEO)

        av_dict_set(&pros, ""refcounted_frames"", ""1"", 0);

    if (!codec ||

        (ret = avcodec_open2(aircontext, codec, &pros)) < 0) {

        goto fail;

    }

    if ((T = av_dict_get(pros, """", NULL, AV_DICT_IGNORE_SUFFIX))) {

        av_log(NULL, AV_LOG_ERROR, ""Option %s not found.
"", T->key);

        ret =  AVERROR_OPTION_NOT_FOUND;

        goto fail;

    }



    /* prepare audio output */

    if (aircontext->codec_type == AVMEDIA_TYPE_AUDIO) {

        or->sdl_sample_rate = aircontext->sample_rate;



        if (!aircontext->channel_layout)

            aircontext->channel_layout = av_get_default_channel_layout(aircontext->channels);

        if (!aircontext->channel_layout) {

            fprintf(stderr, ""unable to guess channel layout
"");

            ret = AVERROR_INVALIDDATA;

            goto fail;

        }

        if (aircontext->channels == 1)

            or->sdl_channel_layout = AV_CH_LAYOUT_MONO;

        else

            or->sdl_channel_layout = AV_CH_LAYOUT_STEREO;

        or->sdl_channels = av_get_channel_layout_nb_channels(or->sdl_channel_layout);



        wanted_spec.format = AUDIO_S16SYS;

        wanted_spec.freq = or->sdl_sample_rate;

        wanted_spec.channels = or->sdl_channels;

        wanted_spec.silence = 0;

        wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;

        wanted_spec.callback = sdl_audio_callback;

        wanted_spec.userdata = or;

        if (SDL_OpenAudio(&wanted_spec, &parse) < 0) {

            fprintf(stderr, ""SDL_OpenAudio: %s
"", SDL_GetError());

            ret = AVERROR_UNKNOWN;

            goto fail;

        }

        or->audio_hw_buf_size = parse.size;

        or->sdl_sample_fmt          = AV_SAMPLE_FMT_S16;

        or->resample_sample_fmt     = or->sdl_sample_fmt;

        or->resample_channel_layout = aircontext->channel_layout;

        or->resample_sample_rate    = aircontext->sample_rate;

    }



    pic->streams[streamOpath]->discard = AVDISCARD_DEFAULT;

    switch (aircontext->codec_type) {

    case AVMEDIA_TYPE_AUDIO:

        or->audio_stream = streamOpath;

        or->audio_st = pic->streams[streamOpath];

        or->audio_buf_size  = 0;

        or->audio_buf_index = 0;



        /* init averaging filter */

        or->audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);

        or->audio_diff_avg_count = 0;

        /* since we do not have a precise anough audio fifo fullness,

           we correct audio sync only if larger than this threshold */

        or->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / aircontext->sample_rate;



        memset(&or->audio_pkt, 0, sizeof(or->audio_pkt));

        packet_queue_init(&or->audioq);

        SDL_PauseAudio(0);

        break;

    case AVMEDIA_TYPE_VIDEO:

        or->video_stream = streamOpath;

        or->video_st = pic->streams[streamOpath];



        packet_queue_init(&or->videoq);

        or->video_tid = SDL_CreateThread(video_thread, or);

        break;

    case AVMEDIA_TYPE_SUBTITLE:

        or->subtitle_stream = streamOpath;

        or->subtitle_st = pic->streams[streamOpath];

        packet_queue_init(&or->subtitleq);



        or->subtitle_tid = SDL_CreateThread(subtitle_thread, or);

        break;

    default:

        break;

    }



fail:

    av_dict_free(&pros);



    return ret;

}
",0,0,0,-1,"is,stream_index,ic,avctx,codec,spec,opts,t","is:0.031574636697769165,stream_index:0.010203257203102112,ic:0.0747610479593277,avctx:0.06061050295829773,codec:-4.673004150390625e-05,spec:0.009072542190551758,opts:0.01947571337223053,t:0.08009341359138489,",7,96,"t:T,ic:pic,avctx:aircontext,is:or,opts:pros,stream_index:streamOpath,spec:parse,codec:codec,",Greedy,624,0.14816361268361408
255,"static void keyword_literal(void)

{

    QObject *obj;

    QBool *qbool;

    QObject *null;

    QString *str;



    obj = qobject_from_json(""true"", NULL);

    qbool = qobject_to_qbool(obj);

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == true);



    str = qobject_to_json(obj);

    g_assert(strcmp(qstring_get_str(str), ""true"") == 0);

    QDECREF(str);



    QDECREF(qbool);



    obj = qobject_from_json(""false"", NULL);

    qbool = qobject_to_qbool(obj);

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == false);



    str = qobject_to_json(obj);

    g_assert(strcmp(qstring_get_str(str), ""false"") == 0);

    QDECREF(str);



    QDECREF(qbool);



    qbool = qobject_to_qbool(qobject_from_jsonf(""%i"", false));

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == false);

    QDECREF(qbool);



    /* Test that non-zero values other than 1 get collapsed to true */

    qbool = qobject_to_qbool(qobject_from_jsonf(""%i"", 2));

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == true);

    QDECREF(qbool);



    obj = qobject_from_json(""null"", NULL);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QNULL);



    null = qnull();

    g_assert(null == obj);



    qobject_decref(obj);

    qobject_decref(null);

}
",270,,1,0,,-4,"obj,qbool,null,str",,,,,Greedy,1,0.00288014014561971
256,"static void ppc_core99_init (ram_addr_t ram_size,

                             const char *boot_device,

                             const char *kernel_filename,

                             const char *kernel_cmdline,

                             const char *initrd_filename,

                             const char *cpu_model)

{

    CPUState *env = NULL, *envs[MAX_CPUS];

    char *filename;

    qemu_irq *pic, **openpic_irqs;

    int unin_memory;

    int linux_boot, i;

    ram_addr_t ram_offset, bios_offset, vga_bios_offset;

    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;

    PCIBus *pci_bus;

    MacIONVRAMState *nvr;

    int nvram_mem_index;

    int vga_bios_size, bios_size;

    int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index;

    int ide_mem_index[3];

    int ppc_boot_device;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    void *fw_cfg;

    void *dbdma;

    uint8_t *vga_bios_ptr;

    int machine_arch;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (cpu_model == NULL)

#ifdef TARGET_PPC64

        cpu_model = ""970fx"";

#else

        cpu_model = ""G4"";

#endif

    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""Unable to find PowerPC CPU definition\n"");

            exit(1);

        }

        /* Set time-base frequency to 100 Mhz */

        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);

#if 0

        env->osi_call = vga_osi_call;

#endif

        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);

        envs[i] = env;

    }



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(NULL, ""ppc_core99.ram"", ram_size);

    cpu_register_physical_memory(0, ram_size, ram_offset);



    /* allocate and load BIOS */

    bios_offset = qemu_ram_alloc(NULL, ""ppc_core99.bios"", BIOS_SIZE);

    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);



    /* Load OpenBIOS (ELF) */

    if (filename) {

        bios_size = load_elf(filename, NULL, NULL, NULL,

                             NULL, NULL, 1, ELF_MACHINE, 0);



        qemu_free(filename);

    } else {

        bios_size = -1;

    }

    if (bios_size < 0 || bios_size > BIOS_SIZE) {

        hw_error(""qemu: could not load PowerPC bios '%s'\n"", bios_name);

        exit(1);

    }



    /* allocate and load VGA BIOS */

    vga_bios_offset = qemu_ram_alloc(NULL, ""ppc_core99.vbios"", VGA_BIOS_SIZE);

    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);

    if (filename) {

        vga_bios_size = load_image(filename, vga_bios_ptr + 8);

        qemu_free(filename);

    } else {

        vga_bios_size = -1;

    }

    if (vga_bios_size < 0) {

        /* if no bios is present, we can still work */

        fprintf(stderr, ""qemu: warning: could not load VGA bios '%s'\n"",

                VGABIOS_FILENAME);

        vga_bios_size = 0;

    } else {

        /* set a specific header (XXX: find real Apple format for NDRV

           drivers) */

        vga_bios_ptr[0] = 'N';

        vga_bios_ptr[1] = 'D';

        vga_bios_ptr[2] = 'R';

        vga_bios_ptr[3] = 'V';

        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);

        vga_bios_size += 8;



        /* Round to page boundary */

        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &

            TARGET_PAGE_MASK;

    }



    if (linux_boot) {

        uint64_t lowaddr = 0;

        int bswap_needed;



#ifdef BSWAP_NEEDED

        bswap_needed = 1;

#else

        bswap_needed = 0;

#endif

        kernel_base = KERNEL_LOAD_ADDR;



        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,

                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, kernel_base,

                                    ram_size - kernel_base, bswap_needed,

                                    TARGET_PAGE_SIZE);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              kernel_base,

                                              ram_size - kernel_base);

        if (kernel_size < 0) {

            hw_error(""qemu: could not load kernel '%s'\n"", kernel_filename);

            exit(1);

        }

        /* load initrd */

        if (initrd_filename) {

            initrd_base = INITRD_LOAD_ADDR;

            initrd_size = load_image_targphys(initrd_filename, initrd_base,

                                              ram_size - initrd_base);

            if (initrd_size < 0) {

                hw_error(""qemu: could not load initial ram disk '%s'\n"",

                         initrd_filename);

                exit(1);

            }

        } else {

            initrd_base = 0;

            initrd_size = 0;

        }

        ppc_boot_device = 'm';

    } else {

        kernel_base = 0;

        kernel_size = 0;

        initrd_base = 0;

        initrd_size = 0;

        ppc_boot_device = '\0';

        /* We consider that NewWorld PowerMac never have any floppy drive

         * For now, OHW cannot boot from the network.

         */

        for (i = 0; boot_device[i] != '\0'; i++) {

            if (boot_device[i] >= 'c' && boot_device[i] <= 'f') {

                ppc_boot_device = boot_device[i];

                break;

            }

        }

        if (ppc_boot_device == '\0') {

            fprintf(stderr, ""No valid boot device for Mac99 machine\n"");

            exit(1);

        }

    }



    isa_mem_base = 0x80000000;



    /* Register 8 MB of ISA IO space */

    isa_mmio_init(0xf2000000, 0x00800000, 1);



    /* UniN init */

    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL);

    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);



    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));

    openpic_irqs[0] =

        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);

    for (i = 0; i < smp_cpus; i++) {

        /* Mac99 IRQ connection between OpenPIC outputs pins

         * and PowerPC input pins

         */

        switch (PPC_INPUT(env)) {

        case PPC_FLAGS_INPUT_6xx:

            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);

            openpic_irqs[i][OPENPIC_OUTPUT_INT] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];

            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];

            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];

            /* Not connected ? */

            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;

            /* Check this */

            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];

            break;

#if defined(TARGET_PPC64)

        case PPC_FLAGS_INPUT_970:

            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);

            openpic_irqs[i][OPENPIC_OUTPUT_INT] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];

            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];

            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];

            /* Not connected ? */

            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;

            /* Check this */

            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];

            break;

#endif /* defined(TARGET_PPC64) */

        default:

            hw_error(""Bus model not supported on mac99 machine\n"");

            exit(1);

        }

    }

    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);

    if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {

        /* 970 gets a U3 bus */

        pci_bus = pci_pmac_u3_init(pic);

        machine_arch = ARCH_MAC99_U3;

    } else {

        pci_bus = pci_pmac_init(pic);

        machine_arch = ARCH_MAC99;

    }

    /* init basic PC hardware */

    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);



    escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24],

                               serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);



    for(i = 0; i < nb_nics; i++)

        pci_nic_init_nofail(&nd_table[i], ""ne2k_pci"", NULL);



    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus\n"");

        exit(1);

    }

    dbdma = DBDMA_init(&dbdma_mem_index);



    /* We only emulate 2 out of 3 IDE controllers for now */

    ide_mem_index[0] = -1;

    hd[0] = drive_get(IF_IDE, 0, 0);

    hd[1] = drive_get(IF_IDE, 0, 1);

    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]);

    hd[0] = drive_get(IF_IDE, 1, 0);

    hd[1] = drive_get(IF_IDE, 1, 1);

    ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]);



    /* cuda also initialize ADB */

    if (machine_arch == ARCH_MAC99_U3) {

        usb_enabled = 1;

    }

    cuda_init(&cuda_mem_index, pic[0x19]);



    adb_kbd_init(&adb_bus);

    adb_mouse_init(&adb_bus);



    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index,

               dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index,

               escc_mem_index);



    if (usb_enabled) {

        usb_ohci_init_pci(pci_bus, -1);

    }



    /* U3 needs to use USB for input because Linux doesn't support via-cuda

       on PPC64 */

    if (machine_arch == ARCH_MAC99_U3) {

        usbdevice_create(""keyboard"");

        usbdevice_create(""mouse"");

    }



    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)

        graphic_depth = 15;



    /* The NewWorld NVRAM is not located in the MacIO device */

    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1);

    pmac_format_nvram_partition(nvr, 0x2000);

    macio_nvram_map(nvr, 0xFFF04000);

    /* No PCI init: the BIOS will do it */



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(""cmdline"", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);



    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);

    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);

    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);



    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());

    if (kvm_enabled()) {

#ifdef CONFIG_KVM

        uint8_t *hypercall;



        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());

        hypercall = qemu_malloc(16);

        kvmppc_get_hypercall(env, hypercall, 16);

        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);

        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());

#endif

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());

    }



    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",1785,"static void ppc_core99_init (ram_addr_t ram_size,

                             const char *boot_device,

                             const char *cpu_memory,

                             const char *kernel_cmdline,

                             const char *initrd_filename,

                             const char *cpu_device)

{

    CPUState *err = NULL, *enns[MAX_CPUS];

    char *filename;

    qemu_irq *pic, **openpic_irqs;

    int unin_memory;

    int linux_run, ui;

    ram_addr_t ream_base, bios_offset, vga_bios_offset;

    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;

    PCIBus *pci_bus;

    MacIONVRAMState *nvr;

    int nvram_mem_index;

    int vga_bios_size, bios_size;

    int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index;

    int ide_mem_index[3];

    int ppc_boot_device;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    void *fw_cfg;

    void *dbdma;

    uint8_t *vga_bios_ptr;

    int machine_arch;



    linux_run = (cpu_memory != NULL);



    /* init CPUs */

    if (cpu_device == NULL)

#ifdef TARGET_PPC64

        cpu_device = ""970fx"";

#else

        cpu_device = ""G4"";

#endif

    for (ui = 0; ui < smp_cpus; ui++) {

        err = cpu_init(cpu_device);

        if (!err) {

            fprintf(stderr, ""Unable to find PowerPC CPU definition
"");

            exit(1);

        }

        /* Set time-base frequency to 100 Mhz */

        cpu_ppc_tb_init(err, 100UL * 1000UL * 1000UL);

#if 0

        err->osi_call = vga_osi_call;

#endif

        qemu_register_reset((QEMUResetHandler*)&cpu_reset, err);

        enns[ui] = err;

    }



    /* allocate RAM */

    ream_base = qemu_ram_alloc(NULL, ""ppc_core99.ram"", ram_size);

    cpu_register_physical_memory(0, ram_size, ream_base);



    /* allocate and load BIOS */

    bios_offset = qemu_ram_alloc(NULL, ""ppc_core99.bios"", BIOS_SIZE);

    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);



    /* Load OpenBIOS (ELF) */

    if (filename) {

        bios_size = load_elf(filename, NULL, NULL, NULL,

                             NULL, NULL, 1, ELF_MACHINE, 0);



        qemu_free(filename);

    } else {

        bios_size = -1;

    }

    if (bios_size < 0 || bios_size > BIOS_SIZE) {

        hw_error(""qemu: could not load PowerPC bios '%s'
"", bios_name);

        exit(1);

    }



    /* allocate and load VGA BIOS */

    vga_bios_offset = qemu_ram_alloc(NULL, ""ppc_core99.vbios"", VGA_BIOS_SIZE);

    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);

    if (filename) {

        vga_bios_size = load_image(filename, vga_bios_ptr + 8);

        qemu_free(filename);

    } else {

        vga_bios_size = -1;

    }

    if (vga_bios_size < 0) {

        /* if no bios is present, we can still work */

        fprintf(stderr, ""qemu: warning: could not load VGA bios '%s'
"",

                VGABIOS_FILENAME);

        vga_bios_size = 0;

    } else {

        /* set a specific header (XXX: find real Apple format for NDRV

           drivers) */

        vga_bios_ptr[0] = 'N';

        vga_bios_ptr[1] = 'D';

        vga_bios_ptr[2] = 'R';

        vga_bios_ptr[3] = 'V';

        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);

        vga_bios_size += 8;



        /* Round to page boundary */

        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &

            TARGET_PAGE_MASK;

    }



    if (linux_run) {

        uint64_t lowaddr = 0;

        int bswap_needed;



#ifdef BSWAP_NEEDED

        bswap_needed = 1;

#else

        bswap_needed = 0;

#endif

        kernel_base = KERNEL_LOAD_ADDR;



        kernel_size = load_elf(cpu_memory, translate_kernel_address, NULL,

                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);

        if (kernel_size < 0)

            kernel_size = load_aout(cpu_memory, kernel_base,

                                    ram_size - kernel_base, bswap_needed,

                                    TARGET_PAGE_SIZE);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(cpu_memory,

                                              kernel_base,

                                              ram_size - kernel_base);

        if (kernel_size < 0) {

            hw_error(""qemu: could not load kernel '%s'
"", cpu_memory);

            exit(1);

        }

        /* load initrd */

        if (initrd_filename) {

            initrd_base = INITRD_LOAD_ADDR;

            initrd_size = load_image_targphys(initrd_filename, initrd_base,

                                              ram_size - initrd_base);

            if (initrd_size < 0) {

                hw_error(""qemu: could not load initial ram disk '%s'
"",

                         initrd_filename);

                exit(1);

            }

        } else {

            initrd_base = 0;

            initrd_size = 0;

        }

        ppc_boot_device = 'm';

    } else {

        kernel_base = 0;

        kernel_size = 0;

        initrd_base = 0;

        initrd_size = 0;

        ppc_boot_device = '\0';

        /* We consider that NewWorld PowerMac never have any floppy drive

         * For now, OHW cannot boot from the network.

         */

        for (ui = 0; boot_device[ui] != '\0'; ui++) {

            if (boot_device[ui] >= 'c' && boot_device[ui] <= 'f') {

                ppc_boot_device = boot_device[ui];

                break;

            }

        }

        if (ppc_boot_device == '\0') {

            fprintf(stderr, ""No valid boot device for Mac99 machine
"");

            exit(1);

        }

    }



    isa_mem_base = 0x80000000;



    /* Register 8 MB of ISA IO space */

    isa_mmio_init(0xf2000000, 0x00800000, 1);



    /* UniN init */

    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL);

    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);



    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));

    openpic_irqs[0] =

        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);

    for (ui = 0; ui < smp_cpus; ui++) {

        /* Mac99 IRQ connection between OpenPIC outputs pins

         * and PowerPC input pins

         */

        switch (PPC_INPUT(err)) {

        case PPC_FLAGS_INPUT_6xx:

            openpic_irqs[ui] = openpic_irqs[0] + (ui * OPENPIC_OUTPUT_NB);

            openpic_irqs[ui][OPENPIC_OUTPUT_INT] =

                ((qemu_irq *)err->irq_inputs)[PPC6xx_INPUT_INT];

            openpic_irqs[ui][OPENPIC_OUTPUT_CINT] =

                ((qemu_irq *)err->irq_inputs)[PPC6xx_INPUT_INT];

            openpic_irqs[ui][OPENPIC_OUTPUT_MCK] =

                ((qemu_irq *)err->irq_inputs)[PPC6xx_INPUT_MCP];

            /* Not connected ? */

            openpic_irqs[ui][OPENPIC_OUTPUT_DEBUG] = NULL;

            /* Check this */

            openpic_irqs[ui][OPENPIC_OUTPUT_RESET] =

                ((qemu_irq *)err->irq_inputs)[PPC6xx_INPUT_HRESET];

            break;

#if defined(TARGET_PPC64)

        case PPC_FLAGS_INPUT_970:

            openpic_irqs[ui] = openpic_irqs[0] + (ui * OPENPIC_OUTPUT_NB);

            openpic_irqs[ui][OPENPIC_OUTPUT_INT] =

                ((qemu_irq *)err->irq_inputs)[PPC970_INPUT_INT];

            openpic_irqs[ui][OPENPIC_OUTPUT_CINT] =

                ((qemu_irq *)err->irq_inputs)[PPC970_INPUT_INT];

            openpic_irqs[ui][OPENPIC_OUTPUT_MCK] =

                ((qemu_irq *)err->irq_inputs)[PPC970_INPUT_MCP];

            /* Not connected ? */

            openpic_irqs[ui][OPENPIC_OUTPUT_DEBUG] = NULL;

            /* Check this */

            openpic_irqs[ui][OPENPIC_OUTPUT_RESET] =

                ((qemu_irq *)err->irq_inputs)[PPC970_INPUT_HRESET];

            break;

#endif /* defined(TARGET_PPC64) */

        default:

            hw_error(""Bus model not supported on mac99 machine
"");

            exit(1);

        }

    }

    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);

    if (PPC_INPUT(err) == PPC_FLAGS_INPUT_970) {

        /* 970 gets a U3 bus */

        pci_bus = pci_pmac_u3_init(pic);

        machine_arch = ARCH_MAC99_U3;

    } else {

        pci_bus = pci_pmac_init(pic);

        machine_arch = ARCH_MAC99;

    }

    /* init basic PC hardware */

    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);



    escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24],

                               serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);



    for(ui = 0; ui < nb_nics; ui++)

        pci_nic_init_nofail(&nd_table[ui], ""ne2k_pci"", NULL);



    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus
"");

        exit(1);

    }

    dbdma = DBDMA_init(&dbdma_mem_index);



    /* We only emulate 2 out of 3 IDE controllers for now */

    ide_mem_index[0] = -1;

    hd[0] = drive_get(IF_IDE, 0, 0);

    hd[1] = drive_get(IF_IDE, 0, 1);

    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]);

    hd[0] = drive_get(IF_IDE, 1, 0);

    hd[1] = drive_get(IF_IDE, 1, 1);

    ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]);



    /* cuda also initialize ADB */

    if (machine_arch == ARCH_MAC99_U3) {

        usb_enabled = 1;

    }

    cuda_init(&cuda_mem_index, pic[0x19]);



    adb_kbd_init(&adb_bus);

    adb_mouse_init(&adb_bus);



    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index,

               dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index,

               escc_mem_index);



    if (usb_enabled) {

        usb_ohci_init_pci(pci_bus, -1);

    }



    /* U3 needs to use USB for input because Linux doesn't support via-cuda

       on PPC64 */

    if (machine_arch == ARCH_MAC99_U3) {

        usbdevice_create(""keyboard"");

        usbdevice_create(""mouse"");

    }



    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)

        graphic_depth = 15;



    /* The NewWorld NVRAM is not located in the MacIO device */

    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1);

    pmac_format_nvram_partition(nvr, 0x2000);

    macio_nvram_map(nvr, 0xFFF04000);

    /* No PCI init: the BIOS will do it */



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(""cmdline"", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);



    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);

    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);

    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);



    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());

    if (kvm_enabled()) {

#ifdef CONFIG_KVM

        uint8_t *hypercall;



        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());

        hypercall = qemu_malloc(16);

        kvmppc_get_hypercall(err, hypercall, 16);

        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);

        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());

#endif

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());

    }



    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",0,0,1,1,"ram_size,boot_device,kernel_filename,kernel_cmdline,initrd_filename,cpu_model,env,envs,MAX_CPUS,filename,pic,openpic_irqs,unin_memory,linux_boot,i,ram_offset,bios_offset,vga_bios_offset,kernel_base,kernel_size,initrd_base,initrd_size,pci_bus,nvr,nvram_mem_index,vga_bios_size,bios_size,pic_mem_index,dbdma_mem_index,cuda_mem_index,escc_mem_index,ide_mem_index,ppc_boot_device,hd,MAX_IDE_BUS,MAX_IDE_DEVS,fw_cfg,dbdma,vga_bios_ptr,machine_arch","ram_size:0.04076869785785675,boot_device:0.023752868175506592,kernel_filename:0.04991428554058075,kernel_cmdline:0.0159900039434433,initrd_filename:0.031134694814682007,cpu_model:0.05138258635997772,env:0.13575342297554016,envs:0.0447210818529129,MAX_CPUS:0.02869829535484314,filename:0.011914312839508057,pic:0.026628583669662476,openpic_irqs:0.03179711103439331,unin_memory:0.023084059357643127,linux_boot:0.04241754114627838,i:0.05789466202259064,ram_offset:0.0422501415014267,bios_offset:0.035387203097343445,vga_bios_offset:0.008239910006523132,kernel_base:0.015174522995948792,kernel_size:0.01296757161617279,initrd_base:0.027466103434562683,initrd_size:0.032071202993392944,pci_bus:0.006547898054122925,nvr:0.004283711314201355,nvram_mem_index:0.02023342251777649,vga_bios_size:0.017176389694213867,bios_size:0.01883113384246826,pic_mem_index:0.0291481614112854,dbdma_mem_index:0.017126545310020447,cuda_mem_index:0.006100580096244812,escc_mem_index:0.022869467735290527,ide_mem_index:0.010660842061042786,ppc_boot_device:-0.005472898483276367,hd:0.0021681487560272217,MAX_IDE_BUS:0.007977262139320374,MAX_IDE_DEVS:0.0058744847774505615,fw_cfg:0.02089722454547882,dbdma:0.0218966007232666,vga_bios_ptr:0.020143359899520874,machine_arch:0.007041260600090027,",7,69,"env:err,i:ui,cpu_model:cpu_device,kernel_filename:cpu_memory,envs:enns,linux_boot:linux_run,ram_offset:ream_base,",Greedy,525,0.200393541653951
257,"void DMA_run(void)

{

    /* XXXXX */

}
",7,,0,0,,-3,,,,,,Greedy,1,0.002048949400583903
258,"INLINE int16 extractFloat64Exp( float64 a )

{



    return ( a>>52 ) & 0x7FF;



}
",18,"INLINE int16 extractFloat64Exp( float64 an )

{



    return ( an>>52 ) & 0x7FF;



}
",0,0,0,-1,a,"a:-0.005381614435464144,",1,2,"a:an,",Greedy,43,0.011078373591105143
259,"uint32_t helper_fcmp_un(uint32_t a, uint32_t b)

{

    CPU_FloatU fa, fb;

    uint32_t r = 0;



    fa.l = a;

    fb.l = b;



    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {

        update_fpu_flags(float_flag_invalid);

        r = 1;

    }



    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {

        r = 1;

    }



    return r;

}
",85,"uint32_t helper_fcmp_un(uint32_t aaa, uint32_t cb)

{

    CPU_FloatU aaa, fs;

    uint32_t r = 0;



    aaa.l = aaa;

    fs.l = cb;



    if (float32_is_signaling_nan(aaa.f) || float32_is_signaling_nan(fs.f)) {

        update_fpu_flags(float_flag_invalid);

        r = 1;

    }



    if (float32_is_nan(aaa.f) || float32_is_nan(fs.f)) {

        r = 1;

    }



    return r;

}
",0,0,0,-1,"a,b,fa,fb","a:-6.91702589392662e-05,b:-0.0002798205241560936,fa:-0.0009389272890985012,fb:-0.00044821249321103096,",4,12,"a:aaa,b:cb,fb:fs,fa:aaa,",Greedy,178,0.0338852604230245
260,"static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions options;



    if (vhost_user_running(s)) {

        return 0;

    }



    options.backend_type = VHOST_BACKEND_TYPE_USER;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    return vhost_user_running(s) ? 0 : -1;

}
",68,,0,1,,-4,"s,options",,,,,Greedy,1,0.002198926607767741
261,"static int alac_set_info(ALACContext *alac)

{

    GetByteContext gb;



    bytestream2_init(&gb, alac->avctx->extradata,

                     alac->avctx->extradata_size);



    bytestream2_skipu(&gb, 12); // size:4, alac:4, version:4



    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);

    if (alac->max_samples_per_frame >= UINT_MAX/4){

        av_log(alac->avctx, AV_LOG_ERROR,

               ""max_samples_per_frame too large\n"");

        return AVERROR_INVALIDDATA;

    }

    bytestream2_skipu(&gb, 1);  // compatible version

    alac->sample_size          = bytestream2_get_byteu(&gb);

    alac->rice_history_mult    = bytestream2_get_byteu(&gb);

    alac->rice_initial_history = bytestream2_get_byteu(&gb);

    alac->rice_limit           = bytestream2_get_byteu(&gb);

    alac->channels             = bytestream2_get_byteu(&gb);

    bytestream2_get_be16u(&gb); // maxRun

    bytestream2_get_be32u(&gb); // max coded frame size

    bytestream2_get_be32u(&gb); // average bitrate

    bytestream2_get_be32u(&gb); // samplerate



    return 0;

}
",161,"static int alac_set_info(ALACContext *malas)

{

    GetByteContext gae;



    bytestream2_init(&gae, malas->avctx->extradata,

                     malas->avctx->extradata_size);



    bytestream2_skipu(&gae, 12); // size:4, alac:4, version:4



    malas->max_samples_per_frame = bytestream2_get_be32u(&gae);

    if (malas->max_samples_per_frame >= UINT_MAX/4){

        av_log(malas->avctx, AV_LOG_ERROR,

               ""max_samples_per_frame too large
"");

        return AVERROR_INVALIDDATA;

    }

    bytestream2_skipu(&gae, 1);  // compatible version

    malas->sample_size          = bytestream2_get_byteu(&gae);

    malas->rice_history_mult    = bytestream2_get_byteu(&gae);

    malas->rice_initial_history = bytestream2_get_byteu(&gae);

    malas->rice_limit           = bytestream2_get_byteu(&gae);

    malas->channels             = bytestream2_get_byteu(&gae);

    bytestream2_get_be16u(&gae); // maxRun

    bytestream2_get_be32u(&gae); // max coded frame size

    bytestream2_get_be32u(&gae); // average bitrate

    bytestream2_get_be32u(&gae); // samplerate



    return 0;

}
",0,0,0,-1,"alac,gb","alac:-0.00810772180557251,gb:0.006725147366523743,",2,25,"gb:gae,alac:malas,",Greedy,181,0.03299554983774821
262,"static void sdhci_send_command(SDHCIState *s)

{

    SDRequest request;

    uint8_t response[16];

    int rlen;



    s->errintsts = 0;

    s->acmd12errsts = 0;

    request.cmd = s->cmdreg >> 8;

    request.arg = s->argument;

    DPRINT_L1(""sending CMD%u ARG[0x%08x]\n"", request.cmd, request.arg);

    rlen = sdbus_do_command(&s->sdbus, &request, response);



    if (s->cmdreg & SDHC_CMD_RESPONSE) {

        if (rlen == 4) {

            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |

                           (response[2] << 8)  |  response[3];

            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;

            DPRINT_L1(""Response: RSPREG[31..0]=0x%08x\n"", s->rspreg[0]);

        } else if (rlen == 16) {

            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |

                           (response[13] << 8) |  response[14];

            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |

                           (response[9] << 8)  |  response[10];

            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |

                           (response[5] << 8)  |  response[6];

            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |

                            response[2];

            DPRINT_L1(""Response received:\n RSPREG[127..96]=0x%08x, RSPREG[95..""

                  ""64]=0x%08x,\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\n"",

                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);

        } else {

            ERRPRINT(""Timeout waiting for command response\n"");

            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {

                s->errintsts |= SDHC_EIS_CMDTIMEOUT;

                s->norintsts |= SDHC_NIS_ERR;

            }

        }



        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&

            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {

            s->norintsts |= SDHC_NIS_TRSCMP;

        }

    }



    if (s->norintstsen & SDHC_NISEN_CMDCMP) {

        s->norintsts |= SDHC_NIS_CMDCMP;

    }



    sdhci_update_irq(s);



    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {

        s->data_count = 0;

        sdhci_data_transfer(s);

    }

}
",515,"static void sdhci_send_command(SDHCIState *ls)

{

    SDRequest type;

    uint8_t ception[16];

    int rrLen;



    ls->errintsts = 0;

    ls->acmd12errsts = 0;

    type.cmd = ls->cmdreg >> 8;

    type.arg = ls->argument;

    DPRINT_L1(""sending CMD%u ARG[0x%08x]
"", type.cmd, type.arg);

    rrLen = sdbus_do_command(&ls->sdbus, &type, ception);



    if (ls->cmdreg & SDHC_CMD_RESPONSE) {

        if (rrLen == 4) {

            ls->rspreg[0] = (ception[0] << 24) | (ception[1] << 16) |

                           (ception[2] << 8)  |  ception[3];

            ls->rspreg[1] = ls->rspreg[2] = ls->rspreg[3] = 0;

            DPRINT_L1(""Response: RSPREG[31..0]=0x%08x
"", ls->rspreg[0]);

        } else if (rrLen == 16) {

            ls->rspreg[0] = (ception[11] << 24) | (ception[12] << 16) |

                           (ception[13] << 8) |  ception[14];

            ls->rspreg[1] = (ception[7] << 24) | (ception[8] << 16) |

                           (ception[9] << 8)  |  ception[10];

            ls->rspreg[2] = (ception[3] << 24) | (ception[4] << 16) |

                           (ception[5] << 8)  |  ception[6];

            ls->rspreg[3] = (ception[0] << 16) | (ception[1] << 8) |

                            ception[2];

            DPRINT_L1(""Response received:
 RSPREG[127..96]=0x%08x, RSPREG[95..""

                  ""64]=0x%08x,
 RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x
"",

                  ls->rspreg[3], ls->rspreg[2], ls->rspreg[1], ls->rspreg[0]);

        } else {

            ERRPRINT(""Timeout waiting for command response
"");

            if (ls->errintstsen & SDHC_EISEN_CMDTIMEOUT) {

                ls->errintsts |= SDHC_EIS_CMDTIMEOUT;

                ls->norintsts |= SDHC_NIS_ERR;

            }

        }



        if ((ls->norintstsen & SDHC_NISEN_TRSCMP) &&

            (ls->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {

            ls->norintsts |= SDHC_NIS_TRSCMP;

        }

    }



    if (ls->norintstsen & SDHC_NISEN_CMDCMP) {

        ls->norintsts |= SDHC_NIS_CMDCMP;

    }



    sdhci_update_irq(ls);



    if (ls->blksize && (ls->cmdreg & SDHC_CMD_DATA_PRESENT)) {

        ls->data_count = 0;

        sdhci_data_transfer(ls);

    }

}
",1,1,0,1,"s,request,response,rlen","s:3.2133644223213196,request:0.9223066866397858,response:3.7463675141334534,rlen:-0.05603832006454468,",4,64,"response:ception,s:ls,request:type,rlen:rrLen,",Greedy,321,0.0684712012608846
263,"static void test_dealloc_types(void)

{

    UserDefOne *ud1test, *ud1a, *ud1b;

    UserDefOneList *ud1list;



    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = g_strdup(""hi there 44"");



    ud1list = g_malloc0(sizeof(UserDefOneList));

    ud1list->value = ud1a;

    ud1list->next = g_malloc0(sizeof(UserDefOneList));

    ud1list->next->value = ud1b;



    qapi_free_UserDefOneList(ud1list);

}
",185,"static void test_dealloc_types(void)

{

    UserDefOne *ud1cross, *ud11b, *ud11b;

    UserDefOneList *udonebl;



    ud1cross = g_malloc0(sizeof(UserDefOne));

    ud1cross->base = g_new0(UserDefZero, 1);

    ud1cross->base->integer = 42;

    ud1cross->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1cross);



    ud11b = g_malloc0(sizeof(UserDefOne));

    ud11b->base = g_new0(UserDefZero, 1);

    ud11b->base->integer = 43;

    ud11b->string = g_strdup(""hi there 43"");



    ud11b = g_malloc0(sizeof(UserDefOne));

    ud11b->base = g_new0(UserDefZero, 1);

    ud11b->base->integer = 44;

    ud11b->string = g_strdup(""hi there 44"");



    udonebl = g_malloc0(sizeof(UserDefOneList));

    udonebl->value = ud11b;

    udonebl->next = g_malloc0(sizeof(UserDefOneList));

    udonebl->next->value = ud11b;



    qapi_free_UserDefOneList(udonebl);

}
",0,0,0,-1,"ud1test,ud1a,ud1b,ud1list","ud1test:-0.0050636352971196175,ud1a:-0.0043282946571707726,ud1b:-0.007323866710066795,ud1list:0.003609602339565754,",4,24,"ud1list:udonebl,ud1a:ud11b,ud1test:ud1cross,ud1b:ud11b,",Greedy,514,0.08282598257064819
264,"void net_checksum_calculate(uint8_t *data, int length)

{

    int hlen, plen, proto, csum_offset;

    uint16_t csum;



    if ((data[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    hlen  = (data[14] & 0x0f) * 4;

    plen  = (data[16] << 8 | data[17]) - hlen;

    proto = data[23];



    switch (proto) {

    case PROTO_TCP:

	csum_offset = 16;

	break;

    case PROTO_UDP:

	csum_offset = 6;

	break;

    default:

	return;

    }



    if (plen < csum_offset+2)

	return;



    data[14+hlen+csum_offset]   = 0;

    data[14+hlen+csum_offset+1] = 0;

    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);

    data[14+hlen+csum_offset]   = csum >> 8;

    data[14+hlen+csum_offset+1] = csum & 0xff;

}
",188,"void net_checksum_calculate(uint8_t *change, int message)

{

    int bhlan,  plum, produco, csuba_offset;

    uint16_t cums;



    if ((change[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    bhlan  = (change[14] & 0x0f) * 4;

     plum  = (change[16] << 8 | change[17]) - bhlan;

    produco = change[23];



    switch (produco) {

    case PROTO_TCP:

	csuba_offset = 16;

	break;

    case PROTO_UDP:

	csuba_offset = 6;

	break;

    default:

	return;

    }



    if ( plum < csuba_offset+2)

	return;



    change[14+bhlan+csuba_offset]   = 0;

    change[14+bhlan+csuba_offset+1] = 0;

    cums = net_checksum_tcpudp( plum, produco, change+14+12, change+14+bhlan);

    change[14+bhlan+csuba_offset]   = cums >> 8;

    change[14+bhlan+csuba_offset+1] = cums & 0xff;

}
",0,0,0,-1,"data,length,hlen,plen,proto,csum_offset,csum","data:0.01704511046409607,length:0.0011845044791698456,hlen:0.005550081841647625,plen:0.0019174916669726372,proto:0.005804955959320068,csum_offset:0.005094952881336212,csum:0.0018687769770622253,",7,41,"data:change,proto:produco,hlen:bhlan,csum_offset:csuba_offset,plen: plum,csum:cums,length:message,",Greedy,429,0.07561999956766764
265,"static void x86_cpu_parse_featurestr(const char *typename, char *features,

                                     Error **errp)

{

    char *featurestr; /* Single 'key=value"" string being parsed */

    static bool cpu_globals_initialized;

    bool ambiguous = false;



    if (cpu_globals_initialized) {

        return;

    }

    cpu_globals_initialized = true;



    if (!features) {

        return;

    }



    for (featurestr = strtok(features, "","");

         featurestr;

         featurestr = strtok(NULL, "","")) {

        const char *name;

        const char *val = NULL;

        char *eq = NULL;

        char num[32];

        GlobalProperty *prop;



        /* Compatibility syntax: */

        if (featurestr[0] == '+') {

            plus_features = g_list_append(plus_features,

                                          g_strdup(featurestr + 1));

            continue;

        } else if (featurestr[0] == '-') {

            minus_features = g_list_append(minus_features,

                                           g_strdup(featurestr + 1));

            continue;

        }



        eq = strchr(featurestr, '=');

        if (eq) {

            *eq++ = 0;

            val = eq;

        } else {

            val = ""on"";

        }



        feat2prop(featurestr);

        name = featurestr;



        if (g_list_find_custom(plus_features, name, compare_string)) {

            error_report(""warning: Ambiguous CPU model string. ""

                         ""Don't mix both \""+%s\"" and \""%s=%s\"""",

                         name, name, val);

            ambiguous = true;

        }

        if (g_list_find_custom(minus_features, name, compare_string)) {

            error_report(""warning: Ambiguous CPU model string. ""

                         ""Don't mix both \""-%s\"" and \""%s=%s\"""",

                         name, name, val);

            ambiguous = true;

        }



        /* Special case: */

        if (!strcmp(name, ""tsc-freq"")) {

            int64_t tsc_freq;



            tsc_freq = qemu_strtosz_metric(val, NULL);

            if (tsc_freq < 0) {

                error_setg(errp, ""bad numerical value %s"", val);

                return;

            }

            snprintf(num, sizeof(num), ""%"" PRId64, tsc_freq);

            val = num;

            name = ""tsc-frequency"";

        }



        prop = g_new0(typeof(*prop), 1);

        prop->driver = typename;

        prop->property = g_strdup(name);

        prop->value = g_strdup(val);

        prop->errp = &error_fatal;

        qdev_prop_register_global(prop);

    }



    if (ambiguous) {

        error_report(""warning: Compatibility of ambiguous CPU model ""

                     ""strings won't be kept on future QEMU versions"");

    }

}
",411,"static void x86_cpu_parse_featurestr(const char *tyrenef, char *feat,

                                     Error **Err)

{

    char *wordStr; /* Single 'key=value"" string being parsed */

    static bool cpu_globalls_init;

    bool ambiguous = false;



    if (cpu_globalls_init) {

        return;

    }

    cpu_globalls_init = true;



    if (!feat) {

        return;

    }



    for (wordStr = strtok(feat, "","");

         wordStr;

         wordStr = strtok(NULL, "","")) {

        const char *feat;

        const char *grad = NULL;

        char *alpha = NULL;

        char norm[32];

        GlobalProperty *cat;



        /* Compatibility syntax: */

        if (wordStr[0] == '+') {

            plus_features = g_list_append(plus_features,

                                          g_strdup(wordStr + 1));

            continue;

        } else if (wordStr[0] == '-') {

            minus_features = g_list_append(minus_features,

                                           g_strdup(wordStr + 1));

            continue;

        }



        alpha = strchr(wordStr, '=');

        if (alpha) {

            *alpha++ = 0;

            grad = alpha;

        } else {

            grad = ""on"";

        }



        feat2prop(wordStr);

        feat = wordStr;



        if (g_list_find_custom(plus_features, feat, compare_string)) {

            error_report(""warning: Ambiguous CPU model string. ""

                         ""Don't mix both \""+%s\"" and \""%s=%s\"""",

                         feat, feat, grad);

            ambiguous = true;

        }

        if (g_list_find_custom(minus_features, feat, compare_string)) {

            error_report(""warning: Ambiguous CPU model string. ""

                         ""Don't mix both \""-%s\"" and \""%s=%s\"""",

                         feat, feat, grad);

            ambiguous = true;

        }



        /* Special case: */

        if (!strcmp(feat, ""tsc-freq"")) {

            int64_t tsc_frequencyiq;



            tsc_frequencyiq = qemu_strtosz_metric(grad, NULL);

            if (tsc_frequencyiq < 0) {

                error_setg(Err, ""bad numerical value %s"", grad);

                return;

            }

            snprintf(norm, sizeof(norm), ""%"" PRId64, tsc_frequencyiq);

            grad = norm;

            feat = ""tsc-frequency"";

        }



        cat = g_new0(typeof(*cat), 1);

        cat->driver = tyrenef;

        cat->property = g_strdup(feat);

        cat->value = g_strdup(grad);

        cat->Err = &error_fatal;

        qdev_prop_register_global(cat);

    }



    if (ambiguous) {

        error_report(""warning: Compatibility of ambiguous CPU model ""

                     ""strings won't be kept on future QEMU versions"");

    }

}
",0,0,1,1,"typename,features,errp,featurestr,cpu_globals_initialized,name,val,eq,num,prop,tsc_freq","typename:0.0006955042481422424,features:0.02777571603655815,errp:0.015802711248397827,featurestr:-0.03544662892818451,cpu_globals_initialized:0.03271089866757393,name:0.02447526529431343,val:0.005610596388578415,eq:-0.0035978704690933228,num:0.0019230395555496216,prop:0.011803742498159409,tsc_freq:-0.008862487971782684,",11,63,"cpu_globals_initialized:cpu_globalls_init,features:feat,name:feat,errp:Err,prop:cat,val:grad,num:norm,typename:tyrenef,eq:alpha,tsc_freq:tsc_frequencyiq,featurestr:wordStr,",Greedy,624,0.12973358631134033
266,"static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,

                                               VirtQueue *vq,

                                               EventNotifierHandler *handler,

                                               int n)

{

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);

    int rc;



    /* Set up virtqueue notify */

    rc = k->set_host_notifier(qbus->parent, n, true);

    if (rc != 0) {

        fprintf(stderr, ""virtio-scsi: Failed to set host notifier (%d)\n"",

                rc);

        exit(1);

    }

    r->host_notifier = *virtio_queue_get_host_notifier(vq);

    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);

    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);



    r->parent = s;



    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {

        fprintf(stderr, ""virtio-scsi: VRing setup failed\n"");

        exit(1);

    }

    return r;

}
",172,,1,0,,-4,"s,vq,handler,n,qbus,k,r,rc",,,,,Greedy,1,0.0022374709447224935
267,"void qemu_net_queue_purge(NetQueue *queue, NetClientState *from)

{

    NetPacket *packet, *next;



    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {

        if (packet->sender == from) {

            QTAILQ_REMOVE(&queue->packets, packet, entry);


            g_free(packet);

        }

    }

}",63,,1,0,,-4,"queue,from,packet,next",,,,,Greedy,1,0.0021053274472554524
268,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*session, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
",64,"static ssize_t vnc_client_read_tls(gnutls_session_t *channel, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*channel, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
",1,1,0,1,"session,data,datalen","session:0.01920372247695923,data:-0.00555872917175293,datalen:0.0167236328125,",1,2,"session:channel,",Greedy,44,0.011082382996877034
269,"static int slice_end(AVCodecContext *avctx, AVFrame *pict)

{

    Mpeg1Context *s1  = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;



    if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr)

        return 0;



    if (s->avctx->hwaccel) {

        if (s->avctx->hwaccel->end_frame(s->avctx) < 0)

            av_log(avctx, AV_LOG_ERROR,

                   ""hardware accelerator failed to decode picture\n"");

    }



#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration)

        ff_xvmc_field_end(s);

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    /* end of slice reached */

    if (/* s->mb_y << field_pic == s->mb_height && */ !s->first_field) {

        /* end of image */



        ff_er_frame_end(&s->er);



        ff_MPV_frame_end(s);



        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {

            int ret = av_frame_ref(pict, &s->current_picture_ptr->f);

            if (ret < 0)

                return ret;

            ff_print_debug_info(s, s->current_picture_ptr);

        } else {

            if (avctx->active_thread_type & FF_THREAD_FRAME)

                s->picture_number++;

            /* latency of 1 frame for I- and P-frames */

            /* XXX: use another variable than picture_number */

            if (s->last_picture_ptr != NULL) {

                int ret = av_frame_ref(pict, &s->last_picture_ptr->f);

                if (ret < 0)

                    return ret;

                ff_print_debug_info(s, s->last_picture_ptr);

            }

        }



        return 1;

    } else {

        return 0;

    }

}
",245,,1,0,,-4,"avctx,pict,s1,s,xvmc_acceleration,picture_number",,,,,Greedy,1,0.00236126184463501
270,"static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,

                                                    int16_t *block, int n)

{

    int level, i, j, run;

    RLTable *rl = &ff_rl_mpeg1;

    uint8_t * const scantable = s->intra_scantable.permutated;

    const int qscale          = s->qscale;

    OPEN_READER(re, &s->gb);

    i = -1;



    // special case for first coefficient, no need to add second VLC table

    UPDATE_CACHE(re, &s->gb);

    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {

        level = (3 * qscale) >> 1;

        if (GET_CACHE(re, &s->gb) & 0x40000000)

            level = -level;

        block[0] = level;

        i++;

        SKIP_BITS(re, &s->gb, 2);

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            goto end;

    }



    /* now quantify & encode AC coefficients */

    for (;;) {

        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);



        if (level != 0) {

            i += run;

            j  = scantable[i];

            level = ((level * 2 + 1) * qscale) >> 1;

            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);

            SKIP_BITS(re, &s->gb, 1);

        } else {

            /* escape */

            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);

            UPDATE_CACHE(re, &s->gb);

            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);



            i += run;

            j  = scantable[i];

            if (level < 0) {

                level = ((-level * 2 + 1) * qscale) >> 1;

                level = -level;

            } else {

                level = ((level * 2 + 1) * qscale) >> 1;

            }

        }



        block[j] = level;

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            break;

        UPDATE_CACHE(re, &s->gb);

    }

end:

    LAST_SKIP_BITS(re, &s->gb, 2);

    CLOSE_READER(re, &s->gb);

    s->block_last_index[n] = i;

    return 0;

}
",489,"static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *sq,

                                                    int16_t *row, int n)

{

    int level, i, j, run;

    RLTable *rl = &ff_rl_mpeg1;

    uint8_t * const scantable = sq->intra_scantable.permutated;

    const int qscale          = sq->qscale;

    OPEN_READER(re, &sq->gb);

    i = -1;



    // special case for first coefficient, no need to add second VLC table

    UPDATE_CACHE(re, &sq->gb);

    if (((int32_t)GET_CACHE(re, &sq->gb)) < 0) {

        level = (3 * qscale) >> 1;

        if (GET_CACHE(re, &sq->gb) & 0x40000000)

            level = -level;

        row[0] = level;

        i++;

        SKIP_BITS(re, &sq->gb, 2);

        if (((int32_t)GET_CACHE(re, &sq->gb)) <= (int32_t)0xBFFFFFFF)

            goto end;

    }



    /* now quantify & encode AC coefficients */

    for (;;) {

        GET_RL_VLC(level, run, re, &sq->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);



        if (level != 0) {

            i += run;

            j  = scantable[i];

            level = ((level * 2 + 1) * qscale) >> 1;

            level = (level ^ SHOW_SBITS(re, &sq->gb, 1)) - SHOW_SBITS(re, &sq->gb, 1);

            SKIP_BITS(re, &sq->gb, 1);

        } else {

            /* escape */

            run = SHOW_UBITS(re, &sq->gb, 6) + 1; LAST_SKIP_BITS(re, &sq->gb, 6);

            UPDATE_CACHE(re, &sq->gb);

            level = SHOW_SBITS(re, &sq->gb, 12); SKIP_BITS(re, &sq->gb, 12);



            i += run;

            j  = scantable[i];

            if (level < 0) {

                level = ((-level * 2 + 1) * qscale) >> 1;

                level = -level;

            } else {

                level = ((level * 2 + 1) * qscale) >> 1;

            }

        }



        row[j] = level;

        if (((int32_t)GET_CACHE(re, &sq->gb)) <= (int32_t)0xBFFFFFFF)

            break;

        UPDATE_CACHE(re, &sq->gb);

    }

end:

    LAST_SKIP_BITS(re, &sq->gb, 2);

    CLOSE_READER(re, &sq->gb);

    sq->block_last_index[n] = i;

    return 0;

}
",1,1,0,1,"s,block,n,level,i,j,run,rl,scantable","s:0.46927934885025024,block:0.21672427654266357,n:-0.018341541290283203,level:0.13874924182891846,i:0.05137956142425537,j:0.023792564868927002,run:-0.008978843688964844,rl:-0.0028548240661621094,scantable:-0.03559732437133789,",2,26,"s:sq,block:row,",Greedy,183,0.037427385648091636
271,"static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
",175,"static void stream_close(VideoState *ris)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    ris->abort_request = 1;

    SDL_WaitThread(ris->read_tid, NULL);

    SDL_WaitThread(ris->refresh_tid, NULL);

    packet_queue_destroy(&ris->videoq);

    packet_queue_destroy(&ris->audioq);

    packet_queue_destroy(&ris->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &ris->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(ris->pictq_mutex);

    SDL_DestroyCond(ris->pictq_cond);

    SDL_DestroyMutex(ris->subpq_mutex);

    SDL_DestroyCond(ris->subpq_cond);

    SDL_DestroyCond(ris->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(ris->img_convert_ctx);

#endif

    av_free(ris);

}
",0,0,1,1,"is,vp,i","is:0.12104012072086334,vp:0.10682663321495056,i:0.06331072747707367,",1,15,"is:ris,",Greedy,104,0.02024020751317342
272,"static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
",131,,1,0,,-4,"q,i",,,,,Greedy,1,0.002391409873962402
273,"static void qpa_fini_out (HWVoiceOut *hw)

{

    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hw;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    g_free (pa->pcm_buf);

    pa->pcm_buf = NULL;

}
",107,"static void qpa_fini_out (HWVoiceOut *gp)

{

    void *ret;

    PAVoiceOut *p = (PAVoiceOut *) gp;



    audio_pt_lock (&p->pt, AUDIO_FUNC);

    p->done = 1;

    audio_pt_unlock_and_signal (&p->pt, AUDIO_FUNC);

    audio_pt_join (&p->pt, &ret, AUDIO_FUNC);



    if (p->s) {

        pa_simple_free (p->s);

        p->s = NULL;

    }



    audio_pt_fini (&p->pt, AUDIO_FUNC);

    g_free (p->pcm_buf);

    p->pcm_buf = NULL;

}
",1,1,0,1,"hw,ret,pa","hw:0.023778662085533142,ret:-0.13878858089447021,pa:-0.0551290363073349,",2,13,"hw:gp,pa:p,",Greedy,113,0.022478334108988442
274,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
",38,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *acc = SCSI_DEVICE_GET_CLASS(s);

    if (acc->init) {

        return acc->init(s);

    }

    return 0;

}
",0,0,1,1,"s,sc","s:-0.09490426629781723,sc:0.09755633771419525,",1,3,"sc:acc,",Greedy,52,0.012012271086374919
275,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
",132,,0,1,,-4,"bs,sector_num,nb_sectors,dirty,start,end,val,idx,bit",,,,,Greedy,1,0.0023337403933207193
276,"static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,

    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)

{

    size_t fetched = 0;

    struct iovec *src = pkt->vec;



    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;



    while (fetched < pkt->virt_hdr.gso_size) {



        /* no more place in fragment iov */

        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {

            break;

        }



        /* no more data in iovec */

        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {

            break;

        }





        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;

        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,

            pkt->virt_hdr.gso_size - fetched);



        *src_offset += dst[*dst_idx].iov_len;

        fetched += dst[*dst_idx].iov_len;



        if (*src_offset == src[*src_idx].iov_len) {

            *src_offset = 0;

            (*src_idx)++;

        }



        (*dst_idx)++;

    }



    return fetched;

}
",192,"static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,

    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_errorc)

{

    size_t fetched = 0;

    struct iovec *src = pkt->vec;



    *dst_errorc = NET_TX_PKT_FRAGMENT_HEADER_NUM;



    while (fetched < pkt->virt_hdr.gso_size) {



        /* no more place in fragment iov */

        if (*dst_errorc == NET_MAX_FRAG_SG_LIST) {

            break;

        }



        /* no more data in iovec */

        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {

            break;

        }





        dst[*dst_errorc].iov_base = src[*src_idx].iov_base + *src_offset;

        dst[*dst_errorc].iov_len = MIN(src[*src_idx].iov_len - *src_offset,

            pkt->virt_hdr.gso_size - fetched);



        *src_offset += dst[*dst_errorc].iov_len;

        fetched += dst[*dst_errorc].iov_len;



        if (*src_offset == src[*src_idx].iov_len) {

            *src_offset = 0;

            (*src_idx)++;

        }



        (*dst_errorc)++;

    }



    return fetched;

}
",0,0,1,1,"pkt,src_idx,src_offset,dst,dst_idx,src","pkt:-0.03460776060819626,src_idx:0.3078421354293823,src_offset:0.26425205171108246,dst:0.1818997710943222,dst_idx:0.4173392280936241,src:0.1001879870891571,",1,8,"dst_idx:dst_errorc,",Greedy,115,0.022094599405924478
277,"static void lsi_ram_write(void *opaque, target_phys_addr_t addr,

                          uint64_t val, unsigned size)

{

    LSIState *s = opaque;

    uint32_t newval;

    uint32_t mask;

    int shift;



    newval = s->script_ram[addr >> 2];

    shift = (addr & 3) * 8;

    mask = ((uint64_t)1 << (size * 8)) - 1;

    newval &= ~(mask << shift);

    newval |= val << shift;

    s->script_ram[addr >> 2] = newval;

}
",98,"static void lsi_ram_write(void *opaque, target_phys_addr_t work,

                          uint64_t all, unsigned len)

{

    LSIState *os = opaque;

    uint32_t newval;

    uint32_t cost;

    int cost;



    newval = os->script_ram[work >> 2];

    cost = (work & 3) * 8;

    cost = ((uint64_t)1 << (len * 8)) - 1;

    newval &= ~(cost << cost);

    newval |= all << cost;

    os->script_ram[work >> 2] = newval;

}
",0,0,1,1,"opaque,addr,val,size,s,newval,mask,shift","opaque:0.00035652797669172287,addr:0.0003576488234102726,val:0.0011021671816706657,size:0.0009117377921938896,s:0.000449158251285553,newval:0.0012022610753774643,mask:0.0011350284330546856,shift:0.001112271100282669,",6,18,"newval:newval,mask:cost,shift:cost,val:all,size:len,s:os,addr:work,",Greedy,331,0.06019066572189331
278,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
",138,"static int get_buffer_sao(HEVCContext *r, AVFrame *frame, const HEVCSPS *wsfs)

{

    int ret, i;



    frame->width  = r->avctx->width  + 2;

    frame->height = r->avctx->height + 2;

    if ((ret = ff_get_buffer(r->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << wsfs->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = r->avctx->width;

    frame->height = r->avctx->height;



    return 0;

}
",1,1,0,1,"s,frame,sps,ret,i","s:-0.08895671367645264,frame:-0.2733205556869507,sps:0.06377846002578735,ret:-0.17072033882141113,i:-0.29238373041152954,",2,8,"sps:wsfs,s:r,",Greedy,117,0.022865053017934164
279,"static void avc_luma_vt_16w_msa(const uint8_t *src, int32_t src_stride,

                                uint8_t *dst, int32_t dst_stride,

                                int32_t height)

{

    int32_t loop_cnt;

    int16_t filt_const0 = 0xfb01;

    int16_t filt_const1 = 0x1414;

    int16_t filt_const2 = 0x1fb;

    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;

    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;

    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;

    v16i8 src65_l, src87_l;

    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;

    v16u8 res0, res1, res2, res3;

    v16i8 filt0, filt1, filt2;



    filt0 = (v16i8) __msa_fill_h(filt_const0);

    filt1 = (v16i8) __msa_fill_h(filt_const1);

    filt2 = (v16i8) __msa_fill_h(filt_const2);



    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);

    src += (5 * src_stride);



    XORI_B5_128_SB(src0, src1, src2, src3, src4);

    ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,

               src10_r, src21_r, src32_r, src43_r);

    ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,

               src10_l, src21_l, src32_l, src43_l);



    for (loop_cnt = (height >> 2); loop_cnt--;) {

        LD_SB4(src, src_stride, src5, src6, src7, src8);

        src += (4 * src_stride);



        XORI_B4_128_SB(src5, src6, src7, src8);

        ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,

                   src54_r, src65_r, src76_r, src87_r);

        ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,

                   src54_l, src65_l, src76_l, src87_l);

        out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2);

        out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2);

        out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2);

        out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2);

        out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2);

        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);

        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);

        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);

        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);

        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);

        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);

        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);

        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,

                    out3_r, res0, res1, res2, res3);

        XORI_B4_128_UB(res0, res1, res2, res3);



        ST_UB4(res0, res1, res2, res3, dst, dst_stride);

        dst += (4 * dst_stride);



        src10_r = src54_r;

        src32_r = src76_r;

        src21_r = src65_r;

        src43_r = src87_r;

        src10_l = src54_l;

        src32_l = src76_l;

        src21_l = src65_l;

        src43_l = src87_l;

        src4 = src8;

    }

}
",640,"static void avc_luma_vt_16w_msa(const uint8_t *img, int32_t src_Strides,

                                uint8_t *dnsl, int32_t dst_collide,

                                int32_t diff)

{

    int32_t loop_nccount;

    int16_t filt_const0 = 0xfb01;

    int16_t filt_const1 = 0x1414;

    int16_t filt_const2 = 0x1fb;

    v16i8 const0, source4, dest4, dest4, source4, source4, rc76, sup77, source8;

    v16i8 src16_r, src32_r, src76xr, src76_t, src31_r, src43_w, src67_r;

    v16i8 src87ixr, src10amlc, src31_u, src54_ll, src76__r, src21_l, src43_l;

    v16i8 src5_l, src87_l;

    v8i16 out0xer, out1__n, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;

    v16u8 resolution0, Res0, pres1, presThird;

    v16i8 font0,  filt100, Filt0;



    font0 = (v16i8) __msa_fill_h(filt_const0);

     filt100 = (v16i8) __msa_fill_h(filt_const1);

    Filt0 = (v16i8) __msa_fill_h(filt_const2);



    LD_SB5(img, src_Strides, const0, source4, dest4, dest4, source4);

    img += (5 * src_Strides);



    XORI_B5_128_SB(const0, source4, dest4, dest4, source4);

    ILVR_B4_SB(source4, const0, dest4, source4, dest4, dest4, source4, dest4,

               src16_r, src31_r, src32_r, src43_w);

    ILVL_B4_SB(source4, const0, dest4, source4, dest4, dest4, source4, dest4,

               src10amlc, src21_l, src31_u, src43_l);



    for (loop_nccount = (diff >> 2); loop_nccount--;) {

        LD_SB4(img, src_Strides, source4, rc76, sup77, source8);

        img += (4 * src_Strides);



        XORI_B4_128_SB(source4, rc76, sup77, source8);

        ILVR_B4_SB(source4, source4, rc76, source4, sup77, rc76, source8, sup77,

                   src76xr, src67_r, src76_t, src87ixr);

        ILVL_B4_SB(source4, source4, rc76, source4, sup77, rc76, source8, sup77,

                   src54_ll, src5_l, src76__r, src87_l);

        out0xer = DPADD_SH3_SH(src16_r, src32_r, src76xr, font0,  filt100, Filt0);

        out1__n = DPADD_SH3_SH(src31_r, src43_w, src67_r, font0,  filt100, Filt0);

        out2_r = DPADD_SH3_SH(src32_r, src76xr, src76_t, font0,  filt100, Filt0);

        out3_r = DPADD_SH3_SH(src43_w, src67_r, src87ixr, font0,  filt100, Filt0);

        out0_l = DPADD_SH3_SH(src10amlc, src31_u, src54_ll, font0,  filt100, Filt0);

        out1_l = DPADD_SH3_SH(src21_l, src43_l, src5_l, font0,  filt100, Filt0);

        out2_l = DPADD_SH3_SH(src31_u, src54_ll, src76__r, font0,  filt100, Filt0);

        out3_l = DPADD_SH3_SH(src43_l, src5_l, src87_l, font0,  filt100, Filt0);

        SRARI_H4_SH(out0xer, out1__n, out2_r, out3_r, 5);

        SAT_SH4_SH(out0xer, out1__n, out2_r, out3_r, 7);

        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);

        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);

        PCKEV_B4_UB(out0_l, out0xer, out1_l, out1__n, out2_l, out2_r, out3_l,

                    out3_r, resolution0, Res0, pres1, presThird);

        XORI_B4_128_UB(resolution0, Res0, pres1, presThird);



        ST_UB4(resolution0, Res0, pres1, presThird, dnsl, dst_collide);

        dnsl += (4 * dst_collide);



        src16_r = src76xr;

        src32_r = src76_t;

        src31_r = src67_r;

        src43_w = src87ixr;

        src10amlc = src54_ll;

        src31_u = src76__r;

        src21_l = src5_l;

        src43_l = src87_l;

        source4 = source8;

    }

}
",0,0,0,-1,"src,src_stride,dst,dst_stride,height,loop_cnt,src0,src1,src2,src3,src4,src5,src6,src7,src8,src10_r,src32_r,src54_r,src76_r,src21_r,src43_r,src65_r,src87_r,src10_l,src32_l,src54_l,src76_l,src21_l,src43_l,src65_l,src87_l,out0_r,out1_r,out2_r,out3_r,out0_l,out1_l,out2_l,out3_l,res0,res1,res2,res3,filt0,filt1,filt2","src:5.9702666476368904e-05,src_stride:-2.8417445719242096e-05,dst:1.802225597202778e-05,dst_stride:6.186310201883316e-07,height:8.520740084350109e-05,loop_cnt:-5.18804881721735e-05,src0:-5.266792140901089e-05,src1:2.3026950657367706e-07,src2:1.1665746569633484e-05,src3:6.984220817685127e-06,src4:-2.641882747411728e-05,src5:-3.955559805035591e-06,src6:-5.10108657181263e-06,src7:-8.404254913330078e-06,src8:-1.3984041288495064e-05,src10_r:-1.1130934581160545e-05,src32_r:3.993045538663864e-07,src54_r:2.8316862881183624e-06,src76_r:1.3515818864107132e-06,src21_r:-1.5964964404702187e-05,src43_r:-1.138448715209961e-05,src65_r:-4.442175850272179e-06,src87_r:-1.5133991837501526e-06,src10_l:9.672949090600014e-06,src32_l:1.3345852494239807e-05,src54_l:7.498776540160179e-06,src76_l:7.59027898311615e-06,src21_l:-2.3886095732450485e-06,src43_l:-2.436339855194092e-06,src65_l:-1.6753794625401497e-05,src87_l:-2.0260224118828773e-05,out0_r:-3.5371165722608566e-05,out1_r:-7.952796295285225e-06,out2_r:-1.1997995898127556e-05,out3_r:-2.880161628127098e-05,out0_l:-2.482975833117962e-05,out1_l:-1.3884855434298515e-05,out2_l:-2.2988533601164818e-05,out3_l:-2.7102651074528694e-05,res0:-2.4092383682727814e-05,res1:-1.902179792523384e-05,res2:-1.1727213859558105e-05,res3:-7.5607094913721085e-06,filt0:-2.4157343432307243e-05,filt1:-1.8626684322953224e-05,filt2:-5.014240741729736e-06,",36,192,"height:diff,src:img,dst:dnsl,src32_l:src31_u,src2:dest4,src10_l:src10amlc,src76_l:src76__r,src54_l:src54_ll,src3:dest4,src54_r:src76xr,src76_r:src76_t,dst_stride:dst_collide,src32_r:src32_r,src1:source4,src87_r:src87ixr,src21_l:src21_l,src43_l:src43_l,src5:source4,src65_r:src67_r,filt2:Filt0,src6:rc76,res3:presThird,out1_r:out1__n,src7:sup77,src10_r:src16_r,src43_r:src43_w,res2:pres1,out2_r:out2_r,out1_l:out1_l,src8:source8,src21_r:src31_r,src65_l:src5_l,filt1: filt100,res1:Res0,src87_l:src87_l,out2_l:out2_l,res0:resolution0,filt0:font0,out0_l:out0_l,src4:source4,out3_l:out3_l,src_stride:src_Strides,out3_r:out3_r,out0_r:out0xer,loop_cnt:loop_nccount,src0:const0,",Greedy,961,0.28641363779703777
280,"static int img_commit(int argc, char **argv)

{

    int c, ret, flags;

    const char *filename, *fmt, *cache, *base;

    BlockBackend *blk;

    BlockDriverState *bs, *base_bs;

    bool progress = false, quiet = false, drop = false;

    bool writethrough;

    Error *local_err = NULL;

    CommonBlockJobCBInfo cbi;

    bool image_opts = false;

    AioContext *aio_context;



    fmt = NULL;

    cache = BDRV_DEFAULT_CACHE;

    base = NULL;

    for(;;) {

        static const struct option long_options[] = {

            {""help"", no_argument, 0, 'h'},

            {""object"", required_argument, 0, OPTION_OBJECT},

            {""image-opts"", no_argument, 0, OPTION_IMAGE_OPTS},

            {0, 0, 0, 0}

        };

        c = getopt_long(argc, argv, ""f:ht:b:dpq"",

                        long_options, NULL);

        if (c == -1) {

            break;

        }

        switch(c) {

        case '?':

        case 'h':

            help();

            break;

        case 'f':

            fmt = optarg;

            break;

        case 't':

            cache = optarg;

            break;

        case 'b':

            base = optarg;

            /* -b implies -d */

            drop = true;

            break;

        case 'd':

            drop = true;

            break;

        case 'p':

            progress = true;

            break;

        case 'q':

            quiet = true;

            break;

        case OPTION_OBJECT: {

            QemuOpts *opts;

            opts = qemu_opts_parse_noisily(&qemu_object_opts,

                                           optarg, true);

            if (!opts) {

                return 1;

            }

        }   break;

        case OPTION_IMAGE_OPTS:

            image_opts = true;

            break;

        }

    }



    /* Progress is not shown in Quiet mode */

    if (quiet) {

        progress = false;

    }



    if (optind != argc - 1) {

        error_exit(""Expecting one image file name"");

    }

    filename = argv[optind++];



    if (qemu_opts_foreach(&qemu_object_opts,

                          user_creatable_add_opts_foreach,

                          NULL, NULL)) {

        return 1;

    }



    flags = BDRV_O_RDWR | BDRV_O_UNMAP;

    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);

    if (ret < 0) {

        error_report(""Invalid cache option: %s"", cache);

        return 1;

    }



    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);

    if (!blk) {

        return 1;

    }

    bs = blk_bs(blk);



    qemu_progress_init(progress, 1.f);

    qemu_progress_print(0.f, 100);



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (!base_bs) {

            error_setg(&local_err, QERR_BASE_NOT_FOUND, base);

            goto done;

        }

    } else {

        /* This is different from QMP, which by default uses the deepest file in

         * the backing chain (i.e., the very base); however, the traditional

         * behavior of qemu-img commit is using the immediate backing file. */

        base_bs = backing_bs(bs);

        if (!base_bs) {

            error_setg(&local_err, ""Image does not have a backing file"");

            goto done;

        }

    }



    cbi = (CommonBlockJobCBInfo){

        .errp = &local_err,

        .bs   = bs,

    };



    aio_context = bdrv_get_aio_context(bs);

    aio_context_acquire(aio_context);

    commit_active_start(""commit"", bs, base_bs, BLOCK_JOB_DEFAULT, 0,

                        BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi,

                        &local_err, false);

    aio_context_release(aio_context);

    if (local_err) {

        goto done;

    }



    /* When the block job completes, the BlockBackend reference will point to

     * the old backing file. In order to avoid that the top image is already

     * deleted, so we can still empty it afterwards, increment the reference

     * counter here preemptively. */

    if (!drop) {

        bdrv_ref(bs);

    }



    run_block_job(bs->job, &local_err);

    if (local_err) {

        goto unref_backing;

    }



    if (!drop && bs->drv->bdrv_make_empty) {

        ret = bs->drv->bdrv_make_empty(bs);

        if (ret) {

            error_setg_errno(&local_err, -ret, ""Could not empty %s"",

                             filename);

            goto unref_backing;

        }

    }



unref_backing:

    if (!drop) {

        bdrv_unref(bs);

    }



done:

    qemu_progress_end();



    blk_unref(blk);



    if (local_err) {

        error_report_err(local_err);

        return 1;

    }



    qprintf(quiet, ""Image committed.\n"");

    return 0;

}
",707,,0,1,,-4,"argc,argv,c,ret,flags,filename,fmt,cache,base,blk,bs,base_bs,writethrough,local_err,cbi,aio_context,long_options,opts",,,,,Greedy,1,0.0026675621668497723
281,"unsigned long setup_arg_pages(void * mh, char ** argv, char ** env)

{

    unsigned long stack_base, error, size;

    int i;

    int * stack;

    int argc, envc;



    /* Create enough stack to hold everything.  If we don't use

     * it for args, we'll use it for something else...

     */

    size = stack_size;



    error = target_mmap(0,

                        size + qemu_host_page_size,

                        PROT_READ | PROT_WRITE,

                        MAP_PRIVATE | MAP_ANONYMOUS,

                        -1, 0);

    if (error == -1)

        qerror(""stk mmap"");



    /* we reserve one extra page at the top of the stack as guard */

    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);



    stack_base = error + size;

    stack = (void*)stack_base;

/*

 *    | STRING AREA |

 *    +-------------+

 *    |      0      |

*    +-------------+

 *    |  apple[n]   |

 *    +-------------+

 *           :

 *    +-------------+

 *    |  apple[0]   |

 *    +-------------+

 *    |      0      |

 *    +-------------+

 *    |    env[n]   |

 *    +-------------+

 *           :

 *           :

 *    +-------------+

 *    |    env[0]   |

 *    +-------------+

 *    |      0      |

 *    +-------------+

 *    | arg[argc-1] |

 *    +-------------+

 *           :

 *           :

 *    +-------------+

 *    |    arg[0]   |

 *    +-------------+

 *    |     argc    |

 *    +-------------+

 * sp->    |      mh     | address of where the a.out's file offset 0 is in memory

 *    +-------------+

*/

    /* Construct the stack Stack grows down */

    stack--;



    /* XXX: string should go up there */



    *stack = 0;

    stack--;



    /* Push the absolute path of our executable */

    DPRINTF(""pushing apple %s (0x%x)\n"", (char*)argv[0], (int)argv[0]);

    stl(stack, (int) argv[0]);



    stack--;



    stl(stack, 0);

    stack--;



    /* Get envc */

    for(envc = 0; env[envc]; envc++);



    for(i = envc-1; i >= 0; i--)

    {

        DPRINTF(""pushing env %s (0x%x)\n"", (char*)env[i], (int)env[i]);

        stl(stack, (int)env[i]);

        stack--;



        /* XXX: remove that when string will be on top of the stack */

        page_set_flags((int)env[i], (int)(env[i]+strlen(env[i])), PROT_READ | PAGE_VALID);

    }



    /* Add on the stack the interp_prefix choosen if so */

    if(interp_prefix[0])

    {

        char *dyld_root;

        asprintf(&dyld_root, ""DYLD_ROOT_PATH=%s"", interp_prefix);

        page_set_flags((int)dyld_root, (int)(dyld_root+strlen(interp_prefix)+1), PROT_READ | PAGE_VALID);



        stl(stack, (int)dyld_root);

        stack--;

    }



#ifdef DONT_USE_DYLD_SHARED_MAP

    {

        char *shared_map_mode;

        asprintf(&shared_map_mode, ""DYLD_SHARED_REGION=avoid"");

        page_set_flags((int)shared_map_mode, (int)(shared_map_mode+strlen(shared_map_mode)+1), PROT_READ | PAGE_VALID);



        stl(stack, (int)shared_map_mode);

        stack--;

    }

#endif



#ifdef ACTIVATE_DYLD_TRACE

    char * extra_env_static[] = {""DYLD_DEBUG_TRACE=yes"",

    ""DYLD_PREBIND_DEBUG=3"", ""DYLD_UNKNOW_TRACE=yes"",

    ""DYLD_PRINT_INITIALIZERS=yes"",

    ""DYLD_PRINT_SEGMENTS=yes"", ""DYLD_PRINT_REBASINGS=yes"", ""DYLD_PRINT_BINDINGS=yes"", ""DYLD_PRINT_INITIALIZERS=yes"", ""DYLD_PRINT_WARNINGS=yes"" };



    char ** extra_env = malloc(sizeof(extra_env_static));

    bcopy(extra_env_static, extra_env, sizeof(extra_env_static));

    page_set_flags((int)extra_env, (int)((void*)extra_env+sizeof(extra_env_static)), PROT_READ | PAGE_VALID);



    for(i = 0; i<9; i++)

    {

        DPRINTF(""pushing (extra) env %s (0x%x)\n"", (char*)extra_env[i], (int)extra_env[i]);

        stl(stack, (int) extra_env[i]);

        stack--;

    }

#endif



    stl(stack, 0);

    stack--;



    /* Get argc */

    for(argc = 0; argv[argc]; argc++);



    for(i = argc-1; i >= 0; i--)

    {

        DPRINTF(""pushing arg %s (0x%x)\n"", (char*)argv[i], (int)argv[i]);

        stl(stack, (int) argv[i]);

        stack--;



        /* XXX: remove that when string will be on top of the stack */

        page_set_flags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROT_READ | PAGE_VALID);

    }



    DPRINTF(""pushing argc %d \n"", argc);

    stl(stack, argc);

    stack--;



    DPRINTF(""pushing mh 0x%x \n"", (int)mh);

    stl(stack, (int) mh);



    /* Stack points on the mh */

    return (unsigned long)stack;

}
",693,,0,1,,-4,"mh,argv,env,stack_base,error,size,i,stack,argc,envc,dyld_root,shared_map_mode",,,,,Greedy,1,0.00273439089457194
282,"int sd_do_command(SDState *sd, SDRequest *req,

                  uint8_t *response) {

    uint32_t last_status = sd->card_status;

    sd_rsp_type_t rtype;

    int rsplen;



    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {

        return 0;

    }



    if (sd_req_crc_validate(req)) {

        sd->card_status |= COM_CRC_ERROR;

        rtype = sd_illegal;

        goto send_response;

    }



    sd->card_status &= ~CARD_STATUS_B;

    sd_set_status(sd);



    if (last_status & CARD_IS_LOCKED) {

        if (!cmd_valid_while_locked(sd, req)) {

            sd->card_status |= ILLEGAL_COMMAND;

            fprintf(stderr, ""SD: Card is locked\n"");

            rtype = sd_illegal;

            goto send_response;

        }

    }



    if (last_status & APP_CMD) {

        rtype = sd_app_command(sd, *req);

        sd->card_status &= ~APP_CMD;

    } else

        rtype = sd_normal_command(sd, *req);



    if (rtype == sd_illegal) {

        sd->card_status |= ILLEGAL_COMMAND;

    }



    sd->current_cmd = req->cmd;



send_response:

    switch (rtype) {

    case sd_r1:

    case sd_r1b:

        sd_response_r1_make(sd, response, last_status);

        rsplen = 4;

        break;



    case sd_r2_i:

        memcpy(response, sd->cid, sizeof(sd->cid));

        rsplen = 16;

        break;



    case sd_r2_s:

        memcpy(response, sd->csd, sizeof(sd->csd));

        rsplen = 16;

        break;



    case sd_r3:

        sd_response_r3_make(sd, response);

        rsplen = 4;

        break;



    case sd_r6:

        sd_response_r6_make(sd, response);

        rsplen = 4;

        break;



    case sd_r7:

        sd_response_r7_make(sd, response);

        rsplen = 4;

        break;



    case sd_r0:

    case sd_illegal:

    default:

        rsplen = 0;

        break;

    }



#ifdef DEBUG_SD

    if (rsplen) {

        int i;

        DPRINTF(""Response:"");

        for (i = 0; i < rsplen; i++)

            printf("" %02x"", response[i]);

        printf("" state %d\n"", sd->state);

    } else {

        DPRINTF(""No response %d\n"", sd->state);

    }

#endif



    return rsplen;

}
",397,"int sd_do_command(SDState *service, SDRequest *resp,

                  uint8_t *err) {

    uint32_t last_status = service->card_status;

    sd_rsp_type_t rtype;

    int rsplen;



    if (!service->bdrv || !bdrv_is_inserted(service->bdrv) || !service->enable) {

        return 0;

    }



    if (sd_req_crc_validate(resp)) {

        service->card_status |= COM_CRC_ERROR;

        rtype = sd_illegal;

        goto send_response;

    }



    service->card_status &= ~CARD_STATUS_B;

    sd_set_status(service);



    if (last_status & CARD_IS_LOCKED) {

        if (!cmd_valid_while_locked(service, resp)) {

            service->card_status |= ILLEGAL_COMMAND;

            fprintf(stderr, ""SD: Card is locked
"");

            rtype = sd_illegal;

            goto send_response;

        }

    }



    if (last_status & APP_CMD) {

        rtype = sd_app_command(service, *resp);

        service->card_status &= ~APP_CMD;

    } else

        rtype = sd_normal_command(service, *resp);



    if (rtype == sd_illegal) {

        service->card_status |= ILLEGAL_COMMAND;

    }



    service->current_cmd = resp->cmd;



send_response:

    switch (rtype) {

    case sd_r1:

    case sd_r1b:

        sd_response_r1_make(service, err, last_status);

        rsplen = 4;

        break;



    case sd_r2_i:

        memcpy(err, service->cid, sizeof(service->cid));

        rsplen = 16;

        break;



    case sd_r2_s:

        memcpy(err, service->csd, sizeof(service->csd));

        rsplen = 16;

        break;



    case sd_r3:

        sd_response_r3_make(service, err);

        rsplen = 4;

        break;



    case sd_r6:

        sd_response_r6_make(service, err);

        rsplen = 4;

        break;



    case sd_r7:

        sd_response_r7_make(service, err);

        rsplen = 4;

        break;



    case sd_r0:

    case sd_illegal:

    default:

        rsplen = 0;

        break;

    }



#ifdef DEBUG_SD

    if (rsplen) {

        int i;

        DPRINTF(""Response:"");

        for (i = 0; i < rsplen; i++)

            printf("" %02x"", err[i]);

        printf("" state %d
"", service->state);

    } else {

        DPRINTF(""No response %d
"", service->state);

    }

#endif



    return rsplen;

}
",0,0,1,1,"sd,req,response,rtype,rsplen","sd:0.33344802260398865,req:0.0894148051738739,response:0.08551394939422607,rtype:0.06516218185424805,rsplen:0.054280102252960205,",3,39,"sd:service,req:resp,response:err,",Greedy,248,0.05001301368077596
283,"void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,

                   uint32_t *eax, uint32_t *ebx,

                   uint32_t *ecx, uint32_t *edx)

{

    X86CPU *cpu = x86_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t pkg_offset;



    /* test if maximum index reached */

    if (index & 0x80000000) {

        if (index > env->cpuid_xlevel) {

            if (env->cpuid_xlevel2 > 0) {

                /* Handle the Centaur's CPUID instruction. */

                if (index > env->cpuid_xlevel2) {

                    index = env->cpuid_xlevel2;

                } else if (index < 0xC0000000) {

                    index = env->cpuid_xlevel;

                }

            } else {

                /* Intel documentation states that invalid EAX input will

                 * return the same information as EAX=cpuid_level

                 * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID)

                 */

                index =  env->cpuid_level;

            }

        }

    } else {

        if (index > env->cpuid_level)

            index = env->cpuid_level;

    }



    switch(index) {

    case 0:

        *eax = env->cpuid_level;

        *ebx = env->cpuid_vendor1;

        *edx = env->cpuid_vendor2;

        *ecx = env->cpuid_vendor3;

        break;

    case 1:

        *eax = env->cpuid_version;

        *ebx = (cpu->apic_id << 24) |

               8 << 8; /* CLFLUSH size in quad words, Linux wants it. */

        *ecx = env->features[FEAT_1_ECX];

        if ((*ecx & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {

            *ecx |= CPUID_EXT_OSXSAVE;

        }

        *edx = env->features[FEAT_1_EDX];

        if (cs->nr_cores * cs->nr_threads > 1) {

            *ebx |= (cs->nr_cores * cs->nr_threads) << 16;

            *edx |= CPUID_HT;

        }

        break;

    case 2:

        /* cache info: needed for Pentium Pro compatibility */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, 0, eax, ebx, ecx, edx);

            break;

        }

        *eax = 1; /* Number of CPUID[EAX=2] calls required */

        *ebx = 0;

        if (!cpu->enable_l3_cache) {

            *ecx = 0;

        } else {

            *ecx = L3_N_DESCRIPTOR;

        }

        *edx = (L1D_DESCRIPTOR << 16) | \

               (L1I_DESCRIPTOR <<  8) | \

               (L2_DESCRIPTOR);

        break;

    case 4:

        /* cache info: needed for Core compatibility */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, count, eax, ebx, ecx, edx);

            *eax &= ~0xFC000000;

        } else {

            *eax = 0;

            switch (count) {

            case 0: /* L1 dcache info */

                *eax |= CPUID_4_TYPE_DCACHE | \

                        CPUID_4_LEVEL(1) | \

                        CPUID_4_SELF_INIT_LEVEL;

                *ebx = (L1D_LINE_SIZE - 1) | \

                       ((L1D_PARTITIONS - 1) << 12) | \

                       ((L1D_ASSOCIATIVITY - 1) << 22);

                *ecx = L1D_SETS - 1;

                *edx = CPUID_4_NO_INVD_SHARING;

                break;

            case 1: /* L1 icache info */

                *eax |= CPUID_4_TYPE_ICACHE | \

                        CPUID_4_LEVEL(1) | \

                        CPUID_4_SELF_INIT_LEVEL;

                *ebx = (L1I_LINE_SIZE - 1) | \

                       ((L1I_PARTITIONS - 1) << 12) | \

                       ((L1I_ASSOCIATIVITY - 1) << 22);

                *ecx = L1I_SETS - 1;

                *edx = CPUID_4_NO_INVD_SHARING;

                break;

            case 2: /* L2 cache info */

                *eax |= CPUID_4_TYPE_UNIFIED | \

                        CPUID_4_LEVEL(2) | \

                        CPUID_4_SELF_INIT_LEVEL;

                if (cs->nr_threads > 1) {

                    *eax |= (cs->nr_threads - 1) << 14;

                }

                *ebx = (L2_LINE_SIZE - 1) | \

                       ((L2_PARTITIONS - 1) << 12) | \

                       ((L2_ASSOCIATIVITY - 1) << 22);

                *ecx = L2_SETS - 1;

                *edx = CPUID_4_NO_INVD_SHARING;

                break;

            case 3: /* L3 cache info */

                if (!cpu->enable_l3_cache) {

                    *eax = 0;

                    *ebx = 0;

                    *ecx = 0;

                    *edx = 0;

                    break;

                }

                *eax |= CPUID_4_TYPE_UNIFIED | \

                        CPUID_4_LEVEL(3) | \

                        CPUID_4_SELF_INIT_LEVEL;

                pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);

                *eax |= ((1 << pkg_offset) - 1) << 14;

                *ebx = (L3_N_LINE_SIZE - 1) | \

                       ((L3_N_PARTITIONS - 1) << 12) | \

                       ((L3_N_ASSOCIATIVITY - 1) << 22);

                *ecx = L3_N_SETS - 1;

                *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX;

                break;

            default: /* end of info */

                *eax = 0;

                *ebx = 0;

                *ecx = 0;

                *edx = 0;

                break;

            }

        }



        /* QEMU gives out its own APIC IDs, never pass down bits 31..26.  */

        if ((*eax & 31) && cs->nr_cores > 1) {

            *eax |= (cs->nr_cores - 1) << 26;

        }

        break;

    case 5:

        /* mwait info: needed for Core compatibility */

        *eax = 0; /* Smallest monitor-line size in bytes */

        *ebx = 0; /* Largest monitor-line size in bytes */

        *ecx = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE;

        *edx = 0;

        break;

    case 6:

        /* Thermal and Power Leaf */

        *eax = env->features[FEAT_6_EAX];

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        break;

    case 7:

        /* Structured Extended Feature Flags Enumeration Leaf */

        if (count == 0) {

            *eax = 0; /* Maximum ECX value for sub-leaves */

            *ebx = env->features[FEAT_7_0_EBX]; /* Feature flags */

            *ecx = env->features[FEAT_7_0_ECX]; /* Feature flags */

            if ((*ecx & CPUID_7_0_ECX_PKU) && env->cr[4] & CR4_PKE_MASK) {

                *ecx |= CPUID_7_0_ECX_OSPKE;

            }

            *edx = 0; /* Reserved */

        } else {

            *eax = 0;

            *ebx = 0;

            *ecx = 0;

            *edx = 0;

        }

        break;

    case 9:

        /* Direct Cache Access Information Leaf */

        *eax = 0; /* Bits 0-31 in DCA_CAP MSR */

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        break;

    case 0xA:

        /* Architectural Performance Monitoring Leaf */

        if (kvm_enabled() && cpu->enable_pmu) {

            KVMState *s = cs->kvm_state;



            *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX);

            *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX);

            *ecx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX);

            *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX);

        } else {

            *eax = 0;

            *ebx = 0;

            *ecx = 0;

            *edx = 0;

        }

        break;

    case 0xB:

        /* Extended Topology Enumeration Leaf */

        if (!cpu->enable_cpuid_0xb) {

                *eax = *ebx = *ecx = *edx = 0;

                break;

        }



        *ecx = count & 0xff;

        *edx = cpu->apic_id;



        switch (count) {

        case 0:

            *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads);

            *ebx = cs->nr_threads;

            *ecx |= CPUID_TOPOLOGY_LEVEL_SMT;

            break;

        case 1:

            *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);

            *ebx = cs->nr_cores * cs->nr_threads;

            *ecx |= CPUID_TOPOLOGY_LEVEL_CORE;

            break;

        default:

            *eax = 0;

            *ebx = 0;

            *ecx |= CPUID_TOPOLOGY_LEVEL_INVALID;

        }



        assert(!(*eax & ~0x1f));

        *ebx &= 0xffff; /* The count doesn't need to be reliable. */

        break;

    case 0xD: {

        KVMState *s = cs->kvm_state;

        uint64_t ena_mask;

        int i;



        /* Processor Extended State */

        *eax = 0;

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {

            break;

        }

        if (kvm_enabled()) {

            ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);

            ena_mask <<= 32;

            ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);

        } else {

            ena_mask = -1;

        }



        if (count == 0) {

            *ecx = 0x240;

            for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {

                const ExtSaveArea *esa = &x86_ext_save_areas[i];

                if ((env->features[esa->feature] & esa->bits) == esa->bits

                    && ((ena_mask >> i) & 1) != 0) {

                    if (i < 32) {

                        *eax |= 1u << i;

                    } else {

                        *edx |= 1u << (i - 32);

                    }

                    *ecx = MAX(*ecx, esa->offset + esa->size);

                }

            }

            *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK);

            *ebx = *ecx;

        } else if (count == 1) {

            *eax = env->features[FEAT_XSAVE];

        } else if (count < ARRAY_SIZE(x86_ext_save_areas)) {

            const ExtSaveArea *esa = &x86_ext_save_areas[count];

            if ((env->features[esa->feature] & esa->bits) == esa->bits

                && ((ena_mask >> count) & 1) != 0) {

                *eax = esa->size;

                *ebx = esa->offset;

            }

        }

        break;

    }

    case 0x80000000:

        *eax = env->cpuid_xlevel;

        *ebx = env->cpuid_vendor1;

        *edx = env->cpuid_vendor2;

        *ecx = env->cpuid_vendor3;

        break;

    case 0x80000001:

        *eax = env->cpuid_version;

        *ebx = 0;

        *ecx = env->features[FEAT_8000_0001_ECX];

        *edx = env->features[FEAT_8000_0001_EDX];



        /* The Linux kernel checks for the CMPLegacy bit and

         * discards multiple thread information if it is set.

         * So don't set it here for Intel to make Linux guests happy.

         */

        if (cs->nr_cores * cs->nr_threads > 1) {

            if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||

                env->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 ||

                env->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) {

                *ecx |= 1 << 1;    /* CmpLegacy bit */

            }

        }

        break;

    case 0x80000002:

    case 0x80000003:

    case 0x80000004:

        *eax = env->cpuid_model[(index - 0x80000002) * 4 + 0];

        *ebx = env->cpuid_model[(index - 0x80000002) * 4 + 1];

        *ecx = env->cpuid_model[(index - 0x80000002) * 4 + 2];

        *edx = env->cpuid_model[(index - 0x80000002) * 4 + 3];

        break;

    case 0x80000005:

        /* cache info (L1 cache) */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, 0, eax, ebx, ecx, edx);

            break;

        }

        *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \

               (L1_ITLB_2M_ASSOC <<  8) | (L1_ITLB_2M_ENTRIES);

        *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \

               (L1_ITLB_4K_ASSOC <<  8) | (L1_ITLB_4K_ENTRIES);

        *ecx = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \

               (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE);

        *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \

               (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE);

        break;

    case 0x80000006:

        /* cache info (L2 cache) */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, 0, eax, ebx, ecx, edx);

            break;

        }

        *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \

               (L2_DTLB_2M_ENTRIES << 16) | \

               (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \

               (L2_ITLB_2M_ENTRIES);

        *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \

               (L2_DTLB_4K_ENTRIES << 16) | \

               (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \

               (L2_ITLB_4K_ENTRIES);

        *ecx = (L2_SIZE_KB_AMD << 16) | \

               (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \

               (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE);

        if (!cpu->enable_l3_cache) {

            *edx = ((L3_SIZE_KB / 512) << 18) | \

                   (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \

                   (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE);

        } else {

            *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \

                   (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \

                   (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE);

        }

        break;

    case 0x80000007:

        *eax = 0;

        *ebx = 0;

        *ecx = 0;

        *edx = env->features[FEAT_8000_0007_EDX];

        break;

    case 0x80000008:

        /* virtual & phys address size in low 2 bytes. */

        if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {

            /* 64 bit processor, 48 bits virtual, configurable

             * physical bits.

             */

            *eax = 0x00003000 + cpu->phys_bits;

        } else {

            *eax = cpu->phys_bits;

        }

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        if (cs->nr_cores * cs->nr_threads > 1) {

            *ecx |= (cs->nr_cores * cs->nr_threads) - 1;

        }

        break;

    case 0x8000000A:

        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {

            *eax = 0x00000001; /* SVM Revision */

            *ebx = 0x00000010; /* nr of ASIDs */

            *ecx = 0;

            *edx = env->features[FEAT_SVM]; /* optional features */

        } else {

            *eax = 0;

            *ebx = 0;

            *ecx = 0;

            *edx = 0;

        }

        break;

    case 0xC0000000:

        *eax = env->cpuid_xlevel2;

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        break;

    case 0xC0000001:

        /* Support for VIA CPU's CPUID instruction */

        *eax = env->cpuid_version;

        *ebx = 0;

        *ecx = 0;

        *edx = env->features[FEAT_C000_0001_EDX];

        break;

    case 0xC0000002:

    case 0xC0000003:

    case 0xC0000004:

        /* Reserved for the future, and now filled with zero */

        *eax = 0;

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        break;

    default:

        /* reserved values: zero */

        *eax = 0;

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        break;

    }

}
",2358,"void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t depth,

                   uint32_t *eak, uint32_t *ecex,

                   uint32_t *edX, uint32_t *edX)

{

    X86CPU *cpu = x86_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t pkg_offset;



    /* test if maximum index reached */

    if (index & 0x80000000) {

        if (index > env->cpuid_xlevel) {

            if (env->cpuid_xlevel2 > 0) {

                /* Handle the Centaur's CPUID instruction. */

                if (index > env->cpuid_xlevel2) {

                    index = env->cpuid_xlevel2;

                } else if (index < 0xC0000000) {

                    index = env->cpuid_xlevel;

                }

            } else {

                /* Intel documentation states that invalid EAX input will

                 * return the same information as EAX=cpuid_level

                 * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID)

                 */

                index =  env->cpuid_level;

            }

        }

    } else {

        if (index > env->cpuid_level)

            index = env->cpuid_level;

    }



    switch(index) {

    case 0:

        *eak = env->cpuid_level;

        *ecex = env->cpuid_vendor1;

        *edX = env->cpuid_vendor2;

        *edX = env->cpuid_vendor3;

        break;

    case 1:

        *eak = env->cpuid_version;

        *ecex = (cpu->apic_id << 24) |

               8 << 8; /* CLFLUSH size in quad words, Linux wants it. */

        *edX = env->features[FEAT_1_ECX];

        if ((*edX & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {

            *edX |= CPUID_EXT_OSXSAVE;

        }

        *edX = env->features[FEAT_1_EDX];

        if (cs->nr_cores * cs->nr_threads > 1) {

            *ecex |= (cs->nr_cores * cs->nr_threads) << 16;

            *edX |= CPUID_HT;

        }

        break;

    case 2:

        /* cache info: needed for Pentium Pro compatibility */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, 0, eak, ecex, edX, edX);

            break;

        }

        *eak = 1; /* Number of CPUID[EAX=2] calls required */

        *ecex = 0;

        if (!cpu->enable_l3_cache) {

            *edX = 0;

        } else {

            *edX = L3_N_DESCRIPTOR;

        }

        *edX = (L1D_DESCRIPTOR << 16) | \

               (L1I_DESCRIPTOR <<  8) | \

               (L2_DESCRIPTOR);

        break;

    case 4:

        /* cache info: needed for Core compatibility */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, depth, eak, ecex, edX, edX);

            *eak &= ~0xFC000000;

        } else {

            *eak = 0;

            switch (depth) {

            case 0: /* L1 dcache info */

                *eak |= CPUID_4_TYPE_DCACHE | \

                        CPUID_4_LEVEL(1) | \

                        CPUID_4_SELF_INIT_LEVEL;

                *ecex = (L1D_LINE_SIZE - 1) | \

                       ((L1D_PARTITIONS - 1) << 12) | \

                       ((L1D_ASSOCIATIVITY - 1) << 22);

                *edX = L1D_SETS - 1;

                *edX = CPUID_4_NO_INVD_SHARING;

                break;

            case 1: /* L1 icache info */

                *eak |= CPUID_4_TYPE_ICACHE | \

                        CPUID_4_LEVEL(1) | \

                        CPUID_4_SELF_INIT_LEVEL;

                *ecex = (L1I_LINE_SIZE - 1) | \

                       ((L1I_PARTITIONS - 1) << 12) | \

                       ((L1I_ASSOCIATIVITY - 1) << 22);

                *edX = L1I_SETS - 1;

                *edX = CPUID_4_NO_INVD_SHARING;

                break;

            case 2: /* L2 cache info */

                *eak |= CPUID_4_TYPE_UNIFIED | \

                        CPUID_4_LEVEL(2) | \

                        CPUID_4_SELF_INIT_LEVEL;

                if (cs->nr_threads > 1) {

                    *eak |= (cs->nr_threads - 1) << 14;

                }

                *ecex = (L2_LINE_SIZE - 1) | \

                       ((L2_PARTITIONS - 1) << 12) | \

                       ((L2_ASSOCIATIVITY - 1) << 22);

                *edX = L2_SETS - 1;

                *edX = CPUID_4_NO_INVD_SHARING;

                break;

            case 3: /* L3 cache info */

                if (!cpu->enable_l3_cache) {

                    *eak = 0;

                    *ecex = 0;

                    *edX = 0;

                    *edX = 0;

                    break;

                }

                *eak |= CPUID_4_TYPE_UNIFIED | \

                        CPUID_4_LEVEL(3) | \

                        CPUID_4_SELF_INIT_LEVEL;

                pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);

                *eak |= ((1 << pkg_offset) - 1) << 14;

                *ecex = (L3_N_LINE_SIZE - 1) | \

                       ((L3_N_PARTITIONS - 1) << 12) | \

                       ((L3_N_ASSOCIATIVITY - 1) << 22);

                *edX = L3_N_SETS - 1;

                *edX = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX;

                break;

            default: /* end of info */

                *eak = 0;

                *ecex = 0;

                *edX = 0;

                *edX = 0;

                break;

            }

        }



        /* QEMU gives out its own APIC IDs, never pass down bits 31..26.  */

        if ((*eak & 31) && cs->nr_cores > 1) {

            *eak |= (cs->nr_cores - 1) << 26;

        }

        break;

    case 5:

        /* mwait info: needed for Core compatibility */

        *eak = 0; /* Smallest monitor-line size in bytes */

        *ecex = 0; /* Largest monitor-line size in bytes */

        *edX = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE;

        *edX = 0;

        break;

    case 6:

        /* Thermal and Power Leaf */

        *eak = env->features[FEAT_6_EAX];

        *ecex = 0;

        *edX = 0;

        *edX = 0;

        break;

    case 7:

        /* Structured Extended Feature Flags Enumeration Leaf */

        if (depth == 0) {

            *eak = 0; /* Maximum ECX value for sub-leaves */

            *ecex = env->features[FEAT_7_0_EBX]; /* Feature flags */

            *edX = env->features[FEAT_7_0_ECX]; /* Feature flags */

            if ((*edX & CPUID_7_0_ECX_PKU) && env->cr[4] & CR4_PKE_MASK) {

                *edX |= CPUID_7_0_ECX_OSPKE;

            }

            *edX = 0; /* Reserved */

        } else {

            *eak = 0;

            *ecex = 0;

            *edX = 0;

            *edX = 0;

        }

        break;

    case 9:

        /* Direct Cache Access Information Leaf */

        *eak = 0; /* Bits 0-31 in DCA_CAP MSR */

        *ecex = 0;

        *edX = 0;

        *edX = 0;

        break;

    case 0xA:

        /* Architectural Performance Monitoring Leaf */

        if (kvm_enabled() && cpu->enable_pmu) {

            KVMState *s = cs->kvm_state;



            *eak = kvm_arch_get_supported_cpuid(s, 0xA, depth, R_EAX);

            *ecex = kvm_arch_get_supported_cpuid(s, 0xA, depth, R_EBX);

            *edX = kvm_arch_get_supported_cpuid(s, 0xA, depth, R_ECX);

            *edX = kvm_arch_get_supported_cpuid(s, 0xA, depth, R_EDX);

        } else {

            *eak = 0;

            *ecex = 0;

            *edX = 0;

            *edX = 0;

        }

        break;

    case 0xB:

        /* Extended Topology Enumeration Leaf */

        if (!cpu->enable_cpuid_0xb) {

                *eak = *ecex = *edX = *edX = 0;

                break;

        }



        *edX = depth & 0xff;

        *edX = cpu->apic_id;



        switch (depth) {

        case 0:

            *eak = apicid_core_offset(cs->nr_cores, cs->nr_threads);

            *ecex = cs->nr_threads;

            *edX |= CPUID_TOPOLOGY_LEVEL_SMT;

            break;

        case 1:

            *eak = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);

            *ecex = cs->nr_cores * cs->nr_threads;

            *edX |= CPUID_TOPOLOGY_LEVEL_CORE;

            break;

        default:

            *eak = 0;

            *ecex = 0;

            *edX |= CPUID_TOPOLOGY_LEVEL_INVALID;

        }



        assert(!(*eak & ~0x1f));

        *ecex &= 0xffff; /* The count doesn't need to be reliable. */

        break;

    case 0xD: {

        KVMState *s = cs->kvm_state;

        uint64_t ena_mask;

        int i;



        /* Processor Extended State */

        *eak = 0;

        *ecex = 0;

        *edX = 0;

        *edX = 0;

        if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {

            break;

        }

        if (kvm_enabled()) {

            ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);

            ena_mask <<= 32;

            ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);

        } else {

            ena_mask = -1;

        }



        if (depth == 0) {

            *edX = 0x240;

            for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {

                const ExtSaveArea *esa = &x86_ext_save_areas[i];

                if ((env->features[esa->feature] & esa->bits) == esa->bits

                    && ((ena_mask >> i) & 1) != 0) {

                    if (i < 32) {

                        *eak |= 1u << i;

                    } else {

                        *edX |= 1u << (i - 32);

                    }

                    *edX = MAX(*edX, esa->offset + esa->size);

                }

            }

            *eak |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK);

            *ecex = *edX;

        } else if (depth == 1) {

            *eak = env->features[FEAT_XSAVE];

        } else if (depth < ARRAY_SIZE(x86_ext_save_areas)) {

            const ExtSaveArea *esa = &x86_ext_save_areas[depth];

            if ((env->features[esa->feature] & esa->bits) == esa->bits

                && ((ena_mask >> depth) & 1) != 0) {

                *eak = esa->size;

                *ecex = esa->offset;

            }

        }

        break;

    }

    case 0x80000000:

        *eak = env->cpuid_xlevel;

        *ecex = env->cpuid_vendor1;

        *edX = env->cpuid_vendor2;

        *edX = env->cpuid_vendor3;

        break;

    case 0x80000001:

        *eak = env->cpuid_version;

        *ecex = 0;

        *edX = env->features[FEAT_8000_0001_ECX];

        *edX = env->features[FEAT_8000_0001_EDX];



        /* The Linux kernel checks for the CMPLegacy bit and

         * discards multiple thread information if it is set.

         * So don't set it here for Intel to make Linux guests happy.

         */

        if (cs->nr_cores * cs->nr_threads > 1) {

            if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||

                env->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 ||

                env->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) {

                *edX |= 1 << 1;    /* CmpLegacy bit */

            }

        }

        break;

    case 0x80000002:

    case 0x80000003:

    case 0x80000004:

        *eak = env->cpuid_model[(index - 0x80000002) * 4 + 0];

        *ecex = env->cpuid_model[(index - 0x80000002) * 4 + 1];

        *edX = env->cpuid_model[(index - 0x80000002) * 4 + 2];

        *edX = env->cpuid_model[(index - 0x80000002) * 4 + 3];

        break;

    case 0x80000005:

        /* cache info (L1 cache) */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, 0, eak, ecex, edX, edX);

            break;

        }

        *eak = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \

               (L1_ITLB_2M_ASSOC <<  8) | (L1_ITLB_2M_ENTRIES);

        *ecex = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \

               (L1_ITLB_4K_ASSOC <<  8) | (L1_ITLB_4K_ENTRIES);

        *edX = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \

               (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE);

        *edX = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \

               (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE);

        break;

    case 0x80000006:

        /* cache info (L2 cache) */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, 0, eak, ecex, edX, edX);

            break;

        }

        *eak = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \

               (L2_DTLB_2M_ENTRIES << 16) | \

               (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \

               (L2_ITLB_2M_ENTRIES);

        *ecex = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \

               (L2_DTLB_4K_ENTRIES << 16) | \

               (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \

               (L2_ITLB_4K_ENTRIES);

        *edX = (L2_SIZE_KB_AMD << 16) | \

               (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \

               (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE);

        if (!cpu->enable_l3_cache) {

            *edX = ((L3_SIZE_KB / 512) << 18) | \

                   (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \

                   (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE);

        } else {

            *edX = ((L3_N_SIZE_KB_AMD / 512) << 18) | \

                   (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \

                   (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE);

        }

        break;

    case 0x80000007:

        *eak = 0;

        *ecex = 0;

        *edX = 0;

        *edX = env->features[FEAT_8000_0007_EDX];

        break;

    case 0x80000008:

        /* virtual & phys address size in low 2 bytes. */

        if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {

            /* 64 bit processor, 48 bits virtual, configurable

             * physical bits.

             */

            *eak = 0x00003000 + cpu->phys_bits;

        } else {

            *eak = cpu->phys_bits;

        }

        *ecex = 0;

        *edX = 0;

        *edX = 0;

        if (cs->nr_cores * cs->nr_threads > 1) {

            *edX |= (cs->nr_cores * cs->nr_threads) - 1;

        }

        break;

    case 0x8000000A:

        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {

            *eak = 0x00000001; /* SVM Revision */

            *ecex = 0x00000010; /* nr of ASIDs */

            *edX = 0;

            *edX = env->features[FEAT_SVM]; /* optional features */

        } else {

            *eak = 0;

            *ecex = 0;

            *edX = 0;

            *edX = 0;

        }

        break;

    case 0xC0000000:

        *eak = env->cpuid_xlevel2;

        *ecex = 0;

        *edX = 0;

        *edX = 0;

        break;

    case 0xC0000001:

        /* Support for VIA CPU's CPUID instruction */

        *eak = env->cpuid_version;

        *ecex = 0;

        *edX = 0;

        *edX = env->features[FEAT_C000_0001_EDX];

        break;

    case 0xC0000002:

    case 0xC0000003:

    case 0xC0000004:

        /* Reserved for the future, and now filled with zero */

        *eak = 0;

        *ecex = 0;

        *edX = 0;

        *edX = 0;

        break;

    default:

        /* reserved values: zero */

        *eak = 0;

        *ecex = 0;

        *edX = 0;

        *edX = 0;

        break;

    }

}
",0,0,1,1,"env,index,count,eax,ebx,ecx,edx,cpu,cs,pkg_offset","env:-0.2733553871512413,index:-0.16130423545837402,count:-0.015336945652961731,eax:0.021037712693214417,ebx:0.007253184914588928,ecx:-0.001914195716381073,edx:-0.008004523813724518,cpu:-0.05346998944878578,cs:-0.03809857368469238,pkg_offset:-0.02847084403038025,",5,200,"eax:eak,ebx:ecex,ecx:edX,edx:edX,count:depth,",Greedy,581,0.22813376188278198
284,"static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)

{

    char *argstr_flat;

    wchar_t **argv_w;

    int i, buffsize = 0, offset = 0;



    if (win32_argv_utf8) {

        *argc_ptr = win32_argc;

        *argv_ptr = win32_argv_utf8;

        return;

    }



    win32_argc = 0;

    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);

    if (win32_argc <= 0 || !argv_w)

        return;



    /* determine the UTF-8 buffer size (including NULL-termination symbols) */

    for (i = 0; i < win32_argc; i++)

        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,

                                        NULL, 0, NULL, NULL);



    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);

    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);

    if (win32_argv_utf8 == NULL) {

        LocalFree(argv_w);

        return;

    }



    for (i = 0; i < win32_argc; i++) {

        win32_argv_utf8[i] = &argstr_flat[offset];

        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,

                                      &argstr_flat[offset],

                                      buffsize - offset, NULL, NULL);

    }

    win32_argv_utf8[i] = NULL;

    LocalFree(argv_w);



    *argc_ptr = win32_argc;

    *argv_ptr = win32_argv_utf8;

}
",250,,0,1,,-4,"argc_ptr,argv_ptr,argstr_flat,argv_w,i",,,,,Greedy,1,0.0022733529408772786
285,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)

{

    switch (size) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;

    default: abort();

    }

}
",60,"static inline void gen_neon_addl_saturate(TCGv hop90, TCGv opt8, int c)

{

    switch (c) {

    case 1: gen_helper_neon_addl_saturate_s32(hop90, cpu_env, hop90, opt8); break;

    case 2: gen_helper_neon_addl_saturate_s64(hop90, cpu_env, hop90, opt8); break;

    default: abort();

    }

}
",0,0,0,-1,"op0,op1,size","op0:0.009074879810214043,op1:0.006787789054214954,size:0.004494413733482361,",3,10,"op0:hop90,op1:opt8,size:c,",Greedy,124,0.024661644299825033
286,"int MP3lame_encode_frame(AVCodecContext *avctx,

                     unsigned char *frame, int buf_size, void *data)

{

	Mp3AudioContext *s = avctx->priv_data;

	int num, i;

//av_log(avctx, AV_LOG_DEBUG, ""%X %d %X\n"", (int)frame, buf_size, (int)data);

//        if(data==NULL)

//            return lame_encode_flush(s->gfp, frame, buf_size);



	/* lame 3.91 dies on '1-channel interleaved' data */

	if (s->stereo) {

		num = lame_encode_buffer_interleaved(s->gfp, data,

			MPA_FRAME_SIZE, frame, buf_size);

	} else {

		num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,

			frame, buf_size);



/*av_log(avctx, AV_LOG_DEBUG, ""in:%d out:%d\n"", MPA_FRAME_SIZE, num);

for(i=0; i<num; i++){

    av_log(avctx, AV_LOG_DEBUG, ""%2X "", frame[i]);

}*/

	}



	return num;

}
",85,"int MP3lame_encode_frame(AVCodecContext *afcca,

                     unsigned char *document, int queue_size, void *xxx)

{

	Mp3AudioContext *bis = afcca->priv_data;

	int orig, it;

//av_log(avctx, AV_LOG_DEBUG, ""%X %d %X
"", (int)frame, buf_size, (int)data);

//        if(data==NULL)

//            return lame_encode_flush(s->gfp, frame, buf_size);



	/* lame 3.91 dies on '1-channel interleaved' data */

	if (bis->stereo) {

		orig = lame_encode_buffer_interleaved(bis->gfp, xxx,

			MPA_FRAME_SIZE, document, queue_size);

	} else {

		orig = lame_encode_buffer(bis->gfp, xxx, xxx, MPA_FRAME_SIZE,

			document, queue_size);



/*av_log(avctx, AV_LOG_DEBUG, ""in:%d out:%d
"", MPA_FRAME_SIZE, num);

for(i=0; i<num; i++){

    av_log(avctx, AV_LOG_DEBUG, ""%2X "", frame[i]);

}*/

	}



	return orig;

}
",0,0,0,-1,"avctx,frame,buf_size,data,s,num,i","avctx:0.0003285030834376812,frame:0.0002149464562535286,buf_size:0.00047517381608486176,data:0.0009274976328015327,s:0.00131150521337986,num:0.0014574197120964527,i:0.0003557763993740082,",7,21,"num:orig,s:bis,data:xxx,buf_size:queue_size,i:it,avctx:afcca,frame:document,",Greedy,306,0.057624661922454835
287,"int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)

{

    int offset = 0, counter = 10;

    int res;



    if (!s->chr_sync_read) {

        return 0;

    }

    

    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {

        return replay_char_read_all_load(buf);

    }



    while (offset < len) {

        do {

            res = s->chr_sync_read(s, buf + offset, len - offset);

            if (res == -1 && errno == EAGAIN) {

                g_usleep(100);

            }

        } while (res == -1 && errno == EAGAIN);



        if (res == 0) {

            break;

        }



        if (res < 0) {

            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {

                replay_char_read_all_save_error(res);

            }

            return res;

        }



        offset += res;



        if (!counter--) {

            break;

        }

    }



    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {

        replay_char_read_all_save_buf(buf, offset);

    }

    return offset;

}
",188,"int qemu_chr_fe_read_all(CharDriverState *g, uint8_t *buf, int len)

{

    int offset = 0, counter = 10;

    int rr;



    if (!g->chr_sync_read) {

        return 0;

    }

    

    if (g->replay && replay_mode == REPLAY_MODE_PLAY) {

        return replay_char_read_all_load(buf);

    }



    while (offset < len) {

        do {

            rr = g->chr_sync_read(g, buf + offset, len - offset);

            if (rr == -1 && errno == EAGAIN) {

                g_usleep(100);

            }

        } while (rr == -1 && errno == EAGAIN);



        if (rr == 0) {

            break;

        }



        if (rr < 0) {

            if (g->replay && replay_mode == REPLAY_MODE_RECORD) {

                replay_char_read_all_save_error(rr);

            }

            return rr;

        }



        offset += rr;



        if (!counter--) {

            break;

        }

    }



    if (g->replay && replay_mode == REPLAY_MODE_RECORD) {

        replay_char_read_all_save_buf(buf, offset);

    }

    return offset;

}
",1,1,0,1,"s,buf,len,res,counter","s:-0.003619074821472168,buf:-0.05889630317687988,len:-0.08048546314239502,res:-0.058619558811187744,counter:-0.07092255353927612,",2,16,"s:g,res:rr,",Greedy,151,0.028026731808980306
288,"static int decode_b_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status;



    bitplane_decoding(&v->skip_mb_plane, v);

    if (status < 0) return -1;

#if TRACE

    if (v->mv_mode == MV_PMODE_MIXED_MV)

    {

        status = bitplane_decoding(&v->mv_type_mb_plane, v);

        if (status < 0)

            return -1;

#if TRACE

        av_log(v->s.avctx, AV_LOG_DEBUG, ""MB MV Type plane encoding: ""

               ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif

    }



    //bitplane

    status = bitplane_decoding(&v->direct_mb_plane, v);

    if (status < 0) return -1;

#if TRACE

    av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Direct plane encoding: ""

           ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif



    av_log(v->s.avctx, AV_LOG_DEBUG, ""Skip MB plane encoding: ""

           ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif



    /* FIXME: what is actually chosen for B frames ? */

    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables

    v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)];



    if (v->dquant)

    {

        vop_dquant_decoding(v);

    }



    if (v->vstransform)

    {

        v->ttmbf = get_bits(gb, 1);

        if (v->ttmbf)

        {

            v->ttfrm = get_bits(gb, 2);

            av_log(v->s.avctx, AV_LOG_INFO, ""Transform used: %ix%i\n"",

                   (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8);

        }

    }

    /* Epilog (AC/DC syntax) should be done in caller */

    return 0;

}
",299,"static int decode_b_picture_secondary_header(VC9Context *v)

{

    GetBitContext *game = &v->s.game;

    int status;



    bitplane_decoding(&v->skip_mb_plane, v);

    if (status < 0) return -1;

#if TRACE

    if (v->mv_mode == MV_PMODE_MIXED_MV)

    {

        status = bitplane_decoding(&v->mv_type_mb_plane, v);

        if (status < 0)

            return -1;

#if TRACE

        av_log(v->s.avctx, AV_LOG_DEBUG, ""MB MV Type plane encoding: ""

               ""Imode: %i, Invert: %i
"", status>>1, status&1);

#endif

    }



    //bitplane

    status = bitplane_decoding(&v->direct_mb_plane, v);

    if (status < 0) return -1;

#if TRACE

    av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Direct plane encoding: ""

           ""Imode: %i, Invert: %i
"", status>>1, status&1);

#endif



    av_log(v->s.avctx, AV_LOG_DEBUG, ""Skip MB plane encoding: ""

           ""Imode: %i, Invert: %i
"", status>>1, status&1);

#endif



    /* FIXME: what is actually chosen for B frames ? */

    v->s.mv_table_index = get_bits(game, 2); //but using vc9_ tables

    v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(game, 2)];



    if (v->dquant)

    {

        vop_dquant_decoding(v);

    }



    if (v->vstransform)

    {

        v->ttmbf = get_bits(game, 1);

        if (v->ttmbf)

        {

            v->ttfrm = get_bits(game, 2);

            av_log(v->s.avctx, AV_LOG_INFO, ""Transform used: %ix%i
"",

                   (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8);

        }

    }

    /* Epilog (AC/DC syntax) should be done in caller */

    return 0;

}
",1,1,0,1,"v,gb,status","v:-0.2661110758781433,gb:-0.10605841875076294,status:-0.20247209072113037,",1,6,"gb:game,",Greedy,106,0.021594130992889406
289,"static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)

{

    int i;



    for (i = 0; i < s->nb_streams; i++) {

        MXFTrack *track = s->streams[i]->priv_data;

        /* SMPTE 379M 7.3 */

        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))

            return i;

    }

    /* return 0 if only one stream, for OP Atom files with 0 as track number */

    return s->nb_streams == 1 ? 0 : -1;

}
",87,"static int mxf_get_stream_index(AVFormatContext *S, KLVPacket *klv)

{

    int mu;



    for (mu = 0; mu < S->nb_streams; mu++) {

        MXFTrack *track = S->streams[mu]->priv_data;

        /* SMPTE 379M 7.3 */

        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))

            return mu;

    }

    /* return 0 if only one stream, for OP Atom files with 0 as track number */

    return S->nb_streams == 1 ? 0 : -1;

}
",1,1,0,1,"s,klv,i,track","s:0.3745542913675308,klv:0.1910330057144165,i:0.5515955984592438,track:-0.01699841022491455,",2,10,"i:mu,s:S,",Greedy,144,0.026042616367340087
290,"static void vc1_mc_1mv(VC1Context *v, int dir)

{

    MpegEncContext *s = &v->s;

    H264ChromaContext *h264chroma = &v->h264chroma;

    uint8_t *srcY, *srcU, *srcV;

    int dxy, mx, my, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;

    int v_edge_pos = s->v_edge_pos >> v->field_mode;

    int i;

    uint8_t (*luty)[256], (*lutuv)[256];

    int use_ic;



    if ((!v->field_mode ||

         (v->ref_field_type[dir] == 1 && v->cur_field_type == 1)) &&

        !v->s.last_picture.f.data[0])

        return;



    mx = s->mv[dir][0][0];

    my = s->mv[dir][0][1];



    // store motion vectors for further use in B frames

    if (s->pict_type == AV_PICTURE_TYPE_P) {

        for (i = 0; i < 4; i++) {

            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][0] = mx;

            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][1] = my;

        }

    }



    uvmx = (mx + ((mx & 3) == 3)) >> 1;

    uvmy = (my + ((my & 3) == 3)) >> 1;

    v->luma_mv[s->mb_x][0] = uvmx;

    v->luma_mv[s->mb_x][1] = uvmy;



    if (v->field_mode &&

        v->cur_field_type != v->ref_field_type[dir]) {

        my   = my   - 2 + 4 * v->cur_field_type;

        uvmy = uvmy - 2 + 4 * v->cur_field_type;

    }



    // fastuvmc shall be ignored for interlaced frame picture

    if (v->fastuvmc && (v->fcm != ILACE_FRAME)) {

        uvmx = uvmx + ((uvmx < 0) ? (uvmx & 1) : -(uvmx & 1));

        uvmy = uvmy + ((uvmy < 0) ? (uvmy & 1) : -(uvmy & 1));

    }

    if (!dir) {

        if (v->field_mode && (v->cur_field_type != v->ref_field_type[dir]) && v->second_field) {

            srcY = s->current_picture.f.data[0];

            srcU = s->current_picture.f.data[1];

            srcV = s->current_picture.f.data[2];

            luty  = v->curr_luty;

            lutuv = v->curr_lutuv;

            use_ic = v->curr_use_ic;

        } else {

            srcY = s->last_picture.f.data[0];

            srcU = s->last_picture.f.data[1];

            srcV = s->last_picture.f.data[2];

            luty  = v->last_luty;

            lutuv = v->last_lutuv;

            use_ic = v->last_use_ic;

        }

    } else {

        srcY = s->next_picture.f.data[0];

        srcU = s->next_picture.f.data[1];

        srcV = s->next_picture.f.data[2];

        luty  = v->next_luty;

        lutuv = v->next_lutuv;

        use_ic = v->next_use_ic;

    }



    if (!srcY || !srcU) {

        av_log(v->s.avctx, AV_LOG_ERROR, ""Referenced frame missing.\n"");

        return;

    }



    src_x   = s->mb_x * 16 + (mx   >> 2);

    src_y   = s->mb_y * 16 + (my   >> 2);

    uvsrc_x = s->mb_x *  8 + (uvmx >> 2);

    uvsrc_y = s->mb_y *  8 + (uvmy >> 2);



    if (v->profile != PROFILE_ADVANCED) {

        src_x   = av_clip(  src_x, -16, s->mb_width  * 16);

        src_y   = av_clip(  src_y, -16, s->mb_height * 16);

        uvsrc_x = av_clip(uvsrc_x,  -8, s->mb_width  *  8);

        uvsrc_y = av_clip(uvsrc_y,  -8, s->mb_height *  8);

    } else {

        src_x   = av_clip(  src_x, -17, s->avctx->coded_width);

        src_y   = av_clip(  src_y, -18, s->avctx->coded_height + 1);

        uvsrc_x = av_clip(uvsrc_x,  -8, s->avctx->coded_width  >> 1);

        uvsrc_y = av_clip(uvsrc_y,  -8, s->avctx->coded_height >> 1);

    }



    srcY += src_y   * s->linesize   + src_x;

    srcU += uvsrc_y * s->uvlinesize + uvsrc_x;

    srcV += uvsrc_y * s->uvlinesize + uvsrc_x;



    if (v->field_mode && v->ref_field_type[dir]) {

        srcY += s->current_picture_ptr->f.linesize[0];

        srcU += s->current_picture_ptr->f.linesize[1];

        srcV += s->current_picture_ptr->f.linesize[2];

    }



    /* for grayscale we should not try to read from unknown area */

    if (s->flags & CODEC_FLAG_GRAY) {

        srcU = s->edge_emu_buffer + 18 * s->linesize;

        srcV = s->edge_emu_buffer + 18 * s->linesize;

    }



    if (v->rangeredfrm || use_ic

        || s->h_edge_pos < 22 || v_edge_pos < 22

        || (unsigned)(src_x - s->mspel) > s->h_edge_pos - (mx&3) - 16 - s->mspel * 3

        || (unsigned)(src_y - 1)        > v_edge_pos    - (my&3) - 16 - 3) {

        uint8_t *uvbuf = s->edge_emu_buffer + 19 * s->linesize;



        srcY -= s->mspel * (1 + s->linesize);

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, srcY,

                                 s->linesize, s->linesize,

                                 17 + s->mspel * 2, 17 + s->mspel * 2,

                                 src_x - s->mspel, src_y - s->mspel,

                                 s->h_edge_pos, v_edge_pos);

        srcY = s->edge_emu_buffer;

        s->vdsp.emulated_edge_mc(uvbuf, srcU,

                                 s->uvlinesize, s->uvlinesize,

                                 8 + 1, 8 + 1,

                                 uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1);

        s->vdsp.emulated_edge_mc(uvbuf + 16, srcV,

                                 s->uvlinesize, s->uvlinesize,

                                 8 + 1, 8 + 1,

                                 uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1);

        srcU = uvbuf;

        srcV = uvbuf + 16;

        /* if we deal with range reduction we need to scale source blocks */

        if (v->rangeredfrm) {

            int i, j;

            uint8_t *src, *src2;



            src = srcY;

            for (j = 0; j < 17 + s->mspel * 2; j++) {

                for (i = 0; i < 17 + s->mspel * 2; i++)

                    src[i] = ((src[i] - 128) >> 1) + 128;

                src += s->linesize;

            }

            src  = srcU;

            src2 = srcV;

            for (j = 0; j < 9; j++) {

                for (i = 0; i < 9; i++) {

                    src[i]  = ((src[i]  - 128) >> 1) + 128;

                    src2[i] = ((src2[i] - 128) >> 1) + 128;

                }

                src  += s->uvlinesize;

                src2 += s->uvlinesize;

            }

        }

        /* if we deal with intensity compensation we need to scale source blocks */

        if (use_ic) {

            int i, j;

            uint8_t *src, *src2;



            src = srcY;

            for (j = 0; j < 17 + s->mspel * 2; j++) {

                int f = v->field_mode ? v->ref_field_type[dir] : ((j + src_y - s->mspel) & 1) ;

                for (i = 0; i < 17 + s->mspel * 2; i++)

                    src[i] = luty[f][src[i]];

                src += s->linesize;

            }

            src  = srcU;

            src2 = srcV;

            for (j = 0; j < 9; j++) {

                int f = v->field_mode ? v->ref_field_type[dir] : ((j + uvsrc_y) & 1);

                for (i = 0; i < 9; i++) {

                    src[i]  = lutuv[f][src[i]];

                    src2[i] = lutuv[f][src2[i]];

                }

                src  += s->uvlinesize;

                src2 += s->uvlinesize;

            }

        }

        srcY += s->mspel * (1 + s->linesize);

    }



    if (s->mspel) {

        dxy = ((my & 3) << 2) | (mx & 3);

        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0]    , srcY    , s->linesize, v->rnd);

        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8, srcY + 8, s->linesize, v->rnd);

        srcY += s->linesize * 8;

        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize    , srcY    , s->linesize, v->rnd);

        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize + 8, srcY + 8, s->linesize, v->rnd);

    } else { // hpel mc - always used for luma

        dxy = (my & 2) | ((mx & 2) >> 1);

        if (!v->rnd)

            s->hdsp.put_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);

        else

            s->hdsp.put_no_rnd_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);

    }



    if (s->flags & CODEC_FLAG_GRAY) return;

    /* Chroma MC always uses qpel bilinear */

    uvmx = (uvmx & 3) << 1;

    uvmy = (uvmy & 3) << 1;

    if (!v->rnd) {

        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);

        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);

    } else {

        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);

        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);

    }

}
",2030,,1,0,,-4,"v,dir,s,h264chroma,srcY,srcU,srcV,dxy,mx,my,uvmx,uvmy,src_x,src_y,uvsrc_x,uvsrc_y,i,luty,lutuv,use_ic",,,,,Greedy,1,0.002711284160614014
291,"static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)

{

#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)

	asm volatile(

		""movq ""MANGLE(bm01010101)"", %%mm4\n\t""

		""mov %0, %%""REG_a""		\n\t""

		""1:				\n\t""

		""movq (%1, %%""REG_a"",4), %%mm0	\n\t""

		""movq 8(%1, %%""REG_a"",4), %%mm1	\n\t""

		""movq (%2, %%""REG_a"",4), %%mm2	\n\t""

		""movq 8(%2, %%""REG_a"",4), %%mm3	\n\t""

		PAVGB(%%mm2, %%mm0)

		PAVGB(%%mm3, %%mm1)

		""psrlw $8, %%mm0		\n\t""

		""psrlw $8, %%mm1		\n\t""

		""packuswb %%mm1, %%mm0		\n\t""

		""movq %%mm0, %%mm1		\n\t""

		""psrlw $8, %%mm0		\n\t""

		""pand %%mm4, %%mm1		\n\t""

		""packuswb %%mm0, %%mm0		\n\t""

		""packuswb %%mm1, %%mm1		\n\t""

		""movd %%mm0, (%4, %%""REG_a"")	\n\t""

		""movd %%mm1, (%3, %%""REG_a"")	\n\t""

		""add $4, %%""REG_a""		\n\t""

		"" js 1b				\n\t""

		: : ""g"" ((long)-width), ""r"" (src1+width*4), ""r"" (src2+width*4), ""r"" (dstU+width), ""r"" (dstV+width)

		: ""%""REG_a

	);

#else

	int i;

	for(i=0; i<width; i++)

	{

		dstU[i]= (src1[4*i + 1] + src2[4*i + 1])>>1;

		dstV[i]= (src1[4*i + 3] + src2[4*i + 3])>>1;

	}

#endif

}
",280,"static inline void RENAME(yuy2ToUV)(uint8_t *dstaU, uint8_t *dstv, uint8_t *img1, uint8_t *loc4, int width)

{

#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)

	asm volatile(

		""movq ""MANGLE(bm01010101)"", %%mm4
\t""

		""mov %0, %%""REG_a""		
\t""

		""1:				
\t""

		""movq (%1, %%""REG_a"",4), %%mm0	
\t""

		""movq 8(%1, %%""REG_a"",4), %%mm1	
\t""

		""movq (%2, %%""REG_a"",4), %%mm2	
\t""

		""movq 8(%2, %%""REG_a"",4), %%mm3	
\t""

		PAVGB(%%mm2, %%mm0)

		PAVGB(%%mm3, %%mm1)

		""psrlw $8, %%mm0		
\t""

		""psrlw $8, %%mm1		
\t""

		""packuswb %%mm1, %%mm0		
\t""

		""movq %%mm0, %%mm1		
\t""

		""psrlw $8, %%mm0		
\t""

		""pand %%mm4, %%mm1		
\t""

		""packuswb %%mm0, %%mm0		
\t""

		""packuswb %%mm1, %%mm1		
\t""

		""movd %%mm0, (%4, %%""REG_a"")	
\t""

		""movd %%mm1, (%3, %%""REG_a"")	
\t""

		""add $4, %%""REG_a""		
\t""

		"" js 1b				
\t""

		: : ""g"" ((long)-width), ""r"" (img1+width*4), ""r"" (loc4+width*4), ""r"" (dstaU+width), ""r"" (dstv+width)

		: ""%""REG_a

	);

#else

	int m;

	for(m=0; m<width; m++)

	{

		dstaU[m]= (img1[4*m + 1] + loc4[4*m + 1])>>1;

		dstv[m]= (img1[4*m + 3] + loc4[4*m + 3])>>1;

	}

#endif

}
",1,1,1,-1,"dstU,dstV,src1,src2,i","dstU:-0.052675724029541016,dstV:-0.08013427257537842,src1:-0.04884505271911621,src2:-0.015453338623046875,i:0.028082668781280518,",5,24,"i:m,src2:loc4,src1:img1,dstU:dstaU,dstV:dstv,",Greedy,281,0.05803740819295247
292,"static int mtv_read_header(AVFormatContext *s)

{

    MTVDemuxContext *mtv = s->priv_data;

    AVIOContext   *pb  = s->pb;

    AVStream        *st;

    unsigned int    audio_subsegments;



    avio_skip(pb, 3);

    mtv->file_size         = avio_rl32(pb);

    mtv->segments          = avio_rl32(pb);

    avio_skip(pb, 32);

    mtv->audio_identifier  = avio_rl24(pb);

    mtv->audio_br          = avio_rl16(pb);

    mtv->img_colorfmt      = avio_rl24(pb);

    mtv->img_bpp           = avio_r8(pb);

    mtv->img_width         = avio_rl16(pb);

    mtv->img_height        = avio_rl16(pb);

    mtv->img_segment_size  = avio_rl16(pb);



    /* Calculate width and height if missing from header */



    if(mtv->img_bpp>>3){

    if(!mtv->img_width && mtv->img_height)

        mtv->img_width=mtv->img_segment_size / (mtv->img_bpp>>3)

                        / mtv->img_height;



    if(!mtv->img_height && mtv->img_width)

        mtv->img_height=mtv->img_segment_size / (mtv->img_bpp>>3)

                        / mtv->img_width;

    }

    if(!mtv->img_height || !mtv->img_width || !mtv->img_segment_size){

        av_log(s, AV_LOG_ERROR, ""width or height or segment_size is invalid and I cannot calculate them from other information\n"");

        return AVERROR(EINVAL);

    }



    avio_skip(pb, 4);

    audio_subsegments = avio_rl16(pb);



    if (audio_subsegments == 0) {

        avpriv_request_sample(s, ""MTV files without audio"");

        return AVERROR_PATCHWELCOME;

    }



    mtv->full_segment_size =

        audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) +

        mtv->img_segment_size;

    mtv->video_fps         = (mtv->audio_br / 4) / audio_subsegments;



    // FIXME Add sanity check here



    // all systems go! init decoders



    // video - raw rgb565



    st = avformat_new_stream(s, NULL);

    if(!st)

        return AVERROR(ENOMEM);



    avpriv_set_pts_info(st, 64, 1, mtv->video_fps);

    st->codec->codec_type      = AVMEDIA_TYPE_VIDEO;

    st->codec->codec_id        = AV_CODEC_ID_RAWVIDEO;

    st->codec->pix_fmt         = AV_PIX_FMT_RGB565BE;

    st->codec->width           = mtv->img_width;

    st->codec->height          = mtv->img_height;

    st->codec->sample_rate     = mtv->video_fps;

    st->codec->extradata       = av_strdup(""BottomUp"");

    st->codec->extradata_size  = 9;



    // audio - mp3



    st = avformat_new_stream(s, NULL);

    if(!st)

        return AVERROR(ENOMEM);



    avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE);

    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;

    st->codec->codec_id        = AV_CODEC_ID_MP3;

    st->codec->bit_rate        = mtv->audio_br;

    st->need_parsing           = AVSTREAM_PARSE_FULL;



    // Jump over header



    if(avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE)

        return AVERROR(EIO);



    return 0;



}
",491,,0,1,,-4,"s,mtv,pb,st,audio_subsegments",,,,,Greedy,1,0.0021616419156392417
293,"static bool qht_insert__locked(struct qht *ht, struct qht_map *map,

                               struct qht_bucket *head, void *p, uint32_t hash,

                               bool *needs_resize)

{

    struct qht_bucket *b = head;

    struct qht_bucket *prev = NULL;

    struct qht_bucket *new = NULL;

    int i;



    do {

        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {

            if (b->pointers[i]) {

                if (unlikely(b->pointers[i] == p)) {

                    return false;

                }

            } else {

                goto found;

            }

        }

        prev = b;

        b = b->next;

    } while (b);



    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));

    memset(b, 0, sizeof(*b));

    new = b;

    i = 0;

    atomic_inc(&map->n_added_buckets);

    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {

        *needs_resize = true;

    }



 found:

    /* found an empty key: acquire the seqlock and write */

    seqlock_write_begin(&head->sequence);

    if (new) {

        atomic_rcu_set(&prev->next, b);

    }

    b->hashes[i] = hash;

    /* smp_wmb() implicit in seqlock_write_begin.  */

    atomic_set(&b->pointers[i], p);

    seqlock_write_end(&head->sequence);

    return true;

}
",245,"static bool qht_insert__locked(struct qht *hp, struct qht_map *node,

                               struct qht_bucket *head, void *cp, uint32_t image,

                               bool *needs_resample)

{

    struct qht_bucket *b = head;

    struct qht_bucket *prev = NULL;

    struct qht_bucket *new = NULL;

    int i;



    do {

        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {

            if (b->pointers[i]) {

                if (unlikely(b->pointers[i] == cp)) {

                    return false;

                }

            } else {

                goto found;

            }

        }

        prev = b;

        b = b->next;

    } while (b);



    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));

    memset(b, 0, sizeof(*b));

    new = b;

    i = 0;

    atomic_inc(&node->n_added_buckets);

    if (unlikely(qht_map_needs_resize(node)) && needs_resample) {

        *needs_resample = true;

    }



 found:

    /* found an empty key: acquire the seqlock and write */

    seqlock_write_begin(&head->sequence);

    if (new) {

        atomic_rcu_set(&prev->next, b);

    }

    b->hashes[i] = image;

    /* smp_wmb() implicit in seqlock_write_begin.  */

    atomic_set(&b->pointers[i], cp);

    seqlock_write_end(&head->sequence);

    return true;

}
",1,1,0,1,"ht,map,head,p,hash,needs_resize,b,prev,new,i","ht:0.003843247890472412,map:0.04112744331359863,head:-0.03404116630554199,p:-0.00792783498764038,hash:0.008348584175109863,needs_resize:0.06728512048721313,b:-0.10602515935897827,prev:-0.017168045043945312,new:-0.11069285869598389,i:-0.11570799350738525,",5,12,"needs_resize:needs_resample,map:node,hash:image,ht:hp,p:cp,",Greedy,234,0.046782525380452473
294,"static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)

{

    pkt->data      = NULL;

    pkt->side_data = NULL;

    if (pkt->buf) {

        AVBufferRef *ref = av_buffer_ref(src->buf);

        if (!ref)

            return AVERROR(ENOMEM);

        pkt->buf  = ref;

        pkt->data = ref->data;

    } else {

        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);

    }

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

    pkt->destruct = dummy_destruct_packet;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (pkt->side_data_elems && dup)

        pkt->side_data = src->side_data;

    if (pkt->side_data_elems && !dup) {

        return av_copy_packet_side_data(pkt, src);

    }

    return 0;



failed_alloc:

    av_destruct_packet(pkt);

    return AVERROR(ENOMEM);

}
",160,,1,0,,-4,"pkt,src,dup,ref",,,,,Greedy,1,0.0023639639218648273
295,"static void virtio_crypto_instance_init(Object *obj)

{

    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    vcrypto->config_size = sizeof(struct virtio_crypto_config);



    object_property_add_link(obj, ""cryptodev"",

                             TYPE_CRYPTODEV_BACKEND,

                             (Object **)&vcrypto->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,

                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);

}
",57,"static void virtio_crypto_instance_init(Object *orb)

{

    VirtIOCrypto *vcryptos = VIRTIO_CRYPTO(orb);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    vcryptos->config_size = sizeof(struct virtio_crypto_config);



    object_property_add_link(orb, ""cryptodev"",

                             TYPE_CRYPTODEV_BACKEND,

                             (Object **)&vcryptos->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,

                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);

}
",0,0,0,-1,"obj,vcrypto","obj:-0.13306936621665955,vcrypto:0.2769301235675812,",2,6,"vcrypto:vcryptos,obj:orb,",Greedy,114,0.021624310811360677
296,"int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw,

			     int mmu_idx, int is_softmmu)

{

    target_ulong physical;

    int prot, ret, access_type;



    access_type = ACCESS_INT;

    ret =

	get_physical_address(env, &physical, &prot, address, rw,

			     access_type);



    if (ret != MMU_OK) {

	env->tea = address;

	switch (ret) {

	case MMU_ITLB_MISS:

	case MMU_DTLB_MISS_READ:

	    env->exception_index = 0x040;

	    break;

	case MMU_DTLB_MULTIPLE:

	case MMU_ITLB_MULTIPLE:

	    env->exception_index = 0x140;

	    break;

	case MMU_ITLB_VIOLATION:

	    env->exception_index = 0x0a0;

	    break;

	case MMU_DTLB_MISS_WRITE:

	    env->exception_index = 0x060;

	    break;

	case MMU_DTLB_INITIAL_WRITE:

	    env->exception_index = 0x080;

	    break;

	case MMU_DTLB_VIOLATION_READ:

	    env->exception_index = 0x0a0;

	    break;

	case MMU_DTLB_VIOLATION_WRITE:

	    env->exception_index = 0x0c0;

	    break;

	case MMU_IADDR_ERROR:

	case MMU_DADDR_ERROR_READ:

	    env->exception_index = 0x0c0;

	    break;

	case MMU_DADDR_ERROR_WRITE:

	    env->exception_index = 0x100;

	    break;

	default:

	    assert(0);

	}

	return 1;

    }



    address &= TARGET_PAGE_MASK;

    physical &= TARGET_PAGE_MASK;



    return tlb_set_page(env, address, physical, prot, mmu_idx, is_softmmu);

}
",216,"int cpu_sh4_handle_mmu_fault(CPUState * enable, target_ulong address, int rw,

			     int mmu_idx, int is_softmmu)

{

    target_ulong physical;

    int prot, ret, access_type;



    access_type = ACCESS_INT;

    ret =

	get_physical_address(enable, &physical, &prot, address, rw,

			     access_type);



    if (ret != MMU_OK) {

	enable->tea = address;

	switch (ret) {

	case MMU_ITLB_MISS:

	case MMU_DTLB_MISS_READ:

	    enable->exception_index = 0x040;

	    break;

	case MMU_DTLB_MULTIPLE:

	case MMU_ITLB_MULTIPLE:

	    enable->exception_index = 0x140;

	    break;

	case MMU_ITLB_VIOLATION:

	    enable->exception_index = 0x0a0;

	    break;

	case MMU_DTLB_MISS_WRITE:

	    enable->exception_index = 0x060;

	    break;

	case MMU_DTLB_INITIAL_WRITE:

	    enable->exception_index = 0x080;

	    break;

	case MMU_DTLB_VIOLATION_READ:

	    enable->exception_index = 0x0a0;

	    break;

	case MMU_DTLB_VIOLATION_WRITE:

	    enable->exception_index = 0x0c0;

	    break;

	case MMU_IADDR_ERROR:

	case MMU_DADDR_ERROR_READ:

	    enable->exception_index = 0x0c0;

	    break;

	case MMU_DADDR_ERROR_WRITE:

	    enable->exception_index = 0x100;

	    break;

	default:

	    assert(0);

	}

	return 1;

    }



    address &= TARGET_PAGE_MASK;

    physical &= TARGET_PAGE_MASK;



    return tlb_set_page(enable, address, physical, prot, mmu_idx, is_softmmu);

}
",0,0,1,1,"env,address,rw,mmu_idx,is_softmmu,physical,prot,ret,access_type","env:0.38036298751831055,address:0.13541430234909058,rw:0.045417606830596924,mmu_idx:-0.029118895530700684,is_softmmu:0.013211667537689209,physical:-0.13906186819076538,prot:0.23028498888015747,ret:0.25267869234085083,access_type:0.0823976993560791,",1,13,"env:enable,",Greedy,107,0.021096142133076985
297,"static int virtio_blk_device_exit(DeviceState *dev)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    VirtIOBlock *s = VIRTIO_BLK(dev);

#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE

    remove_migration_state_change_notifier(&s->migration_state_notifier);

    virtio_blk_data_plane_destroy(s->dataplane);

    s->dataplane = NULL;

#endif

    qemu_del_vm_change_state_handler(s->change);

    unregister_savevm(dev, ""virtio-blk"", s);

    blockdev_mark_auto_del(s->bs);

    virtio_cleanup(vdev);

    return 0;

}
",84,,1,0,,-4,"dev,vdev,s",,,,,Greedy,1,0.0021069924036661784
298,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    uint64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);

    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);



    mr = ddc->get_memory_region(dimm);

    value = memory_region_size(mr);



    visit_type_uint64(v, name, &value, errp);

}
",81,,1,0,,-4,"obj,v,name,opaque,errp,value,mr,dimm,ddc",,,,,Greedy,1,0.0024251540501912436
299,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;",99,"target_ulong spapr_rtas_call(sPAPREnvironment *spmpr,
                             uint32_t node, uint32_t targ, target_ulong init,
                             uint32_t natresult, target_ulong alt)
{
    if ((node >= TOKEN_BASE)
        && ((node - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *throw = rtas_table + (node - TOKEN_BASE);
        if (throw->fn) {
            throw->fn(spmpr, node, targ, init, natresult, alt);
    hcall_dprintf(""Unknown RTAS token 0x%x
"", node);
    rtas_st(alt, 0, -3);
    return H_PARAMETER;",1,1,1,-1,"spapr,token,nargs,args,nret,rets,call","spapr:7.808208465576172e-06,token:-2.1159648895263672e-05,nargs:-0.0002346038818359375,args:-0.00025069713592529297,nret:-0.00027745962142944336,rets:-0.0004558563232421875,call:0.00036221742630004883,",7,20,"call:throw,spapr:spmpr,token:node,nargs:targ,args:init,nret:natresult,rets:alt,",Greedy,318,0.0568852424621582
300,"static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd)

{

    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);

    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);

    int ret;



    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {

        DPRINTF(""Unimplemented LUN %d\n"", req->lun);

        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));

        scsi_req_complete(&r->req, CHECK_CONDITION);

        return 0;

    }



    if (-1 == scsi_req_parse(&r->req, cmd)) {

        BADF(""Unsupported command length, command %x\n"", cmd[0]);

        scsi_command_complete(r, -EINVAL);

        return 0;

    }

    scsi_req_fixup(&r->req);



    DPRINTF(""Command: lun=%d tag=0x%x len %zd data=0x%02x"", lun, tag,

            r->req.cmd.xfer, cmd[0]);



#ifdef DEBUG_SCSI

    {

        int i;

        for (i = 1; i < r->req.cmd.len; i++) {

            printf("" 0x%02x"", cmd[i]);

        }

        printf(""\n"");

    }

#endif



    if (r->req.cmd.xfer == 0) {

        if (r->buf != NULL)

            qemu_free(r->buf);

        r->buflen = 0;

        r->buf = NULL;

        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);

        if (ret < 0) {

            scsi_command_complete(r, ret);

            return 0;

        }

        return 0;

    }



    if (r->buflen != r->req.cmd.xfer) {

        if (r->buf != NULL)

            qemu_free(r->buf);

        r->buf = qemu_malloc(r->req.cmd.xfer);

        r->buflen = r->req.cmd.xfer;

    }



    memset(r->buf, 0, r->buflen);

    r->len = r->req.cmd.xfer;

    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {

        r->len = 0;

        return -r->req.cmd.xfer;

    } else {

        return r->req.cmd.xfer;

    }

}
",419,"static int32_t scsi_send_command(SCSIRequest *rb, uint8_t *code)

{

    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, rb->dev);

    SCSIGenericReq *rx = DO_UPCAST(SCSIGenericReq, rb, rb);

    int ret;



    if (code[0] != REQUEST_SENSE && rb->lun != s->qdev.lun) {

        DPRINTF(""Unimplemented LUN %d
"", rb->lun);

        scsi_req_build_sense(&rx->rb, SENSE_CODE(LUN_NOT_SUPPORTED));

        scsi_req_complete(&rx->rb, CHECK_CONDITION);

        return 0;

    }



    if (-1 == scsi_req_parse(&rx->rb, code)) {

        BADF(""Unsupported command length, command %x
"", code[0]);

        scsi_command_complete(rx, -EINVAL);

        return 0;

    }

    scsi_req_fixup(&rx->rb);



    DPRINTF(""Command: lun=%d tag=0x%x len %zd data=0x%02x"", lun, tag,

            rx->rb.code.xfer, code[0]);



#ifdef DEBUG_SCSI

    {

        int i;

        for (i = 1; i < rx->rb.code.len; i++) {

            printf("" 0x%02x"", code[i]);

        }

        printf(""
"");

    }

#endif



    if (rx->rb.code.xfer == 0) {

        if (rx->buf != NULL)

            qemu_free(rx->buf);

        rx->buflen = 0;

        rx->buf = NULL;

        ret = execute_command(s->bs, rx, SG_DXFER_NONE, scsi_command_complete);

        if (ret < 0) {

            scsi_command_complete(rx, ret);

            return 0;

        }

        return 0;

    }



    if (rx->buflen != rx->rb.code.xfer) {

        if (rx->buf != NULL)

            qemu_free(rx->buf);

        rx->buf = qemu_malloc(rx->rb.code.xfer);

        rx->buflen = rx->rb.code.xfer;

    }



    memset(rx->buf, 0, rx->buflen);

    rx->len = rx->rb.code.xfer;

    if (rx->rb.code.mode == SCSI_XFER_TO_DEV) {

        rx->len = 0;

        return -rx->rb.code.xfer;

    } else {

        return rx->rb.code.xfer;

    }

}
",0,0,1,1,"req,cmd,s,r,ret,i","req:0.15417881309986115,cmd:0.1805492788553238,s:0.0816410630941391,r:0.6348303258419037,ret:0.10672572255134583,i:0.11534091830253601,",3,67,"r:rx,cmd:code,req:rb,",Greedy,306,0.05783631006876628
301,"void ip6_input(struct mbuf *m)

{

    struct ip6 *ip6;



    DEBUG_CALL(""ip6_input"");

    DEBUG_ARG(""m = %lx"", (long)m);

    DEBUG_ARG(""m_len = %d"", m->m_len);



    if (m->m_len < sizeof(struct ip6)) {

        goto bad;

    }



    ip6 = mtod(m, struct ip6 *);



    if (ip6->ip_v != IP6VERSION) {

        goto bad;

    }



    /* check ip_ttl for a correct ICMP reply */

    if (ip6->ip_hl == 0) {

        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,""ttl"");*/

        goto bad;

    }



    /*

     * Switch out to protocol's input routine.

     */

    switch (ip6->ip_nh) {

    case IPPROTO_TCP:

        /*tcp_input(m, hlen, (struct socket *)NULL);*/

        break;

    case IPPROTO_UDP:

        /*udp_input(m, hlen);*/

        break;

    case IPPROTO_ICMPV6:

        icmp6_input(m);

        break;

    default:

        m_free(m);

    }

    return;

bad:

    m_free(m);

}
",140,"void ip6_input(struct mbuf *b)

{

    struct ip06 *ip06;



    DEBUG_CALL(""ip6_input"");

    DEBUG_ARG(""m = %lx"", (long)b);

    DEBUG_ARG(""m_len = %d"", b->m_len);



    if (b->m_len < sizeof(struct ip06)) {

        goto bad;

    }



    ip06 = mtod(b, struct ip06 *);



    if (ip06->ip_v != IP6VERSION) {

        goto bad;

    }



    /* check ip_ttl for a correct ICMP reply */

    if (ip06->ip_hl == 0) {

        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,""ttl"");*/

        goto bad;

    }



    /*

     * Switch out to protocol's input routine.

     */

    switch (ip06->ip_nh) {

    case IPPROTO_TCP:

        /*tcp_input(m, hlen, (struct socket *)NULL);*/

        break;

    case IPPROTO_UDP:

        /*udp_input(m, hlen);*/

        break;

    case IPPROTO_ICMPV6:

        icmp6_input(b);

        break;

    default:

        m_free(b);

    }

    return;

bad:

    m_free(b);

}
",0,0,1,1,"m,ip6","m:-0.005758434534072876,ip6:-0.3430444300174713,",2,16,"m:b,ip6:ip06,",Greedy,144,0.02758976221084595
302,"void fork_start(void)

{

    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);

    pthread_mutex_lock(&exclusive_lock);

    mmap_fork_start();

}
",27,,0,0,,-3,,,,,,Greedy,1,0.0023987253506978353
303,"static int write_dump_pages(DumpState *s)

{

    int ret = 0;

    DataCache page_desc, page_data;

    size_t len_buf_out, size_out;

#ifdef CONFIG_LZO

    lzo_bytep wrkmem = NULL;

#endif

    uint8_t *buf_out = NULL;

    off_t offset_desc, offset_data;

    PageDescriptor pd, pd_zero;

    uint8_t *buf;

    int endian = s->dump_info.d_endian;

    GuestPhysBlock *block_iter = NULL;

    uint64_t pfn_iter;



    /* get offset of page_desc and page_data in dump file */

    offset_desc = s->offset_page;

    offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable;



    prepare_data_cache(&page_desc, s, offset_desc);

    prepare_data_cache(&page_data, s, offset_data);



    /* prepare buffer to store compressed data */

    len_buf_out = get_len_buf_out(s->page_size, s->flag_compress);

    if (len_buf_out == 0) {

        dump_error(s, ""dump: failed to get length of output buffer.\n"");

        goto out;

    }



#ifdef CONFIG_LZO

    wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS);

#endif



    buf_out = g_malloc(len_buf_out);



    /*

     * init zero page's page_desc and page_data, because every zero page

     * uses the same page_data

     */

    pd_zero.size = cpu_convert_to_target32(s->page_size, endian);

    pd_zero.flags = cpu_convert_to_target32(0, endian);

    pd_zero.offset = cpu_convert_to_target64(offset_data, endian);

    pd_zero.page_flags = cpu_convert_to_target64(0, endian);

    buf = g_malloc0(s->page_size);

    ret = write_cache(&page_data, buf, s->page_size, false);

    g_free(buf);

    if (ret < 0) {

        dump_error(s, ""dump: failed to write page data(zero page).\n"");

        goto out;

    }



    offset_data += s->page_size;



    /*

     * dump memory to vmcore page by page. zero page will all be resided in the

     * first page of page section

     */

    while (get_next_page(&block_iter, &pfn_iter, &buf, s)) {

        /* check zero page */

        if (is_zero_page(buf, s->page_size)) {

            ret = write_cache(&page_desc, &pd_zero, sizeof(PageDescriptor),

                              false);

            if (ret < 0) {

                dump_error(s, ""dump: failed to write page desc.\n"");

                goto out;

            }

        } else {

            /*

             * not zero page, then:

             * 1. compress the page

             * 2. write the compressed page into the cache of page_data

             * 3. get page desc of the compressed page and write it into the

             *    cache of page_desc

             *

             * only one compression format will be used here, for

             * s->flag_compress is set. But when compression fails to work,

             * we fall back to save in plaintext.

             */

             size_out = len_buf_out;

             if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) &&

                    (compress2(buf_out, (uLongf *)&size_out, buf, s->page_size,

                    Z_BEST_SPEED) == Z_OK) && (size_out < s->page_size)) {

                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB,

                                                   endian);

                pd.size  = cpu_convert_to_target32(size_out, endian);



                ret = write_cache(&page_data, buf_out, size_out, false);

                if (ret < 0) {

                    dump_error(s, ""dump: failed to write page data.\n"");

                    goto out;

                }

#ifdef CONFIG_LZO

            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) &&

                    (lzo1x_1_compress(buf, s->page_size, buf_out,

                    (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) &&

                    (size_out < s->page_size)) {

                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO,

                                                   endian);

                pd.size  = cpu_convert_to_target32(size_out, endian);



                ret = write_cache(&page_data, buf_out, size_out, false);

                if (ret < 0) {

                    dump_error(s, ""dump: failed to write page data.\n"");

                    goto out;

                }

#endif

#ifdef CONFIG_SNAPPY

            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) &&

                    (snappy_compress((char *)buf, s->page_size,

                    (char *)buf_out, &size_out) == SNAPPY_OK) &&

                    (size_out < s->page_size)) {

                pd.flags = cpu_convert_to_target32(

                                        DUMP_DH_COMPRESSED_SNAPPY, endian);

                pd.size  = cpu_convert_to_target32(size_out, endian);



                ret = write_cache(&page_data, buf_out, size_out, false);

                if (ret < 0) {

                    dump_error(s, ""dump: failed to write page data.\n"");

                    goto out;

                }

#endif

            } else {

                /*

                 * fall back to save in plaintext, size_out should be

                 * assigned to s->page_size

                 */

                pd.flags = cpu_convert_to_target32(0, endian);

                size_out = s->page_size;

                pd.size = cpu_convert_to_target32(size_out, endian);



                ret = write_cache(&page_data, buf, s->page_size, false);

                if (ret < 0) {

                    dump_error(s, ""dump: failed to write page data.\n"");

                    goto out;

                }

            }



            /* get and write page desc here */

            pd.page_flags = cpu_convert_to_target64(0, endian);

            pd.offset = cpu_convert_to_target64(offset_data, endian);

            offset_data += size_out;



            ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), false);

            if (ret < 0) {

                dump_error(s, ""dump: failed to write page desc.\n"");

                goto out;

            }

        }

    }



    ret = write_cache(&page_desc, NULL, 0, true);

    if (ret < 0) {

        dump_error(s, ""dump: failed to sync cache for page_desc.\n"");

        goto out;

    }

    ret = write_cache(&page_data, NULL, 0, true);

    if (ret < 0) {

        dump_error(s, ""dump: failed to sync cache for page_data.\n"");

        goto out;

    }



out:

    free_data_cache(&page_desc);

    free_data_cache(&page_data);



#ifdef CONFIG_LZO

    g_free(wrkmem);

#endif



    g_free(buf_out);



    return ret;

}
",869,"static int write_dump_pages(DumpState *its)

{

    int ret = 0;

    DataCache page_desc, page_data;

    size_t len_buf_out, size_out;

#ifdef CONFIG_LZO

    lzo_bytep wrkmem = NULL;

#endif

    uint8_t *buf_out = NULL;

    off_t offsetCdoc, offset_data;

    PageDescriptor pd, pd__four;

    uint8_t *b;

    int endian = its->dump_info.d_endian;

    GuestPhysBlock *block_iter = NULL;

    uint64_t pfn_iter;



    /* get offset of page_desc and page_data in dump file */

    offsetCdoc = its->offset_page;

    offset_data = offsetCdoc + sizeof(PageDescriptor) * its->num_dumpable;



    prepare_data_cache(&page_desc, its, offsetCdoc);

    prepare_data_cache(&page_data, its, offset_data);



    /* prepare buffer to store compressed data */

    len_buf_out = get_len_buf_out(its->page_size, its->flag_compress);

    if (len_buf_out == 0) {

        dump_error(its, ""dump: failed to get length of output buffer.
"");

        goto out;

    }



#ifdef CONFIG_LZO

    wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS);

#endif



    buf_out = g_malloc(len_buf_out);



    /*

     * init zero page's page_desc and page_data, because every zero page

     * uses the same page_data

     */

    pd__four.size = cpu_convert_to_target32(its->page_size, endian);

    pd__four.flags = cpu_convert_to_target32(0, endian);

    pd__four.offset = cpu_convert_to_target64(offset_data, endian);

    pd__four.page_flags = cpu_convert_to_target64(0, endian);

    b = g_malloc0(its->page_size);

    ret = write_cache(&page_data, b, its->page_size, false);

    g_free(b);

    if (ret < 0) {

        dump_error(its, ""dump: failed to write page data(zero page).
"");

        goto out;

    }



    offset_data += its->page_size;



    /*

     * dump memory to vmcore page by page. zero page will all be resided in the

     * first page of page section

     */

    while (get_next_page(&block_iter, &pfn_iter, &b, its)) {

        /* check zero page */

        if (is_zero_page(b, its->page_size)) {

            ret = write_cache(&page_desc, &pd__four, sizeof(PageDescriptor),

                              false);

            if (ret < 0) {

                dump_error(its, ""dump: failed to write page desc.
"");

                goto out;

            }

        } else {

            /*

             * not zero page, then:

             * 1. compress the page

             * 2. write the compressed page into the cache of page_data

             * 3. get page desc of the compressed page and write it into the

             *    cache of page_desc

             *

             * only one compression format will be used here, for

             * s->flag_compress is set. But when compression fails to work,

             * we fall back to save in plaintext.

             */

             size_out = len_buf_out;

             if ((its->flag_compress & DUMP_DH_COMPRESSED_ZLIB) &&

                    (compress2(buf_out, (uLongf *)&size_out, b, its->page_size,

                    Z_BEST_SPEED) == Z_OK) && (size_out < its->page_size)) {

                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB,

                                                   endian);

                pd.size  = cpu_convert_to_target32(size_out, endian);



                ret = write_cache(&page_data, buf_out, size_out, false);

                if (ret < 0) {

                    dump_error(its, ""dump: failed to write page data.
"");

                    goto out;

                }

#ifdef CONFIG_LZO

            } else if ((its->flag_compress & DUMP_DH_COMPRESSED_LZO) &&

                    (lzo1x_1_compress(b, its->page_size, buf_out,

                    (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) &&

                    (size_out < its->page_size)) {

                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO,

                                                   endian);

                pd.size  = cpu_convert_to_target32(size_out, endian);



                ret = write_cache(&page_data, buf_out, size_out, false);

                if (ret < 0) {

                    dump_error(its, ""dump: failed to write page data.
"");

                    goto out;

                }

#endif

#ifdef CONFIG_SNAPPY

            } else if ((its->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) &&

                    (snappy_compress((char *)b, its->page_size,

                    (char *)buf_out, &size_out) == SNAPPY_OK) &&

                    (size_out < its->page_size)) {

                pd.flags = cpu_convert_to_target32(

                                        DUMP_DH_COMPRESSED_SNAPPY, endian);

                pd.size  = cpu_convert_to_target32(size_out, endian);



                ret = write_cache(&page_data, buf_out, size_out, false);

                if (ret < 0) {

                    dump_error(its, ""dump: failed to write page data.
"");

                    goto out;

                }

#endif

            } else {

                /*

                 * fall back to save in plaintext, size_out should be

                 * assigned to s->page_size

                 */

                pd.flags = cpu_convert_to_target32(0, endian);

                size_out = its->page_size;

                pd.size = cpu_convert_to_target32(size_out, endian);



                ret = write_cache(&page_data, b, its->page_size, false);

                if (ret < 0) {

                    dump_error(its, ""dump: failed to write page data.
"");

                    goto out;

                }

            }



            /* get and write page desc here */

            pd.page_flags = cpu_convert_to_target64(0, endian);

            pd.offset = cpu_convert_to_target64(offset_data, endian);

            offset_data += size_out;



            ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), false);

            if (ret < 0) {

                dump_error(its, ""dump: failed to write page desc.
"");

                goto out;

            }

        }

    }



    ret = write_cache(&page_desc, NULL, 0, true);

    if (ret < 0) {

        dump_error(its, ""dump: failed to sync cache for page_desc.
"");

        goto out;

    }

    ret = write_cache(&page_data, NULL, 0, true);

    if (ret < 0) {

        dump_error(its, ""dump: failed to sync cache for page_data.
"");

        goto out;

    }



out:

    free_data_cache(&page_desc);

    free_data_cache(&page_data);



#ifdef CONFIG_LZO

    g_free(wrkmem);

#endif



    g_free(buf_out);



    return ret;

}
",0,0,1,1,"s,page_desc,page_data,len_buf_out,size_out,buf_out,offset_desc,offset_data,pd,pd_zero,buf,block_iter,pfn_iter","s:0.10314194858074188,page_desc:0.040081724524497986,page_data:0.026010990142822266,len_buf_out:-0.018981382250785828,size_out:0.027408450841903687,buf_out:0.04440818727016449,offset_desc:0.14717930555343628,offset_data:0.096917524933815,pd:-0.005672886967658997,pd_zero:0.11408226191997528,buf:0.10055872797966003,block_iter:0.035019129514694214,pfn_iter:0.08070479333400726,",4,55,"offset_desc:offsetCdoc,pd_zero:pd__four,s:its,buf:b,",Greedy,386,0.0998210867245992
304,"static void do_ext_interrupt(CPUS390XState *env)

{

    S390CPU *cpu = s390_env_get_cpu(env);

    uint64_t mask, addr;

    LowCore *lowcore;

    ExtQueue *q;



    if (!(env->psw.mask & PSW_MASK_EXT)) {

        cpu_abort(CPU(cpu), ""Ext int w/o ext mask\n"");

    }



    lowcore = cpu_map_lowcore(env);



    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {

        lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);

        lowcore->cpu_addr = 0;

        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;

    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {

        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);

        lowcore->cpu_addr = 0;

        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;

    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {

        g_assert(env->ext_index >= 0);

        /*

         * FIXME: floating IRQs should be considered by all CPUs and

         *        shuld not get cleared by CPU reset.

         */

        q = &env->ext_queue[env->ext_index];

        lowcore->ext_int_code = cpu_to_be16(q->code);

        lowcore->ext_params = cpu_to_be32(q->param);

        lowcore->ext_params2 = cpu_to_be64(q->param64);

        lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);

        env->ext_index--;

        if (env->ext_index == -1) {

            env->pending_int &= ~INTERRUPT_EXT_SERVICE;

        }

    } else {

        g_assert_not_reached();

    }



    mask = be64_to_cpu(lowcore->external_new_psw.mask);

    addr = be64_to_cpu(lowcore->external_new_psw.addr);

    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));

    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);



    cpu_unmap_lowcore(lowcore);



    DPRINTF(""%s: %"" PRIx64 "" %"" PRIx64 ""\n"", __func__,

            env->psw.mask, env->psw.addr);



    load_psw(env, mask, addr);

}
",328,,0,1,,-4,"env,cpu,mask,addr,lowcore,q,ext_index",,,,,Greedy,1,0.002160298824310303
305,"static void verdex_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    PXA2xxState *cpu;

    DriveInfo *dinfo;

    int be;

    MemoryRegion *address_space_mem = get_system_memory();



    uint32_t verdex_rom = 0x02000000;

    uint32_t verdex_ram = 0x10000000;



    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: ""pxa270-c0"");



    dinfo = drive_get(IF_PFLASH, 0, 0);

    if (!dinfo && !qtest_enabled()) {

        fprintf(stderr, ""A flash image must be given with the ""

                ""'pflash' parameter\n"");

        exit(1);

    }



#ifdef TARGET_WORDS_BIGENDIAN

    be = 1;

#else

    be = 0;

#endif

    if (!pflash_cfi01_register(0x00000000, NULL, ""verdex.rom"", verdex_rom,

                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                               sector_len, verdex_rom / sector_len,

                               2, 0, 0, 0, 0, be)) {

        fprintf(stderr, ""qemu: Error registering flash memory.\n"");

        exit(1);

    }



    /* Interrupt line of NIC is connected to GPIO line 99 */

    smc91c111_init(&nd_table[0], 0x04000300,

                    qdev_get_gpio_in(cpu->gpio, 99));

}
",194,"static void verdex_init(MachineState *connection)

{

    const char *gpu_model = connection->gpu_model;

    PXA2xxState *bench;

    DriveInfo *ldfi;

    int sb;

    MemoryRegion *address_system_ram = get_system_memory();



    uint32_t verdex_rom = 0x02000000;

    uint32_t verdex_ram = 0x10000000;



    bench = pxa270_init(address_system_ram, verdex_ram, gpu_model ?: ""pxa270-c0"");



    ldfi = drive_get(IF_PFLASH, 0, 0);

    if (!ldfi && !qtest_enabled()) {

        fprintf(stderr, ""A flash image must be given with the ""

                ""'pflash' parameter
"");

        exit(1);

    }



#ifdef TARGET_WORDS_BIGENDIAN

    sb = 1;

#else

    sb = 0;

#endif

    if (!pflash_cfi01_register(0x00000000, NULL, ""verdex.rom"", verdex_rom,

                               ldfi ? blk_bs(blk_by_legacy_dinfo(ldfi)) : NULL,

                               sector_len, verdex_rom / sector_len,

                               2, 0, 0, 0, 0, sb)) {

        fprintf(stderr, ""qemu: Error registering flash memory.
"");

        exit(1);

    }



    /* Interrupt line of NIC is connected to GPIO line 99 */

    smc91c111_init(&nd_table[0], 0x04000300,

                    qdev_get_gpio_in(bench->gpio, 99));

}
",0,0,0,-1,"machine,cpu_model,cpu,dinfo,be,address_space_mem","machine:0.001574372872710228,cpu_model:0.0025108717381954193,cpu:0.0031373929232358932,dinfo:0.0031306613236665726,be:0.0004801512695848942,address_space_mem:0.0028082896023988724,",6,19,"cpu:bench,dinfo:ldfi,address_space_mem:address_system_ram,cpu_model:gpu_model,machine:connection,be:sb,",Greedy,251,0.05203102032343546
306,"static int bochs_open(BlockDriverState *bs, QDict *options, int flags,
                      Error **errp)
{
    BDRVBochsState *s = bs->opaque;
    uint32_t i;
    struct bochs_header bochs;
    int ret;
    bs->read_only = 1; // no write support yet
    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));
    if (ret < 0) {
        return ret;
    if (strcmp(bochs.magic, HEADER_MAGIC) ||
        strcmp(bochs.type, REDOLOG_TYPE) ||
        strcmp(bochs.subtype, GROWING_TYPE) ||
	((le32_to_cpu(bochs.version) != HEADER_VERSION) &&
	(le32_to_cpu(bochs.version) != HEADER_V1))) {
        error_setg(errp, ""Image not in Bochs format"");
        return -EINVAL;
    if (le32_to_cpu(bochs.version) == HEADER_V1) {
        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;
    } else {
        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;
    s->catalog_size = le32_to_cpu(bochs.catalog);
    s->catalog_bitmap = g_malloc(s->catalog_size * 4);
    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,
                     s->catalog_size * 4);
    if (ret < 0) {
        goto fail;
    for (i = 0; i < s->catalog_size; i++)
	le32_to_cpus(&s->catalog_bitmap[i]);
    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);
    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;
    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;
    s->extent_size = le32_to_cpu(bochs.extent);
    if (s->catalog_size < bs->total_sectors / s->extent_size) {
        error_setg(errp, ""Catalog size is too small for this disk size"");
        ret = -EINVAL;
        goto fail;
    qemu_co_mutex_init(&s->lock);
    return 0;
fail:
    g_free(s->catalog_bitmap);
    return ret;",397,"static int bochs_open(BlockDriverState *bl, QDict *Options, int ips,
                      Error **errorper)
{
    BDRVBochsState *http = bl->opaque;
    uint32_t multi;
    struct bochs_header bopathins;
    int fail;
    bl->read_only = 1; // no write support yet
    fail = bdrv_pread(bl->file, 0, &bopathins, sizeof(bopathins));
    if (fail < 0) {
        return fail;
    if (strcmp(bopathins.magic, HEADER_MAGIC) ||
        strcmp(bopathins.type, REDOLOG_TYPE) ||
        strcmp(bopathins.subtype, GROWING_TYPE) ||
	((le32_to_cpu(bopathins.version) != HEADER_VERSION) &&
	(le32_to_cpu(bopathins.version) != HEADER_V1))) {
        error_setg(errorper, ""Image not in Bochs format"");
        return -EINVAL;
    if (le32_to_cpu(bopathins.version) == HEADER_V1) {
        bl->total_sectors = le64_to_cpu(bopathins.extra.redolog_v1.disk) / 512;
    } else {
        bl->total_sectors = le64_to_cpu(bopathins.extra.redolog.disk) / 512;
    http->catalog_size = le32_to_cpu(bopathins.catalog);
    http->catalog_bitmap = g_malloc(http->catalog_size * 4);
    fail = bdrv_pread(bl->file, le32_to_cpu(bopathins.header), http->catalog_bitmap,
                     http->catalog_size * 4);
    if (fail < 0) {
        goto fail;
    for (multi = 0; multi < http->catalog_size; multi++)
	le32_to_cpus(&http->catalog_bitmap[multi]);
    http->data_offset = le32_to_cpu(bopathins.header) + (http->catalog_size * 4);
    http->bitmap_blocks = 1 + (le32_to_cpu(bopathins.bitmap) - 1) / 512;
    http->extent_blocks = 1 + (le32_to_cpu(bopathins.extent) - 1) / 512;
    http->extent_size = le32_to_cpu(bopathins.extent);
    if (http->catalog_size < bl->total_sectors / http->extent_size) {
        error_setg(errorper, ""Catalog size is too small for this disk size"");
        fail = -EINVAL;
        goto fail;
    qemu_co_mutex_init(&http->lock);
    return 0;
fail:
    g_free(http->catalog_bitmap);
    return fail;",1,1,1,-1,"bs,options,flags,errp,s,i,bochs,ret","bs:0.00018781423568725586,options:4.106760025024414e-05,flags:9.489059448242188e-05,errp:-1.424551010131836e-05,s:0.00019669532775878906,i:7.534027099609375e-05,bochs:0.0004254579544067383,ret:5.626678466796875e-05,",8,60,"bochs:bopathins,s:http,bs:bl,flags:ips,i:multi,ret:fail,options:Options,errp:errorper,",Greedy,633,0.12084441979726156
307,"offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)

{

    offset_t offset1;

    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));



    if (whence != SEEK_CUR && whence != SEEK_SET)

        return -EINVAL;



    if (whence == SEEK_CUR) {

        offset1 = pos + (s->buf_ptr - s->buffer);

        if (offset == 0)

            return offset1;

        offset += offset1;

    }

    offset1 = offset - pos;

    if (!s->must_flush &&

        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {

        /* can do the seek inside the buffer */

        s->buf_ptr = s->buffer + offset1;

    } else {

        if (!s->seek)

            return -EPIPE;



#ifdef CONFIG_MUXERS

        if (s->write_flag) {

            flush_buffer(s);

            s->must_flush = 1;

        } else

#endif //CONFIG_MUXERS

        {

            s->buf_end = s->buffer;

        }

        s->buf_ptr = s->buffer;

        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)

            return -EPIPE;

        s->pos = offset;

    }

    s->eof_reached = 0;

    return offset;

}
",228,,1,0,,-4,"s,offset,whence,offset1",,,,,Greedy,1,0.0022051215171813967
308,"void ppc_translate_init(void)

{

    int i;

    char* p;

    size_t cpu_reg_names_size;

    static int done_init = 0;



    if (done_init)

        return;



    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, ""env"");



    p = cpu_reg_names;

    cpu_reg_names_size = sizeof(cpu_reg_names);



    for (i = 0; i < 8; i++) {

        snprintf(p, cpu_reg_names_size, ""crf%d"", i);

        cpu_crf[i] = tcg_global_mem_new_i32(TCG_AREG0,

                                            offsetof(CPUState, crf[i]), p);

        p += 5;

        cpu_reg_names_size -= 5;

    }



    for (i = 0; i < 32; i++) {

        snprintf(p, cpu_reg_names_size, ""r%d"", i);

        cpu_gpr[i] = tcg_global_mem_new(TCG_AREG0,

                                        offsetof(CPUState, gpr[i]), p);

        p += (i < 10) ? 3 : 4;

        cpu_reg_names_size -= (i < 10) ? 3 : 4;

#if !defined(TARGET_PPC64)

        snprintf(p, cpu_reg_names_size, ""r%dH"", i);

        cpu_gprh[i] = tcg_global_mem_new_i32(TCG_AREG0,

                                             offsetof(CPUState, gprh[i]), p);

        p += (i < 10) ? 4 : 5;

        cpu_reg_names_size -= (i < 10) ? 4 : 5;

#endif



        snprintf(p, cpu_reg_names_size, ""fp%d"", i);

        cpu_fpr[i] = tcg_global_mem_new_i64(TCG_AREG0,

                                            offsetof(CPUState, fpr[i]), p);

        p += (i < 10) ? 4 : 5;

        cpu_reg_names_size -= (i < 10) ? 4 : 5;



        snprintf(p, cpu_reg_names_size, ""avr%dH"", i);

#ifdef HOST_WORDS_BIGENDIAN

        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,

                                             offsetof(CPUState, avr[i].u64[0]), p);

#else

        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,

                                             offsetof(CPUState, avr[i].u64[1]), p);

#endif

        p += (i < 10) ? 6 : 7;

        cpu_reg_names_size -= (i < 10) ? 6 : 7;



        snprintf(p, cpu_reg_names_size, ""avr%dL"", i);

#ifdef HOST_WORDS_BIGENDIAN

        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,

                                             offsetof(CPUState, avr[i].u64[1]), p);

#else

        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,

                                             offsetof(CPUState, avr[i].u64[0]), p);

#endif

        p += (i < 10) ? 6 : 7;

        cpu_reg_names_size -= (i < 10) ? 6 : 7;

    }



    cpu_nip = tcg_global_mem_new(TCG_AREG0,

                                 offsetof(CPUState, nip), ""nip"");



    cpu_msr = tcg_global_mem_new(TCG_AREG0,

                                 offsetof(CPUState, msr), ""msr"");



    cpu_ctr = tcg_global_mem_new(TCG_AREG0,

                                 offsetof(CPUState, ctr), ""ctr"");



    cpu_lr = tcg_global_mem_new(TCG_AREG0,

                                offsetof(CPUState, lr), ""lr"");



    cpu_xer = tcg_global_mem_new(TCG_AREG0,

                                 offsetof(CPUState, xer), ""xer"");



    cpu_reserve = tcg_global_mem_new(TCG_AREG0,

                                     offsetof(CPUState, reserve), ""reserve"");



    cpu_fpscr = tcg_global_mem_new_i32(TCG_AREG0,

                                       offsetof(CPUState, fpscr), ""fpscr"");



    cpu_access_type = tcg_global_mem_new_i32(TCG_AREG0,

                                             offsetof(CPUState, access_type), ""access_type"");



    /* register helpers */

#define GEN_HELPER 2

#include ""helper.h""



    done_init = 1;

}
",640,"void ppc_translate_init(void)

{

    int chi;

    char* post;

    size_t cpu_reg_namespscale;

    static int done_init = 0;



    if (done_init)

        return;



    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, ""env"");



    post = cpu_reg_names;

    cpu_reg_namespscale = sizeof(cpu_reg_names);



    for (chi = 0; chi < 8; chi++) {

        snprintf(post, cpu_reg_namespscale, ""crf%d"", chi);

        cpu_crf[chi] = tcg_global_mem_new_i32(TCG_AREG0,

                                            offsetof(CPUState, crf[chi]), post);

        post += 5;

        cpu_reg_namespscale -= 5;

    }



    for (chi = 0; chi < 32; chi++) {

        snprintf(post, cpu_reg_namespscale, ""r%d"", chi);

        cpu_gpr[chi] = tcg_global_mem_new(TCG_AREG0,

                                        offsetof(CPUState, gpr[chi]), post);

        post += (chi < 10) ? 3 : 4;

        cpu_reg_namespscale -= (chi < 10) ? 3 : 4;

#if !defined(TARGET_PPC64)

        snprintf(post, cpu_reg_namespscale, ""r%dH"", chi);

        cpu_gprh[chi] = tcg_global_mem_new_i32(TCG_AREG0,

                                             offsetof(CPUState, gprh[chi]), post);

        post += (chi < 10) ? 4 : 5;

        cpu_reg_namespscale -= (chi < 10) ? 4 : 5;

#endif



        snprintf(post, cpu_reg_namespscale, ""fp%d"", chi);

        cpu_fpr[chi] = tcg_global_mem_new_i64(TCG_AREG0,

                                            offsetof(CPUState, fpr[chi]), post);

        post += (chi < 10) ? 4 : 5;

        cpu_reg_namespscale -= (chi < 10) ? 4 : 5;



        snprintf(post, cpu_reg_namespscale, ""avr%dH"", chi);

#ifdef HOST_WORDS_BIGENDIAN

        cpu_avrh[chi] = tcg_global_mem_new_i64(TCG_AREG0,

                                             offsetof(CPUState, avr[chi].u64[0]), post);

#else

        cpu_avrh[chi] = tcg_global_mem_new_i64(TCG_AREG0,

                                             offsetof(CPUState, avr[chi].u64[1]), post);

#endif

        post += (chi < 10) ? 6 : 7;

        cpu_reg_namespscale -= (chi < 10) ? 6 : 7;



        snprintf(post, cpu_reg_namespscale, ""avr%dL"", chi);

#ifdef HOST_WORDS_BIGENDIAN

        cpu_avrl[chi] = tcg_global_mem_new_i64(TCG_AREG0,

                                             offsetof(CPUState, avr[chi].u64[1]), post);

#else

        cpu_avrl[chi] = tcg_global_mem_new_i64(TCG_AREG0,

                                             offsetof(CPUState, avr[chi].u64[0]), post);

#endif

        post += (chi < 10) ? 6 : 7;

        cpu_reg_namespscale -= (chi < 10) ? 6 : 7;

    }



    cpu_nip = tcg_global_mem_new(TCG_AREG0,

                                 offsetof(CPUState, nip), ""nip"");



    cpu_msr = tcg_global_mem_new(TCG_AREG0,

                                 offsetof(CPUState, msr), ""msr"");



    cpu_ctr = tcg_global_mem_new(TCG_AREG0,

                                 offsetof(CPUState, ctr), ""ctr"");



    cpu_lr = tcg_global_mem_new(TCG_AREG0,

                                offsetof(CPUState, lr), ""lr"");



    cpu_xer = tcg_global_mem_new(TCG_AREG0,

                                 offsetof(CPUState, xer), ""xer"");



    cpu_reserve = tcg_global_mem_new(TCG_AREG0,

                                     offsetof(CPUState, reserve), ""reserve"");



    cpu_fpscr = tcg_global_mem_new_i32(TCG_AREG0,

                                       offsetof(CPUState, fpscr), ""fpscr"");



    cpu_access_type = tcg_global_mem_new_i32(TCG_AREG0,

                                             offsetof(CPUState, access_type), ""access_type"");



    /* register helpers */

#define GEN_HELPER 2

#include ""helper.h""



    done_init = 1;

}
",0,0,1,1,"i,p,cpu_reg_names_size","i:0.033981651067733765,p:0.09658873826265335,cpu_reg_names_size:0.5282839313149452,",3,75,"cpu_reg_names_size:cpu_reg_namespscale,p:post,i:chi,",Greedy,265,0.05810803174972534
309,"static void gen_mtfsfi(DisasContext *ctx)

{

    int bf, sh;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ctx->fpu_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_FPU);

        return;

    }

    bf = crbD(ctx->opcode) >> 2;

    sh = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));

    t1 = tcg_const_i32(1 << sh);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ctx->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}
",166,"static void gen_mtfsfi(DisasContext *cms)

{

    int fee, q;

    TCGv_i64 t00;

    TCGv_i32 tt61;



    if (unlikely(!cms->fpu_enabled)) {

        gen_exception(cms, POWERPC_EXCP_FPU);

        return;

    }

    fee = crbD(cms->opcode) >> 2;

    q = 7 - fee;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(cms, cms->nip - 4);

    gen_reset_fpstatus();

    t00 = tcg_const_i64(FPIMM(cms->opcode) << (4 * q));

    tt61 = tcg_const_i32(1 << q);

    gen_helper_store_fpscr(cpu_env, t00, tt61);

    tcg_temp_free_i64(t00);

    tcg_temp_free_i32(tt61);

    if (unlikely(Rc(cms->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}
",0,0,0,-1,"ctx,bf,sh,t0,t1","ctx:-0.0018009832128882408,bf:0.00390905886888504,sh:0.0012795496731996536,t0:-0.00035888608545064926,t1:0.002872793935239315,",5,23,"bf:fee,t1:tt61,sh:q,t0:t00,ctx:cms,",Greedy,272,0.051417271296183266
310,"void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)

{

    int i;

    size_t pagesize = getpagesize();



    memory = (memory + pagesize - 1) & -pagesize;

    for (i = 0; i < memory / pagesize; i++) {

        memset(area + pagesize * i, 0, 1);

    }

}
",73,,1,0,,-4,"fd,area,memory,errp,i",,,,,Greedy,1,0.00198818842569987
311,"static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)

{

    CuvidContext *ctx = avctx->priv_data;

    AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data;

    AVCUDADeviceContext *device_hwctx = device_ctx->hwctx;

    CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx;

    AVFrame *frame = data;

    CUVIDSOURCEDATAPACKET cupkt;

    AVPacket filter_packet = { 0 };

    AVPacket filtered_packet = { 0 };

    CUdeviceptr mapped_frame = 0;

    int ret = 0, eret = 0;



    if (ctx->bsf && avpkt->size) {

        if ((ret = av_packet_ref(&filter_packet, avpkt)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""av_packet_ref failed\n"");

            return ret;

        }



        if ((ret = av_bsf_send_packet(ctx->bsf, &filter_packet)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""av_bsf_send_packet failed\n"");

            av_packet_unref(&filter_packet);

            return ret;

        }



        if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""av_bsf_receive_packet failed\n"");

            return ret;

        }



        avpkt = &filtered_packet;

    }



    ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx));

    if (ret < 0) {

        av_packet_unref(&filtered_packet);

        return ret;

    }



    memset(&cupkt, 0, sizeof(cupkt));



    if (avpkt->size) {

        cupkt.payload_size = avpkt->size;

        cupkt.payload = avpkt->data;



        if (avpkt->pts != AV_NOPTS_VALUE) {

            cupkt.flags = CUVID_PKT_TIMESTAMP;

            if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)

                cupkt.timestamp = av_rescale_q(avpkt->pts, avctx->pkt_timebase, (AVRational){1, 10000000});

            else

                cupkt.timestamp = avpkt->pts;

        }

    } else {

        cupkt.flags = CUVID_PKT_ENDOFSTREAM;

    }



    ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt));



    av_packet_unref(&filtered_packet);



    if (ret < 0) {

        if (ctx->internal_error)

            ret = ctx->internal_error;

        goto error;

    }



    if (av_fifo_size(ctx->frame_queue)) {

        CUVIDPARSERDISPINFO dispinfo;

        CUVIDPROCPARAMS params;

        unsigned int pitch = 0;

        int offset = 0;

        int i;



        av_fifo_generic_read(ctx->frame_queue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL);



        memset(&params, 0, sizeof(params));

        params.progressive_frame = dispinfo.progressive_frame;

        params.second_field = 0;

        params.top_field_first = dispinfo.top_field_first;



        ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params));

        if (ret < 0)

            goto error;



        if (avctx->pix_fmt == AV_PIX_FMT_CUDA) {

            ret = av_hwframe_get_buffer(ctx->hwframe, frame, 0);

            if (ret < 0) {

                av_log(avctx, AV_LOG_ERROR, ""av_hwframe_get_buffer failed\n"");

                goto error;

            }



            ret = ff_decode_frame_props(avctx, frame);

            if (ret < 0) {

                av_log(avctx, AV_LOG_ERROR, ""ff_decode_frame_props failed\n"");

                goto error;

            }



            for (i = 0; i < 2; i++) {

                CUDA_MEMCPY2D cpy = {

                    .srcMemoryType = CU_MEMORYTYPE_DEVICE,

                    .dstMemoryType = CU_MEMORYTYPE_DEVICE,

                    .srcDevice     = mapped_frame,

                    .dstDevice     = (CUdeviceptr)frame->data[i],

                    .srcPitch      = pitch,

                    .dstPitch      = frame->linesize[i],

                    .srcY          = offset,

                    .WidthInBytes  = FFMIN(pitch, frame->linesize[i]),

                    .Height        = avctx->coded_height >> (i ? 1 : 0),

                };



                ret = CHECK_CU(cuMemcpy2D(&cpy));

                if (ret < 0)

                    goto error;



                offset += avctx->coded_height;

            }

        } else if (avctx->pix_fmt == AV_PIX_FMT_NV12) {

            AVFrame *tmp_frame = av_frame_alloc();

            if (!tmp_frame) {

                av_log(avctx, AV_LOG_ERROR, ""av_frame_alloc failed\n"");

                ret = AVERROR(ENOMEM);

                goto error;

            }



            tmp_frame->format        = AV_PIX_FMT_CUDA;

            tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe);

            tmp_frame->data[0]       = (uint8_t*)mapped_frame;

            tmp_frame->linesize[0]   = pitch;

            tmp_frame->data[1]       = (uint8_t*)(mapped_frame + avctx->coded_height * pitch);

            tmp_frame->linesize[1]   = pitch;

            tmp_frame->width         = avctx->width;

            tmp_frame->height        = avctx->height;



            ret = ff_get_buffer(avctx, frame, 0);

            if (ret < 0) {

                av_log(avctx, AV_LOG_ERROR, ""ff_get_buffer failed\n"");

                av_frame_free(&tmp_frame);

                goto error;

            }



            ret = av_hwframe_transfer_data(frame, tmp_frame, 0);

            if (ret) {

                av_log(avctx, AV_LOG_ERROR, ""av_hwframe_transfer_data failed\n"");

                av_frame_free(&tmp_frame);

                goto error;

            }



            av_frame_free(&tmp_frame);

        } else {

            ret = AVERROR_BUG;

            goto error;

        }



        frame->width = avctx->width;

        frame->height = avctx->height;

        if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)

            frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase);

        else

            frame->pts = dispinfo.timestamp;



        /* CUVIDs opaque reordering breaks the internal pkt logic.

         * So set pkt_pts and clear all the other pkt_ fields.

         */

        frame->pkt_pts = frame->pts;

        av_frame_set_pkt_pos(frame, -1);

        av_frame_set_pkt_duration(frame, 0);

        av_frame_set_pkt_size(frame, -1);



        frame->interlaced_frame = !dispinfo.progressive_frame;



        if (!dispinfo.progressive_frame)

            frame->top_field_first = dispinfo.top_field_first;



        *got_frame = 1;

    } else {

        *got_frame = 0;

    }



error:

    if (mapped_frame)

        eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame));



    eret = CHECK_CU(cuCtxPopCurrent(&dummy));



    if (eret < 0)

        return eret;

    else

        return ret;

}
",1108,,1,0,,-4,"avctx,data,got_frame,avpkt,ctx,device_ctx,device_hwctx,dummy,frame,cupkt",,,,,Greedy,1,0.0025121132532755536
312,"static void hotplug(void)

{

    qtest_start(""-device virtio-net-pci"");



    qpci_plug_device_test(""virtio-net-pci"", ""net1"", PCI_SLOT_HP, NULL);

    qpci_unplug_acpi_device_test(""net1"", PCI_SLOT_HP);



    test_end();

}
",39,,0,0,,-3,,,,,,Greedy,1,0.0020725409189860026
313,"static void ff_h264_idct8_add_sse2(uint8_t *dst, int16_t *block, int stride)

{

    __asm__ volatile(

        ""movdqa   0x10(%1), %%xmm1 \n""

        ""movdqa   0x20(%1), %%xmm2 \n""

        ""movdqa   0x30(%1), %%xmm3 \n""

        ""movdqa   0x50(%1), %%xmm5 \n""

        ""movdqa   0x60(%1), %%xmm6 \n""

        ""movdqa   0x70(%1), %%xmm7 \n""

        H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7)

        TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1))

        ""paddw          %4, %%xmm4 \n""

        ""movdqa     %%xmm4, 0x00(%1) \n""

        ""movdqa     %%xmm2, 0x40(%1) \n""

        H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1)

        ""movdqa     %%xmm6, 0x60(%1) \n""

        ""movdqa     %%xmm7, 0x70(%1) \n""

        ""pxor       %%xmm7, %%xmm7 \n""

        STORE_DIFF_8P(%%xmm2, (%0),      %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm0, (%0,%2),   %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm3, (%0,%3),   %%xmm6, %%xmm7)

        ""lea     (%0,%2,4), %0 \n""

        STORE_DIFF_8P(%%xmm5, (%0),      %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm4, (%0,%2),   %%xmm6, %%xmm7)

        ""movdqa   0x60(%1), %%xmm0 \n""

        ""movdqa   0x70(%1), %%xmm1 \n""

        STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm1, (%0,%3),   %%xmm6, %%xmm7)

        :""+r""(dst)

        :""r""(block), ""r""((x86_reg)stride), ""r""((x86_reg)3L*stride), ""m""(ff_pw_32)

    );

}
",376,"static void ff_h264_idct8_add_sse2(uint8_t *dst, int16_t *block, int stride)

{

    __asm__ volatile(

        ""movdqa   0x10(%1), %%xmm1 \n""

        ""movdqa   0x20(%1), %%xmm2 \n""

        ""movdqa   0x30(%1), %%xmm3 \n""

        ""movdqa   0x50(%1), %%xmm5 \n""

        ""movdqa   0x60(%1), %%xmm6 \n""

        ""movdqa   0x70(%1), %%xmm7 \n""

        H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7)

        TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1))

        ""paddw          %4, %%xmm4 \n""

        ""movdqa     %%xmm4, 0x00(%1) \n""

        ""movdqa     %%xmm2, 0x40(%1) \n""

        H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1)

        ""movdqa     %%xmm6, 0x60(%1) \n""

        ""movdqa     %%xmm7, 0x70(%1) \n""

        ""pxor       %%xmm7, %%xmm7 \n""

        STORE_DIFF_8P(%%xmm2, (%0),      %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm0, (%0,%2),   %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm3, (%0,%3),   %%xmm6, %%xmm7)

        ""lea     (%0,%2,4), %0 \n""

        STORE_DIFF_8P(%%xmm5, (%0),      %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm4, (%0,%2),   %%xmm6, %%xmm7)

        ""movdqa   0x60(%1), %%xmm0 \n""

        ""movdqa   0x70(%1), %%xmm1 \n""

        STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm1, (%0,%3),   %%xmm6, %%xmm7)

        :""+r""(dst)

        :""r""(block), ""r""((x86_reg)stride), ""r""((x86_reg)3L*stride), ""m""(ff_pw_32)

    );

}
",0,0,0,-1,"dst,block,stride","dst:0.00016143545508384705,block:1.079728826880455e-05,stride:-5.639251321554184e-05,",0,0,"dst:dst,block:block,stride:stride,",Greedy,64,0.02098610003789266
314,"static void ide_identify(IDEState *s)

{

    uint16_t *p;

    unsigned int oldsize;



    memset(s->io_buffer, 0, 512);

    p = (uint16_t *)s->io_buffer;

    stw(p + 0, 0x0040);

    stw(p + 1, s->cylinders); 

    stw(p + 3, s->heads);

    stw(p + 4, 512 * s->sectors); /* sectors */

    stw(p + 5, 512); /* sector size */

    stw(p + 6, s->sectors); 

    stw(p + 20, 3); /* buffer type */

    stw(p + 21, 512); /* cache size in sectors */

    stw(p + 22, 4); /* ecc bytes */

    padstr((uint8_t *)(p + 27), ""QEMU HARDDISK"", 40);

#if MAX_MULT_SECTORS > 1    

    stw(p + 47, MAX_MULT_SECTORS);

#endif

    stw(p + 48, 1); /* dword I/O */

    stw(p + 49, 1 << 9); /* LBA supported, no DMA */

    stw(p + 51, 0x200); /* PIO transfer cycle */

    stw(p + 52, 0x200); /* DMA transfer cycle */

    stw(p + 54, s->cylinders);

    stw(p + 55, s->heads);

    stw(p + 56, s->sectors);

    oldsize = s->cylinders * s->heads * s->sectors;

    stw(p + 57, oldsize);

    stw(p + 58, oldsize >> 16);

    if (s->mult_sectors)

        stw(p + 59, 0x100 | s->mult_sectors);

    stw(p + 60, s->nb_sectors);

    stw(p + 61, s->nb_sectors >> 16);

    stw(p + 80, (1 << 1) | (1 << 2));

    stw(p + 82, (1 << 14));

    stw(p + 83, (1 << 14));

    stw(p + 84, (1 << 14));

    stw(p + 85, (1 << 14));

    stw(p + 86, 0);

    stw(p + 87, (1 << 14));

}
",404,"static void ide_identify(IDEState *sis)

{

    uint16_t *data;

    unsigned int oldersmall;



    memset(sis->io_buffer, 0, 512);

    data = (uint16_t *)sis->io_buffer;

    stw(data + 0, 0x0040);

    stw(data + 1, sis->cylinders); 

    stw(data + 3, sis->heads);

    stw(data + 4, 512 * sis->sectors); /* sectors */

    stw(data + 5, 512); /* sector size */

    stw(data + 6, sis->sectors); 

    stw(data + 20, 3); /* buffer type */

    stw(data + 21, 512); /* cache size in sectors */

    stw(data + 22, 4); /* ecc bytes */

    padstr((uint8_t *)(data + 27), ""QEMU HARDDISK"", 40);

#if MAX_MULT_SECTORS > 1    

    stw(data + 47, MAX_MULT_SECTORS);

#endif

    stw(data + 48, 1); /* dword I/O */

    stw(data + 49, 1 << 9); /* LBA supported, no DMA */

    stw(data + 51, 0x200); /* PIO transfer cycle */

    stw(data + 52, 0x200); /* DMA transfer cycle */

    stw(data + 54, sis->cylinders);

    stw(data + 55, sis->heads);

    stw(data + 56, sis->sectors);

    oldersmall = sis->cylinders * sis->heads * sis->sectors;

    stw(data + 57, oldersmall);

    stw(data + 58, oldersmall >> 16);

    if (sis->mult_sectors)

        stw(data + 59, 0x100 | sis->mult_sectors);

    stw(data + 60, sis->nb_sectors);

    stw(data + 61, sis->nb_sectors >> 16);

    stw(data + 80, (1 << 1) | (1 << 2));

    stw(data + 82, (1 << 14));

    stw(data + 83, (1 << 14));

    stw(data + 84, (1 << 14));

    stw(data + 85, (1 << 14));

    stw(data + 86, 0);

    stw(data + 87, (1 << 14));

}
",0,0,0,-1,"s,p,oldsize","s:0.03354191780090332,p:0.03883185796439648,oldsize:0.014776600524783134,",3,53,"p:data,s:sis,oldsize:oldersmall,",Greedy,250,0.049124523003896074
315,"static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,

                       const AVFrame *pict, int *got_packet)

{

    PNGEncContext *s = avctx->priv_data;

    int ret;

    int enc_row_size;

    size_t max_packet_size;

    APNGFctlChunk fctl_chunk = {0};



    if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) {

        uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t));



        if (avctx->frame_number == 0) {

            s->palette_checksum = checksum;

        } else if (checksum != s->palette_checksum) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input contains more than one unique palette. APNG does not support multiple palettes.\n"");

            return -1;

        }

    }



    enc_row_size    = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3);

    max_packet_size =

        AV_INPUT_BUFFER_MIN_SIZE + // headers

        avctx->height * (

            enc_row_size +

            (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE) // fdAT * ceil(enc_row_size / IOBUF_SIZE)

        );

    if (max_packet_size > INT_MAX)

        return AVERROR(ENOMEM);



    if (avctx->frame_number == 0) {

        if (!pict)

            return AVERROR(EINVAL);



        s->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE);

        if (!avctx->extradata)

            return AVERROR(ENOMEM);



        ret = encode_headers(avctx, pict);

        if (ret < 0)

            return ret;



        avctx->extradata_size = s->bytestream - avctx->extradata;



        s->last_frame_packet = av_malloc(max_packet_size);

        if (!s->last_frame_packet)

            return AVERROR(ENOMEM);

    } else if (s->last_frame) {

        ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);

        if (ret < 0)

            return ret;



        memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size);

        pkt->size = s->last_frame_packet_size;

        pkt->pts = pkt->dts = s->last_frame->pts;

    }



    if (pict) {

        s->bytestream_start =

        s->bytestream       = s->last_frame_packet;

        s->bytestream_end   = s->bytestream + max_packet_size;



        // We're encoding the frame first, so we have to do a bit of shuffling around

        // to have the image data write to the correct place in the buffer

        fctl_chunk.sequence_number = s->sequence_number;

        ++s->sequence_number;

        s->bytestream += 26 + 12;



        ret = apng_encode_frame(avctx, pict, &fctl_chunk, &s->last_frame_fctl);

        if (ret < 0)

            return ret;



        fctl_chunk.delay_num = 0; // delay filled in during muxing

        fctl_chunk.delay_den = 0;

    } else {

        s->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE;

    }



    if (s->last_frame) {

        uint8_t* last_fctl_chunk_start = pkt->data;

        uint8_t buf[26];



        AV_WB32(buf + 0, s->last_frame_fctl.sequence_number);

        AV_WB32(buf + 4, s->last_frame_fctl.width);

        AV_WB32(buf + 8, s->last_frame_fctl.height);

        AV_WB32(buf + 12, s->last_frame_fctl.x_offset);

        AV_WB32(buf + 16, s->last_frame_fctl.y_offset);

        AV_WB16(buf + 20, s->last_frame_fctl.delay_num);

        AV_WB16(buf + 22, s->last_frame_fctl.delay_den);

        buf[24] = s->last_frame_fctl.dispose_op;

        buf[25] = s->last_frame_fctl.blend_op;

        png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26);



        *got_packet = 1;

    }



    if (pict) {

        if (!s->last_frame) {

            s->last_frame = av_frame_alloc();

            if (!s->last_frame)

                return AVERROR(ENOMEM);

        } else if (s->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {

            if (!s->prev_frame) {

                s->prev_frame = av_frame_alloc();

                if (!s->prev_frame)

                    return AVERROR(ENOMEM);



                s->prev_frame->format = pict->format;

                s->prev_frame->width = pict->width;

                s->prev_frame->height = pict->height;

                if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0)

                    return ret;

            }



            // Do disposal, but not blending

            memcpy(s->prev_frame->data[0], s->last_frame->data[0],

                   s->last_frame->linesize[0] * s->last_frame->height);

            if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {

                uint32_t y;

                uint8_t bpp = (s->bits_per_pixel + 7) >> 3;

                for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) {

                    size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset;

                    memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width);

                }

            }

        }



        av_frame_unref(s->last_frame);

        ret = av_frame_ref(s->last_frame, (AVFrame*)pict);

        if (ret < 0)

            return ret;



        s->last_frame_fctl = fctl_chunk;

        s->last_frame_packet_size = s->bytestream - s->bytestream_start;

    } else {

        av_frame_free(&s->last_frame);

    }



    return 0;

}
",964,"static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,

                       const AVFrame *Pict, int *got_packet)

{

    PNGEncContext *d = avctx->priv_data;

    int ret;

    int enc_row_size;

    size_t max_packet_size;

    APNGFctlChunk fctl_chunk = {0};



    if (Pict && avctx->codec_id == AV_CODEC_ID_APNG && d->color_type == PNG_COLOR_TYPE_PALETTE) {

        uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, Pict->data[1], 256 * sizeof(uint32_t));



        if (avctx->frame_number == 0) {

            d->palette_checksum = checksum;

        } else if (checksum != d->palette_checksum) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input contains more than one unique palette. APNG does not support multiple palettes.
"");

            return -1;

        }

    }



    enc_row_size    = deflateBound(&d->zstream, (avctx->width * d->bits_per_pixel + 7) >> 3);

    max_packet_size =

        AV_INPUT_BUFFER_MIN_SIZE + // headers

        avctx->height * (

            enc_row_size +

            (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE) // fdAT * ceil(enc_row_size / IOBUF_SIZE)

        );

    if (max_packet_size > INT_MAX)

        return AVERROR(ENOMEM);



    if (avctx->frame_number == 0) {

        if (!Pict)

            return AVERROR(EINVAL);



        d->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE);

        if (!avctx->extradata)

            return AVERROR(ENOMEM);



        ret = encode_headers(avctx, Pict);

        if (ret < 0)

            return ret;



        avctx->extradata_size = d->bytestream - avctx->extradata;



        d->last_frame_packet = av_malloc(max_packet_size);

        if (!d->last_frame_packet)

            return AVERROR(ENOMEM);

    } else if (d->last_frame) {

        ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);

        if (ret < 0)

            return ret;



        memcpy(pkt->data, d->last_frame_packet, d->last_frame_packet_size);

        pkt->size = d->last_frame_packet_size;

        pkt->pts = pkt->dts = d->last_frame->pts;

    }



    if (Pict) {

        d->bytestream_start =

        d->bytestream       = d->last_frame_packet;

        d->bytestream_end   = d->bytestream + max_packet_size;



        // We're encoding the frame first, so we have to do a bit of shuffling around

        // to have the image data write to the correct place in the buffer

        fctl_chunk.sequence_number = d->sequence_number;

        ++d->sequence_number;

        d->bytestream += 26 + 12;



        ret = apng_encode_frame(avctx, Pict, &fctl_chunk, &d->last_frame_fctl);

        if (ret < 0)

            return ret;



        fctl_chunk.delay_num = 0; // delay filled in during muxing

        fctl_chunk.delay_den = 0;

    } else {

        d->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE;

    }



    if (d->last_frame) {

        uint8_t* last_fctl_chunk_start = pkt->data;

        uint8_t buf[26];



        AV_WB32(buf + 0, d->last_frame_fctl.sequence_number);

        AV_WB32(buf + 4, d->last_frame_fctl.width);

        AV_WB32(buf + 8, d->last_frame_fctl.height);

        AV_WB32(buf + 12, d->last_frame_fctl.x_offset);

        AV_WB32(buf + 16, d->last_frame_fctl.y_offset);

        AV_WB16(buf + 20, d->last_frame_fctl.delay_num);

        AV_WB16(buf + 22, d->last_frame_fctl.delay_den);

        buf[24] = d->last_frame_fctl.dispose_op;

        buf[25] = d->last_frame_fctl.blend_op;

        png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26);



        *got_packet = 1;

    }



    if (Pict) {

        if (!d->last_frame) {

            d->last_frame = av_frame_alloc();

            if (!d->last_frame)

                return AVERROR(ENOMEM);

        } else if (d->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {

            if (!d->prev_frame) {

                d->prev_frame = av_frame_alloc();

                if (!d->prev_frame)

                    return AVERROR(ENOMEM);



                d->prev_frame->format = Pict->format;

                d->prev_frame->width = Pict->width;

                d->prev_frame->height = Pict->height;

                if ((ret = av_frame_get_buffer(d->prev_frame, 32)) < 0)

                    return ret;

            }



            // Do disposal, but not blending

            memcpy(d->prev_frame->data[0], d->last_frame->data[0],

                   d->last_frame->linesize[0] * d->last_frame->height);

            if (d->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {

                uint32_t y;

                uint8_t bpp = (d->bits_per_pixel + 7) >> 3;

                for (y = d->last_frame_fctl.y_offset; y < d->last_frame_fctl.y_offset + d->last_frame_fctl.height; ++y) {

                    size_t row_start = d->last_frame->linesize[0] * y + bpp * d->last_frame_fctl.x_offset;

                    memset(d->prev_frame->data[0] + row_start, 0, bpp * d->last_frame_fctl.width);

                }

            }

        }



        av_frame_unref(d->last_frame);

        ret = av_frame_ref(d->last_frame, (AVFrame*)Pict);

        if (ret < 0)

            return ret;



        d->last_frame_fctl = fctl_chunk;

        d->last_frame_packet_size = d->bytestream - d->bytestream_start;

    } else {

        av_frame_free(&d->last_frame);

    }



    return 0;

}
",0,0,1,1,"avctx,pkt,pict,got_packet,s,ret,enc_row_size,max_packet_size","avctx:0.07581827044487,pkt:0.07902628183364868,pict:0.22222337126731873,got_packet:0.06558218598365784,s:0.2694249153137207,ret:0.16251134872436523,enc_row_size:0.0914524495601654,max_packet_size:0.12619367241859436,",2,78,"s:d,pict:Pict,",Greedy,253,0.0640005906422933
316,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return ret;

}
",117,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *base;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    base = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (base) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return base;

}
",0,0,1,1,"bs,sector_num,qiov,nb_sectors,cb,opaque,drv,ret,rd_ops","bs:0.022825784981250763,sector_num:0.061309464275836945,qiov:0.004745051264762878,nb_sectors:0.13148420304059982,cb:0.18549375236034393,opaque:-0.015312910079956055,drv:0.015513114631175995,ret:0.28549283742904663,rd_ops:0.004138544201850891,",1,4,"ret:base,",Greedy,95,0.018257832527160643
317,"static void migrate_set_downtime(QTestState *who, const char *value)

{

    QDict *rsp;

    gchar *cmd;



    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""

                          ""'arguments': { 'value': %s } }"", value);

    rsp = qtest_qmp(who, cmd);

    g_free(cmd);

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);

}
",65,,0,1,,-4,"who,value,rsp,cmd",,,,,Greedy,1,0.002290797233581543
318,"target_ulong do_arm_semihosting(CPUARMState *env)

{

    ARMCPU *cpu = arm_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    target_ulong args;

    target_ulong arg0, arg1, arg2, arg3;

    char * s;

    int nr;

    uint32_t ret;

    uint32_t len;

#ifdef CONFIG_USER_ONLY

    TaskState *ts = cs->opaque;

#else

    CPUARMState *ts = env;

#endif



    if (is_a64(env)) {

        /* Note that the syscall number is in W0, not X0 */

        nr = env->xregs[0] & 0xffffffffU;

        args = env->xregs[1];

    } else {

        nr = env->regs[0];

        args = env->regs[1];

    }



    switch (nr) {

    case TARGET_SYS_OPEN:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        s = lock_user_string(arg0);

        if (!s) {

            /* FIXME - should this error code be -TARGET_EFAULT ? */

            return (uint32_t)-1;

        }

        if (arg1 >= 12) {

            unlock_user(s, arg0, 0);

            return (uint32_t)-1;

        }

        if (strcmp(s, "":tt"") == 0) {

            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;

            unlock_user(s, arg0, 0);

            return result_fileno;

        }

        if (use_gdb_syscalls()) {

            ret = arm_gdb_syscall(cpu, arm_semi_cb, ""open,%s,%x,1a4"", arg0,

                                  (int)arg2+1, gdb_open_modeflags[arg1]);

        } else {

            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));

        }

        unlock_user(s, arg0, 0);

        return ret;

    case TARGET_SYS_CLOSE:

        GET_ARG(0);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""close,%x"", arg0);

        } else {

            return set_swi_errno(ts, close(arg0));

        }

    case TARGET_SYS_WRITEC:

        {

          char c;



          if (get_user_u8(c, args))

              /* FIXME - should this error code be -TARGET_EFAULT ? */

              return (uint32_t)-1;

          /* Write to debug console.  stderr is near enough.  */

          if (use_gdb_syscalls()) {

                return arm_gdb_syscall(cpu, arm_semi_cb, ""write,2,%x,1"", args);

          } else {

                return write(STDERR_FILENO, &c, 1);

          }

        }

    case TARGET_SYS_WRITE0:

        if (!(s = lock_user_string(args)))

            /* FIXME - should this error code be -TARGET_EFAULT ? */

            return (uint32_t)-1;

        len = strlen(s);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""write,2,%x,%x"",

                                   args, len);

        } else {

            ret = write(STDERR_FILENO, s, len);

        }

        unlock_user(s, args, 0);

        return ret;

    case TARGET_SYS_WRITE:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        len = arg2;

        if (use_gdb_syscalls()) {

            arm_semi_syscall_len = len;

            return arm_gdb_syscall(cpu, arm_semi_cb, ""write,%x,%x,%x"",

                                   arg0, arg1, len);

        } else {

            s = lock_user(VERIFY_READ, arg1, len, 1);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            ret = set_swi_errno(ts, write(arg0, s, len));

            unlock_user(s, arg1, 0);

            if (ret == (uint32_t)-1)

                return -1;

            return len - ret;

        }

    case TARGET_SYS_READ:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        len = arg2;

        if (use_gdb_syscalls()) {

            arm_semi_syscall_len = len;

            return arm_gdb_syscall(cpu, arm_semi_cb, ""read,%x,%x,%x"",

                                   arg0, arg1, len);

        } else {

            s = lock_user(VERIFY_WRITE, arg1, len, 0);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            do {

                ret = set_swi_errno(ts, read(arg0, s, len));

            } while (ret == -1 && errno == EINTR);

            unlock_user(s, arg1, len);

            if (ret == (uint32_t)-1)

                return -1;

            return len - ret;

        }

    case TARGET_SYS_READC:

       /* XXX: Read from debug console. Not implemented.  */

        return 0;

    case TARGET_SYS_ISTTY:

        GET_ARG(0);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""isatty,%x"", arg0);

        } else {

            return isatty(arg0);

        }

    case TARGET_SYS_SEEK:

        GET_ARG(0);

        GET_ARG(1);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""lseek,%x,%x,0"",

                                   arg0, arg1);

        } else {

            ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET));

            if (ret == (uint32_t)-1)

              return -1;

            return 0;

        }

    case TARGET_SYS_FLEN:

        GET_ARG(0);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_flen_cb, ""fstat,%x,%x"",

                                   arg0, arm_flen_buf(cpu));

        } else {

            struct stat buf;

            ret = set_swi_errno(ts, fstat(arg0, &buf));

            if (ret == (uint32_t)-1)

                return -1;

            return buf.st_size;

        }

    case TARGET_SYS_TMPNAM:

        /* XXX: Not implemented.  */

        return -1;

    case TARGET_SYS_REMOVE:

        GET_ARG(0);

        GET_ARG(1);

        if (use_gdb_syscalls()) {

            ret = arm_gdb_syscall(cpu, arm_semi_cb, ""unlink,%s"",

                                  arg0, (int)arg1+1);

        } else {

            s = lock_user_string(arg0);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            ret =  set_swi_errno(ts, remove(s));

            unlock_user(s, arg0, 0);

        }

        return ret;

    case TARGET_SYS_RENAME:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        GET_ARG(3);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""rename,%s,%s"",

                                   arg0, (int)arg1+1, arg2, (int)arg3+1);

        } else {

            char *s2;

            s = lock_user_string(arg0);

            s2 = lock_user_string(arg2);

            if (!s || !s2)

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                ret = (uint32_t)-1;

            else

                ret = set_swi_errno(ts, rename(s, s2));

            if (s2)

                unlock_user(s2, arg2, 0);

            if (s)

                unlock_user(s, arg0, 0);

            return ret;

        }

    case TARGET_SYS_CLOCK:

        return clock() / (CLOCKS_PER_SEC / 100);

    case TARGET_SYS_TIME:

        return set_swi_errno(ts, time(NULL));

    case TARGET_SYS_SYSTEM:

        GET_ARG(0);

        GET_ARG(1);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""system,%s"",

                                   arg0, (int)arg1+1);

        } else {

            s = lock_user_string(arg0);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            ret = set_swi_errno(ts, system(s));

            unlock_user(s, arg0, 0);

            return ret;

        }

    case TARGET_SYS_ERRNO:

#ifdef CONFIG_USER_ONLY

        return ts->swi_errno;

#else

        return syscall_err;

#endif

    case TARGET_SYS_GET_CMDLINE:

        {

            /* Build a command-line from the original argv.

             *

             * The inputs are:

             *     * arg0, pointer to a buffer of at least the size

             *               specified in arg1.

             *     * arg1, size of the buffer pointed to by arg0 in

             *               bytes.

             *

             * The outputs are:

             *     * arg0, pointer to null-terminated string of the

             *               command line.

             *     * arg1, length of the string pointed to by arg0.

             */



            char *output_buffer;

            size_t input_size;

            size_t output_size;

            int status = 0;

#if !defined(CONFIG_USER_ONLY)

            const char *cmdline;

#endif

            GET_ARG(0);

            GET_ARG(1);

            input_size = arg1;

            /* Compute the size of the output string.  */

#if !defined(CONFIG_USER_ONLY)

            cmdline = semihosting_get_cmdline();

            if (cmdline == NULL) {

                cmdline = """"; /* Default to an empty line. */

            }

            output_size = strlen(cmdline) + 1; /* Count terminating 0. */

#else

            unsigned int i;



            output_size = ts->info->arg_end - ts->info->arg_start;

            if (!output_size) {

                /* We special-case the ""empty command line"" case (argc==0).

                   Just provide the terminating 0. */

                output_size = 1;

            }

#endif



            if (output_size > input_size) {

                 /* Not enough space to store command-line arguments.  */

                return -1;

            }



            /* Adjust the command-line length.  */

            if (SET_ARG(1, output_size - 1)) {

                /* Couldn't write back to argument block */

                return -1;

            }



            /* Lock the buffer on the ARM side.  */

            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);

            if (!output_buffer) {

                return -1;

            }



            /* Copy the command-line arguments.  */

#if !defined(CONFIG_USER_ONLY)

            pstrcpy(output_buffer, output_size, cmdline);

#else

            if (output_size == 1) {

                /* Empty command-line.  */

                output_buffer[0] = '\0';

                goto out;

            }



            if (copy_from_user(output_buffer, ts->info->arg_start,

                               output_size)) {

                status = -1;

                goto out;

            }



            /* Separate arguments by white spaces.  */

            for (i = 0; i < output_size - 1; i++) {

                if (output_buffer[i] == 0) {

                    output_buffer[i] = ' ';

                }

            }

        out:

#endif

            /* Unlock the buffer on the ARM side.  */

            unlock_user(output_buffer, arg0, output_size);



            return status;

        }

    case TARGET_SYS_HEAPINFO:

        {

            target_ulong retvals[4];

            uint32_t limit;

            int i;



            GET_ARG(0);



#ifdef CONFIG_USER_ONLY

            /* Some C libraries assume the heap immediately follows .bss, so

               allocate it using sbrk.  */

            if (!ts->heap_limit) {

                abi_ulong ret;



                ts->heap_base = do_brk(0);

                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;

                /* Try a big heap, and reduce the size if that fails.  */

                for (;;) {

                    ret = do_brk(limit);

                    if (ret >= limit) {

                        break;

                    }

                    limit = (ts->heap_base >> 1) + (limit >> 1);

                }

                ts->heap_limit = limit;

            }



            retvals[0] = ts->heap_base;

            retvals[1] = ts->heap_limit;

            retvals[2] = ts->stack_base;

            retvals[3] = 0; /* Stack limit.  */

#else

            limit = ram_size;

            /* TODO: Make this use the limit of the loaded application.  */

            retvals[0] = limit / 2;

            retvals[1] = limit;

            retvals[2] = limit; /* Stack base */

            retvals[3] = 0; /* Stack limit.  */

#endif



            for (i = 0; i < ARRAY_SIZE(retvals); i++) {

                bool fail;



                if (is_a64(env)) {

                    fail = put_user_u64(retvals[i], arg0 + i * 8);

                } else {

                    fail = put_user_u32(retvals[i], arg0 + i * 4);

                }



                if (fail) {

                    /* Couldn't write back to argument block */

                    return -1;

                }

            }

            return 0;

        }

    case TARGET_SYS_EXIT:

        if (is_a64(env)) {

            /* The A64 version of this call takes a parameter block,

             * so the application-exit type can return a subcode which

             * is the exit status code from the application.

             */

            GET_ARG(0);

            GET_ARG(1);



            if (arg0 == ADP_Stopped_ApplicationExit) {

                ret = arg1;

            } else {

                ret = 1;

            }

        } else {

            /* ARM specifies only Stopped_ApplicationExit as normal

             * exit, everything else is considered an error */

            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;

        }

        gdb_exit(env, ret);

        exit(ret);

    case TARGET_SYS_SYNCCACHE:

        /* Clean the D-cache and invalidate the I-cache for the specified

         * virtual address range. This is a nop for us since we don't

         * implement caches. This is only present on A64.

         */

        if (is_a64(env)) {

            return 0;

        }

        /* fall through -- invalid for A32/T32 */

    default:

        fprintf(stderr, ""qemu: Unsupported SemiHosting SWI 0x%02x\n"", nr);

        cpu_dump_state(cs, stderr, fprintf, 0);

        abort();

    }

}
",1913,,0,1,,-4,"env,cpu,cs,args,arg0,arg1,arg2,arg3,s,nr,ret,len,ts",,,,,Greedy,1,0.0031086007754007974
319,"static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,

                                         void *logctx, int size)

{

    uint8_t *user_data;

    int e, build, i;



    if (size < 16 || size >= INT_MAX - 16)

        return AVERROR_INVALIDDATA;



    user_data = av_malloc(16 + size + 1);

    if (!user_data)

        return AVERROR(ENOMEM);



    for (i = 0; i < size + 16; i++)

        user_data[i] = get_bits(gb, 8);



    user_data[i] = 0;

    e = sscanf(user_data + 16, ""x264 - core %d"", &build);

    if (e == 1 && build > 0)

        h->x264_build = build;

    if (e == 1 && build == 1 && !strncmp(user_data+16, ""x264 - core 0000"", 16))

        h->x264_build = 67;



    if (strlen(user_data + 16) > 0)

        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""\n"", user_data + 16);



    av_free(user_data);

    return 0;

}
",198,"static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,

                                         void *logctx, int size)

{

    uint8_t *custom_config;

    int e, build, i;



    if (size < 16 || size >= INT_MAX - 16)

        return AVERROR_INVALIDDATA;



    custom_config = av_malloc(16 + size + 1);

    if (!custom_config)

        return AVERROR(ENOMEM);



    for (i = 0; i < size + 16; i++)

        custom_config[i] = get_bits(gb, 8);



    custom_config[i] = 0;

    e = sscanf(custom_config + 16, ""x264 - core %d"", &build);

    if (e == 1 && build > 0)

        h->x264_build = build;

    if (e == 1 && build == 1 && !strncmp(custom_config+16, ""x264 - core 0000"", 16))

        h->x264_build = 67;



    if (strlen(custom_config + 16) > 0)

        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""
"", custom_config + 16);



    av_free(custom_config);

    return 0;

}
",0,0,1,1,"h,gb,logctx,size,user_data,e,build,i","h:0.01621045544743538,gb:-0.019315682351589203,logctx:0.05620860308408737,size:-0.03341294080018997,user_data:0.4440164119005203,e:-0.002520926296710968,build:-0.020663850009441376,i:-0.075145423412323,",1,10,"user_data:custom_config,",Greedy,82,0.016730360190073647
320,"void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{

    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);

    AVFilterPad *dst = link->dstpad;

    int i;



    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);



    if (!(filter_samples = dst->filter_samples))

        filter_samples = avfilter_default_filter_samples;



    /* prepare to copy the samples if the buffer has insufficient permissions */

    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||

        dst->rej_perms & samplesref->perms) {



        av_log(link->dst, AV_LOG_DEBUG,

               ""Copying audio data in avfilter (have perms %x, need %x, reject %x)\n"",

               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);



        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,

                                                          samplesref->audio->nb_samples);

        link->cur_buf->pts                = samplesref->pts;

        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;



        /* Copy actual data into new samples buffer */

        for (i = 0; samplesref->data[i]; i++)

            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);



        avfilter_unref_buffer(samplesref);

    } else

        link->cur_buf = samplesref;



    filter_samples(link, link->cur_buf);

}
",228,,0,1,,-4,"link,samplesref,filter_samples,dst,i",,,,,Greedy,1,0.00224529504776001
321,"static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,

                                   qemu_irq **irqs)

{

    qemu_irq *mpic;

    DeviceState *dev;

    SysBusDevice *s;

    int i, j, k;



    mpic = g_new(qemu_irq, 256);

    dev = qdev_create(NULL, ""openpic"");

    qdev_prop_set_uint32(dev, ""nb_cpus"", smp_cpus);

    qdev_prop_set_uint32(dev, ""model"", params->mpic_version);

    qdev_init_nofail(dev);

    s = SYS_BUS_DEVICE(dev);



    k = 0;

    for (i = 0; i < smp_cpus; i++) {

        for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {

            sysbus_connect_irq(s, k++, irqs[i][j]);

        }

    }



    for (i = 0; i < 256; i++) {

        mpic[i] = qdev_get_gpio_in(dev, i);

    }



    memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET,

                                s->mmio[0].memory);



    return mpic;

}
",188,,0,1,,-4,"params,ccsr,irqs,mpic,dev,s,i,j,k",,,,,Greedy,1,0.002158486843109131
322,"CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))

{

    const char *p;

    CharDriverState *chr;

    QemuOpts *opts;

    Error *err = NULL;



    if (strstart(filename, ""chardev:"", &p)) {

        return qemu_chr_find(p);

    }



    opts = qemu_chr_parse_compat(label, filename);

    if (!opts)

        return NULL;



    chr = qemu_chr_new_from_opts(opts, init, &err);

    if (err) {

        error_report_err(err);

    }

    if (chr && qemu_opt_get_bool(opts, ""mux"", 0)) {

        qemu_chr_fe_claim_no_fail(chr);

        monitor_init(chr, MONITOR_USE_READLINE);

    }

    return chr;

}
",139,,0,1,,-4,"label,filename,init,p,chr,opts,err",,,,,Greedy,1,0.00197834571202596
323,"static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,

                            const char *model, const char *name,

                            const char *ifname, const char *script,

                            const char *downscript, const char *vhostfdname,

                            int vnet_hdr, int fd)

{

    TAPState *s;



    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);

    if (!s) {

        close(fd);

        return -1;

    }



    if (tap_set_sndbuf(s->fd, tap) < 0) {

        return -1;

    }



    if (tap->has_fd || tap->has_fds) {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str), ""fd=%d"", fd);

    } else if (tap->has_helper) {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str), ""helper=%s"",

                 tap->helper);

    } else {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str),

                 ""ifname=%s,script=%s,downscript=%s"", ifname, script,

                 downscript);



        if (strcmp(downscript, ""no"") != 0) {

            snprintf(s->down_script, sizeof(s->down_script), ""%s"", downscript);

            snprintf(s->down_script_arg, sizeof(s->down_script_arg),

                     ""%s"", ifname);

        }

    }



    if (tap->has_vhost ? tap->vhost :

        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {

        int vhostfd;



        if (tap->has_vhostfd) {

            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);

            if (vhostfd == -1) {

                return -1;

            }

        } else {

            vhostfd = -1;

        }



        s->vhost_net = vhost_net_init(&s->nc, vhostfd,

                                      tap->has_vhostforce && tap->vhostforce);

        if (!s->vhost_net) {

            error_report(""vhost-net requested but could not be initialized"");

            return -1;

        }

    } else if (tap->has_vhostfd || tap->has_vhostfds) {

        error_report(""vhostfd= is not valid without vhost"");

        return -1;

    }



    return 0;

}
",381,"static int net_init_tap_one(const NetdevTapOptions *trace, NetClientState *peer,

                            const char *model, const char *name,

                            const char *ifname, const char *script,

                            const char *downscript, const char *vhostfdname,

                            int vnet_hdr, int fd)

{

    TAPState *os;



    os = net_tap_fd_init(peer, model, name, fd, vnet_hdr);

    if (!os) {

        close(fd);

        return -1;

    }



    if (tap_set_sndbuf(os->fd, trace) < 0) {

        return -1;

    }



    if (trace->has_fd || trace->has_fds) {

        snprintf(os->nc.info_str, sizeof(os->nc.info_str), ""fd=%d"", fd);

    } else if (trace->has_helper) {

        snprintf(os->nc.info_str, sizeof(os->nc.info_str), ""helper=%s"",

                 trace->helper);

    } else {

        snprintf(os->nc.info_str, sizeof(os->nc.info_str),

                 ""ifname=%s,script=%s,downscript=%s"", ifname, script,

                 downscript);



        if (strcmp(downscript, ""no"") != 0) {

            snprintf(os->down_script, sizeof(os->down_script), ""%s"", downscript);

            snprintf(os->down_script_arg, sizeof(os->down_script_arg),

                     ""%s"", ifname);

        }

    }



    if (trace->has_vhost ? trace->vhost :

        vhostfdname || (trace->has_vhostforce && trace->vhostforce)) {

        int vhopfd;



        if (trace->has_vhostfd) {

            vhopfd = monitor_handle_fd_param(cur_mon, vhostfdname);

            if (vhopfd == -1) {

                return -1;

            }

        } else {

            vhopfd = -1;

        }



        os->vhost_net = vhost_net_init(&os->nc, vhopfd,

                                      trace->has_vhostforce && trace->vhostforce);

        if (!os->vhost_net) {

            error_report(""vhost-net requested but could not be initialized"");

            return -1;

        }

    } else if (trace->has_vhostfd || trace->has_vhostfds) {

        error_report(""vhostfd= is not valid without vhost"");

        return -1;

    }



    return 0;

}
",0,0,1,1,"tap,peer,model,name,ifname,script,downscript,vhostfdname,vnet_hdr,fd,s,vhostfd","tap:0.11436140537261963,peer:-0.046196289360523224,model:0.04021379351615906,name:0.047556594014167786,ifname:0.029768958687782288,script:0.016471341252326965,downscript:0.036388784646987915,vhostfdname:0.0808427631855011,vnet_hdr:0.023732811212539673,fd:0.07083924114704132,s:0.1472170054912567,vhostfd:0.13339351117610931,",3,37,"s:os,vhostfd:vhopfd,tap:trace,",Greedy,327,0.060958492755889895
324,"int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
",162,"int qdev_prop_check_globals(void)

{

    GList *la;

    int ret = 0;



    for (la = global_props; la; la = la->next) {

        GlobalProperty *pb = la->data;

        ObjectClass *og;

        DeviceClass *driver;

        if (pb->used) {

            continue;

        }

        if (!pb->user_provided) {

            continue;

        }

        og = object_class_by_name(pb->driver);

        og = object_class_dynamic_cast(og, TYPE_DEVICE);

        if (!og) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       pb->driver, pb->property);

            ret = 1;

            continue;

        }

        driver = DEVICE_CLASS(og);

        if (!driver->hotpluggable && !pb->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       pb->driver, pb->property, pb->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
",0,0,0,-1,"l,prop,oc,dc","l:0.022669166326522827,prop:0.028513863682746887,oc:0.0393342487514019,dc:0.015356317162513733,",4,25,"oc:og,prop:pb,l:la,dc:driver,",Greedy,245,0.04364219903945923
325,"static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as)

{

    ESDVoiceOut *esd = (ESDVoiceOut *) hw;

    audsettings_t obt_as = *as;

    int esdfmt = ESD_STREAM | ESD_PLAY;

    int err;

    sigset_t set, old_set;



    sigfillset (&set);



    esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO;

    switch (as->fmt) {

    case AUD_FMT_S8:

    case AUD_FMT_U8:

        esdfmt |= ESD_BITS8;

        obt_as.fmt = AUD_FMT_U8;

        break;



    case AUD_FMT_S32:

    case AUD_FMT_U32:

        dolog (""Will use 16 instead of 32 bit samples\n"");



    case AUD_FMT_S16:

    case AUD_FMT_U16:

    deffmt:

        esdfmt |= ESD_BITS16;

        obt_as.fmt = AUD_FMT_S16;

        break;



    default:

        dolog (""Internal logic error: Bad audio format %d\n"", as->fmt);

        goto deffmt;



    }

    obt_as.endianness = AUDIO_HOST_ENDIANNESS;



    audio_pcm_init_info (&hw->info, &obt_as);



    hw->samples = conf.samples;

    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);

    if (!esd->pcm_buf) {

        dolog (""Could not allocate buffer (%d bytes)\n"",

               hw->samples << hw->info.shift);

        return -1;

    }



    esd->fd = -1;

    err = pthread_sigmask (SIG_BLOCK, &set, &old_set);

    if (err) {

        qesd_logerr (err, ""pthread_sigmask failed\n"");

        goto fail1;

    }



    esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL);

    if (esd->fd < 0) {

        qesd_logerr (errno, ""esd_play_stream failed\n"");

        goto fail2;

    }



    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {

        goto fail3;

    }



    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);

    if (err) {

        qesd_logerr (err, ""pthread_sigmask(restore) failed\n"");

    }



    return 0;



 fail3:

    if (close (esd->fd)) {

        qesd_logerr (errno, ""%s: close on esd socket(%d) failed\n"",

                     AUDIO_FUNC, esd->fd);

    }

    esd->fd = -1;



 fail2:

    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);

    if (err) {

        qesd_logerr (err, ""pthread_sigmask(restore) failed\n"");

    }



 fail1:

    qemu_free (esd->pcm_buf);

    esd->pcm_buf = NULL;

    return -1;

}
",419,"static int qesd_init_out (HWVoiceOut *nas, audsettings_t *nas)

{

    ESDVoiceOut *lesdb = (ESDVoiceOut *) nas;

    audsettings_t obt_as = *nas;

    int esdfmt = ESD_STREAM | ESD_PLAY;

    int id;

    sigset_t sort, old_settings;



    sigfillset (&sort);



    esdfmt |= (nas->nchannels == 2) ? ESD_STEREO : ESD_MONO;

    switch (nas->fmt) {

    case AUD_FMT_S8:

    case AUD_FMT_U8:

        esdfmt |= ESD_BITS8;

        obt_as.fmt = AUD_FMT_U8;

        break;



    case AUD_FMT_S32:

    case AUD_FMT_U32:

        dolog (""Will use 16 instead of 32 bit samples
"");



    case AUD_FMT_S16:

    case AUD_FMT_U16:

    deffmt:

        esdfmt |= ESD_BITS16;

        obt_as.fmt = AUD_FMT_S16;

        break;



    default:

        dolog (""Internal logic error: Bad audio format %d
"", nas->fmt);

        goto deffmt;



    }

    obt_as.endianness = AUDIO_HOST_ENDIANNESS;



    audio_pcm_init_info (&nas->info, &obt_as);



    nas->samples = conf.samples;

    lesdb->pcm_buf = audio_calloc (AUDIO_FUNC, nas->samples, 1 << nas->info.shift);

    if (!lesdb->pcm_buf) {

        dolog (""Could not allocate buffer (%d bytes)
"",

               nas->samples << nas->info.shift);

        return -1;

    }



    lesdb->fd = -1;

    id = pthread_sigmask (SIG_BLOCK, &sort, &old_settings);

    if (id) {

        qesd_logerr (id, ""pthread_sigmask failed
"");

        goto fail1;

    }



    lesdb->fd = esd_play_stream (esdfmt, nas->freq, conf.dac_host, NULL);

    if (lesdb->fd < 0) {

        qesd_logerr (errno, ""esd_play_stream failed
"");

        goto fail2;

    }



    if (audio_pt_init (&lesdb->pt, qesd_thread_out, lesdb, AUDIO_CAP, AUDIO_FUNC)) {

        goto fail3;

    }



    id = pthread_sigmask (SIG_SETMASK, &old_settings, NULL);

    if (id) {

        qesd_logerr (id, ""pthread_sigmask(restore) failed
"");

    }



    return 0;



 fail3:

    if (close (lesdb->fd)) {

        qesd_logerr (errno, ""%s: close on esd socket(%d) failed
"",

                     AUDIO_FUNC, lesdb->fd);

    }

    lesdb->fd = -1;



 fail2:

    id = pthread_sigmask (SIG_SETMASK, &old_settings, NULL);

    if (id) {

        qesd_logerr (id, ""pthread_sigmask(restore) failed
"");

    }



 fail1:

    qemu_free (lesdb->pcm_buf);

    lesdb->pcm_buf = NULL;

    return -1;

}
",0,0,0,-1,"hw,as,esd,err,set,old_set","hw:-0.004187144339084625,as:-0.01336669921875,esd:0.009462013840675354,err:0.010725177824497223,set:0.03157259523868561,old_set:0.10946010053157806,",6,44,"old_set:old_settings,set:sort,err:id,esd:lesdb,hw:nas,as:nas,",Greedy,374,0.07767271200815837
326,"static void monitor_find_completion(const char *cmdline)

{

    const char *cmdname;

    char *args[MAX_ARGS];

    int nb_args, i, len;

    const char *ptype, *str;

    const mon_cmd_t *cmd;

    const KeyDef *key;



    parse_cmdline(cmdline, &nb_args, args);

#ifdef DEBUG_COMPLETION

    for(i = 0; i < nb_args; i++) {

        monitor_printf(cur_mon, ""arg%d = '%s'\n"", i, (char *)args[i]);

    }

#endif



    /* if the line ends with a space, it means we want to complete the

       next arg */

    len = strlen(cmdline);

    if (len > 0 && qemu_isspace(cmdline[len - 1])) {

        if (nb_args >= MAX_ARGS)

            return;

        args[nb_args++] = qemu_strdup("""");

    }

    if (nb_args <= 1) {

        /* command completion */

        if (nb_args == 0)

            cmdname = """";

        else

            cmdname = args[0];

        readline_set_completion_index(cur_mon->rs, strlen(cmdname));

        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {

            cmd_completion(cmdname, cmd->name);

        }

    } else {

        /* find the command */

        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {

            if (compare_cmd(args[0], cmd->name))

                goto found;

        }

        return;

    found:

        ptype = next_arg_type(cmd->args_type);

        for(i = 0; i < nb_args - 2; i++) {

            if (*ptype != '\0') {

                ptype = next_arg_type(ptype);

                while (*ptype == '?')

                    ptype = next_arg_type(ptype);

            }

        }

        str = args[nb_args - 1];

        if (*ptype == '-' && ptype[1] != '\0') {

            ptype += 2;

        }

        switch(*ptype) {

        case 'F':

            /* file completion */

            readline_set_completion_index(cur_mon->rs, strlen(str));

            file_completion(str);

            break;

        case 'B':

            /* block device name completion */

            readline_set_completion_index(cur_mon->rs, strlen(str));

            bdrv_iterate(block_completion_it, (void *)str);

            break;

        case 's':

            /* XXX: more generic ? */

            if (!strcmp(cmd->name, ""info"")) {

                readline_set_completion_index(cur_mon->rs, strlen(str));

                for(cmd = info_cmds; cmd->name != NULL; cmd++) {

                    cmd_completion(str, cmd->name);

                }

            } else if (!strcmp(cmd->name, ""sendkey"")) {

                char *sep = strrchr(str, '-');

                if (sep)

                    str = sep + 1;

                readline_set_completion_index(cur_mon->rs, strlen(str));

                for(key = key_defs; key->name != NULL; key++) {

                    cmd_completion(str, key->name);

                }

            } else if (!strcmp(cmd->name, ""help|?"")) {

                readline_set_completion_index(cur_mon->rs, strlen(str));

                for (cmd = mon_cmds; cmd->name != NULL; cmd++) {

                    cmd_completion(str, cmd->name);

                }

            }

            break;

        default:

            break;

        }

    }

    for(i = 0; i < nb_args; i++)

        qemu_free(args[i]);

}
",610,,1,0,,-4,"cmdline,cmdname,args,MAX_ARGS,nb_args,i,len,ptype,str,cmd,key",,,,,Greedy,1,0.002335079511006673
327,"static void sd_response_r1_make(SDState *sd,

                                uint8_t *response, uint32_t last_status)

{

    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;

    uint32_t status;



    status = (sd->card_status & ~mask) | (last_status & mask);

    sd->card_status &= ~CARD_STATUS_C | APP_CMD;



    response[0] = (status >> 24) & 0xff;

    response[1] = (status >> 16) & 0xff;

    response[2] = (status >> 8) & 0xff;

    response[3] = (status >> 0) & 0xff;

}
",105,,0,1,,-4,"sd,response,last_status,status",,,,,Greedy,1,0.0021557291348775227
328,"static int mpc8_decode_frame(AVCodecContext * avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    MPCContext *c = avctx->priv_data;

    GetBitContext gb2, *gb = &gb2;

    int i, j, k, ch, cnt, res, t;

    Band *bands = c->bands;

    int off;

    int maxband, keyframe;

    int last[2];



    keyframe = c->cur_frame == 0;



    if(keyframe){

        memset(c->Q, 0, sizeof(c->Q));

        c->last_bits_used = 0;

    }

    init_get_bits(gb, buf, buf_size * 8);

    skip_bits(gb, c->last_bits_used & 7);



    if(keyframe)

        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);

    else{

        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);

        if(maxband > 32) maxband -= 33;

    }

    c->last_max_band = maxband;



    /* read subband indexes */

    if(maxband){

        last[0] = last[1] = 0;

        for(i = maxband - 1; i >= 0; i--){

            for(ch = 0; ch < 2; ch++){

                last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];

                if(last[ch] > 15) last[ch] -= 17;

                bands[i].res[ch] = last[ch];

            }

        }

        if(c->MSS){

            int mask;



            cnt = 0;

            for(i = 0; i < maxband; i++)

                if(bands[i].res[0] || bands[i].res[1])

                    cnt++;

            t = mpc8_get_mod_golomb(gb, cnt);

            mask = mpc8_get_mask(gb, cnt, t);

            for(i = maxband - 1; i >= 0; i--)

                if(bands[i].res[0] || bands[i].res[1]){

                    bands[i].msf = mask & 1;

                    mask >>= 1;

                }

        }

    }

    for(i = maxband; i < c->maxbands; i++)

        bands[i].res[0] = bands[i].res[1] = 0;



    if(keyframe){

        for(i = 0; i < 32; i++)

            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;

    }



    for(i = 0; i < maxband; i++){

        if(bands[i].res[0] || bands[i].res[1]){

            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;

            if(cnt >= 0){

                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);

                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);

                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;

            }

        }

    }



    for(i = 0; i < maxband; i++){

        for(ch = 0; ch < 2; ch++){

            if(!bands[i].res[ch]) continue;



            if(c->oldDSCF[ch][i]){

                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;

                c->oldDSCF[ch][i] = 0;

            }else{

                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);

                if(t == 64)

                    t += get_bits(gb, 6);

                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;

            }

            for(j = 0; j < 2; j++){

                if((bands[i].scfi[ch] << j) & 2)

                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];

                else{

                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);

                    if(t == 31)

                        t = 64 + get_bits(gb, 6);

                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;

                }

            }

        }

    }



    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){

        for(ch = 0; ch < 2; ch++){

            res = bands[i].res[ch];

            switch(res){

            case -1:

                for(j = 0; j < SAMPLES_PER_BAND; j++)

                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;

                break;

            case 0:

                break;

            case 1:

                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){

                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);

                    t = mpc8_get_mask(gb, 18, cnt);

                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)

                        c->Q[ch][off + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0;

                }

                break;

            case 2:

                cnt = 6;//2*mpc8_thres[res]

                for(j = 0; j < SAMPLES_PER_BAND; j += 3){

                    t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);

                    c->Q[ch][off + j + 0] = mpc8_idx50[t];

                    c->Q[ch][off + j + 1] = mpc8_idx51[t];

                    c->Q[ch][off + j + 2] = mpc8_idx52[t];

                    cnt = (cnt >> 1) + mpc8_huffq2[t];

                }

                break;

            case 3:

            case 4:

                for(j = 0; j < SAMPLES_PER_BAND; j += 2){

                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];

                    c->Q[ch][off + j + 1] = t >> 4;

                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);

                }

                break;

            case 5:

            case 6:

            case 7:

            case 8:

                cnt = 2 * mpc8_thres[res];

                for(j = 0; j < SAMPLES_PER_BAND; j++){

                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];

                    c->Q[ch][off + j] = t;

                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);

                }

                break;

            default:

                for(j = 0; j < SAMPLES_PER_BAND; j++){

                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);

                    if(res != 9){

                        c->Q[ch][off + j] <<= res - 9;

                        c->Q[ch][off + j] |= get_bits(gb, res - 9);

                    }

                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;

                }

            }

        }

    }



    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);



    c->cur_frame++;



    c->last_bits_used = get_bits_count(gb);

    if(c->cur_frame >= c->frames)

        c->cur_frame = 0;

    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;



    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;

}
",1709,,0,1,,-4,"avctx,data,data_size,avpkt,buf,c,gb2,gb,i,j,k,ch,cnt,res,t,bands,off,maxband,keyframe,last,mask,cur_frame",,,,,Greedy,1,0.0028815627098083495
329,"DeviceState *qdev_try_create(BusState *bus, const char *name)

{

    DeviceState *dev;



    if (object_class_by_name(name) == NULL) {

        return NULL;

    }

    dev = DEVICE(object_new(name));

    if (!dev) {

        return NULL;

    }



    if (!bus) {

        bus = sysbus_get_default();

    }



    qdev_set_parent_bus(dev, bus);

    qdev_prop_set_globals(dev);



    return dev;

}
",81,,0,1,,-4,"bus,name,dev",,,,,Greedy,1,0.0021755496660868325
330,"Visitor *qobject_input_visitor_new_keyval(QObject *obj)

{

    QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);



    v->visitor.type_int64 = qobject_input_type_int64_keyval;

    v->visitor.type_uint64 = qobject_input_type_uint64_keyval;

    v->visitor.type_bool = qobject_input_type_bool_keyval;

    v->visitor.type_str = qobject_input_type_str;

    v->visitor.type_number = qobject_input_type_number_keyval;

    v->visitor.type_any = qobject_input_type_any;

    v->visitor.type_null = qobject_input_type_null;

    v->visitor.type_size = qobject_input_type_size_keyval;



    return &v->visitor;

}
",89,,1,0,,-4,"obj,v",,,,,Greedy,1,0.0023931622505187987
331,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)

{

    int iomemtype;

    pl080_state *s;



    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));

    iomemtype = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */

    return s;

}
",79,"void *pl080_init(uint32_t area, qemu_irq drp, int nachances)

{

    int ymemresource;

    pl080_state *socket;



    socket = (pl080_state *)qemu_mallocz(sizeof(pl080_state));

    ymemresource = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, socket);

    cpu_register_physical_memory(area, 0x00000fff, ymemresource);

    socket->area = area;

    socket->drp = drp;

    socket->nachances = nachances;

    /* ??? Save/restore.  */

    return socket;

}
",1,1,1,-1,"base,irq,nchannels,iomemtype,s","base:0.005133390426635742,irq:0.0062716007232666016,nchannels:0.02405261993408203,iomemtype:0.007546842098236084,s:0.0125274658203125,",5,20,"nchannels:nachances,s:socket,iomemtype:ymemresource,irq:drp,base:area,",Greedy,305,0.0525787353515625
332,"static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table,

                                  float **plevel_table, uint16_t **pint_table,

                                  const CoefVLCTable *vlc_table)

{

    int n                        = vlc_table->n;

    const uint8_t  *table_bits   = vlc_table->huffbits;

    const uint32_t *table_codes  = vlc_table->huffcodes;

    const uint16_t *levels_table = vlc_table->levels;

    uint16_t *run_table, *level_table, *int_table;

    float *flevel_table;

    int i, l, j, k, level;



    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);



    run_table    = av_malloc(n * sizeof(uint16_t));

    level_table  = av_malloc(n * sizeof(uint16_t));

    flevel_table = av_malloc(n * sizeof(*flevel_table));

    int_table    = av_malloc(n * sizeof(uint16_t));

    i            = 2;

    level        = 1;

    k            = 0;

    while (i < n) {

        int_table[k] = i;

        l            = levels_table[k++];

        for (j = 0; j < l; j++) {

            run_table[i]    = j;

            level_table[i]  = level;

            flevel_table[i] = level;

            i++;

        }

        level++;

    }

    *prun_table   = run_table;

    *plevel_table = flevel_table;

    *pint_table   = int_table;

    av_free(level_table);

}
",259,"static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table,

                                  float **plevel_table, uint16_t **pint_table,

                                  const CoefVLCTable *vlg_container)

{

    int n                        = vlg_container->n;

    const uint8_t  *table_bits   = vlg_container->huffbits;

    const uint32_t *table_codes  = vlg_container->huffcodes;

    const uint16_t *levels_table = vlg_container->levels;

    uint16_t *build_session, *level_table, *int_table;

    float *flevel_table;

    int i, l, j, k, level;



    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);



    build_session    = av_malloc(n * sizeof(uint16_t));

    level_table  = av_malloc(n * sizeof(uint16_t));

    flevel_table = av_malloc(n * sizeof(*flevel_table));

    int_table    = av_malloc(n * sizeof(uint16_t));

    i            = 2;

    level        = 1;

    k            = 0;

    while (i < n) {

        int_table[k] = i;

        l            = levels_table[k++];

        for (j = 0; j < l; j++) {

            build_session[i]    = j;

            level_table[i]  = level;

            flevel_table[i] = level;

            i++;

        }

        level++;

    }

    *prun_table   = build_session;

    *plevel_table = flevel_table;

    *pint_table   = int_table;

    av_free(level_table);

}
",0,0,1,1,"vlc,prun_table,plevel_table,pint_table,vlc_table,table_bits,table_codes,levels_table,run_table,level_table,int_table,flevel_table,i,l,j,k,level","vlc:0.01688183844089508,prun_table:0.07723498344421387,plevel_table:0.00787457823753357,pint_table:0.04057992994785309,vlc_table:0.11456921696662903,table_bits:0.05197253078222275,table_codes:-0.012471958994865417,levels_table:0.03888940066099167,run_table:0.14514890313148499,level_table:0.10599594563245773,int_table:0.06270958483219147,flevel_table:0.1138368546962738,i:0.018631204962730408,l:0.01732534170150757,j:-0.005669347941875458,k:0.0006548911333084106,level:-0.015121661126613617,",2,9,"run_table:build_session,vlc_table:vlg_container,",Greedy,173,0.03325971762339274
333,"static inline int parse_nal_units(AVCodecParserContext *s,

                                  AVCodecContext *avctx,

                                  const uint8_t *buf, int buf_size)

{

    H264ParseContext *p = s->priv_data;

    const uint8_t *buf_end = buf + buf_size;



    H2645NAL nal = { NULL };



    unsigned int pps_id;

    unsigned int slice_type;

    int state = -1, got_reset = 0;

    int field_poc[2];

    int ret;



    /* set some sane default values */

    s->pict_type         = AV_PICTURE_TYPE_I;

    s->key_frame         = 0;

    s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;



    ff_h264_sei_uninit(&p->sei);



    if (!buf_size)

        return 0;



    for (;;) {

        const SPS *sps;

        int src_length, consumed;

        buf = avpriv_find_start_code(buf, buf_end, &state);

        if (buf >= buf_end)

            break;

        --buf;

        src_length = buf_end - buf;

        switch (state & 0x1f) {

        case H264_NAL_SLICE:

        case H264_NAL_IDR_SLICE:

            // Do not walk the whole buffer just to decode slice header

            if ((state & 0x1f) == H264_NAL_IDR_SLICE || ((state >> 5) & 0x3) == 0) {

                /* IDR or disposable slice

                 * No need to decode many bytes because MMCOs shall not be present. */

                if (src_length > 60)

                    src_length = 60;

            } else {

                /* To decode up to MMCOs */

                if (src_length > 1000)

                    src_length = 1000;

            }

            break;

        }



        consumed = ff_h2645_extract_rbsp(buf, src_length, &nal);

        if (consumed < 0)

            break;



        ret = init_get_bits(&nal.gb, nal.data, nal.size * 8);

        if (ret < 0)

            goto fail;

        get_bits1(&nal.gb);

        nal.ref_idc = get_bits(&nal.gb, 2);

        nal.type    = get_bits(&nal.gb, 5);



        switch (nal.type) {

        case H264_NAL_SPS:

            ff_h264_decode_seq_parameter_set(&nal.gb, avctx, &p->ps);

            break;

        case H264_NAL_PPS:

            ff_h264_decode_picture_parameter_set(&nal.gb, avctx, &p->ps,

                                                 nal.size_bits);

            break;

        case H264_NAL_SEI:

            ff_h264_sei_decode(&p->sei, &nal.gb, &p->ps, avctx);

            break;

        case H264_NAL_IDR_SLICE:

            s->key_frame = 1;



            p->poc.prev_frame_num        = 0;

            p->poc.prev_frame_num_offset = 0;

            p->poc.prev_poc_msb          =

            p->poc.prev_poc_lsb          = 0;

        /* fall through */

        case H264_NAL_SLICE:

            get_ue_golomb(&nal.gb);  // skip first_mb_in_slice

            slice_type   = get_ue_golomb_31(&nal.gb);

            s->pict_type = ff_h264_golomb_to_pict_type[slice_type % 5];

            if (p->sei.recovery_point.recovery_frame_cnt >= 0) {

                /* key frame, since recovery_frame_cnt is set */

                s->key_frame = 1;

            }

            pps_id = get_ue_golomb(&nal.gb);

            if (pps_id >= MAX_PPS_COUNT) {

                av_log(avctx, AV_LOG_ERROR,

                       ""pps_id %u out of range\n"", pps_id);

                goto fail;

            }

            if (!p->ps.pps_list[pps_id]) {

                av_log(avctx, AV_LOG_ERROR,

                       ""non-existing PPS %u referenced\n"", pps_id);

                goto fail;

            }

            p->ps.pps = (const PPS*)p->ps.pps_list[pps_id]->data;

            if (!p->ps.sps_list[p->ps.pps->sps_id]) {

                av_log(avctx, AV_LOG_ERROR,

                       ""non-existing SPS %u referenced\n"", p->ps.pps->sps_id);

                goto fail;

            }

            p->ps.sps = (SPS*)p->ps.sps_list[p->ps.pps->sps_id]->data;



            sps = p->ps.sps;



            p->poc.frame_num = get_bits(&nal.gb, sps->log2_max_frame_num);



            s->coded_width  = 16 * sps->mb_width;

            s->coded_height = 16 * sps->mb_height;

            s->width        = s->coded_width  - (sps->crop_right + sps->crop_left);

            s->height       = s->coded_height - (sps->crop_top   + sps->crop_bottom);

            if (s->width <= 0 || s->height <= 0) {

                s->width  = s->coded_width;

                s->height = s->coded_height;

            }



            switch (sps->bit_depth_luma) {

            case 9:

                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P9;

                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P9;

                else                                  s->format = AV_PIX_FMT_YUV420P9;

                break;

            case 10:

                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P10;

                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P10;

                else                                  s->format = AV_PIX_FMT_YUV420P10;

                break;

            case 8:

                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P;

                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P;

                else                                  s->format = AV_PIX_FMT_YUV420P;

                break;

            default:

                s->format = AV_PIX_FMT_NONE;

            }



            avctx->profile = ff_h264_get_profile(sps);

            avctx->level   = sps->level_idc;



            if (sps->frame_mbs_only_flag) {

                p->picture_structure = PICT_FRAME;

            } else {

                if (get_bits1(&nal.gb)) { // field_pic_flag

                    p->picture_structure = PICT_TOP_FIELD + get_bits1(&nal.gb); // bottom_field_flag

                } else {

                    p->picture_structure = PICT_FRAME;

                }

            }



            if (nal.type == H264_NAL_IDR_SLICE)

                get_ue_golomb(&nal.gb); /* idr_pic_id */

            if (sps->poc_type == 0) {

                p->poc.poc_lsb = get_bits(&nal.gb, sps->log2_max_poc_lsb);



                if (p->ps.pps->pic_order_present == 1 &&

                    p->picture_structure == PICT_FRAME)

                    p->poc.delta_poc_bottom = get_se_golomb(&nal.gb);

            }



            if (sps->poc_type == 1 &&

                !sps->delta_pic_order_always_zero_flag) {

                p->poc.delta_poc[0] = get_se_golomb(&nal.gb);



                if (p->ps.pps->pic_order_present == 1 &&

                    p->picture_structure == PICT_FRAME)

                    p->poc.delta_poc[1] = get_se_golomb(&nal.gb);

            }



            /* Decode POC of this picture.

             * The prev_ values needed for decoding POC of the next picture are not set here. */

            field_poc[0] = field_poc[1] = INT_MAX;

            ff_h264_init_poc(field_poc, &s->output_picture_number, sps,

                             &p->poc, p->picture_structure, nal.ref_idc);



            /* Continue parsing to check if MMCO_RESET is present.

             * FIXME: MMCO_RESET could appear in non-first slice.

             *        Maybe, we should parse all undisposable non-IDR slice of this

             *        picture until encountering MMCO_RESET in a slice of it. */

            if (nal.ref_idc && nal.type != H264_NAL_IDR_SLICE) {

                got_reset = scan_mmco_reset(s, &nal.gb, avctx);

                if (got_reset < 0)

                    goto fail;

            }



            /* Set up the prev_ values for decoding POC of the next picture. */

            p->poc.prev_frame_num        = got_reset ? 0 : p->poc.frame_num;

            p->poc.prev_frame_num_offset = got_reset ? 0 : p->poc.frame_num_offset;

            if (nal.ref_idc != 0) {

                if (!got_reset) {

                    p->poc.prev_poc_msb = p->poc.poc_msb;

                    p->poc.prev_poc_lsb = p->poc.poc_lsb;

                } else {

                    p->poc.prev_poc_msb = 0;

                    p->poc.prev_poc_lsb =

                        p->picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0];

                }

            }



            if (sps->pic_struct_present_flag) {

                switch (p->sei.picture_timing.pic_struct) {

                case SEI_PIC_STRUCT_TOP_FIELD:

                case SEI_PIC_STRUCT_BOTTOM_FIELD:

                    s->repeat_pict = 0;

                    break;

                case SEI_PIC_STRUCT_FRAME:

                case SEI_PIC_STRUCT_TOP_BOTTOM:

                case SEI_PIC_STRUCT_BOTTOM_TOP:

                    s->repeat_pict = 1;

                    break;

                case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:

                case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:

                    s->repeat_pict = 2;

                    break;

                case SEI_PIC_STRUCT_FRAME_DOUBLING:

                    s->repeat_pict = 3;

                    break;

                case SEI_PIC_STRUCT_FRAME_TRIPLING:

                    s->repeat_pict = 5;

                    break;

                default:

                    s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;

                    break;

                }

            } else {

                s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;

            }



            if (p->picture_structure == PICT_FRAME) {

                s->picture_structure = AV_PICTURE_STRUCTURE_FRAME;

                if (sps->pic_struct_present_flag) {

                    switch (p->sei.picture_timing.pic_struct) {

                    case SEI_PIC_STRUCT_TOP_BOTTOM:

                    case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:

                        s->field_order = AV_FIELD_TT;

                        break;

                    case SEI_PIC_STRUCT_BOTTOM_TOP:

                    case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:

                        s->field_order = AV_FIELD_BB;

                        break;

                    default:

                        s->field_order = AV_FIELD_PROGRESSIVE;

                        break;

                    }

                } else {

                    if (field_poc[0] < field_poc[1])

                        s->field_order = AV_FIELD_TT;

                    else if (field_poc[0] > field_poc[1])

                        s->field_order = AV_FIELD_BB;

                    else

                        s->field_order = AV_FIELD_PROGRESSIVE;

                }

            } else {

                if (p->picture_structure == PICT_TOP_FIELD)

                    s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD;

                else

                    s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD;

                s->field_order = AV_FIELD_UNKNOWN;

            }



            av_freep(&nal.rbsp_buffer);

            return 0; /* no need to evaluate the rest */

        }

        buf += consumed;

    }

    /* didn't find a picture! */

    av_log(avctx, AV_LOG_ERROR, ""missing picture in access unit\n"");

fail:

    av_freep(&nal.rbsp_buffer);

    return -1;

}
",1574,"static inline int parse_nal_units(AVCodecParserContext *s,

                                  AVCodecContext *avctx,

                                  const uint8_t *buf, int buflexend)

{

    H264ParseContext *p = s->priv_data;

    const uint8_t *uc_ended = buf + buflexend;



    H2645NAL nal = { NULL };



    unsigned int pps_id;

    unsigned int slice_type;

    int state = -1, got_reset = 0;

    int field_poc[2];

    int ret;



    /* set some sane default values */

    s->pict_type         = AV_PICTURE_TYPE_I;

    s->key_frame         = 0;

    s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;



    ff_h264_sei_uninit(&p->sei);



    if (!buflexend)

        return 0;



    for (;;) {

        const SPS *sps;

        int srcsdistance, consumed;

        buf = avpriv_find_start_code(buf, uc_ended, &state);

        if (buf >= uc_ended)

            break;

        --buf;

        srcsdistance = uc_ended - buf;

        switch (state & 0x1f) {

        case H264_NAL_SLICE:

        case H264_NAL_IDR_SLICE:

            // Do not walk the whole buffer just to decode slice header

            if ((state & 0x1f) == H264_NAL_IDR_SLICE || ((state >> 5) & 0x3) == 0) {

                /* IDR or disposable slice

                 * No need to decode many bytes because MMCOs shall not be present. */

                if (srcsdistance > 60)

                    srcsdistance = 60;

            } else {

                /* To decode up to MMCOs */

                if (srcsdistance > 1000)

                    srcsdistance = 1000;

            }

            break;

        }



        consumed = ff_h2645_extract_rbsp(buf, srcsdistance, &nal);

        if (consumed < 0)

            break;



        ret = init_get_bits(&nal.gb, nal.data, nal.size * 8);

        if (ret < 0)

            goto fail;

        get_bits1(&nal.gb);

        nal.ref_idc = get_bits(&nal.gb, 2);

        nal.type    = get_bits(&nal.gb, 5);



        switch (nal.type) {

        case H264_NAL_SPS:

            ff_h264_decode_seq_parameter_set(&nal.gb, avctx, &p->ps);

            break;

        case H264_NAL_PPS:

            ff_h264_decode_picture_parameter_set(&nal.gb, avctx, &p->ps,

                                                 nal.size_bits);

            break;

        case H264_NAL_SEI:

            ff_h264_sei_decode(&p->sei, &nal.gb, &p->ps, avctx);

            break;

        case H264_NAL_IDR_SLICE:

            s->key_frame = 1;



            p->poc.prev_frame_num        = 0;

            p->poc.prev_frame_num_offset = 0;

            p->poc.prev_poc_msb          =

            p->poc.prev_poc_lsb          = 0;

        /* fall through */

        case H264_NAL_SLICE:

            get_ue_golomb(&nal.gb);  // skip first_mb_in_slice

            slice_type   = get_ue_golomb_31(&nal.gb);

            s->pict_type = ff_h264_golomb_to_pict_type[slice_type % 5];

            if (p->sei.recovery_point.recovery_frame_cnt >= 0) {

                /* key frame, since recovery_frame_cnt is set */

                s->key_frame = 1;

            }

            pps_id = get_ue_golomb(&nal.gb);

            if (pps_id >= MAX_PPS_COUNT) {

                av_log(avctx, AV_LOG_ERROR,

                       ""pps_id %u out of range
"", pps_id);

                goto fail;

            }

            if (!p->ps.pps_list[pps_id]) {

                av_log(avctx, AV_LOG_ERROR,

                       ""non-existing PPS %u referenced
"", pps_id);

                goto fail;

            }

            p->ps.pps = (const PPS*)p->ps.pps_list[pps_id]->data;

            if (!p->ps.sps_list[p->ps.pps->sps_id]) {

                av_log(avctx, AV_LOG_ERROR,

                       ""non-existing SPS %u referenced
"", p->ps.pps->sps_id);

                goto fail;

            }

            p->ps.sps = (SPS*)p->ps.sps_list[p->ps.pps->sps_id]->data;



            sps = p->ps.sps;



            p->poc.frame_num = get_bits(&nal.gb, sps->log2_max_frame_num);



            s->coded_width  = 16 * sps->mb_width;

            s->coded_height = 16 * sps->mb_height;

            s->width        = s->coded_width  - (sps->crop_right + sps->crop_left);

            s->height       = s->coded_height - (sps->crop_top   + sps->crop_bottom);

            if (s->width <= 0 || s->height <= 0) {

                s->width  = s->coded_width;

                s->height = s->coded_height;

            }



            switch (sps->bit_depth_luma) {

            case 9:

                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P9;

                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P9;

                else                                  s->format = AV_PIX_FMT_YUV420P9;

                break;

            case 10:

                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P10;

                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P10;

                else                                  s->format = AV_PIX_FMT_YUV420P10;

                break;

            case 8:

                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P;

                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P;

                else                                  s->format = AV_PIX_FMT_YUV420P;

                break;

            default:

                s->format = AV_PIX_FMT_NONE;

            }



            avctx->profile = ff_h264_get_profile(sps);

            avctx->level   = sps->level_idc;



            if (sps->frame_mbs_only_flag) {

                p->picture_structure = PICT_FRAME;

            } else {

                if (get_bits1(&nal.gb)) { // field_pic_flag

                    p->picture_structure = PICT_TOP_FIELD + get_bits1(&nal.gb); // bottom_field_flag

                } else {

                    p->picture_structure = PICT_FRAME;

                }

            }



            if (nal.type == H264_NAL_IDR_SLICE)

                get_ue_golomb(&nal.gb); /* idr_pic_id */

            if (sps->poc_type == 0) {

                p->poc.poc_lsb = get_bits(&nal.gb, sps->log2_max_poc_lsb);



                if (p->ps.pps->pic_order_present == 1 &&

                    p->picture_structure == PICT_FRAME)

                    p->poc.delta_poc_bottom = get_se_golomb(&nal.gb);

            }



            if (sps->poc_type == 1 &&

                !sps->delta_pic_order_always_zero_flag) {

                p->poc.delta_poc[0] = get_se_golomb(&nal.gb);



                if (p->ps.pps->pic_order_present == 1 &&

                    p->picture_structure == PICT_FRAME)

                    p->poc.delta_poc[1] = get_se_golomb(&nal.gb);

            }



            /* Decode POC of this picture.

             * The prev_ values needed for decoding POC of the next picture are not set here. */

            field_poc[0] = field_poc[1] = INT_MAX;

            ff_h264_init_poc(field_poc, &s->output_picture_number, sps,

                             &p->poc, p->picture_structure, nal.ref_idc);



            /* Continue parsing to check if MMCO_RESET is present.

             * FIXME: MMCO_RESET could appear in non-first slice.

             *        Maybe, we should parse all undisposable non-IDR slice of this

             *        picture until encountering MMCO_RESET in a slice of it. */

            if (nal.ref_idc && nal.type != H264_NAL_IDR_SLICE) {

                got_reset = scan_mmco_reset(s, &nal.gb, avctx);

                if (got_reset < 0)

                    goto fail;

            }



            /* Set up the prev_ values for decoding POC of the next picture. */

            p->poc.prev_frame_num        = got_reset ? 0 : p->poc.frame_num;

            p->poc.prev_frame_num_offset = got_reset ? 0 : p->poc.frame_num_offset;

            if (nal.ref_idc != 0) {

                if (!got_reset) {

                    p->poc.prev_poc_msb = p->poc.poc_msb;

                    p->poc.prev_poc_lsb = p->poc.poc_lsb;

                } else {

                    p->poc.prev_poc_msb = 0;

                    p->poc.prev_poc_lsb =

                        p->picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0];

                }

            }



            if (sps->pic_struct_present_flag) {

                switch (p->sei.picture_timing.pic_struct) {

                case SEI_PIC_STRUCT_TOP_FIELD:

                case SEI_PIC_STRUCT_BOTTOM_FIELD:

                    s->repeat_pict = 0;

                    break;

                case SEI_PIC_STRUCT_FRAME:

                case SEI_PIC_STRUCT_TOP_BOTTOM:

                case SEI_PIC_STRUCT_BOTTOM_TOP:

                    s->repeat_pict = 1;

                    break;

                case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:

                case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:

                    s->repeat_pict = 2;

                    break;

                case SEI_PIC_STRUCT_FRAME_DOUBLING:

                    s->repeat_pict = 3;

                    break;

                case SEI_PIC_STRUCT_FRAME_TRIPLING:

                    s->repeat_pict = 5;

                    break;

                default:

                    s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;

                    break;

                }

            } else {

                s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;

            }



            if (p->picture_structure == PICT_FRAME) {

                s->picture_structure = AV_PICTURE_STRUCTURE_FRAME;

                if (sps->pic_struct_present_flag) {

                    switch (p->sei.picture_timing.pic_struct) {

                    case SEI_PIC_STRUCT_TOP_BOTTOM:

                    case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:

                        s->field_order = AV_FIELD_TT;

                        break;

                    case SEI_PIC_STRUCT_BOTTOM_TOP:

                    case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:

                        s->field_order = AV_FIELD_BB;

                        break;

                    default:

                        s->field_order = AV_FIELD_PROGRESSIVE;

                        break;

                    }

                } else {

                    if (field_poc[0] < field_poc[1])

                        s->field_order = AV_FIELD_TT;

                    else if (field_poc[0] > field_poc[1])

                        s->field_order = AV_FIELD_BB;

                    else

                        s->field_order = AV_FIELD_PROGRESSIVE;

                }

            } else {

                if (p->picture_structure == PICT_TOP_FIELD)

                    s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD;

                else

                    s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD;

                s->field_order = AV_FIELD_UNKNOWN;

            }



            av_freep(&nal.rbsp_buffer);

            return 0; /* no need to evaluate the rest */

        }

        buf += consumed;

    }

    /* didn't find a picture! */

    av_log(avctx, AV_LOG_ERROR, ""missing picture in access unit
"");

fail:

    av_freep(&nal.rbsp_buffer);

    return -1;

}
",0,0,1,1,"s,avctx,buf,buf_size,p,buf_end,pps_id,slice_type,field_poc,ret,sps,src_length,consumed","s:-0.07886141538619995,avctx:-0.007514864206314087,buf:-0.14487358927726746,buf_size:0.16786208748817444,p:0.03620719909667969,buf_end:0.14003217220306396,pps_id:0.1045483946800232,slice_type:0.07148143649101257,field_poc:0.04986044764518738,ret:0.011636853218078613,sps:0.04332989454269409,src_length:0.20695450901985168,consumed:0.02712586522102356,",3,14,"src_length:srcsdistance,buf_size:buflexend,buf_end:uc_ended,",Greedy,309,0.09917850891749064
334,"static av_always_inline void FUNC(intra_pred)(HEVCContext *s, int x0, int y0,

                                              int log2_size, int c_idx)

{

#define PU(x) \

    ((x) >> s->ps.sps->log2_min_pu_size)

#define MVF(x, y) \

    (s->ref->tab_mvf[(x) + (y) * min_pu_width])

#define MVF_PU(x, y) \

    MVF(PU(x0 + ((x) << hshift)), PU(y0 + ((y) << vshift)))

#define IS_INTRA(x, y) \

    (MVF_PU(x, y).pred_flag == PF_INTRA)

#define MIN_TB_ADDR_ZS(x, y) \

    s->ps.pps->min_tb_addr_zs[(y) * (s->ps.sps->tb_mask+2) + (x)]

#define EXTEND(ptr, val, len)         \

do {                                  \

    pixel4 pix = PIXEL_SPLAT_X4(val); \

    for (i = 0; i < (len); i += 4)    \

        AV_WN4P(ptr + i, pix);        \

} while (0)



#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \

        for (i = start; i < (start) + (length); i += 4)                        \

            if (!IS_INTRA(i, -1))                                              \

                AV_WN4P(&ptr[i], a);                                           \

            else                                                               \

                a = PIXEL_SPLAT_X4(ptr[i+3])

#define EXTEND_LEFT_CIP(ptr, start, length) \

        for (i = start; i > (start) - (length); i--) \

            if (!IS_INTRA(i - 1, -1)) \

                ptr[i - 1] = ptr[i]

#define EXTEND_UP_CIP(ptr, start, length)                                      \

        for (i = (start); i > (start) - (length); i -= 4)                      \

            if (!IS_INTRA(-1, i - 3))                                          \

                AV_WN4P(&ptr[i - 3], a);                                       \

            else                                                               \

                a = PIXEL_SPLAT_X4(ptr[i - 3])

#define EXTEND_DOWN_CIP(ptr, start, length)                                    \

        for (i = start; i < (start) + (length); i += 4)                        \

            if (!IS_INTRA(-1, i))                                              \

                AV_WN4P(&ptr[i], a);                                           \

            else                                                               \

                a = PIXEL_SPLAT_X4(ptr[i + 3])



    HEVCLocalContext *lc = s->HEVClc;

    int i;

    int hshift = s->ps.sps->hshift[c_idx];

    int vshift = s->ps.sps->vshift[c_idx];

    int size = (1 << log2_size);

    int size_in_luma_h = size << hshift;

    int size_in_tbs_h  = size_in_luma_h >> s->ps.sps->log2_min_tb_size;

    int size_in_luma_v = size << vshift;

    int size_in_tbs_v  = size_in_luma_v >> s->ps.sps->log2_min_tb_size;

    int x = x0 >> hshift;

    int y = y0 >> vshift;

    int x_tb = (x0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask;

    int y_tb = (y0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask;



    int cur_tb_addr = MIN_TB_ADDR_ZS(x_tb, y_tb);



    ptrdiff_t stride = s->frame->linesize[c_idx] / sizeof(pixel);

    pixel *src = (pixel*)s->frame->data[c_idx] + x + y * stride;



    int min_pu_width = s->ps.sps->min_pu_width;



    enum IntraPredMode mode = c_idx ? lc->tu.intra_pred_mode_c :

                              lc->tu.intra_pred_mode;

    pixel4 a;

    pixel  left_array[2 * MAX_TB_SIZE + 1];

    pixel  filtered_left_array[2 * MAX_TB_SIZE + 1];

    pixel  top_array[2 * MAX_TB_SIZE + 1];

    pixel  filtered_top_array[2 * MAX_TB_SIZE + 1];



    pixel  *left          = left_array + 1;

    pixel  *top           = top_array  + 1;

    pixel  *filtered_left = filtered_left_array + 1;

    pixel  *filtered_top  = filtered_top_array  + 1;

    int cand_bottom_left = lc->na.cand_bottom_left && cur_tb_addr > MIN_TB_ADDR_ZS( x_tb - 1, (y_tb + size_in_tbs_v) & s->ps.sps->tb_mask);

    int cand_left        = lc->na.cand_left;

    int cand_up_left     = lc->na.cand_up_left;

    int cand_up          = lc->na.cand_up;

    int cand_up_right    = lc->na.cand_up_right    && cur_tb_addr > MIN_TB_ADDR_ZS((x_tb + size_in_tbs_h) & s->ps.sps->tb_mask, y_tb - 1);



    int bottom_left_size = (FFMIN(y0 + 2 * size_in_luma_v, s->ps.sps->height) -

                           (y0 + size_in_luma_v)) >> vshift;

    int top_right_size   = (FFMIN(x0 + 2 * size_in_luma_h, s->ps.sps->width) -

                           (x0 + size_in_luma_h)) >> hshift;



    if (s->ps.pps->constrained_intra_pred_flag == 1) {

        int size_in_luma_pu_v = PU(size_in_luma_v);

        int size_in_luma_pu_h = PU(size_in_luma_h);

        int on_pu_edge_x    = !av_mod_uintp2(x0, s->ps.sps->log2_min_pu_size);

        int on_pu_edge_y    = !av_mod_uintp2(y0, s->ps.sps->log2_min_pu_size);

        if (!size_in_luma_pu_h)

            size_in_luma_pu_h++;

        if (cand_bottom_left == 1 && on_pu_edge_x) {

            int x_left_pu   = PU(x0 - 1);

            int y_bottom_pu = PU(y0 + size_in_luma_v);

            int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_bottom_pu);

            cand_bottom_left = 0;

            for (i = 0; i < max; i += 2)

                cand_bottom_left |= (MVF(x_left_pu, y_bottom_pu + i).pred_flag == PF_INTRA);

        }

        if (cand_left == 1 && on_pu_edge_x) {

            int x_left_pu   = PU(x0 - 1);

            int y_left_pu   = PU(y0);

            int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_left_pu);

            cand_left = 0;

            for (i = 0; i < max; i += 2)

                cand_left |= (MVF(x_left_pu, y_left_pu + i).pred_flag == PF_INTRA);

        }

        if (cand_up_left == 1) {

            int x_left_pu   = PU(x0 - 1);

            int y_top_pu    = PU(y0 - 1);

            cand_up_left = MVF(x_left_pu, y_top_pu).pred_flag == PF_INTRA;

        }

        if (cand_up == 1 && on_pu_edge_y) {

            int x_top_pu    = PU(x0);

            int y_top_pu    = PU(y0 - 1);

            int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_top_pu);

            cand_up = 0;

            for (i = 0; i < max; i += 2)

                cand_up |= (MVF(x_top_pu + i, y_top_pu).pred_flag == PF_INTRA);

        }

        if (cand_up_right == 1 && on_pu_edge_y) {

            int y_top_pu    = PU(y0 - 1);

            int x_right_pu  = PU(x0 + size_in_luma_h);

            int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_right_pu);

            cand_up_right = 0;

            for (i = 0; i < max; i += 2)

                cand_up_right |= (MVF(x_right_pu + i, y_top_pu).pred_flag == PF_INTRA);

        }

        memset(left, 128, 2 * MAX_TB_SIZE*sizeof(pixel));

        memset(top , 128, 2 * MAX_TB_SIZE*sizeof(pixel));

        top[-1] = 128;

    }

    if (cand_up_left) {

        left[-1] = POS(-1, -1);

        top[-1]  = left[-1];

    }

    if (cand_up)

        memcpy(top, src - stride, size * sizeof(pixel));

    if (cand_up_right) {

        memcpy(top + size, src - stride + size, size * sizeof(pixel));

        EXTEND(top + size + top_right_size, POS(size + top_right_size - 1, -1),

               size - top_right_size);

    }

    if (cand_left)

        for (i = 0; i < size; i++)

            left[i] = POS(-1, i);

    if (cand_bottom_left) {

        for (i = size; i < size + bottom_left_size; i++)

            left[i] = POS(-1, i);

        EXTEND(left + size + bottom_left_size, POS(-1, size + bottom_left_size - 1),

               size - bottom_left_size);

    }



    if (s->ps.pps->constrained_intra_pred_flag == 1) {

        if (cand_bottom_left || cand_left || cand_up_left || cand_up || cand_up_right) {

            int size_max_x = x0 + ((2 * size) << hshift) < s->ps.sps->width ?

                                    2 * size : (s->ps.sps->width - x0) >> hshift;

            int size_max_y = y0 + ((2 * size) << vshift) < s->ps.sps->height ?

                                    2 * size : (s->ps.sps->height - y0) >> vshift;

            int j = size + (cand_bottom_left? bottom_left_size: 0) -1;

            if (!cand_up_right) {

                size_max_x = x0 + ((size) << hshift) < s->ps.sps->width ?

                                                    size : (s->ps.sps->width - x0) >> hshift;

            }

            if (!cand_bottom_left) {

                size_max_y = y0 + (( size) << vshift) < s->ps.sps->height ?

                                                     size : (s->ps.sps->height - y0) >> vshift;

            }

            if (cand_bottom_left || cand_left || cand_up_left) {

                while (j > -1 && !IS_INTRA(-1, j))

                    j--;

                if (!IS_INTRA(-1, j)) {

                    j = 0;

                    while (j < size_max_x && !IS_INTRA(j, -1))

                        j++;

                    EXTEND_LEFT_CIP(top, j, j + 1);

                    left[-1] = top[-1];

                }

            } else {

                j = 0;

                while (j < size_max_x && !IS_INTRA(j, -1))

                    j++;

                if (j > 0)

                    if (x0 > 0) {

                        EXTEND_LEFT_CIP(top, j, j + 1);

                    } else {

                        EXTEND_LEFT_CIP(top, j, j);

                        top[-1] = top[0];

                    }

                left[-1] = top[-1];

            }

            left[-1] = top[-1];

            if (cand_bottom_left || cand_left) {

                a = PIXEL_SPLAT_X4(left[-1]);

                EXTEND_DOWN_CIP(left, 0, size_max_y);

            }

            if (!cand_left)

                EXTEND(left, left[-1], size);

            if (!cand_bottom_left)

                EXTEND(left + size, left[size - 1], size);

            if (x0 != 0 && y0 != 0) {

                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);

                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);

                if (!IS_INTRA(-1, - 1))

                    left[-1] = left[0];

            } else if (x0 == 0) {

                EXTEND(left, 0, size_max_y);

            } else {

                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);

                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);

            }

            top[-1] = left[-1];

            if (y0 != 0) {

                a = PIXEL_SPLAT_X4(left[-1]);

                EXTEND_RIGHT_CIP(top, 0, size_max_x);

            }

        }

    }

    // Infer the unavailable samples

    if (!cand_bottom_left) {

        if (cand_left) {

            EXTEND(left + size, left[size - 1], size);

        } else if (cand_up_left) {

            EXTEND(left, left[-1], 2 * size);

            cand_left = 1;

        } else if (cand_up) {

            left[-1] = top[0];

            EXTEND(left, left[-1], 2 * size);

            cand_up_left = 1;

            cand_left    = 1;

        } else if (cand_up_right) {

            EXTEND(top, top[size], size);

            left[-1] = top[size];

            EXTEND(left, left[-1], 2 * size);

            cand_up      = 1;

            cand_up_left = 1;

            cand_left    = 1;

        } else { // No samples available

            left[-1] = (1 << (BIT_DEPTH - 1));

            EXTEND(top,  left[-1], 2 * size);

            EXTEND(left, left[-1], 2 * size);

        }

    }



    if (!cand_left)

        EXTEND(left, left[size], size);

    if (!cand_up_left) {

        left[-1] = left[0];

    }

    if (!cand_up)

        EXTEND(top, left[-1], size);

    if (!cand_up_right)

        EXTEND(top + size, top[size - 1], size);



    top[-1] = left[-1];



    // Filtering process

    if (!s->ps.sps->intra_smoothing_disabled_flag && (c_idx == 0  || s->ps.sps->chroma_format_idc == 3)) {

        if (mode != INTRA_DC && size != 4){

            int intra_hor_ver_dist_thresh[] = { 7, 1, 0 };

            int min_dist_vert_hor = FFMIN(FFABS((int)(mode - 26U)),

                                          FFABS((int)(mode - 10U)));

            if (min_dist_vert_hor > intra_hor_ver_dist_thresh[log2_size - 3]) {

                int threshold = 1 << (BIT_DEPTH - 5);

                if (s->ps.sps->sps_strong_intra_smoothing_enable_flag && c_idx == 0 &&

                    log2_size == 5 &&

                    FFABS(top[-1]  + top[63]  - 2 * top[31])  < threshold &&

                    FFABS(left[-1] + left[63] - 2 * left[31]) < threshold) {

                    // We can't just overwrite values in top because it could be

                    // a pointer into src

                    filtered_top[-1] = top[-1];

                    filtered_top[63] = top[63];

                    for (i = 0; i < 63; i++)

                        filtered_top[i] = ((64 - (i + 1)) * top[-1] +

                                           (i + 1)  * top[63] + 32) >> 6;

                    for (i = 0; i < 63; i++)

                        left[i] = ((64 - (i + 1)) * left[-1] +

                                   (i + 1)  * left[63] + 32) >> 6;

                    top = filtered_top;

                } else {

                    filtered_left[2 * size - 1] = left[2 * size - 1];

                    filtered_top[2 * size - 1]  = top[2 * size - 1];

                    for (i = 2 * size - 2; i >= 0; i--)

                        filtered_left[i] = (left[i + 1] + 2 * left[i] +

                                            left[i - 1] + 2) >> 2;

                    filtered_top[-1]  =

                    filtered_left[-1] = (left[0] + 2 * left[-1] + top[0] + 2) >> 2;

                    for (i = 2 * size - 2; i >= 0; i--)

                        filtered_top[i] = (top[i + 1] + 2 * top[i] +

                                           top[i - 1] + 2) >> 2;

                    left = filtered_left;

                    top  = filtered_top;

                }

            }

        }

    }



    switch (mode) {

    case INTRA_PLANAR:

        s->hpc.pred_planar[log2_size - 2]((uint8_t *)src, (uint8_t *)top,

                                          (uint8_t *)left, stride);

        break;

    case INTRA_DC:

        s->hpc.pred_dc((uint8_t *)src, (uint8_t *)top,

                       (uint8_t *)left, stride, log2_size, c_idx);

        break;

    default:

        s->hpc.pred_angular[log2_size - 2]((uint8_t *)src, (uint8_t *)top,

                                           (uint8_t *)left, stride, c_idx,

                                           mode);

        break;

    }

}
",2695,,1,0,,-4,"s,x0,y0,log2_size,c_idx,i,a",,,,,Greedy,1,0.0032290299733479817
335,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
",93,"static void end_last_frame(AVFilterContext *cli)

{

    TileContext *grade    = cli->priv;

    AVFilterLink *againstyle = cli->outputs[0];

    AVFilterBufferRef *outIPbuff = againstyle->outIPbuff;



    againstyle->outIPbuff = NULL;

    ff_start_frame(againstyle, outIPbuff);

    while (grade->current < grade->nb_frames)

        draw_blank_frame(cli, outIPbuff);

    ff_draw_slice(againstyle, 0, outIPbuff->video->h, 1);

    ff_end_frame(againstyle);

    grade->current = 0;

}
",0,0,1,1,"ctx,tile,outlink,out_buf","ctx:0.0665179193019867,tile:0.11940620094537735,outlink:0.03709179908037186,out_buf:0.08826421573758125,",4,20,"tile:grade,out_buf:outIPbuff,ctx:cli,outlink:againstyle,",Greedy,264,0.044906202952067056
336,"void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = format;

    format->next = NULL;

}
",45,"void av_register_output_format(AVOutputFormat *xml)

{

    AVOutputFormat **f = &first_oformat;



    while (*f != NULL)

        f = &(*f)->next;



    *f = xml;

    xml->next = NULL;

}
",0,0,1,1,"format,p","format:0.09234004095196724,p:0.39729178696870804,",2,8,"p:f,format:xml,",Greedy,106,0.020016050338745116
337,"static void decode_32Bit_opc(CPUTriCoreState *env, DisasContext *ctx)

{

    int op1;

    int32_t r1, r2, r3;

    int32_t address, const16;

    int8_t b, const4;

    int32_t bpos;

    TCGv temp, temp2, temp3;



    op1 = MASK_OP_MAJOR(ctx->opcode);



    /* handle JNZ.T opcode only being 7 bit long */

    if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) {

        op1 = OPCM_32_BRN_JTT;

    }



    switch (op1) {

/* ABS-format */

    case OPCM_32_ABS_LDW:

        decode_abs_ldw(env, ctx);


    case OPCM_32_ABS_LDB:

        decode_abs_ldb(env, ctx);


    case OPCM_32_ABS_LDMST_SWAP:

        decode_abs_ldst_swap(env, ctx);


    case OPCM_32_ABS_LDST_CONTEXT:

        decode_abs_ldst_context(env, ctx);


    case OPCM_32_ABS_STORE:

        decode_abs_store(env, ctx);


    case OPCM_32_ABS_STOREB_H:

        decode_abs_storeb_h(env, ctx);


    case OPC1_32_ABS_STOREQ:

        address = MASK_OP_ABS_OFF18(ctx->opcode);

        r1 = MASK_OP_ABS_S1D(ctx->opcode);

        temp = tcg_const_i32(EA_ABS_FORMAT(address));

        temp2 = tcg_temp_new();



        tcg_gen_shri_tl(temp2, cpu_gpr_d[r1], 16);

        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_LEUW);



        tcg_temp_free(temp2);

        tcg_temp_free(temp);


    case OPC1_32_ABS_LD_Q:

        address = MASK_OP_ABS_OFF18(ctx->opcode);

        r1 = MASK_OP_ABS_S1D(ctx->opcode);

        temp = tcg_const_i32(EA_ABS_FORMAT(address));



        tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LEUW);

        tcg_gen_shli_tl(cpu_gpr_d[r1], cpu_gpr_d[r1], 16);



        tcg_temp_free(temp);


    case OPC1_32_ABS_LEA:

        address = MASK_OP_ABS_OFF18(ctx->opcode);

        r1 = MASK_OP_ABS_S1D(ctx->opcode);

        tcg_gen_movi_tl(cpu_gpr_a[r1], EA_ABS_FORMAT(address));


/* ABSB-format */

    case OPC1_32_ABSB_ST_T:

        address = MASK_OP_ABS_OFF18(ctx->opcode);

        b = MASK_OP_ABSB_B(ctx->opcode);

        bpos = MASK_OP_ABSB_BPOS(ctx->opcode);



        temp = tcg_const_i32(EA_ABS_FORMAT(address));

        temp2 = tcg_temp_new();



        tcg_gen_qemu_ld_tl(temp2, temp, ctx->mem_idx, MO_UB);

        tcg_gen_andi_tl(temp2, temp2, ~(0x1u << bpos));

        tcg_gen_ori_tl(temp2, temp2, (b << bpos));

        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_UB);



        tcg_temp_free(temp);

        tcg_temp_free(temp2);


/* B-format */

    case OPC1_32_B_CALL:

    case OPC1_32_B_CALLA:

    case OPC1_32_B_J:

    case OPC1_32_B_JA:

    case OPC1_32_B_JL:

    case OPC1_32_B_JLA:

        address = MASK_OP_B_DISP24(ctx->opcode);

        gen_compute_branch(ctx, op1, 0, 0, 0, address);


/* Bit-format */

    case OPCM_32_BIT_ANDACC:

        decode_bit_andacc(env, ctx);


    case OPCM_32_BIT_LOGICAL_T1:

        decode_bit_logical_t(env, ctx);


    case OPCM_32_BIT_INSERT:

        decode_bit_insert(env, ctx);


    case OPCM_32_BIT_LOGICAL_T2:

        decode_bit_logical_t2(env, ctx);


    case OPCM_32_BIT_ORAND:

        decode_bit_orand(env, ctx);


    case OPCM_32_BIT_SH_LOGIC1:

        decode_bit_sh_logic1(env, ctx);


    case OPCM_32_BIT_SH_LOGIC2:

        decode_bit_sh_logic2(env, ctx);


    /* BO Format */

    case OPCM_32_BO_ADDRMODE_POST_PRE_BASE:

        decode_bo_addrmode_post_pre_base(env, ctx);


    case OPCM_32_BO_ADDRMODE_BITREVERSE_CIRCULAR:

        decode_bo_addrmode_bitreverse_circular(env, ctx);


    case OPCM_32_BO_ADDRMODE_LD_POST_PRE_BASE:

        decode_bo_addrmode_ld_post_pre_base(env, ctx);


    case OPCM_32_BO_ADDRMODE_LD_BITREVERSE_CIRCULAR:

        decode_bo_addrmode_ld_bitreverse_circular(env, ctx);


    case OPCM_32_BO_ADDRMODE_STCTX_POST_PRE_BASE:

        decode_bo_addrmode_stctx_post_pre_base(env, ctx);


    case OPCM_32_BO_ADDRMODE_LDMST_BITREVERSE_CIRCULAR:

        decode_bo_addrmode_ldmst_bitreverse_circular(env, ctx);


/* BOL-format */

    case OPC1_32_BOL_LD_A_LONGOFF:

    case OPC1_32_BOL_LD_W_LONGOFF:

    case OPC1_32_BOL_LEA_LONGOFF:

    case OPC1_32_BOL_ST_W_LONGOFF:

    case OPC1_32_BOL_ST_A_LONGOFF:

        decode_bol_opc(env, ctx, op1);


/* BRC Format */

    case OPCM_32_BRC_EQ_NEQ:

    case OPCM_32_BRC_GE:

    case OPCM_32_BRC_JLT:

    case OPCM_32_BRC_JNE:

        const4 = MASK_OP_BRC_CONST4_SEXT(ctx->opcode);

        address = MASK_OP_BRC_DISP15_SEXT(ctx->opcode);

        r1 = MASK_OP_BRC_S1(ctx->opcode);

        gen_compute_branch(ctx, op1, r1, 0, const4, address);


/* BRN Format */

    case OPCM_32_BRN_JTT:

        address = MASK_OP_BRN_DISP15_SEXT(ctx->opcode);

        r1 = MASK_OP_BRN_S1(ctx->opcode);

        gen_compute_branch(ctx, op1, r1, 0, 0, address);


/* BRR Format */

    case OPCM_32_BRR_EQ_NEQ:

    case OPCM_32_BRR_ADDR_EQ_NEQ:

    case OPCM_32_BRR_GE:

    case OPCM_32_BRR_JLT:

    case OPCM_32_BRR_JNE:

    case OPCM_32_BRR_JNZ:

    case OPCM_32_BRR_LOOP:

        address = MASK_OP_BRR_DISP15_SEXT(ctx->opcode);

        r2 = MASK_OP_BRR_S2(ctx->opcode);

        r1 = MASK_OP_BRR_S1(ctx->opcode);

        gen_compute_branch(ctx, op1, r1, r2, 0, address);


/* RC Format */

    case OPCM_32_RC_LOGICAL_SHIFT:

        decode_rc_logical_shift(env, ctx);


    case OPCM_32_RC_ACCUMULATOR:

        decode_rc_accumulator(env, ctx);


    case OPCM_32_RC_SERVICEROUTINE:

        decode_rc_serviceroutine(env, ctx);


    case OPCM_32_RC_MUL:

        decode_rc_mul(env, ctx);


/* RCPW Format */

    case OPCM_32_RCPW_MASK_INSERT:

        decode_rcpw_insert(env, ctx);


/* RCRR Format */

    case OPC1_32_RCRR_INSERT:

        r1 = MASK_OP_RCRR_S1(ctx->opcode);

        r2 = MASK_OP_RCRR_S3(ctx->opcode);

        r3 = MASK_OP_RCRR_D(ctx->opcode);

        const16 = MASK_OP_RCRR_CONST4(ctx->opcode);

        temp = tcg_const_i32(const16);

        temp2 = tcg_temp_new(); /* width*/

        temp3 = tcg_temp_new(); /* pos */



        tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f);

        tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f);



        gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], temp, temp2, temp3);



        tcg_temp_free(temp);

        tcg_temp_free(temp2);

        tcg_temp_free(temp3);


/* RCRW Format */

    case OPCM_32_RCRW_MASK_INSERT:

        decode_rcrw_insert(env, ctx);


/* RCR Format */

    case OPCM_32_RCR_COND_SELECT:

        decode_rcr_cond_select(env, ctx);


    case OPCM_32_RCR_MADD:

        decode_rcr_madd(env, ctx);


    case OPCM_32_RCR_MSUB:

        decode_rcr_msub(env, ctx);


/* RLC Format */

    case OPC1_32_RLC_ADDI:

    case OPC1_32_RLC_ADDIH:

    case OPC1_32_RLC_ADDIH_A:

    case OPC1_32_RLC_MFCR:

    case OPC1_32_RLC_MOV:

    case OPC1_32_RLC_MOV_64:

    case OPC1_32_RLC_MOV_U:

    case OPC1_32_RLC_MOV_H:

    case OPC1_32_RLC_MOVH_A:

    case OPC1_32_RLC_MTCR:

        decode_rlc_opc(env, ctx, op1);






    }

}",1016,,1,0,,-4,"env,ctx,op1,r1,r2,r3,address,const16,b,const4,bpos,temp,temp2,temp3",,,,,Greedy,1,0.0024879256884257
338,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
",61,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *flower,

                                                            int PERmissions)

{

    AVFilterBufferRef *fcurl =

        avfilter_get_video_buffer_ref_from_arrays(flower->data, flower->linesize, PERmissions,

                                                  flower->width, flower->height,

                                                  flower->format);

    if (!fcurl)

        return NULL;

    avfilter_copy_frame_props(fcurl, flower);

    return fcurl;

}
",0,0,1,1,"frame,perms,picref","frame:0.04717515408992767,perms:0.02368442714214325,picref:0.030724577605724335,",3,13,"frame:flower,picref:fcurl,perms:PERmissions,",Greedy,139,0.0260662039120992
339,"void *g_realloc(void *ptr, size_t size)

{

    size_t old_size, copy;

    void *new_ptr;



    if (!ptr)

        return g_malloc(size);

    old_size = *(size_t *)((char *)ptr - 16);

    copy = old_size < size ? old_size : size;

    new_ptr = g_malloc(size);

    memcpy(new_ptr, ptr, copy);

    g_free(ptr);

    return new_ptr;

}
",84,,1,0,,-4,"ptr,size,old_size,copy,new_ptr",,,,,Greedy,1,0.0020275235176086424
340,"static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)

{

    AVStream *st;

    OutputStream *ost;

    AVCodecContext *audio_enc;



    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);

    st  = ost->st;



    audio_enc = st->codec;

    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;



    if (!ost->stream_copy) {

        char *sample_fmt = NULL;



        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);



        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);

        if (sample_fmt &&

            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid sample format '%s'\n"", sample_fmt);

            exit_program(1);

        }



        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);

    }



    return ost;

}
",153,,1,0,,-4,"o,oc,st,ost,audio_enc,sample_fmt",,,,,Greedy,1,0.0021144946416219077
341,"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
                            AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size       = avpkt->size;
    AVFrame *const p   = data;
    int compressed, xmin, ymin, xmax, ymax;
    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,
                 bytes_per_scanline;
    uint8_t *ptr;
    const uint8_t *buf_end = buf + buf_size;
    const uint8_t *bufstart = buf;
    uint8_t *scanline;
    int ret = -1;
    if (buf[0] != 0x0a || buf[1] > 5) {
        av_log(avctx, AV_LOG_ERROR, ""this is not PCX encoded data\n"");
    compressed = buf[2];
    xmin       = AV_RL16(buf + 4);
    ymin       = AV_RL16(buf + 6);
    xmax       = AV_RL16(buf + 8);
    ymax       = AV_RL16(buf + 10);
    if (xmax < xmin || ymax < ymin) {
        av_log(avctx, AV_LOG_ERROR, ""invalid image dimensions\n"");
    w = xmax - xmin + 1;
    h = ymax - ymin + 1;
    bits_per_pixel     = buf[3];
    bytes_per_line     = AV_RL16(buf + 66);
    nplanes            = buf[65];
    bytes_per_scanline = nplanes * bytes_per_line;
    if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 ||
        (!compressed && bytes_per_scanline > buf_size / h)) {
        av_log(avctx, AV_LOG_ERROR, ""PCX data is corrupted\n"");
    switch ((nplanes << 8) + bits_per_pixel) {
    case 0x0308:
        avctx->pix_fmt = AV_PIX_FMT_RGB24;
        break;
    case 0x0108:
    case 0x0104:
    case 0x0102:
    case 0x0101:
    case 0x0401:
    case 0x0301:
    case 0x0201:
        avctx->pix_fmt = AV_PIX_FMT_PAL8;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR, ""invalid PCX file\n"");
    buf += 128;
    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)
        return ret;
    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
        return ret;
    p->pict_type = AV_PICTURE_TYPE_I;
    ptr    = p->data[0];
    stride = p->linesize[0];
    scanline = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE);
    if (!scanline)
        return AVERROR(ENOMEM);
    if (nplanes == 3 && bits_per_pixel == 8) {
        for (y = 0; y < h; y++) {
            buf = pcx_rle_decode(buf, buf_end,
                                 scanline, bytes_per_scanline, compressed);
            for (x = 0; x < w; x++) {
                ptr[3 * x]     = scanline[x];
                ptr[3 * x + 1] = scanline[x + bytes_per_line];
                ptr[3 * x + 2] = scanline[x + (bytes_per_line << 1)];
            ptr += stride;
    } else if (nplanes == 1 && bits_per_pixel == 8) {
        const uint8_t *palstart = bufstart + buf_size - 769;
        if (buf_size < 769) {
            av_log(avctx, AV_LOG_ERROR, ""File is too short\n"");
            ret = avctx->err_recognition & AV_EF_EXPLODE ?
                  AVERROR_INVALIDDATA : buf_size;
            goto end;
        for (y = 0; y < h; y++, ptr += stride) {
            buf = pcx_rle_decode(buf, buf_end,
                                 scanline, bytes_per_scanline, compressed);
            memcpy(ptr, scanline, w);
        if (buf != palstart) {
            av_log(avctx, AV_LOG_WARNING, ""image data possibly corrupted\n"");
            buf = palstart;
        if (*buf++ != 12) {
            av_log(avctx, AV_LOG_ERROR, ""expected palette after image data\n"");
            ret = avctx->err_recognition & AV_EF_EXPLODE ?
                  AVERROR_INVALIDDATA : buf_size;
            goto end;
    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */
        GetBitContext s;
        for (y = 0; y < h; y++) {
            init_get_bits(&s, scanline, bytes_per_scanline << 3);
            buf = pcx_rle_decode(buf, buf_end,
                                 scanline, bytes_per_scanline, compressed);
            for (x = 0; x < w; x++)
                ptr[x] = get_bits(&s, bits_per_pixel);
            ptr += stride;
    } else {    /* planar, 4, 8 or 16 colors */
        int i;
        for (y = 0; y < h; y++) {
            buf = pcx_rle_decode(buf, buf_end,
                                 scanline, bytes_per_scanline, compressed);
            for (x = 0; x < w; x++) {
                int m = 0x80 >> (x & 7), v = 0;
                for (i = nplanes - 1; i >= 0; i--) {
                    v <<= 1;
                    v  += !!(scanline[i * bytes_per_line + (x >> 3)] & m);
                ptr[x] = v;
            ptr += stride;
    if (nplanes == 1 && bits_per_pixel == 8) {
        pcx_palette(&buf, (uint32_t *)p->data[1], 256);
    } else if (bits_per_pixel < 8) {
        const uint8_t *palette = bufstart + 16;
        pcx_palette(&palette, (uint32_t *)p->data[1], 16);
    *got_frame = 1;
    ret = buf - bufstart;
end:
    av_free(scanline);
    return ret;",988,"static int pcx_decode_frame(AVCodecContext *averctl, void *block, int *af_range,
                            AVPacket *avcpkg)
{
    const uint8_t *cb = avcpkg->block;
    int buf_size       = avcpkg->size;
    AVFrame *const port   = block;
    int expressed, yMin, xskip, yend, ymake;
    unsigned int win, e, bits_per_second, bytes_perjlin, numbands, slider, y, time,
                 bytes_per_readlin;
    uint8_t *port;
    const uint8_t *buffer_end = cb + buf_size;
    const uint8_t *buffrom = cb;
    uint8_t *readpos;
    int ret = -1;
    if (cb[0] != 0x0a || cb[1] > 5) {
        av_log(averctl, AV_LOG_ERROR, ""this is not PCX encoded data
"");
    expressed = cb[2];
    yMin       = AV_RL16(cb + 4);
    xskip       = AV_RL16(cb + 6);
    yend       = AV_RL16(cb + 8);
    ymake       = AV_RL16(cb + 10);
    if (yend < yMin || ymake < xskip) {
        av_log(averctl, AV_LOG_ERROR, ""invalid image dimensions
"");
    win = yend - yMin + 1;
    e = ymake - xskip + 1;
    bits_per_second     = cb[3];
    bytes_perjlin     = AV_RL16(cb + 66);
    numbands            = cb[65];
    bytes_per_readlin = numbands * bytes_perjlin;
    if (bytes_per_readlin < (win * bits_per_second * numbands + 7) / 8 ||
        (!expressed && bytes_per_readlin > buf_size / e)) {
        av_log(averctl, AV_LOG_ERROR, ""PCX data is corrupted
"");
    switch ((numbands << 8) + bits_per_second) {
    case 0x0308:
        averctl->pix_fmt = AV_PIX_FMT_RGB24;
        break;
    case 0x0108:
    case 0x0104:
    case 0x0102:
    case 0x0101:
    case 0x0401:
    case 0x0301:
    case 0x0201:
        averctl->pix_fmt = AV_PIX_FMT_PAL8;
        break;
    default:
        av_log(averctl, AV_LOG_ERROR, ""invalid PCX file
"");
    cb += 128;
    if ((ret = ff_set_dimensions(averctl, win, e)) < 0)
        return ret;
    if ((ret = ff_get_buffer(averctl, port, 0)) < 0) {
        av_log(averctl, AV_LOG_ERROR, ""get_buffer() failed
"");
        return ret;
    port->pict_type = AV_PICTURE_TYPE_I;
    port    = port->block[0];
    slider = port->linesize[0];
    readpos = av_malloc(bytes_per_readlin + AV_INPUT_BUFFER_PADDING_SIZE);
    if (!readpos)
        return AVERROR(ENOMEM);
    if (numbands == 3 && bits_per_second == 8) {
        for (y = 0; y < e; y++) {
            cb = pcx_rle_decode(cb, buffer_end,
                                 readpos, bytes_per_readlin, expressed);
            for (time = 0; time < win; time++) {
                port[3 * time]     = readpos[time];
                port[3 * time + 1] = readpos[time + bytes_perjlin];
                port[3 * time + 2] = readpos[time + (bytes_perjlin << 1)];
            port += slider;
    } else if (numbands == 1 && bits_per_second == 8) {
        const uint8_t *palstart = buffrom + buf_size - 769;
        if (buf_size < 769) {
            av_log(averctl, AV_LOG_ERROR, ""File is too short
"");
            ret = averctl->err_recognition & AV_EF_EXPLODE ?
                  AVERROR_INVALIDDATA : buf_size;
            goto end;
        for (y = 0; y < e; y++, port += slider) {
            cb = pcx_rle_decode(cb, buffer_end,
                                 readpos, bytes_per_readlin, expressed);
            memcpy(port, readpos, win);
        if (cb != palstart) {
            av_log(averctl, AV_LOG_WARNING, ""image data possibly corrupted
"");
            cb = palstart;
        if (*cb++ != 12) {
            av_log(averctl, AV_LOG_ERROR, ""expected palette after image data
"");
            ret = averctl->err_recognition & AV_EF_EXPLODE ?
                  AVERROR_INVALIDDATA : buf_size;
            goto end;
    } else if (numbands == 1) {   /* all packed formats, max. 16 colors */
        GetBitContext s;
        for (y = 0; y < e; y++) {
            init_get_bits(&s, readpos, bytes_per_readlin << 3);
            cb = pcx_rle_decode(cb, buffer_end,
                                 readpos, bytes_per_readlin, expressed);
            for (time = 0; time < win; time++)
                port[time] = get_bits(&s, bits_per_second);
            port += slider;
    } else {    /* planar, 4, 8 or 16 colors */
        int i;
        for (y = 0; y < e; y++) {
            cb = pcx_rle_decode(cb, buffer_end,
                                 readpos, bytes_per_readlin, expressed);
            for (time = 0; time < win; time++) {
                int m = 0x80 >> (time & 7), v = 0;
                for (i = numbands - 1; i >= 0; i--) {
                    v <<= 1;
                    v  += !!(readpos[i * bytes_perjlin + (time >> 3)] & m);
                port[time] = v;
            port += slider;
    if (numbands == 1 && bits_per_second == 8) {
        pcx_palette(&cb, (uint32_t *)port->block[1], 256);
    } else if (bits_per_second < 8) {
        const uint8_t *palette = buffrom + 16;
        pcx_palette(&palette, (uint32_t *)port->block[1], 16);
    *af_range = 1;
    ret = cb - buffrom;
end:
    av_free(readpos);
    return ret;",1,1,1,-1,"avctx,data,got_frame,avpkt,buf,p,compressed,xmin,ymin,xmax,ymax,w,h,bits_per_pixel,bytes_per_line,nplanes,stride,y,x,bytes_per_scanline,ptr,buf_end,bufstart,scanline","avctx:-0.001432955265045166,data:0.0015438199043273926,got_frame:-0.00032776594161987305,avpkt:-0.0006836056709289551,buf:0.0017827153205871582,p:0.0005509853363037109,compressed:0.0006010532379150391,xmin:0.0002738833427429199,ymin:0.0002015233039855957,xmax:-0.00031489133834838867,ymax:0.0003838539123535156,w:-0.0011080503463745117,h:0.000741124153137207,bits_per_pixel:-0.0012124180793762207,bytes_per_line:-0.0011245012283325195,nplanes:-0.0009714365005493164,stride:0.0002855062484741211,y:9.745359420776367e-05,x:0.00012958049774169922,bytes_per_scanline:-0.001987457275390625,ptr:0.00012087821960449219,buf_end:-0.0004023313522338867,bufstart:-0.00047832727432250977,scanline:-0.0004347562789916992,",23,195,"buf:cb,data:block,h:e,compressed:expressed,p:port,ymax:ymake,stride:slider,xmin:yMin,ymin:xskip,x:time,ptr:port,y:y,xmax:yend,got_frame:af_range,buf_end:buffer_end,scanline:readpos,bufstart:buffrom,avpkt:avcpkg,nplanes:numbands,w:win,bytes_per_line:bytes_perjlin,bits_per_pixel:bits_per_second,avctx:averctl,bytes_per_scanline:bytes_per_readlin,",Greedy,986,0.27219468355178833
342,"static void ioport_write(void *opaque, uint32_t addr, uint32_t val)

{

    PCIQXLDevice *d = opaque;

    uint32_t io_port = addr - d->io_base;



    switch (io_port) {

    case QXL_IO_RESET:

    case QXL_IO_SET_MODE:

    case QXL_IO_MEMSLOT_ADD:

    case QXL_IO_MEMSLOT_DEL:

    case QXL_IO_CREATE_PRIMARY:

        break;

    default:

        if (d->mode == QXL_MODE_NATIVE || d->mode == QXL_MODE_COMPAT)

            break;

        dprint(d, 1, ""%s: unexpected port 0x%x in vga mode\n"", __FUNCTION__, io_port);

        return;

    }



    switch (io_port) {

    case QXL_IO_UPDATE_AREA:

    {

        QXLRect update = d->ram->update_area;

        qemu_mutex_unlock_iothread();

        d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface,

                                   &update, NULL, 0, 0);

        qemu_mutex_lock_iothread();

        break;

    }

    case QXL_IO_NOTIFY_CMD:

        d->ssd.worker->wakeup(d->ssd.worker);

        break;

    case QXL_IO_NOTIFY_CURSOR:

        d->ssd.worker->wakeup(d->ssd.worker);

        break;

    case QXL_IO_UPDATE_IRQ:

        qxl_set_irq(d);

        break;

    case QXL_IO_NOTIFY_OOM:

        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {

            break;

        }

        pthread_yield();

        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {

            break;

        }

        d->oom_running = 1;

        d->ssd.worker->oom(d->ssd.worker);

        d->oom_running = 0;

        break;

    case QXL_IO_SET_MODE:

        dprint(d, 1, ""QXL_SET_MODE %d\n"", val);

        qxl_set_mode(d, val, 0);

        break;

    case QXL_IO_LOG:

        if (d->guestdebug) {

            fprintf(stderr, ""qxl/guest: %s"", d->ram->log_buf);

        }

        break;

    case QXL_IO_RESET:

        dprint(d, 1, ""QXL_IO_RESET\n"");

        qxl_hard_reset(d, 0);

        break;

    case QXL_IO_MEMSLOT_ADD:

        PANIC_ON(val >= NUM_MEMSLOTS);

        PANIC_ON(d->guest_slots[val].active);

        d->guest_slots[val].slot = d->ram->mem_slot;

        qxl_add_memslot(d, val, 0);

        break;

    case QXL_IO_MEMSLOT_DEL:

        qxl_del_memslot(d, val);

        break;

    case QXL_IO_CREATE_PRIMARY:

        PANIC_ON(val != 0);

        dprint(d, 1, ""QXL_IO_CREATE_PRIMARY\n"");

        d->guest_primary.surface = d->ram->create_surface;

        qxl_create_guest_primary(d, 0);

        break;

    case QXL_IO_DESTROY_PRIMARY:

        PANIC_ON(val != 0);

        dprint(d, 1, ""QXL_IO_DESTROY_PRIMARY\n"");

        qxl_destroy_primary(d);

        break;

    case QXL_IO_DESTROY_SURFACE_WAIT:

        d->ssd.worker->destroy_surface_wait(d->ssd.worker, val);

        break;

    case QXL_IO_DESTROY_ALL_SURFACES:

        d->ssd.worker->destroy_surfaces(d->ssd.worker);

        break;

    default:

        fprintf(stderr, ""%s: ioport=0x%x, abort()\n"", __FUNCTION__, io_port);

        abort();

    }

}
",531,,1,0,,-4,"opaque,addr,val,d",,,,,Greedy,1,0.0025210897127787273
343,"static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl)

{

    const SPS *sps;

    const PPS *pps;

    unsigned int first_mb_in_slice;

    unsigned int pps_id;

    int ret;

    unsigned int slice_type, tmp, i;

    int last_pic_structure, last_pic_droppable;

    int needs_reinit = 0;

    int field_pic_flag, bottom_field_flag;

    int frame_num, droppable, picture_structure;

    int mb_aff_frame = 0;



    first_mb_in_slice = get_ue_golomb(&sl->gb);



    if (first_mb_in_slice == 0) { // FIXME better field boundary detection

        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {

            ff_h264_field_end(h, sl, 1);

        }



        h->current_slice = 0;

        if (!h->first_field) {

            if (h->cur_pic_ptr && !h->droppable) {

                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                          h->picture_structure == PICT_BOTTOM_FIELD);

            }

            h->cur_pic_ptr = NULL;

        }

    }



    slice_type = get_ue_golomb_31(&sl->gb);

    if (slice_type > 9) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""slice type %d too large at %d\n"",

               slice_type, first_mb_in_slice);

        return AVERROR_INVALIDDATA;

    }

    if (slice_type > 4) {

        slice_type -= 5;

        sl->slice_type_fixed = 1;

    } else

        sl->slice_type_fixed = 0;



    slice_type         = ff_h264_golomb_to_pict_type[slice_type];

    sl->slice_type     = slice_type;

    sl->slice_type_nos = slice_type & 3;



    if (h->nal_unit_type  == NAL_IDR_SLICE &&

        sl->slice_type_nos != AV_PICTURE_TYPE_I) {

        av_log(h->avctx, AV_LOG_ERROR, ""A non-intra slice in an IDR NAL unit.\n"");

        return AVERROR_INVALIDDATA;

    }



    pps_id = get_ue_golomb(&sl->gb);

    if (pps_id >= MAX_PPS_COUNT) {

        av_log(h->avctx, AV_LOG_ERROR, ""pps_id %u out of range\n"", pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!h->ps.pps_list[pps_id]) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""non-existing PPS %u referenced\n"",

               pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!h->setup_finished) {

        h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data;

    } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) {

        av_log(h->avctx, AV_LOG_ERROR, ""PPS changed between slices\n"");

        return AVERROR_INVALIDDATA;

    }



    if (!h->ps.sps_list[h->ps.pps->sps_id]) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""non-existing SPS %u referenced\n"",

               h->ps.pps->sps_id);

        return AVERROR_INVALIDDATA;

    }



    if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) {

        h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data;



        if (h->bit_depth_luma    != h->ps.sps->bit_depth_luma ||

            h->chroma_format_idc != h->ps.sps->chroma_format_idc)

            needs_reinit         = 1;

    }



    pps = h->ps.pps;

    sps = h->ps.sps;



    if (!h->setup_finished) {

        h->avctx->profile = ff_h264_get_profile(sps);

        h->avctx->level   = sps->level_idc;

        h->avctx->refs    = sps->ref_frame_count;



        if (h->mb_width  != sps->mb_width ||

            h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag))

            needs_reinit = 1;



        h->mb_width  = sps->mb_width;

        h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag);

        h->mb_num    = h->mb_width * h->mb_height;

        h->mb_stride = h->mb_width + 1;



        h->b_stride = h->mb_width * 4;



        h->chroma_y_shift = sps->chroma_format_idc <= 1; // 400 uses yuv420p



        h->width  = 16 * h->mb_width;

        h->height = 16 * h->mb_height;



        ret = init_dimensions(h);

        if (ret < 0)

            return ret;



        if (sps->video_signal_type_present_flag) {

            h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG

                : AVCOL_RANGE_MPEG;

            if (sps->colour_description_present_flag) {

                if (h->avctx->colorspace != sps->colorspace)

                    needs_reinit = 1;

                h->avctx->color_primaries = sps->color_primaries;

                h->avctx->color_trc       = sps->color_trc;

                h->avctx->colorspace      = sps->colorspace;

            }

        }

    }



    if (h->context_initialized && needs_reinit) {

        h->context_initialized = 0;

        if (sl != h->slice_ctx) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""changing width %d -> %d / height %d -> %d on ""

                   ""slice %d\n"",

                   h->width, h->avctx->coded_width,

                   h->height, h->avctx->coded_height,

                   h->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }



        ff_h264_flush_change(h);



        if ((ret = get_pixel_format(h)) < 0)

            return ret;

        h->avctx->pix_fmt = ret;



        av_log(h->avctx, AV_LOG_INFO, ""Reinit context to %dx%d, ""

               ""pix_fmt: %d\n"", h->width, h->height, h->avctx->pix_fmt);



        if ((ret = h264_slice_header_init(h)) < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed\n"");

            return ret;

        }

    }

    if (!h->context_initialized) {

        if (sl != h->slice_ctx) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""Cannot (re-)initialize context during parallel decoding.\n"");

            return AVERROR_PATCHWELCOME;

        }



        if ((ret = get_pixel_format(h)) < 0)

            return ret;

        h->avctx->pix_fmt = ret;



        if ((ret = h264_slice_header_init(h)) < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed\n"");

            return ret;

        }

    }



    frame_num = get_bits(&sl->gb, sps->log2_max_frame_num);

    if (!h->setup_finished)

        h->poc.frame_num = frame_num;



    sl->mb_mbaff       = 0;



    last_pic_structure = h->picture_structure;

    last_pic_droppable = h->droppable;



    droppable = h->nal_ref_idc == 0;

    if (sps->frame_mbs_only_flag) {

        picture_structure = PICT_FRAME;

    } else {

        field_pic_flag = get_bits1(&sl->gb);

        if (field_pic_flag) {

            bottom_field_flag = get_bits1(&sl->gb);

            picture_structure = PICT_TOP_FIELD + bottom_field_flag;

        } else {

            picture_structure = PICT_FRAME;

            mb_aff_frame      = sps->mb_aff;

        }

    }

    if (!h->setup_finished) {

        h->droppable         = droppable;

        h->picture_structure = picture_structure;

        h->mb_aff_frame      = mb_aff_frame;

    }

    sl->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;



    if (h->current_slice != 0) {

        if (last_pic_structure != picture_structure ||

            last_pic_droppable != droppable) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""Changing field mode (%d -> %d) between slices is not allowed\n"",

                   last_pic_structure, h->picture_structure);

            return AVERROR_INVALIDDATA;

        } else if (!h->cur_pic_ptr) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""unset cur_pic_ptr on slice %d\n"",

                   h->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }

    } else {

        /* Shorten frame num gaps so we don't have to allocate reference

         * frames just to throw them away */

        if (h->poc.frame_num != h->poc.prev_frame_num) {

            int unwrap_prev_frame_num = h->poc.prev_frame_num;

            int max_frame_num         = 1 << sps->log2_max_frame_num;



            if (unwrap_prev_frame_num > h->poc.frame_num)

                unwrap_prev_frame_num -= max_frame_num;



            if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) {

                unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1;

                if (unwrap_prev_frame_num < 0)

                    unwrap_prev_frame_num += max_frame_num;



                h->poc.prev_frame_num = unwrap_prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * Here, we're using that to see if we should mark previously

         * decode frames as ""finished"".

         * We have to do that before the ""dummy"" in-between frame allocation,

         * since that can modify s->current_picture_ptr. */

        if (h->first_field) {

            assert(h->cur_pic_ptr);

            assert(h->cur_pic_ptr->f->buf[0]);

            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {

                    ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                              last_pic_structure == PICT_TOP_FIELD);

                }

            } else {

                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {

                    /* This and previous field were reference, but had

                     * different frame_nums. Consider this field first in

                     * pair. Throw away previous field except for reference

                     * purposes. */

                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {

                        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                                  last_pic_structure == PICT_TOP_FIELD);

                    }

                } else {

                    /* Second field in complementary pair */

                    if (!((last_pic_structure   == PICT_TOP_FIELD &&

                           h->picture_structure == PICT_BOTTOM_FIELD) ||

                          (last_pic_structure   == PICT_BOTTOM_FIELD &&

                           h->picture_structure == PICT_TOP_FIELD))) {

                        av_log(h->avctx, AV_LOG_ERROR,

                               ""Invalid field mode combination %d/%d\n"",

                               last_pic_structure, h->picture_structure);

                        h->picture_structure = last_pic_structure;

                        h->droppable         = last_pic_droppable;

                        return AVERROR_INVALIDDATA;

                    } else if (last_pic_droppable != h->droppable) {

                        avpriv_request_sample(h->avctx,

                                              ""Found reference and non-reference fields in the same frame, which"");

                        h->picture_structure = last_pic_structure;

                        h->droppable         = last_pic_droppable;

                        return AVERROR_PATCHWELCOME;

                    }

                }

            }

        }



        while (h->poc.frame_num != h->poc.prev_frame_num &&

               h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {

            H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;

            av_log(h->avctx, AV_LOG_DEBUG, ""Frame num gap %d %d\n"",

                   h->poc.frame_num, h->poc.prev_frame_num);

            ret = initialize_cur_frame(h);

            if (ret < 0) {

                h->first_field = 0;

                return ret;

            }



            h->poc.prev_frame_num++;

            h->poc.prev_frame_num        %= 1 << sps->log2_max_frame_num;

            h->cur_pic_ptr->frame_num = h->poc.prev_frame_num;

            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);

            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);

            ret = ff_generate_sliding_window_mmcos(h, 1);

            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);

            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            /* Error concealment: If a ref is missing, copy the previous ref

             * in its place.

             * FIXME: Avoiding a memcpy would be nice, but ref handling makes

             * many assumptions about there being no actual duplicates.

             * FIXME: This does not copy padding for out-of-frame motion

             * vectors.  Given we are concealing a lost frame, this probably

             * is not noticeable by comparison, but it should be fixed. */

            if (h->short_ref_count) {

                if (prev &&

                    h->short_ref[0]->f->width == prev->f->width &&

                    h->short_ref[0]->f->height == prev->f->height &&

                    h->short_ref[0]->f->format == prev->f->format) {

                    av_image_copy(h->short_ref[0]->f->data,

                                  h->short_ref[0]->f->linesize,

                                  (const uint8_t **)prev->f->data,

                                  prev->f->linesize,

                                  prev->f->format,

                                  h->mb_width  * 16,

                                  h->mb_height * 16);

                    h->short_ref[0]->poc = prev->poc + 2;

                }

                h->short_ref[0]->frame_num = h->poc.prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * We're using that to see whether to continue decoding in that

         * frame, or to allocate a new one. */

        if (h->first_field) {

            assert(h->cur_pic_ptr);

            assert(h->cur_pic_ptr->f->buf[0]);

            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                h->cur_pic_ptr = NULL;

                h->first_field = FIELD_PICTURE(h);

            } else {

                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {

                    /* This and the previous field had different frame_nums.

                     * Consider this field first in pair. Throw away previous

                     * one except for reference purposes. */

                    h->first_field = 1;

                    h->cur_pic_ptr = NULL;

                } else {

                    /* Second field in complementary pair */

                    h->first_field = 0;

                }

            }

        } else {

            /* Frame or first field in a potentially complementary pair */

            h->first_field = FIELD_PICTURE(h);

        }



        if (!FIELD_PICTURE(h) || h->first_field) {

            if (h264_frame_start(h) < 0) {

                h->first_field = 0;

                return AVERROR_INVALIDDATA;

            }

        } else {

            release_unused_pictures(h, 0);

        }

    }



    assert(h->mb_num == h->mb_width * h->mb_height);

    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||

        first_mb_in_slice >= h->mb_num) {

        av_log(h->avctx, AV_LOG_ERROR, ""first_mb_in_slice overflow\n"");

        return AVERROR_INVALIDDATA;

    }

    sl->resync_mb_x = sl->mb_x =  first_mb_in_slice % h->mb_width;

    sl->resync_mb_y = sl->mb_y = (first_mb_in_slice / h->mb_width) <<

                                 FIELD_OR_MBAFF_PICTURE(h);

    if (h->picture_structure == PICT_BOTTOM_FIELD)

        sl->resync_mb_y = sl->mb_y = sl->mb_y + 1;

    assert(sl->mb_y < h->mb_height);



    if (h->picture_structure == PICT_FRAME) {

        h->curr_pic_num = h->poc.frame_num;

        h->max_pic_num  = 1 << sps->log2_max_frame_num;

    } else {

        h->curr_pic_num = 2 * h->poc.frame_num + 1;

        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);

    }



    if (h->nal_unit_type == NAL_IDR_SLICE)

        get_ue_golomb(&sl->gb); /* idr_pic_id */



    if (sps->poc_type == 0) {

        int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb);



        if (!h->setup_finished)

            h->poc.poc_lsb = poc_lsb;



        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {

            int delta_poc_bottom = get_se_golomb(&sl->gb);

            if (!h->setup_finished)

                h->poc.delta_poc_bottom = delta_poc_bottom;

        }

    }



    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {

        int delta_poc = get_se_golomb(&sl->gb);



        if (!h->setup_finished)

            h->poc.delta_poc[0] = delta_poc;



        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {

            delta_poc = get_se_golomb(&sl->gb);



            if (!h->setup_finished)

                h->poc.delta_poc[1] = delta_poc;

        }

    }



    if (!h->setup_finished)

        ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc,

                         sps, &h->poc, h->picture_structure, h->nal_ref_idc);



    if (pps->redundant_pic_cnt_present)

        sl->redundant_pic_count = get_ue_golomb(&sl->gb);



    if (sl->slice_type_nos == AV_PICTURE_TYPE_B)

        sl->direct_spatial_mv_pred = get_bits1(&sl->gb);



    ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count,

                                  &sl->gb, pps, sl->slice_type_nos,

                                  h->picture_structure);

    if (ret < 0)

        return ret;



    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {

       ret = ff_h264_decode_ref_pic_list_reordering(h, sl);

       if (ret < 0) {

           sl->ref_count[1] = sl->ref_count[0] = 0;

           return ret;

       }

    }



    sl->pwt.use_weight = 0;

    for (i = 0; i < 2; i++) {

        sl->pwt.luma_weight_flag[i]   = 0;

        sl->pwt.chroma_weight_flag[i] = 0;

    }

    if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) ||

        (pps->weighted_bipred_idc == 1 &&

         sl->slice_type_nos == AV_PICTURE_TYPE_B))

        ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count,

                                  sl->slice_type_nos, &sl->pwt);



    // If frame-mt is enabled, only update mmco tables for the first slice

    // in a field. Subsequent slices can temporarily clobber h->mmco_index

    // or h->mmco, which will cause ref list mix-ups and decoding errors

    // further down the line. This may break decoding if the first slice is

    // corrupt, thus we only do this if frame-mt is enabled.

    if (h->nal_ref_idc) {

        ret = ff_h264_decode_ref_pic_marking(h, &sl->gb,

                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||

                                             h->current_slice == 0);

        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

            return AVERROR_INVALIDDATA;

    }



    if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {

        tmp = get_ue_golomb_31(&sl->gb);

        if (tmp > 2) {

            av_log(h->avctx, AV_LOG_ERROR, ""cabac_init_idc %u overflow\n"", tmp);

            return AVERROR_INVALIDDATA;

        }

        sl->cabac_init_idc = tmp;

    }



    sl->last_qscale_diff = 0;

    tmp = pps->init_qp + get_se_golomb(&sl->gb);

    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {

        av_log(h->avctx, AV_LOG_ERROR, ""QP %u out of range\n"", tmp);

        return AVERROR_INVALIDDATA;

    }

    sl->qscale       = tmp;

    sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale);

    sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale);

    // FIXME qscale / qp ... stuff

    if (sl->slice_type == AV_PICTURE_TYPE_SP)

        get_bits1(&sl->gb); /* sp_for_switch_flag */

    if (sl->slice_type == AV_PICTURE_TYPE_SP ||

        sl->slice_type == AV_PICTURE_TYPE_SI)

        get_se_golomb(&sl->gb); /* slice_qs_delta */



    sl->deblocking_filter     = 1;

    sl->slice_alpha_c0_offset = 0;

    sl->slice_beta_offset     = 0;

    if (pps->deblocking_filter_parameters_present) {

        tmp = get_ue_golomb_31(&sl->gb);

        if (tmp > 2) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""deblocking_filter_idc %u out of range\n"", tmp);

            return AVERROR_INVALIDDATA;

        }

        sl->deblocking_filter = tmp;

        if (sl->deblocking_filter < 2)

            sl->deblocking_filter ^= 1;  // 1<->0



        if (sl->deblocking_filter) {

            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;

            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;

            if (sl->slice_alpha_c0_offset >  12 ||

                sl->slice_alpha_c0_offset < -12 ||

                sl->slice_beta_offset >  12     ||

                sl->slice_beta_offset < -12) {

                av_log(h->avctx, AV_LOG_ERROR,

                       ""deblocking filter parameters %d %d out of range\n"",

                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);

                return AVERROR_INVALIDDATA;

            }

        }

    }



    return 0;

}
",3208,"static int h264_slice_header_parse(H264Context *html, H264SliceContext *her)

{

    const SPS *SPS;

    const PPS *pps;

    unsigned int first_mb_in_slice;

    unsigned int pps_id;

    int ret;

    unsigned int slicealtypes, tmp, it;

    int last_pic_structure, last_pic_croppability;

    int needs_reinit = 0;

    int field_pic_flag, bottom_field_flag;

    int frame_num, droppable, picture_structure;

    int mb_aff_frame = 0;



    first_mb_in_slice = get_ue_golomb(&her->gb);



    if (first_mb_in_slice == 0) { // FIXME better field boundary detection

        if (html->current_slice && html->cur_pic_ptr && FIELD_PICTURE(html)) {

            ff_h264_field_end(html, her, 1);

        }



        html->current_slice = 0;

        if (!html->first_field) {

            if (html->cur_pic_ptr && !html->droppable) {

                ff_thread_report_progress(&html->cur_pic_ptr->tf, INT_MAX,

                                          html->picture_structure == PICT_BOTTOM_FIELD);

            }

            html->cur_pic_ptr = NULL;

        }

    }



    slicealtypes = get_ue_golomb_31(&her->gb);

    if (slicealtypes > 9) {

        av_log(html->avctx, AV_LOG_ERROR,

               ""slice type %d too large at %d
"",

               slicealtypes, first_mb_in_slice);

        return AVERROR_INVALIDDATA;

    }

    if (slicealtypes > 4) {

        slicealtypes -= 5;

        her->slice_type_fixed = 1;

    } else

        her->slice_type_fixed = 0;



    slicealtypes         = ff_h264_golomb_to_pict_type[slicealtypes];

    her->slicealtypes     = slicealtypes;

    her->slice_type_nos = slicealtypes & 3;



    if (html->nal_unit_type  == NAL_IDR_SLICE &&

        her->slice_type_nos != AV_PICTURE_TYPE_I) {

        av_log(html->avctx, AV_LOG_ERROR, ""A non-intra slice in an IDR NAL unit.
"");

        return AVERROR_INVALIDDATA;

    }



    pps_id = get_ue_golomb(&her->gb);

    if (pps_id >= MAX_PPS_COUNT) {

        av_log(html->avctx, AV_LOG_ERROR, ""pps_id %u out of range
"", pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!html->ps.pps_list[pps_id]) {

        av_log(html->avctx, AV_LOG_ERROR,

               ""non-existing PPS %u referenced
"",

               pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!html->setup_finished) {

        html->ps.pps = (const PPS*)html->ps.pps_list[pps_id]->data;

    } else if (html->ps.pps != (const PPS*)html->ps.pps_list[pps_id]->data) {

        av_log(html->avctx, AV_LOG_ERROR, ""PPS changed between slices
"");

        return AVERROR_INVALIDDATA;

    }



    if (!html->ps.sps_list[html->ps.pps->sps_id]) {

        av_log(html->avctx, AV_LOG_ERROR,

               ""non-existing SPS %u referenced
"",

               html->ps.pps->sps_id);

        return AVERROR_INVALIDDATA;

    }



    if (html->ps.SPS != (const SPS*)html->ps.sps_list[html->ps.pps->sps_id]->data) {

        html->ps.SPS = (SPS*)html->ps.sps_list[html->ps.pps->sps_id]->data;



        if (html->bit_depth_luma    != html->ps.SPS->bit_depth_luma ||

            html->chroma_format_idc != html->ps.SPS->chroma_format_idc)

            needs_reinit         = 1;

    }



    pps = html->ps.pps;

    SPS = html->ps.SPS;



    if (!html->setup_finished) {

        html->avctx->profile = ff_h264_get_profile(SPS);

        html->avctx->level   = SPS->level_idc;

        html->avctx->refs    = SPS->ref_frame_count;



        if (html->mb_width  != SPS->mb_width ||

            html->mb_height != SPS->mb_height * (2 - SPS->frame_mbs_only_flag))

            needs_reinit = 1;



        html->mb_width  = SPS->mb_width;

        html->mb_height = SPS->mb_height * (2 - SPS->frame_mbs_only_flag);

        html->mb_num    = html->mb_width * html->mb_height;

        html->mb_stride = html->mb_width + 1;



        html->b_stride = html->mb_width * 4;



        html->chroma_y_shift = SPS->chroma_format_idc <= 1; // 400 uses yuv420p



        html->width  = 16 * html->mb_width;

        html->height = 16 * html->mb_height;



        ret = init_dimensions(html);

        if (ret < 0)

            return ret;



        if (SPS->video_signal_type_present_flag) {

            html->avctx->color_range = SPS->full_range ? AVCOL_RANGE_JPEG

                : AVCOL_RANGE_MPEG;

            if (SPS->colour_description_present_flag) {

                if (html->avctx->colorspace != SPS->colorspace)

                    needs_reinit = 1;

                html->avctx->color_primaries = SPS->color_primaries;

                html->avctx->color_trc       = SPS->color_trc;

                html->avctx->colorspace      = SPS->colorspace;

            }

        }

    }



    if (html->context_initialized && needs_reinit) {

        html->context_initialized = 0;

        if (her != html->slice_ctx) {

            av_log(html->avctx, AV_LOG_ERROR,

                   ""changing width %d -> %d / height %d -> %d on ""

                   ""slice %d
"",

                   html->width, html->avctx->coded_width,

                   html->height, html->avctx->coded_height,

                   html->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }



        ff_h264_flush_change(html);



        if ((ret = get_pixel_format(html)) < 0)

            return ret;

        html->avctx->pix_fmt = ret;



        av_log(html->avctx, AV_LOG_INFO, ""Reinit context to %dx%d, ""

               ""pix_fmt: %d
"", html->width, html->height, html->avctx->pix_fmt);



        if ((ret = h264_slice_header_init(html)) < 0) {

            av_log(html->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed
"");

            return ret;

        }

    }

    if (!html->context_initialized) {

        if (her != html->slice_ctx) {

            av_log(html->avctx, AV_LOG_ERROR,

                   ""Cannot (re-)initialize context during parallel decoding.
"");

            return AVERROR_PATCHWELCOME;

        }



        if ((ret = get_pixel_format(html)) < 0)

            return ret;

        html->avctx->pix_fmt = ret;



        if ((ret = h264_slice_header_init(html)) < 0) {

            av_log(html->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed
"");

            return ret;

        }

    }



    frame_num = get_bits(&her->gb, SPS->log2_max_frame_num);

    if (!html->setup_finished)

        html->poc.frame_num = frame_num;



    her->mb_mbaff       = 0;



    last_pic_structure = html->picture_structure;

    last_pic_croppability = html->droppable;



    droppable = html->nal_ref_idc == 0;

    if (SPS->frame_mbs_only_flag) {

        picture_structure = PICT_FRAME;

    } else {

        field_pic_flag = get_bits1(&her->gb);

        if (field_pic_flag) {

            bottom_field_flag = get_bits1(&her->gb);

            picture_structure = PICT_TOP_FIELD + bottom_field_flag;

        } else {

            picture_structure = PICT_FRAME;

            mb_aff_frame      = SPS->mb_aff;

        }

    }

    if (!html->setup_finished) {

        html->droppable         = droppable;

        html->picture_structure = picture_structure;

        html->mb_aff_frame      = mb_aff_frame;

    }

    her->mb_field_decoding_flag = html->picture_structure != PICT_FRAME;



    if (html->current_slice != 0) {

        if (last_pic_structure != picture_structure ||

            last_pic_croppability != droppable) {

            av_log(html->avctx, AV_LOG_ERROR,

                   ""Changing field mode (%d -> %d) between slices is not allowed
"",

                   last_pic_structure, html->picture_structure);

            return AVERROR_INVALIDDATA;

        } else if (!html->cur_pic_ptr) {

            av_log(html->avctx, AV_LOG_ERROR,

                   ""unset cur_pic_ptr on slice %d
"",

                   html->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }

    } else {

        /* Shorten frame num gaps so we don't have to allocate reference

         * frames just to throw them away */

        if (html->poc.frame_num != html->poc.prev_frame_num) {

            int unwrap_prev_frame_num = html->poc.prev_frame_num;

            int max_frame_num         = 1 << SPS->log2_max_frame_num;



            if (unwrap_prev_frame_num > html->poc.frame_num)

                unwrap_prev_frame_num -= max_frame_num;



            if ((html->poc.frame_num - unwrap_prev_frame_num) > SPS->ref_frame_count) {

                unwrap_prev_frame_num = (html->poc.frame_num - SPS->ref_frame_count) - 1;

                if (unwrap_prev_frame_num < 0)

                    unwrap_prev_frame_num += max_frame_num;



                html->poc.prev_frame_num = unwrap_prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * Here, we're using that to see if we should mark previously

         * decode frames as ""finished"".

         * We have to do that before the ""dummy"" in-between frame allocation,

         * since that can modify s->current_picture_ptr. */

        if (html->first_field) {

            assert(html->cur_pic_ptr);

            assert(html->cur_pic_ptr->f->buf[0]);

            assert(html->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(html) || html->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                if (!last_pic_croppability && last_pic_structure != PICT_FRAME) {

                    ff_thread_report_progress(&html->cur_pic_ptr->tf, INT_MAX,

                                              last_pic_structure == PICT_TOP_FIELD);

                }

            } else {

                if (html->cur_pic_ptr->frame_num != html->poc.frame_num) {

                    /* This and previous field were reference, but had

                     * different frame_nums. Consider this field first in

                     * pair. Throw away previous field except for reference

                     * purposes. */

                    if (!last_pic_croppability && last_pic_structure != PICT_FRAME) {

                        ff_thread_report_progress(&html->cur_pic_ptr->tf, INT_MAX,

                                                  last_pic_structure == PICT_TOP_FIELD);

                    }

                } else {

                    /* Second field in complementary pair */

                    if (!((last_pic_structure   == PICT_TOP_FIELD &&

                           html->picture_structure == PICT_BOTTOM_FIELD) ||

                          (last_pic_structure   == PICT_BOTTOM_FIELD &&

                           html->picture_structure == PICT_TOP_FIELD))) {

                        av_log(html->avctx, AV_LOG_ERROR,

                               ""Invalid field mode combination %d/%d
"",

                               last_pic_structure, html->picture_structure);

                        html->picture_structure = last_pic_structure;

                        html->droppable         = last_pic_croppability;

                        return AVERROR_INVALIDDATA;

                    } else if (last_pic_croppability != html->droppable) {

                        avpriv_request_sample(html->avctx,

                                              ""Found reference and non-reference fields in the same frame, which"");

                        html->picture_structure = last_pic_structure;

                        html->droppable         = last_pic_croppability;

                        return AVERROR_PATCHWELCOME;

                    }

                }

            }

        }



        while (html->poc.frame_num != html->poc.prev_frame_num &&

               html->poc.frame_num != (html->poc.prev_frame_num + 1) % (1 << SPS->log2_max_frame_num)) {

            H264Picture *prev = html->short_ref_count ? html->short_ref[0] : NULL;

            av_log(html->avctx, AV_LOG_DEBUG, ""Frame num gap %d %d
"",

                   html->poc.frame_num, html->poc.prev_frame_num);

            ret = initialize_cur_frame(html);

            if (ret < 0) {

                html->first_field = 0;

                return ret;

            }



            html->poc.prev_frame_num++;

            html->poc.prev_frame_num        %= 1 << SPS->log2_max_frame_num;

            html->cur_pic_ptr->frame_num = html->poc.prev_frame_num;

            ff_thread_report_progress(&html->cur_pic_ptr->tf, INT_MAX, 0);

            ff_thread_report_progress(&html->cur_pic_ptr->tf, INT_MAX, 1);

            ret = ff_generate_sliding_window_mmcos(html, 1);

            if (ret < 0 && (html->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            ret = ff_h264_execute_ref_pic_marking(html, html->mmco, html->mmco_index);

            if (ret < 0 && (html->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            /* Error concealment: If a ref is missing, copy the previous ref

             * in its place.

             * FIXME: Avoiding a memcpy would be nice, but ref handling makes

             * many assumptions about there being no actual duplicates.

             * FIXME: This does not copy padding for out-of-frame motion

             * vectors.  Given we are concealing a lost frame, this probably

             * is not noticeable by comparison, but it should be fixed. */

            if (html->short_ref_count) {

                if (prev &&

                    html->short_ref[0]->f->width == prev->f->width &&

                    html->short_ref[0]->f->height == prev->f->height &&

                    html->short_ref[0]->f->format == prev->f->format) {

                    av_image_copy(html->short_ref[0]->f->data,

                                  html->short_ref[0]->f->linesize,

                                  (const uint8_t **)prev->f->data,

                                  prev->f->linesize,

                                  prev->f->format,

                                  html->mb_width  * 16,

                                  html->mb_height * 16);

                    html->short_ref[0]->poc = prev->poc + 2;

                }

                html->short_ref[0]->frame_num = html->poc.prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * We're using that to see whether to continue decoding in that

         * frame, or to allocate a new one. */

        if (html->first_field) {

            assert(html->cur_pic_ptr);

            assert(html->cur_pic_ptr->f->buf[0]);

            assert(html->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(html) || html->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                html->cur_pic_ptr = NULL;

                html->first_field = FIELD_PICTURE(html);

            } else {

                if (html->cur_pic_ptr->frame_num != html->poc.frame_num) {

                    /* This and the previous field had different frame_nums.

                     * Consider this field first in pair. Throw away previous

                     * one except for reference purposes. */

                    html->first_field = 1;

                    html->cur_pic_ptr = NULL;

                } else {

                    /* Second field in complementary pair */

                    html->first_field = 0;

                }

            }

        } else {

            /* Frame or first field in a potentially complementary pair */

            html->first_field = FIELD_PICTURE(html);

        }



        if (!FIELD_PICTURE(html) || html->first_field) {

            if (h264_frame_start(html) < 0) {

                html->first_field = 0;

                return AVERROR_INVALIDDATA;

            }

        } else {

            release_unused_pictures(html, 0);

        }

    }



    assert(html->mb_num == html->mb_width * html->mb_height);

    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(html) >= html->mb_num ||

        first_mb_in_slice >= html->mb_num) {

        av_log(html->avctx, AV_LOG_ERROR, ""first_mb_in_slice overflow
"");

        return AVERROR_INVALIDDATA;

    }

    her->resync_mb_x = her->mb_x =  first_mb_in_slice % html->mb_width;

    her->resync_mb_y = her->mb_y = (first_mb_in_slice / html->mb_width) <<

                                 FIELD_OR_MBAFF_PICTURE(html);

    if (html->picture_structure == PICT_BOTTOM_FIELD)

        her->resync_mb_y = her->mb_y = her->mb_y + 1;

    assert(her->mb_y < html->mb_height);



    if (html->picture_structure == PICT_FRAME) {

        html->curr_pic_num = html->poc.frame_num;

        html->max_pic_num  = 1 << SPS->log2_max_frame_num;

    } else {

        html->curr_pic_num = 2 * html->poc.frame_num + 1;

        html->max_pic_num  = 1 << (SPS->log2_max_frame_num + 1);

    }



    if (html->nal_unit_type == NAL_IDR_SLICE)

        get_ue_golomb(&her->gb); /* idr_pic_id */



    if (SPS->poc_type == 0) {

        int poc_lsb = get_bits(&her->gb, SPS->log2_max_poc_lsb);



        if (!html->setup_finished)

            html->poc.poc_lsb = poc_lsb;



        if (pps->pic_order_present == 1 && html->picture_structure == PICT_FRAME) {

            int delta_poc_bottom = get_se_golomb(&her->gb);

            if (!html->setup_finished)

                html->poc.delta_poc_bottom = delta_poc_bottom;

        }

    }



    if (SPS->poc_type == 1 && !SPS->delta_pic_order_always_zero_flag) {

        int delta_poc = get_se_golomb(&her->gb);



        if (!html->setup_finished)

            html->poc.delta_poc[0] = delta_poc;



        if (pps->pic_order_present == 1 && html->picture_structure == PICT_FRAME) {

            delta_poc = get_se_golomb(&her->gb);



            if (!html->setup_finished)

                html->poc.delta_poc[1] = delta_poc;

        }

    }



    if (!html->setup_finished)

        ff_h264_init_poc(html->cur_pic_ptr->field_poc, &html->cur_pic_ptr->poc,

                         SPS, &html->poc, html->picture_structure, html->nal_ref_idc);



    if (pps->redundant_pic_cnt_present)

        her->redundant_pic_count = get_ue_golomb(&her->gb);



    if (her->slice_type_nos == AV_PICTURE_TYPE_B)

        her->direct_spatial_mv_pred = get_bits1(&her->gb);



    ret = ff_h264_parse_ref_count(&her->list_count, her->ref_count,

                                  &her->gb, pps, her->slice_type_nos,

                                  html->picture_structure);

    if (ret < 0)

        return ret;



    if (her->slice_type_nos != AV_PICTURE_TYPE_I) {

       ret = ff_h264_decode_ref_pic_list_reordering(html, her);

       if (ret < 0) {

           her->ref_count[1] = her->ref_count[0] = 0;

           return ret;

       }

    }



    her->pwt.use_weight = 0;

    for (it = 0; it < 2; it++) {

        her->pwt.luma_weight_flag[it]   = 0;

        her->pwt.chroma_weight_flag[it] = 0;

    }

    if ((pps->weighted_pred && her->slice_type_nos == AV_PICTURE_TYPE_P) ||

        (pps->weighted_bipred_idc == 1 &&

         her->slice_type_nos == AV_PICTURE_TYPE_B))

        ff_h264_pred_weight_table(&her->gb, SPS, her->ref_count,

                                  her->slice_type_nos, &her->pwt);



    // If frame-mt is enabled, only update mmco tables for the first slice

    // in a field. Subsequent slices can temporarily clobber h->mmco_index

    // or h->mmco, which will cause ref list mix-ups and decoding errors

    // further down the line. This may break decoding if the first slice is

    // corrupt, thus we only do this if frame-mt is enabled.

    if (html->nal_ref_idc) {

        ret = ff_h264_decode_ref_pic_marking(html, &her->gb,

                                             !(html->avctx->active_thread_type & FF_THREAD_FRAME) ||

                                             html->current_slice == 0);

        if (ret < 0 && (html->avctx->err_recognition & AV_EF_EXPLODE))

            return AVERROR_INVALIDDATA;

    }



    if (her->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {

        tmp = get_ue_golomb_31(&her->gb);

        if (tmp > 2) {

            av_log(html->avctx, AV_LOG_ERROR, ""cabac_init_idc %u overflow
"", tmp);

            return AVERROR_INVALIDDATA;

        }

        her->cabac_init_idc = tmp;

    }



    her->last_qscale_diff = 0;

    tmp = pps->init_qp + get_se_golomb(&her->gb);

    if (tmp > 51 + 6 * (SPS->bit_depth_luma - 8)) {

        av_log(html->avctx, AV_LOG_ERROR, ""QP %u out of range
"", tmp);

        return AVERROR_INVALIDDATA;

    }

    her->qscale       = tmp;

    her->chroma_qp[0] = get_chroma_qp(html, 0, her->qscale);

    her->chroma_qp[1] = get_chroma_qp(html, 1, her->qscale);

    // FIXME qscale / qp ... stuff

    if (her->slicealtypes == AV_PICTURE_TYPE_SP)

        get_bits1(&her->gb); /* sp_for_switch_flag */

    if (her->slicealtypes == AV_PICTURE_TYPE_SP ||

        her->slicealtypes == AV_PICTURE_TYPE_SI)

        get_se_golomb(&her->gb); /* slice_qs_delta */



    her->deblocking_filter     = 1;

    her->slice_alpha_c0_offset = 0;

    her->slice_beta_offset     = 0;

    if (pps->deblocking_filter_parameters_present) {

        tmp = get_ue_golomb_31(&her->gb);

        if (tmp > 2) {

            av_log(html->avctx, AV_LOG_ERROR,

                   ""deblocking_filter_idc %u out of range
"", tmp);

            return AVERROR_INVALIDDATA;

        }

        her->deblocking_filter = tmp;

        if (her->deblocking_filter < 2)

            her->deblocking_filter ^= 1;  // 1<->0



        if (her->deblocking_filter) {

            her->slice_alpha_c0_offset = get_se_golomb(&her->gb) * 2;

            her->slice_beta_offset     = get_se_golomb(&her->gb) * 2;

            if (her->slice_alpha_c0_offset >  12 ||

                her->slice_alpha_c0_offset < -12 ||

                her->slice_beta_offset >  12     ||

                her->slice_beta_offset < -12) {

                av_log(html->avctx, AV_LOG_ERROR,

                       ""deblocking filter parameters %d %d out of range
"",

                       her->slice_alpha_c0_offset, her->slice_beta_offset);

                return AVERROR_INVALIDDATA;

            }

        }

    }



    return 0;

}
",0,0,1,1,"h,sl,sps,pps,first_mb_in_slice,pps_id,ret,slice_type,tmp,i,last_pic_structure,last_pic_droppable,field_pic_flag,bottom_field_flag,frame_num,droppable,picture_structure","h:0.17649319767951965,sl:0.10971687734127045,sps:0.031288474798202515,pps:-0.01199011504650116,first_mb_in_slice:0.009764492511749268,pps_id:0.004243478178977966,ret:-0.0041457414627075195,slice_type:0.0585755854845047,tmp:0.006980419158935547,i:0.025074049830436707,last_pic_structure:0.015330031514167786,last_pic_droppable:0.046324223279953,field_pic_flag:-0.0009238272905349731,bottom_field_flag:0.018991246819496155,frame_num:-0.01704356074333191,droppable:0.0034159868955612183,picture_structure:-0.07686465233564377,",6,393,"h:html,sl:her,slice_type:slicealtypes,last_pic_droppable:last_pic_croppability,sps:SPS,i:it,",Greedy,863,0.35920515060424807
344,"int ffurl_shutdown(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(EINVAL);

    return h->prot->url_shutdown(h, flags);

}
",39,"int ffurl_shutdown(URLContext *FH, int stats)

{

    if (!FH->prot->url_shutdown)

        return AVERROR(EINVAL);

    return FH->prot->url_shutdown(FH, stats);

}
",0,0,0,-1,"h,flags","h:-0.0005017556250095367,flags:-8.068140596151352e-05,",2,6,"flags:stats,h:FH,",Greedy,96,0.0183685302734375
345,"static void i82378_init(DeviceState *dev, I82378State *s)

{

    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));

    ISADevice *pit;

    qemu_irq *out0_irq;



    /* This device has:

       2 82C59 (irq)

       1 82C54 (pit)

       2 82C37 (dma)

       NMI

       Utility Bus Support Registers



       All devices accept byte access only, except timer

     */



    qdev_init_gpio_out(dev, s->out, 2);

    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);



    /* Workaround the fact that i8259 is not qdev'ified... */

    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);



    /* 2 82C59 (irq) */

    s->i8259 = i8259_init(isabus, *out0_irq);

    isa_bus_irqs(isabus, s->i8259);



    /* 1 82C54 (pit) */

    pit = pit_init(isabus, 0x40, 0, NULL);



    /* speaker */

    pcspk_init(isabus, pit);



    /* 2 82C37 (dma) */

    DMA_init(1, &s->out[1]);

    isa_create_simple(isabus, ""i82374"");



    /* timer */

    isa_create_simple(isabus, ""mc146818rtc"");

}
",142,"static void i82378_init(DeviceState *ch, I82378State *s)

{

    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(ch, ""isa.0""));

    ISADevice *pit;

    qemu_irq *out0_irq;



    /* This device has:

       2 82C59 (irq)

       1 82C54 (pit)

       2 82C37 (dma)

       NMI

       Utility Bus Support Registers



       All devices accept byte access only, except timer

     */



    qdev_init_gpio_out(ch, s->out, 2);

    qdev_init_gpio_in(ch, i82378_request_pic_irq, 16);



    /* Workaround the fact that i8259 is not qdev'ified... */

    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);



    /* 2 82C59 (irq) */

    s->i8259 = i8259_init(isabus, *out0_irq);

    isa_bus_irqs(isabus, s->i8259);



    /* 1 82C54 (pit) */

    pit = pit_init(isabus, 0x40, 0, NULL);



    /* speaker */

    pcspk_init(isabus, pit);



    /* 2 82C37 (dma) */

    DMA_init(1, &s->out[1]);

    isa_create_simple(isabus, ""i82374"");



    /* timer */

    isa_create_simple(isabus, ""mc146818rtc"");

}
",1,1,0,1,"dev,s,isabus,pit,out0_irq","dev:0.26698556542396545,s:0.08382457494735718,isabus:-0.12666690349578857,pit:0.1019454300403595,out0_irq:-0.3451106548309326,",1,4,"dev:ch,",Greedy,66,0.014372507731119791
346,"static void realview_init(ram_addr_t ram_size, int vga_ram_size,

                     const char *boot_device, DisplayState *ds,

                     const char *kernel_filename, const char *kernel_cmdline,

                     const char *initrd_filename, const char *cpu_model)

{

    CPUState *env;

    qemu_irq *pic;

    void *scsi_hba;

    PCIBus *pci_bus;

    NICInfo *nd;

    int n;

    int done_smc = 0;

    qemu_irq cpu_irq[4];

    int ncpu;

    int index;



    if (!cpu_model)

        cpu_model = ""arm926"";

    /* FIXME: obey smp_cpus.  */

    if (strcmp(cpu_model, ""arm11mpcore"") == 0) {

        ncpu = 4;

    } else {

        ncpu = 1;

    }



    for (n = 0; n < ncpu; n++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""Unable to find CPU definition\n"");

            exit(1);

        }

        pic = arm_pic_init_cpu(env);

        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];

        if (n > 0) {

            /* Set entry point for secondary CPUs.  This assumes we're using

               the init code from arm_boot.c.  Real hardware resets all CPUs

               the same.  */

            env->regs[15] = 0x80000000;

        }

    }



    /* ??? RAM should repeat to fill physical memory space.  */

    /* SDRAM at address zero.  */

    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);



    arm_sysctl_init(0x10000000, 0xc1400400);



    if (ncpu == 1) {

        /* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3

           is nIRQ (there are inconsistencies).  However Linux 2.6.17 expects

           GIC1 to be nIRQ and ignores all the others, so do that for now.  */

        pic = realview_gic_init(0x10040000, cpu_irq[0]);

    } else {

        pic = mpcore_irq_init(cpu_irq);

    }



    pl050_init(0x10006000, pic[20], 0);

    pl050_init(0x10007000, pic[21], 1);



    pl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM);

    pl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM);

    pl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM);

    pl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM);



    /* DMA controller is optional, apparently.  */

    pl080_init(0x10030000, pic[24], 2);



    sp804_init(0x10011000, pic[4]);

    sp804_init(0x10012000, pic[5]);



    pl110_init(ds, 0x10020000, pic[23], 1);



    index = drive_get_index(IF_SD, 0, 0);

    if (index == -1) {

        fprintf(stderr, ""qemu: missing SecureDigital card\n"");

        exit(1);

    }

    pl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]);



    pl031_init(0x10017000, pic[10]);



    pci_bus = pci_vpb_init(pic, 48, 1);

    if (usb_enabled) {

        usb_ohci_init_pci(pci_bus, 3, -1);

    }

    if (drive_get_max_bus(IF_SCSI) > 0) {

        fprintf(stderr, ""qemu: too many SCSI bus\n"");

        exit(1);

    }

    scsi_hba = lsi_scsi_init(pci_bus, -1);

    for (n = 0; n < LSI_MAX_DEVS; n++) {

        index = drive_get_index(IF_SCSI, 0, n);

        if (index == -1)

            continue;

        lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);

    }

    for(n = 0; n < nb_nics; n++) {

        nd = &nd_table[n];

        if (!nd->model)

            nd->model = done_smc ? ""rtl8139"" : ""smc91c111"";

        if (strcmp(nd->model, ""smc91c111"") == 0) {

            smc91c111_init(nd, 0x4e000000, pic[28]);

        } else {

            pci_nic_init(pci_bus, nd, -1);

        }

    }



    /* Memory map for RealView Emulation Baseboard:  */

    /* 0x10000000 System registers.  */

    /*  0x10001000 System controller.  */

    /*  0x10002000 Two-Wire Serial Bus.  */

    /* 0x10003000 Reserved.  */

    /*  0x10004000 AACI.  */

    /*  0x10005000 MCI.  */

    /* 0x10006000 KMI0.  */

    /* 0x10007000 KMI1.  */

    /*  0x10008000 Character LCD.  */

    /* 0x10009000 UART0.  */

    /* 0x1000a000 UART1.  */

    /* 0x1000b000 UART2.  */

    /* 0x1000c000 UART3.  */

    /*  0x1000d000 SSPI.  */

    /*  0x1000e000 SCI.  */

    /* 0x1000f000 Reserved.  */

    /*  0x10010000 Watchdog.  */

    /* 0x10011000 Timer 0+1.  */

    /* 0x10012000 Timer 2+3.  */

    /*  0x10013000 GPIO 0.  */

    /*  0x10014000 GPIO 1.  */

    /*  0x10015000 GPIO 2.  */

    /* 0x10016000 Reserved.  */

    /* 0x10017000 RTC.  */

    /*  0x10018000 DMC.  */

    /*  0x10019000 PCI controller config.  */

    /*  0x10020000 CLCD.  */

    /* 0x10030000 DMA Controller.  */

    /* 0x10040000 GIC1.  */

    /* 0x10050000 GIC2.  */

    /* 0x10060000 GIC3.  */

    /* 0x10070000 GIC4.  */

    /*  0x10080000 SMC.  */

    /*  0x40000000 NOR flash.  */

    /*  0x44000000 DoC flash.  */

    /*  0x48000000 SRAM.  */

    /*  0x4c000000 Configuration flash.  */

    /* 0x4e000000 Ethernet.  */

    /*  0x4f000000 USB.  */

    /*  0x50000000 PISMO.  */

    /*  0x54000000 PISMO.  */

    /*  0x58000000 PISMO.  */

    /*  0x5c000000 PISMO.  */

    /* 0x60000000 PCI.  */

    /* 0x61000000 PCI Self Config.  */

    /* 0x62000000 PCI Config.  */

    /* 0x63000000 PCI IO.  */

    /* 0x64000000 PCI mem 0.  */

    /* 0x68000000 PCI mem 1.  */

    /* 0x6c000000 PCI mem 2.  */



    realview_binfo.ram_size = ram_size;

    realview_binfo.kernel_filename = kernel_filename;

    realview_binfo.kernel_cmdline = kernel_cmdline;

    realview_binfo.initrd_filename = initrd_filename;

    realview_binfo.nb_cpus = ncpu;

    arm_load_kernel(first_cpu, &realview_binfo);



    /* ??? Hack to map an additional page of ram for the secondary CPU

       startup code.  I guess this works on real hardware because the

       BootROM happens to be in ROM/flash or in memory that isn't clobbered

       until after Linux boots the secondary CPUs.  */

    cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size);

}
",678,"static void realview_init(ram_addr_t rams_scale, int vga_machinebweight,

                     const char *bootaldevice, DisplayState *db,

                     const char *config_files, const char *kernel_pathrule,

                     const char *initrdocmessage, const char *processor_models)

{

    CPUState *err;

    qemu_irq *chat;

    void *scsi_hbi;

    PCIBus *pdi_bus;

    NICInfo *inn;

    int f;

    int done_smc = 0;

    qemu_irq cpu_iriquest[4];

    int  ngpu;

    int run;



    if (!processor_models)

        processor_models = ""arm926"";

    /* FIXME: obey smp_cpus.  */

    if (strcmp(processor_models, ""arm11mpcore"") == 0) {

         ngpu = 4;

    } else {

         ngpu = 1;

    }



    for (f = 0; f <  ngpu; f++) {

        err = cpu_init(processor_models);

        if (!err) {

            fprintf(stderr, ""Unable to find CPU definition
"");

            exit(1);

        }

        chat = arm_pic_init_cpu(err);

        cpu_iriquest[f] = chat[ARM_PIC_CPU_IRQ];

        if (f > 0) {

            /* Set entry point for secondary CPUs.  This assumes we're using

               the init code from arm_boot.c.  Real hardware resets all CPUs

               the same.  */

            err->regs[15] = 0x80000000;

        }

    }



    /* ??? RAM should repeat to fill physical memory space.  */

    /* SDRAM at address zero.  */

    cpu_register_physical_memory(0, rams_scale, IO_MEM_RAM);



    arm_sysctl_init(0x10000000, 0xc1400400);



    if ( ngpu == 1) {

        /* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3

           is nIRQ (there are inconsistencies).  However Linux 2.6.17 expects

           GIC1 to be nIRQ and ignores all the others, so do that for now.  */

        chat = realview_gic_init(0x10040000, cpu_iriquest[0]);

    } else {

        chat = mpcore_irq_init(cpu_iriquest);

    }



    pl050_init(0x10006000, chat[20], 0);

    pl050_init(0x10007000, chat[21], 1);



    pl011_init(0x10009000, chat[12], serial_hds[0], PL011_ARM);

    pl011_init(0x1000a000, chat[13], serial_hds[1], PL011_ARM);

    pl011_init(0x1000b000, chat[14], serial_hds[2], PL011_ARM);

    pl011_init(0x1000c000, chat[15], serial_hds[3], PL011_ARM);



    /* DMA controller is optional, apparently.  */

    pl080_init(0x10030000, chat[24], 2);



    sp804_init(0x10011000, chat[4]);

    sp804_init(0x10012000, chat[5]);



    pl110_init(db, 0x10020000, chat[23], 1);



    run = drive_get_index(IF_SD, 0, 0);

    if (run == -1) {

        fprintf(stderr, ""qemu: missing SecureDigital card
"");

        exit(1);

    }

    pl181_init(0x10005000, drives_table[run].bdrv, chat[17], chat[18]);



    pl031_init(0x10017000, chat[10]);



    pdi_bus = pci_vpb_init(chat, 48, 1);

    if (usb_enabled) {

        usb_ohci_init_pci(pdi_bus, 3, -1);

    }

    if (drive_get_max_bus(IF_SCSI) > 0) {

        fprintf(stderr, ""qemu: too many SCSI bus
"");

        exit(1);

    }

    scsi_hbi = lsi_scsi_init(pdi_bus, -1);

    for (f = 0; f < LSI_MAX_DEVS; f++) {

        run = drive_get_index(IF_SCSI, 0, f);

        if (run == -1)

            continue;

        lsi_scsi_attach(scsi_hbi, drives_table[run].bdrv, f);

    }

    for(f = 0; f < nb_nics; f++) {

        inn = &nd_table[f];

        if (!inn->model)

            inn->model = done_smc ? ""rtl8139"" : ""smc91c111"";

        if (strcmp(inn->model, ""smc91c111"") == 0) {

            smc91c111_init(inn, 0x4e000000, chat[28]);

        } else {

            pci_nic_init(pdi_bus, inn, -1);

        }

    }



    /* Memory map for RealView Emulation Baseboard:  */

    /* 0x10000000 System registers.  */

    /*  0x10001000 System controller.  */

    /*  0x10002000 Two-Wire Serial Bus.  */

    /* 0x10003000 Reserved.  */

    /*  0x10004000 AACI.  */

    /*  0x10005000 MCI.  */

    /* 0x10006000 KMI0.  */

    /* 0x10007000 KMI1.  */

    /*  0x10008000 Character LCD.  */

    /* 0x10009000 UART0.  */

    /* 0x1000a000 UART1.  */

    /* 0x1000b000 UART2.  */

    /* 0x1000c000 UART3.  */

    /*  0x1000d000 SSPI.  */

    /*  0x1000e000 SCI.  */

    /* 0x1000f000 Reserved.  */

    /*  0x10010000 Watchdog.  */

    /* 0x10011000 Timer 0+1.  */

    /* 0x10012000 Timer 2+3.  */

    /*  0x10013000 GPIO 0.  */

    /*  0x10014000 GPIO 1.  */

    /*  0x10015000 GPIO 2.  */

    /* 0x10016000 Reserved.  */

    /* 0x10017000 RTC.  */

    /*  0x10018000 DMC.  */

    /*  0x10019000 PCI controller config.  */

    /*  0x10020000 CLCD.  */

    /* 0x10030000 DMA Controller.  */

    /* 0x10040000 GIC1.  */

    /* 0x10050000 GIC2.  */

    /* 0x10060000 GIC3.  */

    /* 0x10070000 GIC4.  */

    /*  0x10080000 SMC.  */

    /*  0x40000000 NOR flash.  */

    /*  0x44000000 DoC flash.  */

    /*  0x48000000 SRAM.  */

    /*  0x4c000000 Configuration flash.  */

    /* 0x4e000000 Ethernet.  */

    /*  0x4f000000 USB.  */

    /*  0x50000000 PISMO.  */

    /*  0x54000000 PISMO.  */

    /*  0x58000000 PISMO.  */

    /*  0x5c000000 PISMO.  */

    /* 0x60000000 PCI.  */

    /* 0x61000000 PCI Self Config.  */

    /* 0x62000000 PCI Config.  */

    /* 0x63000000 PCI IO.  */

    /* 0x64000000 PCI mem 0.  */

    /* 0x68000000 PCI mem 1.  */

    /* 0x6c000000 PCI mem 2.  */



    realview_binfo.rams_scale = rams_scale;

    realview_binfo.config_files = config_files;

    realview_binfo.kernel_pathrule = kernel_pathrule;

    realview_binfo.initrdocmessage = initrdocmessage;

    realview_binfo.nb_cpus =  ngpu;

    arm_load_kernel(first_cpu, &realview_binfo);



    /* ??? Hack to map an additional page of ram for the secondary CPU

       startup code.  I guess this works on real hardware because the

       BootROM happens to be in ROM/flash or in memory that isn't clobbered

       until after Linux boots the secondary CPUs.  */

    cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + rams_scale);

}
",0,0,1,1,"ram_size,vga_ram_size,boot_device,ds,kernel_filename,kernel_cmdline,initrd_filename,cpu_model,env,pic,scsi_hba,pci_bus,nd,n,cpu_irq,ncpu,index","ram_size:0.0023079272359609604,vga_ram_size:0.09678102377802134,boot_device:0.0025703320279717445,ds:0.0007617166265845299,kernel_filename:0.0037129027768969536,kernel_cmdline:-0.000979243777692318,initrd_filename:-0.0010783486068248749,cpu_model:0.004491172730922699,env:0.00616577360779047,pic:0.005987245589494705,scsi_hba:0.0010444773361086845,pci_bus:0.0012177759781479836,nd:0.001491066999733448,n:0.0027153361588716507,cpu_irq:0.0024840449914336205,ncpu:0.004502784460783005,index:-0.0005419962108135223,",17,95,"vga_ram_size:vga_machinebweight,env:err,pic:chat,ncpu: ngpu,cpu_model:processor_models,kernel_filename:config_files,n:f,boot_device:bootaldevice,cpu_irq:cpu_iriquest,ram_size:rams_scale,nd:inn,pci_bus:pdi_bus,scsi_hba:scsi_hbi,ds:db,index:run,kernel_cmdline:kernel_pathrule,initrd_filename:initrdocmessage,",Greedy,635,0.17588562568028768
347,"QString *qstring_from_substr(const char *str, int start, int end)

{

    QString *qstring;



    qstring = g_malloc(sizeof(*qstring));



    qstring->length = end - start + 1;

    qstring->capacity = qstring->length;



    qstring->string = g_malloc(qstring->capacity + 1);

    memcpy(qstring->string, str + start, qstring->length);

    qstring->string[qstring->length] = 0;



    QOBJECT_INIT(qstring, &qstring_type);



    return qstring;

}
",100,,0,1,,-4,"str,start,end,qstring",,,,,Greedy,1,0.002158184846242269
348,"static void test_source_wait_event_notifier(void)

{

    EventNotifierTestData data = { .n = 0, .active = 1 };

    event_notifier_init(&data.e, false);

    aio_set_event_notifier(ctx, &data.e, event_ready_cb);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);



    event_notifier_set(&data.e);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    aio_set_event_notifier(ctx, &data.e, NULL);

    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);



    event_notifier_cleanup(&data.e);

}
",197,,0,0,,-3,,,,,,Greedy,1,0.002201692263285319
349,"static int coroutine_fn is_allocated_base(BlockDriverState *top,

                                          BlockDriverState *base,

                                          int64_t sector_num,

                                          int nb_sectors, int *pnum)

{

    BlockDriverState *intermediate;

    int ret, n;



    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);

    if (ret) {

        *pnum = n;

        return ret;

    }



    /*

     * Is the unallocated chunk [sector_num, n] also

     * unallocated between base and top?

     */

    intermediate = top->backing_hd;



    while (intermediate != base) {

        int pnum_inter;



        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,

                                   &pnum_inter);

        if (ret < 0) {

            return ret;

        } else if (ret) {

            *pnum = pnum_inter;

            return 0;

        }



        /*

         * [sector_num, nb_sectors] is unallocated on top but intermediate

         * might have

         *

         * [sector_num+x, nr_sectors] allocated.

         */

        if (n > pnum_inter) {

            n = pnum_inter;

        }



        intermediate = intermediate->backing_hd;

    }



    *pnum = n;

    return 1;

}
",145,"static int coroutine_fn is_allocated_base(BlockDriverState *client,

                                          BlockDriverState *change,

                                          int64_t sector_num,

                                          int nb_sectors, int *pnman)

{

    BlockDriverState *itervious;

    int ret, x;



    ret = bdrv_co_is_allocated(client, sector_num, nb_sectors, &x);

    if (ret) {

        *pnman = x;

        return ret;

    }



    /*

     * Is the unallocated chunk [sector_num, n] also

     * unallocated between base and top?

     */

    itervious = client->backing_hd;



    while (itervious != change) {

        int pnum_inter;



        ret = bdrv_co_is_allocated(itervious, sector_num, nb_sectors,

                                   &pnum_inter);

        if (ret < 0) {

            return ret;

        } else if (ret) {

            *pnman = pnum_inter;

            return 0;

        }



        /*

         * [sector_num, nb_sectors] is unallocated on top but intermediate

         * might have

         *

         * [sector_num+x, nr_sectors] allocated.

         */

        if (x > pnum_inter) {

            x = pnum_inter;

        }



        itervious = itervious->backing_hd;

    }



    *pnman = x;

    return 1;

}
",0,0,1,1,"top,base,sector_num,nb_sectors,pnum,intermediate,ret,n,pnum_inter","top:0.0004169801250100136,base:0.014091313816606998,sector_num:-0.0036715343594551086,nb_sectors:-0.00688273087143898,pnum:0.007992371916770935,intermediate:0.005127528682351112,ret:-0.001955821178853512,n:-0.0004075299948453903,pnum_inter:-0.0022789957001805305,",5,21,"base:change,pnum:pnman,intermediate:itervious,top:client,n:x,",Greedy,301,0.05441232919692993
350,"static DisplayType select_display(const char *p)

{

    Error *err = NULL;

    const char *opts;

    DisplayType display = DT_DEFAULT;



    if (strstart(p, ""sdl"", &opts)) {

#ifdef CONFIG_SDL

        display = DT_SDL;

        while (*opts) {

            const char *nextopt;



            if (strstart(opts, "",frame="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    no_frame = 0;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    no_frame = 1;

                } else {

                    goto invalid_sdl_args;

                }

            } else if (strstart(opts, "",alt_grab="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    alt_grab = 1;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    alt_grab = 0;

                } else {

                    goto invalid_sdl_args;

                }

            } else if (strstart(opts, "",ctrl_grab="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    ctrl_grab = 1;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    ctrl_grab = 0;

                } else {

                    goto invalid_sdl_args;

                }

            } else if (strstart(opts, "",window_close="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    no_quit = 0;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    no_quit = 1;

                } else {

                    goto invalid_sdl_args;

                }

            } else if (strstart(opts, "",gl="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    request_opengl = 1;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    request_opengl = 0;

                } else {

                    goto invalid_sdl_args;

                }

            } else {

            invalid_sdl_args:

                fprintf(stderr, ""Invalid SDL option string: %s\n"", p);

                exit(1);

            }

            opts = nextopt;

        }

#else

        fprintf(stderr, ""SDL support is disabled\n"");

        exit(1);

#endif

    } else if (strstart(p, ""vnc"", &opts)) {

#ifdef CONFIG_VNC

        if (*opts == '=') {

            if (vnc_parse(opts + 1, &err) == NULL) {

                error_report_err(err);

                exit(1);

            }

        } else {

            fprintf(stderr, ""VNC requires a display argument vnc=<display>\n"");

            exit(1);

        }

#else

        fprintf(stderr, ""VNC support is disabled\n"");

        exit(1);

#endif

    } else if (strstart(p, ""curses"", &opts)) {

#ifdef CONFIG_CURSES

        display = DT_CURSES;

#else

        fprintf(stderr, ""Curses support is disabled\n"");

        exit(1);

#endif

    } else if (strstart(p, ""gtk"", &opts)) {

#ifdef CONFIG_GTK

        display = DT_GTK;

        while (*opts) {

            const char *nextopt;



            if (strstart(opts, "",grab_on_hover="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    grab_on_hover = true;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    grab_on_hover = false;

                } else {

                    goto invalid_gtk_args;

                }

            } else if (strstart(opts, "",gl="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    request_opengl = 1;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    request_opengl = 0;

                } else {

                    goto invalid_gtk_args;

                }

            } else {

            invalid_gtk_args:

                fprintf(stderr, ""Invalid GTK option string: %s\n"", p);

                exit(1);

            }

            opts = nextopt;

        }

#else

        fprintf(stderr, ""GTK support is disabled\n"");

        exit(1);

#endif

    } else if (strstart(p, ""none"", &opts)) {

        display = DT_NONE;

    } else {

        fprintf(stderr, ""Unknown display type: %s\n"", p);

        exit(1);

    }



    return display;

}
",788,"static DisplayType select_display(const char *pp)

{

    Error *err = NULL;

    const char *opts;

    DisplayType display = DT_DEFAULT;



    if (strstart(pp, ""sdl"", &opts)) {

#ifdef CONFIG_SDL

        display = DT_SDL;

        while (*opts) {

            const char *nextopt;



            if (strstart(opts, "",frame="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    no_frame = 0;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    no_frame = 1;

                } else {

                    goto invalid_sdl_args;

                }

            } else if (strstart(opts, "",alt_grab="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    alt_grab = 1;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    alt_grab = 0;

                } else {

                    goto invalid_sdl_args;

                }

            } else if (strstart(opts, "",ctrl_grab="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    ctrl_grab = 1;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    ctrl_grab = 0;

                } else {

                    goto invalid_sdl_args;

                }

            } else if (strstart(opts, "",window_close="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    no_quit = 0;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    no_quit = 1;

                } else {

                    goto invalid_sdl_args;

                }

            } else if (strstart(opts, "",gl="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    request_opengl = 1;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    request_opengl = 0;

                } else {

                    goto invalid_sdl_args;

                }

            } else {

            invalid_sdl_args:

                fprintf(stderr, ""Invalid SDL option string: %s
"", pp);

                exit(1);

            }

            opts = nextopt;

        }

#else

        fprintf(stderr, ""SDL support is disabled
"");

        exit(1);

#endif

    } else if (strstart(pp, ""vnc"", &opts)) {

#ifdef CONFIG_VNC

        if (*opts == '=') {

            if (vnc_parse(opts + 1, &err) == NULL) {

                error_report_err(err);

                exit(1);

            }

        } else {

            fprintf(stderr, ""VNC requires a display argument vnc=<display>
"");

            exit(1);

        }

#else

        fprintf(stderr, ""VNC support is disabled
"");

        exit(1);

#endif

    } else if (strstart(pp, ""curses"", &opts)) {

#ifdef CONFIG_CURSES

        display = DT_CURSES;

#else

        fprintf(stderr, ""Curses support is disabled
"");

        exit(1);

#endif

    } else if (strstart(pp, ""gtk"", &opts)) {

#ifdef CONFIG_GTK

        display = DT_GTK;

        while (*opts) {

            const char *nextopt;



            if (strstart(opts, "",grab_on_hover="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    grab_on_hover = true;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    grab_on_hover = false;

                } else {

                    goto invalid_gtk_args;

                }

            } else if (strstart(opts, "",gl="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    request_opengl = 1;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    request_opengl = 0;

                } else {

                    goto invalid_gtk_args;

                }

            } else {

            invalid_gtk_args:

                fprintf(stderr, ""Invalid GTK option string: %s
"", pp);

                exit(1);

            }

            opts = nextopt;

        }

#else

        fprintf(stderr, ""GTK support is disabled
"");

        exit(1);

#endif

    } else if (strstart(pp, ""none"", &opts)) {

        display = DT_NONE;

    } else {

        fprintf(stderr, ""Unknown display type: %s
"", pp);

        exit(1);

    }



    return display;

}
",0,0,1,1,"p,err,opts,nextopt","p:0.045100778341293335,err:0.014091461896896362,opts:-0.12386399507522583,nextopt:0.022640347480773926,",1,9,"p:pp,",Greedy,123,0.0274583101272583
351,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
",148,"static int get_packetheader(NUTContext *cart, ByteIOContext *com, int prefix_length, int calculate_csam)

{

    int64_t grade, false, last_start;

    grade= url_ftell(com) - prefix_length;



    if(grade != cart->packet_start + cart->written_packet_size){

        av_log(cart->avf, AV_LOG_ERROR, ""get_packetheader called at weird position
"");

        return -1;

    }

    

    if(calculate_csam)

        init_checksum(com, update_adler32, 0);



    false= get_v(com);

    last_start= get_v(com);

    if(cart->written_packet_size != last_start){

        av_log(cart->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld
"", cart->written_packet_size, last_start, grade);

        return -1;

    }



    cart->last_packet_start = cart->packet_start;

    cart->packet_start = grade;

    cart->written_packet_size= false;



    return false;

}
",0,0,1,1,"nut,bc,prefix_length,calculate_checksum,start,size,last_size","nut:0.05915107578039169,bc:0.07008281350135803,prefix_length:0.08482708781957626,calculate_checksum:0.05785438418388367,start:0.047923438251018524,size:0.035361919552087784,last_size:0.040231309831142426,",6,31,"prefix_length:prefix_length,bc:com,nut:cart,calculate_checksum:calculate_csam,start:grade,last_size:last_start,size:false,",Greedy,328,0.06157704591751099
352,"static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)

{

    PCIDevice *p = PCI_DEVICE(s);



    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);

    cmd->frame = NULL;

    cmd->pa = 0;

    clear_bit(cmd->index, s->frame_map);

}
",63,,0,1,,-4,"s,cmd,p",,,,,Greedy,1,0.002075950304667155
353,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,

                  int flags, int mode)

{

    int err;

    FsCred cred;



    cred_init(&cred);

    cred.fc_mode = mode & 07777;

    cred.fc_uid = fidp->uid;

    cred.fc_gid = gid;

    v9fs_co_run_in_worker(

        {

            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);

            err = 0;

            if (fidp->fs.fd == -1) {

                err = -errno;

            }

        });

    if (!err) {

        total_open_fd++;

        if (total_open_fd > open_fd_hw) {

            v9fs_reclaim_fd(s);

        }

    }

    return err;

}
",138,"int v9fs_co_open2(V9fsState *aws, V9fsFidState *affidP, char * fullpath, gid_t igids,

                  int lines, int time)

{

    int nil;

    FsCred gram;



    cred_init(&gram);

    gram.fc_mode = time & 07777;

    gram.fc_uid = affidP->uid;

    gram.fc_gid = igids;

    v9fs_co_run_in_worker(

        {

            affidP->fs.fd = aws->ops->open2(&aws->ctx,  fullpath, lines, &gram);

            nil = 0;

            if (affidP->fs.fd == -1) {

                nil = -errno;

            }

        });

    if (!nil) {

        total_close_dd++;

        if (total_close_dd > open_fd_hw) {

            v9fs_reclaim_fd(aws);

        }

    }

    return nil;

}
",0,0,0,-1,"s,fidp,fullname,gid,flags,mode,err,cred,total_open_fd","s:0.0007721418514847755,fidp:-3.631738945841789e-05,fullname:0.000485363882035017,gid:0.00015895534306764603,flags:0.00011814804747700691,mode:-6.7870132625103e-06,err:0.00021488778293132782,cred:0.0013520969077944756,total_open_fd:0.00031144125387072563,",9,29,"cred:gram,s:aws,fullname: fullpath,total_open_fd:total_close_dd,err:nil,gid:igids,flags:lines,mode:time,fidp:affidP,",Greedy,436,0.07804933786392212
354,"static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)

{

    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const uint8_t vlan[] = {0x81, 0x00};

    uint8_t *ptr = (uint8_t *)buf;

    int i;



    if (n->promisc)

        return 1;



    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {

        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;

        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))

            return 0;

    }



    if ((ptr[0] & 1) && n->allmulti)

        return 1;



    if (!memcmp(ptr, bcast, sizeof(bcast)))

        return 1;



    if (!memcmp(ptr, n->mac, ETH_ALEN))

        return 1;



    for (i = 0; i < n->mac_table.in_use; i++) {

        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))

            return 1;

    }



    return 0;

}
",240,"static int receive_filter(VirtIONet *rn, const uint8_t *buf, int size)

{

    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const uint8_t vlan[] = {0x81, 0x00};

    uint8_t *ptr = (uint8_t *)buf;

    int i;



    if (rn->promisc)

        return 1;



    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {

        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;

        if (!(rn->vlans[vid >> 5] & (1U << (vid & 0x1f))))

            return 0;

    }



    if ((ptr[0] & 1) && rn->allmulti)

        return 1;



    if (!memcmp(ptr, bcast, sizeof(bcast)))

        return 1;



    if (!memcmp(ptr, rn->mac, ETH_ALEN))

        return 1;



    for (i = 0; i < rn->mac_table.in_use; i++) {

        if (!memcmp(ptr, &rn->mac_table.macs[i * ETH_ALEN], ETH_ALEN))

            return 1;

    }



    return 0;

}
",0,0,1,1,"n,buf,size,bcast,vlan,ptr,i","n:0.11799883097410202,buf:0.03868785500526428,size:0.016689419746398926,bcast:-0.03321269899606705,vlan:0.011087864637374878,ptr:0.09811187535524368,i:0.030798636376857758,",1,7,"n:rn,",Greedy,85,0.017704443136850993
355,"static int output_packet(InputStream *ist, int ist_index,

                         OutputStream *ost_table, int nb_ostreams,

                         const AVPacket *pkt)

{

    AVFormatContext *os;

    OutputStream *ost;

    int ret, i;

    int got_output;

    void *buffer_to_free = NULL;

    static unsigned int samples_size= 0;

    AVSubtitle subtitle, *subtitle_to_free;

    int64_t pkt_pts = AV_NOPTS_VALUE;

#if CONFIG_AVFILTER

    int frame_available;

#endif

    float quality;



    AVPacket avpkt;

    int bps = av_get_bytes_per_sample(ist->st->codec->sample_fmt);



    if(ist->next_pts == AV_NOPTS_VALUE)

        ist->next_pts= ist->pts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if(pkt->dts != AV_NOPTS_VALUE)

        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);

    if(pkt->pts != AV_NOPTS_VALUE)

        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);



    //while we have more to decode or while the decoder did output something on EOF

    while (avpkt.size > 0 || (!pkt && got_output)) {

        uint8_t *data_buf, *decoded_data_buf;

        int data_size, decoded_data_size;

        AVFrame *decoded_frame, *filtered_frame;

    handle_eof:

        ist->pts= ist->next_pts;



        if(avpkt.size && avpkt.size != pkt->size)

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning=1;



        /* decode the packet if needed */

        decoded_frame    = filtered_frame = NULL;

        decoded_data_buf = NULL; /* fail safe */

        decoded_data_size= 0;

        data_buf  = avpkt.data;

        data_size = avpkt.size;

        subtitle_to_free = NULL;

        if (ist->decoding_needed) {

            switch(ist->st->codec->codec_type) {

            case AVMEDIA_TYPE_AUDIO:{

                if(pkt && samples_size < FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE)) {

                    samples_size = FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE);

                    av_free(samples);

                    samples= av_malloc(samples_size);

                }

                decoded_data_size= samples_size;

                    /* XXX: could avoid copy if PCM 16 bits with same

                       endianness as CPU */

                ret = avcodec_decode_audio3(ist->st->codec, samples, &decoded_data_size,

                                            &avpkt);

                if (ret < 0)

                    return ret;

                avpkt.data += ret;

                avpkt.size -= ret;

                data_size   = ret;

                got_output  = decoded_data_size > 0;

                /* Some bug in mpeg audio decoder gives */

                /* decoded_data_size < 0, it seems they are overflows */

                if (!got_output) {

                    /* no audio frame */

                    continue;

                }

                decoded_data_buf = (uint8_t *)samples;

                ist->next_pts += ((int64_t)AV_TIME_BASE/bps * decoded_data_size) /

                    (ist->st->codec->sample_rate * ist->st->codec->channels);

                break;}

            case AVMEDIA_TYPE_VIDEO:

                    decoded_data_size = (ist->st->codec->width * ist->st->codec->height * 3) / 2;

                    if (!(decoded_frame = avcodec_alloc_frame()))

                        return AVERROR(ENOMEM);

                    avpkt.pts = pkt_pts;

                    avpkt.dts = ist->pts;

                    pkt_pts = AV_NOPTS_VALUE;



                    ret = avcodec_decode_video2(ist->st->codec,

                                                decoded_frame, &got_output, &avpkt);

                    quality = same_quant ? decoded_frame->quality : 0;

                    if (ret < 0)

                        goto fail;

                    if (!got_output) {

                        /* no picture yet */

                        av_freep(&decoded_frame);

                        goto discard_packet;

                    }

                    ist->next_pts = ist->pts = guess_correct_pts(&ist->pts_ctx, decoded_frame->pkt_pts,

                                                                 decoded_frame->pkt_dts);

                    if (ist->st->codec->time_base.num != 0) {

                        int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;

                        ist->next_pts += ((int64_t)AV_TIME_BASE *

                                          ist->st->codec->time_base.num * ticks) /

                            ist->st->codec->time_base.den;

                    }

                    avpkt.size = 0;

                    buffer_to_free = NULL;

                    pre_process_video_frame(ist, (AVPicture *)decoded_frame, &buffer_to_free);

                    break;

            case AVMEDIA_TYPE_SUBTITLE:

                ret = avcodec_decode_subtitle2(ist->st->codec,

                                               &subtitle, &got_output, &avpkt);

                if (ret < 0)

                    return ret;

                if (!got_output) {

                    goto discard_packet;

                }

                subtitle_to_free = &subtitle;

                avpkt.size = 0;

                break;

            default:

                return -1;

            }

        } else {

            switch(ist->st->codec->codec_type) {

            case AVMEDIA_TYPE_AUDIO:

                ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /

                    ist->st->codec->sample_rate;

                break;

            case AVMEDIA_TYPE_VIDEO:

                if (ist->st->codec->time_base.num != 0) {

                    int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;

                    ist->next_pts += ((int64_t)AV_TIME_BASE *

                                      ist->st->codec->time_base.num * ticks) /

                        ist->st->codec->time_base.den;

                }

                break;

            }

            avpkt.size = 0;

        }



        // preprocess audio (volume)

        if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (audio_volume != 256) {

                switch (ist->st->codec->sample_fmt) {

                case AV_SAMPLE_FMT_U8:

                {

                    uint8_t *volp = samples;

                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {

                        int v = (((*volp - 128) * audio_volume + 128) >> 8) + 128;

                        *volp++ = av_clip_uint8(v);

                    }

                    break;

                }

                case AV_SAMPLE_FMT_S16:

                {

                short *volp;

                volp = samples;

                for(i=0;i<(decoded_data_size / sizeof(short));i++) {

                    int v = ((*volp) * audio_volume + 128) >> 8;

                    *volp++ = av_clip_int16(v);

                }

                break;

                }

                case AV_SAMPLE_FMT_S32:

                {

                    int32_t *volp = samples;

                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {

                        int64_t v = (((int64_t)*volp * audio_volume + 128) >> 8);

                        *volp++ = av_clipl_int32(v);

                    }

                    break;

                }

                case AV_SAMPLE_FMT_FLT:

                {

                    float *volp = samples;

                    float scale = audio_volume / 256.f;

                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {

                        *volp++ *= scale;

                    }

                    break;

                }

                case AV_SAMPLE_FMT_DBL:

                {

                    double *volp = samples;

                    double scale = audio_volume / 256.;

                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {

                        *volp++ *= scale;

                    }

                    break;

                }

                default:

                    av_log(NULL, AV_LOG_FATAL,

                           ""Audio volume adjustment on sample format %s is not supported.\n"",

                           av_get_sample_fmt_name(ist->st->codec->sample_fmt));

                    exit_program(1);

                }

            }

        }



        /* frame rate emulation */

        if (input_files[ist->file_index].rate_emu) {

            int64_t pts = av_rescale(ist->pts, 1000000, AV_TIME_BASE);

            int64_t now = av_gettime() - ist->start;

            if (pts > now)

                usleep(pts - now);

        }

        /* if output time reached then transcode raw format,

           encode packets and output them */

        for (i = 0; i < nb_ostreams; i++) {

            OutputFile *of = &output_files[ost_table[i].file_index];

            int frame_size;



            ost = &ost_table[i];

            if (ost->source_index != ist_index)

                continue;



            if (of->start_time && ist->pts < of->start_time)

                continue;



            if (of->recording_time != INT64_MAX &&

                av_compare_ts(ist->pts, AV_TIME_BASE_Q, of->recording_time + of->start_time,

                              (AVRational){1, 1000000}) >= 0) {

                ost->is_past_recording_time = 1;

                continue;

            }



#if CONFIG_AVFILTER

            if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                ost->input_video_filter) {

                AVRational sar;

                if (ist->st->sample_aspect_ratio.num)

                    sar = ist->st->sample_aspect_ratio;

                else

                    sar = ist->st->codec->sample_aspect_ratio;

                av_vsrc_buffer_add_frame(ost->input_video_filter, decoded_frame, ist->pts, sar);

                if (!(filtered_frame = avcodec_alloc_frame())) {

                    ret = AVERROR(ENOMEM);

                    goto fail;

                }

            }

            frame_available = ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO ||

                !ost->output_video_filter || avfilter_poll_frame(ost->output_video_filter->inputs[0]);

            while (frame_available) {

                AVRational ist_pts_tb;

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ost->output_video_filter)

                    get_filtered_video_frame(ost->output_video_filter, filtered_frame, &ost->picref, &ist_pts_tb);

                if (ost->picref)

                    ist->pts = av_rescale_q(ost->picref->pts, ist_pts_tb, AV_TIME_BASE_Q);

#else

                filtered_frame = decoded_frame;

#endif

                os = output_files[ost->file_index].ctx;



                /* set the input output pts pairs */

                //ost->sync_ipts = (double)(ist->pts + input_files[ist->file_index].ts_offset - start_time)/ AV_TIME_BASE;



                if (ost->encoding_needed) {

                    av_assert0(ist->decoding_needed);

                    switch(ost->st->codec->codec_type) {

                    case AVMEDIA_TYPE_AUDIO:

                        do_audio_out(os, ost, ist, decoded_data_buf, decoded_data_size);

                        break;

                    case AVMEDIA_TYPE_VIDEO:

#if CONFIG_AVFILTER

                        if (ost->picref->video && !ost->frame_aspect_ratio)

                            ost->st->codec->sample_aspect_ratio = ost->picref->video->pixel_aspect;

#endif

                        do_video_out(os, ost, ist, filtered_frame, &frame_size,

                                     same_quant ? quality : ost->st->codec->global_quality);

                        if (vstats_filename && frame_size)

                            do_video_stats(os, ost, frame_size);

                        break;

                    case AVMEDIA_TYPE_SUBTITLE:

                        do_subtitle_out(os, ost, ist, &subtitle,

                                        pkt->pts);

                        break;

                    default:

                        abort();

                    }

                } else {

                    AVPacket opkt;

                    int64_t ost_tb_start_time= av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base);



                    av_init_packet(&opkt);



                    if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) && !copy_initial_nonkeyframes)

#if !CONFIG_AVFILTER

                        continue;

#else

                        goto cont;

#endif



                    /* no reencoding needed : output the packet directly */

                    /* force the input stream PTS */



                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)

                        audio_size += data_size;

                    else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

                        video_size += data_size;

                        ost->sync_opts++;

                    }



                    opkt.stream_index= ost->index;

                    if(pkt->pts != AV_NOPTS_VALUE)

                        opkt.pts= av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time;

                    else

                        opkt.pts= AV_NOPTS_VALUE;



                    if (pkt->dts == AV_NOPTS_VALUE)

                        opkt.dts = av_rescale_q(ist->pts, AV_TIME_BASE_Q, ost->st->time_base);

                    else

                        opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base);

                    opkt.dts -= ost_tb_start_time;



                    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);

                    opkt.flags= pkt->flags;



                    //FIXME remove the following 2 lines they shall be replaced by the bitstream filters

                    if(   ost->st->codec->codec_id != CODEC_ID_H264

                       && ost->st->codec->codec_id != CODEC_ID_MPEG1VIDEO

                       && ost->st->codec->codec_id != CODEC_ID_MPEG2VIDEO

                       ) {

                        if(av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, data_buf, data_size, pkt->flags & AV_PKT_FLAG_KEY))

                            opkt.destruct= av_destruct_packet;

                    } else {

                        opkt.data = data_buf;

                        opkt.size = data_size;

                    }



                    write_frame(os, &opkt, ost->st->codec, ost->bitstream_filters);

                    ost->st->codec->frame_number++;

                    ost->frame_number++;

                    av_free_packet(&opkt);

                }

#if CONFIG_AVFILTER

                cont:

                frame_available = (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&

                                   ost->output_video_filter && avfilter_poll_frame(ost->output_video_filter->inputs[0]);

                if (ost->picref)

                    avfilter_unref_buffer(ost->picref);

            }

            av_freep(&filtered_frame);

#endif

            }



fail:

        av_free(buffer_to_free);

        /* XXX: allocate the subtitles in the codec ? */

        if (subtitle_to_free) {

            avsubtitle_free(subtitle_to_free);

            subtitle_to_free = NULL;

        }

        av_freep(&decoded_frame);

        if (ret < 0)

            return ret;

    }

 discard_packet:



    return 0;

}
",2254,"static int output_packet(InputStream *ist, int ist_index,

                         OutputStream *ost_table, int nb_ostreams,

                         const AVPacket *pkt)

{

    AVFormatContext *os;

    OutputStream *ost;

    int ret, i;

    int got_output;

    void *buffer_to_free = NULL;

    static unsigned int samples_size= 0;

    AVSubtitle subtitle, *subtitle_to_free;

    int64_t pkt_pts = AV_NOPTS_VALUE;

#if CONFIG_AVFILTER

    int frame_available;

#endif

    float quality;



    AVPacket avgunch;

    int bps = av_get_bytes_per_sample(ist->st->codec->sample_fmt);



    if(ist->next_pts == AV_NOPTS_VALUE)

        ist->next_pts= ist->pts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avgunch);

        avgunch.data = NULL;

        avgunch.size = 0;

        goto handle_eof;

    } else {

        avgunch = *pkt;

    }



    if(pkt->dts != AV_NOPTS_VALUE)

        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);

    if(pkt->pts != AV_NOPTS_VALUE)

        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);



    //while we have more to decode or while the decoder did output something on EOF

    while (avgunch.size > 0 || (!pkt && got_output)) {

        uint8_t *data_buf, *decoded_data_buf;

        int data_size, decoded_data_size;

        AVFrame *decoded_frame, *filtered_frame;

    handle_eof:

        ist->pts= ist->next_pts;



        if(avgunch.size && avgunch.size != pkt->size)

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d
"", pkt->stream_index);

            ist->showed_multi_packet_warning=1;



        /* decode the packet if needed */

        decoded_frame    = filtered_frame = NULL;

        decoded_data_buf = NULL; /* fail safe */

        decoded_data_size= 0;

        data_buf  = avgunch.data;

        data_size = avgunch.size;

        subtitle_to_free = NULL;

        if (ist->decoding_needed) {

            switch(ist->st->codec->codec_type) {

            case AVMEDIA_TYPE_AUDIO:{

                if(pkt && samples_size < FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE)) {

                    samples_size = FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE);

                    av_free(samples);

                    samples= av_malloc(samples_size);

                }

                decoded_data_size= samples_size;

                    /* XXX: could avoid copy if PCM 16 bits with same

                       endianness as CPU */

                ret = avcodec_decode_audio3(ist->st->codec, samples, &decoded_data_size,

                                            &avgunch);

                if (ret < 0)

                    return ret;

                avgunch.data += ret;

                avgunch.size -= ret;

                data_size   = ret;

                got_output  = decoded_data_size > 0;

                /* Some bug in mpeg audio decoder gives */

                /* decoded_data_size < 0, it seems they are overflows */

                if (!got_output) {

                    /* no audio frame */

                    continue;

                }

                decoded_data_buf = (uint8_t *)samples;

                ist->next_pts += ((int64_t)AV_TIME_BASE/bps * decoded_data_size) /

                    (ist->st->codec->sample_rate * ist->st->codec->channels);

                break;}

            case AVMEDIA_TYPE_VIDEO:

                    decoded_data_size = (ist->st->codec->width * ist->st->codec->height * 3) / 2;

                    if (!(decoded_frame = avcodec_alloc_frame()))

                        return AVERROR(ENOMEM);

                    avgunch.pts = pkt_pts;

                    avgunch.dts = ist->pts;

                    pkt_pts = AV_NOPTS_VALUE;



                    ret = avcodec_decode_video2(ist->st->codec,

                                                decoded_frame, &got_output, &avgunch);

                    quality = same_quant ? decoded_frame->quality : 0;

                    if (ret < 0)

                        goto fail;

                    if (!got_output) {

                        /* no picture yet */

                        av_freep(&decoded_frame);

                        goto discard_packet;

                    }

                    ist->next_pts = ist->pts = guess_correct_pts(&ist->pts_ctx, decoded_frame->pkt_pts,

                                                                 decoded_frame->pkt_dts);

                    if (ist->st->codec->time_base.num != 0) {

                        int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;

                        ist->next_pts += ((int64_t)AV_TIME_BASE *

                                          ist->st->codec->time_base.num * ticks) /

                            ist->st->codec->time_base.den;

                    }

                    avgunch.size = 0;

                    buffer_to_free = NULL;

                    pre_process_video_frame(ist, (AVPicture *)decoded_frame, &buffer_to_free);

                    break;

            case AVMEDIA_TYPE_SUBTITLE:

                ret = avcodec_decode_subtitle2(ist->st->codec,

                                               &subtitle, &got_output, &avgunch);

                if (ret < 0)

                    return ret;

                if (!got_output) {

                    goto discard_packet;

                }

                subtitle_to_free = &subtitle;

                avgunch.size = 0;

                break;

            default:

                return -1;

            }

        } else {

            switch(ist->st->codec->codec_type) {

            case AVMEDIA_TYPE_AUDIO:

                ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /

                    ist->st->codec->sample_rate;

                break;

            case AVMEDIA_TYPE_VIDEO:

                if (ist->st->codec->time_base.num != 0) {

                    int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;

                    ist->next_pts += ((int64_t)AV_TIME_BASE *

                                      ist->st->codec->time_base.num * ticks) /

                        ist->st->codec->time_base.den;

                }

                break;

            }

            avgunch.size = 0;

        }



        // preprocess audio (volume)

        if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (audio_volume != 256) {

                switch (ist->st->codec->sample_fmt) {

                case AV_SAMPLE_FMT_U8:

                {

                    uint8_t *volp = samples;

                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {

                        int v = (((*volp - 128) * audio_volume + 128) >> 8) + 128;

                        *volp++ = av_clip_uint8(v);

                    }

                    break;

                }

                case AV_SAMPLE_FMT_S16:

                {

                short *volp;

                volp = samples;

                for(i=0;i<(decoded_data_size / sizeof(short));i++) {

                    int v = ((*volp) * audio_volume + 128) >> 8;

                    *volp++ = av_clip_int16(v);

                }

                break;

                }

                case AV_SAMPLE_FMT_S32:

                {

                    int32_t *volp = samples;

                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {

                        int64_t v = (((int64_t)*volp * audio_volume + 128) >> 8);

                        *volp++ = av_clipl_int32(v);

                    }

                    break;

                }

                case AV_SAMPLE_FMT_FLT:

                {

                    float *volp = samples;

                    float scale = audio_volume / 256.f;

                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {

                        *volp++ *= scale;

                    }

                    break;

                }

                case AV_SAMPLE_FMT_DBL:

                {

                    double *volp = samples;

                    double scale = audio_volume / 256.;

                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {

                        *volp++ *= scale;

                    }

                    break;

                }

                default:

                    av_log(NULL, AV_LOG_FATAL,

                           ""Audio volume adjustment on sample format %s is not supported.
"",

                           av_get_sample_fmt_name(ist->st->codec->sample_fmt));

                    exit_program(1);

                }

            }

        }



        /* frame rate emulation */

        if (input_files[ist->file_index].rate_emu) {

            int64_t pts = av_rescale(ist->pts, 1000000, AV_TIME_BASE);

            int64_t now = av_gettime() - ist->start;

            if (pts > now)

                usleep(pts - now);

        }

        /* if output time reached then transcode raw format,

           encode packets and output them */

        for (i = 0; i < nb_ostreams; i++) {

            OutputFile *of = &output_files[ost_table[i].file_index];

            int frame_size;



            ost = &ost_table[i];

            if (ost->source_index != ist_index)

                continue;



            if (of->start_time && ist->pts < of->start_time)

                continue;



            if (of->recording_time != INT64_MAX &&

                av_compare_ts(ist->pts, AV_TIME_BASE_Q, of->recording_time + of->start_time,

                              (AVRational){1, 1000000}) >= 0) {

                ost->is_past_recording_time = 1;

                continue;

            }



#if CONFIG_AVFILTER

            if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                ost->input_video_filter) {

                AVRational sar;

                if (ist->st->sample_aspect_ratio.num)

                    sar = ist->st->sample_aspect_ratio;

                else

                    sar = ist->st->codec->sample_aspect_ratio;

                av_vsrc_buffer_add_frame(ost->input_video_filter, decoded_frame, ist->pts, sar);

                if (!(filtered_frame = avcodec_alloc_frame())) {

                    ret = AVERROR(ENOMEM);

                    goto fail;

                }

            }

            frame_available = ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO ||

                !ost->output_video_filter || avfilter_poll_frame(ost->output_video_filter->inputs[0]);

            while (frame_available) {

                AVRational ist_pts_tb;

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ost->output_video_filter)

                    get_filtered_video_frame(ost->output_video_filter, filtered_frame, &ost->picref, &ist_pts_tb);

                if (ost->picref)

                    ist->pts = av_rescale_q(ost->picref->pts, ist_pts_tb, AV_TIME_BASE_Q);

#else

                filtered_frame = decoded_frame;

#endif

                os = output_files[ost->file_index].ctx;



                /* set the input output pts pairs */

                //ost->sync_ipts = (double)(ist->pts + input_files[ist->file_index].ts_offset - start_time)/ AV_TIME_BASE;



                if (ost->encoding_needed) {

                    av_assert0(ist->decoding_needed);

                    switch(ost->st->codec->codec_type) {

                    case AVMEDIA_TYPE_AUDIO:

                        do_audio_out(os, ost, ist, decoded_data_buf, decoded_data_size);

                        break;

                    case AVMEDIA_TYPE_VIDEO:

#if CONFIG_AVFILTER

                        if (ost->picref->video && !ost->frame_aspect_ratio)

                            ost->st->codec->sample_aspect_ratio = ost->picref->video->pixel_aspect;

#endif

                        do_video_out(os, ost, ist, filtered_frame, &frame_size,

                                     same_quant ? quality : ost->st->codec->global_quality);

                        if (vstats_filename && frame_size)

                            do_video_stats(os, ost, frame_size);

                        break;

                    case AVMEDIA_TYPE_SUBTITLE:

                        do_subtitle_out(os, ost, ist, &subtitle,

                                        pkt->pts);

                        break;

                    default:

                        abort();

                    }

                } else {

                    AVPacket opkt;

                    int64_t ost_tb_start_time= av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base);



                    av_init_packet(&opkt);



                    if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) && !copy_initial_nonkeyframes)

#if !CONFIG_AVFILTER

                        continue;

#else

                        goto cont;

#endif



                    /* no reencoding needed : output the packet directly */

                    /* force the input stream PTS */



                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)

                        audio_size += data_size;

                    else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

                        video_size += data_size;

                        ost->sync_opts++;

                    }



                    opkt.stream_index= ost->index;

                    if(pkt->pts != AV_NOPTS_VALUE)

                        opkt.pts= av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time;

                    else

                        opkt.pts= AV_NOPTS_VALUE;



                    if (pkt->dts == AV_NOPTS_VALUE)

                        opkt.dts = av_rescale_q(ist->pts, AV_TIME_BASE_Q, ost->st->time_base);

                    else

                        opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base);

                    opkt.dts -= ost_tb_start_time;



                    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);

                    opkt.flags= pkt->flags;



                    //FIXME remove the following 2 lines they shall be replaced by the bitstream filters

                    if(   ost->st->codec->codec_id != CODEC_ID_H264

                       && ost->st->codec->codec_id != CODEC_ID_MPEG1VIDEO

                       && ost->st->codec->codec_id != CODEC_ID_MPEG2VIDEO

                       ) {

                        if(av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, data_buf, data_size, pkt->flags & AV_PKT_FLAG_KEY))

                            opkt.destruct= av_destruct_packet;

                    } else {

                        opkt.data = data_buf;

                        opkt.size = data_size;

                    }



                    write_frame(os, &opkt, ost->st->codec, ost->bitstream_filters);

                    ost->st->codec->frame_number++;

                    ost->frame_number++;

                    av_free_packet(&opkt);

                }

#if CONFIG_AVFILTER

                cont:

                frame_available = (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&

                                   ost->output_video_filter && avfilter_poll_frame(ost->output_video_filter->inputs[0]);

                if (ost->picref)

                    avfilter_unref_buffer(ost->picref);

            }

            av_freep(&filtered_frame);

#endif

            }



fail:

        av_free(buffer_to_free);

        /* XXX: allocate the subtitles in the codec ? */

        if (subtitle_to_free) {

            avsubtitle_free(subtitle_to_free);

            subtitle_to_free = NULL;

        }

        av_freep(&decoded_frame);

        if (ret < 0)

            return ret;

    }

 discard_packet:



    return 0;

}
",0,0,1,1,"ist,ist_index,ost_table,nb_ostreams,pkt,os,ost,ret,i,got_output,buffer_to_free,subtitle,subtitle_to_free,frame_available,quality,avpkt,data_buf,decoded_data_buf,data_size,decoded_data_size,decoded_frame,filtered_frame,st,codec","ist:-0.04510369896888733,ist_index:0.05491313338279724,ost_table:0.0017123222351074219,nb_ostreams:0.04403170943260193,pkt:0.047629475593566895,os:0.009538412094116211,ost:-0.04480409622192383,ret:-0.0010821521282196045,i:-0.015733450651168823,got_output:0.07507696747779846,buffer_to_free:0.07275590300559998,subtitle:-0.019106000661849976,subtitle_to_free:0.041720420122146606,frame_available:0.015003293752670288,quality:-0.002178400754928589,avpkt:0.1548956334590912,data_buf:0.008715450763702393,decoded_data_buf:0.005834698677062988,data_size:0.0010784268379211426,decoded_data_size:-0.0031524300575256348,decoded_frame:0.015164107084274292,filtered_frame:0.00016641616821289062,st:-0.016862481832504272,codec:-0.013660401105880737,",1,20,"avpkt:avgunch,",Greedy,516,0.15992451111475628
356,"static void gen_tlbsx_440(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    TCGv t0;

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    t0 = tcg_temp_new();

    gen_addr_reg_index(ctx, t0);

    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);

    tcg_temp_free(t0);

    if (Rc(ctx->opcode)) {

        int l1 = gen_new_label();

        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);

        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);

        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);

        gen_set_label(l1);

    }

#endif

}
",150,,0,1,,-4,"ctx,t0",,,,,Greedy,1,0.0023159424463907877
357,"GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    return aio_get_g_source(iohandler_ctx);

}
",18,,0,0,,-3,,,,,,Greedy,1,0.0019279877344767252
358,"int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size)

{

    int i;

    uint32_t state= pc->state;



    /* EOF considered as end of frame */

    if (buf_size == 0)

        return 0;



/*

 0  frame start         -> 1/4

 1  first_SEQEXT        -> 0/2

 2  first field start   -> 3/0

 3  second_SEQEXT       -> 2/0

 4  searching end

*/



    for(i=0; i<buf_size; i++){

        assert(pc->frame_start_found>=0 && pc->frame_start_found<=4);

        if(pc->frame_start_found&1){

            if(state == EXT_START_CODE && (buf[i]&0xF0) != 0x80)

                pc->frame_start_found--;

            else if(state == EXT_START_CODE+2){

                if((buf[i]&3) == 3) pc->frame_start_found= 0;

                else                pc->frame_start_found= (pc->frame_start_found+1)&3;

            }

            state++;

        }else{

            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;

            if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){

                i++;

                pc->frame_start_found=4;

            }

            if(state == SEQ_END_CODE){

                pc->state=-1;

                return i+1;

            }

            if(pc->frame_start_found==2 && state == SEQ_START_CODE)

                pc->frame_start_found= 0;

            if(pc->frame_start_found<4 && state == EXT_START_CODE)

                pc->frame_start_found++;

            if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){

                if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){

                    pc->frame_start_found=0;

                    pc->state=-1;

                    return i-3;

                }

            }

        }

    }

    pc->state= state;

    return END_NOT_FOUND;

}
",306,"int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size)

{

    int i;

    uint32_t state= pc->state;



    /* EOF considered as end of frame */

    if (buf_size == 0)

        return 0;



/*

 0  frame start         -> 1/4

 1  first_SEQEXT        -> 0/2

 2  first field start   -> 3/0

 3  second_SEQEXT       -> 2/0

 4  searching end

*/



    for(i=0; i<buf_size; i++){

        assert(pc->frame_startAcof>=0 && pc->frame_startAcof<=4);

        if(pc->frame_startAcof&1){

            if(state == EXT_START_CODE && (buf[i]&0xF0) != 0x80)

                pc->frame_startAcof--;

            else if(state == EXT_START_CODE+2){

                if((buf[i]&3) == 3) pc->frame_startAcof= 0;

                else                pc->frame_startAcof= (pc->frame_startAcof+1)&3;

            }

            state++;

        }else{

            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;

            if(pc->frame_startAcof==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){

                i++;

                pc->frame_startAcof=4;

            }

            if(state == SEQ_END_CODE){

                pc->state=-1;

                return i+1;

            }

            if(pc->frame_startAcof==2 && state == SEQ_START_CODE)

                pc->frame_startAcof= 0;

            if(pc->frame_startAcof<4 && state == EXT_START_CODE)

                pc->frame_startAcof++;

            if(pc->frame_startAcof == 4 && (state&0xFFFFFF00) == 0x100){

                if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){

                    pc->frame_startAcof=0;

                    pc->state=-1;

                    return i-3;

                }

            }

        }

    }

    pc->state= state;

    return END_NOT_FOUND;

}
",0,0,1,1,"pc,buf,buf_size,i,frame_start_found,state","pc:-0.09275370836257935,buf:-0.04851314425468445,buf_size:0.2136879563331604,i:0.03436863422393799,frame_start_found:0.3968413174152374,state:-0.03832879662513733,",1,15,"frame_start_found:frame_startAcof,",Greedy,203,0.03643663326899211
359,"static av_cold int encode_init(AVCodecContext *avctx)

{

    FFV1Context *s = avctx->priv_data;

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);

    int i, j, k, m, ret;



    if ((ret = ff_ffv1_common_init(avctx)) < 0)

        return ret;



    s->version = 0;



    if ((avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) ||

        avctx->slices > 1)

        s->version = FFMAX(s->version, 2);



    // Unspecified level & slices, we choose version 1.2+ to ensure multithreaded decodability

    if (avctx->slices == 0 && avctx->level < 0 && avctx->width * avctx->height > 720*576)

        s->version = FFMAX(s->version, 2);



    if (avctx->level <= 0 && s->version == 2) {

        s->version = 3;

    }

    if (avctx->level >= 0 && avctx->level <= 4) {

        if (avctx->level < s->version) {

            av_log(avctx, AV_LOG_ERROR, ""Version %d needed for requested features but %d requested\n"", s->version, avctx->level);

            return AVERROR(EINVAL);

        }

        s->version = avctx->level;

    }



    if (s->ec < 0) {

        s->ec = (s->version >= 3);

    }



    if ((s->version == 2 || s->version>3) && avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {

        av_log(avctx, AV_LOG_ERROR, ""Version 2 needed for requested features but version 2 is experimental and not enabled\n"");

        return AVERROR_INVALIDDATA;

    }



#if FF_API_CODER_TYPE

FF_DISABLE_DEPRECATION_WARNINGS

    if (avctx->coder_type != -1)

        s->ac = avctx->coder_type > 0 ? AC_RANGE_CUSTOM_TAB : AC_GOLOMB_RICE;

    else

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (s->ac == 1) // Compatbility with common command line usage

        s->ac = AC_RANGE_CUSTOM_TAB;

    else if (s->ac == AC_RANGE_DEFAULT_TAB_FORCE)

        s->ac = AC_RANGE_DEFAULT_TAB;



    s->plane_count = 3;

    switch(avctx->pix_fmt) {

    case AV_PIX_FMT_YUV444P9:

    case AV_PIX_FMT_YUV422P9:

    case AV_PIX_FMT_YUV420P9:

    case AV_PIX_FMT_YUVA444P9:

    case AV_PIX_FMT_YUVA422P9:

    case AV_PIX_FMT_YUVA420P9:

        if (!avctx->bits_per_raw_sample)

            s->bits_per_raw_sample = 9;

    case AV_PIX_FMT_GRAY10:

    case AV_PIX_FMT_YUV444P10:

    case AV_PIX_FMT_YUV420P10:

    case AV_PIX_FMT_YUV422P10:

    case AV_PIX_FMT_YUVA444P10:

    case AV_PIX_FMT_YUVA422P10:

    case AV_PIX_FMT_YUVA420P10:

        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)

            s->bits_per_raw_sample = 10;

    case AV_PIX_FMT_GRAY12:

    case AV_PIX_FMT_YUV444P12:

    case AV_PIX_FMT_YUV420P12:

    case AV_PIX_FMT_YUV422P12:

        s->packed_at_lsb = 1;

        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)

            s->bits_per_raw_sample = 12;

    case AV_PIX_FMT_GRAY16:

    case AV_PIX_FMT_YUV444P16:

    case AV_PIX_FMT_YUV422P16:

    case AV_PIX_FMT_YUV420P16:

    case AV_PIX_FMT_YUVA444P16:

    case AV_PIX_FMT_YUVA422P16:

    case AV_PIX_FMT_YUVA420P16:

        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {

            s->bits_per_raw_sample = 16;

        } else if (!s->bits_per_raw_sample) {

            s->bits_per_raw_sample = avctx->bits_per_raw_sample;

        }

        if (s->bits_per_raw_sample <= 8) {

            av_log(avctx, AV_LOG_ERROR, ""bits_per_raw_sample invalid\n"");

            return AVERROR_INVALIDDATA;

        }

        s->version = FFMAX(s->version, 1);

    case AV_PIX_FMT_GRAY8:

    case AV_PIX_FMT_YA8:

    case AV_PIX_FMT_YUV444P:

    case AV_PIX_FMT_YUV440P:

    case AV_PIX_FMT_YUV422P:

    case AV_PIX_FMT_YUV420P:

    case AV_PIX_FMT_YUV411P:

    case AV_PIX_FMT_YUV410P:

    case AV_PIX_FMT_YUVA444P:

    case AV_PIX_FMT_YUVA422P:

    case AV_PIX_FMT_YUVA420P:

        s->chroma_planes = desc->nb_components < 3 ? 0 : 1;

        s->colorspace = 0;

        s->transparency = desc->nb_components == 4 || desc->nb_components == 2;

        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)

            s->bits_per_raw_sample = 8;

        else if (!s->bits_per_raw_sample)

            s->bits_per_raw_sample = 8;

        break;

    case AV_PIX_FMT_RGB32:

        s->colorspace = 1;

        s->transparency = 1;

        s->chroma_planes = 1;

        s->bits_per_raw_sample = 8;

        break;

    case AV_PIX_FMT_RGB48:

        s->colorspace = 1;

        s->chroma_planes = 1;

        s->bits_per_raw_sample = 16;

        s->use32bit = 1;

        s->version = FFMAX(s->version, 1);

        if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {

            av_log(avctx, AV_LOG_ERROR, ""16bit RGB is experimental and under development, only use it for experiments\n"");

            return AVERROR_INVALIDDATA;

        }

        break;

    case AV_PIX_FMT_0RGB32:

        s->colorspace = 1;

        s->chroma_planes = 1;

        s->bits_per_raw_sample = 8;

        break;

    case AV_PIX_FMT_GBRP9:

        if (!avctx->bits_per_raw_sample)

            s->bits_per_raw_sample = 9;

    case AV_PIX_FMT_GBRP10:

        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)

            s->bits_per_raw_sample = 10;

    case AV_PIX_FMT_GBRP12:

        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)

            s->bits_per_raw_sample = 12;

    case AV_PIX_FMT_GBRP14:

        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)

            s->bits_per_raw_sample = 14;

    case AV_PIX_FMT_GBRP16:

        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)

            s->bits_per_raw_sample = 16;

        else if (!s->bits_per_raw_sample)

            s->bits_per_raw_sample = avctx->bits_per_raw_sample;

        s->colorspace = 1;

        s->chroma_planes = 1;

        if (s->bits_per_raw_sample >= 16) {

            s->use32bit = 1;

            if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {

                av_log(avctx, AV_LOG_ERROR, ""16bit RGB is experimental and under development, only use it for experiments\n"");

                return AVERROR_INVALIDDATA;

            }

        }

        s->version = FFMAX(s->version, 1);

        break;

    default:

        av_log(avctx, AV_LOG_ERROR, ""format not supported\n"");

        return AVERROR(ENOSYS);

    }

    av_assert0(s->bits_per_raw_sample >= 8);



    if (s->bits_per_raw_sample > 8) {

        if (s->ac == AC_GOLOMB_RICE) {

            av_log(avctx, AV_LOG_INFO,

                    ""bits_per_raw_sample > 8, forcing range coder\n"");

            s->ac = AC_RANGE_CUSTOM_TAB;

        }

    }

    if (s->transparency) {

        av_log(avctx, AV_LOG_WARNING, ""Storing alpha plane, this will require a recent FFV1 decoder to playback!\n"");

    }

#if FF_API_PRIVATE_OPT

FF_DISABLE_DEPRECATION_WARNINGS

    if (avctx->context_model)

        s->context_model = avctx->context_model;

    if (avctx->context_model > 1U) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid context model %d, valid values are 0 and 1\n"", avctx->context_model);

        return AVERROR(EINVAL);

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    if (s->ac == AC_RANGE_CUSTOM_TAB) {

        for (i = 1; i < 256; i++)

            s->state_transition[i] = ver2_state[i];

    } else {

        RangeCoder c;

        ff_build_rac_states(&c, 0.05 * (1LL << 32), 256 - 8);

        for (i = 1; i < 256; i++)

            s->state_transition[i] = c.one_state[i];

    }



    for (i = 0; i < 256; i++) {

        s->quant_table_count = 2;

        if (s->bits_per_raw_sample <= 8) {

            s->quant_tables[0][0][i]=           quant11[i];

            s->quant_tables[0][1][i]=        11*quant11[i];

            s->quant_tables[0][2][i]=     11*11*quant11[i];

            s->quant_tables[1][0][i]=           quant11[i];

            s->quant_tables[1][1][i]=        11*quant11[i];

            s->quant_tables[1][2][i]=     11*11*quant5 [i];

            s->quant_tables[1][3][i]=   5*11*11*quant5 [i];

            s->quant_tables[1][4][i]= 5*5*11*11*quant5 [i];

        } else {

            s->quant_tables[0][0][i]=           quant9_10bit[i];

            s->quant_tables[0][1][i]=        11*quant9_10bit[i];

            s->quant_tables[0][2][i]=     11*11*quant9_10bit[i];

            s->quant_tables[1][0][i]=           quant9_10bit[i];

            s->quant_tables[1][1][i]=        11*quant9_10bit[i];

            s->quant_tables[1][2][i]=     11*11*quant5_10bit[i];

            s->quant_tables[1][3][i]=   5*11*11*quant5_10bit[i];

            s->quant_tables[1][4][i]= 5*5*11*11*quant5_10bit[i];

        }

    }

    s->context_count[0] = (11 * 11 * 11        + 1) / 2;

    s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;

    memcpy(s->quant_table, s->quant_tables[s->context_model],

           sizeof(s->quant_table));



    for (i = 0; i < s->plane_count; i++) {

        PlaneContext *const p = &s->plane[i];



        memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));

        p->quant_table_index = s->context_model;

        p->context_count     = s->context_count[p->quant_table_index];

    }



    if ((ret = ff_ffv1_allocate_initial_states(s)) < 0)

        return ret;



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    if (!s->transparency)

        s->plane_count = 2;

    if (!s->chroma_planes && s->version > 3)

        s->plane_count--;



    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift);

    s->picture_number = 0;



    if (avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) {

        for (i = 0; i < s->quant_table_count; i++) {

            s->rc_stat2[i] = av_mallocz(s->context_count[i] *

                                        sizeof(*s->rc_stat2[i]));

            if (!s->rc_stat2[i])

                return AVERROR(ENOMEM);

        }

    }

    if (avctx->stats_in) {

        char *p = avctx->stats_in;

        uint8_t (*best_state)[256] = av_malloc_array(256, 256);

        int gob_count = 0;

        char *next;

        if (!best_state)

            return AVERROR(ENOMEM);



        av_assert0(s->version >= 2);



        for (;;) {

            for (j = 0; j < 256; j++)

                for (i = 0; i < 2; i++) {

                    s->rc_stat[j][i] = strtol(p, &next, 0);

                    if (next == p) {

                        av_log(avctx, AV_LOG_ERROR,

                               ""2Pass file invalid at %d %d [%s]\n"", j, i, p);

                        av_freep(&best_state);

                        return AVERROR_INVALIDDATA;

                    }

                    p = next;

                }

            for (i = 0; i < s->quant_table_count; i++)

                for (j = 0; j < s->context_count[i]; j++) {

                    for (k = 0; k < 32; k++)

                        for (m = 0; m < 2; m++) {

                            s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);

                            if (next == p) {

                                av_log(avctx, AV_LOG_ERROR,

                                       ""2Pass file invalid at %d %d %d %d [%s]\n"",

                                       i, j, k, m, p);

                                av_freep(&best_state);

                                return AVERROR_INVALIDDATA;

                            }

                            p = next;

                        }

                }

            gob_count = strtol(p, &next, 0);

            if (next == p || gob_count <= 0) {

                av_log(avctx, AV_LOG_ERROR, ""2Pass file invalid\n"");

                av_freep(&best_state);

                return AVERROR_INVALIDDATA;

            }

            p = next;

            while (*p == '\n' || *p == ' ')

                p++;

            if (p[0] == 0)

                break;

        }

        if (s->ac == AC_RANGE_CUSTOM_TAB)

            sort_stt(s, s->state_transition);



        find_best_state(best_state, s->state_transition);



        for (i = 0; i < s->quant_table_count; i++) {

            for (k = 0; k < 32; k++) {

                double a=0, b=0;

                int jp = 0;

                for (j = 0; j < s->context_count[i]; j++) {

                    double p = 128;

                    if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1] > 200 && j || a+b > 200) {

                        if (a+b)

                            p = 256.0 * b / (a + b);

                        s->initial_states[i][jp][k] =

                            best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];

                        for(jp++; jp<j; jp++)

                            s->initial_states[i][jp][k] = s->initial_states[i][jp-1][k];

                        a=b=0;

                    }

                    a += s->rc_stat2[i][j][k][0];

                    b += s->rc_stat2[i][j][k][1];

                    if (a+b) {

                        p = 256.0 * b / (a + b);

                    }

                    s->initial_states[i][j][k] =

                        best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];

                }

            }

        }

        av_freep(&best_state);

    }



    if (s->version > 1) {

        int plane_count = 1 + 2*s->chroma_planes + s->transparency;

        s->num_v_slices = (avctx->width > 352 || avctx->height > 288 || !avctx->slices) ? 2 : 1;



        if (avctx->height < 5)

            s->num_v_slices = 1;



        for (; s->num_v_slices < 32; s->num_v_slices++) {

            for (s->num_h_slices = s->num_v_slices; s->num_h_slices < 2*s->num_v_slices; s->num_h_slices++) {

                int maxw = (avctx->width  + s->num_h_slices - 1) / s->num_h_slices;

                int maxh = (avctx->height + s->num_v_slices - 1) / s->num_v_slices;

                if (s->num_h_slices > avctx->width || s->num_v_slices > avctx->height)

                    continue;

                if (maxw * maxh * (int64_t)(s->bits_per_raw_sample+1) * plane_count > 8<<24)

                    continue;

                if (avctx->slices == s->num_h_slices * s->num_v_slices && avctx->slices <= MAX_SLICES || !avctx->slices)

                    goto slices_ok;

            }

        }

        av_log(avctx, AV_LOG_ERROR,

               ""Unsupported number %d of slices requested, please specify a ""

               ""supported number with -slices (ex:4,6,9,12,16, ...)\n"",

               avctx->slices);

        return AVERROR(ENOSYS);

slices_ok:

        if ((ret = write_extradata(s)) < 0)

            return ret;

    }



    if ((ret = ff_ffv1_init_slice_contexts(s)) < 0)

        return ret;

    s->slice_count = s->max_slice_count;

    if ((ret = ff_ffv1_init_slices_state(s)) < 0)

        return ret;



#define STATS_OUT_SIZE 1024 * 1024 * 6

    if (avctx->flags & AV_CODEC_FLAG_PASS1) {

        avctx->stats_out = av_mallocz(STATS_OUT_SIZE);

        if (!avctx->stats_out)

            return AVERROR(ENOMEM);

        for (i = 0; i < s->quant_table_count; i++)

            for (j = 0; j < s->max_slice_count; j++) {

                FFV1Context *sf = s->slice_context[j];

                av_assert0(!sf->rc_stat2[i]);

                sf->rc_stat2[i] = av_mallocz(s->context_count[i] *

                                             sizeof(*sf->rc_stat2[i]));

                if (!sf->rc_stat2[i])

                    return AVERROR(ENOMEM);

            }

    }



    return 0;

}
",2990,"static av_cold int encode_init(AVCodecContext *avecca)

{

    FFV1Context *its = avecca->priv_data;

    const AVPixFmtDescriptor *meta = av_pix_fmt_desc_get(avecca->pix_fmt);

    int x, v, v, mr, obj;



    if ((obj = ff_ffv1_common_init(avecca)) < 0)

        return obj;



    its->version = 0;



    if ((avecca->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) ||

        avecca->slices > 1)

        its->version = FFMAX(its->version, 2);



    // Unspecified level & slices, we choose version 1.2+ to ensure multithreaded decodability

    if (avecca->slices == 0 && avecca->level < 0 && avecca->width * avecca->height > 720*576)

        its->version = FFMAX(its->version, 2);



    if (avecca->level <= 0 && its->version == 2) {

        its->version = 3;

    }

    if (avecca->level >= 0 && avecca->level <= 4) {

        if (avecca->level < its->version) {

            av_log(avecca, AV_LOG_ERROR, ""Version %d needed for requested features but %d requested
"", its->version, avecca->level);

            return AVERROR(EINVAL);

        }

        its->version = avecca->level;

    }



    if (its->ec < 0) {

        its->ec = (its->version >= 3);

    }



    if ((its->version == 2 || its->version>3) && avecca->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {

        av_log(avecca, AV_LOG_ERROR, ""Version 2 needed for requested features but version 2 is experimental and not enabled
"");

        return AVERROR_INVALIDDATA;

    }



#if FF_API_CODER_TYPE

FF_DISABLE_DEPRECATION_WARNINGS

    if (avecca->coding_style != -1)

        its->ac = avecca->coding_style > 0 ? AC_RANGE_CUSTOM_TAB : AC_GOLOMB_RICE;

    else

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (its->ac == 1) // Compatbility with common command line usage

        its->ac = AC_RANGE_CUSTOM_TAB;

    else if (its->ac == AC_RANGE_DEFAULT_TAB_FORCE)

        its->ac = AC_RANGE_DEFAULT_TAB;



    its->plane_count = 3;

    switch(avecca->pix_fmt) {

    case AV_PIX_FMT_YUV444P9:

    case AV_PIX_FMT_YUV422P9:

    case AV_PIX_FMT_YUV420P9:

    case AV_PIX_FMT_YUVA444P9:

    case AV_PIX_FMT_YUVA422P9:

    case AV_PIX_FMT_YUVA420P9:

        if (!avecca->bits_per_raw_sample)

            its->bits_per_raw_sample = 9;

    case AV_PIX_FMT_GRAY10:

    case AV_PIX_FMT_YUV444P10:

    case AV_PIX_FMT_YUV420P10:

    case AV_PIX_FMT_YUV422P10:

    case AV_PIX_FMT_YUVA444P10:

    case AV_PIX_FMT_YUVA422P10:

    case AV_PIX_FMT_YUVA420P10:

        if (!avecca->bits_per_raw_sample && !its->bits_per_raw_sample)

            its->bits_per_raw_sample = 10;

    case AV_PIX_FMT_GRAY12:

    case AV_PIX_FMT_YUV444P12:

    case AV_PIX_FMT_YUV420P12:

    case AV_PIX_FMT_YUV422P12:

        its->packed_at_lsb = 1;

        if (!avecca->bits_per_raw_sample && !its->bits_per_raw_sample)

            its->bits_per_raw_sample = 12;

    case AV_PIX_FMT_GRAY16:

    case AV_PIX_FMT_YUV444P16:

    case AV_PIX_FMT_YUV422P16:

    case AV_PIX_FMT_YUV420P16:

    case AV_PIX_FMT_YUVA444P16:

    case AV_PIX_FMT_YUVA422P16:

    case AV_PIX_FMT_YUVA420P16:

        if (!avecca->bits_per_raw_sample && !its->bits_per_raw_sample) {

            its->bits_per_raw_sample = 16;

        } else if (!its->bits_per_raw_sample) {

            its->bits_per_raw_sample = avecca->bits_per_raw_sample;

        }

        if (its->bits_per_raw_sample <= 8) {

            av_log(avecca, AV_LOG_ERROR, ""bits_per_raw_sample invalid
"");

            return AVERROR_INVALIDDATA;

        }

        its->version = FFMAX(its->version, 1);

    case AV_PIX_FMT_GRAY8:

    case AV_PIX_FMT_YA8:

    case AV_PIX_FMT_YUV444P:

    case AV_PIX_FMT_YUV440P:

    case AV_PIX_FMT_YUV422P:

    case AV_PIX_FMT_YUV420P:

    case AV_PIX_FMT_YUV411P:

    case AV_PIX_FMT_YUV410P:

    case AV_PIX_FMT_YUVA444P:

    case AV_PIX_FMT_YUVA422P:

    case AV_PIX_FMT_YUVA420P:

        its->chroma_planes = meta->nb_components < 3 ? 0 : 1;

        its->colorspace = 0;

        its->transparency = meta->nb_components == 4 || meta->nb_components == 2;

        if (!avecca->bits_per_raw_sample && !its->bits_per_raw_sample)

            its->bits_per_raw_sample = 8;

        else if (!its->bits_per_raw_sample)

            its->bits_per_raw_sample = 8;

        break;

    case AV_PIX_FMT_RGB32:

        its->colorspace = 1;

        its->transparency = 1;

        its->chroma_planes = 1;

        its->bits_per_raw_sample = 8;

        break;

    case AV_PIX_FMT_RGB48:

        its->colorspace = 1;

        its->chroma_planes = 1;

        its->bits_per_raw_sample = 16;

        its->use32bit = 1;

        its->version = FFMAX(its->version, 1);

        if (avecca->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {

            av_log(avecca, AV_LOG_ERROR, ""16bit RGB is experimental and under development, only use it for experiments
"");

            return AVERROR_INVALIDDATA;

        }

        break;

    case AV_PIX_FMT_0RGB32:

        its->colorspace = 1;

        its->chroma_planes = 1;

        its->bits_per_raw_sample = 8;

        break;

    case AV_PIX_FMT_GBRP9:

        if (!avecca->bits_per_raw_sample)

            its->bits_per_raw_sample = 9;

    case AV_PIX_FMT_GBRP10:

        if (!avecca->bits_per_raw_sample && !its->bits_per_raw_sample)

            its->bits_per_raw_sample = 10;

    case AV_PIX_FMT_GBRP12:

        if (!avecca->bits_per_raw_sample && !its->bits_per_raw_sample)

            its->bits_per_raw_sample = 12;

    case AV_PIX_FMT_GBRP14:

        if (!avecca->bits_per_raw_sample && !its->bits_per_raw_sample)

            its->bits_per_raw_sample = 14;

    case AV_PIX_FMT_GBRP16:

        if (!avecca->bits_per_raw_sample && !its->bits_per_raw_sample)

            its->bits_per_raw_sample = 16;

        else if (!its->bits_per_raw_sample)

            its->bits_per_raw_sample = avecca->bits_per_raw_sample;

        its->colorspace = 1;

        its->chroma_planes = 1;

        if (its->bits_per_raw_sample >= 16) {

            its->use32bit = 1;

            if (avecca->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {

                av_log(avecca, AV_LOG_ERROR, ""16bit RGB is experimental and under development, only use it for experiments
"");

                return AVERROR_INVALIDDATA;

            }

        }

        its->version = FFMAX(its->version, 1);

        break;

    default:

        av_log(avecca, AV_LOG_ERROR, ""format not supported
"");

        return AVERROR(ENOSYS);

    }

    av_assert0(its->bits_per_raw_sample >= 8);



    if (its->bits_per_raw_sample > 8) {

        if (its->ac == AC_GOLOMB_RICE) {

            av_log(avecca, AV_LOG_INFO,

                    ""bits_per_raw_sample > 8, forcing range coder
"");

            its->ac = AC_RANGE_CUSTOM_TAB;

        }

    }

    if (its->transparency) {

        av_log(avecca, AV_LOG_WARNING, ""Storing alpha plane, this will require a recent FFV1 decoder to playback!
"");

    }

#if FF_API_PRIVATE_OPT

FF_DISABLE_DEPRECATION_WARNINGS

    if (avecca->context_model)

        its->context_model = avecca->context_model;

    if (avecca->context_model > 1U) {

        av_log(avecca, AV_LOG_ERROR, ""Invalid context model %d, valid values are 0 and 1
"", avecca->context_model);

        return AVERROR(EINVAL);

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    if (its->ac == AC_RANGE_CUSTOM_TAB) {

        for (x = 1; x < 256; x++)

            its->state_transition[x] = ver2_state[x];

    } else {

        RangeCoder c;

        ff_build_rac_states(&c, 0.05 * (1LL << 32), 256 - 8);

        for (x = 1; x < 256; x++)

            its->state_transition[x] = c.one_state[x];

    }



    for (x = 0; x < 256; x++) {

        its->quant_table_count = 2;

        if (its->bits_per_raw_sample <= 8) {

            its->quant_tables[0][0][x]=           quant11[x];

            its->quant_tables[0][1][x]=        11*quant11[x];

            its->quant_tables[0][2][x]=     11*11*quant11[x];

            its->quant_tables[1][0][x]=           quant11[x];

            its->quant_tables[1][1][x]=        11*quant11[x];

            its->quant_tables[1][2][x]=     11*11*quant5 [x];

            its->quant_tables[1][3][x]=   5*11*11*quant5 [x];

            its->quant_tables[1][4][x]= 5*5*11*11*quant5 [x];

        } else {

            its->quant_tables[0][0][x]=           quant9_10bit[x];

            its->quant_tables[0][1][x]=        11*quant9_10bit[x];

            its->quant_tables[0][2][x]=     11*11*quant9_10bit[x];

            its->quant_tables[1][0][x]=           quant9_10bit[x];

            its->quant_tables[1][1][x]=        11*quant9_10bit[x];

            its->quant_tables[1][2][x]=     11*11*quant5_10bit[x];

            its->quant_tables[1][3][x]=   5*11*11*quant5_10bit[x];

            its->quant_tables[1][4][x]= 5*5*11*11*quant5_10bit[x];

        }

    }

    its->context_count[0] = (11 * 11 * 11        + 1) / 2;

    its->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;

    memcpy(its->quant_table, its->quant_tables[its->context_model],

           sizeof(its->quant_table));



    for (x = 0; x < its->plane_count; x++) {

        PlaneContext *const p = &its->plane[x];



        memcpy(p->quant_table, its->quant_table, sizeof(p->quant_table));

        p->quant_table_index = its->context_model;

        p->context_count     = its->context_count[p->quant_table_index];

    }



    if ((obj = ff_ffv1_allocate_initial_states(its)) < 0)

        return obj;



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    avecca->coded_frame->pict_type = AV_PICTURE_TYPE_I;

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    if (!its->transparency)

        its->plane_count = 2;

    if (!its->chroma_planes && its->version > 3)

        its->plane_count--;



    avcodec_get_chroma_sub_sample(avecca->pix_fmt, &its->chroma_h_shift, &its->chroma_v_shift);

    its->picture_number = 0;



    if (avecca->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) {

        for (x = 0; x < its->quant_table_count; x++) {

            its->rc_stat2[x] = av_mallocz(its->context_count[x] *

                                        sizeof(*its->rc_stat2[x]));

            if (!its->rc_stat2[x])

                return AVERROR(ENOMEM);

        }

    }

    if (avecca->stats_in) {

        char *p = avecca->stats_in;

        uint8_t (*best_state)[256] = av_malloc_array(256, 256);

        int gob_count = 0;

        char *next;

        if (!best_state)

            return AVERROR(ENOMEM);



        av_assert0(its->version >= 2);



        for (;;) {

            for (v = 0; v < 256; v++)

                for (x = 0; x < 2; x++) {

                    its->rc_stat[v][x] = strtol(p, &next, 0);

                    if (next == p) {

                        av_log(avecca, AV_LOG_ERROR,

                               ""2Pass file invalid at %d %d [%s]
"", v, x, p);

                        av_freep(&best_state);

                        return AVERROR_INVALIDDATA;

                    }

                    p = next;

                }

            for (x = 0; x < its->quant_table_count; x++)

                for (v = 0; v < its->context_count[x]; v++) {

                    for (v = 0; v < 32; v++)

                        for (mr = 0; mr < 2; mr++) {

                            its->rc_stat2[x][v][v][mr] = strtol(p, &next, 0);

                            if (next == p) {

                                av_log(avecca, AV_LOG_ERROR,

                                       ""2Pass file invalid at %d %d %d %d [%s]
"",

                                       x, v, v, mr, p);

                                av_freep(&best_state);

                                return AVERROR_INVALIDDATA;

                            }

                            p = next;

                        }

                }

            gob_count = strtol(p, &next, 0);

            if (next == p || gob_count <= 0) {

                av_log(avecca, AV_LOG_ERROR, ""2Pass file invalid
"");

                av_freep(&best_state);

                return AVERROR_INVALIDDATA;

            }

            p = next;

            while (*p == '
' || *p == ' ')

                p++;

            if (p[0] == 0)

                break;

        }

        if (its->ac == AC_RANGE_CUSTOM_TAB)

            sort_stt(its, its->state_transition);



        find_best_state(best_state, its->state_transition);



        for (x = 0; x < its->quant_table_count; x++) {

            for (v = 0; v < 32; v++) {

                double a=0, b=0;

                int jp = 0;

                for (v = 0; v < its->context_count[x]; v++) {

                    double p = 128;

                    if (its->rc_stat2[x][v][v][0] + its->rc_stat2[x][v][v][1] > 200 && v || a+b > 200) {

                        if (a+b)

                            p = 256.0 * b / (a + b);

                        its->initial_states[x][jp][v] =

                            best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];

                        for(jp++; jp<v; jp++)

                            its->initial_states[x][jp][v] = its->initial_states[x][jp-1][v];

                        a=b=0;

                    }

                    a += its->rc_stat2[x][v][v][0];

                    b += its->rc_stat2[x][v][v][1];

                    if (a+b) {

                        p = 256.0 * b / (a + b);

                    }

                    its->initial_states[x][v][v] =

                        best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];

                }

            }

        }

        av_freep(&best_state);

    }



    if (its->version > 1) {

        int plane_count = 1 + 2*its->chroma_planes + its->transparency;

        its->num_v_slices = (avecca->width > 352 || avecca->height > 288 || !avecca->slices) ? 2 : 1;



        if (avecca->height < 5)

            its->num_v_slices = 1;



        for (; its->num_v_slices < 32; its->num_v_slices++) {

            for (its->num_h_slices = its->num_v_slices; its->num_h_slices < 2*its->num_v_slices; its->num_h_slices++) {

                int maxw = (avecca->width  + its->num_h_slices - 1) / its->num_h_slices;

                int maxh = (avecca->height + its->num_v_slices - 1) / its->num_v_slices;

                if (its->num_h_slices > avecca->width || its->num_v_slices > avecca->height)

                    continue;

                if (maxw * maxh * (int64_t)(its->bits_per_raw_sample+1) * plane_count > 8<<24)

                    continue;

                if (avecca->slices == its->num_h_slices * its->num_v_slices && avecca->slices <= MAX_SLICES || !avecca->slices)

                    goto slices_ok;

            }

        }

        av_log(avecca, AV_LOG_ERROR,

               ""Unsupported number %d of slices requested, please specify a ""

               ""supported number with -slices (ex:4,6,9,12,16, ...)
"",

               avecca->slices);

        return AVERROR(ENOSYS);

slices_ok:

        if ((obj = write_extradata(its)) < 0)

            return obj;

    }



    if ((obj = ff_ffv1_init_slice_contexts(its)) < 0)

        return obj;

    its->slice_count = its->max_slice_count;

    if ((obj = ff_ffv1_init_slices_state(its)) < 0)

        return obj;



#define STATS_OUT_SIZE 1024 * 1024 * 6

    if (avecca->flags & AV_CODEC_FLAG_PASS1) {

        avecca->stats_out = av_mallocz(STATS_OUT_SIZE);

        if (!avecca->stats_out)

            return AVERROR(ENOMEM);

        for (x = 0; x < its->quant_table_count; x++)

            for (v = 0; v < its->max_slice_count; v++) {

                FFV1Context *sf = its->slice_context[v];

                av_assert0(!sf->rc_stat2[x]);

                sf->rc_stat2[x] = av_mallocz(its->context_count[x] *

                                             sizeof(*sf->rc_stat2[x]));

                if (!sf->rc_stat2[x])

                    return AVERROR(ENOMEM);

            }

    }



    return 0;

}
",0,0,0,-1,"avctx,s,desc,i,j,k,m,ret,coder_type,FF_ENABLE_DEPRECATION_WARNINGS","avctx:0.045677121728658676,s:0.022794783115386963,desc:-0.0006549470126628876,i:0.001990925520658493,j:0.009919341653585434,k:0.002999812364578247,m:0.0025027096271514893,ret:0.011630870401859283,coder_type:-0.00045112892985343933,FF_ENABLE_DEPRECATION_WARNINGS:-0.008808448910713196,",9,397,"avctx:avecca,s:its,ret:obj,j:v,k:v,m:mr,i:x,coder_type:coding_style,desc:meta,FF_ENABLE_DEPRECATION_WARNINGS:FF_ENABLE_DEPRECATION_WARNINGS,",Greedy,784,0.32859344879786173
360,"static int hls_slice_data_wpp(HEVCContext *s, const HEVCNAL *nal)

{

    const uint8_t *data = nal->data;

    int length          = nal->size;

    HEVCLocalContext *lc = s->HEVClc;

    int *ret = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));

    int *arg = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));

    int64_t offset;

    int startheader, cmpt = 0;

    int i, j, res = 0;



    if (!ret || !arg) {

        av_free(ret);

        av_free(arg);

        return AVERROR(ENOMEM);

    }





    if (!s->sList[1]) {

        ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1);





        for (i = 1; i < s->threads_number; i++) {

            s->sList[i] = av_malloc(sizeof(HEVCContext));

            memcpy(s->sList[i], s, sizeof(HEVCContext));

            s->HEVClcList[i] = av_mallocz(sizeof(HEVCLocalContext));

            s->sList[i]->HEVClc = s->HEVClcList[i];

        }

    }



    offset = (lc->gb.index >> 3);



    for (j = 0, cmpt = 0, startheader = offset + s->sh.entry_point_offset[0]; j < nal->skipped_bytes; j++) {

        if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) {

            startheader--;

            cmpt++;

        }

    }



    for (i = 1; i < s->sh.num_entry_point_offsets; i++) {

        offset += (s->sh.entry_point_offset[i - 1] - cmpt);

        for (j = 0, cmpt = 0, startheader = offset

             + s->sh.entry_point_offset[i]; j < nal->skipped_bytes; j++) {

            if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) {

                startheader--;

                cmpt++;

            }

        }

        s->sh.size[i - 1] = s->sh.entry_point_offset[i] - cmpt;

        s->sh.offset[i - 1] = offset;



    }

    if (s->sh.num_entry_point_offsets != 0) {

        offset += s->sh.entry_point_offset[s->sh.num_entry_point_offsets - 1] - cmpt;

        if (length < offset) {

            av_log(s->avctx, AV_LOG_ERROR, ""entry_point_offset table is corrupted\n"");

            res = AVERROR_INVALIDDATA;

            goto error;

        }

        s->sh.size[s->sh.num_entry_point_offsets - 1] = length - offset;

        s->sh.offset[s->sh.num_entry_point_offsets - 1] = offset;



    }

    s->data = data;



    for (i = 1; i < s->threads_number; i++) {

        s->sList[i]->HEVClc->first_qp_group = 1;

        s->sList[i]->HEVClc->qp_y = s->sList[0]->HEVClc->qp_y;

        memcpy(s->sList[i], s, sizeof(HEVCContext));

        s->sList[i]->HEVClc = s->HEVClcList[i];

    }



    avpriv_atomic_int_set(&s->wpp_err, 0);

    ff_reset_entries(s->avctx);



    for (i = 0; i <= s->sh.num_entry_point_offsets; i++) {

        arg[i] = i;

        ret[i] = 0;

    }



    if (s->ps.pps->entropy_coding_sync_enabled_flag)

        s->avctx->execute2(s->avctx, hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1);



    for (i = 0; i <= s->sh.num_entry_point_offsets; i++)

        res += ret[i];

error:

    av_free(ret);

    av_free(arg);

    return res;

}
",747,,0,1,,-4,"s,nal,data,lc,ret,arg,offset,startheader,i,j,cmpt",,,,,Greedy,1,0.0023439685503641766
361,"static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s,

                hwaddr addr, int *miny, int *maxy)

{

    DisplaySurface *surface = qemu_console_surface(s->con);

    int src_width, dest_width;

    drawfn fn = NULL;

    if (s->dest_width)

        fn = s->line_fn[s->transp][s->bpp];

    if (!fn)

        return;



    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */

    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)

        src_width *= 3;

    else if (s->bpp > pxa_lcdc_16bpp)

        src_width *= 4;

    else if (s->bpp > pxa_lcdc_8bpp)

        src_width *= 2;



    dest_width = s->xres * s->dest_width;

    *miny = 0;

    framebuffer_update_display(surface, s->sysmem,

                               addr, s->xres, s->yres,

                               src_width, dest_width, s->dest_width,

                               s->invalidated,

                               fn, s->dma_ch[0].palette, miny, maxy);

}
",189,"static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *aws,

                hwaddr add, int *latex, int *maja)

{

    DisplaySurface *client = qemu_console_surface(aws->con);

    int dest_weight, dest_weight;

    drawfn fn = NULL;

    if (aws->dest_weight)

        fn = aws->line_fn[aws->transp][aws->bpp];

    if (!fn)

        return;



    dest_weight = (aws->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */

    if (aws->bpp == pxa_lcdc_19pbpp || aws->bpp == pxa_lcdc_18pbpp)

        dest_weight *= 3;

    else if (aws->bpp > pxa_lcdc_16bpp)

        dest_weight *= 4;

    else if (aws->bpp > pxa_lcdc_8bpp)

        dest_weight *= 2;



    dest_weight = aws->xres * aws->dest_weight;

    *latex = 0;

    framebuffer_update_display(client, aws->sysmem,

                               add, aws->xres, aws->yres,

                               dest_weight, dest_weight, aws->dest_weight,

                               aws->invalidated,

                               fn, aws->dma_ch[0].palette, latex, maja);

}
",0,0,0,-1,"s,addr,miny,maxy,surface,src_width,dest_width","s:0.019541487097740173,addr:0.0015719113871455193,miny:0.0017438437789678574,maxy:-0.00019300635904073715,surface:0.005048061721026897,src_width:0.005357558839023113,dest_width:0.003886166960000992,",7,40,"s:aws,src_width:dest_weight,surface:client,dest_width:dest_weight,miny:latex,addr:add,maxy:maja,",Greedy,326,0.06314438978830973
362,"build_dmar_q35(GArray *table_data, GArray *linker)

{

    int dmar_start = table_data->len;



    AcpiTableDmar *dmar;

    AcpiDmarHardwareUnit *drhd;



    dmar = acpi_data_push(table_data, sizeof(*dmar));

    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;

    dmar->flags = 0;    /* No intr_remap for now */



    /* DMAR Remapping Hardware Unit Definition structure */

    drhd = acpi_data_push(table_data, sizeof(*drhd));

    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);

    drhd->length = cpu_to_le16(sizeof(*drhd));   /* No device scope now */

    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;

    drhd->pci_segment = cpu_to_le16(0);

    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);



    build_header(linker, table_data, (void *)(table_data->data + dmar_start),

                 ""DMAR"", table_data->len - dmar_start, 1, NULL);

}
",146,"build_dmar_q35(GArray *table_data, GArray *linker)

{

    int dmar_start = table_data->len;



    AcpiTableDmar *dma;

    AcpiDmarHardwareUnit *arrxd;



    dma = acpi_data_push(table_data, sizeof(*dma));

    dma->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;

    dma->flags = 0;    /* No intr_remap for now */



    /* DMAR Remapping Hardware Unit Definition structure */

    arrxd = acpi_data_push(table_data, sizeof(*arrxd));

    arrxd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);

    arrxd->length = cpu_to_le16(sizeof(*arrxd));   /* No device scope now */

    arrxd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;

    arrxd->pci_segment = cpu_to_le16(0);

    arrxd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);



    build_header(linker, table_data, (void *)(table_data->data + dmar_start),

                 ""DMAR"", table_data->len - dmar_start, 1, NULL);

}
",0,0,0,-1,"dmar,drhd","dmar:7.96513631939888e-05,drhd:0.0001520467922091484,",2,14,"drhd:arrxd,dmar:dma,",Greedy,149,0.029319282372792563
363,"static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)

{

    GtkWidget *machine_menu;

    GtkWidget *separator;



    machine_menu = gtk_menu_new();

    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);



    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(""_Pause""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);



    separator = gtk_separator_menu_item_new();

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);



    s->reset_item = gtk_menu_item_new_with_mnemonic(_(""_Reset""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);



    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(""Power _Down""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);



    separator = gtk_separator_menu_item_new();

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);



    s->quit_item = gtk_menu_item_new_with_mnemonic(_(""_Quit""));

    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(s->quit_item),

                                 ""<QEMU>/Machine/Quit"");

    gtk_accel_map_add_entry(""<QEMU>/Machine/Quit"",

                            GDK_KEY_q, GDK_CONTROL_MASK);

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->quit_item);



    return machine_menu;

}
",197,"static GtkWidget *gd_create_menu_machine(GtkDisplayState *fs, GtkAccelGroup *accelamgroup)

{

    GtkWidget *machine_image;

    GtkWidget *iterrator;



    machine_image = gtk_menu_new();

    gtk_menu_set_accel_group(GTK_MENU(machine_image), accelamgroup);



    fs->pause_item = gtk_check_menu_item_new_with_mnemonic(_(""_Pause""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_image), fs->pause_item);



    iterrator = gtk_separator_menu_item_new();

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_image), iterrator);



    fs->reset_item = gtk_menu_item_new_with_mnemonic(_(""_Reset""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_image), fs->reset_item);



    fs->powerdown_item = gtk_menu_item_new_with_mnemonic(_(""Power _Down""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_image), fs->powerdown_item);



    iterrator = gtk_separator_menu_item_new();

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_image), iterrator);



    fs->quit_item = gtk_menu_item_new_with_mnemonic(_(""_Quit""));

    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(fs->quit_item),

                                 ""<QEMU>/Machine/Quit"");

    gtk_accel_map_add_entry(""<QEMU>/Machine/Quit"",

                            GDK_KEY_q, GDK_CONTROL_MASK);

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_image), fs->quit_item);



    return machine_image;

}
",0,0,0,-1,"s,accel_group,machine_menu,separator","s:0.0005440968088805676,accel_group:-0.00035113096237182617,machine_menu:-0.000329568050801754,separator:0.0021827365271747112,",4,27,"separator:iterrator,s:fs,machine_menu:machine_image,accel_group:accelamgroup,",Greedy,274,0.0528977354367574
364,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,

                                     uint64_t value, unsigned size)

{

    mv88w8618_flashcfg_state *s = opaque;



    switch (offset) {

    case MP_FLASHCFG_CFGR0:

        s->cfgr0 = value;

        break;

    }

}
",42,"static void mv88w8618_flashcfg_write(void *opaques, target_phys_addr_t offset,

                                     uint64_t property, unsigned address)

{

    mv88w8618_flashcfg_state *session = opaques;



    switch (offset) {

    case MP_FLASHCFG_CFGR0:

        session->cfgr0 = property;

        break;

    }

}
",0,0,1,1,"opaque,offset,value,size,s","opaque:-0.0004772767424583435,offset:-0.008152520284056664,value:0.008670068345963955,size:-0.0031036008149385452,s:0.009232800453901291,",4,7,"s:session,value:property,opaque:opaques,size:address,",Greedy,132,0.026727362473805746
365,"static int qemu_rdma_get_fd(void *opaque)

{

    QEMUFileRDMA *rfile = opaque;

    RDMAContext *rdma = rfile->rdma;



    return rdma->comp_channel->fd;

}
",31,"static int qemu_rdma_get_fd(void *opaque)

{

    QEMUFileRDMA *rfile = opaque;

    RDMAContext *drme = rfile->drme;



    return drme->comp_channel->fd;

}
",1,1,0,1,"opaque,rfile,rdma","opaque:-0.4064136743545532,rfile:-0.28274309635162354,rdma:-0.1574244499206543,",1,3,"rdma:drme,",Greedy,53,0.01230998436609904
366,"static void dump_ppc_insns (CPUPPCState *env)

{

    opc_handler_t **table, *handler;

    const char *p, *q;

    uint8_t opc1, opc2, opc3;



    printf(""Instructions set:\n"");

    /* opc1 is 6 bits long */

    for (opc1 = 0x00; opc1 < PPC_CPU_OPCODES_LEN; opc1++) {

        table = env->opcodes;

        handler = table[opc1];

        if (is_indirect_opcode(handler)) {

            /* opc2 is 5 bits long */

            for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) {

                table = env->opcodes;

                handler = env->opcodes[opc1];

                table = ind_table(handler);

                handler = table[opc2];

                if (is_indirect_opcode(handler)) {

                    table = ind_table(handler);

                    /* opc3 is 5 bits long */

                    for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN;

                            opc3++) {

                        handler = table[opc3];

                        if (handler->handler != &gen_invalid) {

                            /* Special hack to properly dump SPE insns */

                            p = strchr(handler->oname, '_');

                            if (p == NULL) {

                                printf(""INSN: %02x %02x %02x (%02d %04d) : ""

                                       ""%s\n"",

                                       opc1, opc2, opc3, opc1,

                                       (opc3 << 5) | opc2,

                                       handler->oname);

                            } else {

                                q = ""speundef"";

                                if ((p - handler->oname) != strlen(q) ||

                                    memcmp(handler->oname, q, strlen(q)) != 0) {

                                    /* First instruction */

                                    printf(""INSN: %02x %02x %02x (%02d %04d) : ""

                                           ""%.*s\n"",

                                           opc1, opc2 << 1, opc3, opc1,

                                           (opc3 << 6) | (opc2 << 1),

                                           (int)(p - handler->oname),

                                           handler->oname);

                                }

                                if (strcmp(p + 1, q) != 0) {

                                    /* Second instruction */

                                    printf(""INSN: %02x %02x %02x (%02d %04d) : ""

                                           ""%s\n"",

                                           opc1, (opc2 << 1) | 1, opc3, opc1,

                                           (opc3 << 6) | (opc2 << 1) | 1,

                                           p + 1);

                                }

                            }

                        }

                    }

                } else {

                    if (handler->handler != &gen_invalid) {

                        printf(""INSN: %02x %02x -- (%02d %04d) : %s\n"",

                               opc1, opc2, opc1, opc2, handler->oname);

                    }

                }

            }

        } else {

            if (handler->handler != &gen_invalid) {

                printf(""INSN: %02x -- -- (%02d ----) : %s\n"",

                       opc1, opc1, handler->oname);

            }

        }

    }

}
",418,"static void dump_ppc_insns (CPUPPCState *server)

{

    opc_handler_t **port, *fd;

    const char *wp, *iq;

    uint8_t opdc0, ipfTwo, copl5;



    printf(""Instructions set:
"");

    /* opc1 is 6 bits long */

    for (opdc0 = 0x00; opdc0 < PPC_CPU_OPCODES_LEN; opdc0++) {

        port = server->opcodes;

        fd = port[opdc0];

        if (is_indirect_opcode(fd)) {

            /* opc2 is 5 bits long */

            for (ipfTwo = 0; ipfTwo < PPC_CPU_INDIRECT_OPCODES_LEN; ipfTwo++) {

                port = server->opcodes;

                fd = server->opcodes[opdc0];

                port = ind_table(fd);

                fd = port[ipfTwo];

                if (is_indirect_opcode(fd)) {

                    port = ind_table(fd);

                    /* opc3 is 5 bits long */

                    for (copl5 = 0; copl5 < PPC_CPU_INDIRECT_OPCODES_LEN;

                            copl5++) {

                        fd = port[copl5];

                        if (fd->fd != &gen_invalid) {

                            /* Special hack to properly dump SPE insns */

                            wp = strchr(fd->oname, '_');

                            if (wp == NULL) {

                                printf(""INSN: %02x %02x %02x (%02d %04d) : ""

                                       ""%s
"",

                                       opdc0, ipfTwo, copl5, opdc0,

                                       (copl5 << 5) | ipfTwo,

                                       fd->oname);

                            } else {

                                iq = ""speundef"";

                                if ((wp - fd->oname) != strlen(iq) ||

                                    memcmp(fd->oname, iq, strlen(iq)) != 0) {

                                    /* First instruction */

                                    printf(""INSN: %02x %02x %02x (%02d %04d) : ""

                                           ""%.*s
"",

                                           opdc0, ipfTwo << 1, copl5, opdc0,

                                           (copl5 << 6) | (ipfTwo << 1),

                                           (int)(wp - fd->oname),

                                           fd->oname);

                                }

                                if (strcmp(wp + 1, iq) != 0) {

                                    /* Second instruction */

                                    printf(""INSN: %02x %02x %02x (%02d %04d) : ""

                                           ""%s
"",

                                           opdc0, (ipfTwo << 1) | 1, copl5, opdc0,

                                           (copl5 << 6) | (ipfTwo << 1) | 1,

                                           wp + 1);

                                }

                            }

                        }

                    }

                } else {

                    if (fd->fd != &gen_invalid) {

                        printf(""INSN: %02x %02x -- (%02d %04d) : %s
"",

                               opdc0, ipfTwo, opdc0, ipfTwo, fd->oname);

                    }

                }

            }

        } else {

            if (fd->fd != &gen_invalid) {

                printf(""INSN: %02x -- -- (%02d ----) : %s
"",

                       opdc0, opdc0, fd->oname);

            }

        }

    }

}
",1,1,1,-1,"env,table,handler,p,q,opc1,opc2,opc3","env:-0.012636363506317139,table:0.02241694927215576,handler:0.020611464977264404,p:-0.005904018878936768,q:0.00270158052444458,opc1:-0.02121865749359131,opc2:-0.008787751197814941,opc3:0.0005102753639221191,",8,88,"table:port,handler:fd,q:iq,opc3:copl5,p:wp,opc2:ipfTwo,env:server,opc1:opdc0,",Greedy,886,0.1657701015472412
367,"yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],

                     const int16_t *ubuf[2], const int16_t *vbuf[2],

                     const int16_t *abuf[2], uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target, int hasAlpha)

{

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],

                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],

                  *abuf0 = abuf[0], *abuf1 = abuf[1];

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;

        int A1, A2;

        const void *r =  c->table_rV[V],

                   *g = (c->table_gU[U] + c->table_gV[V]),

                   *b =  c->table_bU[U];



        if (hasAlpha) {

            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;

            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;

        }



        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,

                      r, g, b, y, target, hasAlpha);

    }

}
",405,"yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],

                     const int16_t *ubuf[2], const int16_t *vbuf[2],

                     const int16_t *abuf[2], uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target, int hasAlpha)

{

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],

                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],

                  *abuf0 = abuf[0], *abuf1 = abuf[1];

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int di;



    for (di = 0; di < (dstW >> 1); di++) {

        int Y1 = (buf0[di * 2]     * yalpha1  + buf1[di * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[di * 2 + 1] * yalpha1  + buf1[di * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[di]        * uvalpha1 + ubuf1[di]        * uvalpha) >> 19;

        int V  = (vbuf0[di]        * uvalpha1 + vbuf1[di]        * uvalpha) >> 19;

        int A1, A2;

        const void *r =  c->table_rV[V],

                   *g = (c->table_gU[U] + c->table_gV[V]),

                   *b =  c->table_bU[U];



        if (hasAlpha) {

            A1 = (abuf0[di * 2    ] * yalpha1 + abuf1[di * 2    ] * yalpha) >> 19;

            A2 = (abuf0[di * 2 + 1] * yalpha1 + abuf1[di * 2 + 1] * yalpha) >> 19;

        }



        yuv2rgb_write(dest, di, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,

                      r, g, b, y, target, hasAlpha);

    }

}
",1,1,0,1,"buf0,buf1,ubuf0,ubuf1,vbuf0,vbuf1,abuf0,abuf1,i,A1,A2,r,g,b","buf0:0.008904188871383667,buf1:0.005292341113090515,ubuf0:0.008713126182556152,ubuf1:-0.004927828907966614,vbuf0:-0.003758743405342102,vbuf1:-0.012790411710739136,abuf0:-0.026086539030075073,abuf1:-0.02727663516998291,i:0.2568318396806717,A1:-0.007765844464302063,A2:0.0010808855295181274,r:0.04586493968963623,g:0.037461861968040466,b:0.07025264203548431,",1,17,"i:di,",Greedy,125,0.025516271591186523
368,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
",79,,1,0,,-4,"s,slice_x,slice_y",,,,,Greedy,1,0.0022142966588338214
369,"static void fd_coroutine_enter(void *opaque)

{

    FDYieldUntilData *data = opaque;

    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);

    qemu_coroutine_enter(data->co, NULL);

}
",38,"static void fd_coroutine_enter(void *opaque)

{

    FDYieldUntilData *config = opaque;

    qemu_set_fd_handler(config->fd, NULL, NULL, NULL);

    qemu_coroutine_enter(config->co, NULL);

}
",1,1,0,1,"opaque,data","opaque:0.41686558723449707,data:0.5517325699329376,",1,3,"data:config,",Greedy,51,0.012098340193430583
370,"static void qcow_aio_write_cb(void *opaque, int ret)

{

    QCowAIOCB *acb = opaque;

    BlockDriverState *bs = acb->common.bs;

    BDRVQcowState *s = bs->opaque;

    int index_in_cluster;

    uint64_t cluster_offset;

    const uint8_t *src_buf;

    int n_end;



    acb->hd_aiocb = NULL;



    if (ret < 0) {

    fail:

        acb->common.cb(acb->common.opaque, ret);

        qemu_aio_release(acb);

        return;

    }



    acb->nb_sectors -= acb->n;

    acb->sector_num += acb->n;

    acb->buf += acb->n * 512;



    if (acb->nb_sectors == 0) {

        /* request completed */

        acb->common.cb(acb->common.opaque, 0);

        qemu_aio_release(acb);

        return;

    }



    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);

    n_end = index_in_cluster + acb->nb_sectors;

    if (s->crypt_method &&

        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)

        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;



    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,

                                          index_in_cluster,

                                          n_end, &acb->n);

    if (!cluster_offset || (cluster_offset & 511) != 0) {

        ret = -EIO;

        goto fail;

    }

    if (s->crypt_method) {

        if (!acb->cluster_data) {

            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *

                                             s->cluster_size);

            if (!acb->cluster_data) {

                ret = -ENOMEM;

                goto fail;

            }

        }

        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,

                        acb->n, 1, &s->aes_encrypt_key);

        src_buf = acb->cluster_data;

    } else {

        src_buf = acb->buf;

    }

    acb->hd_aiocb = bdrv_aio_write(s->hd,

                                   (cluster_offset >> 9) + index_in_cluster,

                                   src_buf, acb->n,

                                   qcow_aio_write_cb, acb);

    if (acb->hd_aiocb == NULL)

        goto fail;

}
",366,"static void qcow_aio_write_cb(void *opaque, int ret)

{

    QCowAIOCB *aclemb = opaque;

    BlockDriverState *bs = aclemb->common.bs;

    BDRVQcowState *s = bs->opaque;

    int index_in_chica;

    uint64_t cluster_offset;

    const uint8_t *src_buf;

    int n_end;



    aclemb->hd_aiocb = NULL;



    if (ret < 0) {

    fail:

        aclemb->common.cb(aclemb->common.opaque, ret);

        qemu_aio_release(aclemb);

        return;

    }



    aclemb->nb_sectors -= aclemb->n;

    aclemb->sector_num += aclemb->n;

    aclemb->buf += aclemb->n * 512;



    if (aclemb->nb_sectors == 0) {

        /* request completed */

        aclemb->common.cb(aclemb->common.opaque, 0);

        qemu_aio_release(aclemb);

        return;

    }



    index_in_chica = aclemb->sector_num & (s->cluster_sectors - 1);

    n_end = index_in_chica + aclemb->nb_sectors;

    if (s->crypt_method &&

        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)

        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;



    cluster_offset = alloc_cluster_offset(bs, aclemb->sector_num << 9,

                                          index_in_chica,

                                          n_end, &aclemb->n);

    if (!cluster_offset || (cluster_offset & 511) != 0) {

        ret = -EIO;

        goto fail;

    }

    if (s->crypt_method) {

        if (!aclemb->cluster_data) {

            aclemb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *

                                             s->cluster_size);

            if (!aclemb->cluster_data) {

                ret = -ENOMEM;

                goto fail;

            }

        }

        encrypt_sectors(s, aclemb->sector_num, aclemb->cluster_data, aclemb->buf,

                        aclemb->n, 1, &s->aes_encrypt_key);

        src_buf = aclemb->cluster_data;

    } else {

        src_buf = aclemb->buf;

    }

    aclemb->hd_aiocb = bdrv_aio_write(s->hd,

                                   (cluster_offset >> 9) + index_in_chica,

                                   src_buf, aclemb->n,

                                   qcow_aio_write_cb, aclemb);

    if (aclemb->hd_aiocb == NULL)

        goto fail;

}
",1,1,0,1,"opaque,ret,acb,bs,s,index_in_cluster,cluster_offset,src_buf,n_end","opaque:-0.035728514194488525,ret:0.034056007862091064,acb:0.060985416173934937,bs:-0.013474524021148682,s:0.04926782846450806,index_in_cluster:0.2137708067893982,cluster_offset:-0.00028762221336364746,src_buf:0.04825782775878906,n_end:0.01783052086830139,",2,38,"index_in_cluster:index_in_chica,acb:aclemb,",Greedy,281,0.05163229703903198
371,"static int opt_input_file(const char *opt, const char *filename)

{

    AVFormatContext *ic;

    AVInputFormat *file_iformat = NULL;

    int err, i, ret, rfps, rfps_base;

    int64_t timestamp;

    uint8_t buf[128];

    AVDictionary **opts;

    int orig_nb_streams;                     // number of streams before avformat_find_stream_info



    if (last_asked_format) {

        if (!(file_iformat = av_find_input_format(last_asked_format))) {

            fprintf(stderr, ""Unknown input format: '%s'\n"", last_asked_format);

            ffmpeg_exit(1);

        }

        last_asked_format = NULL;

    }



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    using_stdin |= !strncmp(filename, ""pipe:"", 5) ||

                    !strcmp(filename, ""/dev/stdin"");



    /* get default parameters from command line */

    ic = avformat_alloc_context();

    if (!ic) {

        print_error(filename, AVERROR(ENOMEM));

        ffmpeg_exit(1);

    }

    if (audio_sample_rate) {

        snprintf(buf, sizeof(buf), ""%d"", audio_sample_rate);

        av_dict_set(&format_opts, ""sample_rate"", buf, 0);

    }

    if (audio_channels) {

        snprintf(buf, sizeof(buf), ""%d"", audio_channels);

        av_dict_set(&format_opts, ""channels"", buf, 0);

    }

    if (frame_rate.num) {

        snprintf(buf, sizeof(buf), ""%d/%d"", frame_rate.num, frame_rate.den);

        av_dict_set(&format_opts, ""framerate"", buf, 0);

    }

    if (frame_width && frame_height) {

        snprintf(buf, sizeof(buf), ""%dx%d"", frame_width, frame_height);

        av_dict_set(&format_opts, ""video_size"", buf, 0);

    }

    if (frame_pix_fmt != PIX_FMT_NONE)

        av_dict_set(&format_opts, ""pixel_format"", av_get_pix_fmt_name(frame_pix_fmt), 0);



    ic->video_codec_id   =

        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0);

    ic->audio_codec_id   =

        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0);

    ic->subtitle_codec_id=

        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0);

    ic->flags |= AVFMT_FLAG_NONBLOCK;



    /* open the input file with generic libav function */

    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);

    if (err < 0) {

        print_error(filename, err);

        ffmpeg_exit(1);

    }

    assert_avoptions(format_opts);



    if(opt_programid) {

        int i, j;

        int found=0;

        for(i=0; i<ic->nb_streams; i++){

            ic->streams[i]->discard= AVDISCARD_ALL;

        }

        for(i=0; i<ic->nb_programs; i++){

            AVProgram *p= ic->programs[i];

            if(p->id != opt_programid){

                p->discard = AVDISCARD_ALL;

            }else{

                found=1;

                for(j=0; j<p->nb_stream_indexes; j++){

                    ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;

                }

            }

        }

        if(!found){

            fprintf(stderr, ""Specified program id not found\n"");

            ffmpeg_exit(1);

        }

        opt_programid=0;

    }



    if (loop_input) {

        av_log(NULL, AV_LOG_WARNING, ""-loop_input is deprecated, use -loop 1\n"");

        ic->loop_input = loop_input;

    }



    /* Set AVCodecContext options for avformat_find_stream_info */

    opts = setup_find_stream_info_opts(ic, codec_opts);

    orig_nb_streams = ic->nb_streams;



    /* If not enough info to get the stream parameters, we decode the

       first frames to get it. (used in mpeg case for example) */

    ret = avformat_find_stream_info(ic, opts);

    if (ret < 0 && verbose >= 0) {

        fprintf(stderr, ""%s: could not find codec parameters\n"", filename);

        av_close_input_file(ic);

        ffmpeg_exit(1);

    }



    timestamp = start_time;

    /* add the stream start time */

    if (ic->start_time != AV_NOPTS_VALUE)

        timestamp += ic->start_time;



    /* if seeking requested, we execute it */

    if (start_time != 0) {

        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);

        if (ret < 0) {

            fprintf(stderr, ""%s: could not seek to position %0.3f\n"",

                    filename, (double)timestamp / AV_TIME_BASE);

        }

        /* reset seek info */

        start_time = 0;

    }



    /* update the current parameters so that they match the one of the input stream */

    for(i=0;i<ic->nb_streams;i++) {

        AVStream *st = ic->streams[i];

        AVCodecContext *dec = st->codec;

        InputStream *ist;



        dec->thread_count = thread_count;



        input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1);

        ist = &input_streams[nb_input_streams - 1];

        ist->st = st;

        ist->file_index = nb_input_files;

        ist->discard = 1;

        ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0);



        if (i < nb_ts_scale)

            ist->ts_scale = ts_scale[i];



        switch (dec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->dec = avcodec_find_decoder_by_name(audio_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            if(audio_disable)

                st->discard= AVDISCARD_ALL;

            break;

        case AVMEDIA_TYPE_VIDEO:

            ist->dec= avcodec_find_decoder_by_name(video_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            rfps      = ic->streams[i]->r_frame_rate.num;

            rfps_base = ic->streams[i]->r_frame_rate.den;

            if (dec->lowres) {

                dec->flags |= CODEC_FLAG_EMU_EDGE;

            }

            if(me_threshold)

                dec->debug |= FF_DEBUG_MV;



            if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {



                if (verbose >= 0)

                    fprintf(stderr,""\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\n"",

                            i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,



                    (float)rfps / rfps_base, rfps, rfps_base);

            }



            if(video_disable)

                st->discard= AVDISCARD_ALL;

            else if(video_discard)

                st->discard= video_discard;

            break;

        case AVMEDIA_TYPE_DATA:

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            if(subtitle_disable)

                st->discard = AVDISCARD_ALL;

            break;

        case AVMEDIA_TYPE_ATTACHMENT:

        case AVMEDIA_TYPE_UNKNOWN:

            break;

        default:

            abort();

        }

    }



    /* dump the file content */

    if (verbose >= 0)

        av_dump_format(ic, nb_input_files, filename, 0);



    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);

    input_files[nb_input_files - 1].ctx        = ic;

    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;

    input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : timestamp);



    top_field_first = -1;

    frame_rate    = (AVRational){0, 0};

    frame_pix_fmt = PIX_FMT_NONE;

    frame_height = 0;

    frame_width  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    av_freep(&ts_scale);

    nb_ts_scale = 0;



    for (i = 0; i < orig_nb_streams; i++)

        av_dict_free(&opts[i]);

    av_freep(&opts);

    av_freep(&video_codec_name);

    av_freep(&audio_codec_name);

    av_freep(&subtitle_codec_name);

    uninit_opts();

    init_opts();

    return 0;

}
",1353,"static int opt_input_file(const char *opt, const char *filename)

{

    AVFormatContext *pic;

    AVInputFormat *file_iolar = NULL;

    int stat, i, cb, rdframes, rfps6base;

    int64_t timeline;

    uint8_t file[128];

    AVDictionary **opts;

    int  orig_nb_streampoints;                     // number of streams before avformat_find_stream_info



    if (last_asked_format) {

        if (!(file_iolar = av_find_input_format(last_asked_format))) {

            fprintf(stderr, ""Unknown input format: '%s'
"", last_asked_format);

            ffmpeg_exit(1);

        }

        last_asked_format = NULL;

    }



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    using_stdin |= !strncmp(filename, ""pipe:"", 5) ||

                    !strcmp(filename, ""/dev/stdin"");



    /* get default parameters from command line */

    pic = avformat_alloc_context();

    if (!pic) {

        print_error(filename, AVERROR(ENOMEM));

        ffmpeg_exit(1);

    }

    if (audio_sample_rate) {

        snprintf(file, sizeof(file), ""%d"", audio_sample_rate);

        av_dict_set(&format_opts, ""sample_rate"", file, 0);

    }

    if (audio_channels) {

        snprintf(file, sizeof(file), ""%d"", audio_channels);

        av_dict_set(&format_opts, ""channels"", file, 0);

    }

    if (frame_rate.num) {

        snprintf(file, sizeof(file), ""%d/%d"", frame_rate.num, frame_rate.den);

        av_dict_set(&format_opts, ""framerate"", file, 0);

    }

    if (frame_width && frame_height) {

        snprintf(file, sizeof(file), ""%dx%d"", frame_width, frame_height);

        av_dict_set(&format_opts, ""video_size"", file, 0);

    }

    if (frame_pix_fmt != PIX_FMT_NONE)

        av_dict_set(&format_opts, ""pixel_format"", av_get_pix_fmt_name(frame_pix_fmt), 0);



    pic->video_codec_id   =

        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0);

    pic->audio_codec_id   =

        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0);

    pic->subtitle_codec_id=

        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0);

    pic->flags |= AVFMT_FLAG_NONBLOCK;



    /* open the input file with generic libav function */

    stat = avformat_open_input(&pic, filename, file_iolar, &format_opts);

    if (stat < 0) {

        print_error(filename, stat);

        ffmpeg_exit(1);

    }

    assert_avoptions(format_opts);



    if(opt_programid) {

        int i, j;

        int found=0;

        for(i=0; i<pic->nb_streams; i++){

            pic->streams[i]->discard= AVDISCARD_ALL;

        }

        for(i=0; i<pic->nb_programs; i++){

            AVProgram *p= pic->programs[i];

            if(p->id != opt_programid){

                p->discard = AVDISCARD_ALL;

            }else{

                found=1;

                for(j=0; j<p->nb_stream_indexes; j++){

                    pic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;

                }

            }

        }

        if(!found){

            fprintf(stderr, ""Specified program id not found
"");

            ffmpeg_exit(1);

        }

        opt_programid=0;

    }



    if (loop_input) {

        av_log(NULL, AV_LOG_WARNING, ""-loop_input is deprecated, use -loop 1
"");

        pic->loop_input = loop_input;

    }



    /* Set AVCodecContext options for avformat_find_stream_info */

    opts = setup_find_stream_info_opts(pic, codec_opts);

     orig_nb_streampoints = pic->nb_streams;



    /* If not enough info to get the stream parameters, we decode the

       first frames to get it. (used in mpeg case for example) */

    cb = avformat_find_stream_info(pic, opts);

    if (cb < 0 && verbose >= 0) {

        fprintf(stderr, ""%s: could not find codec parameters
"", filename);

        av_close_input_file(pic);

        ffmpeg_exit(1);

    }



    timeline = start_time;

    /* add the stream start time */

    if (pic->start_time != AV_NOPTS_VALUE)

        timeline += pic->start_time;



    /* if seeking requested, we execute it */

    if (start_time != 0) {

        cb = av_seek_frame(pic, -1, timeline, AVSEEK_FLAG_BACKWARD);

        if (cb < 0) {

            fprintf(stderr, ""%s: could not seek to position %0.3f
"",

                    filename, (double)timeline / AV_TIME_BASE);

        }

        /* reset seek info */

        start_time = 0;

    }



    /* update the current parameters so that they match the one of the input stream */

    for(i=0;i<pic->nb_streams;i++) {

        AVStream *st = pic->streams[i];

        AVCodecContext *dec = st->codec;

        InputStream *ist;



        dec->thread_count = thread_count;



        input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1);

        ist = &input_streams[nb_input_streams - 1];

        ist->st = st;

        ist->file_index = nb_input_files;

        ist->discard = 1;

        ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0);



        if (i < nb_ts_scale)

            ist->ts_scale = ts_scale[i];



        switch (dec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->dec = avcodec_find_decoder_by_name(audio_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            if(audio_disable)

                st->discard= AVDISCARD_ALL;

            break;

        case AVMEDIA_TYPE_VIDEO:

            ist->dec= avcodec_find_decoder_by_name(video_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            rdframes      = pic->streams[i]->r_frame_rate.num;

            rfps6base = pic->streams[i]->r_frame_rate.den;

            if (dec->lowres) {

                dec->flags |= CODEC_FLAG_EMU_EDGE;

            }

            if(me_threshold)

                dec->debug |= FF_DEBUG_MV;



            if (dec->time_base.den != rdframes*dec->ticks_per_frame || dec->time_base.num != rfps6base) {



                if (verbose >= 0)

                    fprintf(stderr,""
Seems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)
"",

                            i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,



                    (float)rdframes / rfps6base, rdframes, rfps6base);

            }



            if(video_disable)

                st->discard= AVDISCARD_ALL;

            else if(video_discard)

                st->discard= video_discard;

            break;

        case AVMEDIA_TYPE_DATA:

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            if(subtitle_disable)

                st->discard = AVDISCARD_ALL;

            break;

        case AVMEDIA_TYPE_ATTACHMENT:

        case AVMEDIA_TYPE_UNKNOWN:

            break;

        default:

            abort();

        }

    }



    /* dump the file content */

    if (verbose >= 0)

        av_dump_format(pic, nb_input_files, filename, 0);



    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);

    input_files[nb_input_files - 1].ctx        = pic;

    input_files[nb_input_files - 1].ist_index  = nb_input_streams - pic->nb_streams;

    input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : timeline);



    top_field_first = -1;

    frame_rate    = (AVRational){0, 0};

    frame_pix_fmt = PIX_FMT_NONE;

    frame_height = 0;

    frame_width  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    av_freep(&ts_scale);

    nb_ts_scale = 0;



    for (i = 0; i <  orig_nb_streampoints; i++)

        av_dict_free(&opts[i]);

    av_freep(&opts);

    av_freep(&video_codec_name);

    av_freep(&audio_codec_name);

    av_freep(&subtitle_codec_name);

    uninit_opts();

    init_opts();

    return 0;

}
",0,0,1,1,"opt,filename,ic,file_iformat,err,i,ret,rfps,rfps_base,timestamp,buf,opts,orig_nb_streams","opt:-0.030469059944152832,filename:-0.02784484624862671,ic:0.004942849278450012,file_iformat:0.03547656536102295,err:0.001934647560119629,i:0.00033427774906158447,ret:0.008180081844329834,rfps:0.013921186327934265,rfps_base:0.006467118859291077,timestamp:0.003349587321281433,buf:0.04075230658054352,opts:-0.02521313726902008,orig_nb_streams:0.0733959823846817,",9,72,"orig_nb_streams: orig_nb_streampoints,buf:file,file_iformat:file_iolar,rfps:rdframes,ret:cb,rfps_base:rfps6base,ic:pic,timestamp:timeline,err:stat,",Greedy,372,0.11893195311228434
372,"static int usb_hub_handle_control(USBDevice *dev, USBPacket *p,

               int request, int value, int index, int length, uint8_t *data)

{

    USBHubState *s = (USBHubState *)dev;

    int ret;



    ret = usb_desc_handle_control(dev, p, request, value, index, length, data);

    if (ret >= 0) {

        return ret;

    }



    switch(request) {

    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:

        if (value == 0 && index != 0x81) { /* clear ep halt */

            goto fail;

        }

        ret = 0;

        break;

    case DeviceRequest | USB_REQ_GET_INTERFACE:

        data[0] = 0;

        ret = 1;

        break;

    case DeviceOutRequest | USB_REQ_SET_INTERFACE:

        ret = 0;

        break;

        /* usb specific requests */

    case GetHubStatus:

        data[0] = 0;

        data[1] = 0;

        data[2] = 0;

        data[3] = 0;

        ret = 4;

        break;

    case GetPortStatus:

        {

            unsigned int n = index - 1;

            USBHubPort *port;

            if (n >= NUM_PORTS) {

                goto fail;

            }

            port = &s->ports[n];

            data[0] = port->wPortStatus;

            data[1] = port->wPortStatus >> 8;

            data[2] = port->wPortChange;

            data[3] = port->wPortChange >> 8;

            ret = 4;

        }

        break;

    case SetHubFeature:

    case ClearHubFeature:

        if (value == 0 || value == 1) {

        } else {

            goto fail;

        }

        ret = 0;

        break;

    case SetPortFeature:

        {

            unsigned int n = index - 1;

            USBHubPort *port;

            USBDevice *dev;

            if (n >= NUM_PORTS) {

                goto fail;

            }

            port = &s->ports[n];

            dev = port->port.dev;

            switch(value) {

            case PORT_SUSPEND:

                port->wPortStatus |= PORT_STAT_SUSPEND;

                break;

            case PORT_RESET:

                if (dev) {

                    usb_send_msg(dev, USB_MSG_RESET);

                    port->wPortChange |= PORT_STAT_C_RESET;

                    /* set enable bit */

                    port->wPortStatus |= PORT_STAT_ENABLE;

                }

                break;

            case PORT_POWER:

                break;

            default:

                goto fail;

            }

            ret = 0;

        }

        break;

    case ClearPortFeature:

        {

            unsigned int n = index - 1;

            USBHubPort *port;



            if (n >= NUM_PORTS) {

                goto fail;

            }

            port = &s->ports[n];

            switch(value) {

            case PORT_ENABLE:

                port->wPortStatus &= ~PORT_STAT_ENABLE;

                break;

            case PORT_C_ENABLE:

                port->wPortChange &= ~PORT_STAT_C_ENABLE;

                break;

            case PORT_SUSPEND:

                port->wPortStatus &= ~PORT_STAT_SUSPEND;

                break;

            case PORT_C_SUSPEND:

                port->wPortChange &= ~PORT_STAT_C_SUSPEND;

                break;

            case PORT_C_CONNECTION:

                port->wPortChange &= ~PORT_STAT_C_CONNECTION;

                break;

            case PORT_C_OVERCURRENT:

                port->wPortChange &= ~PORT_STAT_C_OVERCURRENT;

                break;

            case PORT_C_RESET:

                port->wPortChange &= ~PORT_STAT_C_RESET;

                break;

            default:

                goto fail;

            }

            ret = 0;

        }

        break;

    case GetHubDescriptor:

        {

            unsigned int n, limit, var_hub_size = 0;

            memcpy(data, qemu_hub_hub_descriptor,

                   sizeof(qemu_hub_hub_descriptor));

            data[2] = NUM_PORTS;



            /* fill DeviceRemovable bits */

            limit = ((NUM_PORTS + 1 + 7) / 8) + 7;

            for (n = 7; n < limit; n++) {

                data[n] = 0x00;

                var_hub_size++;

            }



            /* fill PortPwrCtrlMask bits */

            limit = limit + ((NUM_PORTS + 7) / 8);

            for (;n < limit; n++) {

                data[n] = 0xff;

                var_hub_size++;

            }



            ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size;

            data[0] = ret;

            break;

        }

    default:

    fail:

        ret = USB_RET_STALL;

        break;

    }

    return ret;

}
",679,"static int usb_hub_handle_control(USBDevice *diff, USBPacket *p,

               int request, int value, int index, int length, uint8_t *it)

{

    USBHubState *s = (USBHubState *)diff;

    int ret;



    ret = usb_desc_handle_control(diff, p, request, value, index, length, it);

    if (ret >= 0) {

        return ret;

    }



    switch(request) {

    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:

        if (value == 0 && index != 0x81) { /* clear ep halt */

            goto fail;

        }

        ret = 0;

        break;

    case DeviceRequest | USB_REQ_GET_INTERFACE:

        it[0] = 0;

        ret = 1;

        break;

    case DeviceOutRequest | USB_REQ_SET_INTERFACE:

        ret = 0;

        break;

        /* usb specific requests */

    case GetHubStatus:

        it[0] = 0;

        it[1] = 0;

        it[2] = 0;

        it[3] = 0;

        ret = 4;

        break;

    case GetPortStatus:

        {

            unsigned int n = index - 1;

            USBHubPort *port;

            if (n >= NUM_PORTS) {

                goto fail;

            }

            port = &s->ports[n];

            it[0] = port->wPortStatus;

            it[1] = port->wPortStatus >> 8;

            it[2] = port->wPortChange;

            it[3] = port->wPortChange >> 8;

            ret = 4;

        }

        break;

    case SetHubFeature:

    case ClearHubFeature:

        if (value == 0 || value == 1) {

        } else {

            goto fail;

        }

        ret = 0;

        break;

    case SetPortFeature:

        {

            unsigned int n = index - 1;

            USBHubPort *port;

            USBDevice *diff;

            if (n >= NUM_PORTS) {

                goto fail;

            }

            port = &s->ports[n];

            diff = port->port.diff;

            switch(value) {

            case PORT_SUSPEND:

                port->wPortStatus |= PORT_STAT_SUSPEND;

                break;

            case PORT_RESET:

                if (diff) {

                    usb_send_msg(diff, USB_MSG_RESET);

                    port->wPortChange |= PORT_STAT_C_RESET;

                    /* set enable bit */

                    port->wPortStatus |= PORT_STAT_ENABLE;

                }

                break;

            case PORT_POWER:

                break;

            default:

                goto fail;

            }

            ret = 0;

        }

        break;

    case ClearPortFeature:

        {

            unsigned int n = index - 1;

            USBHubPort *port;



            if (n >= NUM_PORTS) {

                goto fail;

            }

            port = &s->ports[n];

            switch(value) {

            case PORT_ENABLE:

                port->wPortStatus &= ~PORT_STAT_ENABLE;

                break;

            case PORT_C_ENABLE:

                port->wPortChange &= ~PORT_STAT_C_ENABLE;

                break;

            case PORT_SUSPEND:

                port->wPortStatus &= ~PORT_STAT_SUSPEND;

                break;

            case PORT_C_SUSPEND:

                port->wPortChange &= ~PORT_STAT_C_SUSPEND;

                break;

            case PORT_C_CONNECTION:

                port->wPortChange &= ~PORT_STAT_C_CONNECTION;

                break;

            case PORT_C_OVERCURRENT:

                port->wPortChange &= ~PORT_STAT_C_OVERCURRENT;

                break;

            case PORT_C_RESET:

                port->wPortChange &= ~PORT_STAT_C_RESET;

                break;

            default:

                goto fail;

            }

            ret = 0;

        }

        break;

    case GetHubDescriptor:

        {

            unsigned int n, limit, var_hub_size = 0;

            memcpy(it, qemu_hub_hub_descriptor,

                   sizeof(qemu_hub_hub_descriptor));

            it[2] = NUM_PORTS;



            /* fill DeviceRemovable bits */

            limit = ((NUM_PORTS + 1 + 7) / 8) + 7;

            for (n = 7; n < limit; n++) {

                it[n] = 0x00;

                var_hub_size++;

            }



            /* fill PortPwrCtrlMask bits */

            limit = limit + ((NUM_PORTS + 7) / 8);

            for (;n < limit; n++) {

                it[n] = 0xff;

                var_hub_size++;

            }



            ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size;

            it[0] = ret;

            break;

        }

    default:

    fail:

        ret = USB_RET_STALL;

        break;

    }

    return ret;

}
",0,0,1,1,"dev,p,request,value,index,length,data,s,ret,port,n","dev:0.14859870076179504,p:0.06828948110342026,request:0.05095508694648743,value:0.058230362832546234,index:0.06927713006734848,length:0.048924610018730164,data:0.13955088704824448,s:0.04790385067462921,ret:0.13498082756996155,port:0.12155839800834656,n:0.040886640548706055,",2,24,"dev:diff,data:it,",Greedy,250,0.05185993115107219
373,"static int mxf_write_packet(AVFormatContext *s, AVPacket *pkt)

{

    MXFContext *mxf = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st = s->streams[pkt->stream_index];

    MXFStreamContext *sc = st->priv_data;

    MXFIndexEntry ie = {0};



    if (!mxf->edit_unit_byte_count && !(mxf->edit_units_count % EDIT_UNITS_PER_BODY)) {

        mxf->index_entries = av_realloc(mxf->index_entries,

            (mxf->edit_units_count + EDIT_UNITS_PER_BODY)*sizeof(*mxf->index_entries));

        if (!mxf->index_entries) {

            av_log(s, AV_LOG_ERROR, ""could not allocate index entries\n"");

            return -1;

        }

    }



    if (st->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO) {

        if (!mxf_parse_mpeg2_frame(s, st, pkt, &ie)) {

            av_log(s, AV_LOG_ERROR, ""could not get mpeg2 profile and level\n"");

            return -1;

        }

    }



    if (!mxf->header_written) {

        if (mxf->edit_unit_byte_count) {

            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);

            mxf_write_klv_fill(s);

            mxf_write_index_table_segment(s);

        } else {

            mxf_write_partition(s, 0, 0, header_open_partition_key, 1);

        }

        mxf->header_written = 1;

    }



    if (st->index == 0) {

        if (!mxf->edit_unit_byte_count &&

            (!mxf->edit_units_count || mxf->edit_units_count > EDIT_UNITS_PER_BODY) &&

            !(ie.flags & 0x33)) { // I frame, Gop start

            mxf_write_klv_fill(s);

            mxf_write_partition(s, 1, 2, body_partition_key, 0);



            mxf_write_klv_fill(s);

            mxf_write_index_table_segment(s);

        }



        mxf_write_klv_fill(s);

        mxf_write_system_item(s);



        if (!mxf->edit_unit_byte_count) {

            mxf->index_entries[mxf->edit_units_count].offset = mxf->body_offset;

            mxf->index_entries[mxf->edit_units_count].flags = ie.flags;

            mxf->index_entries[mxf->edit_units_count].temporal_ref = ie.temporal_ref;

            mxf->body_offset += KAG_SIZE; // size of system element

        }

        mxf->edit_units_count++;

    } else if (!mxf->edit_unit_byte_count && st->index == 1) {

        mxf->index_entries[mxf->edit_units_count-1].slice_offset =

            mxf->body_offset - mxf->index_entries[mxf->edit_units_count-1].offset;

    }



    mxf_write_klv_fill(s);

    avio_write(pb, sc->track_essence_element_key, 16); // write key

    if (s->oformat == &ff_mxf_d10_muxer) {

        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

            mxf_write_d10_video_packet(s, st, pkt);

        else

            mxf_write_d10_audio_packet(s, st, pkt);

    } else {

        klv_encode_ber4_length(pb, pkt->size); // write length

        avio_write(pb, pkt->data, pkt->size);

        mxf->body_offset += 16+4+pkt->size + klv_fill_size(16+4+pkt->size);

    }



    avio_flush(pb);



    return 0;

}
",531,"static int mxf_write_packet(AVFormatContext *sie, AVPacket *pkt)

{

    MXFContext *mxf = sie->priv_data;

    AVIOContext *pb = sie->pb;

    AVStream *st = sie->streams[pkt->stream_index];

    MXFStreamContext *sc = st->priv_data;

    MXFIndexEntry ie = {0};



    if (!mxf->edit_unit_byte_count && !(mxf->edit_units_count % EDIT_UNITS_PER_BODY)) {

        mxf->index_entries = av_realloc(mxf->index_entries,

            (mxf->edit_units_count + EDIT_UNITS_PER_BODY)*sizeof(*mxf->index_entries));

        if (!mxf->index_entries) {

            av_log(sie, AV_LOG_ERROR, ""could not allocate index entries
"");

            return -1;

        }

    }



    if (st->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO) {

        if (!mxf_parse_mpeg2_frame(sie, st, pkt, &ie)) {

            av_log(sie, AV_LOG_ERROR, ""could not get mpeg2 profile and level
"");

            return -1;

        }

    }



    if (!mxf->header_written) {

        if (mxf->edit_unit_byte_count) {

            mxf_write_partition(sie, 1, 2, header_open_partition_key, 1);

            mxf_write_klv_fill(sie);

            mxf_write_index_table_segment(sie);

        } else {

            mxf_write_partition(sie, 0, 0, header_open_partition_key, 1);

        }

        mxf->header_written = 1;

    }



    if (st->index == 0) {

        if (!mxf->edit_unit_byte_count &&

            (!mxf->edit_units_count || mxf->edit_units_count > EDIT_UNITS_PER_BODY) &&

            !(ie.flags & 0x33)) { // I frame, Gop start

            mxf_write_klv_fill(sie);

            mxf_write_partition(sie, 1, 2, body_partition_key, 0);



            mxf_write_klv_fill(sie);

            mxf_write_index_table_segment(sie);

        }



        mxf_write_klv_fill(sie);

        mxf_write_system_item(sie);



        if (!mxf->edit_unit_byte_count) {

            mxf->index_entries[mxf->edit_units_count].offset = mxf->body_offset;

            mxf->index_entries[mxf->edit_units_count].flags = ie.flags;

            mxf->index_entries[mxf->edit_units_count].temporal_ref = ie.temporal_ref;

            mxf->body_offset += KAG_SIZE; // size of system element

        }

        mxf->edit_units_count++;

    } else if (!mxf->edit_unit_byte_count && st->index == 1) {

        mxf->index_entries[mxf->edit_units_count-1].slice_offset =

            mxf->body_offset - mxf->index_entries[mxf->edit_units_count-1].offset;

    }



    mxf_write_klv_fill(sie);

    avio_write(pb, sc->track_essence_element_key, 16); // write key

    if (sie->oformat == &ff_mxf_d10_muxer) {

        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

            mxf_write_d10_video_packet(sie, st, pkt);

        else

            mxf_write_d10_audio_packet(sie, st, pkt);

    } else {

        klv_encode_ber4_length(pb, pkt->size); // write length

        avio_write(pb, pkt->data, pkt->size);

        mxf->body_offset += 16+4+pkt->size + klv_fill_size(16+4+pkt->size);

    }



    avio_flush(pb);



    return 0;

}
",0,0,1,1,"s,pkt,mxf,pb,st,sc,edit_units_count","s:0.3263585567474365,pkt:-0.013755083084106445,mxf:0.22473981976509094,pb:0.019861668348312378,st:0.0816015899181366,sc:0.06206199526786804,edit_units_count:0.008595466613769531,",1,21,"s:sie,",Greedy,173,0.034403451283772785
374,"int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,

                              int access_type, int mmu_idx, int is_softmmu)

{

    uint32_t phys_addr;

    target_ulong page_size;

    int prot;

    int ret, is_user;



    is_user = mmu_idx == MMU_USER_IDX;

    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,

                        &page_size);

    if (ret == 0) {

        /* Map a single [sub]page.  */

        phys_addr &= ~(uint32_t)0x3ff;

        address &= ~(uint32_t)0x3ff;

        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,

                      page_size);

        return 0;

    }



    if (access_type == 2) {

        env->cp15.c5_insn = ret;

        env->cp15.c6_insn = address;

        env->exception_index = EXCP_PREFETCH_ABORT;

    } else {

        env->cp15.c5_data = ret;

        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))

            env->cp15.c5_data |= (1 << 11);

        env->cp15.c6_data = address;

        env->exception_index = EXCP_DATA_ABORT;

    }

    return 1;

}
",190,"int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong test,

                              int access_type, int mmu_inx, int is_softmmcu)

{

    uint32_t phys2work;

    target_ulong page_size;

    int prot;

    int ret, is_user;



    is_user = mmu_inx == MMU_USER_IDX;

    ret = get_phys_addr(env, test, access_type, is_user, &phys2work, &prot,

                        &page_size);

    if (ret == 0) {

        /* Map a single [sub]page.  */

        phys2work &= ~(uint32_t)0x3ff;

        test &= ~(uint32_t)0x3ff;

        tlb_set_page (env, test, phys2work, prot | PAGE_EXEC, mmu_inx,

                      page_size);

        return 0;

    }



    if (access_type == 2) {

        env->cp15.c5_insn = ret;

        env->cp15.c6_insn = test;

        env->exception_index = EXCP_PREFETCH_ABORT;

    } else {

        env->cp15.c5_data = ret;

        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))

            env->cp15.c5_data |= (1 << 11);

        env->cp15.c6_data = test;

        env->exception_index = EXCP_DATA_ABORT;

    }

    return 1;

}
",0,0,1,1,"env,address,access_type,mmu_idx,is_softmmu,phys_addr,page_size,prot,ret,is_user","env:-0.10928167402744293,address:0.03998380899429321,access_type:-0.05458906292915344,mmu_idx:0.1934296041727066,is_softmmu:0.04474145174026489,phys_addr:-0.003674045205116272,page_size:-0.06453129649162292,prot:-0.023562148213386536,ret:-0.024157017469406128,is_user:-0.027445361018180847,",4,14,"mmu_idx:mmu_inx,is_softmmu:is_softmmcu,address:test,phys_addr:phys2work,",Greedy,199,0.03933589061101277
375,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){

    return h->pps.chroma_qp_table[t][qscale];

}
",30,"static inline int get_chroma_qp(H264Context *him, int title, int Qsize){

    return him->pps.chroma_qp_table[title][Qsize];

}
",0,0,1,1,"h,t,qscale","h:-0.0009186882525682449,t:0.0004753582179546356,qscale:-0.00029209814965724945,",3,6,"t:title,qscale:Qsize,h:him,",Greedy,122,0.023840701580047606
376,"static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc,

                              int plane_idx, int is_key, int is_chroma)

{

    int blk, ret;

    int i, j, bx, by;

    uint8_t *dst, *ref, *ref_start, *ref_end;

    int v, col[2];

    const uint8_t *scan;

    int xoff, yoff;

    LOCAL_ALIGNED_16(int16_t, block, [64]);

    LOCAL_ALIGNED_16(int32_t, dctblock, [64]);

    int coordmap[64];

    int ybias = is_key ? -15 : 0;

    int qp;



    const int stride = frame->linesize[plane_idx];

    int bw = is_chroma ? (c->avctx->width  + 15) >> 4 : (c->avctx->width  + 7) >> 3;

    int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3;



    binkb_init_bundles(c);

    ref_start = frame->data[plane_idx];

    ref_end   = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8;



    for (i = 0; i < 64; i++)

        coordmap[i] = (i & 7) + (i >> 3) * stride;



    for (by = 0; by < bh; by++) {

        for (i = 0; i < BINKB_NB_SRC; i++) {

            if ((ret = binkb_read_bundle(c, bc, i)) < 0)

                return ret;

        }



        dst  = frame->data[plane_idx]  + 8*by*stride;

        for (bx = 0; bx < bw; bx++, dst += 8) {

            blk = binkb_get_value(c, BINKB_SRC_BLOCK_TYPES);

            switch (blk) {

            case 0:

                break;

            case 1:

                scan = bink_patterns[bitstream_read(bc, 4)];

                i = 0;

                do {

                    int mode = bitstream_read_bit(bc);

                    int run  = bitstream_read(bc, binkb_runbits[i]) + 1;



                    i += run;

                    if (i > 64) {

                        av_log(c->avctx, AV_LOG_ERROR, ""Run went out of bounds\n"");

                        return AVERROR_INVALIDDATA;

                    }

                    if (mode) {

                        v = binkb_get_value(c, BINKB_SRC_COLORS);

                        for (j = 0; j < run; j++)

                            dst[coordmap[*scan++]] = v;

                    } else {

                        for (j = 0; j < run; j++)

                            dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);

                    }

                } while (i < 63);

                if (i == 63)

                    dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);

                break;

            case 2:

                memset(dctblock, 0, sizeof(*dctblock) * 64);

                dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC);

                qp = binkb_get_value(c, BINKB_SRC_INTRA_Q);

                read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp);

                c->binkdsp.idct_put(dst, stride, dctblock);

                break;

            case 3:

                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);

                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;

                ref = dst + xoff + yoff * stride;

                if (ref < ref_start || ref + 8*stride > ref_end) {

                    av_log(c->avctx, AV_LOG_WARNING, ""Reference block is out of bounds\n"");

                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {

                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);

                } else {

                    put_pixels8x8_overlapped(dst, ref, stride);

                }

                c->bdsp.clear_block(block);

                v = binkb_get_value(c, BINKB_SRC_INTER_COEFS);

                read_residue(bc, block, v);

                c->binkdsp.add_pixels8(dst, block, stride);

                break;

            case 4:

                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);

                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;

                ref = dst + xoff + yoff * stride;

                if (ref < ref_start || ref + 8 * stride > ref_end) {

                    av_log(c->avctx, AV_LOG_WARNING, ""Reference block is out of bounds\n"");

                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {

                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);

                } else {

                    put_pixels8x8_overlapped(dst, ref, stride);

                }

                memset(dctblock, 0, sizeof(*dctblock) * 64);

                dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC);

                qp = binkb_get_value(c, BINKB_SRC_INTER_Q);

                read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp);

                c->binkdsp.idct_add(dst, stride, dctblock);

                break;

            case 5:

                v = binkb_get_value(c, BINKB_SRC_COLORS);

                c->bdsp.fill_block_tab[1](dst, v, stride, 8);

                break;

            case 6:

                for (i = 0; i < 2; i++)

                    col[i] = binkb_get_value(c, BINKB_SRC_COLORS);

                for (i = 0; i < 8; i++) {

                    v = binkb_get_value(c, BINKB_SRC_PATTERN);

                    for (j = 0; j < 8; j++, v >>= 1)

                        dst[i*stride + j] = col[v & 1];

                }

                break;

            case 7:

                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);

                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;

                ref = dst + xoff + yoff * stride;

                if (ref < ref_start || ref + 8 * stride > ref_end) {

                    av_log(c->avctx, AV_LOG_WARNING, ""Reference block is out of bounds\n"");

                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {

                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);

                } else {

                    put_pixels8x8_overlapped(dst, ref, stride);

                }

                break;

            case 8:

                for (i = 0; i < 8; i++)

                    memcpy(dst + i*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + i*8, 8);

                c->bundle[BINKB_SRC_COLORS].cur_ptr += 64;

                break;

            default:

                av_log(c->avctx, AV_LOG_ERROR, ""Unknown block type %d\n"", blk);

                return AVERROR_INVALIDDATA;

            }

        }

    }

    if (bitstream_tell(bc) & 0x1F) // next plane data starts at 32-bit boundary

        bitstream_skip(bc, 32 - (bitstream_tell(bc) & 0x1F));



    return 0;

}
",1273,,0,1,,-4,"c,frame,bc,plane_idx,is_key,is_chroma,blk,ret,i,j,bx,by,dst,ref,ref_start,ref_end,v,col,scan,xoff,yoff,coordmap,qp",,,,,Greedy,1,0.002584687868754069
377,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
",95,"static int get_cpsr(QEMUFile *f, void *ipec, size_t size)

{

    ARMCPU *cpu = ipec;

    CPUARMState *fi = &cpu->fi;

    uint32_t val = qemu_get_be32(f);



    fi->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(fi)) {

        pstate_write(fi, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    fi->uncached_cpsr = val & CPSR_M;

    cpsr_write(fi, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
",1,1,0,1,"f,opaque,size,cpu,env","f:0.03504323959350586,opaque:0.46511420607566833,size:0.14171332120895386,cpu:0.17781299352645874,env:0.3199892044067383,",2,9,"opaque:ipec,env:fi,",Greedy,123,0.023175235589345297
378,"static void term_handle_byte(int ch)

{

    switch(term_esc_state) {

    case IS_NORM:

        switch(ch) {

        case 1:

            term_bol();

            break;

        case 4:

            term_delete_char();

            break;

        case 5:

            term_eol();

            break;

        case 9:

            term_completion();

            break;

        case 10:

        case 13:

            term_cmd_buf[term_cmd_buf_size] = '\0';

	    term_hist_add(term_cmd_buf);

            term_printf(""\n"");

            term_handle_command(term_cmd_buf);

            term_show_prompt();

            break;

        case 27:

            term_esc_state = IS_ESC;

            break;

        case 127:

        case 8:

            term_backspace();

            break;

	case 155:

            term_esc_state = IS_CSI;

	    break;

        default:

            if (ch >= 32) {

                term_insert_char(ch);

            }

            break;

        }

        break;

    case IS_ESC:

        if (ch == '[') {

            term_esc_state = IS_CSI;

            term_esc_param = 0;

        } else {

            term_esc_state = IS_NORM;

        }

        break;

    case IS_CSI:

        switch(ch) {

	case 'A':

	case 'F':

	    term_up_char();

	    break;

	case 'B':

	case 'E':

	    term_down_char();

	    break;

        case 'D':

            term_backward_char();

            break;

        case 'C':

            term_forward_char();

            break;

        case '0' ... '9':

            term_esc_param = term_esc_param * 10 + (ch - '0');

            goto the_end;

        case '~':

            switch(term_esc_param) {

            case 1:

                term_bol();

                break;

            case 3:

                term_delete_char();

                break;

            case 4:

                term_eol();

                break;

            }

            break;

        default:

            break;

        }

        term_esc_state = IS_NORM;

    the_end:

        break;

    }

    term_update();

}
",312,"static void term_handle_byte(int cher)

{

    switch(term_esc_state) {

    case IS_NORM:

        switch(cher) {

        case 1:

            term_bol();

            break;

        case 4:

            term_delete_char();

            break;

        case 5:

            term_eol();

            break;

        case 9:

            term_completion();

            break;

        case 10:

        case 13:

            term_cmd_buf[term_cmd_buf_size] = '\0';

	    term_hist_add(term_cmd_buf);

            term_printf(""
"");

            term_handle_command(term_cmd_buf);

            term_show_prompt();

            break;

        case 27:

            term_esc_state = IS_ESC;

            break;

        case 127:

        case 8:

            term_backspace();

            break;

	case 155:

            term_esc_state = IS_CSI;

	    break;

        default:

            if (cher >= 32) {

                term_insert_char(cher);

            }

            break;

        }

        break;

    case IS_ESC:

        if (cher == '[') {

            term_esc_state = IS_CSI;

            term_esc_param = 0;

        } else {

            term_esc_state = IS_NORM;

        }

        break;

    case IS_CSI:

        switch(cher) {

	case 'A':

	case 'F':

	    term_up_char();

	    break;

	case 'B':

	case 'E':

	    term_down_char();

	    break;

        case 'D':

            term_backward_char();

            break;

        case 'C':

            term_forward_char();

            break;

        case '0' ... '9':

            term_esc_param = term_esc_param * 10 + (cher - '0');

            goto the_end;

        case '~':

            switch(term_esc_param) {

            case 1:

                term_bol();

                break;

            case 3:

                term_delete_char();

                break;

            case 4:

                term_eol();

                break;

            }

            break;

        default:

            break;

        }

        term_esc_state = IS_NORM;

    the_end:

        break;

    }

    term_update();

}
",0,0,0,-1,ch,"ch:-0.03440771996974945,",1,7,"ch:cher,",Greedy,70,0.01675512393315633
379,"struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)

{

    struct omap_l4_s *bus = g_malloc0(

                    sizeof(*bus) + ta_num * sizeof(*bus->ta));



    bus->ta_num = ta_num;

    bus->base = base;



#ifdef L4_MUX_HACK

    omap_l4_io_entries = 1;

    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));



    omap_cpu_io_entry =

            cpu_register_io_memory(omap_l4_io_readfn,

                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);

# define L4_PAGES	(0xb4000 / TARGET_PAGE_SIZE)

    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);

#endif



    return bus;

}
",180,"struct omap_l4_s *omap_l4_init(target_phys_addr_t la, int ta_nom)

{

    struct omap_l4_s *bug = g_malloc0(

                    sizeof(*bug) + ta_nom * sizeof(*bug->ta));



    bug->ta_nom = ta_nom;

    bug->la = la;



#ifdef L4_MUX_HACK

    omap_l4_io_entries = 1;

    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));



    omap_cpu_io_entry =

            cpu_register_io_memory(omap_l4_io_readfn,

                            omap_l4_io_writefn, bug, DEVICE_NATIVE_ENDIAN);

# define L4_PAGES	(0xb4000 / TARGET_PAGE_SIZE)

    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);

#endif



    return bug;

}
",0,0,1,1,"base,ta_num,bus","base:-0.00847388431429863,ta_num:-0.02501097321510315,bus:0.012926731258630753,",3,14,"bus:bug,base:la,ta_num:ta_nom,",Greedy,182,0.03606539964675903
380,"static void qbus_list_bus(DeviceState *dev, char *dest, int len)

{

    BusState *child;

    const char *sep = "" "";

    int pos = 0;



    pos += snprintf(dest+pos, len-pos,""child busses at \""%s\"":"",

                    dev->id ? dev->id : dev->info->name);

    LIST_FOREACH(child, &dev->child_bus, sibling) {

        pos += snprintf(dest+pos, len-pos, ""%s\""%s\"""", sep, child->name);

        sep = "", "";

    }

}
",109,"static void qbus_list_bus(DeviceState *test, char *test, int err)

{

    BusState *feed;

    const char *sep = "" "";

    int pos = 0;



    pos += snprintf(test+pos, err-pos,""child busses at \""%s\"":"",

                    test->id ? test->id : test->info->name);

    LIST_FOREACH(feed, &test->child_bus, sibling) {

        pos += snprintf(test+pos, err-pos, ""%s\""%s\"""", sep, feed->name);

        sep = "", "";

    }

}
",0,0,0,-1,"dev,dest,len,child,sep","dev:0.002828306518495083,dest:0.003583005629479885,len:0.003543129190802574,child:0.0017619486898183823,sep:0.0018484732136130333,",4,14,"dest:test,len:err,dev:test,sep:sep,child:feed,",Greedy,243,0.04341003894805908
381,"static int read_directory(BDRVVVFATState* s, int mapping_index)

{

    mapping_t* mapping = array_get(&(s->mapping), mapping_index);

    direntry_t* direntry;

    const char* dirname = mapping->path;

    int first_cluster = mapping->begin;

    int parent_index = mapping->info.dir.parent_mapping_index;

    mapping_t* parent_mapping = (mapping_t*)

        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);

    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;



    DIR* dir=opendir(dirname);

    struct dirent* entry;

    int i;



    assert(mapping->mode & MODE_DIRECTORY);



    if(!dir) {

        mapping->end = mapping->begin;

        return -1;

    }



    i = mapping->info.dir.first_dir_index =

            first_cluster == 0 ? 0 : s->directory.next;



    if (first_cluster != 0) {

        /* create the top entries of a subdirectory */

        (void)create_short_and_long_name(s, i, ""."", 1);

        (void)create_short_and_long_name(s, i, "".."", 1);

    }



    /* actually read the directory, and allocate the mappings */

    while((entry=readdir(dir))) {

        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);

        char* buffer;

        direntry_t* direntry;

        struct stat st;

        int is_dot=!strcmp(entry->d_name,""."");

        int is_dotdot=!strcmp(entry->d_name,"".."");



        if(first_cluster == 0 && (is_dotdot || is_dot))

            continue;



        buffer = g_malloc(length);

        snprintf(buffer,length,""%s/%s"",dirname,entry->d_name);



        if(stat(buffer,&st)<0) {

            g_free(buffer);

            continue;

        }



        /* create directory entry for this file */

        if (!is_dot && !is_dotdot) {

            direntry = create_short_and_long_name(s, i, entry->d_name, 0);

        } else {

            direntry = array_get(&(s->directory), is_dot ? i : i + 1);

        }

        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);

        direntry->reserved[0]=direntry->reserved[1]=0;

        direntry->ctime=fat_datetime(st.st_ctime,1);

        direntry->cdate=fat_datetime(st.st_ctime,0);

        direntry->adate=fat_datetime(st.st_atime,0);

        direntry->begin_hi=0;

        direntry->mtime=fat_datetime(st.st_mtime,1);

        direntry->mdate=fat_datetime(st.st_mtime,0);

        if(is_dotdot)

            set_begin_of_direntry(direntry, first_cluster_of_parent);

        else if(is_dot)

            set_begin_of_direntry(direntry, first_cluster);

        else

            direntry->begin=0; /* do that later */

        if (st.st_size > 0x7fffffff) {

            fprintf(stderr, ""File %s is larger than 2GB\n"", buffer);

            g_free(buffer);

            closedir(dir);

            return -2;

        }

        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);



        /* create mapping for this file */

        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {

            s->current_mapping = array_get_next(&(s->mapping));

            s->current_mapping->begin=0;

            s->current_mapping->end=st.st_size;

            /*

             * we get the direntry of the most recent direntry, which

             * contains the short name and all the relevant information.

             */

            s->current_mapping->dir_index=s->directory.next-1;

            s->current_mapping->first_mapping_index = -1;

            if (S_ISDIR(st.st_mode)) {

                s->current_mapping->mode = MODE_DIRECTORY;

                s->current_mapping->info.dir.parent_mapping_index =

                    mapping_index;

            } else {

                s->current_mapping->mode = MODE_UNDEFINED;

                s->current_mapping->info.file.offset = 0;

            }

            s->current_mapping->path=buffer;

            s->current_mapping->read_only =

                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;

        } else {

            g_free(buffer);

        }

    }

    closedir(dir);



    /* fill with zeroes up to the end of the cluster */

    while(s->directory.next%(0x10*s->sectors_per_cluster)) {

        direntry_t* direntry=array_get_next(&(s->directory));

        memset(direntry,0,sizeof(direntry_t));

    }



/* TODO: if there are more entries, bootsector has to be adjusted! */

#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)

    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {

        /* root directory */

        int cur = s->directory.next;

        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);

        s->directory.next = ROOT_ENTRIES;

        memset(array_get(&(s->directory), cur), 0,

                (ROOT_ENTRIES - cur) * sizeof(direntry_t));

    }



    /* re-get the mapping, since s->mapping was possibly realloc()ed */

    mapping = array_get(&(s->mapping), mapping_index);

    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)

        * 0x20 / s->cluster_size;

    mapping->end = first_cluster;



    direntry = array_get(&(s->directory), mapping->dir_index);

    set_begin_of_direntry(direntry, mapping->begin);



    return 0;

}
",936,"static int read_directory(BDRVVVFATState* s, int mapping_index)

{

    mapping_t* mapping = array_get(&(s->mapping), mapping_index);

    direntry_t* directry;

    const char* dirName = mapping->path;

    int first_cluster = mapping->begin;

    int parent_index = mapping->info.direction.parent_mapping_index;

    mapping_t* parent_smapping = (mapping_t*)

        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);

    int first_cluster_of_parent = parent_smapping ? parent_smapping->begin : -1;



    DIR* direction=opendir(dirName);

    struct dirent* entry;

    int i;



    assert(mapping->mode & MODE_DIRECTORY);



    if(!direction) {

        mapping->end = mapping->begin;

        return -1;

    }



    i = mapping->info.direction.first_dir_index =

            first_cluster == 0 ? 0 : s->directory.next;



    if (first_cluster != 0) {

        /* create the top entries of a subdirectory */

        (void)create_short_and_long_name(s, i, ""."", 1);

        (void)create_short_and_long_name(s, i, "".."", 1);

    }



    /* actually read the directory, and allocate the mappings */

    while((entry=readdir(direction))) {

        unsigned int length=strlen(dirName)+2+strlen(entry->d_name);

        char* channel;

        direntry_t* directry;

        struct stat stream;

        int is_dot=!strcmp(entry->d_name,""."");

        int is_dotdot=!strcmp(entry->d_name,"".."");



        if(first_cluster == 0 && (is_dotdot || is_dot))

            continue;



        channel = g_malloc(length);

        snprintf(channel,length,""%s/%s"",dirName,entry->d_name);



        if(stat(channel,&stream)<0) {

            g_free(channel);

            continue;

        }



        /* create directory entry for this file */

        if (!is_dot && !is_dotdot) {

            directry = create_short_and_long_name(s, i, entry->d_name, 0);

        } else {

            directry = array_get(&(s->directory), is_dot ? i : i + 1);

        }

        directry->attributes=(S_ISDIR(stream.st_mode)?0x10:0x20);

        directry->reserved[0]=directry->reserved[1]=0;

        directry->ctime=fat_datetime(stream.st_ctime,1);

        directry->cdate=fat_datetime(stream.st_ctime,0);

        directry->adate=fat_datetime(stream.st_atime,0);

        directry->begin_hi=0;

        directry->mtime=fat_datetime(stream.st_mtime,1);

        directry->mdate=fat_datetime(stream.st_mtime,0);

        if(is_dotdot)

            set_begin_of_direntry(directry, first_cluster_of_parent);

        else if(is_dot)

            set_begin_of_direntry(directry, first_cluster);

        else

            directry->begin=0; /* do that later */

        if (stream.st_size > 0x7fffffff) {

            fprintf(stderr, ""File %s is larger than 2GB
"", channel);

            g_free(channel);

            closedir(direction);

            return -2;

        }

        directry->size=cpu_to_le32(S_ISDIR(stream.st_mode)?0:stream.st_size);



        /* create mapping for this file */

        if(!is_dot && !is_dotdot && (S_ISDIR(stream.st_mode) || stream.st_size)) {

            s->current_mapping = array_get_next(&(s->mapping));

            s->current_mapping->begin=0;

            s->current_mapping->end=stream.st_size;

            /*

             * we get the direntry of the most recent direntry, which

             * contains the short name and all the relevant information.

             */

            s->current_mapping->dir_index=s->directory.next-1;

            s->current_mapping->first_mapping_index = -1;

            if (S_ISDIR(stream.st_mode)) {

                s->current_mapping->mode = MODE_DIRECTORY;

                s->current_mapping->info.direction.parent_mapping_index =

                    mapping_index;

            } else {

                s->current_mapping->mode = MODE_UNDEFINED;

                s->current_mapping->info.file.offset = 0;

            }

            s->current_mapping->path=channel;

            s->current_mapping->read_only =

                (stream.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;

        } else {

            g_free(channel);

        }

    }

    closedir(direction);



    /* fill with zeroes up to the end of the cluster */

    while(s->directory.next%(0x10*s->sectors_per_cluster)) {

        direntry_t* directry=array_get_next(&(s->directory));

        memset(directry,0,sizeof(direntry_t));

    }



/* TODO: if there are more entries, bootsector has to be adjusted! */

#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)

    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {

        /* root directory */

        int cur = s->directory.next;

        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);

        s->directory.next = ROOT_ENTRIES;

        memset(array_get(&(s->directory), cur), 0,

                (ROOT_ENTRIES - cur) * sizeof(direntry_t));

    }



    /* re-get the mapping, since s->mapping was possibly realloc()ed */

    mapping = array_get(&(s->mapping), mapping_index);

    first_cluster += (s->directory.next - mapping->info.direction.first_dir_index)

        * 0x20 / s->cluster_size;

    mapping->end = first_cluster;



    directry = array_get(&(s->directory), mapping->dir_index);

    set_begin_of_direntry(directry, mapping->begin);



    return 0;

}
",1,1,0,1,"s,mapping_index,mapping,direntry,dirname,parent_mapping,dir,entry,i,buffer,st","s:-0.1097954511642456,mapping_index:-0.07642608880996704,mapping:-0.17619246244430542,direntry:-0.046419382095336914,dirname:-0.05457937717437744,parent_mapping:0.01615375280380249,dir:-0.045982182025909424,entry:-0.06479185819625854,i:-0.06253266334533691,buffer:0.07252159714698792,st:-0.03431195020675659,",6,62,"buffer:channel,parent_mapping:parent_smapping,st:stream,dir:direction,direntry:directry,dirname:dirName,",Greedy,435,0.10466066201527914
382,"static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)

{

    const char *p;

    char *q, buf1[20], c;

    int nd, len, addchar_count;

    int found_count = 0;



    q = buf;

    p = filename;

    for (;;) {

        c = *p;

        if (c == '\0')

            break;

        if (c == '%' && *(p+1) == '%')  // %%

            addchar_count = 2;

        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {

            nd = 0;

            addchar_count = 1;

            while (av_isdigit(*(p + addchar_count))) {

                nd = nd * 10 + *(p + addchar_count) - '0';

                addchar_count++;

            }



            if (*(p + addchar_count) == placeholder) {

                len = snprintf(buf1, sizeof(buf1), ""%0*""PRId64, (number < 0) ? nd : nd++, number);

                if (len < 1)  // returned error or empty buf1

                    goto fail;

                if ((q - buf + len) > buf_size - 1)

                    goto fail;

                memcpy(q, buf1, len);

                q += len;

                p += (addchar_count + 1);

                addchar_count = 0;

                found_count++;

            }



        } else

            addchar_count = 1;



        while (addchar_count--)

            if ((q - buf) < buf_size - 1)

                *q++ = *p++;

            else

                goto fail;

    }

    *q = '\0';

    return found_count;

fail:

    *q = '\0';

    return -1;

}
",327,"static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)

{

    const char *p;

    char *q, buf1[20], c;

    int nd, len, addcharacter_size;

    int foundancetotal = 0;



    q = buf;

    p = filename;

    for (;;) {

        c = *p;

        if (c == '\0')

            break;

        if (c == '%' && *(p+1) == '%')  // %%

            addcharacter_size = 2;

        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {

            nd = 0;

            addcharacter_size = 1;

            while (av_isdigit(*(p + addcharacter_size))) {

                nd = nd * 10 + *(p + addcharacter_size) - '0';

                addcharacter_size++;

            }



            if (*(p + addcharacter_size) == placeholder) {

                len = snprintf(buf1, sizeof(buf1), ""%0*""PRId64, (number < 0) ? nd : nd++, number);

                if (len < 1)  // returned error or empty buf1

                    goto fail;

                if ((q - buf + len) > buf_size - 1)

                    goto fail;

                memcpy(q, buf1, len);

                q += len;

                p += (addcharacter_size + 1);

                addcharacter_size = 0;

                foundancetotal++;

            }



        } else

            addcharacter_size = 1;



        while (addcharacter_size--)

            if ((q - buf) < buf_size - 1)

                *q++ = *p++;

            else

                goto fail;

    }

    *q = '\0';

    return foundancetotal;

fail:

    *q = '\0';

    return -1;

}
",0,0,1,1,"buf,buf_size,filename,placeholder,number,p,q,buf1,c,nd,len,addchar_count,found_count","buf:-0.09968674182891846,buf_size:0.07443767786026001,filename:-0.0478377640247345,placeholder:-0.05956524610519409,number:0.06521046161651611,p:-0.14167481660842896,q:0.01043933629989624,buf1:-0.04951423406600952,c:-0.006229668855667114,nd:-0.02295100688934326,len:-0.025924623012542725,addchar_count:0.2689574360847473,found_count:0.09066605567932129,",2,14,"addchar_count:addcharacter_size,found_count:foundancetotal,",Greedy,128,0.026724406083424888
383,"static void cubieboard_init(QEMUMachineInitArgs *args)

{

    CubieBoardState *s = g_new(CubieBoardState, 1);

    Error *err = NULL;



    s->a10 = AW_A10(object_new(TYPE_AW_A10));

    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);

    if (err != NULL) {

        error_report(""Couldn't realize Allwinner A10: %s\n"",

                error_get_pretty(err));

        exit(1);

    }



    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);

    vmstate_register_ram_global(&s->sdram);

    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,

                                &s->sdram);



    cubieboard_binfo.ram_size = args->ram_size;

    cubieboard_binfo.kernel_filename = args->kernel_filename;

    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;

    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);

}
",157,"static void cubieboard_init(QEMUMachineInitArgs *ants)

{

    CubieBoardState *ses = g_new(CubieBoardState, 1);

    Error *f = NULL;



    ses->a10 = AW_A10(object_new(TYPE_AW_A10));

    object_property_set_bool(OBJECT(ses->a10), true, ""realized"", &f);

    if (f != NULL) {

        error_report(""Couldn't realize Allwinner A10: %s
"",

                error_get_pretty(f));

        exit(1);

    }



    memory_region_init_ram(&ses->sdram, NULL, ""cubieboard.ram"", ants->ram_size);

    vmstate_register_ram_global(&ses->sdram);

    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,

                                &ses->sdram);



    cubieboard_binfo.ram_size = ants->ram_size;

    cubieboard_binfo.kernel_filename = ants->kernel_filename;

    cubieboard_binfo.kernel_cmdline = ants->kernel_cmdline;

    arm_load_kernel(&ses->a10->cpu, &cubieboard_binfo);

}
",0,0,0,-1,"args,s,err","args:0.029758557677268982,s:0.024140648543834686,err:0.04064113646745682,",3,16,"err:f,args:ants,s:ses,",Greedy,186,0.034312943617502846
384,"void esp_init(target_phys_addr_t espaddr, int it_shift,

              ESPDMAMemoryReadWriteFunc dma_memory_read,

              ESPDMAMemoryReadWriteFunc dma_memory_write,

              void *dma_opaque, qemu_irq irq, qemu_irq *reset,

              qemu_irq *dma_enable)

{

    DeviceState *dev;

    SysBusDevice *s;

    SysBusESPState *sysbus;

    ESPState *esp;



    dev = qdev_create(NULL, ""esp"");

    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);

    esp = &sysbus->esp;

    esp->dma_memory_read = dma_memory_read;

    esp->dma_memory_write = dma_memory_write;

    esp->dma_opaque = dma_opaque;

    sysbus->it_shift = it_shift;

    /* XXX for now until rc4030 has been changed to use DMA enable signal */

    esp->dma_enabled = 1;

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, espaddr);

    *reset = qdev_get_gpio_in(dev, 0);

    *dma_enable = qdev_get_gpio_in(dev, 1);

}
",158,,0,1,,-4,"espaddr,it_shift,dma_memory_read,dma_memory_write,dma_opaque,irq,reset,dma_enable,dev,s,sysbus,esp",,,,,Greedy,1,0.002454888820648193
385,"static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)

{

    WMACodecContext *s = avctx->priv_data;

    float **audio      = (float **) frame->extended_data;

    int len            = frame->nb_samples;

    int window_index   = s->frame_len_bits - s->block_len_bits;

    FFTContext *mdct   = &s->mdct_ctx[window_index];

    int ch;

    const float *win   = s->windows[window_index];

    int window_len     = 1 << s->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (ch = 0; ch < avctx->channels; ch++) {

        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));

        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);

        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],

                                    win, len);

        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);

        mdct->mdct_calc(mdct, s->coefs[ch], s->output);

    }

}
",233,,0,1,,-4,"avctx,frame,s,audio,mdct,ch,win",,,,,Greedy,1,0.002141384283701579
386,"static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,

                                const uint8_t *s2, int stride)

{

    int i;

    vec_u8 perm1 = vec_lvsl(0, s1);

    vec_u8 perm2 = vec_lvsl(0, s2);

    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);

    vec_s16 shorts1, shorts2;



    for (i = 0; i < 4; i++) {

        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        vec_u8 pixl  = vec_ld(0,  s1);

        vec_u8 pixr  = vec_ld(15, s1);

        vec_u8 bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shorts1 = vec_sub(shorts1, shorts2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shorts1, 0, (vec_s16 *)block);



        s1    += stride;

        s2    += stride;

        block += 8;



        /* The code below is a copy of the code above...

         * This is a manual unroll. */



        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        pixl  = vec_ld(0,  s1);

        pixr  = vec_ld(15, s1);

        bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shorts1 = vec_sub(shorts1, shorts2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shorts1, 0, (vec_s16 *)block);



        s1    += stride;

        s2    += stride;

        block += 8;

    }

}
",315,"static void diff_pixels_altivec(int16_t *restrict channel, const uint8_t *site127,

                                const uint8_t *ks20, int striding)

{

    int phi;

    vec_u8 perm1 = vec_lvsl(0, site127);

    vec_u8 perm2 = vec_lvsl(0, ks20);

    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);

    vec_s16 shapes0, chports2;



    for (phi = 0; phi < 4; phi++) {

        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        vec_u8 pixl  = vec_ld(0,  site127);

        vec_u8 pixr  = vec_ld(15, site127);

        vec_u8 bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shapes0 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  ks20);

        pixr  = vec_ld(15, ks20);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        chports2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shapes0 = vec_sub(shapes0, chports2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shapes0, 0, (vec_s16 *)channel);



        site127    += striding;

        ks20    += striding;

        channel += 8;



        /* The code below is a copy of the code above...

         * This is a manual unroll. */



        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        pixl  = vec_ld(0,  site127);

        pixr  = vec_ld(15, site127);

        bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shapes0 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  ks20);

        pixr  = vec_ld(15, ks20);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        chports2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shapes0 = vec_sub(shapes0, chports2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shapes0, 0, (vec_s16 *)channel);



        site127    += striding;

        ks20    += striding;

        channel += 8;

    }

}
",1,1,0,1,"block,s1,s2,stride,i,shorts1,shorts2","block:-0.030320286750793457,s1:-0.003571748733520508,s2:-0.009014546871185303,stride:-0.010432720184326172,i:-0.010846555233001709,shorts1:0.004682958126068115,shorts2:0.0023579001426696777,",7,44,"shorts1:shapes0,shorts2:chports2,s1:site127,s2:ks20,stride:striding,i:phi,block:channel,",Greedy,592,0.11240619818369547
387,"int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)

{

    PerThreadContext *p = avctx->thread_opaque;

    int *progress, err;



    f->owner = avctx;



    ff_init_buffer_info(avctx, f);



    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {

        f->thread_opaque = NULL;

        return avctx->get_buffer(avctx, f);

    }



    if (p->state != STATE_SETTING_UP &&

        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&

                avctx->get_buffer != avcodec_default_get_buffer))) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() cannot be called after ff_thread_finish_setup()\n"");

        return -1;

    }



    pthread_mutex_lock(&p->parent->buffer_mutex);

    f->thread_opaque = progress = allocate_progress(p);



    if (!progress) {

        pthread_mutex_unlock(&p->parent->buffer_mutex);

        return -1;

    }



    progress[0] =

    progress[1] = -1;



    if (avctx->thread_safe_callbacks ||

        avctx->get_buffer == avcodec_default_get_buffer) {

        err = avctx->get_buffer(avctx, f);

    } else {

        p->requested_frame = f;

        p->state = STATE_GET_BUFFER;

        pthread_mutex_lock(&p->progress_mutex);

        pthread_cond_signal(&p->progress_cond);



        while (p->state != STATE_SETTING_UP)

            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);



        err = p->result;



        pthread_mutex_unlock(&p->progress_mutex);



        if (!avctx->codec->update_thread_context)

            ff_thread_finish_setup(avctx);

    }



    pthread_mutex_unlock(&p->parent->buffer_mutex);



    return err;

}
",284,,1,0,,-4,"avctx,f,p,progress,err",,,,,Greedy,1,0.0021200974782307944
388,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}",37,"bool qio_task_propagate_error(QIOTask *exec,

                              Error **erps)

{

    if (exec->err) {

        error_propagate(erps, exec->err);


        return true;

    }



    return false;

}",1,1,0,1,"task,errp","task:-0.2102501392364502,errp:-0.24058109521865845,",2,5,"task:exec,errp:erps,",Greedy,81,0.016709478696187337
389,"static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}
",203,"static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *dos = &c->streams[i];

        if (dos->out)

            avio_close(dos->out);

        dos->out = NULL;

        if (dos->ctx && dos->ctx_inited)

            av_write_trailer(dos->ctx);

        if (dos->ctx && dos->ctx->pb)

            av_free(dos->ctx->pb);

        if (dos->ctx)

            avformat_free_context(dos->ctx);

        av_free(dos->metadata);

        for (j = 0; j < dos->nb_extra_packets; j++)

            av_free(dos->extra_packets[j]);

        for (j = 0; j < dos->nb_fragments; j++)

            av_free(dos->fragments[j]);

        av_free(dos->fragments);

    }

    av_freep(&c->streams);

}
",0,0,1,1,"s,c,i,j,os","s:0.02241942286491394,c:0.05789497494697571,i:-0.07490357756614685,j:-0.05439533293247223,os:0.0818842202425003,",1,18,"os:dos,",Greedy,106,0.01988758643468221
390,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
",233,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abef0 = hasAlpha ? abuf[0] : NULL,

                  *ebbuffn = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int z;



    for (z = 0; z < dstW; z++) {

        int Y = (buf0[z * 2] * yalpha1 + buf1[z * 2] * yalpha) >> 19;

        int AF;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            AF = (abef0[z * 2] * yalpha1 + ebbuffn[z * 2] * yalpha) >> 19;

            AF = av_clip_uint8(AF);

        }



        dest[z * 2    ] = Y;

        dest[z * 2 + 1] = hasAlpha ? AF : 255;

    }

}
",1,1,0,1,"buf0,buf1,abuf0,abuf1,i,A","buf0:-0.008571207523345947,buf1:0.002995908260345459,abuf0:0.037705063819885254,abuf1:0.015385866165161133,i:0.1934003233909607,A:0.0991131067276001,",4,19,"i:z,A:AF,abuf0:abef0,abuf1:ebbuffn,",Greedy,223,0.04404717286427816
391,"static void device_unparent(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    BusState *bus;



    if (dev->realized) {

        object_property_set_bool(obj, false, ""realized"", NULL);

    }

    while (dev->num_child_bus) {

        bus = QLIST_FIRST(&dev->child_bus);

        object_unparent(OBJECT(bus));

    }

    if (dev->parent_bus) {

        bus_remove_child(dev->parent_bus, dev);

        object_unref(OBJECT(dev->parent_bus));

        dev->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (dev->pending_deleted_event) {

        g_assert(dev->canonical_path);



        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,

                                       &error_abort);

        g_free(dev->canonical_path);

        dev->canonical_path = NULL;

    }

}
",150,"static void device_unparent(Object *pos)

{

    DeviceState *gd = DEVICE(pos);

    BusState *bus;



    if (gd->realized) {

        object_property_set_bool(pos, false, ""realized"", NULL);

    }

    while (gd->num_child_bus) {

        bus = QLIST_FIRST(&gd->child_bus);

        object_unparent(OBJECT(bus));

    }

    if (gd->parent_bus) {

        bus_remove_child(gd->parent_bus, gd);

        object_unref(OBJECT(gd->parent_bus));

        gd->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (gd->pending_deleted_event) {

        g_assert(gd->canonical_path);



        qapi_event_send_device_deleted(!!gd->id, gd->id, gd->canonical_path,

                                       &error_abort);

        g_free(gd->canonical_path);

        gd->canonical_path = NULL;

    }

}
",1,1,0,1,"obj,dev,bus","obj:-0.02968418598175049,dev:0.020535409450531006,bus:-0.05159294605255127,",2,19,"dev:gd,obj:pos,",Greedy,142,0.027852070331573487
392,"QBool *qbool_from_bool(bool value)

{

    QBool *qb;



    qb = g_malloc(sizeof(*qb));

    qb->value = value;

    QOBJECT_INIT(qb, &qbool_type);



    return qb;

}
",41,"QBool *qbool_from_bool(bool error)

{

    QBool *QB;



    QB = g_malloc(sizeof(*QB));

    QB->error = error;

    QOBJECT_INIT(QB, &qbool_type);



    return QB;

}
",0,0,0,-1,"value,qb","value:0.0015212027356028557,qb:0.0019272039644420147,",2,9,"qb:QB,value:error,",Greedy,125,0.022252798080444336
393,"static void setup_rt_frame(int usig, struct emulated_sigaction *ka, 

                           target_siginfo_t *info,

			   target_sigset_t *set, CPUState *env)

{

	struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));

	int err = 0;



#if 0

	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))

            return 1;

#endif

	__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);

	__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);

	err |= copy_siginfo_to_user(&frame->info, info);



	/* Clear all the bits of the ucontext we don't use.  */

	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));



	err |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/

				env, set->sig[0]);

	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));



	if (err == 0)

		err = setup_return(env, ka, &frame->retcode, frame, usig);



	if (err == 0) {

		/*

		 * For realtime signals we must also set the second and third

		 * arguments for the signal handler.

		 *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06

		 */

            env->regs[1] = (target_ulong)frame->pinfo;

            env->regs[2] = (target_ulong)frame->puc;

	}



        //	return err;

}
",241,,0,1,,-4,"usig,ka,info,set,env,frame",,,,,Greedy,1,0.0022542476654052734
394,"static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index,

                                uint64_t *buid, hwaddr *pio,

                                hwaddr *mmio32, hwaddr *mmio64,

                                unsigned n_dma, uint32_t *liobns, Error **errp)

{

    /*

     * New-style PHB window placement.

     *

     * Goals: Gives large (1TiB), naturally aligned 64-bit MMIO window

     * for each PHB, in addition to 2GiB 32-bit MMIO and 64kiB PIO

     * windows.

     *

     * Some guest kernels can't work with MMIO windows above 1<<46

     * (64TiB), so we place up to 31 PHBs in the area 32TiB..64TiB

     *

     * 32TiB..(33TiB+1984kiB) contains the 64kiB PIO windows for each

     * PHB stacked together.  (32TiB+2GiB)..(32TiB+64GiB) contains the

     * 2GiB 32-bit MMIO windows for each PHB.  Then 33..64TiB has the

     * 1TiB 64-bit MMIO windows for each PHB.

     */

    const uint64_t base_buid = 0x800000020000000ULL;

    const int max_phbs =

        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;

    int i;



    /* Sanity check natural alignments */

    QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0);

    QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0);

    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0);

    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0);

    /* Sanity check bounds */

    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE);

    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE);



    if (index >= max_phbs) {

        error_setg(errp, ""\""index\"" for PAPR PHB is too large (max %u)"",

                   max_phbs - 1);

        return;

    }



    *buid = base_buid + index;

    for (i = 0; i < n_dma; ++i) {

        liobns[i] = SPAPR_PCI_LIOBN(index, i);

    }



    *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE;

    *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE;

    *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE;

}
",223,"static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t ix,

                                uint64_t *buId, hwaddr * pix,

                                hwaddr *mmio32, hwaddr *mmio64,

                                unsigned n_dma, uint32_t *liobns, Error **errp)

{

    /*

     * New-style PHB window placement.

     *

     * Goals: Gives large (1TiB), naturally aligned 64-bit MMIO window

     * for each PHB, in addition to 2GiB 32-bit MMIO and 64kiB PIO

     * windows.

     *

     * Some guest kernels can't work with MMIO windows above 1<<46

     * (64TiB), so we place up to 31 PHBs in the area 32TiB..64TiB

     *

     * 32TiB..(33TiB+1984kiB) contains the 64kiB PIO windows for each

     * PHB stacked together.  (32TiB+2GiB)..(32TiB+64GiB) contains the

     * 2GiB 32-bit MMIO windows for each PHB.  Then 33..64TiB has the

     * 1TiB 64-bit MMIO windows for each PHB.

     */

    const uint64_t base_buid = 0x800000020000000ULL;

    const int max_phbs =

        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;

    int i;



    /* Sanity check natural alignments */

    QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0);

    QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0);

    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0);

    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0);

    /* Sanity check bounds */

    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE);

    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE);



    if (ix >= max_phbs) {

        error_setg(errp, ""\""index\"" for PAPR PHB is too large (max %u)"",

                   max_phbs - 1);

        return;

    }



    *buId = base_buid + ix;

    for (i = 0; i < n_dma; ++i) {

        liobns[i] = SPAPR_PCI_LIOBN(ix, i);

    }



    * pix = SPAPR_PCI_BASE + ix * SPAPR_PCI_IO_WIN_SIZE;

    *mmio32 = SPAPR_PCI_BASE + (ix + 1) * SPAPR_PCI_MEM32_WIN_SIZE;

    *mmio64 = SPAPR_PCI_BASE + (ix + 1) * SPAPR_PCI_MEM64_WIN_SIZE;

}
",1,1,0,1,"spapr,index,buid,pio,mmio32,mmio64,n_dma,liobns,errp,i","spapr:0.003012239933013916,index:0.11973714828491211,buid:0.15877312421798706,pio:0.1063544750213623,mmio32:-0.058598339557647705,mmio64:-0.03453660011291504,n_dma:0.019974887371063232,liobns:0.02763456106185913,errp:-0.018878400325775146,i:0.04961615800857544,",3,11,"buid:buId,index:ix,pio: pix,",Greedy,129,0.02987436850865682
395,"static void ppc405ep_compute_clocks (ppc405ep_cpc_t *cpc)

{

    uint32_t CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk;

    uint32_t UART0_clk, UART1_clk;

    uint64_t VCO_out, PLL_out;

    int M, D;



    VCO_out = 0;

    if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) {

        M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; /* FBMUL */

#ifdef DEBUG_CLOCKS_LL

        printf(""FBMUL %01"" PRIx32 "" %d\n"", (cpc->pllmr[1] >> 20) & 0xF, M);

#endif

        D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); /* FWDA */

#ifdef DEBUG_CLOCKS_LL

        printf(""FWDA %01"" PRIx32 "" %d\n"", (cpc->pllmr[1] >> 16) & 0x7, D);

#endif

        VCO_out = cpc->sysclk * M * D;

        if (VCO_out < 500000000UL || VCO_out > 1000000000UL) {

            /* Error - unlock the PLL */

            printf(""VCO out of range %"" PRIu64 ""\n"", VCO_out);

#if 0

            cpc->pllmr[1] &= ~0x80000000;

            goto pll_bypass;

#endif

        }

        PLL_out = VCO_out / D;

        /* Pretend the PLL is locked */

        cpc->boot |= 0x00000001;

    } else {

#if 0

    pll_bypass:

#endif

        PLL_out = cpc->sysclk;

        if (cpc->pllmr[1] & 0x40000000) {

            /* Pretend the PLL is not locked */

            cpc->boot &= ~0x00000001;

        }

    }

    /* Now, compute all other clocks */

    D = ((cpc->pllmr[0] >> 20) & 0x3) + 1; /* CCDV */

#ifdef DEBUG_CLOCKS_LL

    printf(""CCDV %01"" PRIx32 "" %d\n"", (cpc->pllmr[0] >> 20) & 0x3, D);

#endif

    CPU_clk = PLL_out / D;

    D = ((cpc->pllmr[0] >> 16) & 0x3) + 1; /* CBDV */

#ifdef DEBUG_CLOCKS_LL

    printf(""CBDV %01"" PRIx32 "" %d\n"", (cpc->pllmr[0] >> 16) & 0x3, D);

#endif

    PLB_clk = CPU_clk / D;

    D = ((cpc->pllmr[0] >> 12) & 0x3) + 1; /* OPDV */

#ifdef DEBUG_CLOCKS_LL

    printf(""OPDV %01"" PRIx32 "" %d\n"", (cpc->pllmr[0] >> 12) & 0x3, D);

#endif

    OPB_clk = PLB_clk / D;

    D = ((cpc->pllmr[0] >> 8) & 0x3) + 2; /* EPDV */

#ifdef DEBUG_CLOCKS_LL

    printf(""EPDV %01"" PRIx32 "" %d\n"", (cpc->pllmr[0] >> 8) & 0x3, D);

#endif

    EBC_clk = PLB_clk / D;

    D = ((cpc->pllmr[0] >> 4) & 0x3) + 1; /* MPDV */

#ifdef DEBUG_CLOCKS_LL

    printf(""MPDV %01"" PRIx32 "" %d\n"", (cpc->pllmr[0] >> 4) & 0x3, D);

#endif

    MAL_clk = PLB_clk / D;

    D = (cpc->pllmr[0] & 0x3) + 1; /* PPDV */

#ifdef DEBUG_CLOCKS_LL

    printf(""PPDV %01"" PRIx32 "" %d\n"", cpc->pllmr[0] & 0x3, D);

#endif

    PCI_clk = PLB_clk / D;

    D = ((cpc->ucr - 1) & 0x7F) + 1; /* U0DIV */

#ifdef DEBUG_CLOCKS_LL

    printf(""U0DIV %01"" PRIx32 "" %d\n"", cpc->ucr & 0x7F, D);

#endif

    UART0_clk = PLL_out / D;

    D = (((cpc->ucr >> 8) - 1) & 0x7F) + 1; /* U1DIV */

#ifdef DEBUG_CLOCKS_LL

    printf(""U1DIV %01"" PRIx32 "" %d\n"", (cpc->ucr >> 8) & 0x7F, D);

#endif

    UART1_clk = PLL_out / D;

#ifdef DEBUG_CLOCKS

    printf(""Setup PPC405EP clocks - sysclk %"" PRIu32 "" VCO %"" PRIu64

           "" PLL out %"" PRIu64 "" Hz\n"", cpc->sysclk, VCO_out, PLL_out);

    printf(""CPU %"" PRIu32 "" PLB %"" PRIu32 "" OPB %"" PRIu32 "" EBC %"" PRIu32

           "" MAL %"" PRIu32 "" PCI %"" PRIu32 "" UART0 %"" PRIu32

           "" UART1 %"" PRIu32 ""\n"",

           CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk,

           UART0_clk, UART1_clk);

#endif

    /* Setup CPU clocks */

    clk_setup(&cpc->clk_setup[PPC405EP_CPU_CLK], CPU_clk);

    /* Setup PLB clock */

    clk_setup(&cpc->clk_setup[PPC405EP_PLB_CLK], PLB_clk);

    /* Setup OPB clock */

    clk_setup(&cpc->clk_setup[PPC405EP_OPB_CLK], OPB_clk);

    /* Setup external clock */

    clk_setup(&cpc->clk_setup[PPC405EP_EBC_CLK], EBC_clk);

    /* Setup MAL clock */

    clk_setup(&cpc->clk_setup[PPC405EP_MAL_CLK], MAL_clk);

    /* Setup PCI clock */

    clk_setup(&cpc->clk_setup[PPC405EP_PCI_CLK], PCI_clk);

    /* Setup UART0 clock */

    clk_setup(&cpc->clk_setup[PPC405EP_UART0_CLK], UART0_clk);

    /* Setup UART1 clock */

    clk_setup(&cpc->clk_setup[PPC405EP_UART1_CLK], UART1_clk);

}
",835,,1,0,,-4,"cpc,CPU_clk,PLB_clk,OPB_clk,EBC_clk,MAL_clk,PCI_clk,UART0_clk,UART1_clk,VCO_out,PLL_out,M,D",,,,,Greedy,1,0.0023976445198059084
396,"av_cold void ff_wmv2_common_init(Wmv2Context * w){

    MpegEncContext * const s= &w->s;



    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);

    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);

}
",58,,1,0,,-4,"w,s",,,,,Greedy,1,0.0021017710367838543
397,"void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));",121,"void tap_fd_set_offload(int form, int chesumption, int fbo84,
                        int tco613, int ECn, int ucho)
{
    unsigned int offload = 0;
    if (chesumption) {
        offload |= TUN_F_CSUM;
        if (fbo84)
            offload |= TUN_F_TSO4;
        if (tco613)
            offload |= TUN_F_TSO6;
        if ((fbo84 || tco613) && ECn)
            offload |= TUN_F_TSO_ECN;
        if (ucho)
            offload |= TUN_F_UFO;
    if (ioctl(form, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(form, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s
"",
                    strerror(errno));",1,1,1,-1,"fd,csum,tso4,tso6,ecn,ufo","fd:0.0032439231872558594,csum:-0.0006351470947265625,tso4:0.007178604602813721,tso6:0.0053400397300720215,ecn:0.0009568333625793457,ufo:-0.0006570816040039062,",6,15,"tso4:fbo84,tso6:tco613,fd:form,ecn:ECn,csum:chesumption,ufo:ucho,",Greedy,256,0.048036416371663414
398,"void ff_mpeg1_encode_init(MpegEncContext *s)

{

    static int done=0;



    common_init(s);



    if(!done){

        int f_code;

        int mv;

	int i;



        done=1;

        init_rl(&rl_mpeg1);



	for(i=0; i<64; i++)

	{

		mpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i];

		mpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i];

	}

        

        init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len);



	/* build unified dc encoding tables */

	for(i=-255; i<256; i++)

	{

		int adiff, index;

		int bits, code;

		int diff=i;



		adiff = ABS(diff);

		if(diff<0) diff--;

		index = av_log2(2*adiff);



		bits= vlc_dc_lum_bits[index] + index;

		code= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1));

		mpeg1_lum_dc_uni[i+255]= bits + (code<<8);

		

		bits= vlc_dc_chroma_bits[index] + index;

		code= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1));

		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);

	}



        mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) );



        for(f_code=1; f_code<=MAX_FCODE; f_code++){

            for(mv=-MAX_MV; mv<=MAX_MV; mv++){

                int len;



                if(mv==0) len= mbMotionVectorTable[0][1];

                else{

                    int val, bit_size, range, code;



                    bit_size = f_code - 1;

                    range = 1 << bit_size;



                    val=mv;

                    if (val < 0) 

                        val = -val;

                    val--;

                    code = (val >> bit_size) + 1;

                    if(code<17){

                        len= mbMotionVectorTable[code][1] + 1 + bit_size;

                    }else{

                        len= mbMotionVectorTable[16][1] + 2 + bit_size;

                    }

                }



                mv_penalty[f_code][mv+MAX_MV]= len;

            }

        }

        



        for(f_code=MAX_FCODE; f_code>0; f_code--){

            for(mv=-(8<<f_code); mv<(8<<f_code); mv++){

                fcode_tab[mv+MAX_MV]= f_code;

            }

        }

    }

    s->me.mv_penalty= mv_penalty;

    s->fcode_tab= fcode_tab;

    if(s->codec_id == CODEC_ID_MPEG1VIDEO){

        s->min_qcoeff=-255;

        s->max_qcoeff= 255;

    }else{

        s->min_qcoeff=-2047;

        s->max_qcoeff= 2047;

    }

    s->intra_ac_vlc_length=

    s->inter_ac_vlc_length=

    s->intra_ac_vlc_last_length=

    s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len;

}
",554,"void ff_mpeg1_encode_init(MpegEncContext *s)

{

    static int done=0;



    common_init(s);



    if(!done){

        int f_code;

        int mva;

	int i;



        done=1;

        init_rl(&rl_mpeg1);



	for(i=0; i<64; i++)

	{

		mpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i];

		mpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i];

	}

        

        init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len);



	/* build unified dc encoding tables */

	for(i=-255; i<256; i++)

	{

		int adiff, index;

		int bits, code;

		int diff=i;



		adiff = ABS(diff);

		if(diff<0) diff--;

		index = av_log2(2*adiff);



		bits= vlc_dc_lum_bits[index] + index;

		code= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1));

		mpeg1_lum_dc_uni[i+255]= bits + (code<<8);

		

		bits= vlc_dc_chroma_bits[index] + index;

		code= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1));

		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);

	}



        mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) );



        for(f_code=1; f_code<=MAX_FCODE; f_code++){

            for(mva=-MAX_MV; mva<=MAX_MV; mva++){

                int lon;



                if(mva==0) lon= mbMotionVectorTable[0][1];

                else{

                    int vol, bit64count, label, code;



                    bit64count = f_code - 1;

                    label = 1 << bit64count;



                    vol=mva;

                    if (vol < 0) 

                        vol = -vol;

                    vol--;

                    code = (vol >> bit64count) + 1;

                    if(code<17){

                        lon= mbMotionVectorTable[code][1] + 1 + bit64count;

                    }else{

                        lon= mbMotionVectorTable[16][1] + 2 + bit64count;

                    }

                }



                mv_penalty[f_code][mva+MAX_MV]= lon;

            }

        }

        



        for(f_code=MAX_FCODE; f_code>0; f_code--){

            for(mva=-(8<<f_code); mva<(8<<f_code); mva++){

                fcode_tab[mva+MAX_MV]= f_code;

            }

        }

    }

    s->me.mv_penalty= mv_penalty;

    s->fcode_tab= fcode_tab;

    if(s->codec_id == CODEC_ID_MPEG1VIDEO){

        s->min_qcoeff=-255;

        s->max_qcoeff= 255;

    }else{

        s->min_qcoeff=-2047;

        s->max_qcoeff= 2047;

    }

    s->intra_ac_vlc_length=

    s->inter_ac_vlc_length=

    s->intra_ac_vlc_last_length=

    s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len;

}
",1,1,0,1,"s,f_code,mv,i,adiff,index,bits,code,diff,len,val,bit_size,range","s:-0.06484586000442505,f_code:-0.01423865556716919,mv:0.011994481086730957,i:-0.17465466260910034,adiff:-0.011299967765808105,index:-0.09381580352783203,bits:-0.03241318464279175,code:-0.03360092639923096,diff:-0.11022156476974487,len:-0.010936617851257324,val:-4.172325134277344e-06,bit_size:-3.5762786865234375e-06,range:-1.1920928955078125e-06,",5,31,"mv:mva,range:label,bit_size:bit64count,val:vol,len:lon,",Greedy,246,0.054162442684173584
399,"static av_cold int ac3_decode_init(AVCodecContext *avctx)

{

    AC3DecodeContext *s = avctx->priv_data;

    s->avctx = avctx;



    ff_ac3_common_init();

    ac3_tables_init();

    ff_mdct_init(&s->imdct_256, 8, 1, 1.0);

    ff_mdct_init(&s->imdct_512, 9, 1, 1.0);

    ff_kbd_window_init(s->window, 5.0, 256);

    dsputil_init(&s->dsp, avctx);

    ff_fmt_convert_init(&s->fmt_conv, avctx);

    av_lfg_init(&s->dith_state, 0);



    /* set scale value for float to int16 conversion */

    s->mul_bias = 32767.0f;



    /* allow downmixing to stereo or mono */

    if (avctx->channels > 0 && avctx->request_channels > 0 &&

            avctx->request_channels < avctx->channels &&

            avctx->request_channels <= 2) {

        avctx->channels = avctx->request_channels;

    }

    s->downmixed = 1;



    /* allocate context input buffer */

    if (avctx->error_recognition >= FF_ER_CAREFUL) {

        s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!s->input_buffer)

            return AVERROR(ENOMEM);

    }



    avctx->sample_fmt = AV_SAMPLE_FMT_S16;

    return 0;

}
",195,,1,0,,-4,"avctx,s",,,,,Greedy,1,0.0020070791244506834

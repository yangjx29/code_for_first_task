Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,No. Changed Names,No. Changed Tokens,Replaced Names,Attack Type,Query Times,Time Cost
1,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *s = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int ring_order;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {


            goto out;

        }




        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->xendev.gnttabdev,

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        ring_order = xen_9pdev->rings[i].intf->ring_order;

        if (ring_order > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].ring_order = ring_order;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->xendev.gnttabdev,

                (1 << ring_order),

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(ring_order);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             xendev->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(xendev, 0,

                          ""xenevtchn_bind_interdomain failed port=%d\n"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(xendev, 2, ""bind evtchn port %d\n"", xendev->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(xendev, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(xendev, ""path"");

    xen_9pdev->id = s->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", xendev->dev);

    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, ""tag"");

    v9fs_register_transport(s, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            s->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(s, NULL);



    return 0;



out:

    xen_9pfs_free(xendev);

    return -1;

}",826,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *pix_fmt = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int tcg_gen_concat_tl_i64;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {


            goto out;

        }




        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->xendev.gnttabdev,

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        tcg_gen_concat_tl_i64 = xen_9pdev->rings[i].intf->tcg_gen_concat_tl_i64;

        if (tcg_gen_concat_tl_i64 > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].tcg_gen_concat_tl_i64 = tcg_gen_concat_tl_i64;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->xendev.gnttabdev,

                (1 << tcg_gen_concat_tl_i64),

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(tcg_gen_concat_tl_i64);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             xendev->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(xendev, 0,

                          ""xenevtchn_bind_interdomain failed port=%d
"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(xendev, 2, ""bind evtchn port %d
"", xendev->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(xendev, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(xendev, ""path"");

    xen_9pdev->id = pix_fmt->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", xendev->dev);

    xen_9pdev->tag = pix_fmt->fsconf.tag = xenstore_read_fe_str(xendev, ""tag"");

    v9fs_register_transport(pix_fmt, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            pix_fmt->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, pix_fmt->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(pix_fmt, NULL);



    return 0;



out:

    xen_9pfs_free(xendev);

    return -1;

}",1,1,0,1,s,-0.15661945939064026,2,15,"{'ring_order': 'tcg_gen_concat_tl_i64', 's': 'pix_fmt'}",MHM-Origin,39,0.01986699104309082
4,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    float aspect;



    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    s->aspect_ratio_info= get_bits(&s->gb, 4);

    if(!s->mpeg2){

        aspect= mpeg1_aspect[s->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        avctx->has_b_frames= 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        if (s->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            avctx->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        }

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_intra_matrix[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->inter_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_non_intra_matrix[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    avctx->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",757,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *encode_imm, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *APB_SPECIAL_BASE = &s1->mpeg_enc_ctx;

    int width, height, i, CPUFLAG_SSE4, j;

    float aspect;



    init_get_bits(&APB_SPECIAL_BASE->gb, encode_imm, buf_size);



    width = get_bits(&APB_SPECIAL_BASE->gb, 12);

    height = get_bits(&APB_SPECIAL_BASE->gb, 12);

    APB_SPECIAL_BASE->aspect_ratio_info= get_bits(&APB_SPECIAL_BASE->gb, 4);

    if(!APB_SPECIAL_BASE->mpeg2){

        aspect= mpeg1_aspect[APB_SPECIAL_BASE->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    APB_SPECIAL_BASE->frame_rate_index = get_bits(&APB_SPECIAL_BASE->gb, 4);

    if (APB_SPECIAL_BASE->frame_rate_index == 0)

        return -1;

    APB_SPECIAL_BASE->bit_rate = get_bits(&APB_SPECIAL_BASE->gb, 18) * 400;

    if (get_bits1(&APB_SPECIAL_BASE->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != APB_SPECIAL_BASE->width ||

        height != APB_SPECIAL_BASE->height) {

        /* start new mpeg1 context decoding */

        APB_SPECIAL_BASE->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(APB_SPECIAL_BASE);

        }

        APB_SPECIAL_BASE->width = width;

        APB_SPECIAL_BASE->height = height;

        avctx->has_b_frames= 1;

        APB_SPECIAL_BASE->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        if (APB_SPECIAL_BASE->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            avctx->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            avctx->frame_rate = frame_rate_tab[APB_SPECIAL_BASE->frame_rate_index];

        }

        APB_SPECIAL_BASE->frame_rate = avctx->frame_rate;

        avctx->bit_rate = APB_SPECIAL_BASE->bit_rate;

        

        if (MPV_common_init(APB_SPECIAL_BASE) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&APB_SPECIAL_BASE->gb, 10); /* vbv_buffer_size */

    skip_bits(&APB_SPECIAL_BASE->gb, 1);



    /* get matrix */

    if (get_bits1(&APB_SPECIAL_BASE->gb)) {

        for(i=0;i<64;i++) {

            CPUFLAG_SSE4 = get_bits(&APB_SPECIAL_BASE->gb, 8);

            j = APB_SPECIAL_BASE->intra_scantable.permutated[i];

            APB_SPECIAL_BASE->intra_matrix[j] = CPUFLAG_SSE4;

            APB_SPECIAL_BASE->chroma_intra_matrix[j] = CPUFLAG_SSE4;

        }

#ifdef DEBUG

        dprintf(""intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", APB_SPECIAL_BASE->intra_matrix[APB_SPECIAL_BASE->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= APB_SPECIAL_BASE->idct_permutation[i];

            CPUFLAG_SSE4 = ff_mpeg1_default_intra_matrix[i];

            APB_SPECIAL_BASE->intra_matrix[j] = CPUFLAG_SSE4;

            APB_SPECIAL_BASE->chroma_intra_matrix[j] = CPUFLAG_SSE4;

        }

    }

    if (get_bits1(&APB_SPECIAL_BASE->gb)) {

        for(i=0;i<64;i++) {

            CPUFLAG_SSE4 = get_bits(&APB_SPECIAL_BASE->gb, 8);

            j = APB_SPECIAL_BASE->intra_scantable.permutated[i];

            APB_SPECIAL_BASE->inter_matrix[j] = CPUFLAG_SSE4;

            APB_SPECIAL_BASE->chroma_inter_matrix[j] = CPUFLAG_SSE4;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", APB_SPECIAL_BASE->inter_matrix[APB_SPECIAL_BASE->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= APB_SPECIAL_BASE->idct_permutation[i];

            CPUFLAG_SSE4 = ff_mpeg1_default_non_intra_matrix[i];

            APB_SPECIAL_BASE->inter_matrix[j] = CPUFLAG_SSE4;

            APB_SPECIAL_BASE->chroma_inter_matrix[j] = CPUFLAG_SSE4;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    APB_SPECIAL_BASE->progressive_sequence = 1;

    APB_SPECIAL_BASE->progressive_frame = 1;

    APB_SPECIAL_BASE->picture_structure = PICT_FRAME;

    APB_SPECIAL_BASE->frame_pred_frame_dct = 1;

    APB_SPECIAL_BASE->mpeg2 = 0;

    avctx->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",0,0,1,1,v,0.1736917495727539,3,68,"{'s': 'APB_SPECIAL_BASE', 'buf': 'encode_imm', 'v': 'CPUFLAG_SSE4'}",MHM-Origin,61,0.030010306835174562
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
",45,"static uint32_t drc_set_unusable(sPAPRDRConnector *QTAILQ_REMOVE)

{

    QTAILQ_REMOVE->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (QTAILQ_REMOVE->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(QTAILQ_REMOVE);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(QTAILQ_REMOVE);

    }



    return RTAS_OUT_SUCCESS;

}
",0,0,0,-1,drc,-0.005069925915449858,1,5,{'drc': 'nb_mmco'},MHM-Origin,386,0.16987762053807576
6,"static void scsi_read_request(SCSIDiskReq *r)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    if (r->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd\n"", r->iov.iov_len);

        r->sector_count = 0;

        scsi_req_data(&r->req, r->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d\n"", r->sector_count);

    if (r->sector_count == 0) {

        scsi_command_complete(r, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    n = r->sector_count;

    if (n > SCSI_DMA_BUF_SIZE / 512)

        n = SCSI_DMA_BUF_SIZE / 512;



    r->iov.iov_len = n * 512;

    qemu_iovec_init_external(&r->qiov, &r->iov, 1);

    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,

                              scsi_read_complete, r);

    if (r->req.aiocb == NULL) {

        scsi_read_complete(r, -EIO);

    }

}
",214,"static void scsi_read_request(SCSIDiskReq *r)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t pci_bus3;



    if (r->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd
"", r->iov.iov_len);

        r->sector_count = 0;

        scsi_req_data(&r->req, r->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d
"", r->sector_count);

    if (r->sector_count == 0) {

        scsi_command_complete(r, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    pci_bus3 = r->sector_count;

    if (pci_bus3 > SCSI_DMA_BUF_SIZE / 512)

        pci_bus3 = SCSI_DMA_BUF_SIZE / 512;



    r->iov.iov_len = pci_bus3 * 512;

    qemu_iovec_init_external(&r->qiov, &r->iov, 1);

    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, pci_bus3,

                              scsi_read_complete, r);

    if (r->req.aiocb == NULL) {

        scsi_read_complete(r, -EIO);

    }

}
",1,1,0,1,n,-0.05197662115097046,1,6,{'n': 'pci_bus3'},MHM-Origin,21,0.009037641684214275
8,"aio_write_f(int argc, char **argv)

{

	char *p;

	int count = 0;

	int nr_iov, i, c;

	int pattern = 0xcd;

	struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((c = getopt(argc, argv, ""CqP:"")) != EOF) {

		switch (c) {

		case 'C':

			ctx->Cflag = 1;

			break;

		case 'q':

			ctx->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	ctx->offset = cvtnum(argv[optind]);

	if (ctx->offset < 0) {

		printf(""non-numeric length argument -- %s\n"", argv[optind]);

		return 0;

	}

	optind++;



	if (ctx->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)ctx->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned\n"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"", argv[i]);

			return 0;

		}

		count += len;

	}



	nr_iov = argc - optind;

	qemu_iovec_init(&ctx->qiov, nr_iov);

	ctx->buf = p = qemu_io_alloc(count, pattern);

	for (i = 0; i < nr_iov; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"",

				argv[optind]);

			return 0;

		}



		qemu_iovec_add(&ctx->qiov, p, len);

		p += len;

		optind++;

	}



	gettimeofday(&ctx->t1, NULL);

	acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,

			      ctx->qiov.size >> 9, aio_write_done, ctx);

	if (!acb)

		return -EIO;



	return 0;

}
",439,"aio_write_f(int argc, char **argv)

{

	char *p;

	int count = 0;

	int vmstate_spapr, get_bits_long, c;

	int pattern = 0xcd;

	struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((c = getopt(argc, argv, ""CqP:"")) != EOF) {

		switch (c) {

		case 'C':

			ctx->Cflag = 1;

			break;

		case 'q':

			ctx->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	ctx->offset = cvtnum(argv[optind]);

	if (ctx->offset < 0) {

		printf(""non-numeric length argument -- %s
"", argv[optind]);

		return 0;

	}

	optind++;



	if (ctx->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned
"",

			(long long)ctx->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned
"",

			count);

		return 0;

	}



	for (get_bits_long = optind; get_bits_long < argc; get_bits_long++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s
"", argv[get_bits_long]);

			return 0;

		}

		count += len;

	}



	vmstate_spapr = argc - optind;

	qemu_iovec_init(&ctx->qiov, vmstate_spapr);

	ctx->buf = p = qemu_io_alloc(count, pattern);

	for (get_bits_long = 0; get_bits_long < vmstate_spapr; get_bits_long++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s
"",

				argv[optind]);

			return 0;

		}



		qemu_iovec_add(&ctx->qiov, p, len);

		p += len;

		optind++;

	}



	gettimeofday(&ctx->t1, NULL);

	acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,

			      ctx->qiov.size >> 9, aio_write_done, ctx);

	if (!acb)

		return -EIO;



	return 0;

}
",0,0,1,1,i,0.22440847754478455,2,12,"{'nr_iov': 'vmstate_spapr', 'i': 'get_bits_long'}",MHM-Origin,42,0.018623832861582437
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188,"static void vc1_inv_trans_8x8_dc_c(uint8_t *ga_channel_listen_add, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        ga_channel_listen_add[0] = cm[ga_channel_listen_add[0]];

        ga_channel_listen_add[1] = cm[ga_channel_listen_add[1]];

        ga_channel_listen_add[2] = cm[ga_channel_listen_add[2]];

        ga_channel_listen_add[3] = cm[ga_channel_listen_add[3]];

        ga_channel_listen_add[4] = cm[ga_channel_listen_add[4]];

        ga_channel_listen_add[5] = cm[ga_channel_listen_add[5]];

        ga_channel_listen_add[6] = cm[ga_channel_listen_add[6]];

        ga_channel_listen_add[7] = cm[ga_channel_listen_add[7]];

        ga_channel_listen_add += linesize;

    }

}
",1,1,0,1,dest,-0.6236083954572678,1,18,{'dest': 'ga_channel_listen_add'},MHM-Origin,20,0.008601697285970052
12,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();",70,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t __msa_insve_w;
    uint32_t hsub;
    __msa_insve_w = T0 | ((uint64_t) (env->y) << 32);
    hsub = T1;
    __msa_insve_w = __msa_insve_w / hsub;
    if (__msa_insve_w > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = __msa_insve_w;
	T1 = 0;
    FORCE_RET();",1,1,1,-1,x0,0.00034427642822265625,2,9,"{'x1': 'hsub', 'x0': '__msa_insve_w'}",MHM-Origin,396,0.17006272872289022
13,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
",26,"void cpu_x86_init_mmu(CPUX86State *MSR_MTRRfix4K_F0000)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(MSR_MTRRfix4K_F0000);

}
",0,0,1,1,env,0.7390343332663178,1,2,{'env': 'MSR_MTRRfix4K_F0000'},MHM-Origin,278,0.11748060385386148
14,"int qemu_cpu_self(void *env)

{

    return 1;

}
",12,"int qemu_cpu_self(void *object_property_add_child)

{

    return 1;

}
",0,0,1,1,env,0.570503730326891,1,1,{'env': 'object_property_add_child'},MHM-Origin,21,0.00847167174021403
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
",104,"static void net_vhost_link_down(VhostUserState *surface, bool HV_X64_MSR_STIMER0_CONFIG)

{

    surface->nc.HV_X64_MSR_STIMER0_CONFIG = HV_X64_MSR_STIMER0_CONFIG;



    if (surface->nc.peer) {

        surface->nc.peer->HV_X64_MSR_STIMER0_CONFIG = HV_X64_MSR_STIMER0_CONFIG;

    }



    if (surface->nc.info->link_status_changed) {

        surface->nc.info->link_status_changed(&surface->nc);

    }



    if (surface->nc.peer && surface->nc.peer->info->link_status_changed) {

        surface->nc.peer->info->link_status_changed(surface->nc.peer);

    }

}
",0,0,1,1,link_down,0.6479134261608124,2,16,"{'s': 'surface', 'link_down': 'HV_X64_MSR_STIMER0_CONFIG'}",MHM-Origin,155,0.06908604303995768
18,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",38,"START_TEST(qint_get_int_test)

{

    QInt *qemu_irq_lower;

    const int value = 123456;



    qemu_irq_lower = qint_from_int(value);

    fail_unless(qint_get_int(qemu_irq_lower) == value);



    QDECREF(qemu_irq_lower);

}
",0,0,0,-1,qi,0.0007983604446053505,1,4,{'qi': 'qemu_irq_lower'},MHM-Origin,400,0.1712908903757731
19,"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
{
    uint8_t symbols[256];
    uint8_t bits[256];
    uint16_t codes[256];
    int num_lens, num_codes, num_codes_sum, prefix;
    int i, j, count;
    prefix        = 0;
    count         = 0;
    num_codes_sum = 0;
    num_lens = get_bits(gb, 5);
    for (i = 0; i < num_lens; i++) {
        num_codes      = get_bits(gb, 9);
        num_codes_sum += num_codes;
        if (num_codes_sum > 256) {
            av_log(ctx->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.\n"", num_codes_sum);
        for (j = 0; j < num_codes; j++) {
            symbols[count] = get_bits(gb, 8);
            bits[count]    = i + 1;
            codes[count]   = prefix++;
            count++;
        if (prefix > (65535 - 256)/2) {
        prefix <<= 1;
    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);",214,"static int read_code_table(CLLCContext *av_frame_unref, GetBitContext *tcg_gen_sub_i64, VLC *nb_meta_data_maps)
{
    uint8_t symbols[256];
    uint8_t HEVClc[256];
    uint16_t codes[256];
    int num_lens, dest_byte_c, acb, IVSHMEM_MASTER;
    int bh_lock, j, count;
    IVSHMEM_MASTER        = 0;
    count         = 0;
    acb = 0;
    num_lens = get_bits(tcg_gen_sub_i64, 5);
    for (bh_lock = 0; bh_lock < num_lens; bh_lock++) {
        dest_byte_c      = get_bits(tcg_gen_sub_i64, 9);
        acb += dest_byte_c;
        if (acb > 256) {
            av_log(av_frame_unref->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.
"", acb);
        for (j = 0; j < dest_byte_c; j++) {
            symbols[count] = get_bits(tcg_gen_sub_i64, 8);
            HEVClc[count]    = bh_lock + 1;
            codes[count]   = IVSHMEM_MASTER++;
            count++;
        if (IVSHMEM_MASTER > (65535 - 256)/2) {
        IVSHMEM_MASTER <<= 1;
    return ff_init_vlc_sparse(nb_meta_data_maps, VLC_BITS, count, HEVClc, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);",1,1,1,-1,vlc,0.00011205673217773438,8,30,"{'gb': 'tcg_gen_sub_i64', 'num_codes_sum': 'acb', 'prefix': 'IVSHMEM_MASTER', 'vlc': 'nb_meta_data_maps', 'num_codes': 'dest_byte_c', 'bits': 'HEVClc', 'i': 'bh_lock', 'ctx': 'av_frame_unref'}",MHM-Origin,400,0.17370187838872272
22,"static void usbredir_bulk_packet(void *priv, uint32_t id,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,

            ep, len, id);



    aurb = async_find(dev, id);

    if (!aurb) {

        free(data);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!\n"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->data, data, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)\n"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(data);

}
",245,"static void usbredir_bulk_packet(void *ilms, uint32_t id,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = ilms;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *FW_CFG_INITRD_ADDR;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u
"", bulk_packet->status,

            ep, len, id);



    FW_CFG_INITRD_ADDR = async_find(dev, id);

    if (!FW_CFG_INITRD_ADDR) {

        free(data);

        return;

    }



    if (FW_CFG_INITRD_ADDR->bulk_packet.endpoint != bulk_packet->endpoint ||

            FW_CFG_INITRD_ADDR->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!
"");

        len = USB_RET_NAK;

    }



    if (FW_CFG_INITRD_ADDR->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, data_len);

            if (data_len <= FW_CFG_INITRD_ADDR->packet->len) {

                memcpy(FW_CFG_INITRD_ADDR->packet->data, data, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)
"", data_len,

                      FW_CFG_INITRD_ADDR->packet->len);

                len = USB_RET_STALL;

            }

        }

        FW_CFG_INITRD_ADDR->packet->len = len;

        usb_packet_complete(&dev->dev, FW_CFG_INITRD_ADDR->packet);

    }

    async_free(dev, FW_CFG_INITRD_ADDR);

    free(data);

}
",1,1,0,1,aurb,-0.12127399444580078,2,14,"{'priv': 'ilms', 'aurb': 'FW_CFG_INITRD_ADDR'}",MHM-Origin,43,0.02045520544052124
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
",167,"static int decode_plte_chunk(AVCodecContext *cbs_h265_read_sps, PNGDecContext *s,

                             uint32_t trace_megasas_dcmd_req_alloc_failed)

{

    int n, tcg_gen_ext32s_i64, r, StreamMap, vmstate_register_ram;



    if ((trace_megasas_dcmd_req_alloc_failed % 3) != 0 || trace_megasas_dcmd_req_alloc_failed > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = trace_megasas_dcmd_req_alloc_failed / 3;

    for (tcg_gen_ext32s_i64 = 0; tcg_gen_ext32s_i64 < n; tcg_gen_ext32s_i64++) {

        r = bytestream2_get_byte(&s->gb);

        StreamMap = bytestream2_get_byte(&s->gb);

        vmstate_register_ram = bytestream2_get_byte(&s->gb);

        s->palette[tcg_gen_ext32s_i64] = (0xFFU << 24) | (r << 16) | (StreamMap << 8) | vmstate_register_ram;

    }

    for (; tcg_gen_ext32s_i64 < 256; tcg_gen_ext32s_i64++)

        s->palette[tcg_gen_ext32s_i64] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
",1,1,0,1,avctx,-0.8293900862336159,5,19,"{'length': 'trace_megasas_dcmd_req_alloc_failed', 'i': 'tcg_gen_ext32s_i64', 'b': 'vmstate_register_ram', 'g': 'StreamMap', 'avctx': 'cbs_h265_read_sps'}",MHM-Origin,118,0.057313696543375654
27,"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,

                              char **serial)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;

    DriveInfo *dinfo;



    if (!conf->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(conf->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(conf->bs);

        if (*dinfo->serial) {

            *serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = virtio_blk_reset;

    s->bs = conf->bs;

    s->conf = conf;

    s->serial = *serial;

    s->rq = NULL;

    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);



    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);

    s->qdev = dev;

    register_savevm(dev, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, s);

    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);

    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);



    bdrv_iostatus_enable(s->bs);

    add_boot_device_path(conf->bootindex, dev, ""/disk@0,0"");



    return &s->vdev;

}
",322,"VirtIODevice *virtio_blk_init(DeviceState *U, BlockConf *PCI_PREF_RANGE_TYPE_64,

                              char **ABGR)

{

    VirtIOBlock *get_bits_long;

    int cylinders, QERR_INVALID_PARAMETER_VALUE, secs;

    static int dma_memory_write;

    DriveInfo *sbd;



    if (!PCI_PREF_RANGE_TYPE_64->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(PCI_PREF_RANGE_TYPE_64->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*ABGR) {

        /* try to fall back to value set with legacy -drive serial=... */

        sbd = drive_get_by_blockdev(PCI_PREF_RANGE_TYPE_64->bs);

        if (*sbd->ABGR) {

            *ABGR = strdup(sbd->ABGR);

        }

    }



    get_bits_long = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    get_bits_long->vdev.get_config = virtio_blk_update_config;

    get_bits_long->vdev.get_features = virtio_blk_get_features;

    get_bits_long->vdev.reset = virtio_blk_reset;

    get_bits_long->bs = PCI_PREF_RANGE_TYPE_64->bs;

    get_bits_long->PCI_PREF_RANGE_TYPE_64 = PCI_PREF_RANGE_TYPE_64;

    get_bits_long->ABGR = *ABGR;

    get_bits_long->rq = NULL;

    get_bits_long->sector_mask = (get_bits_long->PCI_PREF_RANGE_TYPE_64->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(get_bits_long->bs, &cylinders, &QERR_INVALID_PARAMETER_VALUE, &secs);



    get_bits_long->vq = virtio_add_queue(&get_bits_long->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, get_bits_long);

    get_bits_long->qdev = U;

    register_savevm(U, ""virtio-blk"", dma_memory_write++, 2,

                    virtio_blk_save, virtio_blk_load, get_bits_long);

    bdrv_set_dev_ops(get_bits_long->bs, &virtio_block_ops, get_bits_long);

    bdrv_set_buffer_alignment(get_bits_long->bs, PCI_PREF_RANGE_TYPE_64->logical_block_size);



    bdrv_iostatus_enable(get_bits_long->bs);

    add_boot_device_path(PCI_PREF_RANGE_TYPE_64->bootindex, U, ""/disk@0,0"");



    return &get_bits_long->vdev;

}
",0,0,1,1,heads,0.33148737251758575,7,51,"{'s': 'get_bits_long', 'dinfo': 'sbd', 'conf': 'PCI_PREF_RANGE_TYPE_64', 'virtio_blk_id': 'dma_memory_write', 'serial': 'ABGR', 'dev': 'U', 'heads': 'QERR_INVALID_PARAMETER_VALUE'}",MHM-Origin,157,0.07446149190266928
30,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",31,"static void mem_begin(MemoryListener *MSR_IA32_SYSENTER_ESP)

{

    AddressSpaceDispatch *d = container_of(MSR_IA32_SYSENTER_ESP, AddressSpaceDispatch, MSR_IA32_SYSENTER_ESP);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",0,0,1,1,listener,0.8866688311100006,1,3,{'listener': 'MSR_IA32_SYSENTER_ESP'},MHM-Origin,23,0.008711616198221842
31,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",218,"static uint32_t tight_palette_buf2rgb(int motion_y, const uint8_t *vram)

{

    uint32_t rgb = 0;



    if (motion_y == 32) {

        rgb |= ((vram[0] & ~1) | !((vram[4] >> 3) & 1)) << 24;

        rgb |= ((vram[1] & ~1) | !((vram[4] >> 2) & 1)) << 16;

        rgb |= ((vram[2] & ~1) | !((vram[4] >> 1) & 1)) <<  8;

        rgb |= ((vram[3] & ~1) | !((vram[4] >> 0) & 1)) <<  0;

    }

    if (motion_y == 16) {

        rgb |= ((vram[0] & ~1) | !((vram[2] >> 1) & 1)) << 8;

        rgb |= ((vram[1] & ~1) | !((vram[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",0,0,0,-1,bpp,-0.004218612797558308,2,16,"{'buf': 'vram', 'bpp': 'motion_y'}",MHM-Origin,395,0.17574079036712648
33,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",135,"void stream_start(const char *qemu_log, BlockDriverState *gen_movl_seg_T0,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t first_stream, BlockdevOnError nb_ostreams,

                  BlockCompletionFunc *cb, void *bdrv_refresh_filename, Error **tcg_gen_qemu_st_i64)

{

    StreamBlockJob *s;



    s = block_job_create(qemu_log, &stream_job_driver, gen_movl_seg_T0, first_stream,

                         cb, bdrv_refresh_filename, tcg_gen_qemu_st_i64);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->nb_ostreams = nb_ostreams;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(gen_movl_seg_T0, base, s, s->common.co, bdrv_refresh_filename);

    qemu_coroutine_enter(s->common.co, s);

}
",1,1,0,1,opaque,-0.13853445649147034,6,15,"{'on_error': 'nb_ostreams', 'speed': 'first_stream', 'job_id': 'qemu_log', 'bs': 'gen_movl_seg_T0', 'opaque': 'bdrv_refresh_filename', 'errp': 'tcg_gen_qemu_st_i64'}",MHM-Origin,163,0.0707014799118042
34,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    picture->extended_data = picture->data;
    return ret;
}",212,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *add_boot_device_path,
                                              int *pts,
                                              AVPacket *tap_fd_get_ifname)
{
    int ret;
    *pts = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = tap_fd_get_ifname;
    apply_param_change(avctx, tap_fd_get_ifname);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || tap_fd_get_ifname->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, add_boot_device_path, pts,
                                         tap_fd_get_ifname);
        else {
            ret = avctx->codec->decode(avctx, add_boot_device_path, pts,
                                       tap_fd_get_ifname);
            add_boot_device_path->pkt_dts             = tap_fd_get_ifname->dts;
            add_boot_device_path->sample_aspect_ratio = avctx->sample_aspect_ratio;
            add_boot_device_path->width               = avctx->width;
            add_boot_device_path->height              = avctx->height;
            add_boot_device_path->format              = avctx->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*pts)
            avctx->frame_number++;
    } else
        ret = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    add_boot_device_path->extended_data = add_boot_device_path->data;
    return ret;
}",1,1,0,1,picture,-0.19067040085792542,3,22,"{'avpkt': 'tap_fd_get_ifname', 'got_picture_ptr': 'pts', 'picture': 'add_boot_device_path'}",MHM-Origin,58,0.028227825959523518
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
",119,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *MSR_IA32_TSCDEADLINE = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(MSR_IA32_TSCDEADLINE);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected
"");

    }

    qdev_init_gpio_in(MSR_IA32_TSCDEADLINE, omap_gpio_set, 16);

    qdev_init_gpio_out(MSR_IA32_TSCDEADLINE, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
",1,1,0,1,dev,-0.31122294068336487,1,4,{'dev': 'MSR_IA32_TSCDEADLINE'},MHM-Origin,41,0.01710344950358073
36,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
",52,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *gpad_irq, I2SCodec *slave)

{

    gpad_irq->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, gpad_irq, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, gpad_irq, 1)[0];

}
",1,1,0,1,s,-0.3755955398082733,1,4,{'s': 'gpad_irq'},MHM-Origin,19,0.008419223626454671
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}
",129,"int floatx80_eq(floatx80 S_IRWXU, floatx80 planes, float_status *kvmppc_smt_threads)

{



    if (    (    ( extractFloatx80Exp( S_IRWXU ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( S_IRWXU )<<1 ) )

         || (    ( extractFloatx80Exp( planes ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( planes )<<1 ) )

       ) {

        float_raise(float_flag_invalid, kvmppc_smt_threads);

        return 0;

    }

    return

           ( S_IRWXU.low == planes.low )

        && (    ( S_IRWXU.high == planes.high )

             || (    ( S_IRWXU.low == 0 )

                  && ( (uint16_t) ( ( S_IRWXU.high | planes.high )<<1 ) == 0 ) )

           );



}
",0,0,0,-1,status,-0.0012614107690751553,3,15,"{'a': 'S_IRWXU', 'status': 'kvmppc_smt_threads', 'b': 'planes'}",MHM-Origin,387,0.1741209109624227
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
",42,"void json_lexer_init(JSONLexer *LWBRX, JSONLexerEmitter quant_idx)

{

    LWBRX->emit = quant_idx;

    LWBRX->state = IN_START;

    LWBRX->token = qstring_new();

    LWBRX->x = LWBRX->y = 0;

}
",0,0,0,-1,func,0.0027049779891967773,2,8,"{'func': 'quant_idx', 'lexer': 'LWBRX'}",MHM-Origin,400,0.16263153553009033
39,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque, int type)

{

    struct qemu_paiocb *acb;



    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!acb)

        return NULL;

    acb->aio_type = type;

    acb->aio_fildes = fd;

    acb->ev_signo = SIGUSR2;

    acb->async_context_id = get_async_context_id();



    if (qiov) {

        acb->aio_iov = qiov->iov;

        acb->aio_niov = qiov->niov;

    }

    acb->aio_nbytes = nb_sectors * 512;

    acb->aio_offset = sector_num * 512;



    acb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = acb;



    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);

    qemu_paio_submit(acb);

    return &acb->common;

}
",163,"BlockDriverAIOCB *paio_submit(BlockDriverState *tc, int tabf2,

        int64_t ff_wav_codec_get_id, QEMUIOVector *IN_START, int got_picture_ptr,

        BlockDriverCompletionFunc *cb, void *kernel_le, int BLOCK)

{

    struct qemu_paiocb *dst;



    dst = qemu_aio_get(&raw_aio_pool, tc, cb, kernel_le);

    if (!dst)

        return NULL;

    dst->aio_type = BLOCK;

    dst->aio_fildes = tabf2;

    dst->ev_signo = SIGUSR2;

    dst->async_context_id = get_async_context_id();



    if (IN_START) {

        dst->aio_iov = IN_START->iov;

        dst->aio_niov = IN_START->niov;

    }

    dst->aio_nbytes = got_picture_ptr * 512;

    dst->aio_offset = ff_wav_codec_get_id * 512;



    dst->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = dst;



    trace_paio_submit(dst, kernel_le, ff_wav_codec_get_id, got_picture_ptr, BLOCK);

    qemu_paio_submit(dst);

    return &dst->common;

}
",0,0,0,-1,sector_num,-0.00886421650648117,8,36,"{'fd': 'tabf2', 'acb': 'dst', 'sector_num': 'ff_wav_codec_get_id', 'bs': 'tc', 'opaque': 'kernel_le', 'type': 'BLOCK', 'qiov': 'IN_START', 'nb_sectors': 'got_picture_ptr'}",MHM-Origin,397,0.176161789894104
43,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *boot_devices,

                        const char *kernel_filename, const char *kernel_cmdline,

                        const char *initrd_filename, const char *cpu_model,

                        const struct hwdef *hwdef)

{

    CPUState *env;

    char *filename;

    m48t59_t *nvram;

    int ret, linux_boot;

    unsigned int i;

    ram_addr_t ram_offset, prom_offset;

    long initrd_size, kernel_size;

    PCIBus *pci_bus, *pci_bus2, *pci_bus3;

    QEMUBH *bh;

    qemu_irq *irq;

    int drive_index;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    void *fw_cfg;

    ResetData *reset_info;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    bh = qemu_bh_new(tick_irq, env);

    env->tick = ptimer_init(bh);

    ptimer_set_period(env->tick, 1ULL);



    bh = qemu_bh_new(stick_irq, env);

    env->stick = ptimer_init(bh);

    ptimer_set_period(env->stick, 1ULL);



    bh = qemu_bh_new(hstick_irq, env);

    env->hstick = ptimer_init(bh);

    ptimer_set_period(env->hstick, 1ULL);



    reset_info = qemu_mallocz(sizeof(ResetData));

    reset_info->env = env;

    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;

    qemu_register_reset(main_cpu_reset, reset_info);

    main_cpu_reset(reset_info);

    // Override warm reset address with cold start address

    env->pc = hwdef->prom_addr + 0x20ULL;

    env->npc = env->pc + 4;



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->prom_addr,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,

                       NULL, NULL, NULL);

        if (ret < 0) {

            ret = load_image_targphys(filename, hwdef->prom_addr,

                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                  TARGET_PAGE_MASK);

        }

        qemu_free(filename);

    } else {

        ret = -1;

    }

    if (ret < 0) {

        fprintf(stderr, ""qemu: could not load prom '%s'\n"",

                bios_name);

        exit(1);

    }



    kernel_size = 0;

    initrd_size = 0;

    if (linux_boot) {

        /* XXX: put correct offset */

        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,

                                    ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              KERNEL_LOAD_ADDR,

                                              ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",

                    kernel_filename);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            initrd_size = load_image_targphys(initrd_filename,

                                              INITRD_LOAD_ADDR,

                                              ram_size - INITRD_LOAD_ADDR);

            if (initrd_size < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'\n"",

                        initrd_filename);

                exit(1);

            }

        }

        if (initrd_size > 0) {

            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {

                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS

                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);

                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);

                    break;

                }

            }

        }

    }

    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,

                           &pci_bus3);

    isa_mem_base = VGA_BASE;

    pci_vga_init(pci_bus, 0, 0);



    // XXX Should be pci_bus3

    pci_ebus_init(pci_bus, -1);



    i = 0;

    if (hwdef->console_serial_base) {

        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,

                       serial_hds[i], 1);

        i++;

    }

    for(; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,

                        serial_hds[i]);

        }

    }



    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {

        if (parallel_hds[i]) {

            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,

                          parallel_hds[i]);

        }

    }



    for(i = 0; i < nb_nics; i++)

        pci_nic_init(&nd_table[i], ""ne2k_pci"", NULL);



    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);

    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus\n"");

        exit(1);

    }

    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,

                                      i % MAX_IDE_DEVS);

       if (drive_index != -1)

           hd[i] = drives_table[drive_index].bdrv;

       else

           hd[i] = NULL;

    }



    pci_cmd646_ide_init(pci_bus, hd, 1);



    /* FIXME: wire up interrupts.  */

    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);

    for(i = 0; i < MAX_FD; i++) {

        drive_index = drive_get_index(IF_FLOPPY, 0, i);

       if (drive_index != -1)

           fd[i] = drives_table[drive_index].bdrv;

       else

           fd[i] = NULL;

    }

    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);

    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);

    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, ""Sun4u"", RAM_size, boot_devices,

                           KERNEL_LOAD_ADDR, kernel_size,

                           kernel_cmdline,

                           INITRD_LOAD_ADDR, initrd_size,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);

    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",1202,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *boot_devices,

                        const char *usb_redir_bulk_packet_header, const char *kernel_cmdline,

                        const char *initrd_filename, const char *cpu_model,

                        const struct av_log2 *av_log2)

{

    CPUState *env;

    char *SPAPR_PCI_MSI_WINDOW;

    m48t59_t *nvram;

    int votes, mb;

    unsigned int i;

    ram_addr_t ram_offset, prom_offset;

    long detach, kernel_size;

    PCIBus *opts, *pci_bus2, *pci_bus3;

    QEMUBH *nb_frames_drop;

    qemu_irq *irq;

    int drive_index;

    BlockDriverState *clear[MAX_IDE_BUS * trace_megasas_dcmd_internal_submit];

    BlockDriverState *sye[MAX_FD];

    void *fw_cfg;

    ResetData *MAX_PILS;



    mb = (usb_redir_bulk_packet_header != NULL);



    /* init CPUs */

    if (!cpu_model)

        cpu_model = av_log2->default_cpu_model;



    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find Sparc CPU definition
"");

        exit(1);

    }

    nb_frames_drop = qemu_bh_new(tick_irq, env);

    env->tick = ptimer_init(nb_frames_drop);

    ptimer_set_period(env->tick, 1ULL);



    nb_frames_drop = qemu_bh_new(stick_irq, env);

    env->stick = ptimer_init(nb_frames_drop);

    ptimer_set_period(env->stick, 1ULL);



    nb_frames_drop = qemu_bh_new(hstick_irq, env);

    env->hstick = ptimer_init(nb_frames_drop);

    ptimer_set_period(env->hstick, 1ULL);



    MAX_PILS = qemu_mallocz(sizeof(ResetData));

    MAX_PILS->env = env;

    MAX_PILS->reset_addr = av_log2->prom_addr + 0x40ULL;

    qemu_register_reset(main_cpu_reset, MAX_PILS);

    main_cpu_reset(MAX_PILS);

    // Override warm reset address with cold start address

    env->pc = av_log2->prom_addr + 0x20ULL;

    env->npc = env->pc + 4;



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(av_log2->prom_addr,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    SPAPR_PCI_MSI_WINDOW = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (SPAPR_PCI_MSI_WINDOW) {

        votes = load_elf(SPAPR_PCI_MSI_WINDOW, av_log2->prom_addr - PROM_VADDR,

                       NULL, NULL, NULL);

        if (votes < 0) {

            votes = load_image_targphys(SPAPR_PCI_MSI_WINDOW, av_log2->prom_addr,

                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                  TARGET_PAGE_MASK);

        }

        qemu_free(SPAPR_PCI_MSI_WINDOW);

    } else {

        votes = -1;

    }

    if (votes < 0) {

        fprintf(stderr, ""qemu: could not load prom '%s'
"",

                bios_name);

        exit(1);

    }



    kernel_size = 0;

    detach = 0;

    if (mb) {

        /* XXX: put correct offset */

        kernel_size = load_elf(usb_redir_bulk_packet_header, 0, NULL, NULL, NULL);

        if (kernel_size < 0)

            kernel_size = load_aout(usb_redir_bulk_packet_header, KERNEL_LOAD_ADDR,

                                    ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(usb_redir_bulk_packet_header,

                                              KERNEL_LOAD_ADDR,

                                              ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'
"",

                    usb_redir_bulk_packet_header);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            detach = load_image_targphys(initrd_filename,

                                              INITRD_LOAD_ADDR,

                                              ram_size - INITRD_LOAD_ADDR);

            if (detach < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'
"",

                        initrd_filename);

                exit(1);

            }

        }

        if (detach > 0) {

            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {

                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS

                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);

                    stl_phys(KERNEL_LOAD_ADDR + i + 20, detach);

                    break;

                }

            }

        }

    }

    opts = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,

                           &pci_bus3);

    isa_mem_base = VGA_BASE;

    pci_vga_init(opts, 0, 0);



    // XXX Should be pci_bus3

    pci_ebus_init(opts, -1);



    i = 0;

    if (av_log2->console_serial_base) {

        serial_mm_init(av_log2->console_serial_base, 0, NULL, 115200,

                       serial_hds[i], 1);

        i++;

    }

    for(; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,

                        serial_hds[i]);

        }

    }



    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {

        if (parallel_hds[i]) {

            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,

                          parallel_hds[i]);

        }

    }



    for(i = 0; i < nb_nics; i++)

        pci_nic_init(&nd_table[i], ""ne2k_pci"", NULL);



    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);

    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus
"");

        exit(1);

    }

    for(i = 0; i < MAX_IDE_BUS * trace_megasas_dcmd_internal_submit; i++) {

        drive_index = drive_get_index(IF_IDE, i / trace_megasas_dcmd_internal_submit,

                                      i % trace_megasas_dcmd_internal_submit);

       if (drive_index != -1)

           clear[i] = drives_table[drive_index].bdrv;

       else

           clear[i] = NULL;

    }



    pci_cmd646_ide_init(opts, clear, 1);



    /* FIXME: wire up interrupts.  */

    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);

    for(i = 0; i < MAX_FD; i++) {

        drive_index = drive_get_index(IF_FLOPPY, 0, i);

       if (drive_index != -1)

           sye[i] = drives_table[drive_index].bdrv;

       else

           sye[i] = NULL;

    }

    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, sye);

    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);

    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, ""Sun4u"", RAM_size, boot_devices,

                           KERNEL_LOAD_ADDR, kernel_size,

                           kernel_cmdline,

                           INITRD_LOAD_ADDR, detach,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, av_log2->machine_id);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, detach);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);

    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",0,0,1,1,linux_boot,0.05280113220214844,12,70,"{'fd': 'sye', 'MAX_IDE_DEVS': 'trace_megasas_dcmd_internal_submit', 'reset_info': 'MAX_PILS', 'filename': 'SPAPR_PCI_MSI_WINDOW', 'pci_bus': 'opts', 'initrd_size': 'detach', 'ret': 'votes', 'hd': 'clear', 'bh': 'nb_frames_drop', 'hwdef': 'av_log2', 'kernel_filename': 'usb_redir_bulk_packet_header', 'linux_boot': 'mb'}",MHM-Origin,339,0.2100285569826762
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",116,"static void fpu_init (CPUMIPSState *mask1, const mips_def_t *vector_fmul_scalar)

{

    int bl0;



    for (bl0 = 0; bl0 < MIPS_FPU_MAX; bl0++)

        mask1->fpus[bl0].fcr0 = vector_fmul_scalar->CP1_fcr0;



    memcpy(&mask1->active_fpu, &mask1->fpus[0], sizeof(mask1->active_fpu));

    if (mask1->user_mode_only) {

        if (mask1->CP0_Config1 & (1 << CP0C1_FP))

            mask1->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (mask1->active_fpu.fcr0 & (1 << FCR0_F64))

            mask1->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",0,0,1,1,def,0.37095576524734497,3,17,"{'i': 'bl0', 'env': 'mask1', 'def': 'vector_fmul_scalar'}",MHM-Origin,112,0.04700395663579305
45,"static int bfi_decode_frame(AVCodecContext *avctx, void *data,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *bfi = avctx->priv_data;

    uint8_t *dst = bfi->dst;

    uint8_t *src, *dst_offset, colour1, colour2;

    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;

    uint32_t *pal;

    int i, j, height = avctx->height;



    if (bfi->frame.data[0])

        avctx->release_buffer(avctx, &bfi->frame);



    bfi->frame.reference = 1;



    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        bfi->frame.pict_type = AV_PICTURE_TYPE_I;

        bfi->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.\n"");

            return -1;

        }

        pal = (uint32_t *)bfi->frame.data[1];

        for (i = 0; i < avctx->extradata_size / 3; i++) {

            int shift = 16;

            *pal = 0;

            for (j = 0; j < 3; j++, shift -= 8)

                *pal +=

                    ((avctx->extradata[i * 3 + j] << 2) |

                    (avctx->extradata[i * 3 + j] >> 4)) << shift;

            pal++;

        }

        bfi->frame.palette_has_changed = 1;

    } else {

        bfi->frame.pict_type = AV_PICTURE_TYPE_P;

        bfi->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (dst != frame_end) {

        static const uint8_t lentab[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.\n"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (dst + (length << lentab[code]) > frame_end)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(avctx, AV_LOG_ERROR, ""Frame larger than buffer.\n"");

                return -1;

            }

            bytestream_get_buffer(&buf, dst, length);

            dst += length;

            break;



        case 1:                //Back Chain

            dst_offset = dst - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < bfi->dst)

                break;

            while (length--)

                *dst++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            dst += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *dst++ = colour1;

                *dst++ = colour2;

            }

            break;



        }

    }



    src = bfi->dst;

    dst = bfi->frame.data[0];

    while (height--) {

        memcpy(dst, src, avctx->width);

        src += avctx->width;

        dst += bfi->frame.linesize[0];

    }

    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = bfi->frame;

    return buf_size;

}
",728,"static int bfi_decode_frame(AVCodecContext *waiting_buffers_tail, void *tabf1,

                            int *data_size, AVPacket *init_output_filter)

{

    const uint8_t *cmptparm = init_output_filter->tabf1, *buf_end = init_output_filter->tabf1 + init_output_filter->size;

    int buf_size = init_output_filter->size;

    BFIContext *cache = waiting_buffers_tail->priv_data;

    uint8_t *AV_PICTURE_TYPE_B = cache->AV_PICTURE_TYPE_B;

    uint8_t *BLOCK, *next_frame_offset, ctrl, colour2;

    uint8_t *frame_end = cache->AV_PICTURE_TYPE_B + waiting_buffers_tail->width * waiting_buffers_tail->height;

    uint32_t *put_bits_count;

    int tso_enable, gen_opc_instr_start, height = waiting_buffers_tail->height;



    if (cache->frame.tabf1[0])

        waiting_buffers_tail->release_buffer(waiting_buffers_tail, &cache->frame);



    cache->frame.reference = 1;



    if (waiting_buffers_tail->get_buffer(waiting_buffers_tail, &cache->frame) < 0) {

        av_log(waiting_buffers_tail, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!waiting_buffers_tail->frame_number) {

        cache->frame.pict_type = AV_PICTURE_TYPE_I;

        cache->frame.key_frame = 1;

        /* Setting the palette */

        if (waiting_buffers_tail->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.
"");

            return -1;

        }

        put_bits_count = (uint32_t *)cache->frame.tabf1[1];

        for (tso_enable = 0; tso_enable < waiting_buffers_tail->extradata_size / 3; tso_enable++) {

            int shift = 16;

            *put_bits_count = 0;

            for (gen_opc_instr_start = 0; gen_opc_instr_start < 3; gen_opc_instr_start++, shift -= 8)

                *put_bits_count +=

                    ((waiting_buffers_tail->extradata[tso_enable * 3 + gen_opc_instr_start] << 2) |

                    (waiting_buffers_tail->extradata[tso_enable * 3 + gen_opc_instr_start] >> 4)) << shift;

            put_bits_count++;

        }

        cache->frame.palette_has_changed = 1;

    } else {

        cache->frame.pict_type = AV_PICTURE_TYPE_P;

        cache->frame.key_frame = 0;

    }



    cmptparm += 4; // Unpacked size, not required.



    while (AV_PICTURE_TYPE_B != frame_end) {

        static const uint8_t lentab[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *cmptparm++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (cmptparm >= buf_end) {

            av_log(waiting_buffers_tail, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.
"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&cmptparm);

                offset = bytestream_get_le16(&cmptparm);

            } else {

                length = bytestream_get_le16(&cmptparm);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&cmptparm);

        }



        /* Do boundary check */

        if (AV_PICTURE_TYPE_B + (length << lentab[code]) > frame_end)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - cmptparm) {

                av_log(waiting_buffers_tail, AV_LOG_ERROR, ""Frame larger than buffer.
"");

                return -1;

            }

            bytestream_get_buffer(&cmptparm, AV_PICTURE_TYPE_B, length);

            AV_PICTURE_TYPE_B += length;

            break;



        case 1:                //Back Chain

            next_frame_offset = AV_PICTURE_TYPE_B - offset;

            length *= 4;        //Convert dwords to bytes.

            if (next_frame_offset < cache->AV_PICTURE_TYPE_B)

                break;

            while (length--)

                *AV_PICTURE_TYPE_B++ = *next_frame_offset++;

            break;



        case 2:                //Skip Chain

            AV_PICTURE_TYPE_B += length;

            break;



        case 3:                //Fill Chain

            ctrl = bytestream_get_byte(&cmptparm);

            colour2 = bytestream_get_byte(&cmptparm);

            while (length--) {

                *AV_PICTURE_TYPE_B++ = ctrl;

                *AV_PICTURE_TYPE_B++ = colour2;

            }

            break;



        }

    }



    BLOCK = cache->AV_PICTURE_TYPE_B;

    AV_PICTURE_TYPE_B = cache->frame.tabf1[0];

    while (height--) {

        memcpy(AV_PICTURE_TYPE_B, BLOCK, waiting_buffers_tail->width);

        BLOCK += waiting_buffers_tail->width;

        AV_PICTURE_TYPE_B += cache->frame.linesize[0];

    }

    *data_size = sizeof(AVFrame);

    *(AVFrame *)tabf1 = cache->frame;

    return buf_size;

}
",1,1,1,-1,src,-0.019229769706726074,12,106,"{'pal': 'put_bits_count', 'avctx': 'waiting_buffers_tail', 'colour1': 'ctrl', 'j': 'gen_opc_instr_start', 'i': 'tso_enable', 'bfi': 'cache', 'dst': 'AV_PICTURE_TYPE_B', 'avpkt': 'init_output_filter', 'buf': 'cmptparm', 'data': 'tabf1', 'src': 'BLOCK', 'dst_offset': 'next_frame_offset'}",MHM-Origin,394,0.20231002569198608
46,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !bus->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",563,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *cpu_npc = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""cpu_npc"");

    if (path != NULL) {

        cpu_npc = qbus_find(path);

        if (!cpu_npc) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(cpu_npc), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(cpu_npc)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        cpu_npc = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!cpu_npc) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && cpu_npc && !cpu_npc->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, cpu_npc->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (cpu_npc) {

        qdev_set_parent_bus(dev, cpu_npc);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",1,1,0,1,bus,-0.038409143686294556,1,13,{'bus': 'cpu_npc'},MHM-Origin,21,0.01026853322982788
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
",24,"void thread_pool_submit(ThreadPoolFunc *SIGP_STAT_INVALID_PARAMETER, void *psize)

{

    thread_pool_submit_aio(SIGP_STAT_INVALID_PARAMETER, psize, NULL, NULL);

}
",0,0,1,1,func,0.877723278477788,2,4,"{'func': 'SIGP_STAT_INVALID_PARAMETER', 'arg': 'psize'}",MHM-Origin,255,0.10796051025390625
49,"int cpu_exec(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    cc->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        cc = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(cc == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, cpu);

        }

    }



    cc->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",232,"int cpu_exec(CPUState *cpu)

{

    CPUClass *ERR = CPU_GET_CLASS(cpu);

    int cbs_h265_read_pps;

    SyncClocks out_samples;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    ERR->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&out_samples, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        ERR = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(ERR == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &cbs_h265_read_pps)) {

        TranslationBlock *float64_is_infinity = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &float64_is_infinity)) {

            TranslationBlock *tb = tb_find(cpu, float64_is_infinity, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &float64_is_infinity, &tb_exit, &out_samples);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&out_samples, cpu);

        }

    }



    ERR->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return cbs_h265_read_pps;

}
",1,1,0,1,ret,-0.21849653124809265,4,16,"{'last_tb': 'float64_is_infinity', 'cc': 'ERR', 'ret': 'cbs_h265_read_pps', 'sc': 'out_samples'}",MHM-Origin,221,0.09920201301574708
50,"static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)

{

    int i;

    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&dest->scsw, &src->scsw);



    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {

        dest->esw[i] = cpu_to_be32(src->esw[i]);

    }

    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {

        dest->ecw[i] = cpu_to_be32(src->ecw[i]);

    }

    /* extended measurements enabled? */

    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||

        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {

            dest->emw[i] = cpu_to_be32(src->emw[i]);

        }

    }

}
",245,"static void copy_irb_to_guest(IRB *ff_vorbis_vwin, const IRB *PCI_BRIDGE_CTL_DISCARD, PMCW *srs)

{

    int print_error;

    uint16_t stctl = PCI_BRIDGE_CTL_DISCARD->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = PCI_BRIDGE_CTL_DISCARD->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&ff_vorbis_vwin->scsw, &PCI_BRIDGE_CTL_DISCARD->scsw);



    for (print_error = 0; print_error < ARRAY_SIZE(ff_vorbis_vwin->esw); print_error++) {

        ff_vorbis_vwin->esw[print_error] = cpu_to_be32(PCI_BRIDGE_CTL_DISCARD->esw[print_error]);

    }

    for (print_error = 0; print_error < ARRAY_SIZE(ff_vorbis_vwin->ecw); print_error++) {

        ff_vorbis_vwin->ecw[print_error] = cpu_to_be32(PCI_BRIDGE_CTL_DISCARD->ecw[print_error]);

    }

    /* extended measurements enabled? */

    if ((PCI_BRIDGE_CTL_DISCARD->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(srs->flags & PMCW_FLAGS_MASK_TF) ||

        !(srs->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (print_error = 0; print_error < ARRAY_SIZE(ff_vorbis_vwin->emw); print_error++) {

            ff_vorbis_vwin->emw[print_error] = cpu_to_be32(PCI_BRIDGE_CTL_DISCARD->emw[print_error]);

        }

    }

}
",0,0,0,-1,dest,0.1986198127269745,4,35,"{'src': 'PCI_BRIDGE_CTL_DISCARD', 'dest': 'ff_vorbis_vwin', 'pmcw': 'srs', 'i': 'print_error'}",MHM-Origin,393,0.17446986039479573
51,"static int process_input_packet(InputStream *ist, const AVPacket *pkt)

{

    int i;

    int got_output;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &got_output);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (pkt) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",600,"static int process_input_packet(InputStream *ist, const AVPacket *pkt)

{

    int i;

    int DEFAULT_NETWORK_DOWN_SCRIPT;

    AVPacket scsi_command_complete;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&scsi_command_complete);

        scsi_command_complete.data = NULL;

        scsi_command_complete.size = 0;

        goto handle_eof;

    } else {

        scsi_command_complete = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (scsi_command_complete.size > 0 || (!pkt && DEFAULT_NETWORK_DOWN_SCRIPT))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (scsi_command_complete.size && scsi_command_complete.size != pkt->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d
"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &scsi_command_complete, &DEFAULT_NETWORK_DOWN_SCRIPT);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &scsi_command_complete, &DEFAULT_NETWORK_DOWN_SCRIPT);

            if (scsi_command_complete.duration)

                ist->next_dts += av_rescale_q(scsi_command_complete.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &scsi_command_complete, &DEFAULT_NETWORK_DOWN_SCRIPT);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (pkt) {

            scsi_command_complete.data += ret;

            scsi_command_complete.size -= ret;

        }

        if (!DEFAULT_NETWORK_DOWN_SCRIPT) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",0,0,1,1,got_output,0.26566430926322937,2,21,"{'avpkt': 'scsi_command_complete', 'got_output': 'DEFAULT_NETWORK_DOWN_SCRIPT'}",MHM-Origin,59,0.027530614535013834
54,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *pkt_data,

                                           size_t pkt_len)

{

    struct virtio_net_hdr *vhdr;

    bool isip4, isip6, istcp, isudp;

    uint8_t *data;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vhdr);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, vhdr->csum_start, vhdr->csum_offset);

        return;

    }



    data = (uint8_t *)pkt_data + vhdr->csum_start;

    len = pkt_len - vhdr->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));



    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",206,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *ff_thread_decode_frame,

                                           const void *PCI_IO_BASE,

                                           size_t gen_helper_raise_exception)

{

    struct virtio_net_hdr *get_bits;

    bool PCI_BRIDGE_CTL_SEC_DISCARD, CC_OP_MULW, count, mask15g;

    uint8_t *data;

    int sid;



    if (!vmxnet_rx_pkt_has_virt_hdr(ff_thread_decode_frame)) {

        return;

    }



    get_bits = vmxnet_rx_pkt_get_vhdr(ff_thread_decode_frame);

    if (!VMXNET_FLAG_IS_SET(get_bits->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(ff_thread_decode_frame, &PCI_BRIDGE_CTL_SEC_DISCARD, &CC_OP_MULW, &mask15g, &count);

    if (!(PCI_BRIDGE_CTL_SEC_DISCARD || CC_OP_MULW) || !(count || mask15g)) {

        return;

    }



    vmxnet3_dump_virt_hdr(get_bits);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (gen_helper_raise_exception < (get_bits->csum_start + get_bits->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  sid, get_bits->csum_start, get_bits->csum_offset);

        return;

    }



    data = (uint8_t *)PCI_IO_BASE + get_bits->csum_start;

    sid = gen_helper_raise_exception - get_bits->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(data + get_bits->csum_offset, net_raw_checksum(data, sid));



    get_bits->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    get_bits->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",1,1,1,-1,pkt_data,0.015163660049438477,9,38,"{'pkt_len': 'gen_helper_raise_exception', 'len': 'sid', 'isip4': 'PCI_BRIDGE_CTL_SEC_DISCARD', 'isudp': 'mask15g', 'vhdr': 'get_bits', 'istcp': 'count', 'pkt': 'ff_thread_decode_frame', 'isip6': 'CC_OP_MULW', 'pkt_data': 'PCI_IO_BASE'}",MHM-Origin,399,0.17034878333409628
56,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *div_blocks,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int s;



        bd[0].block_length = div_blocks[b];

        bd[1].block_length = div_blocks[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!\n"");



            for (s = 0; s < div_blocks[b]; s++)

                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];

        } else if (bd[1].js_blocks) {

            for (s = 0; s < div_blocks[b]; s++)

                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];

        }



        offset  += div_blocks[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",721,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *bdrv_file_open,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int s;



        bd[0].block_length = bdrv_file_open[b];

        bd[1].block_length = bdrv_file_open[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, bdrv_file_open, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, bdrv_file_open, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!
"");



            for (s = 0; s < bdrv_file_open[b]; s++)

                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];

        } else if (bd[1].js_blocks) {

            for (s = 0; s < bdrv_file_open[b]; s++)

                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];

        }



        offset  += bdrv_file_open[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",1,1,0,1,div_blocks,-0.7141480594873428,1,8,{'div_blocks': 'bdrv_file_open'},MHM-Origin,23,0.011596580346425375
58,"static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)

{

    int compno;

    int x, y;

    int *image_line;

    int frame_index;

    const int numcomps  = image->numcomps;

    uint16_t *frame_ptr = (uint16_t *)frame->data[0];



    for (compno = 0; compno < numcomps; ++compno) {

        if (image->comps[compno].w > frame->linesize[0] / numcomps) {

            av_log(avctx, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image\n"");

            return 0;

        }

    }



    for (compno = 0; compno < numcomps; ++compno) {

        for (y = 0; y < avctx->height; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            frame_index = y * (frame->linesize[0] / 2) + compno;

            for (x = 0; x < avctx->width; ++x) {

                image_line[x] = frame_ptr[frame_index] >> 4;

                frame_index += numcomps;

            }

            for (; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - 1];

            }

        }

        for (; y < image->comps[compno].h; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            for (x = 0; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - image->comps[compno].w];

            }

        }

    }



    return 1;

}
",328,"static int libopenjpeg_copy_packed12(AVCodecContext *stripsizesoff, const AVFrame *bdrv_get_flags, opj_image_t *top)

{

    int compno;

    int x, y;

    int *image_line;

    int MirrorBlockJob;

    const int numcomps  = top->numcomps;

    uint16_t *frame_ptr = (uint16_t *)bdrv_get_flags->data[0];



    for (compno = 0; compno < numcomps; ++compno) {

        if (top->comps[compno].w > bdrv_get_flags->linesize[0] / numcomps) {

            av_log(stripsizesoff, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image
"");

            return 0;

        }

    }



    for (compno = 0; compno < numcomps; ++compno) {

        for (y = 0; y < stripsizesoff->height; ++y) {

            image_line = top->comps[compno].data + y * top->comps[compno].w;

            MirrorBlockJob = y * (bdrv_get_flags->linesize[0] / 2) + compno;

            for (x = 0; x < stripsizesoff->width; ++x) {

                image_line[x] = frame_ptr[MirrorBlockJob] >> 4;

                MirrorBlockJob += numcomps;

            }

            for (; x < top->comps[compno].w; ++x) {

                image_line[x] = image_line[x - 1];

            }

        }

        for (; y < top->comps[compno].h; ++y) {

            image_line = top->comps[compno].data + y * top->comps[compno].w;

            for (x = 0; x < top->comps[compno].w; ++x) {

                image_line[x] = image_line[x - top->comps[compno].w];

            }

        }

    }



    return 1;

}
",1,1,0,1,frame,-0.43843957781791687,4,24,"{'avctx': 'stripsizesoff', 'frame_index': 'MirrorBlockJob', 'image': 'top', 'frame': 'bdrv_get_flags'}",MHM-Origin,82,0.03658336798350016
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
",95,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long bdrv_set_dev_ops, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<bdrv_set_dev_ops; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
",1,1,0,1,num_pixels,-0.9687769133597612,1,2,{'num_pixels': 'bdrv_set_dev_ops'},MHM-Origin,24,0.008984096844991048
62,"static inline void codeblock(DiracContext *s, SubBand *b,

                             GetBitContext *gb, DiracArith *c,

                             int left, int right, int top, int bottom,

                             int blockcnt_one, int is_arith)

{

    int x, y, zero_block;

    int qoffset, qfactor;

    IDWTELEM *buf;



    /* check for any coded coefficients in this codeblock */

    if (!blockcnt_one) {

        if (is_arith)

            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);

        else

            zero_block = get_bits1(gb);



        if (zero_block)

            return;

    }



    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {

        if (is_arith)

            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);

        else

            b->quant += dirac_get_se_golomb(gb);

    }



    b->quant = FFMIN(b->quant, MAX_QUANT);



    qfactor = qscale_tab[b->quant];

    /* TODO: context pointer? */

    if (!s->num_refs)

        qoffset = qoffset_intra_tab[b->quant];

    else

        qoffset = qoffset_inter_tab[b->quant];



    buf = b->ibuf + top * b->stride;

    for (y = top; y < bottom; y++) {

        for (x = left; x < right; x++) {

            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */

            if (is_arith)

                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);

            else

                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);

        }

        buf += b->stride;

    }

}
",269,"static inline void codeblock(DiracContext *s, SubBand *b,

                             GetBitContext *gb, DiracArith *c,

                             int left, int right, int top, int bottom,

                             int blockcnt_one, int R_CS)

{

    int x, y, zero_block;

    int NUM_SHORT_DISTANCES, NET_TX_PKT_L2HDR_FRAG;

    IDWTELEM *vmsd;



    /* check for any coded coefficients in this codeblock */

    if (!blockcnt_one) {

        if (R_CS)

            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);

        else

            zero_block = get_bits1(gb);



        if (zero_block)

            return;

    }



    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {

        if (R_CS)

            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);

        else

            b->quant += dirac_get_se_golomb(gb);

    }



    b->quant = FFMIN(b->quant, MAX_QUANT);



    NET_TX_PKT_L2HDR_FRAG = qscale_tab[b->quant];

    /* TODO: context pointer? */

    if (!s->num_refs)

        NUM_SHORT_DISTANCES = qoffset_intra_tab[b->quant];

    else

        NUM_SHORT_DISTANCES = qoffset_inter_tab[b->quant];



    vmsd = b->ibuf + top * b->stride;

    for (y = top; y < bottom; y++) {

        for (x = left; x < right; x++) {

            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */

            if (R_CS)

                coeff_unpack_arith(c, NET_TX_PKT_L2HDR_FRAG, NUM_SHORT_DISTANCES, b, vmsd+x, x, y);

            else

                vmsd[x] = coeff_unpack_golomb(gb, NET_TX_PKT_L2HDR_FRAG, NUM_SHORT_DISTANCES);

        }

        vmsd += b->stride;

    }

}
",0,0,1,1,qfactor,0.20013868808746338,4,18,"{'is_arith': 'R_CS', 'qoffset': 'NUM_SHORT_DISTANCES', 'buf': 'vmsd', 'qfactor': 'NET_TX_PKT_L2HDR_FRAG'}",MHM-Origin,80,0.03662174940109253
64,"void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            ret = ~ret;

    }

    T0 = ret;

}
",96,"void do_POWER_maskg (void)

{

    uint32_t SCSI_DMA_BUF_SIZE;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        SCSI_DMA_BUF_SIZE = -1;

    } else {

        SCSI_DMA_BUF_SIZE = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            SCSI_DMA_BUF_SIZE = ~SCSI_DMA_BUF_SIZE;

    }

    T0 = SCSI_DMA_BUF_SIZE;

}
",1,1,1,-1,ret,-0.00025004148483276367,1,6,{'ret': 'SCSI_DMA_BUF_SIZE'},MHM-Origin,396,0.168247918287913
65,"static void qed_aio_read_data(void *opaque, int ret,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, acb, ret, offset, len);



    if (ret < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (ret == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (ret != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, ret);

}
",209,"static void qed_aio_read_data(void *opaque, int ret,

                              uint64_t gen_lea_v_seg, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *tcg_gen_extu_tl_i64 = acb->common.tcg_gen_extu_tl_i64;



    /* Adjust offset into cluster */

    gen_lea_v_seg += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, acb, ret, gen_lea_v_seg, len);



    if (ret < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (ret == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (ret != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(tcg_gen_extu_tl_i64->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(tcg_gen_extu_tl_i64->file, gen_lea_v_seg / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, ret);

}
",1,1,0,1,bs,-0.2281901240348816,2,8,"{'offset': 'gen_lea_v_seg', 'bs': 'tcg_gen_extu_tl_i64'}",MHM-Origin,43,0.018927220503489176
66,"int qcow2_update_header(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    QCowHeader *header;

    char *buf;

    size_t buflen = s->cluster_size;

    int ret;

    uint64_t total_size;

    uint32_t refcount_table_clusters;

    size_t header_length;

    Qcow2UnknownHeaderExtension *uext;



    buf = qemu_blockalign(bs, buflen);



    /* Header structure */

    header = (QCowHeader*) buf;



    if (buflen < sizeof(*header)) {

        ret = -ENOSPC;

        goto fail;

    }



    header_length = sizeof(*header) + s->unknown_header_fields_size;

    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;

    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);



    *header = (QCowHeader) {

        /* Version 2 fields */

        .magic                  = cpu_to_be32(QCOW_MAGIC),

        .version                = cpu_to_be32(s->qcow_version),

        .backing_file_offset    = 0,

        .backing_file_size      = 0,

        .cluster_bits           = cpu_to_be32(s->cluster_bits),

        .size                   = cpu_to_be64(total_size),

        .crypt_method           = cpu_to_be32(s->crypt_method_header),

        .l1_size                = cpu_to_be32(s->l1_size),

        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),

        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),

        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),

        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),

        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),



        /* Version 3 fields */

        .incompatible_features  = cpu_to_be64(s->incompatible_features),

        .compatible_features    = cpu_to_be64(s->compatible_features),

        .autoclear_features     = cpu_to_be64(s->autoclear_features),

        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),

        .header_length          = cpu_to_be32(header_length),

    };



    /* For older versions, write a shorter header */

    switch (s->qcow_version) {

    case 2:

        ret = offsetof(QCowHeader, incompatible_features);

        break;

    case 3:

        ret = sizeof(*header);

        break;

    default:

        return -EINVAL;

    }



    buf += ret;

    buflen -= ret;

    memset(buf, 0, buflen);



    /* Preserve any unknown field in the header */

    if (s->unknown_header_fields_size) {

        if (buflen < s->unknown_header_fields_size) {

            ret = -ENOSPC;

            goto fail;

        }



        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);

        buf += s->unknown_header_fields_size;

        buflen -= s->unknown_header_fields_size;

    }



    /* Backing file format header extension */

    if (*bs->backing_format) {

        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,

                             bs->backing_format, strlen(bs->backing_format),

                             buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* Feature table */

    Qcow2Feature features[] = {

        /* no feature defined yet */

    };



    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,

                         features, sizeof(features), buflen);

    if (ret < 0) {

        goto fail;

    }

    buf += ret;

    buflen -= ret;



    /* Keep unknown header extensions */

    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {

        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* End of header extensions */

    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);

    if (ret < 0) {

        goto fail;

    }



    buf += ret;

    buflen -= ret;



    /* Backing file name */

    if (*bs->backing_file) {

        size_t backing_file_len = strlen(bs->backing_file);



        if (buflen < backing_file_len) {

            ret = -ENOSPC;

            goto fail;

        }



        strncpy(buf, bs->backing_file, buflen);



        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));

        header->backing_file_size   = cpu_to_be32(backing_file_len);

    }



    /* Write the new header */

    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);

    if (ret < 0) {

        goto fail;

    }



    ret = 0;

fail:

    qemu_vfree(header);

    return ret;

}
",696,"int qcow2_update_header(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    QCowHeader *header;

    char *buf;

    size_t buflen = s->cluster_size;

    int ret;

    uint64_t total_size;

    uint32_t refcount_table_clusters;

    size_t buf_size2;

    Qcow2UnknownHeaderExtension *uext;



    buf = qemu_blockalign(bs, buflen);



    /* Header structure */

    header = (QCowHeader*) buf;



    if (buflen < sizeof(*header)) {

        ret = -ENOSPC;

        goto fail;

    }



    buf_size2 = sizeof(*header) + s->unknown_header_fields_size;

    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;

    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);



    *header = (QCowHeader) {

        /* Version 2 fields */

        .magic                  = cpu_to_be32(QCOW_MAGIC),

        .version                = cpu_to_be32(s->qcow_version),

        .backing_file_offset    = 0,

        .backing_file_size      = 0,

        .cluster_bits           = cpu_to_be32(s->cluster_bits),

        .size                   = cpu_to_be64(total_size),

        .crypt_method           = cpu_to_be32(s->crypt_method_header),

        .l1_size                = cpu_to_be32(s->l1_size),

        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),

        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),

        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),

        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),

        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),



        /* Version 3 fields */

        .incompatible_features  = cpu_to_be64(s->incompatible_features),

        .compatible_features    = cpu_to_be64(s->compatible_features),

        .autoclear_features     = cpu_to_be64(s->autoclear_features),

        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),

        .buf_size2          = cpu_to_be32(buf_size2),

    };



    /* For older versions, write a shorter header */

    switch (s->qcow_version) {

    case 2:

        ret = offsetof(QCowHeader, incompatible_features);

        break;

    case 3:

        ret = sizeof(*header);

        break;

    default:

        return -EINVAL;

    }



    buf += ret;

    buflen -= ret;

    memset(buf, 0, buflen);



    /* Preserve any unknown field in the header */

    if (s->unknown_header_fields_size) {

        if (buflen < s->unknown_header_fields_size) {

            ret = -ENOSPC;

            goto fail;

        }



        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);

        buf += s->unknown_header_fields_size;

        buflen -= s->unknown_header_fields_size;

    }



    /* Backing file format header extension */

    if (*bs->backing_format) {

        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,

                             bs->backing_format, strlen(bs->backing_format),

                             buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* Feature table */

    Qcow2Feature features[] = {

        /* no feature defined yet */

    };



    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,

                         features, sizeof(features), buflen);

    if (ret < 0) {

        goto fail;

    }

    buf += ret;

    buflen -= ret;



    /* Keep unknown header extensions */

    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {

        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* End of header extensions */

    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);

    if (ret < 0) {

        goto fail;

    }



    buf += ret;

    buflen -= ret;



    /* Backing file name */

    if (*bs->backing_file) {

        size_t backing_file_len = strlen(bs->backing_file);



        if (buflen < backing_file_len) {

            ret = -ENOSPC;

            goto fail;

        }



        strncpy(buf, bs->backing_file, buflen);



        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));

        header->backing_file_size   = cpu_to_be32(backing_file_len);

    }



    /* Write the new header */

    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);

    if (ret < 0) {

        goto fail;

    }



    ret = 0;

fail:

    qemu_vfree(header);

    return ret;

}
",1,1,0,1,header_length,-0.01750051975250244,1,4,{'header_length': 'buf_size2'},MHM-Origin,21,0.010105582078297932
69,"static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)

{

    MLPHeaderInfo mh;

    int substr, ret;



    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)

        return ret;



    if (mh.group1_bits == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown bits per sample\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group2_bits > mh.group1_bits) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel group 2 cannot have more bits per sample than group 1.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel groups with differing sample rates are not currently supported.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group1_samplerate == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown sampling rate\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group1_samplerate > MAX_SAMPLERATE) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Sampling rate %d is greater than the supported maximum (%d).\n"",

               mh.group1_samplerate, MAX_SAMPLERATE);

        return AVERROR_INVALIDDATA;


    if (mh.access_unit_size > MAX_BLOCKSIZE) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Block size %d is greater than the supported maximum (%d).\n"",

               mh.access_unit_size, MAX_BLOCKSIZE);

        return AVERROR_INVALIDDATA;


    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Block size pow2 %d is greater than the supported maximum (%d).\n"",

               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);

        return AVERROR_INVALIDDATA;




    if (mh.num_substreams == 0)

        return AVERROR_INVALIDDATA;

    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {

        av_log(m->avctx, AV_LOG_ERROR, ""MLP only supports up to 2 substreams.\n"");

        return AVERROR_INVALIDDATA;


    if (mh.num_substreams > MAX_SUBSTREAMS) {


                              ""%d substreams (more than the ""

                              ""maximum supported by the decoder)"",

                              mh.num_substreams);





    m->access_unit_size      = mh.access_unit_size;

    m->access_unit_size_pow2 = mh.access_unit_size_pow2;



    m->num_substreams        = mh.num_substreams;

    m->max_decoded_substream = m->num_substreams - 1;



    m->avctx->sample_rate    = mh.group1_samplerate;

    m->avctx->frame_size     = mh.access_unit_size;



    m->avctx->bits_per_raw_sample = mh.group1_bits;

    if (mh.group1_bits > 16)

        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;

    else

        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    m->params_valid = 1;

    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)

        m->substream[substr].restart_seen = 0;



    /* Set the layout for each substream. When there's more than one, the first

     * substream is Stereo. Subsequent substreams' layouts are indicated in the

     * major sync. */

    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {







        if ((substr = (mh.num_substreams > 1)))

            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        m->substream[substr].ch_layout = mh.channel_layout_mlp;

    } else {







        if ((substr = (mh.num_substreams > 1)))

            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        if (mh.num_substreams > 2)

            if (mh.channel_layout_thd_stream2)

                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;

            else

                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;

        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;



        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {

            av_log(m->avctx, AV_LOG_DEBUG, ""Mono stream with 2 substreams, ignoring 2nd\n"");

            m->max_decoded_substream = 0;

            if (m->avctx->channels==2)

                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;





    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;



    return 0;
",644,"static int read_major_sync(MLPDecodeContext *bnd, GetBitContext *start_sqs)

{

    MLPHeaderInfo defined;

    int reason, RV34_MB_B_FORWARD;



    if ((RV34_MB_B_FORWARD = ff_mlp_read_major_sync(bnd->avctx, &defined, start_sqs)) != 0)

        return RV34_MB_B_FORWARD;



    if (defined.group1_bits == 0) {

        av_log(bnd->avctx, AV_LOG_ERROR, ""invalid/unknown bits per sample
"");

        return AVERROR_INVALIDDATA;


    if (defined.group2_bits > defined.group1_bits) {

        av_log(bnd->avctx, AV_LOG_ERROR,

               ""Channel group 2 cannot have more bits per sample than group 1.
"");

        return AVERROR_INVALIDDATA;




    if (defined.group2_samplerate && defined.group2_samplerate != defined.group1_samplerate) {

        av_log(bnd->avctx, AV_LOG_ERROR,

               ""Channel groups with differing sample rates are not currently supported.
"");

        return AVERROR_INVALIDDATA;




    if (defined.group1_samplerate == 0) {

        av_log(bnd->avctx, AV_LOG_ERROR, ""invalid/unknown sampling rate
"");

        return AVERROR_INVALIDDATA;


    if (defined.group1_samplerate > MAX_SAMPLERATE) {

        av_log(bnd->avctx, AV_LOG_ERROR,

               ""Sampling rate %d is greater than the supported maximum (%d).
"",

               defined.group1_samplerate, MAX_SAMPLERATE);

        return AVERROR_INVALIDDATA;


    if (defined.access_unit_size > MAX_BLOCKSIZE) {

        av_log(bnd->avctx, AV_LOG_ERROR,

               ""Block size %d is greater than the supported maximum (%d).
"",

               defined.access_unit_size, MAX_BLOCKSIZE);

        return AVERROR_INVALIDDATA;


    if (defined.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {

        av_log(bnd->avctx, AV_LOG_ERROR,

               ""Block size pow2 %d is greater than the supported maximum (%d).
"",

               defined.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);

        return AVERROR_INVALIDDATA;




    if (defined.num_substreams == 0)

        return AVERROR_INVALIDDATA;

    if (bnd->avctx->codec_id == AV_CODEC_ID_MLP && defined.num_substreams > 2) {

        av_log(bnd->avctx, AV_LOG_ERROR, ""MLP only supports up to 2 substreams.
"");

        return AVERROR_INVALIDDATA;


    if (defined.num_substreams > MAX_SUBSTREAMS) {


                              ""%d substreams (more than the ""

                              ""maximum supported by the decoder)"",

                              defined.num_substreams);





    bnd->access_unit_size      = defined.access_unit_size;

    bnd->access_unit_size_pow2 = defined.access_unit_size_pow2;



    bnd->num_substreams        = defined.num_substreams;

    bnd->max_decoded_substream = bnd->num_substreams - 1;



    bnd->avctx->sample_rate    = defined.group1_samplerate;

    bnd->avctx->frame_size     = defined.access_unit_size;



    bnd->avctx->bits_per_raw_sample = defined.group1_bits;

    if (defined.group1_bits > 16)

        bnd->avctx->sample_fmt = AV_SAMPLE_FMT_S32;

    else

        bnd->avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    bnd->params_valid = 1;

    for (reason = 0; reason < MAX_SUBSTREAMS; reason++)

        bnd->substream[reason].restart_seen = 0;



    /* Set the layout for each substream. When there's more than one, the first

     * substream is Stereo. Subsequent substreams' layouts are indicated in the

     * major sync. */

    if (bnd->avctx->codec_id == AV_CODEC_ID_MLP) {







        if ((reason = (defined.num_substreams > 1)))

            bnd->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        bnd->substream[reason].ch_layout = defined.channel_layout_mlp;

    } else {







        if ((reason = (defined.num_substreams > 1)))

            bnd->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        if (defined.num_substreams > 2)

            if (defined.channel_layout_thd_stream2)

                bnd->substream[2].ch_layout = defined.channel_layout_thd_stream2;

            else

                bnd->substream[2].ch_layout = defined.channel_layout_thd_stream1;

        bnd->substream[reason].ch_layout = defined.channel_layout_thd_stream1;



        if (bnd->avctx->channels<=2 && bnd->substream[reason].ch_layout == AV_CH_LAYOUT_MONO && bnd->max_decoded_substream == 1) {

            av_log(bnd->avctx, AV_LOG_DEBUG, ""Mono stream with 2 substreams, ignoring 2nd
"");

            bnd->max_decoded_substream = 0;

            if (bnd->avctx->channels==2)

                bnd->avctx->channel_layout = AV_CH_LAYOUT_STEREO;





    bnd->needs_reordering = defined.channel_arrangement >= 18 && defined.channel_arrangement <= 20;



    return 0;
",1,1,1,-1,m,2.288818359375e-05,5,89,"{'ret': 'RV34_MB_B_FORWARD', 'gb': 'start_sqs', 'm': 'bnd', 'substr': 'reason', 'mh': 'defined'}",MHM-Origin,389,0.20778807799021404
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",129,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *cluster_sector_num = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!cluster_sector_num->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, cluster_sector_num->framerate.den, cluster_sector_num->framerate.num);



    /* simulate tty display speed */

    cluster_sector_num->chars_per_frame = FFMAX(av_q2d(st->time_base) * cluster_sector_num->chars_per_frame, 1);



    return st;

}
",1,1,0,1,bin,-0.2683533728122711,1,6,{'bin': 'cluster_sector_num'},MHM-Origin,21,0.008887652556101482
72,"static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_state;



    if (prev_state != state) {

        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);

        prev_state = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

            guest_y += y;

            dx = x;

            dy = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);

    }

    qemu_input_event_sync();

}
",202,"static void sdl_send_mouse_event(int MSR_MTRRfix4K_C8000, int dy, int arg6, int y, int state)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t HEVC_NAL_TRAIL_R;



    if (HEVC_NAL_TRAIL_R != state) {

        qemu_input_update_buttons(dcl->con, bmap, HEVC_NAL_TRAIL_R, state);

        HEVC_NAL_TRAIL_R = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, arg6,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            arg6 -= guest_x;

            y -= guest_y;

            guest_x += arg6;

            guest_y += y;

            MSR_MTRRfix4K_C8000 = arg6;

            dy = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, MSR_MTRRfix4K_C8000);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);

    }

    qemu_input_event_sync();

}
",0,0,1,1,dx,0.676531694829464,3,12,"{'prev_state': 'HEVC_NAL_TRAIL_R', 'x': 'arg6', 'dx': 'MSR_MTRRfix4K_C8000'}",MHM-Origin,63,0.028052234649658205
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
",95,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int fd_in_tag, sb;

    fd_in_tag = ((int64_t)*phigh < 0);

    if (fd_in_tag)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (fd_in_tag ^ sb)

        *plow = - *plow;

    if (fd_in_tag)

        *phigh = - *phigh;

}
",1,1,0,1,sa,-0.5431197285652161,1,5,{'sa': 'fd_in_tag'},MHM-Origin,23,0.008683764934539795
77,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->bl.request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {

            bs->bl.max_pdiscard =

                iscsilun->bl.max_unmap * iscsilun->block_size;

        }

        bs->bl.pdiscard_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pdiscard_alignment = iscsilun->block_size;

    }



    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {

        bs->bl.max_pwrite_zeroes =

            iscsilun->bl.max_ws_len * iscsilun->block_size;

    }

    if (iscsilun->lbp.lbpws) {

        bs->bl.pwrite_zeroes_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;

    }

    if (iscsilun->bl.opt_xfer_len &&

        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {

        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *

                                        iscsilun->block_size);

    }

}
",274,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **matrix_coeff_index_now)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->bl.request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {

            bs->bl.max_pdiscard =

                iscsilun->bl.max_unmap * iscsilun->block_size;

        }

        bs->bl.pdiscard_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pdiscard_alignment = iscsilun->block_size;

    }



    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {

        bs->bl.max_pwrite_zeroes =

            iscsilun->bl.max_ws_len * iscsilun->block_size;

    }

    if (iscsilun->lbp.lbpws) {

        bs->bl.pwrite_zeroes_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;

    }

    if (iscsilun->bl.opt_xfer_len &&

        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {

        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *

                                        iscsilun->block_size);

    }

}
",1,1,0,1,errp,-0.2939773350954056,1,1,{'errp': 'matrix_coeff_index_now'},MHM-Origin,22,0.009140988190968832
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",70,"static void tap_receive(void *opaque, const uint8_t *RV34_MB_B_FORWARD, size_t qemu_rdma_poll)

{

    TAPState *s = opaque;

    int slave_index;

    for(;;) {

        slave_index = write(s->fd, RV34_MB_B_FORWARD, qemu_rdma_poll);

        if (slave_index < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",0,0,1,1,size,0.8736434988677502,3,7,"{'size': 'qemu_rdma_poll', 'buf': 'RV34_MB_B_FORWARD', 'ret': 'slave_index'}",MHM-Origin,161,0.07065990368525187
79,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
",94,"static void scsi_disk_realize(SCSIDevice *vrc, Error **bdrv_aio_readv)

{

    DriveInfo *timer_del;

    Error *MAX_NEG_CROP = NULL;



    if (!vrc->conf.bs) {

        scsi_realize(vrc, &MAX_NEG_CROP);

        assert(MAX_NEG_CROP);

        error_propagate(bdrv_aio_readv, MAX_NEG_CROP);

        return;

    }



    timer_del = drive_get_by_blockdev(vrc->conf.bs);

    if (timer_del->media_cd) {

        scsi_cd_realize(vrc, bdrv_aio_readv);

    } else {

        scsi_hd_realize(vrc, bdrv_aio_readv);

    }

}
",0,0,1,1,local_err,0.7535575777292252,4,17,"{'errp': 'bdrv_aio_readv', 'dinfo': 'timer_del', 'dev': 'vrc', 'local_err': 'MAX_NEG_CROP'}",MHM-Origin,332,0.14625288645426432
80,"static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *inode;

    unsigned int datalen;



    dprintf(""sn_info: name %s id_str %s s: name %s vm_state_size %"" PRId64 "" ""

            ""is_snapshot %d\n"", sn_info->name, sn_info->id_str,

            s->name, sn_info->vm_state_size, s->is_snapshot);



    if (s->is_snapshot) {

        error_report(""You can't create a snapshot of a snapshot VDI, ""

                     ""%s (%"" PRIu32 "")."", s->name, s->inode.vdi_id);



        return -EINVAL;

    }



    dprintf(""%s %s\n"", sn_info->name, sn_info->id_str);



    s->inode.vm_state_size = sn_info->vm_state_size;

    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));

    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);



    /* refresh inode. */

    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        ret = fd;

        goto cleanup;

    }



    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    if (ret < 0) {

        error_report(""failed to write snapshot's inode."");

        goto cleanup;

    }



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,

                       s->addr, s->port);

    if (ret < 0) {

        error_report(""failed to create inode for snapshot. %s"",

                     strerror(errno));

        goto cleanup;

    }



    inode = (SheepdogInode *)g_malloc(datalen);



    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),

                      s->inode.nr_copies, datalen, 0, s->cache_enabled);



    if (ret < 0) {

        error_report(""failed to read new inode info. %s"", strerror(errno));

        goto cleanup;

    }



    memcpy(&s->inode, inode, datalen);

    dprintf(""s->inode: name %s snap_id %x oid %x\n"",

            s->inode.name, s->inode.snap_id, s->inode.vdi_id);



cleanup:

    closesocket(fd);

    return ret;

}
",435,"static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *inode;

    unsigned int gen_helper_fucom_ST0_FT0;



    dprintf(""sn_info: name %s id_str %s s: name %s vm_state_size %"" PRId64 "" ""

            ""is_snapshot %d
"", sn_info->name, sn_info->id_str,

            s->name, sn_info->vm_state_size, s->is_snapshot);



    if (s->is_snapshot) {

        error_report(""You can't create a snapshot of a snapshot VDI, ""

                     ""%s (%"" PRIu32 "")."", s->name, s->inode.vdi_id);



        return -EINVAL;

    }



    dprintf(""%s %s
"", sn_info->name, sn_info->id_str);



    s->inode.vm_state_size = sn_info->vm_state_size;

    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));

    /* we don't need to update entire object */

    gen_helper_fucom_ST0_FT0 = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);



    /* refresh inode. */

    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        ret = fd;

        goto cleanup;

    }



    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, gen_helper_fucom_ST0_FT0, 0, false, s->cache_enabled);

    if (ret < 0) {

        error_report(""failed to write snapshot's inode."");

        goto cleanup;

    }



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,

                       s->addr, s->port);

    if (ret < 0) {

        error_report(""failed to create inode for snapshot. %s"",

                     strerror(errno));

        goto cleanup;

    }



    inode = (SheepdogInode *)g_malloc(gen_helper_fucom_ST0_FT0);



    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),

                      s->inode.nr_copies, gen_helper_fucom_ST0_FT0, 0, s->cache_enabled);



    if (ret < 0) {

        error_report(""failed to read new inode info. %s"", strerror(errno));

        goto cleanup;

    }



    memcpy(&s->inode, inode, gen_helper_fucom_ST0_FT0);

    dprintf(""s->inode: name %s snap_id %x oid %x
"",

            s->inode.name, s->inode.snap_id, s->inode.vdi_id);



cleanup:

    closesocket(fd);

    return ret;

}
",0,0,1,1,datalen,0.1664452850818634,1,6,{'datalen': 'gen_helper_fucom_ST0_FT0'},MHM-Origin,21,0.010675342877705891
81,"static int vnc_display_listen(VncDisplay *vd,

                              SocketAddress **saddr,

                              size_t nsaddr,

                              SocketAddress **wsaddr,

                              size_t nwsaddr,

                              Error **errp)

{

    size_t i;



    for (i = 0; i < nsaddr; i++) {

        if (vnc_display_listen_addr(vd, saddr[i],

                                    ""vnc-listen"",

                                    &vd->lsock,

                                    &vd->lsock_tag,

                                    &vd->nlsock,

                                    errp) < 0) {

            return -1;

        }

    }

    for (i = 0; i < nwsaddr; i++) {

        if (vnc_display_listen_addr(vd, wsaddr[i],

                                    ""vnc-ws-listen"",

                                    &vd->lwebsock,

                                    &vd->lwebsock_tag,

                                    &vd->nlwebsock,

                                    errp) < 0) {

            return -1;

        }

    }



    return 0;

}
",147,"static int vnc_display_listen(VncDisplay *vd,

                              SocketAddress **MSR_IA32_TSC,

                              size_t QEMU_FILE_TYPE_BIOS,

                              SocketAddress **iTask,

                              size_t num_lens,

                              Error **tcg_gen_concat_tl_i64)

{

    size_t rice_count_exact;



    for (rice_count_exact = 0; rice_count_exact < QEMU_FILE_TYPE_BIOS; rice_count_exact++) {

        if (vnc_display_listen_addr(vd, MSR_IA32_TSC[rice_count_exact],

                                    ""vnc-listen"",

                                    &vd->lsock,

                                    &vd->lsock_tag,

                                    &vd->nlsock,

                                    tcg_gen_concat_tl_i64) < 0) {

            return -1;

        }

    }

    for (rice_count_exact = 0; rice_count_exact < num_lens; rice_count_exact++) {

        if (vnc_display_listen_addr(vd, iTask[rice_count_exact],

                                    ""vnc-ws-listen"",

                                    &vd->lwebsock,

                                    &vd->lwebsock_tag,

                                    &vd->nlwebsock,

                                    tcg_gen_concat_tl_i64) < 0) {

            return -1;

        }

    }



    return 0;

}
",0,0,1,1,wsaddr,0.3250561058521271,6,20,"{'i': 'rice_count_exact', 'wsaddr': 'iTask', 'errp': 'tcg_gen_concat_tl_i64', 'nwsaddr': 'num_lens', 'saddr': 'MSR_IA32_TSC', 'nsaddr': 'QEMU_FILE_TYPE_BIOS'}",MHM-Origin,322,0.14358771244684856
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
",94,"static char *enumerate_cpus(unsigned long *tcg_gen_movi_tl, int ALAC_EXTRADATA_SIZE)

{

    int bits_per_sample;

    bool first = true;

    GString *bdrv_truncate = g_string_new(NULL);



    for (bits_per_sample = find_first_bit(tcg_gen_movi_tl, ALAC_EXTRADATA_SIZE);

        bits_per_sample < ALAC_EXTRADATA_SIZE;

        bits_per_sample = find_next_bit(tcg_gen_movi_tl, ALAC_EXTRADATA_SIZE, bits_per_sample + 1)) {

        g_string_append_printf(bdrv_truncate, ""%s%d"", first ? """" : "" "", bits_per_sample);

        first = false;

    }

    return g_string_free(bdrv_truncate, FALSE);

}
",0,0,0,-1,cpus,-0.0011456580832600594,4,16,"{'cpus': 'tcg_gen_movi_tl', 'max_cpus': 'ALAC_EXTRADATA_SIZE', 's': 'bdrv_truncate', 'cpu': 'bits_per_sample'}",MHM-Origin,403,0.17654636303583782
85,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,

                              target_ulong opcode, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);

    VIOsPAPR_RTCE *rtce;



    if (!dev) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);

#endif



    if (ioba >= dev->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    rtce->tce = tce;



    return H_SUCCESS;

}
",169,"static target_ulong h_put_tce(CPUPPCState *CodedBitstreamUnit, sPAPREnvironment *spapr,

                              target_ulong opcode, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);

    VIOsPAPR_RTCE *rtce;



    if (!dev) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist
"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""
"", dev->qdev.id, ioba, tce);

#endif



    if (ioba >= dev->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""
"", ioba);

        return H_PARAMETER;

    }



    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    rtce->tce = tce;



    return H_SUCCESS;

}
",1,1,0,1,env,-0.5032780766487122,1,1,{'env': 'CodedBitstreamUnit'},MHM-Origin,23,0.008964149157206218
88,"Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",80,"Object *object_resolve_path_component(Object *has_vhostfd, const gchar *part)

{

    ObjectProperty *prop = object_property_find(has_vhostfd, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",1,1,0,1,parent,-0.4331359267234802,1,2,{'parent': 'has_vhostfd'},MHM-Origin,22,0.008355979124704998
90,"void cpu_tick_set_count(CPUTimer *timer, uint64_t count)

{

    uint64_t real_count = count & ~timer->disabled_mask;

    uint64_t disabled_bit = count & timer->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, timer->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p\n"",

                  timer->name, real_count,

                  timer->disabled?""disabled"":""enabled"", timer);



    timer->disabled = disabled_bit ? 1 : 0;

    timer->clock_offset = vm_clock_offset;

}
",91,"void cpu_tick_set_count(CPUTimer *timer, uint64_t EXCP0D_GPF)

{

    uint64_t real_count = EXCP0D_GPF & ~timer->disabled_mask;

    uint64_t disabled_bit = EXCP0D_GPF & timer->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, timer->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p
"",

                  timer->name, real_count,

                  timer->disabled?""disabled"":""enabled"", timer);



    timer->disabled = disabled_bit ? 1 : 0;

    timer->clock_offset = vm_clock_offset;

}
",1,1,0,1,count,-0.48608455061912537,1,3,{'count': 'EXCP0D_GPF'},MHM-Origin,23,0.008413636684417724
91,"void commit_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, BlockDriverState *top, int64_t speed,

                  BlockdevOnError on_error, const char *backing_file_str,

                  const char *filter_node_name, Error **errp)

{

    CommitBlockJob *s;

    BlockReopenQueue *reopen_queue = NULL;

    int orig_overlay_flags;

    int orig_base_flags;

    BlockDriverState *iter;

    BlockDriverState *overlay_bs;

    BlockDriverState *commit_top_bs = NULL;

    Error *local_err = NULL;

    int ret;



    assert(top != bs);

    if (top == base) {

        error_setg(errp, ""Invalid files for merge: top and base are the same"");

        return;




    overlay_bs = bdrv_find_overlay(bs, top);



    if (overlay_bs == NULL) {

        error_setg(errp, ""Could not find overlay image for %s:"", top->filename);

        return;




    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,

                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);

    if (!s) {

        return;




    orig_base_flags    = bdrv_get_flags(base);

    orig_overlay_flags = bdrv_get_flags(overlay_bs);



    /* convert base & overlay_bs to r/w, if necessary */

    if (!(orig_base_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,

                                         orig_base_flags | BDRV_O_RDWR);


    if (!(orig_overlay_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,

                                         orig_overlay_flags | BDRV_O_RDWR);


    if (reopen_queue) {

        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);

        if (local_err != NULL) {

            error_propagate(errp, local_err);

            goto fail;





    /* Insert commit_top block node above top, so we can block consistent read

     * on the backing chain below it */

    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,

                                         errp);

    if (commit_top_bs == NULL) {

        goto fail;





    commit_top_bs->total_sectors = top->total_sectors;

    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));



    bdrv_set_backing_hd(commit_top_bs, top, &local_err);

    if (local_err) {

        bdrv_unref(commit_top_bs);

        commit_top_bs = NULL;

        error_propagate(errp, local_err);

        goto fail;


    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);

    if (local_err) {

        bdrv_unref(commit_top_bs);

        commit_top_bs = NULL;

        error_propagate(errp, local_err);

        goto fail;




    s->commit_top_bs = commit_top_bs;

    bdrv_unref(commit_top_bs);



    /* Block all nodes between top and base, because they will

     * disappear from the chain after this operation. */

    assert(bdrv_chain_contains(top, base));

    for (iter = top; iter != base; iter = backing_bs(iter)) {

        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves

         * at s->base (if writes are blocked for a node, they are also blocked

         * for its backing file). The other options would be a second filter

         * driver above s->base. */

        ret = block_job_add_bdrv(&s->common, ""intermediate node"", iter, 0,

                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,

                                 errp);

        if (ret < 0) {

            goto fail;





    ret = block_job_add_bdrv(&s->common, ""base"", base, 0, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    /* overlay_bs must be blocked because it needs to be modified to

     * update the backing image string. */

    ret = block_job_add_bdrv(&s->common, ""overlay of top"", overlay_bs,

                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    s->base = blk_new(BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_WRITE

                      | BLK_PERM_RESIZE,

                      BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_GRAPH_MOD

                      | BLK_PERM_WRITE_UNCHANGED);

    ret = blk_insert_bs(s->base, base, errp);

    if (ret < 0) {

        goto fail;




    /* Required permissions are already taken with block_job_add_bdrv() */

    s->top = blk_new(0, BLK_PERM_ALL);

    ret = blk_insert_bs(s->top, top, errp);

    if (ret < 0) {

        goto fail;




    s->active = bs;



    s->base_flags          = orig_base_flags;

    s->orig_overlay_flags  = orig_overlay_flags;



    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;



    trace_commit_start(bs, base, top, s);

    block_job_start(&s->common);

    return;



fail:

    if (s->base) {

        blk_unref(s->base);


    if (s->top) {

        blk_unref(s->top);


    if (commit_top_bs) {

        bdrv_set_backing_hd(overlay_bs, top, &error_abort);


    block_job_early_fail(&s->common);
",700,"void commit_start(const char *lms_prevvalues, BlockDriverState *emulated_edge_mc,

                  BlockDriverState *preload, BlockDriverState *ROUND_UP, int64_t colour1,

                  BlockdevOnError hash, const char *val_type,

                  const char *AV_OPT_FLAG_ENCODING_PARAM, Error **nb)

{

    CommitBlockJob *s;

    BlockReopenQueue *reopen_queue = NULL;

    int OPC_SUB_CP2;

    int orig_base_flags;

    BlockDriverState *dev;

    BlockDriverState *fw_cfg;

    BlockDriverState *commit_top_bs = NULL;

    Error *send_packets = NULL;

    int ret;



    assert(ROUND_UP != emulated_edge_mc);

    if (ROUND_UP == preload) {

        error_setg(nb, ""Invalid files for merge: top and base are the same"");

        return;




    fw_cfg = bdrv_find_overlay(emulated_edge_mc, ROUND_UP);



    if (fw_cfg == NULL) {

        error_setg(nb, ""Could not find overlay image for %s:"", ROUND_UP->filename);

        return;




    s = block_job_create(lms_prevvalues, &commit_job_driver, emulated_edge_mc, 0, BLK_PERM_ALL,

                         colour1, BLOCK_JOB_DEFAULT, NULL, NULL, nb);

    if (!s) {

        return;




    orig_base_flags    = bdrv_get_flags(preload);

    OPC_SUB_CP2 = bdrv_get_flags(fw_cfg);



    /* convert base & overlay_bs to r/w, if necessary */

    if (!(orig_base_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, preload, NULL,

                                         orig_base_flags | BDRV_O_RDWR);


    if (!(OPC_SUB_CP2 & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, fw_cfg, NULL,

                                         OPC_SUB_CP2 | BDRV_O_RDWR);


    if (reopen_queue) {

        bdrv_reopen_multiple(bdrv_get_aio_context(emulated_edge_mc), reopen_queue, &send_packets);

        if (send_packets != NULL) {

            error_propagate(nb, send_packets);

            goto fail;





    /* Insert commit_top block node above top, so we can block consistent read

     * on the backing chain below it */

    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, AV_OPT_FLAG_ENCODING_PARAM, 0,

                                         nb);

    if (commit_top_bs == NULL) {

        goto fail;





    commit_top_bs->total_sectors = ROUND_UP->total_sectors;

    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(ROUND_UP));



    bdrv_set_backing_hd(commit_top_bs, ROUND_UP, &send_packets);

    if (send_packets) {

        bdrv_unref(commit_top_bs);

        commit_top_bs = NULL;

        error_propagate(nb, send_packets);

        goto fail;


    bdrv_set_backing_hd(fw_cfg, commit_top_bs, &send_packets);

    if (send_packets) {

        bdrv_unref(commit_top_bs);

        commit_top_bs = NULL;

        error_propagate(nb, send_packets);

        goto fail;




    s->commit_top_bs = commit_top_bs;

    bdrv_unref(commit_top_bs);



    /* Block all nodes between top and base, because they will

     * disappear from the chain after this operation. */

    assert(bdrv_chain_contains(ROUND_UP, preload));

    for (dev = ROUND_UP; dev != preload; dev = backing_bs(dev)) {

        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves

         * at s->base (if writes are blocked for a node, they are also blocked

         * for its backing file). The other options would be a second filter

         * driver above s->base. */

        ret = block_job_add_bdrv(&s->common, ""intermediate node"", dev, 0,

                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,

                                 nb);

        if (ret < 0) {

            goto fail;





    ret = block_job_add_bdrv(&s->common, ""preload"", preload, 0, BLK_PERM_ALL, nb);

    if (ret < 0) {

        goto fail;




    /* overlay_bs must be blocked because it needs to be modified to

     * update the backing image string. */

    ret = block_job_add_bdrv(&s->common, ""overlay of top"", fw_cfg,

                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, nb);

    if (ret < 0) {

        goto fail;




    s->preload = blk_new(BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_WRITE

                      | BLK_PERM_RESIZE,

                      BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_GRAPH_MOD

                      | BLK_PERM_WRITE_UNCHANGED);

    ret = blk_insert_bs(s->preload, preload, nb);

    if (ret < 0) {

        goto fail;




    /* Required permissions are already taken with block_job_add_bdrv() */

    s->ROUND_UP = blk_new(0, BLK_PERM_ALL);

    ret = blk_insert_bs(s->ROUND_UP, ROUND_UP, nb);

    if (ret < 0) {

        goto fail;




    s->active = emulated_edge_mc;



    s->base_flags          = orig_base_flags;

    s->OPC_SUB_CP2  = OPC_SUB_CP2;



    s->val_type = g_strdup(val_type);



    s->hash = hash;



    trace_commit_start(emulated_edge_mc, preload, ROUND_UP, s);

    block_job_start(&s->common);

    return;



fail:

    if (s->preload) {

        blk_unref(s->preload);


    if (s->ROUND_UP) {

        blk_unref(s->ROUND_UP);


    if (commit_top_bs) {

        bdrv_set_backing_hd(fw_cfg, ROUND_UP, &error_abort);


    block_job_early_fail(&s->common);
",1,1,1,-1,orig_overlay_flags,-0.00011998414993286133,13,96,"{'speed': 'colour1', 'top': 'ROUND_UP', 'base': 'preload', 'on_error': 'hash', 'errp': 'nb', 'filter_node_name': 'AV_OPT_FLAG_ENCODING_PARAM', 'bs': 'emulated_edge_mc', 'job_id': 'lms_prevvalues', 'iter': 'dev', 'local_err': 'send_packets', 'overlay_bs': 'fw_cfg', 'backing_file_str': 'val_type', 'orig_overlay_flags': 'OPC_SUB_CP2'}",MHM-Origin,390,0.21443026065826415
92,"int bdrv_is_removable(BlockDriverState *bs)

{

    return bs->removable;

}
",14,"int bdrv_is_removable(BlockDriverState *cc)

{

    return cc->removable;

}
",0,0,0,-1,bs,0.001196457538753748,1,2,{'bs': 'cc'},MHM-Origin,388,0.16320821046829223
97,"static void handle_satn(ESPState *s)

{

    uint8_t buf[32];

    int len;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn;

        return;

    }

    len = get_cmd(s, buf);

    if (len)

        do_cmd(s, buf);

}
",60,"static void handle_satn(ESPState *RV34_MB_P_8x8)

{

    uint8_t buf[32];

    int len;



    if (RV34_MB_P_8x8->dma && !RV34_MB_P_8x8->dma_enabled) {

        RV34_MB_P_8x8->dma_cb = handle_satn;

        return;

    }

    len = get_cmd(RV34_MB_P_8x8, buf);

    if (len)

        do_cmd(RV34_MB_P_8x8, buf);

}
",1,1,0,1,s,-0.7392797395586967,1,6,{'s': 'RV34_MB_P_8x8'},MHM-Origin,66,0.02408175468444824
99,"int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,

                   const char *version, const char *serial, const char *model,

                   uint64_t wwn,

                   uint32_t cylinders, uint32_t heads, uint32_t secs,

                   int chs_trans)

{

    uint64_t nb_sectors;



    s->blk = blk;

    s->drive_kind = kind;



    blk_get_geometry(blk, &nb_sectors);

    s->cylinders = cylinders;

    s->heads = heads;

    s->sectors = secs;

    s->chs_trans = chs_trans;

    s->nb_sectors = nb_sectors;

    s->wwn = wwn;

    /* The SMART values should be preserved across power cycles

       but they aren't.  */

    s->smart_enabled = 1;

    s->smart_autosave = 1;

    s->smart_errors = 0;

    s->smart_selftest_count = 0;

    if (kind == IDE_CD) {

        blk_set_dev_ops(blk, &ide_cd_block_ops, s);

        blk_set_guest_block_size(blk, 2048);

    } else {

        if (!blk_is_inserted(s->blk)) {

            error_report(""Device needs media, but drive is empty"");

            return -1;

        }

        if (blk_is_read_only(blk)) {

            error_report(""Can't use a read-only drive"");

            return -1;

        }

        blk_set_dev_ops(blk, &ide_hd_block_ops, s);

    }

    if (serial) {

        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);

    } else {

        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),

                 ""QM%05d"", s->drive_serial);

    }

    if (model) {

        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);

    } else {

        switch (kind) {

        case IDE_CD:

            strcpy(s->drive_model_str, ""QEMU DVD-ROM"");

            break;

        case IDE_CFATA:

            strcpy(s->drive_model_str, ""QEMU MICRODRIVE"");

            break;

        default:

            strcpy(s->drive_model_str, ""QEMU HARDDISK"");

            break;

        }

    }



    if (version) {

        pstrcpy(s->version, sizeof(s->version), version);

    } else {

        pstrcpy(s->version, sizeof(s->version), qemu_get_version());

    }



    ide_reset(s);

    blk_iostatus_enable(blk);

    return 0;

}
",389,"int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,

                   const char *version, const char *serial, const char *SPAPR_PCI_MSI_WINDOW,

                   uint64_t wwn,

                   uint32_t cylinders, uint32_t QmpOutputVisitor, uint32_t secs,

                   int start_bit)

{

    uint64_t nb_sectors;



    s->blk = blk;

    s->drive_kind = kind;



    blk_get_geometry(blk, &nb_sectors);

    s->cylinders = cylinders;

    s->QmpOutputVisitor = QmpOutputVisitor;

    s->sectors = secs;

    s->start_bit = start_bit;

    s->nb_sectors = nb_sectors;

    s->wwn = wwn;

    /* The SMART values should be preserved across power cycles

       but they aren't.  */

    s->smart_enabled = 1;

    s->smart_autosave = 1;

    s->smart_errors = 0;

    s->smart_selftest_count = 0;

    if (kind == IDE_CD) {

        blk_set_dev_ops(blk, &ide_cd_block_ops, s);

        blk_set_guest_block_size(blk, 2048);

    } else {

        if (!blk_is_inserted(s->blk)) {

            error_report(""Device needs media, but drive is empty"");

            return -1;

        }

        if (blk_is_read_only(blk)) {

            error_report(""Can't use a read-only drive"");

            return -1;

        }

        blk_set_dev_ops(blk, &ide_hd_block_ops, s);

    }

    if (serial) {

        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);

    } else {

        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),

                 ""QM%05d"", s->drive_serial);

    }

    if (SPAPR_PCI_MSI_WINDOW) {

        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), SPAPR_PCI_MSI_WINDOW);

    } else {

        switch (kind) {

        case IDE_CD:

            strcpy(s->drive_model_str, ""QEMU DVD-ROM"");

            break;

        case IDE_CFATA:

            strcpy(s->drive_model_str, ""QEMU MICRODRIVE"");

            break;

        default:

            strcpy(s->drive_model_str, ""QEMU HARDDISK"");

            break;

        }

    }



    if (version) {

        pstrcpy(s->version, sizeof(s->version), version);

    } else {

        pstrcpy(s->version, sizeof(s->version), qemu_get_version());

    }



    ide_reset(s);

    blk_iostatus_enable(blk);

    return 0;

}
",0,0,1,1,model,0.2054847776889801,3,9,"{'chs_trans': 'start_bit', 'heads': 'QmpOutputVisitor', 'model': 'SPAPR_PCI_MSI_WINDOW'}",MHM-Origin,62,0.02608973185221354
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",51,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t H264SliceContext, uint64_t chroma_intra_matrix)

{

    struct vhost_iotlb_msg imsg;



    imsg.H264SliceContext = H264SliceContext;

    imsg.size = chroma_intra_matrix;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",1,1,0,1,iova,-0.6184284687042236,2,5,"{'len': 'chroma_intra_matrix', 'iova': 'H264SliceContext'}",MHM-Origin,41,0.015677809715270996
101,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)

{

    uint32_t val;

    val = gic_dist_readb(opaque, offset);

    val |= gic_dist_readb(opaque, offset + 1) << 8;

    return val;

}
",41,"static uint32_t gic_dist_readw(void *current_migration, target_phys_addr_t CMDLINE_ADDR)

{

    uint32_t MAX_PARALLEL_PORTS;

    MAX_PARALLEL_PORTS = gic_dist_readb(current_migration, CMDLINE_ADDR);

    MAX_PARALLEL_PORTS |= gic_dist_readb(current_migration, CMDLINE_ADDR + 1) << 8;

    return MAX_PARALLEL_PORTS;

}
",0,0,1,1,offset,0.460237767547369,3,10,"{'opaque': 'current_migration', 'val': 'MAX_PARALLEL_PORTS', 'offset': 'CMDLINE_ADDR'}",MHM-Origin,163,0.0674638032913208
102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
",88,"static void test_qemu_strtoull_overflow(void)

{

    const char *qtest_memread = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *resid = &f;

    uint64_t res = 999;

    int qcr;



    qcr = qemu_strtoull(qtest_memread, &resid, 0, &res);



    g_assert_cmpint(qcr, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(resid == qtest_memread + strlen(qtest_memread));

}
",0,0,1,1,str,0.6205740086734295,3,10,"{'str': 'qtest_memread', 'err': 'qcr', 'endptr': 'resid'}",MHM-Origin,375,0.16514317989349364
103,"PXA2xxState *pxa255_init(unsigned int sdram_size)

{

    PXA2xxState *s;

    int iomemtype, i;

    DriveInfo *dinfo;



    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));



    s->env = cpu_init(""pxa255"");

    if (!s->env) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }

    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];



    /* SDRAM & Internal Memory Storage */

    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,

                    qemu_ram_alloc(NULL, ""pxa255.sdram"",

                                   sdram_size) | IO_MEM_RAM);

    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,

                    qemu_ram_alloc(NULL, ""pxa255.internal"",

                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);



    s->pic = pxa2xx_pic_init(0x40d00000, s->env);



    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);



    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);



    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);



    dinfo = drive_get(IF_SD, 0, 0);

    if (!dinfo) {

        fprintf(stderr, ""qemu: missing SecureDigital device\n"");

        exit(1);

    }

    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,

                              s->pic[PXA2XX_PIC_MMC], s->dma);



    for (i = 0; pxa255_serial[i].io_base; i ++)

        if (serial_hds[i]) {

#ifdef TARGET_WORDS_BIGENDIAN

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           s->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 1);

#else

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           s->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 0);

#endif

        } else {

            break;

        }

    if (serial_hds[i])

        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],

                        s->dma, serial_hds[i]);



    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);



    s->cm_base = 0x41300000;

    s->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */

    s->clkcfg = 0x00000009;		/* Turbo mode active */

    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,

                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_cm"", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);



    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);



    s->mm_base = 0x48000000;

    s->mm_regs[MDMRS >> 2] = 0x00020002;

    s->mm_regs[MDREFR >> 2] = 0x03ca4000;

    s->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */

    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,

                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_mm"", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);



    s->pm_base = 0x40f00000;

    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,

                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);

    register_savevm(NULL, ""pxa2xx_pm"", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);



    for (i = 0; pxa255_ssp[i].io_base; i ++);

    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);

    for (i = 0; pxa255_ssp[i].io_base; i ++) {

        DeviceState *dev;

        dev = sysbus_create_simple(""pxa2xx-ssp"", pxa255_ssp[i].io_base,

                                   s->pic[pxa255_ssp[i].irqn]);

        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, ""ssi"");

    }



    if (usb_enabled) {

        sysbus_create_simple(""sysbus-ohci"", 0x4c000000,

                             s->pic[PXA2XX_PIC_USBH1]);

    }



    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);

    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);



    s->rtc_base = 0x40900000;

    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,

                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);

    pxa2xx_rtc_init(s);

    register_savevm(NULL, ""pxa2xx_rtc"", 0, 0, pxa2xx_rtc_save,

                    pxa2xx_rtc_load, s);



    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);

    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);



    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);



    /* GPIO1 resets the processor */

    /* The handler can be overridden by board-specific code */

    qdev_connect_gpio_out(s->gpio, 1, s->reset);

    return s;

}
",897,"PXA2xxState *pxa255_init(unsigned int b8_stride)

{

    PXA2xxState *s;

    int iomemtype, i;

    DriveInfo *dinfo;



    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));



    s->env = cpu_init(""pxa255"");

    if (!s->env) {

        fprintf(stderr, ""Unable to find CPU definition
"");

        exit(1);

    }

    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];



    /* SDRAM & Internal Memory Storage */

    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, b8_stride,

                    qemu_ram_alloc(NULL, ""pxa255.sdram"",

                                   b8_stride) | IO_MEM_RAM);

    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,

                    qemu_ram_alloc(NULL, ""pxa255.internal"",

                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);



    s->pic = pxa2xx_pic_init(0x40d00000, s->env);



    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);



    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);



    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);



    dinfo = drive_get(IF_SD, 0, 0);

    if (!dinfo) {

        fprintf(stderr, ""qemu: missing SecureDigital device
"");

        exit(1);

    }

    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,

                              s->pic[PXA2XX_PIC_MMC], s->dma);



    for (i = 0; pxa255_serial[i].io_base; i ++)

        if (serial_hds[i]) {

#ifdef TARGET_WORDS_BIGENDIAN

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           s->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 1);

#else

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           s->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 0);

#endif

        } else {

            break;

        }

    if (serial_hds[i])

        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],

                        s->dma, serial_hds[i]);



    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);



    s->cm_base = 0x41300000;

    s->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */

    s->clkcfg = 0x00000009;		/* Turbo mode active */

    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,

                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_cm"", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);



    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);



    s->mm_base = 0x48000000;

    s->mm_regs[MDMRS >> 2] = 0x00020002;

    s->mm_regs[MDREFR >> 2] = 0x03ca4000;

    s->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */

    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,

                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_mm"", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);



    s->pm_base = 0x40f00000;

    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,

                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);

    register_savevm(NULL, ""pxa2xx_pm"", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);



    for (i = 0; pxa255_ssp[i].io_base; i ++);

    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);

    for (i = 0; pxa255_ssp[i].io_base; i ++) {

        DeviceState *dev;

        dev = sysbus_create_simple(""pxa2xx-ssp"", pxa255_ssp[i].io_base,

                                   s->pic[pxa255_ssp[i].irqn]);

        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, ""ssi"");

    }



    if (usb_enabled) {

        sysbus_create_simple(""sysbus-ohci"", 0x4c000000,

                             s->pic[PXA2XX_PIC_USBH1]);

    }



    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);

    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);



    s->rtc_base = 0x40900000;

    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,

                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);

    pxa2xx_rtc_init(s);

    register_savevm(NULL, ""pxa2xx_rtc"", 0, 0, pxa2xx_rtc_save,

                    pxa2xx_rtc_load, s);



    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);

    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);



    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);



    /* GPIO1 resets the processor */

    /* The handler can be overridden by board-specific code */

    qdev_connect_gpio_out(s->gpio, 1, s->reset);

    return s;

}
",0,0,1,1,sdram_size,0.03357666730880737,1,3,{'sdram_size': 'b8_stride'},MHM-Origin,22,0.011186079184214274
104,"int usb_device_delete_addr(int busnr, int addr)

{

    USBBus *bus;

    USBPort *port;

    USBDevice *dev;



    bus = usb_bus_find(busnr);

    if (!bus)

        return -1;



    TAILQ_FOREACH(port, &bus->used, next) {

        if (port->dev->addr == addr)

            break;

    }

    if (!port)

        return -1;



    dev = port->dev;

    TAILQ_REMOVE(&bus->used, port, next);

    bus->nused--;



    usb_attach(port, NULL);

    dev->info->handle_destroy(dev);



    TAILQ_INSERT_TAIL(&bus->free, port, next);

    bus->nfree++;

    return 0;

}
",131,"int usb_device_delete_addr(int qemu_log_mask, int HEVCContext)

{

    USBBus *bus;

    USBPort *cpu_exec_enter;

    USBDevice *delay_samples;



    bus = usb_bus_find(qemu_log_mask);

    if (!bus)

        return -1;



    TAILQ_FOREACH(cpu_exec_enter, &bus->used, next) {

        if (cpu_exec_enter->delay_samples->HEVCContext == HEVCContext)

            break;

    }

    if (!cpu_exec_enter)

        return -1;



    delay_samples = cpu_exec_enter->delay_samples;

    TAILQ_REMOVE(&bus->used, cpu_exec_enter, next);

    bus->RTCState--;



    usb_attach(cpu_exec_enter, NULL);

    delay_samples->info->handle_destroy(delay_samples);



    TAILQ_INSERT_TAIL(&bus->free, cpu_exec_enter, next);

    bus->output_streams++;

    return 0;

}
",0,0,0,-1,port,-0.0005223061889410019,6,21,"{'nused': 'RTCState', 'dev': 'lm32_pic_init', 'nfree': 'output_streams', 'port': 'cpu_exec_enter', 'busnr': 'qemu_log_mask', 'addr': 'HEVCContext'}",MHM-Origin,396,0.20082428852717082
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add(qov, name, qfloat_from_double(*obj));

}
",46,"static void qmp_output_type_number(Visitor *RV34_MB_SKIP, const char *MSR_IA32_TSC, double *channelNum,

                                   Error **pin)

{

    QmpOutputVisitor *MAX_RINGS = to_qov(RV34_MB_SKIP);

    qmp_output_add(MAX_RINGS, MSR_IA32_TSC, qfloat_from_double(*channelNum));

}
",0,0,0,-1,qov,8.359504863619804e-05,5,9,"{'name': 'MSR_IA32_TSC', 'qov': 'MAX_RINGS', 'errp': 'pin', 'obj': 'channelNum', 'v': 'RV34_MB_SKIP'}",MHM-Origin,391,0.20566032330195108
107,"static int alloc_refcount_block(BlockDriverState *bs,

    int64_t cluster_index, uint16_t **refcount_block)

{

    BDRVQcowState *s = bs->opaque;

    unsigned int refcount_table_index;

    int ret;



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    refcount_table_index = cluster_index >> s->refcount_block_bits;



    if (refcount_table_index < s->refcount_table_size) {



        uint64_t refcount_block_offset =

            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(s, refcount_block_offset)) {

                qcow2_signal_corruption(bs, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        refcount_table_index);

                return -EIO;

            }



             return load_refcount_block(bs, refcount_block_offset,

                 (void**) refcount_block);

        }

    }



    /*

     * If we came here, we need to allocate something. Something is at least

     * a cluster for the new refcount block. It may also include a new refcount

     * table if the old refcount table is too small.

     *

     * Note that allocating clusters here needs some special care:

     *

     * - We can't use the normal qcow2_alloc_clusters(), it would try to

     *   increase the refcount and very likely we would end up with an endless

     *   recursion. Instead we must place the refcount blocks in a way that

     *   they can describe them themselves.

     *

     * - We need to consider that at this point we are inside update_refcounts

     *   and potentially doing an initial refcount increase. This means that

     *   some clusters have already been allocated by the caller, but their

     *   refcount isn't accurate yet. If we allocate clusters for metadata, we

     *   need to return -EAGAIN to signal the caller that it needs to restart

     *   the search for free clusters.

     *

     * - alloc_clusters_noref and qcow2_free_clusters may load a different

     *   refcount block into the cache

     */



    *refcount_block = NULL;



    /* We write to the refcount table, so we might depend on L2 tables */

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {

        return ret;

    }



    /* Allocate the refcount block itself and mark it as used */

    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);

    if (new_block < 0) {

        return new_block;

    }



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Allocate refcount block %d for %"" PRIx64

        "" at %"" PRIx64 ""\n"",

        refcount_table_index, cluster_index << s->cluster_bits, new_block);

#endif



    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {

        /* Zero the new refcount block before updating it */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);



        /* The block describes itself, need to update the cache */

        int block_index = (new_block >> s->cluster_bits) &

            (s->refcount_block_size - 1);

        (*refcount_block)[block_index] = cpu_to_be16(1);

    } else {

        /* Described somewhere else. This can recurse at most twice before we

         * arrive at a block that describes itself. */

        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,

                              QCOW2_DISCARD_NEVER);

        if (ret < 0) {

            goto fail_block;

        }



        ret = qcow2_cache_flush(bs, s->refcount_block_cache);

        if (ret < 0) {

            goto fail_block;

        }



        /* Initialize the new refcount block only after updating its refcount,

         * update_refcount uses the refcount cache itself */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);

    }



    /* Now the new refcount block needs to be written to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);

    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);

    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {

        goto fail_block;

    }



    /* If the refcount table is big enough, just hook the block up there */

    if (refcount_table_index < s->refcount_table_size) {

        uint64_t data64 = cpu_to_be64(new_block);

        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);

        ret = bdrv_pwrite_sync(bs->file,

            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),

            &data64, sizeof(data64));

        if (ret < 0) {

            goto fail_block;

        }



        s->refcount_table[refcount_table_index] = new_block;



        /* The new refcount block may be where the caller intended to put its

         * data, so let it restart the search. */

        return -EAGAIN;

    }



    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    if (ret < 0) {

        goto fail_block;

    }



    /*

     * If we come here, we need to grow the refcount table. Again, a new

     * refcount table needs some space and we can't simply allocate to avoid

     * endless recursion.

     *

     * Therefore let's grab new refcount blocks at the end of the image, which

     * will describe themselves and the new refcount table. This way we can

     * reference them only in the new table and do the switch to the new

     * refcount table at once without producing an inconsistent state in

     * between.

     */

    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);



    /* Calculate the number of refcount blocks needed so far */

    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);



    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {

        return -EFBIG;

    }



    /* And now we need at least one block more for the new metadata */

    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);

    uint64_t last_table_size;

    uint64_t blocks_clusters;

    do {

        uint64_t table_clusters =

            size_to_clusters(s, table_size * sizeof(uint64_t));

        blocks_clusters = 1 +

            ((table_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size);

        uint64_t meta_clusters = table_clusters + blocks_clusters;



        last_table_size = table_size;

        table_size = next_refcount_table_size(s, blocks_used +

            ((meta_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size));



    } while (last_table_size != table_size);



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Grow refcount table %"" PRId32 "" => %"" PRId64 ""\n"",

        s->refcount_table_size, table_size);

#endif



    /* Create the new refcount table and blocks */

    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *

        s->cluster_size;

    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;

    uint64_t *new_table = g_try_new0(uint64_t, table_size);

    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);



    assert(table_size > 0 && blocks_clusters > 0);

    if (new_table == NULL || new_blocks == NULL) {

        ret = -ENOMEM;

        goto fail_table;

    }



    /* Fill the new refcount table */

    memcpy(new_table, s->refcount_table,

        s->refcount_table_size * sizeof(uint64_t));

    new_table[refcount_table_index] = new_block;



    int i;

    for (i = 0; i < blocks_clusters; i++) {

        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);

    }



    /* Fill the refcount blocks */

    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));

    int block = 0;

    for (i = 0; i < table_clusters + blocks_clusters; i++) {

        new_blocks[block++] = cpu_to_be16(1);

    }



    /* Write refcount blocks to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);

    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,

        blocks_clusters * s->cluster_size);

    g_free(new_blocks);

    new_blocks = NULL;

    if (ret < 0) {

        goto fail_table;

    }



    /* Write refcount table to disk */

    for(i = 0; i < table_size; i++) {

        cpu_to_be64s(&new_table[i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);

    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,

        table_size * sizeof(uint64_t));

    if (ret < 0) {

        goto fail_table;

    }



    for(i = 0; i < table_size; i++) {

        be64_to_cpus(&new_table[i]);

    }



    /* Hook up the new refcount table in the qcow2 header */

    uint8_t data[12];

    cpu_to_be64w((uint64_t*)data, table_offset);

    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);

    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),

        data, sizeof(data));

    if (ret < 0) {

        goto fail_table;

    }



    /* And switch it in memory */

    uint64_t old_table_offset = s->refcount_table_offset;

    uint64_t old_table_size = s->refcount_table_size;



    g_free(s->refcount_table);

    s->refcount_table = new_table;

    s->refcount_table_size = table_size;

    s->refcount_table_offset = table_offset;



    /* Free old table. */

    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),

                        QCOW2_DISCARD_OTHER);



    ret = load_refcount_block(bs, new_block, (void**) refcount_block);

    if (ret < 0) {

        return ret;

    }



    /* If we were trying to do the initial refcount update for some cluster

     * allocation, we might have used the same clusters to store newly

     * allocated metadata. Make the caller search some new space. */

    return -EAGAIN;



fail_table:

    g_free(new_blocks);

    g_free(new_table);

fail_block:

    if (*refcount_block != NULL) {

        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    }

    return ret;

}
",1242,"static int alloc_refcount_block(BlockDriverState *bios_name,

    int64_t cluster_index, uint16_t **refcount_block)

{

    BDRVQcowState *bdsp = bios_name->opaque;

    unsigned int refcount_table_index;

    int ret;



    BLKDBG_EVENT(bios_name->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    refcount_table_index = cluster_index >> bdsp->refcount_block_bits;



    if (refcount_table_index < bdsp->refcount_table_size) {



        uint64_t refcount_block_offset =

            bdsp->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(bdsp, refcount_block_offset)) {

                qcow2_signal_corruption(bios_name, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        refcount_table_index);

                return -EIO;

            }



             return load_refcount_block(bios_name, refcount_block_offset,

                 (void**) refcount_block);

        }

    }



    /*

     * If we came here, we need to allocate something. Something is at least

     * a cluster for the new refcount block. It may also include a new refcount

     * table if the old refcount table is too small.

     *

     * Note that allocating clusters here needs some special care:

     *

     * - We can't use the normal qcow2_alloc_clusters(), it would try to

     *   increase the refcount and very likely we would end up with an endless

     *   recursion. Instead we must place the refcount blocks in a way that

     *   they can describe them themselves.

     *

     * - We need to consider that at this point we are inside update_refcounts

     *   and potentially doing an initial refcount increase. This means that

     *   some clusters have already been allocated by the caller, but their

     *   refcount isn't accurate yet. If we allocate clusters for metadata, we

     *   need to return -EAGAIN to signal the caller that it needs to restart

     *   the search for free clusters.

     *

     * - alloc_clusters_noref and qcow2_free_clusters may load a different

     *   refcount block into the cache

     */



    *refcount_block = NULL;



    /* We write to the refcount table, so we might depend on L2 tables */

    ret = qcow2_cache_flush(bios_name, bdsp->l2_table_cache);

    if (ret < 0) {

        return ret;

    }



    /* Allocate the refcount block itself and mark it as used */

    int64_t new_block = alloc_clusters_noref(bios_name, bdsp->cluster_size);

    if (new_block < 0) {

        return new_block;

    }



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Allocate refcount block %d for %"" PRIx64

        "" at %"" PRIx64 ""
"",

        refcount_table_index, cluster_index << bdsp->cluster_bits, new_block);

#endif



    if (in_same_refcount_block(bdsp, new_block, cluster_index << bdsp->cluster_bits)) {

        /* Zero the new refcount block before updating it */

        ret = qcow2_cache_get_empty(bios_name, bdsp->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, bdsp->cluster_size);



        /* The block describes itself, need to update the cache */

        int block_index = (new_block >> bdsp->cluster_bits) &

            (bdsp->refcount_block_size - 1);

        (*refcount_block)[block_index] = cpu_to_be16(1);

    } else {

        /* Described somewhere else. This can recurse at most twice before we

         * arrive at a block that describes itself. */

        ret = update_refcount(bios_name, new_block, bdsp->cluster_size, 1, false,

                              QCOW2_DISCARD_NEVER);

        if (ret < 0) {

            goto fail_block;

        }



        ret = qcow2_cache_flush(bios_name, bdsp->refcount_block_cache);

        if (ret < 0) {

            goto fail_block;

        }



        /* Initialize the new refcount block only after updating its refcount,

         * update_refcount uses the refcount cache itself */

        ret = qcow2_cache_get_empty(bios_name, bdsp->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, bdsp->cluster_size);

    }



    /* Now the new refcount block needs to be written to disk */

    BLKDBG_EVENT(bios_name->file, BLKDBG_REFBLOCK_ALLOC_WRITE);

    qcow2_cache_entry_mark_dirty(bdsp->refcount_block_cache, *refcount_block);

    ret = qcow2_cache_flush(bios_name, bdsp->refcount_block_cache);

    if (ret < 0) {

        goto fail_block;

    }



    /* If the refcount table is big enough, just hook the block up there */

    if (refcount_table_index < bdsp->refcount_table_size) {

        uint64_t data64 = cpu_to_be64(new_block);

        BLKDBG_EVENT(bios_name->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);

        ret = bdrv_pwrite_sync(bios_name->file,

            bdsp->refcount_table_offset + refcount_table_index * sizeof(uint64_t),

            &data64, sizeof(data64));

        if (ret < 0) {

            goto fail_block;

        }



        bdsp->refcount_table[refcount_table_index] = new_block;



        /* The new refcount block may be where the caller intended to put its

         * data, so let it restart the search. */

        return -EAGAIN;

    }



    ret = qcow2_cache_put(bios_name, bdsp->refcount_block_cache, (void**) refcount_block);

    if (ret < 0) {

        goto fail_block;

    }



    /*

     * If we come here, we need to grow the refcount table. Again, a new

     * refcount table needs some space and we can't simply allocate to avoid

     * endless recursion.

     *

     * Therefore let's grab new refcount blocks at the end of the image, which

     * will describe themselves and the new refcount table. This way we can

     * reference them only in the new table and do the switch to the new

     * refcount table at once without producing an inconsistent state in

     * between.

     */

    BLKDBG_EVENT(bios_name->file, BLKDBG_REFTABLE_GROW);



    /* Calculate the number of refcount blocks needed so far */

    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, bdsp->refcount_block_size);



    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {

        return -EFBIG;

    }



    /* And now we need at least one block more for the new metadata */

    uint64_t table_size = next_refcount_table_size(bdsp, blocks_used + 1);

    uint64_t IS_8X16;

    uint64_t blocks_clusters;

    do {

        uint64_t table_clusters =

            size_to_clusters(bdsp, table_size * sizeof(uint64_t));

        blocks_clusters = 1 +

            ((table_clusters + bdsp->refcount_block_size - 1)

            / bdsp->refcount_block_size);

        uint64_t meta_clusters = table_clusters + blocks_clusters;



        IS_8X16 = table_size;

        table_size = next_refcount_table_size(bdsp, blocks_used +

            ((meta_clusters + bdsp->refcount_block_size - 1)

            / bdsp->refcount_block_size));



    } while (IS_8X16 != table_size);



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Grow refcount table %"" PRId32 "" => %"" PRId64 ""
"",

        bdsp->refcount_table_size, table_size);

#endif



    /* Create the new refcount table and blocks */

    uint64_t meta_offset = (blocks_used * bdsp->refcount_block_size) *

        bdsp->cluster_size;

    uint64_t table_offset = meta_offset + blocks_clusters * bdsp->cluster_size;

    uint64_t *resync_mb_y = g_try_new0(uint64_t, table_size);

    uint16_t *tb = g_try_malloc0(blocks_clusters * bdsp->cluster_size);



    assert(table_size > 0 && blocks_clusters > 0);

    if (resync_mb_y == NULL || tb == NULL) {

        ret = -ENOMEM;

        goto fail_table;

    }



    /* Fill the new refcount table */

    memcpy(resync_mb_y, bdsp->refcount_table,

        bdsp->refcount_table_size * sizeof(uint64_t));

    resync_mb_y[refcount_table_index] = new_block;



    int gen_add_A0_ds_seg;

    for (gen_add_A0_ds_seg = 0; gen_add_A0_ds_seg < blocks_clusters; gen_add_A0_ds_seg++) {

        resync_mb_y[blocks_used + gen_add_A0_ds_seg] = meta_offset + (gen_add_A0_ds_seg * bdsp->cluster_size);

    }



    /* Fill the refcount blocks */

    uint64_t table_clusters = size_to_clusters(bdsp, table_size * sizeof(uint64_t));

    int block = 0;

    for (gen_add_A0_ds_seg = 0; gen_add_A0_ds_seg < table_clusters + blocks_clusters; gen_add_A0_ds_seg++) {

        tb[block++] = cpu_to_be16(1);

    }



    /* Write refcount blocks to disk */

    BLKDBG_EVENT(bios_name->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);

    ret = bdrv_pwrite_sync(bios_name->file, meta_offset, tb,

        blocks_clusters * bdsp->cluster_size);

    g_free(tb);

    tb = NULL;

    if (ret < 0) {

        goto fail_table;

    }



    /* Write refcount table to disk */

    for(gen_add_A0_ds_seg = 0; gen_add_A0_ds_seg < table_size; gen_add_A0_ds_seg++) {

        cpu_to_be64s(&resync_mb_y[gen_add_A0_ds_seg]);

    }



    BLKDBG_EVENT(bios_name->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);

    ret = bdrv_pwrite_sync(bios_name->file, table_offset, resync_mb_y,

        table_size * sizeof(uint64_t));

    if (ret < 0) {

        goto fail_table;

    }



    for(gen_add_A0_ds_seg = 0; gen_add_A0_ds_seg < table_size; gen_add_A0_ds_seg++) {

        be64_to_cpus(&resync_mb_y[gen_add_A0_ds_seg]);

    }



    /* Hook up the new refcount table in the qcow2 header */

    uint8_t alias[12];

    cpu_to_be64w((uint64_t*)alias, table_offset);

    cpu_to_be32w((uint32_t*)(alias + 8), table_clusters);

    BLKDBG_EVENT(bios_name->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);

    ret = bdrv_pwrite_sync(bios_name->file, offsetof(QCowHeader, refcount_table_offset),

        alias, sizeof(alias));

    if (ret < 0) {

        goto fail_table;

    }



    /* And switch it in memory */

    uint64_t old_table_offset = bdsp->refcount_table_offset;

    uint64_t old_table_size = bdsp->refcount_table_size;



    g_free(bdsp->refcount_table);

    bdsp->refcount_table = resync_mb_y;

    bdsp->refcount_table_size = table_size;

    bdsp->refcount_table_offset = table_offset;



    /* Free old table. */

    qcow2_free_clusters(bios_name, old_table_offset, old_table_size * sizeof(uint64_t),

                        QCOW2_DISCARD_OTHER);



    ret = load_refcount_block(bios_name, new_block, (void**) refcount_block);

    if (ret < 0) {

        return ret;

    }



    /* If we were trying to do the initial refcount update for some cluster

     * allocation, we might have used the same clusters to store newly

     * allocated metadata. Make the caller search some new space. */

    return -EAGAIN;



fail_table:

    g_free(tb);

    g_free(resync_mb_y);

fail_block:

    if (*refcount_block != NULL) {

        qcow2_cache_put(bios_name, bdsp->refcount_block_cache, (void**) refcount_block);

    }

    return ret;

}
",1,1,0,1,bs,-0.14107072353363037,7,117,"{'data': 'alias', 's': 'bdsp', 'last_table_size': 'IS_8X16', 'new_blocks': 'tb', 'bs': 'bios_name', 'new_table': 'resync_mb_y', 'i': 'gen_add_A0_ds_seg'}",MHM-Origin,256,0.18729967673619588
109,"static int getopt(int argc, char *argv[], char *opts)

{

    static int sp = 1;

    int c;

    char *cp;



    if (sp == 1)

        if (optind >= argc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][sp];

    if (c == ':' || (cp = strchr(opts, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c\n"", c);

        if (argv[optind][++sp] == '\0') {

            optind++;

            sp = 1;

        }

        return '?';

    }

    if (*++cp == ':') {

        if (argv[optind][sp+1] != '\0')

            optarg = &argv[optind++][sp+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c\n"", c);

            sp = 1;

            return '?';

        } else

            optarg = argv[optind++];

        sp = 1;

    } else {

        if (argv[optind][++sp] == '\0') {

            sp = 1;

            optind++;

        }

        optarg = NULL;

    }



    return c;

}
",289,"static int getopt(int argc, char *argv[], char *timer_irq)

{

    static int set_float_rounding_mode = 1;

    int c;

    char *p4;



    if (set_float_rounding_mode == 1)

        if (optind >= argc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][set_float_rounding_mode];

    if (c == ':' || (p4 = strchr(timer_irq, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c
"", c);

        if (argv[optind][++set_float_rounding_mode] == '\0') {

            optind++;

            set_float_rounding_mode = 1;

        }

        return '?';

    }

    if (*++p4 == ':') {

        if (argv[optind][set_float_rounding_mode+1] != '\0')

            optarg = &argv[optind++][set_float_rounding_mode+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c
"", c);

            set_float_rounding_mode = 1;

            return '?';

        } else

            optarg = argv[optind++];

        set_float_rounding_mode = 1;

    } else {

        if (argv[optind][++set_float_rounding_mode] == '\0') {

            set_float_rounding_mode = 1;

            optind++;

        }

        optarg = NULL;

    }



    return c;

}
",0,0,1,1,sp,0.28066058456897736,3,16,"{'opts': 'timer_irq', 'cp': 'p4', 'sp': 'set_float_rounding_mode'}",MHM-Origin,61,0.026708161830902098
110,"static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,

                                    uint32_t val)

{

    SLAVIO_TIMERState *s = opaque;

    uint32_t saddr;

    int reload = 0;



    DPRINTF(""write "" TARGET_FMT_plx "" %08x\n"", addr, val);

    saddr = (addr & TIMER_MAXADDR) >> 2;

    switch (saddr) {

    case TIMER_LIMIT:

        if (slavio_timer_is_user(s)) {

            // set user counter MSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else {

            // set limit, reset counter

            qemu_irq_lower(s->irq);

            s->limit = val & TIMER_MAX_COUNT32;

            if (!s->limit)

                s->limit = TIMER_MAX_COUNT32;

            ptimer_set_limit(s->timer, s->limit >> 9, 1);

        }

        break;

    case TIMER_COUNTER:

        if (slavio_timer_is_user(s)) {

            // set user counter LSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else

            DPRINTF(""not user timer\n"");

        break;

    case TIMER_COUNTER_NORST:

        // set limit without resetting counter

        s->limit = val & TIMER_MAX_COUNT32;

        if (!s->limit)

            s->limit = TIMER_MAX_COUNT32;

        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);

        break;

    case TIMER_STATUS:

        if (slavio_timer_is_user(s)) {

            // start/stop user counter

            if ((val & 1) && !s->running) {

                DPRINTF(""processor %d user timer started\n"", s->slave_index);

                ptimer_run(s->timer, 0);

                s->running = 1;

            } else if (!(val & 1) && s->running) {

                DPRINTF(""processor %d user timer stopped\n"", s->slave_index);

                ptimer_stop(s->timer);

                s->running = 0;

            }

        }

        break;

    case TIMER_MODE:

        if (s->master == NULL) {

            unsigned int i;



            for (i = 0; i < s->num_slaves; i++) {

                if (val & (1 << i)) {

                    qemu_irq_lower(s->slave[i]->irq);

                    s->slave[i]->limit = -1ULL;

                }

                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {

                    ptimer_stop(s->slave[i]->timer);

                    ptimer_set_limit(s->slave[i]->timer,

                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);

                    DPRINTF(""processor %d timer changed\n"",

                            s->slave[i]->slave_index);

                    ptimer_run(s->slave[i]->timer, 0);

                }

            }

            s->slave_mode = val & ((1 << s->num_slaves) - 1);

        } else

            DPRINTF(""not system timer\n"");

        break;

    default:

        DPRINTF(""invalid write address "" TARGET_FMT_plx ""\n"", addr);

        break;

    }

}
",567,"static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t AV_CODEC_ID_PCM_U8,

                                    uint32_t val)

{

    SLAVIO_TIMERState *s = opaque;

    uint32_t saddr;

    int reload = 0;



    DPRINTF(""write "" TARGET_FMT_plx "" %08x
"", AV_CODEC_ID_PCM_U8, val);

    saddr = (AV_CODEC_ID_PCM_U8 & TIMER_MAXADDR) >> 2;

    switch (saddr) {

    case TIMER_LIMIT:

        if (slavio_timer_is_user(s)) {

            // set user counter MSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset
"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else {

            // set limit, reset counter

            qemu_irq_lower(s->irq);

            s->limit = val & TIMER_MAX_COUNT32;

            if (!s->limit)

                s->limit = TIMER_MAX_COUNT32;

            ptimer_set_limit(s->timer, s->limit >> 9, 1);

        }

        break;

    case TIMER_COUNTER:

        if (slavio_timer_is_user(s)) {

            // set user counter LSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset
"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else

            DPRINTF(""not user timer
"");

        break;

    case TIMER_COUNTER_NORST:

        // set limit without resetting counter

        s->limit = val & TIMER_MAX_COUNT32;

        if (!s->limit)

            s->limit = TIMER_MAX_COUNT32;

        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);

        break;

    case TIMER_STATUS:

        if (slavio_timer_is_user(s)) {

            // start/stop user counter

            if ((val & 1) && !s->running) {

                DPRINTF(""processor %d user timer started
"", s->slave_index);

                ptimer_run(s->timer, 0);

                s->running = 1;

            } else if (!(val & 1) && s->running) {

                DPRINTF(""processor %d user timer stopped
"", s->slave_index);

                ptimer_stop(s->timer);

                s->running = 0;

            }

        }

        break;

    case TIMER_MODE:

        if (s->master == NULL) {

            unsigned int i;



            for (i = 0; i < s->num_slaves; i++) {

                if (val & (1 << i)) {

                    qemu_irq_lower(s->slave[i]->irq);

                    s->slave[i]->limit = -1ULL;

                }

                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {

                    ptimer_stop(s->slave[i]->timer);

                    ptimer_set_limit(s->slave[i]->timer,

                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);

                    DPRINTF(""processor %d timer changed
"",

                            s->slave[i]->slave_index);

                    ptimer_run(s->slave[i]->timer, 0);

                }

            }

            s->slave_mode = val & ((1 << s->num_slaves) - 1);

        } else

            DPRINTF(""not system timer
"");

        break;

    default:

        DPRINTF(""invalid write address "" TARGET_FMT_plx ""
"", AV_CODEC_ID_PCM_U8);

        break;

    }

}
",0,0,1,1,addr,0.42186060547828674,1,4,{'addr': 'AV_CODEC_ID_PCM_U8'},MHM-Origin,22,0.009801650047302246
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",104,"static void temp_allocate_frame(TCGContext *tf, int temp)

{

    TCGTemp *ts;

    ts = &tf->temps[temp];

    tf->current_frame_offset = (tf->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (tf->current_frame_offset + sizeof(tcg_target_long) > tf->frame_end)

        tcg_abort();

    ts->mem_offset = tf->current_frame_offset;

    ts->mem_reg = tf->frame_reg;

    ts->mem_allocated = 1;

    tf->current_frame_offset += sizeof(tcg_target_long);

}
",0,0,1,1,s,0.31265801191329956,1,9,{'s': 'tf'},MHM-Origin,19,0.008330778280893961
113,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",150,"void qmp_block_stream(const char *rt, bool has_base,

                      const char *kvm_vm_ioctl, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *filter = NULL;



    bs = bdrv_find(rt);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, rt);

        return;

    }



    if (kvm_vm_ioctl) {

        base_bs = bdrv_find_backing_image(bs, kvm_vm_ioctl);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, kvm_vm_ioctl);

            return;

        }

    }



    stream_start(bs, base_bs, kvm_vm_ioctl, block_stream_cb, bs, &filter);

    if (error_is_set(&filter)) {

        error_propagate(errp, filter);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",0,0,1,1,local_err,0.21908849477767944,3,12,"{'device': 'rt', 'local_err': 'filter', 'base': 'kvm_vm_ioctl'}",MHM-Origin,99,0.04308676719665527
115,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
",38,"static inline int num_effective_busses(XilinxSPIPS *ubuf0)

{

    return (ubuf0->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            ubuf0->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? ubuf0->num_busses : 1;

}
",0,0,0,-1,s,-0.007663613185286522,1,4,{'s': 'ubuf0'},MHM-Origin,395,0.1703636884689331
117,"static void gen_set_CF_bit31(TCGv var)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, var, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
",35,"static void gen_set_CF_bit31(TCGv vqs)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, vqs, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
",1,1,1,-1,var,-0.0008381009101867676,1,2,{'var': 'vqs'},MHM-Origin,399,0.1657915989557902
118,"static int get_siz(Jpeg2000DecoderContext *s)
{
    int i;
    int ncomponents;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *possible_fmts = NULL;
    int possible_fmts_nb = 0;
    if (bytestream2_get_bytes_left(&s->g) < 36) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for SIZ\n"");
    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz
    s->width          = bytestream2_get_be32u(&s->g); // Width
    s->height         = bytestream2_get_be32u(&s->g); // Height
    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz
    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz
    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz
    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz
    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz
    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz
    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz
    if (s->image_offset_x || s->image_offset_y) {
        avpriv_request_sample(s->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {
        avpriv_request_sample(s->avctx, ""Large Dimensions"");
        return AVERROR_PATCHWELCOME;
    if (ncomponents <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"",
    if (ncomponents > 4) {
        avpriv_request_sample(s->avctx, ""Support for %d components"",
                              ncomponents);
        return AVERROR_PATCHWELCOME;
    s->ncomponents = ncomponents;
    if (s->tile_width <= 0 || s->tile_height <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"",
               s->tile_width, s->tile_height);
    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for %d components in SIZ\n"", s->ncomponents);
    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i
        uint8_t x    = bytestream2_get_byteu(&s->g);
        s->cbps[i]   = (x & 0x7f) + 1;
        s->precision = FFMAX(s->cbps[i], s->precision);
        s->sgnd[i]   = !!(x & 0x80);
        s->cdx[i]    = bytestream2_get_byteu(&s->g);
        s->cdy[i]    = bytestream2_get_byteu(&s->g);
        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {
            av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d\n"", s->cdx[i], s->cdy[i]);
        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;
    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);
    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);
    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(EINVAL);
    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));
    if (!s->tile) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(ENOMEM);
    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {
        Jpeg2000Tile *tile = s->tile + i;
        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));
        if (!tile->comp)
            return AVERROR(ENOMEM);
    /* compute image size with reduction factor */
    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,
                                               s->reduction_factor);
    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,
                                               s->reduction_factor);
    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
        possible_fmts = xyz_pix_fmts;
        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
    } else {
        switch (s->colour_space) {
        case 16:
            possible_fmts = rgb_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
            break;
        case 17:
            possible_fmts = gray_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
            break;
        case 18:
            possible_fmts = yuv_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
            break;
        default:
            possible_fmts = all_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
            break;
    for (i = 0; i < possible_fmts_nb; ++i) {
        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {
            s->avctx->pix_fmt = possible_fmts[i];
            break;
    if (i == possible_fmts_nb) {
        if (ncomponents == 4 &&
            s->cdy[0] == 1 && s->cdx[0] == 1 &&
            s->cdy[1] == 1 && s->cdx[1] == 1 &&
            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {
            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {
                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
                s->cdef[0] = 0;
                s->cdef[1] = 1;
                s->cdef[2] = 2;
                s->cdef[3] = 3;
                i = 0;
    if (i == possible_fmts_nb) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d\n""
               ""cdx[0]: %d, cdy[0]: %d\n""
               ""cdx[1]: %d, cdy[1]: %d\n""
               ""cdx[2]: %d, cdy[2]: %d\n""
               ""cdx[3]: %d, cdy[3]: %d\n"",
               s->avctx->profile, s->colour_space, ncomponents, s->precision,
               s->cdx[0],
               s->cdy[0],
               ncomponents > 1 ? s->cdx[1] : 0,
               ncomponents > 1 ? s->cdy[1] : 0,
               ncomponents > 2 ? s->cdx[2] : 0,
               ncomponents > 2 ? s->cdy[2] : 0,
               ncomponents > 3 ? s->cdx[3] : 0,
               ncomponents > 3 ? s->cdy[3] : 0);
        return AVERROR_PATCHWELCOME;
    s->avctx->bits_per_raw_sample = s->precision;
    return 0;",1272,"static int get_siz(Jpeg2000DecoderContext *fsconf)
{
    int kernel_le;
    int RTP_H261_PAYLOAD_HEADER_SIZE;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *lumFilterSize = NULL;
    int possible_fmts_nb = 0;
    if (bytestream2_get_bytes_left(&fsconf->g) < 36) {
        av_log(fsconf->avctx, AV_LOG_ERROR, ""Insufficient space for SIZ
"");
    fsconf->avctx->profile = bytestream2_get_be16u(&fsconf->g); // Rsiz
    fsconf->width          = bytestream2_get_be32u(&fsconf->g); // Width
    fsconf->height         = bytestream2_get_be32u(&fsconf->g); // Height
    fsconf->image_offset_x = bytestream2_get_be32u(&fsconf->g); // X0Siz
    fsconf->image_offset_y = bytestream2_get_be32u(&fsconf->g); // Y0Siz
    fsconf->tile_width     = bytestream2_get_be32u(&fsconf->g); // XTSiz
    fsconf->tile_height    = bytestream2_get_be32u(&fsconf->g); // YTSiz
    fsconf->tile_offset_x  = bytestream2_get_be32u(&fsconf->g); // XT0Siz
    fsconf->tile_offset_y  = bytestream2_get_be32u(&fsconf->g); // YT0Siz
    RTP_H261_PAYLOAD_HEADER_SIZE       = bytestream2_get_be16u(&fsconf->g); // CSiz
    if (fsconf->image_offset_x || fsconf->image_offset_y) {
        avpriv_request_sample(fsconf->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    if (av_image_check_size(fsconf->width, fsconf->height, 0, fsconf->avctx)) {
        avpriv_request_sample(fsconf->avctx, ""Large Dimensions"");
        return AVERROR_PATCHWELCOME;
    if (RTP_H261_PAYLOAD_HEADER_SIZE <= 0) {
        av_log(fsconf->avctx, AV_LOG_ERROR, ""Invalid number of components: %d
"",
    if (RTP_H261_PAYLOAD_HEADER_SIZE > 4) {
        avpriv_request_sample(fsconf->avctx, ""Support for %d components"",
                              RTP_H261_PAYLOAD_HEADER_SIZE);
        return AVERROR_PATCHWELCOME;
    fsconf->RTP_H261_PAYLOAD_HEADER_SIZE = RTP_H261_PAYLOAD_HEADER_SIZE;
    if (fsconf->tile_width <= 0 || fsconf->tile_height <= 0) {
        av_log(fsconf->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.
"",
               fsconf->tile_width, fsconf->tile_height);
    if (bytestream2_get_bytes_left(&fsconf->g) < 3 * fsconf->RTP_H261_PAYLOAD_HEADER_SIZE) {
        av_log(fsconf->avctx, AV_LOG_ERROR, ""Insufficient space for %d components in SIZ
"", fsconf->RTP_H261_PAYLOAD_HEADER_SIZE);
    for (kernel_le = 0; kernel_le < fsconf->RTP_H261_PAYLOAD_HEADER_SIZE; kernel_le++) { // Ssiz_i XRsiz_i, YRsiz_i
        uint8_t x    = bytestream2_get_byteu(&fsconf->g);
        fsconf->cbps[kernel_le]   = (x & 0x7f) + 1;
        fsconf->precision = FFMAX(fsconf->cbps[kernel_le], fsconf->precision);
        fsconf->sgnd[kernel_le]   = !!(x & 0x80);
        fsconf->cdx[kernel_le]    = bytestream2_get_byteu(&fsconf->g);
        fsconf->cdy[kernel_le]    = bytestream2_get_byteu(&fsconf->g);
        if (   !fsconf->cdx[kernel_le] || fsconf->cdx[kernel_le] == 3 || fsconf->cdx[kernel_le] > 4
            || !fsconf->cdy[kernel_le] || fsconf->cdy[kernel_le] == 3 || fsconf->cdy[kernel_le] > 4) {
            av_log(fsconf->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d
"", fsconf->cdx[kernel_le], fsconf->cdy[kernel_le]);
        log2_chroma_wh |= fsconf->cdy[kernel_le] >> 1 << kernel_le * 4 | fsconf->cdx[kernel_le] >> 1 << kernel_le * 4 + 2;
    fsconf->numXtiles = ff_jpeg2000_ceildiv(fsconf->width  - fsconf->tile_offset_x, fsconf->tile_width);
    fsconf->numYtiles = ff_jpeg2000_ceildiv(fsconf->height - fsconf->tile_offset_y, fsconf->tile_height);
    if (fsconf->numXtiles * (uint64_t)fsconf->numYtiles > INT_MAX/sizeof(*fsconf->reg_to_temp)) {
        fsconf->numXtiles = fsconf->numYtiles = 0;
        return AVERROR(EINVAL);
    fsconf->reg_to_temp = av_mallocz_array(fsconf->numXtiles * fsconf->numYtiles, sizeof(*fsconf->reg_to_temp));
    if (!fsconf->reg_to_temp) {
        fsconf->numXtiles = fsconf->numYtiles = 0;
        return AVERROR(ENOMEM);
    for (kernel_le = 0; kernel_le < fsconf->numXtiles * fsconf->numYtiles; kernel_le++) {
        Jpeg2000Tile *reg_to_temp = fsconf->reg_to_temp + kernel_le;
        reg_to_temp->comp = av_mallocz(fsconf->RTP_H261_PAYLOAD_HEADER_SIZE * sizeof(*reg_to_temp->comp));
        if (!reg_to_temp->comp)
            return AVERROR(ENOMEM);
    /* compute image size with reduction factor */
    fsconf->avctx->width  = ff_jpeg2000_ceildivpow2(fsconf->width  - fsconf->image_offset_x,
                                               fsconf->reduction_factor);
    fsconf->avctx->height = ff_jpeg2000_ceildivpow2(fsconf->height - fsconf->image_offset_y,
                                               fsconf->reduction_factor);
    if (fsconf->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
        fsconf->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
        lumFilterSize = xyz_pix_fmts;
        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
    } else {
        switch (fsconf->colour_space) {
        case 16:
            lumFilterSize = rgb_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
            break;
        case 17:
            lumFilterSize = gray_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
            break;
        case 18:
            lumFilterSize = yuv_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
            break;
        default:
            lumFilterSize = all_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
            break;
    for (kernel_le = 0; kernel_le < possible_fmts_nb; ++kernel_le) {
        if (pix_fmt_match(lumFilterSize[kernel_le], RTP_H261_PAYLOAD_HEADER_SIZE, fsconf->precision, log2_chroma_wh, fsconf->pal8)) {
            fsconf->avctx->pix_fmt = lumFilterSize[kernel_le];
            break;
    if (kernel_le == possible_fmts_nb) {
        if (RTP_H261_PAYLOAD_HEADER_SIZE == 4 &&
            fsconf->cdy[0] == 1 && fsconf->cdx[0] == 1 &&
            fsconf->cdy[1] == 1 && fsconf->cdx[1] == 1 &&
            fsconf->cdy[2] == fsconf->cdy[3] && fsconf->cdx[2] == fsconf->cdx[3]) {
            if (fsconf->precision == 8 && fsconf->cdy[2] == 2 && fsconf->cdx[2] == 2 && !fsconf->pal8) {
                fsconf->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
                fsconf->cdef[0] = 0;
                fsconf->cdef[1] = 1;
                fsconf->cdef[2] = 2;
                fsconf->cdef[3] = 3;
                kernel_le = 0;
    if (kernel_le == possible_fmts_nb) {
        av_log(fsconf->avctx, AV_LOG_ERROR,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d
""
               ""cdx[0]: %d, cdy[0]: %d
""
               ""cdx[1]: %d, cdy[1]: %d
""
               ""cdx[2]: %d, cdy[2]: %d
""
               ""cdx[3]: %d, cdy[3]: %d
"",
               fsconf->avctx->profile, fsconf->colour_space, RTP_H261_PAYLOAD_HEADER_SIZE, fsconf->precision,
               fsconf->cdx[0],
               fsconf->cdy[0],
               RTP_H261_PAYLOAD_HEADER_SIZE > 1 ? fsconf->cdx[1] : 0,
               RTP_H261_PAYLOAD_HEADER_SIZE > 1 ? fsconf->cdy[1] : 0,
               RTP_H261_PAYLOAD_HEADER_SIZE > 2 ? fsconf->cdx[2] : 0,
               RTP_H261_PAYLOAD_HEADER_SIZE > 2 ? fsconf->cdy[2] : 0,
               RTP_H261_PAYLOAD_HEADER_SIZE > 3 ? fsconf->cdx[3] : 0,
               RTP_H261_PAYLOAD_HEADER_SIZE > 3 ? fsconf->cdy[3] : 0);
        return AVERROR_PATCHWELCOME;
    fsconf->avctx->bits_per_raw_sample = fsconf->precision;
    return 0;",1,1,1,-1,i,-0.00044995546340942383,5,203,"{'possible_fmts': 'lumFilterSize', 'i': 'kernel_le', 's': 'fsconf', 'tile': 'reg_to_temp', 'ncomponents': 'RTP_H261_PAYLOAD_HEADER_SIZE'}",MHM-Origin,396,0.2479638973871867
120,"static void sd_1d97_int(int *p, int i0, int i1)

{

    int i;



    if (i1 <= i0 + 1) {

        if (i0 == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, i0, i1);

    i0++; i1++;



    for (i = i0/2 - 2; i < i1/2 + 1; i++)

        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2 + 1; i++)

        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2; i++)

        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2; i < i1/2; i++)

        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

}
",331,"static void sd_1d97_int(int *p, int IMDCT_buf, int sub_packet_cnt)

{

    int i;



    if (sub_packet_cnt <= IMDCT_buf + 1) {

        if (IMDCT_buf == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, IMDCT_buf, sub_packet_cnt);

    IMDCT_buf++; sub_packet_cnt++;



    for (i = IMDCT_buf/2 - 2; i < sub_packet_cnt/2 + 1; i++)

        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = IMDCT_buf/2 - 1; i < sub_packet_cnt/2 + 1; i++)

        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

    for (i = IMDCT_buf/2 - 1; i < sub_packet_cnt/2; i++)

        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = IMDCT_buf/2; i < sub_packet_cnt/2; i++)

        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

}
",1,1,0,1,i1,-0.8183356076478958,2,17,"{'i0': 'IMDCT_buf', 'i1': 'sub_packet_cnt'}",MHM-Origin,39,0.017435407638549803
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",128,"static inline void RENAME(rgb32ToY)(uint8_t *codec_name, uint8_t *value, int width)

{

	int is_arith;

	for(is_arith=0; is_arith<width; is_arith++)

	{

		int r=  ((uint32_t*)value)[is_arith]&0xFF;

		int g= (((uint32_t*)value)[is_arith]>>8)&0xFF;

		int b= (((uint32_t*)value)[is_arith]>>16)&0xFF;



		codec_name[is_arith]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",1,1,0,1,src,-0.3088008761405945,3,14,"{'i': 'is_arith', 'dst': 'codec_name', 'src': 'value'}",MHM-Origin,80,0.034632388750712076
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",62,"static uint32_t s390_pci_generate_fid(Error **TARGET_PAGE_MASK)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(TARGET_PAGE_MASK, ""no free fid could be found"");

    return 0;

}
",0,0,1,1,errp,0.8719219341874123,1,2,{'errp': 'TARGET_PAGE_MASK'},MHM-Origin,22,0.008382534980773926
123,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
",54,"static void virtio_9p_device_unrealize(DeviceState *QEMUMachineInitArgs, Error **params)

{

    VirtIODevice *from = VIRTIO_DEVICE(QEMUMachineInitArgs);

    V9fsVirtioState *meta_data_maps = VIRTIO_9P(QEMUMachineInitArgs);

    V9fsState *isa_mem_base = &meta_data_maps->state;



    virtio_cleanup(from);

    v9fs_device_unrealize_common(isa_mem_base, params);

}
",0,0,0,-1,dev,0.029898972250521183,5,11,"{'errp': 'params', 'dev': 'QEMUMachineInitArgs', 's': 'isa_mem_base', 'v': 'meta_data_maps', 'vdev': 'from'}",MHM-Origin,405,0.16670466661453248
124,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",89,"static int ipmovie_read_packet(AVFormatContext *gen_helper_fmov_STN_ST0,

                               AVPacket *aspect_ratio_info)

{

    IPMVEContext *ipmovie = (IPMVEContext *)gen_helper_fmov_STN_ST0->priv_data;

    ByteIOContext *pb = &gen_helper_fmov_STN_ST0->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, aspect_ratio_info);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",1,1,0,1,pkt,-0.23328188061714172,2,5,"{'s': 'gen_helper_fmov_STN_ST0', 'pkt': 'aspect_ratio_info'}",MHM-Origin,41,0.016197776794433592
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",53,"bool qemu_co_enter_next(CoQueue *role_val)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&role_val->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&role_val->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",1,1,0,1,queue,-0.5368788801133633,1,3,{'queue': 'role_val'},MHM-Origin,23,0.007863227526346843
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
",39,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *ff_celt_flush = mon_get_cpu();

    if (!ff_celt_flush)

        return 0;

    return ff_celt_flush->regwptr[val];

}
",1,1,0,1,env,-0.7306552529335022,1,3,{'env': 'ff_celt_flush'},MHM-Origin,19,0.007455523808797201
131,"static void set_vlan(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *local_err = NULL;

    int32_t id;

    NetClientState *hubport;



    if (dev->realized) {

        qdev_prop_set_after_realize(dev, name, errp);





    visit_type_int32(v, &id, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);



    if (id == -1) {

        *ptr = NULL;









    hubport = net_hub_port_find(id);

    if (!hubport) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  name, prop->info->name);



    *ptr = hubport;
",165,"static void set_vlan(Object *g_assert, Visitor *v, void *CF_USE_ICOUNT,

                     const char *name, Error **tcg_gen_andi_i64)

{

    DeviceState *QTAILQ_FOREACH = DEVICE(g_assert);

    Property *qemu_chr_add_handlers = CF_USE_ICOUNT;

    NICPeers *OPUS_MODE_CELT = qdev_get_prop_ptr(QTAILQ_FOREACH, qemu_chr_add_handlers);

    NetClientState **qpsum = &OPUS_MODE_CELT->ncs[0];

    Error *local_err = NULL;

    int32_t tcg_gen_qemu_st_i32;

    NetClientState *open;



    if (QTAILQ_FOREACH->realized) {

        qdev_prop_set_after_realize(QTAILQ_FOREACH, name, tcg_gen_andi_i64);





    visit_type_int32(v, &tcg_gen_qemu_st_i32, name, &local_err);

    if (local_err) {

        error_propagate(tcg_gen_andi_i64, local_err);



    if (tcg_gen_qemu_st_i32 == -1) {

        *qpsum = NULL;









    open = net_hub_port_find(tcg_gen_qemu_st_i32);

    if (!open) {

        error_set(tcg_gen_andi_i64, QERR_INVALID_PARAMETER_VALUE,

                  name, qemu_chr_add_handlers->info->name);



    *qpsum = open;
",1,1,1,-1,hubport,0.00014543533325195312,9,28,"{'hubport': 'open', 'prop': 'qemu_chr_add_handlers', 'id': 'tcg_gen_qemu_st_i32', 'errp': 'tcg_gen_andi_i64', 'ptr': 'qpsum', 'opaque': 'CF_USE_ICOUNT', 'peers_ptr': 'OPUS_MODE_CELT', 'dev': 'QTAILQ_FOREACH', 'obj': 'g_assert'}",MHM-Origin,397,0.16299864053726196
132,"static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",138,"static av_cold int png_dec_end(AVCodecContext *bdrv_round_to_clusters)

{

    PNGDecContext *AVIO_FLAG_WRITE = bdrv_round_to_clusters->priv_data;



    ff_thread_release_buffer(bdrv_round_to_clusters, &AVIO_FLAG_WRITE->previous_picture);

    av_frame_free(&AVIO_FLAG_WRITE->previous_picture.f);

    ff_thread_release_buffer(bdrv_round_to_clusters, &AVIO_FLAG_WRITE->last_picture);

    av_frame_free(&AVIO_FLAG_WRITE->last_picture.f);

    ff_thread_release_buffer(bdrv_round_to_clusters, &AVIO_FLAG_WRITE->picture);

    av_frame_free(&AVIO_FLAG_WRITE->picture.f);

    av_freep(&AVIO_FLAG_WRITE->buffer);

    AVIO_FLAG_WRITE->buffer_size = 0;

    av_freep(&AVIO_FLAG_WRITE->last_row);

    AVIO_FLAG_WRITE->last_row_size = 0;

    av_freep(&AVIO_FLAG_WRITE->tmp_row);

    AVIO_FLAG_WRITE->tmp_row_size = 0;

    av_freep(&AVIO_FLAG_WRITE->extra_data);

    AVIO_FLAG_WRITE->extra_data_size = 0;



    return 0;

}
",1,1,0,1,s,-0.34527692198753357,2,20,"{'avctx': 'bdrv_round_to_clusters', 's': 'AVIO_FLAG_WRITE'}",MHM-Origin,60,0.024862356980641685
136,"static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],

                   int dst_stride[3], int src_stride[3], int width,

                   int height, uint8_t *qp_store, int qp_stride)

{

    int x, y, i, j;

    const int count = 1<<p->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? p->hsub : 0);

        int h = height >> (is_chroma ? p->vsub : 0);

        int stride = p->temp_stride[i];

        int block = BLOCK >> (is_chroma ? p->hsub : 0);



        if (!src[i] || !dst[i])

            continue;

        for (y = 0; y < h; y++) {

            int index = block + block * stride + y * stride;



            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );

            for (x = 0; x < block; x++) {

                p->src[i][index     - x - 1] = p->src[i][index +     x    ];

                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];

            }

        }

        for (y = 0; y < block; y++) {

            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);

            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);

        }



        p->frame->linesize[i] = stride;

        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));

    }



    if (p->qp)

        p->frame->quality = p->qp * FF_QP2LAMBDA;

    else {

        int qpsum=0;

        int qpcount = (height>>4) * (height>>4);



        for (y = 0; y < (height>>4); y++) {

            for (x = 0; x < (width>>4); x++)

                qpsum += qp_store[x + y * qp_stride];

        }

        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;

    }

//    init per MB qscale stuff FIXME

    p->frame->height = height;

    p->frame->width  = width;



    for (i = 0; i < count; i++) {

        const int x1 = offset[i+count-1][0];

        const int y1 = offset[i+count-1][1];

        const int x1c = x1 >> p->hsub;

        const int y1c = y1 >> p->vsub;

        const int BLOCKc = BLOCK >> p->hsub;

        int offset;

        AVPacket pkt;

        int got_pkt_ptr;



        av_init_packet(&pkt);

        pkt.data = p->outbuf;

        pkt.size = p->outbuf_size;



        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];

        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];

        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];

        p->frame->format  = p->avctx_enc[i]->pix_fmt;



        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);

        p->frame_dec = p->avctx_enc[i]->coded_frame;



        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];



        for (y = 0; y < height; y++)

            for (x = 0; x < width; x++)

                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];



        if (!src[2] || !dst[2])

            continue;



        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];



        for (y = 0; y < height>>p->vsub; y++) {

            for (x = 0; x < width>>p->hsub; x++) {

                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];

                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];

            }

        }

    }



    for (j = 0; j < 3; j++) {

        int is_chroma = !!j;

        if (!dst[j])

            continue;

        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],

                      width  >> (is_chroma ? p->hsub : 0),

                      height >> (is_chroma ? p->vsub : 0),

                      8-p->log2_count);

    }

}
",1136,"static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],

                   int dst_stride[3], int src_stride[3], int width,

                   int height, uint8_t *qp_store, int MSR_MTRRphysBase)

{

    int x, y, i, j;

    const int count = 1<<p->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? p->hsub : 0);

        int h = height >> (is_chroma ? p->vsub : 0);

        int stride = p->temp_stride[i];

        int block = BLOCK >> (is_chroma ? p->hsub : 0);



        if (!src[i] || !dst[i])

            continue;

        for (y = 0; y < h; y++) {

            int index = block + block * stride + y * stride;



            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );

            for (x = 0; x < block; x++) {

                p->src[i][index     - x - 1] = p->src[i][index +     x    ];

                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];

            }

        }

        for (y = 0; y < block; y++) {

            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);

            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);

        }



        p->frame->linesize[i] = stride;

        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));

    }



    if (p->qp)

        p->frame->quality = p->qp * FF_QP2LAMBDA;

    else {

        int qpsum=0;

        int qpcount = (height>>4) * (height>>4);



        for (y = 0; y < (height>>4); y++) {

            for (x = 0; x < (width>>4); x++)

                qpsum += qp_store[x + y * MSR_MTRRphysBase];

        }

        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;

    }

//    init per MB qscale stuff FIXME

    p->frame->height = height;

    p->frame->width  = width;



    for (i = 0; i < count; i++) {

        const int x1 = offset[i+count-1][0];

        const int y1 = offset[i+count-1][1];

        const int x1c = x1 >> p->hsub;

        const int y1c = y1 >> p->vsub;

        const int BLOCKc = BLOCK >> p->hsub;

        int offset;

        AVPacket pkt;

        int got_pkt_ptr;



        av_init_packet(&pkt);

        pkt.data = p->outbuf;

        pkt.size = p->outbuf_size;



        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];

        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];

        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];

        p->frame->format  = p->avctx_enc[i]->pix_fmt;



        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);

        p->frame_dec = p->avctx_enc[i]->coded_frame;



        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];



        for (y = 0; y < height; y++)

            for (x = 0; x < width; x++)

                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];



        if (!src[2] || !dst[2])

            continue;



        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];



        for (y = 0; y < height>>p->vsub; y++) {

            for (x = 0; x < width>>p->hsub; x++) {

                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];

                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];

            }

        }

    }



    for (j = 0; j < 3; j++) {

        int is_chroma = !!j;

        if (!dst[j])

            continue;

        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],

                      width  >> (is_chroma ? p->hsub : 0),

                      height >> (is_chroma ? p->vsub : 0),

                      8-p->log2_count);

    }

}
",1,1,0,1,qp_stride,-0.3132796883583069,1,2,{'qp_stride': 'MSR_MTRRphysBase'},MHM-Origin,24,0.010264400641123455
137,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",61,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *done;



    s = qfloat_suite();

    done = srunner_create(s);



    srunner_run_all(done, CK_NORMAL);

    nf = srunner_ntests_failed(done);

    srunner_free(done);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",0,0,1,1,sr,0.43006154149770737,1,5,{'sr': 'done'},MHM-Origin,21,0.008011043071746826
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
",131,"static target_ulong put_tce_emu(sPAPRTCETable *sn_info, target_ulong fcmov_cc,

                                target_ulong cpu_tmp0)

{

    IOMMUTLBEntry ibv_ack_cq_events;

    hwaddr page_mask = IOMMU_PAGE_MASK(sn_info->page_shift);

    unsigned long index = (fcmov_cc - sn_info->bus_offset) >> sn_info->page_shift;



    if (index >= sn_info->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""
"", fcmov_cc);

        return H_PARAMETER;

    }



    sn_info->table[index] = cpu_tmp0;



    ibv_ack_cq_events.target_as = &address_space_memory,

    ibv_ack_cq_events.iova = fcmov_cc & page_mask;

    ibv_ack_cq_events.translated_addr = cpu_tmp0 & page_mask;

    ibv_ack_cq_events.addr_mask = ~page_mask;

    ibv_ack_cq_events.perm = spapr_tce_iommu_access_flags(cpu_tmp0);

    memory_region_notify_iommu(&sn_info->iommu, ibv_ack_cq_events);



    return H_SUCCESS;

}
",0,0,1,1,tcet,0.22852474451065063,4,22,"{'entry': 'ibv_ack_cq_events', 'tce': 'cpu_tmp0', 'tcet': 'sn_info', 'ioba': 'fcmov_cc'}",MHM-Origin,215,0.09457481702168782
140,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,

                                    TCGv arg2, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, t1;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, arg1, arg2);



    if (compute_ca) {

        gen_op_arith_compute_ca(ctx, t0, arg1, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, t1);

        gen_op_arith_compute_ca(ctx, t0, t1, 0);

        tcg_temp_free(t1);

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);

    }



    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
",251,"static inline void gen_op_arith_add(DisasContext *temps, TCGv ret, TCGv CP1_fcr0,

                                    TCGv q_scale_type, int aurb, int backing_file_str,

                                    int htab_mask)

{

    TCGv FF_THREAD_SLICE, t1;



    if ((!backing_file_str && !htab_mask) ||

        (!TCGV_EQUAL(ret,CP1_fcr0) && !TCGV_EQUAL(ret, q_scale_type)))  {

        FF_THREAD_SLICE = ret;

    } else {

        FF_THREAD_SLICE = tcg_temp_local_new();

    }



    if (aurb) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (backing_file_str) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (htab_mask) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(FF_THREAD_SLICE, CP1_fcr0, q_scale_type);



    if (backing_file_str) {

        gen_op_arith_compute_ca(temps, FF_THREAD_SLICE, CP1_fcr0, 0);

    }

    if (aurb) {

        tcg_gen_add_tl(FF_THREAD_SLICE, FF_THREAD_SLICE, t1);

        gen_op_arith_compute_ca(temps, FF_THREAD_SLICE, t1, 0);

        tcg_temp_free(t1);

    }

    if (htab_mask) {

        gen_op_arith_compute_ov(temps, FF_THREAD_SLICE, CP1_fcr0, q_scale_type, 0);

    }



    if (unlikely(Rc(temps->opcode) != 0))

        gen_set_Rc0(temps, FF_THREAD_SLICE);



    if (!TCGV_EQUAL(FF_THREAD_SLICE, ret)) {

        tcg_gen_mov_tl(ret, FF_THREAD_SLICE);

        tcg_temp_free(FF_THREAD_SLICE);

    }

}
",1,1,0,1,arg1,-0.6989635825157166,7,39,"{'add_ca': 'aurb', 'compute_ca': 'backing_file_str', 't0': 'FF_THREAD_SLICE', 'arg1': 'CP1_fcr0', 'arg2': 'q_scale_type', 'ctx': 'temps', 'compute_ov': 'htab_mask'}",MHM-Origin,249,0.1151339848836263
141,"static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t*)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_end = end - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%mm0    \n\t""

            ""punpcklwd     %5, %%mm1    \n\t""

            ""punpcklwd     %5, %%mm2    \n\t""

            ""punpckhwd     %5, %%mm3    \n\t""

            ""punpckhwd     %5, %%mm4    \n\t""

            ""punpckhwd     %5, %%mm5    \n\t""

            ""psllq         $8, %%mm1    \n\t""

            ""psllq        $16, %%mm2    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""psllq         $8, %%mm4    \n\t""

            ""psllq        $16, %%mm5    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm5, %%mm3    \n\t""



            ""movq       %%mm0, %%mm6    \n\t""

            ""movq       %%mm3, %%mm7    \n\t""



            ""movq         8%1, %%mm0    \n\t""

            ""movq         8%1, %%mm1    \n\t""

            ""movq         8%1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%mm0    \n\t""

            ""punpcklwd     %5, %%mm1    \n\t""

            ""punpcklwd     %5, %%mm2    \n\t""

            ""punpckhwd     %5, %%mm3    \n\t""

            ""punpckhwd     %5, %%mm4    \n\t""

            ""punpckhwd     %5, %%mm5    \n\t""

            ""psllq         $8, %%mm1    \n\t""

            ""psllq        $16, %%mm2    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""psllq         $8, %%mm4    \n\t""

            ""psllq        $16, %%mm5    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm5, %%mm3    \n\t""



            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r), ""m""(mmx_null)

            :""memory"");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            ""movq       %%mm0, %%mm4    \n\t""

            ""movq       %%mm3, %%mm5    \n\t""

            ""movq       %%mm6, %%mm0    \n\t""

            ""movq       %%mm7, %%mm1    \n\t""



            ""movq       %%mm4, %%mm6    \n\t""

            ""movq       %%mm5, %%mm7    \n\t""

            ""movq       %%mm0, %%mm2    \n\t""

            ""movq       %%mm1, %%mm3    \n\t""



            STORE_BGR24_MMX



            :""=m""(*d)

            :""m""(*s)

            :""memory"");

        d += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

    }

}
",512,"static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *omap_gpio_init;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t*)src;

    omap_gpio_init = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_end = omap_gpio_init - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movq          %1, %%mm0    
\t""

            ""movq          %1, %%mm1    
\t""

            ""movq          %1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            ""movq       %%mm0, %%mm3    
\t""

            ""movq       %%mm1, %%mm4    
\t""

            ""movq       %%mm2, %%mm5    
\t""

            ""punpcklwd     %5, %%mm0    
\t""

            ""punpcklwd     %5, %%mm1    
\t""

            ""punpcklwd     %5, %%mm2    
\t""

            ""punpckhwd     %5, %%mm3    
\t""

            ""punpckhwd     %5, %%mm4    
\t""

            ""punpckhwd     %5, %%mm5    
\t""

            ""psllq         $8, %%mm1    
\t""

            ""psllq        $16, %%mm2    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""psllq         $8, %%mm4    
\t""

            ""psllq        $16, %%mm5    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm5, %%mm3    
\t""



            ""movq       %%mm0, %%mm6    
\t""

            ""movq       %%mm3, %%mm7    
\t""



            ""movq         8%1, %%mm0    
\t""

            ""movq         8%1, %%mm1    
\t""

            ""movq         8%1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            ""movq       %%mm0, %%mm3    
\t""

            ""movq       %%mm1, %%mm4    
\t""

            ""movq       %%mm2, %%mm5    
\t""

            ""punpcklwd     %5, %%mm0    
\t""

            ""punpcklwd     %5, %%mm1    
\t""

            ""punpcklwd     %5, %%mm2    
\t""

            ""punpckhwd     %5, %%mm3    
\t""

            ""punpckhwd     %5, %%mm4    
\t""

            ""punpckhwd     %5, %%mm5    
\t""

            ""psllq         $8, %%mm1    
\t""

            ""psllq        $16, %%mm2    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""psllq         $8, %%mm4    
\t""

            ""psllq        $16, %%mm5    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm5, %%mm3    
\t""



            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r), ""m""(mmx_null)

            :""memory"");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            ""movq       %%mm0, %%mm4    
\t""

            ""movq       %%mm3, %%mm5    
\t""

            ""movq       %%mm6, %%mm0    
\t""

            ""movq       %%mm7, %%mm1    
\t""



            ""movq       %%mm4, %%mm6    
\t""

            ""movq       %%mm5, %%mm7    
\t""

            ""movq       %%mm0, %%mm2    
\t""

            ""movq       %%mm1, %%mm3    
\t""



            STORE_BGR24_MMX



            :""=m""(*d)

            :""m""(*s)

            :""memory"");

        d += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < omap_gpio_init) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

    }

}
",1,1,0,1,end,-0.823220506310463,1,4,{'end': 'omap_gpio_init'},MHM-Origin,42,0.01980650027592977
143,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
",114,"static int ftp_file_size(FTPContext *venc)

{

    char backing_file_offset[CONTROL_BUFFER_SIZE];

    char *PCI_COMMAND_MEMORY = NULL;

    const int BDRVSheepdogState[] = {213, 0};



    snprintf(backing_file_offset, sizeof(backing_file_offset), ""SIZE %s\r
"", venc->path);

    if (ftp_send_command(venc, backing_file_offset, BDRVSheepdogState, &PCI_COMMAND_MEMORY)) {

        venc->filesize = strtoll(&PCI_COMMAND_MEMORY[4], NULL, 10);

    } else {

        venc->filesize = -1;

        av_free(PCI_COMMAND_MEMORY);

        return AVERROR(EIO);

    }



    av_free(PCI_COMMAND_MEMORY);

    return 0;

}
",0,0,0,-1,s,-0.0006725843995809555,4,16,"{'s': 'venc', 'command': 'backing_file_offset', 'size_codes': 'BDRVSheepdogState', 'res': 'PCI_COMMAND_MEMORY'}",MHM-Origin,396,0.17111332416534425
146," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }



    tlb_flush(s, 1);

}
",85," void cpu_sh4_invalidate_tlb(CPUSH4State *top)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &top->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &top->utlb[i];

        entry->v = 0;

    }



    tlb_flush(top, 1);

}
",0,0,1,1,s,0.3075059503316879,1,4,{'s': 'top'},MHM-Origin,22,0.010676074028015136
147,"uint16_t net_checksum_finish(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}
",32,"uint16_t net_checksum_finish(uint32_t nextchr)

{

    while (nextchr>>16)

	nextchr = (nextchr & 0xFFFF)+(nextchr >> 16);

    return ~nextchr;

}
",0,0,0,-1,sum,-0.010589438490569592,1,6,{'sum': 'nextchr'},MHM-Origin,391,0.2029913345972697
148,"static void pci_init_mask_bridge(PCIDevice *d)

{

    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and

       PCI_SEC_LETENCY_TIMER */

    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);



    /* base and limit */

    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;

    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;

    pci_set_word(d->wmask + PCI_MEMORY_BASE,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,

                 PCI_PREF_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,

                 PCI_PREF_RANGE_MASK & 0xffff);



    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */

    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);



    /* Supported memory and i/o types */

    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;

    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;

    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_64);

    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_64);



/* TODO: add this define to pci_regs.h in linux and then in qemu. */

#define  PCI_BRIDGE_CTL_VGA_16BIT	0x10	/* VGA 16-bit decode */

#define  PCI_BRIDGE_CTL_DISCARD		0x100	/* Primary discard timer */

#define  PCI_BRIDGE_CTL_SEC_DISCARD	0x200	/* Secondary discard timer */

#define  PCI_BRIDGE_CTL_DISCARD_STATUS	0x400	/* Discard timer status */

#define  PCI_BRIDGE_CTL_DISCARD_SERR	0x800	/* Discard timer SERR# enable */

/*

 * TODO: Bridges default to 10-bit VGA decoding but we currently only

 * implement 16-bit decoding (no alias support).

 */

    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_PARITY |

                 PCI_BRIDGE_CTL_SERR |

                 PCI_BRIDGE_CTL_ISA |

                 PCI_BRIDGE_CTL_VGA |

                 PCI_BRIDGE_CTL_VGA_16BIT |

                 PCI_BRIDGE_CTL_MASTER_ABORT |

                 PCI_BRIDGE_CTL_BUS_RESET |

                 PCI_BRIDGE_CTL_FAST_BACK |

                 PCI_BRIDGE_CTL_DISCARD |

                 PCI_BRIDGE_CTL_SEC_DISCARD |

                 PCI_BRIDGE_CTL_DISCARD_SERR);

    /* Below does not do anything as we never set this bit, put here for

     * completeness. */

    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_DISCARD_STATUS);

    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;

    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;

    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_MASK);

    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_MASK);

}
",247,"static void pci_init_mask_bridge(PCIDevice *test_cases)

{

    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and

       PCI_SEC_LETENCY_TIMER */

    memset(test_cases->wmask + PCI_PRIMARY_BUS, 0xff, 4);



    /* base and limit */

    test_cases->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;

    test_cases->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;

    pci_set_word(test_cases->wmask + PCI_MEMORY_BASE,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(test_cases->wmask + PCI_MEMORY_LIMIT,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(test_cases->wmask + PCI_PREF_MEMORY_BASE,

                 PCI_PREF_RANGE_MASK & 0xffff);

    pci_set_word(test_cases->wmask + PCI_PREF_MEMORY_LIMIT,

                 PCI_PREF_RANGE_MASK & 0xffff);



    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */

    memset(test_cases->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);



    /* Supported memory and i/o types */

    test_cases->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;

    test_cases->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;

    pci_word_test_and_set_mask(test_cases->config + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_64);

    pci_word_test_and_set_mask(test_cases->config + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_64);



/* TODO: add this define to pci_regs.h in linux and then in qemu. */

#define  PCI_BRIDGE_CTL_VGA_16BIT	0x10	/* VGA 16-bit decode */

#define  PCI_BRIDGE_CTL_DISCARD		0x100	/* Primary discard timer */

#define  PCI_BRIDGE_CTL_SEC_DISCARD	0x200	/* Secondary discard timer */

#define  PCI_BRIDGE_CTL_DISCARD_STATUS	0x400	/* Discard timer status */

#define  PCI_BRIDGE_CTL_DISCARD_SERR	0x800	/* Discard timer SERR# enable */

/*

 * TODO: Bridges default to 10-bit VGA decoding but we currently only

 * implement 16-bit decoding (no alias support).

 */

    pci_set_word(test_cases->wmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_PARITY |

                 PCI_BRIDGE_CTL_SERR |

                 PCI_BRIDGE_CTL_ISA |

                 PCI_BRIDGE_CTL_VGA |

                 PCI_BRIDGE_CTL_VGA_16BIT |

                 PCI_BRIDGE_CTL_MASTER_ABORT |

                 PCI_BRIDGE_CTL_BUS_RESET |

                 PCI_BRIDGE_CTL_FAST_BACK |

                 PCI_BRIDGE_CTL_DISCARD |

                 PCI_BRIDGE_CTL_SEC_DISCARD |

                 PCI_BRIDGE_CTL_DISCARD_SERR);

    /* Below does not do anything as we never set this bit, put here for

     * completeness. */

    pci_set_word(test_cases->w1cmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_DISCARD_STATUS);

    test_cases->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;

    test_cases->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;

    pci_word_test_and_set_mask(test_cases->cmask + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_MASK);

    pci_word_test_and_set_mask(test_cases->cmask + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_MASK);

}
",0,0,0,-1,d,-0.07266699895262718,1,19,{'d': 'QEMU_FILE_TYPE_BIOS'},MHM-Origin,389,0.2211164156595866
150,"static void gpollfds_from_select(void)

{

    int fd;

    for (fd = 0; fd <= nfds; fd++) {

        int events = 0;

        if (FD_ISSET(fd, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(fd, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(fd, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .fd = fd,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",114,"static void gpollfds_from_select(void)

{

    int top_field_first;

    for (top_field_first = 0; top_field_first <= nfds; top_field_first++) {

        int events = 0;

        if (FD_ISSET(top_field_first, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(top_field_first, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(top_field_first, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .top_field_first = top_field_first,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",0,0,0,-1,fd,-0.028442087583243847,1,9,{'fd': 'top_field_first'},MHM-Origin,391,0.1734637220700582
151,"static int decode_frame(AVCodecContext *avctx,

                        void *data, int *got_frame, AVPacket *avpkt)

{

    TiffContext *const s = avctx->priv_data;

    AVFrame *const p = data;

    ThreadFrame frame = { .f = data };

    unsigned off;

    int le, ret, plane, planes;

    int i, j, entries, stride;

    unsigned soff, ssize;

    uint8_t *dst;

    GetByteContext stripsizes;

    GetByteContext stripdata;



    bytestream2_init(&s->gb, avpkt->data, avpkt->size);



    // parse image header

    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header\n"");

        return ret;

    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {

        av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size\n"");

        return AVERROR_INVALIDDATA;

    }

    s->le          = le;

    // TIFF_BPP is not a required tag and defaults to 1

    s->bppcount    = s->bpp = 1;

    s->photometric = TIFF_PHOTOMETRIC_NONE;

    s->compr       = TIFF_RAW;

    s->fill_order  = 0;

    free_geotags(s);



    // Reset these offsets so we can tell if they were set this frame

    s->stripsizesoff = s->strippos = 0;

    /* parse image file directory */

    bytestream2_seek(&s->gb, off, SEEK_SET);

    entries = ff_tget_short(&s->gb, le);

    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)

        return AVERROR_INVALIDDATA;

    for (i = 0; i < entries; i++) {

        if ((ret = tiff_decode_tag(s, p)) < 0)

            return ret;

    }



    for (i = 0; i<s->geotag_count; i++) {

        const char *keyname = get_geokey_name(s->geotags[i].key);

        if (!keyname) {

            av_log(avctx, AV_LOG_WARNING, ""Unknown or unsupported GeoTIFF key %d\n"", s->geotags[i].key);

            continue;

        }

        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {

            av_log(avctx, AV_LOG_WARNING, ""Type of GeoTIFF key %d is wrong\n"", s->geotags[i].key);

            continue;

        }

        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);

        if (ret<0) {

            av_log(avctx, AV_LOG_ERROR, ""Writing metadata with key '%s' failed\n"", keyname);

            return ret;

        }

    }



    if (!s->strippos && !s->stripoff) {

        av_log(avctx, AV_LOG_ERROR, ""Image data is missing\n"");

        return AVERROR_INVALIDDATA;

    }

    /* now we have the data and may start decoding */

    if ((ret = init_image(s, &frame)) < 0)

        return ret;



    if (s->strips == 1 && !s->stripsize) {

        av_log(avctx, AV_LOG_WARNING, ""Image data size missing\n"");

        s->stripsize = avpkt->size - s->stripoff;

    }



    if (s->stripsizesoff) {

        if (s->stripsizesoff >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,

                         avpkt->size - s->stripsizesoff);

    }

    if (s->strippos) {

        if (s->strippos >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripdata, avpkt->data + s->strippos,

                         avpkt->size - s->strippos);

    }



    if (s->rps <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""rps %d invalid\n"", s->rps);

        return AVERROR_INVALIDDATA;

    }



    planes = s->planar ? s->bppcount : 1;

    for (plane = 0; plane < planes; plane++) {

        stride = p->linesize[plane];

        dst = p->data[plane];

        for (i = 0; i < s->height; i += s->rps) {

            if (s->stripsizesoff)

                ssize = ff_tget(&stripsizes, s->sstype, le);

            else

                ssize = s->stripsize;



            if (s->strippos)

                soff = ff_tget(&stripdata, s->sot, le);

            else

                soff = s->stripoff;



            if (soff > avpkt->size || ssize > avpkt->size - soff) {

                av_log(avctx, AV_LOG_ERROR, ""Invalid strip size/offset\n"");

                return AVERROR_INVALIDDATA;

            }

            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,

                                         FFMIN(s->rps, s->height - i))) < 0) {

                if (avctx->err_recognition & AV_EF_EXPLODE)

                    return ret;

                break;

            }

            dst += s->rps * stride;

        }

        if (s->predictor == 2) {

            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {

                av_log(s->avctx, AV_LOG_ERROR, ""predictor == 2 with YUV is unsupported"");

                return AVERROR_PATCHWELCOME;

            }

            dst   = p->data[plane];

            soff  = s->bpp >> 3;

            if (s->planar)

                soff  = FFMAX(soff / s->bppcount, 1);

            ssize = s->width * soff;

            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));

                    dst += stride;

                }

            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));

                    dst += stride;

                }

            } else {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j++)

                        dst[j] += dst[j - soff];

                    dst += stride;

                }

            }

        }



        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {

            dst = p->data[plane];

            for (i = 0; i < s->height; i++) {

                for (j = 0; j < stride; j++)

                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];

                dst += stride;

            }

        }

    }



    if (s->planar && s->bppcount > 2) {

        FFSWAP(uint8_t*, p->data[0],     p->data[2]);

        FFSWAP(int,      p->linesize[0], p->linesize[2]);

        FFSWAP(uint8_t*, p->data[0],     p->data[1]);

        FFSWAP(int,      p->linesize[0], p->linesize[1]);

    }



    *got_frame = 1;



    return avpkt->size;

}
",1407,"static int decode_frame(AVCodecContext *avctx,

                        void *data, int *got_frame, AVPacket *avpkt)

{

    TiffContext *const s = avctx->priv_data;

    AVFrame *const p = data;

    ThreadFrame frame = { .f = data };

    unsigned off;

    int le, ret, plane, planes;

    int i, j, entries, stride;

    unsigned MSR_MTRRfix16K_80000, ssize;

    uint8_t *dst;

    GetByteContext stripsizes;

    GetByteContext stripdata;



    bytestream2_init(&s->gb, avpkt->data, avpkt->size);



    // parse image header

    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header
"");

        return ret;

    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {

        av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size
"");

        return AVERROR_INVALIDDATA;

    }

    s->le          = le;

    // TIFF_BPP is not a required tag and defaults to 1

    s->bppcount    = s->bpp = 1;

    s->photometric = TIFF_PHOTOMETRIC_NONE;

    s->compr       = TIFF_RAW;

    s->fill_order  = 0;

    free_geotags(s);



    // Reset these offsets so we can tell if they were set this frame

    s->stripsizesoff = s->strippos = 0;

    /* parse image file directory */

    bytestream2_seek(&s->gb, off, SEEK_SET);

    entries = ff_tget_short(&s->gb, le);

    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)

        return AVERROR_INVALIDDATA;

    for (i = 0; i < entries; i++) {

        if ((ret = tiff_decode_tag(s, p)) < 0)

            return ret;

    }



    for (i = 0; i<s->geotag_count; i++) {

        const char *keyname = get_geokey_name(s->geotags[i].key);

        if (!keyname) {

            av_log(avctx, AV_LOG_WARNING, ""Unknown or unsupported GeoTIFF key %d
"", s->geotags[i].key);

            continue;

        }

        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {

            av_log(avctx, AV_LOG_WARNING, ""Type of GeoTIFF key %d is wrong
"", s->geotags[i].key);

            continue;

        }

        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);

        if (ret<0) {

            av_log(avctx, AV_LOG_ERROR, ""Writing metadata with key '%s' failed
"", keyname);

            return ret;

        }

    }



    if (!s->strippos && !s->stripoff) {

        av_log(avctx, AV_LOG_ERROR, ""Image data is missing
"");

        return AVERROR_INVALIDDATA;

    }

    /* now we have the data and may start decoding */

    if ((ret = init_image(s, &frame)) < 0)

        return ret;



    if (s->strips == 1 && !s->stripsize) {

        av_log(avctx, AV_LOG_WARNING, ""Image data size missing
"");

        s->stripsize = avpkt->size - s->stripoff;

    }



    if (s->stripsizesoff) {

        if (s->stripsizesoff >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,

                         avpkt->size - s->stripsizesoff);

    }

    if (s->strippos) {

        if (s->strippos >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripdata, avpkt->data + s->strippos,

                         avpkt->size - s->strippos);

    }



    if (s->rps <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""rps %d invalid
"", s->rps);

        return AVERROR_INVALIDDATA;

    }



    planes = s->planar ? s->bppcount : 1;

    for (plane = 0; plane < planes; plane++) {

        stride = p->linesize[plane];

        dst = p->data[plane];

        for (i = 0; i < s->height; i += s->rps) {

            if (s->stripsizesoff)

                ssize = ff_tget(&stripsizes, s->sstype, le);

            else

                ssize = s->stripsize;



            if (s->strippos)

                MSR_MTRRfix16K_80000 = ff_tget(&stripdata, s->sot, le);

            else

                MSR_MTRRfix16K_80000 = s->stripoff;



            if (MSR_MTRRfix16K_80000 > avpkt->size || ssize > avpkt->size - MSR_MTRRfix16K_80000) {

                av_log(avctx, AV_LOG_ERROR, ""Invalid strip size/offset
"");

                return AVERROR_INVALIDDATA;

            }

            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + MSR_MTRRfix16K_80000, ssize, i,

                                         FFMIN(s->rps, s->height - i))) < 0) {

                if (avctx->err_recognition & AV_EF_EXPLODE)

                    return ret;

                break;

            }

            dst += s->rps * stride;

        }

        if (s->predictor == 2) {

            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {

                av_log(s->avctx, AV_LOG_ERROR, ""predictor == 2 with YUV is unsupported"");

                return AVERROR_PATCHWELCOME;

            }

            dst   = p->data[plane];

            MSR_MTRRfix16K_80000  = s->bpp >> 3;

            if (s->planar)

                MSR_MTRRfix16K_80000  = FFMAX(MSR_MTRRfix16K_80000 / s->bppcount, 1);

            ssize = s->width * MSR_MTRRfix16K_80000;

            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {

                for (i = 0; i < s->height; i++) {

                    for (j = MSR_MTRRfix16K_80000; j < ssize; j += 2)

                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - MSR_MTRRfix16K_80000));

                    dst += stride;

                }

            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {

                for (i = 0; i < s->height; i++) {

                    for (j = MSR_MTRRfix16K_80000; j < ssize; j += 2)

                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - MSR_MTRRfix16K_80000));

                    dst += stride;

                }

            } else {

                for (i = 0; i < s->height; i++) {

                    for (j = MSR_MTRRfix16K_80000; j < ssize; j++)

                        dst[j] += dst[j - MSR_MTRRfix16K_80000];

                    dst += stride;

                }

            }

        }



        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {

            dst = p->data[plane];

            for (i = 0; i < s->height; i++) {

                for (j = 0; j < stride; j++)

                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];

                dst += stride;

            }

        }

    }



    if (s->planar && s->bppcount > 2) {

        FFSWAP(uint8_t*, p->data[0],     p->data[2]);

        FFSWAP(int,      p->linesize[0], p->linesize[2]);

        FFSWAP(uint8_t*, p->data[0],     p->data[1]);

        FFSWAP(int,      p->linesize[0], p->linesize[1]);

    }



    *got_frame = 1;



    return avpkt->size;

}
",0,0,1,1,soff,0.17679131031036377,1,16,{'soff': 'MSR_MTRRfix16K_80000'},MHM-Origin,19,0.011221965154012045
153,"static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,

                                      MegasasCmd *cmd)

{

    struct mfi_pd_info *info = cmd->iov_buf;

    size_t dcmd_size = sizeof(struct mfi_pd_info);

    uint64_t pd_size;

    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);

    uint8_t cmdbuf[6];

    SCSIRequest *req;

    size_t len, resid;



    if (!cmd->iov_buf) {

        cmd->iov_buf = g_malloc0(dcmd_size);

        info = cmd->iov_buf;

        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */

        info->vpd_page83[0] = 0x7f;

        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info std inquiry"");

            g_free(cmd->iov_buf);

            cmd->iov_buf = NULL;

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info std inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {

        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info vpd inquiry"");

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info vpd inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    }

    /* Finished, set FW state */

    if ((info->inquiry_data[0] >> 5) == 0) {

        if (megasas_is_jbod(cmd->state)) {

            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);

        } else {

            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);

        }

    } else {

        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);

    }



    info->ref.v.device_id = cpu_to_le16(pd_id);

    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|

                                          MFI_PD_DDF_TYPE_INTF_SAS);

    blk_get_geometry(sdev->conf.blk, &pd_size);

    info->raw_size = cpu_to_le64(pd_size);

    info->non_coerced_size = cpu_to_le64(pd_size);

    info->coerced_size = cpu_to_le64(pd_size);

    info->encl_device_id = 0xFFFF;

    info->slot_number = (sdev->id & 0xFF);

    info->path_info.count = 1;

    info->path_info.sas_addr[0] =

        cpu_to_le64(megasas_get_sata_addr(pd_id));

    info->connected_port_bitmap = 0x1;

    info->device_speed = 1;

    info->link_speed = 1;

    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);

    g_free(cmd->iov_buf);

    cmd->iov_size = dcmd_size - resid;

    cmd->iov_buf = NULL;

    return MFI_STAT_OK;

}
",569,"static int megasas_pd_get_info_submit(SCSIDevice *PNGDecContext, int lun,

                                      MegasasCmd *cmd)

{

    struct mfi_pd_info *info = cmd->iov_buf;

    size_t dcmd_size = sizeof(struct mfi_pd_info);

    uint64_t BLK_PERM_CONSISTENT_READ;

    uint16_t pd_id = ((PNGDecContext->id & 0xFF) << 8) | (lun & 0xFF);

    uint8_t cmdbuf[6];

    SCSIRequest *sig;

    size_t QEMUFile, free_inout;



    if (!cmd->iov_buf) {

        cmd->iov_buf = g_malloc0(dcmd_size);

        info = cmd->iov_buf;

        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */

        info->vpd_page83[0] = 0x7f;

        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));

        sig = scsi_req_new(PNGDecContext, cmd->index, lun, cmdbuf, cmd);

        if (!sig) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info std inquiry"");

            g_free(cmd->iov_buf);

            cmd->iov_buf = NULL;

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info std inquiry"", lun);

        QEMUFile = scsi_req_enqueue(sig);

        if (QEMUFile > 0) {

            cmd->iov_size = QEMUFile;

            scsi_req_continue(sig);

        }

        return MFI_STAT_INVALID_STATUS;

    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {

        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));

        sig = scsi_req_new(PNGDecContext, cmd->index, lun, cmdbuf, cmd);

        if (!sig) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info vpd inquiry"");

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info vpd inquiry"", lun);

        QEMUFile = scsi_req_enqueue(sig);

        if (QEMUFile > 0) {

            cmd->iov_size = QEMUFile;

            scsi_req_continue(sig);

        }

        return MFI_STAT_INVALID_STATUS;

    }

    /* Finished, set FW state */

    if ((info->inquiry_data[0] >> 5) == 0) {

        if (megasas_is_jbod(cmd->state)) {

            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);

        } else {

            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);

        }

    } else {

        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);

    }



    info->ref.v.device_id = cpu_to_le16(pd_id);

    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|

                                          MFI_PD_DDF_TYPE_INTF_SAS);

    blk_get_geometry(PNGDecContext->conf.blk, &BLK_PERM_CONSISTENT_READ);

    info->raw_size = cpu_to_le64(BLK_PERM_CONSISTENT_READ);

    info->non_coerced_size = cpu_to_le64(BLK_PERM_CONSISTENT_READ);

    info->coerced_size = cpu_to_le64(BLK_PERM_CONSISTENT_READ);

    info->encl_device_id = 0xFFFF;

    info->slot_number = (PNGDecContext->id & 0xFF);

    info->path_info.count = 1;

    info->path_info.sas_addr[0] =

        cpu_to_le64(megasas_get_sata_addr(pd_id));

    info->connected_port_bitmap = 0x1;

    info->device_speed = 1;

    info->link_speed = 1;

    free_inout = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);

    g_free(cmd->iov_buf);

    cmd->iov_size = dcmd_size - free_inout;

    cmd->iov_buf = NULL;

    return MFI_STAT_OK;

}
",1,1,0,1,pd_size,-0.1827060580253601,5,30,"{'sdev': 'PNGDecContext', 'resid': 'free_inout', 'len': 'QEMUFile', 'req': 'sig', 'pd_size': 'BLK_PERM_CONSISTENT_READ'}",MHM-Origin,101,0.05130760272343953
154,"static void gen_isel(DisasContext *ctx)

{

    int l1, l2;

    uint32_t bi = rC(ctx->opcode);

    uint32_t mask;

    TCGv_i32 t0;



    l1 = gen_new_label();

    l2 = gen_new_label();



    mask = 0x08 >> (bi & 0x03);

    t0 = tcg_temp_new_i32();

    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    if (rA(ctx->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);

    gen_set_label(l2);

    tcg_temp_free_i32(t0);

}
",177,"static void gen_isel(DisasContext *sye)

{

    int enc, QCowHeader;

    uint32_t bi = rC(sye->opcode);

    uint32_t decode_plte_chunk;

    TCGv_i32 AVMEDIA_TYPE_AUDIO;



    enc = gen_new_label();

    QCowHeader = gen_new_label();



    decode_plte_chunk = 0x08 >> (bi & 0x03);

    AVMEDIA_TYPE_AUDIO = tcg_temp_new_i32();

    tcg_gen_andi_i32(AVMEDIA_TYPE_AUDIO, cpu_crf[bi >> 2], decode_plte_chunk);

    tcg_gen_brcondi_i32(TCG_COND_EQ, AVMEDIA_TYPE_AUDIO, 0, enc);

    if (rA(sye->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(sye->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(sye->opcode)], cpu_gpr[rA(sye->opcode)]);

    tcg_gen_br(QCowHeader);

    gen_set_label(enc);

    tcg_gen_mov_tl(cpu_gpr[rD(sye->opcode)], cpu_gpr[rB(sye->opcode)]);

    gen_set_label(QCowHeader);

    tcg_temp_free_i32(AVMEDIA_TYPE_AUDIO);

}
",0,0,1,1,l1,0.4859090745449066,5,24,"{'mask': 'decode_plte_chunk', 'ctx': 'sye', 't0': 'AVMEDIA_TYPE_AUDIO', 'l2': 'QCowHeader', 'l1': 'enc'}",MHM-Origin,329,0.15122183561325073
155,"static void stream_process_mem2s(struct Stream *s,

                                 StreamSlave *tx_dev)

{

    uint32_t prev_d;

    unsigned char txbuf[16 * 1024];

    unsigned int txlen;

    uint32_t app[6];



    if (!stream_running(s) || stream_idle(s)) {

        return;

    }



    while (1) {

        stream_desc_load(s, s->regs[R_CURDESC]);



        if (s->desc.status & SDESC_STATUS_COMPLETE) {

            s->regs[R_DMASR] |= DMASR_HALTED;

            break;

        }



        if (stream_desc_sof(&s->desc)) {

            s->pos = 0;

            memcpy(app, s->desc.app, sizeof app);

        }



        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;

        if ((txlen + s->pos) > sizeof txbuf) {

            hw_error(""%s: too small internal txbuf! %d\n"", __func__,

                     txlen + s->pos);

        }



        cpu_physical_memory_read(s->desc.buffer_address,

                                 txbuf + s->pos, txlen);

        s->pos += txlen;



        if (stream_desc_eof(&s->desc)) {

            stream_push(tx_dev, txbuf, s->pos, app);

            s->pos = 0;

            stream_complete(s);

        }



        /* Update the descriptor.  */

        s->desc.status = txlen | SDESC_STATUS_COMPLETE;

        stream_desc_store(s, s->regs[R_CURDESC]);



        /* Advance.  */

        prev_d = s->regs[R_CURDESC];

        s->regs[R_CURDESC] = s->desc.nxtdesc;

        if (prev_d == s->regs[R_TAILDESC]) {

            s->regs[R_DMASR] |= DMASR_IDLE;

            break;

        }

    }

}
",294,"static void stream_process_mem2s(struct Stream *s,

                                 StreamSlave *MSR_MTRRfix4K_F0000)

{

    uint32_t max_ws_len;

    unsigned char vert_out0[16 * 1024];

    unsigned int VM_MASK;

    uint32_t app[6];



    if (!stream_running(s) || stream_idle(s)) {

        return;

    }



    while (1) {

        stream_desc_load(s, s->regs[R_CURDESC]);



        if (s->desc.status & SDESC_STATUS_COMPLETE) {

            s->regs[R_DMASR] |= DMASR_HALTED;

            break;

        }



        if (stream_desc_sof(&s->desc)) {

            s->pos = 0;

            memcpy(app, s->desc.app, sizeof app);

        }



        VM_MASK = s->desc.control & SDESC_CTRL_LEN_MASK;

        if ((VM_MASK + s->pos) > sizeof vert_out0) {

            hw_error(""%s: too small internal txbuf! %d
"", __func__,

                     VM_MASK + s->pos);

        }



        cpu_physical_memory_read(s->desc.buffer_address,

                                 vert_out0 + s->pos, VM_MASK);

        s->pos += VM_MASK;



        if (stream_desc_eof(&s->desc)) {

            stream_push(MSR_MTRRfix4K_F0000, vert_out0, s->pos, app);

            s->pos = 0;

            stream_complete(s);

        }



        /* Update the descriptor.  */

        s->desc.status = VM_MASK | SDESC_STATUS_COMPLETE;

        stream_desc_store(s, s->regs[R_CURDESC]);



        /* Advance.  */

        max_ws_len = s->regs[R_CURDESC];

        s->regs[R_CURDESC] = s->desc.nxtdesc;

        if (max_ws_len == s->regs[R_TAILDESC]) {

            s->regs[R_DMASR] |= DMASR_IDLE;

            break;

        }

    }

}
",0,0,1,1,tx_dev,0.557571604847908,4,16,"{'tx_dev': 'MSR_MTRRfix4K_F0000', 'txbuf': 'vert_out0', 'prev_d': 'max_ws_len', 'txlen': 'VM_MASK'}",MHM-Origin,159,0.07471419970194498
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",84,"static void test_qemu_strtoll_whitespace(void)

{

    const char *timer1_irq = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(timer1_irq, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == timer1_irq);

}
",1,1,0,1,str,-0.16700884699821472,1,3,{'str': 'timer1_irq'},MHM-Origin,23,0.00809326966603597
161,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!tso_enable) {

        goto func_exit;

    }



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:

    return rc;

}
",80,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *HV_X64_MSR_SCONTROL,

                                          bool INT_MAX)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t ebml_header;



    ebml_header = eth_get_l3_proto(HV_X64_MSR_SCONTROL->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        HV_X64_MSR_SCONTROL->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!INT_MAX) {

        goto func_exit;

    }



    rc = eth_get_gso_type(ebml_header, HV_X64_MSR_SCONTROL->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          HV_X64_MSR_SCONTROL->l4proto);



func_exit:

    return rc;

}
",0,0,0,-1,tso_enable,-0.09980715811252594,3,10,"{'tso_enable': 'INT_MAX', 'pkt': 'HV_X64_MSR_SCONTROL', 'l3_proto': 'ebml_header'}",MHM-Origin,397,0.1700358192125956
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
",75,"int ff_schro_queue_push_back(FFSchroQueue *active_thread_type, void *tap_fd_get_ifname)

{

    FFSchroQueueElement *avpriv_set_pts_info = av_mallocz(sizeof(FFSchroQueueElement));



    if (!avpriv_set_pts_info)

        return -1;



    avpriv_set_pts_info->data = tap_fd_get_ifname;



    if (!active_thread_type->p_head)

        active_thread_type->p_head = avpriv_set_pts_info;

    else

        active_thread_type->p_tail->next = avpriv_set_pts_info;

    active_thread_type->p_tail = avpriv_set_pts_info;



    ++active_thread_type->long_ref;

    return 0;

}
",1,1,0,1,p_data,-0.8903351053595543,4,15,"{'queue': 'active_thread_type', 'size': 'long_ref', 'p_new': 'avpriv_set_pts_info', 'p_data': 'tap_fd_get_ifname'}",MHM-Origin,82,0.033752934137980146
165,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    unsigned int offset, w, h, y, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_pixel = AV_RL16(buf+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.\n"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c\n"");



    buf += offset;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, p) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*bytes_per_pixel);

#endif

        ptr += stride;

        buf += w*bytes_per_pixel;

    }



    *picture = s->picture;

    *data_size = sizeof(AVPicture);



    return offset + w*h*bytes_per_pixel;

}",384,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *phys_ram = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const tx_dev = &s->picture;

    unsigned int av_le2ne32, w, attachment_filename, PUSHQ, stride, bytes_per_pixel;

    uint8_t *ff_jpeg2000_ceildiv;





    av_le2ne32          = AV_RL16(phys_ram);

    w               = AV_RL16(phys_ram+8);

    attachment_filename               = AV_RL16(phys_ram+10);

    bytes_per_pixel = AV_RL16(phys_ram+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.
"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - phys_ram < av_le2ne32)


    if (av_le2ne32 != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c
"");



    phys_ram += av_le2ne32;



    if (tx_dev->data[0])

        avctx->release_buffer(avctx, tx_dev);



    if (av_image_check_size(w, attachment_filename, 0, avctx))

        return -1;

    if (w != avctx->width || attachment_filename != avctx->height)

        avcodec_set_dimensions(avctx, w, attachment_filename);

    if (avctx->get_buffer(avctx, tx_dev) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    tx_dev->pict_type = AV_PICTURE_TYPE_I;



    ff_jpeg2000_ceildiv    = tx_dev->data[0];

    stride = tx_dev->linesize[0];



    for (PUSHQ=0; PUSHQ<attachment_filename; PUSHQ++) {

        if (buf_end - phys_ram < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int md5_ctx;

        for (md5_ctx=0; md5_ctx<w*bytes_per_pixel; md5_ctx+=bytes_per_pixel)

            AV_WN16(ff_jpeg2000_ceildiv+md5_ctx, AV_RL16(phys_ram+md5_ctx));

#else

        memcpy(ff_jpeg2000_ceildiv, phys_ram, w*bytes_per_pixel);

#endif

        ff_jpeg2000_ceildiv += stride;

        phys_ram += w*bytes_per_pixel;

    }



    *picture = s->picture;

    *data_size = sizeof(AVPicture);



    return av_le2ne32 + w*attachment_filename*bytes_per_pixel;

}",1,1,0,1,buf,-0.2042723000049591,7,47,"{'ptr': 'ff_jpeg2000_ceildiv', 'x': 'md5_ctx', 'y': 'PUSHQ', 'h': 'attachment_filename', 'buf': 'phys_ram', 'p': 'tx_dev', 'offset': 'av_le2ne32'}",MHM-Origin,157,0.0718879222869873
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",49,"static void vpc_close(BlockDriverState *qobject_from_json)

{

    BDRVVPCState *s = qobject_from_json->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",1,1,0,1,bs,-0.3980487585067749,1,2,{'bs': 'qobject_from_json'},MHM-Origin,41,0.015864924589792887
168,"static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!s->pb->eof_reached) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", klv.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_system_item_key)) {

            if (!mxf->current_partition->essence_offset) {

                compute_partition_essence_offset(s, mxf, &klv);

            }



            if (!essence_offset)

                essence_offset = klv.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&

                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

        }



        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {

            if (IS_KLV_KEY(klv.key, metadata->key)) {

                int res;

                if (klv.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);

                } else {

                    uint64_t next = avio_tell(s->pb) + klv.length;

                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);

                    avio_seek(s->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(s, AV_LOG_ERROR, ""error reading header metadata\n"");

                    return res;

                }

                break;

            }

        }

        if (!metadata->read)

            avio_skip(s->pb, klv.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(s, AV_LOG_ERROR, ""no essence\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    return mxf_parse_structural_metadata(mxf);

}
",520,"static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket cpuid_vendor1;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key
"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!s->pb->eof_reached) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&cpuid_vendor1, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", cpuid_vendor1.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""
"", cpuid_vendor1.length, cpuid_vendor1.offset);

        if (IS_KLV_KEY(cpuid_vendor1.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(cpuid_vendor1.key, mxf_essence_element_key) ||

            IS_KLV_KEY(cpuid_vendor1.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(cpuid_vendor1.key, mxf_system_item_key)) {

            if (!mxf->current_partition->essence_offset) {

                compute_partition_essence_offset(s, mxf, &cpuid_vendor1);

            }



            if (!essence_offset)

                essence_offset = cpuid_vendor1.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(cpuid_vendor1.key, mxf_header_partition_pack_key, 13) &&

                   cpuid_vendor1.key[13] >= 2 && cpuid_vendor1.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

        }



        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {

            if (IS_KLV_KEY(cpuid_vendor1.key, metadata->key)) {

                int res;

                if (cpuid_vendor1.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &cpuid_vendor1, metadata->read, metadata->ctx_size, metadata->type);

                } else {

                    uint64_t next = avio_tell(s->pb) + cpuid_vendor1.length;

                    res = metadata->read(mxf, s->pb, 0, cpuid_vendor1.length, cpuid_vendor1.key, cpuid_vendor1.offset);

                    avio_seek(s->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(s, AV_LOG_ERROR, ""error reading header metadata
"");

                    return res;

                }

                break;

            }

        }

        if (!metadata->read)

            avio_skip(s->pb, cpuid_vendor1.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(s, AV_LOG_ERROR, ""no essence
"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    return mxf_parse_structural_metadata(mxf);

}
",1,1,0,1,klv,-0.17321860790252686,1,22,{'klv': 'cpuid_vendor1'},MHM-Origin,23,0.010693756739298503
169,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *img;
    int i;
    int sub_dx[4];
    int sub_dy[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    sub_dx[0] = sub_dx[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;
    numcomps = desc->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported\n"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = sub_dx[i];
        cmptparm[i].dy = sub_dy[i];
        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];
        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];
    }
    img = opj_image_create(numcomps, cmptparm, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    img->x0 = 0;
    img->y0 = 0;
    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;
    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;
    return img;
}",514,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *pfd)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *img;
    int i;
    int coroutine_fn[4];
    int sub_dy[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    coroutine_fn[0] = coroutine_fn[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    coroutine_fn[1] = coroutine_fn[2] = 1 << desc->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;
    numcomps = desc->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported
"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = coroutine_fn[i];
        cmptparm[i].dy = sub_dy[i];
        cmptparm[i].w = (avctx->width + coroutine_fn[i] - 1) / coroutine_fn[i];
        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];
    }
    img = opj_image_create(numcomps, cmptparm, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    img->x0 = 0;
    img->y0 = 0;
    img->x1 = (avctx->width  - 1) * pfd->subsampling_dx + 1;
    img->y1 = (avctx->height - 1) * pfd->subsampling_dy + 1;
    return img;
}",1,1,0,1,parameters,-0.32143163681030273,2,11,"{'sub_dx': 'coroutine_fn', 'parameters': 'pfd'}",MHM-Origin,40,0.019000295797983804
170,"static int xen_platform_initfn(PCIDevice *dev)

{

    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);

    uint8_t *pci_conf;



    pci_conf = d->pci_dev.config;



    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);



    pci_config_set_prog_interface(pci_conf, 0);



    pci_conf[PCI_INTERRUPT_PIN] = 1;



    pci_register_bar(&d->pci_dev, 0, 0x100,

            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);



    /* reserve 16MB mmio address for share memory*/

    pci_register_bar(&d->pci_dev, 1, 0x1000000,

            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);



    platform_fixed_ioport_init(d);



    return 0;

}
",100,"static int xen_platform_initfn(PCIDevice *QERR_INVALID_PARAMETER_VALUE)

{

    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, QERR_INVALID_PARAMETER_VALUE);

    uint8_t *band;



    band = d->pci_dev.config;



    pci_set_word(band + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);



    pci_config_set_prog_interface(band, 0);



    band[PCI_INTERRUPT_PIN] = 1;



    pci_register_bar(&d->pci_dev, 0, 0x100,

            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);



    /* reserve 16MB mmio address for share memory*/

    pci_register_bar(&d->pci_dev, 1, 0x1000000,

            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);



    platform_fixed_ioport_init(d);



    return 0;

}
",0,0,1,1,dev,0.7405168823897839,2,7,"{'pci_conf': 'band', 'dev': 'QERR_INVALID_PARAMETER_VALUE'}",MHM-Origin,159,0.0673355499903361
171,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *dir_path, const char *name, FsCred *credp)

{

    int retval;

    V9fsString fullname, target;



    v9fs_string_init(&fullname);

    v9fs_string_init(&target);



    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    v9fs_string_sprintf(&target, ""%s"", oldpath);



    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &target, &fullname, credp->fc_uid, credp->fc_gid);

    v9fs_string_free(&fullname);

    v9fs_string_free(&target);

    if (retval < 0) {

        errno = -retval;

        retval = -1;

    }

    return retval;

}
",139,"static int proxy_symlink(FsContext *rdma, const char *vhostfds,

                         V9fsPath *rv34_pred_mv, const char *ioba, FsCred *last_picture)

{

    int sub_dy;

    V9fsString CC_OP_SUBB, fdparam;



    v9fs_string_init(&CC_OP_SUBB);

    v9fs_string_init(&fdparam);



    v9fs_string_sprintf(&CC_OP_SUBB, ""%s/%s"", rv34_pred_mv->data, ioba);

    v9fs_string_sprintf(&fdparam, ""%s"", vhostfds);



    sub_dy = v9fs_request(rdma->private, T_SYMLINK, NULL, ""ssdd"",

                          &fdparam, &CC_OP_SUBB, last_picture->fc_uid, last_picture->fc_gid);

    v9fs_string_free(&CC_OP_SUBB);

    v9fs_string_free(&fdparam);

    if (sub_dy < 0) {

        errno = -sub_dy;

        sub_dy = -1;

    }

    return sub_dy;

}
",0,0,0,-1,target,-0.0047441935166716576,8,27,"{'credp': 'last_picture', 'fullname': 'CC_OP_SUBB', 'fs_ctx': 'rdma', 'oldpath': 'vhostfds', 'retval': 'sub_dy', 'name': 'ioba', 'dir_path': 'rv34_pred_mv', 'target': 'fdparam'}",MHM-Origin,400,0.1745036005973816
172,"static int vfio_enable_intx(VFIODevice *vdev)

{

    VFIOIRQSetFD irq_set_fd = {

        .irq_set = {

            .argsz = sizeof(irq_set_fd),

            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,

            .index = VFIO_PCI_INTX_IRQ_INDEX,

            .start = 0,

            .count = 1,

        },

    };

    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);

    int ret;



    if (vdev->intx.disabled || !pin) {

        return 0;

    }



    vfio_disable_interrupts(vdev);



    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */

    ret = event_notifier_init(&vdev->intx.interrupt, 0);

    if (ret) {

        error_report(""vfio: Error: event_notifier_init failed\n"");

        return ret;

    }



    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);

    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);



    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {

        error_report(""vfio: Error: Failed to setup INTx fd: %m\n"");

        return -errno;

    }



    /*

     * Disable mmaps so we can trap on BAR accesses.  We interpret any

     * access as a response to an interrupt and unmask the physical

     * device.  The device will re-assert if the interrupt is still

     * pending.  We'll likely retrigger on the host multiple times per

     * guest interrupt, but without EOI notification it's better than

     * nothing.  Acceleration paths through KVM will avoid this.

     */

    vfio_mmap_set_enabled(vdev, false);



    vdev->interrupt = VFIO_INT_INTx;



    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,

            vdev->host.bus, vdev->host.slot, vdev->host.function);



    return 0;

}
",234,"static int vfio_enable_intx(VFIODevice *ff_yuyvToY_sse2)

{

    VFIOIRQSetFD irq_set_fd = {

        .irq_set = {

            .argsz = sizeof(irq_set_fd),

            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,

            .index = VFIO_PCI_INTX_IRQ_INDEX,

            .start = 0,

            .count = 1,

        },

    };

    uint8_t pin = vfio_pci_read_config(&ff_yuyvToY_sse2->pdev, PCI_INTERRUPT_PIN, 1);

    int ga_channel_listen_add;



    if (ff_yuyvToY_sse2->intx.disabled || !pin) {

        return 0;

    }



    vfio_disable_interrupts(ff_yuyvToY_sse2);



    ff_yuyvToY_sse2->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */

    ga_channel_listen_add = event_notifier_init(&ff_yuyvToY_sse2->intx.interrupt, 0);

    if (ga_channel_listen_add) {

        error_report(""vfio: Error: event_notifier_init failed
"");

        return ga_channel_listen_add;

    }



    irq_set_fd.fd = event_notifier_get_fd(&ff_yuyvToY_sse2->intx.interrupt);

    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, ff_yuyvToY_sse2);



    if (ioctl(ff_yuyvToY_sse2->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {

        error_report(""vfio: Error: Failed to setup INTx fd: %m
"");

        return -errno;

    }



    /*

     * Disable mmaps so we can trap on BAR accesses.  We interpret any

     * access as a response to an interrupt and unmask the physical

     * device.  The device will re-assert if the interrupt is still

     * pending.  We'll likely retrigger on the host multiple times per

     * guest interrupt, but without EOI notification it's better than

     * nothing.  Acceleration paths through KVM will avoid this.

     */

    vfio_mmap_set_enabled(ff_yuyvToY_sse2, false);



    ff_yuyvToY_sse2->interrupt = VFIO_INT_INTx;



    DPRINTF(""%s(%04x:%02x:%02x.%x)
"", __func__, ff_yuyvToY_sse2->host.domain,

            ff_yuyvToY_sse2->host.bus, ff_yuyvToY_sse2->host.slot, ff_yuyvToY_sse2->host.function);



    return 0;

}
",0,0,1,1,vdev,0.13416451215744019,2,19,"{'vdev': 'ff_yuyvToY_sse2', 'ret': 'ga_channel_listen_add'}",MHM-Origin,398,0.18484458525975545
173,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    /* mvc and memmove do not behave the same when areas overlap! */

    } else if ((dest < src) || (src + l < dest)) {

        memmove(g2h(dest), g2h(src), l + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if ((dest + 8 <= src) || (src + 8 <= dest)) {

        for (i = 0; i < l_64; i++) {

            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));

            x += 8;

        }

    }



    /* slow version with byte accesses which always work */

    for (i = x; i <= l; i++) {

        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));

    }

}
",335,"void HELPER(mvc)(CPUS390XState *predicterror_buffer, uint32_t external_htab, uint64_t DPB, uint64_t AVMEDIA_TYPE_SUBTITLE)

{

    int hwdef = 0;

    int x = 0;

    uint32_t l_64 = (external_htab + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""
"",

               __func__, external_htab, DPB, AVMEDIA_TYPE_SUBTITLE);



#ifndef CONFIG_USER_ONLY

    if ((external_htab > 32) &&

        (AVMEDIA_TYPE_SUBTITLE & TARGET_PAGE_MASK) == ((AVMEDIA_TYPE_SUBTITLE + external_htab) & TARGET_PAGE_MASK) &&

        (DPB & TARGET_PAGE_MASK) == ((DPB + external_htab) & TARGET_PAGE_MASK)) {

        if (DPB == (AVMEDIA_TYPE_SUBTITLE + 1)) {

            mvc_fast_memset(predicterror_buffer, external_htab + 1, DPB, cpu_ldub_data(predicterror_buffer, AVMEDIA_TYPE_SUBTITLE));

            return;

        } else if ((AVMEDIA_TYPE_SUBTITLE & TARGET_PAGE_MASK) != (DPB & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(predicterror_buffer, external_htab + 1, DPB, AVMEDIA_TYPE_SUBTITLE);

            return;

        }

    }

#else

    if (DPB == (AVMEDIA_TYPE_SUBTITLE + 1)) {

        memset(g2h(DPB), cpu_ldub_data(predicterror_buffer, AVMEDIA_TYPE_SUBTITLE), external_htab + 1);

        return;

    /* mvc and memmove do not behave the same when areas overlap! */

    } else if ((DPB < AVMEDIA_TYPE_SUBTITLE) || (AVMEDIA_TYPE_SUBTITLE + external_htab < DPB)) {

        memmove(g2h(DPB), g2h(AVMEDIA_TYPE_SUBTITLE), external_htab + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if ((DPB + 8 <= AVMEDIA_TYPE_SUBTITLE) || (AVMEDIA_TYPE_SUBTITLE + 8 <= DPB)) {

        for (hwdef = 0; hwdef < l_64; hwdef++) {

            cpu_stq_data(predicterror_buffer, DPB + x, cpu_ldq_data(predicterror_buffer, AVMEDIA_TYPE_SUBTITLE + x));

            x += 8;

        }

    }



    /* slow version with byte accesses which always work */

    for (hwdef = x; hwdef <= external_htab; hwdef++) {

        cpu_stb_data(predicterror_buffer, DPB + hwdef, cpu_ldub_data(predicterror_buffer, AVMEDIA_TYPE_SUBTITLE + hwdef));

    }

}
",0,0,1,1,env,0.37178488075733185,5,67,"{'l': 'external_htab', 'env': 'predicterror_buffer', 'i': 'hwdef', 'dest': 'DPB', 'src': 'AVMEDIA_TYPE_SUBTITLE'}",MHM-Origin,376,0.17789313793182374
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",89,"void helper_store_fpcr (uint64_t qobject_to_json)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((qobject_to_json >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((qobject_to_json >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",0,0,1,1,val,0.3426662087440491,1,3,{'val': 'qobject_to_json'},MHM-Origin,57,0.02603456974029541
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
",18,"void spapr_tce_set_bypass(sPAPRTCETable *R_EDX, bool ROCKER_EINVAL)

{

    R_EDX->ROCKER_EINVAL = ROCKER_EINVAL;

}
",0,0,1,1,bypass,0.49323440436273813,2,5,"{'bypass': 'ROCKER_EINVAL', 'tcet': 'R_EDX'}",MHM-Origin,96,0.041119515895843506
176,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",67,"void qemu_system_wakeup_request(WakeupReason MSR_MTRRfix64K_00000)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << MSR_MTRRfix64K_00000))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &MSR_MTRRfix64K_00000);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",0,0,1,1,reason,0.7634279280900955,1,3,{'reason': 'MSR_MTRRfix64K_00000'},MHM-Origin,99,0.04291150172551473
178,"int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,

                            VLC *vlc, const float *level_table,

                            const uint16_t *run_table, int version,

                            WMACoef *ptr, int offset, int num_coefs,

                            int block_len, int frame_len_bits,

                            int coef_nb_bits)

{

    int code, level, sign;

    const uint32_t *ilvl = (const uint32_t *) level_table;

    uint32_t *iptr = (uint32_t *) ptr;

    const unsigned int coef_mask = block_len - 1;

    for (; offset < num_coefs; offset++) {

        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);

        if (code > 1) {

            /** normal code */

            offset                  += run_table[code];

            sign                     = get_bits1(gb) - 1;

            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;

        } else if (code == 1) {

            /** EOB */

            break;

        } else {

            /** escape */

            if (!version) {

                level = get_bits(gb, coef_nb_bits);

                /** NOTE: this is rather suboptimal. reading

                 *  block_len_bits would be better */

                offset += get_bits(gb, frame_len_bits);

            } else {

                level = ff_wma_get_large_val(gb);

                /** escape decode */

                if (get_bits1(gb)) {

                    if (get_bits1(gb)) {

                        if (get_bits1(gb)) {

                            av_log(avctx, AV_LOG_ERROR,

                                   ""broken escape sequence\n"");

                            return -1;

                        } else

                            offset += get_bits(gb, frame_len_bits) + 4;

                    } else

                        offset += get_bits(gb, 2) + 1;

                }

            }

            sign                    = get_bits1(gb) - 1;

            ptr[offset & coef_mask] = (level ^ sign) - sign;

        }

    }

    /** NOTE: EOB can be omitted */

    if (offset > num_coefs) {

        av_log(avctx, AV_LOG_ERROR, ""overflow in spectral RLE, ignoring\n"");

        return -1;

    }



    return 0;

}
",317,"int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,

                            VLC *vlc, const float *level_table,

                            const uint16_t *motion_val, int version,

                            WMACoef *ptr, int offset, int num_coefs,

                            int block_len, int frame_len_bits,

                            int coef_nb_bits)

{

    int ref_list, level, sign;

    const uint32_t *orientation = (const uint32_t *) level_table;

    uint32_t *iptr = (uint32_t *) ptr;

    const unsigned int coef_mask = block_len - 1;

    for (; offset < num_coefs; offset++) {

        ref_list = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);

        if (ref_list > 1) {

            /** normal code */

            offset                  += motion_val[ref_list];

            sign                     = get_bits1(gb) - 1;

            iptr[offset & coef_mask] = orientation[ref_list] ^ sign << 31;

        } else if (ref_list == 1) {

            /** EOB */

            break;

        } else {

            /** escape */

            if (!version) {

                level = get_bits(gb, coef_nb_bits);

                /** NOTE: this is rather suboptimal. reading

                 *  block_len_bits would be better */

                offset += get_bits(gb, frame_len_bits);

            } else {

                level = ff_wma_get_large_val(gb);

                /** escape decode */

                if (get_bits1(gb)) {

                    if (get_bits1(gb)) {

                        if (get_bits1(gb)) {

                            av_log(avctx, AV_LOG_ERROR,

                                   ""broken escape sequence
"");

                            return -1;

                        } else

                            offset += get_bits(gb, frame_len_bits) + 4;

                    } else

                        offset += get_bits(gb, 2) + 1;

                }

            }

            sign                    = get_bits1(gb) - 1;

            ptr[offset & coef_mask] = (level ^ sign) - sign;

        }

    }

    /** NOTE: EOB can be omitted */

    if (offset > num_coefs) {

        av_log(avctx, AV_LOG_ERROR, ""overflow in spectral RLE, ignoring
"");

        return -1;

    }



    return 0;

}
",1,1,0,1,run_table,-0.19937771558761597,3,10,"{'code': 'ref_list', 'ilvl': 'orientation', 'run_table': 'motion_val'}",MHM-Origin,62,0.02674900690714518
179,"int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,

                         AVFilterInOut *open_inputs,

                         AVFilterInOut *open_outputs, AVClass *log_ctx)

{

    int index = 0, ret;

    char chr = 0;



    AVFilterInOut *curr_inputs = NULL;



    do {

        AVFilterContext *filter;

        filters += strspn(filters, WHITESPACES);



        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)

            goto fail;



        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)

            goto fail;



        if (filter->input_count == 1 && !curr_inputs && !index) {

            /* First input can be omitted if it is ""[in]"" */

            const char *tmp = ""[in]"";

            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)

                goto fail;

        }



        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)

            goto fail;



        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,

                                 log_ctx)) < 0)

            goto fail;



        filters += strspn(filters, WHITESPACES);

        chr = *filters++;



        if (chr == ';' && curr_inputs) {

            av_log(log_ctx, AV_LOG_ERROR,

                   ""Could not find a output to link when parsing \""%s\""\n"",

                   filters - 1);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        index++;

    } while (chr == ',' || chr == ';');



    if (chr) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Unable to parse graph description substring: \""%s\""\n"",

               filters - 1);

        ret = AVERROR(EINVAL);

        goto fail;

    }



    if (open_inputs && !strcmp(open_inputs->name, ""out"") && curr_inputs) {

        /* Last output can be omitted if it is ""[out]"" */

        const char *tmp = ""[out]"";

        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,

                                 log_ctx)) < 0)

            goto fail;

    }



    return 0;



 fail:

    avfilter_graph_free(graph);

    free_inout(open_inputs);

    free_inout(open_outputs);

    free_inout(curr_inputs);

    return ret;

}
",405,"int avfilter_graph_parse(AVFilterGraph *AVClass, const char *l1_size,

                         AVFilterInOut *CC_OP_MULW,

                         AVFilterInOut *start_address, AVClass *log_ctx)

{

    int bS = 0, kvmppc_alloc_rma;

    char chr = 0;



    AVFilterInOut *curr_inputs = NULL;



    do {

        AVFilterContext *kvm_vm_ioctl;

        l1_size += strspn(l1_size, WHITESPACES);



        if ((kvmppc_alloc_rma = parse_inputs(&l1_size, &curr_inputs, &start_address, log_ctx)) < 0)

            goto fail;



        if ((kvmppc_alloc_rma = parse_filter(&kvm_vm_ioctl, &l1_size, AVClass, bS, log_ctx)) < 0)

            goto fail;



        if (kvm_vm_ioctl->input_count == 1 && !curr_inputs && !bS) {

            /* First input can be omitted if it is ""[in]"" */

            const char *dstWidth = ""[in]"";

            if ((kvmppc_alloc_rma = parse_inputs(&dstWidth, &curr_inputs, &start_address, log_ctx)) < 0)

                goto fail;

        }



        if ((kvmppc_alloc_rma = link_filter_inouts(kvm_vm_ioctl, &curr_inputs, &CC_OP_MULW, log_ctx)) < 0)

            goto fail;



        if ((kvmppc_alloc_rma = parse_outputs(&l1_size, &curr_inputs, &CC_OP_MULW, &start_address,

                                 log_ctx)) < 0)

            goto fail;



        l1_size += strspn(l1_size, WHITESPACES);

        chr = *l1_size++;



        if (chr == ';' && curr_inputs) {

            av_log(log_ctx, AV_LOG_ERROR,

                   ""Could not find a output to link when parsing \""%s\""
"",

                   l1_size - 1);

            kvmppc_alloc_rma = AVERROR(EINVAL);

            goto fail;

        }

        bS++;

    } while (chr == ',' || chr == ';');



    if (chr) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Unable to parse graph description substring: \""%s\""
"",

               l1_size - 1);

        kvmppc_alloc_rma = AVERROR(EINVAL);

        goto fail;

    }



    if (CC_OP_MULW && !strcmp(CC_OP_MULW->name, ""out"") && curr_inputs) {

        /* Last output can be omitted if it is ""[out]"" */

        const char *dstWidth = ""[out]"";

        if ((kvmppc_alloc_rma = parse_outputs(&dstWidth, &curr_inputs, &CC_OP_MULW, &start_address,

                                 log_ctx)) < 0)

            goto fail;

    }



    return 0;



 fail:

    avfilter_graph_free(AVClass);

    free_inout(CC_OP_MULW);

    free_inout(start_address);

    free_inout(curr_inputs);

    return kvmppc_alloc_rma;

}
",0,0,1,1,index,0.10434430837631226,8,50,"{'ret': 'kvmppc_alloc_rma', 'filter': 'kvm_vm_ioctl', 'graph': 'AVClass', 'index': 'bS', 'tmp': 'dstWidth', 'filters': 'l1_size', 'open_outputs': 'start_address', 'open_inputs': 'CC_OP_MULW'}",MHM-Origin,347,0.16057225863138835
182,"static int sd_create_branch(BDRVSheepdogState *s)

{

    int ret, fd;

    uint32_t vid;

    char *buf;



    dprintf(""%"" PRIx32 "" is snapshot.\n"", s->inode.vdi_id);



    buf = g_malloc(SD_INODE_SIZE);



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,

                       s->addr, s->port);

    if (ret) {

        goto out;

    }



    dprintf(""%"" PRIx32 "" is created.\n"", vid);



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        error_report(""failed to connect"");

        ret = fd;

        goto out;

    }



    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,

                      SD_INODE_SIZE, 0, s->cache_enabled);



    closesocket(fd);



    if (ret < 0) {

        goto out;

    }



    memcpy(&s->inode, buf, sizeof(s->inode));



    s->is_snapshot = false;

    ret = 0;

    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);



out:

    g_free(buf);



    return ret;

}
",235,"static int sd_create_branch(BDRVSheepdogState *err_out)

{

    int ret, fd;

    uint32_t vid;

    char *buf;



    dprintf(""%"" PRIx32 "" is snapshot.
"", err_out->inode.vdi_id);



    buf = g_malloc(SD_INODE_SIZE);



    ret = do_sd_create(err_out->name, err_out->inode.vdi_size, err_out->inode.vdi_id, &vid, 1,

                       err_out->addr, err_out->port);

    if (ret) {

        goto out;

    }



    dprintf(""%"" PRIx32 "" is created.
"", vid);



    fd = connect_to_sdog(err_out->addr, err_out->port);

    if (fd < 0) {

        error_report(""failed to connect"");

        ret = fd;

        goto out;

    }



    ret = read_object(fd, buf, vid_to_vdi_oid(vid), err_out->inode.nr_copies,

                      SD_INODE_SIZE, 0, err_out->cache_enabled);



    closesocket(fd);



    if (ret < 0) {

        goto out;

    }



    memcpy(&err_out->inode, buf, sizeof(err_out->inode));



    err_out->is_snapshot = false;

    ret = 0;

    dprintf(""%"" PRIx32 "" was newly created.
"", err_out->inode.vdi_id);



out:

    g_free(buf);



    return ret;

}
",0,0,1,1,s,0.0315108597278595,1,15,{'s': 'err_out'},MHM-Origin,24,0.008701920509338379
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",80,"static int parse_uint8(DeviceState *skip_bits_long, Property *virtio_cleanup, const char *num_children)

{

    uint8_t *ptr = qdev_get_prop_ptr(skip_bits_long, virtio_cleanup);

    const char *local_qiov;



    /* accept both hex and decimal */

    local_qiov = strncasecmp(num_children, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(num_children, local_qiov, ptr) != 1)

        return -EINVAL;

    return 0;

}
",1,1,0,1,dev,-0.4974668622016907,4,10,"{'str': 'num_children', 'fmt': 'local_qiov', 'prop': 'virtio_cleanup', 'dev': 'skip_bits_long'}",MHM-Origin,138,0.05571308135986328
184,"av_cold int swri_rematrix_init(SwrContext *s){

    int i, j;

    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);

    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);



    s->mix_any_f = NULL;



    if (!s->rematrix_custom) {

        int r = auto_matrix(s);

        if (r)

            return r;

    }

    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++) {

            double rem = 0;



            for (j = 0; j < nb_in; j++) {

                double target = s->matrix[i][j] * 32768 + rem;

                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);

                rem += target - ((int*)s->native_matrix)[i * nb_in + j];

            }

        }

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));

        s->native_one    = av_mallocz(sizeof(float));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((float*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(double));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((double*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){

        // Only for dithering currently

//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_one)

            return AVERROR(ENOMEM);

//         for (i = 0; i < nb_out; i++)

//             for (j = 0; j < nb_in; j++)

//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);

    }else

        av_assert0(0);

    //FIXME quantize for integeres

    for (i = 0; i < SWR_CH_MAX; i++) {

        int ch_in=0;

        for (j = 0; j < SWR_CH_MAX; j++) {

            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);

            if(s->matrix[i][j])

                s->matrix_ch[i][++ch_in]= j;

        }

        s->matrix_ch[i][0]= ch_in;

    }



    if(HAVE_YASM && HAVE_MMX)

        return swri_rematrix_init_x86(s);



    return 0;

}
",782,"av_cold int swri_rematrix_init(SwrContext *s){

    int BlockStats, j;

    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);

    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);



    s->mix_any_f = NULL;



    if (!s->rematrix_custom) {

        int r = auto_matrix(s);

        if (r)

            return r;

    }

    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (BlockStats = 0; BlockStats < nb_out; BlockStats++) {

            double rem = 0;



            for (j = 0; j < nb_in; j++) {

                double target = s->matrix[BlockStats][j] * 32768 + rem;

                ((int*)s->native_matrix)[BlockStats * nb_in + j] = lrintf(target);

                rem += target - ((int*)s->native_matrix)[BlockStats * nb_in + j];

            }

        }

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));

        s->native_one    = av_mallocz(sizeof(float));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (BlockStats = 0; BlockStats < nb_out; BlockStats++)

            for (j = 0; j < nb_in; j++)

                ((float*)s->native_matrix)[BlockStats * nb_in + j] = s->matrix[BlockStats][j];

        *((float*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(double));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (BlockStats = 0; BlockStats < nb_out; BlockStats++)

            for (j = 0; j < nb_in; j++)

                ((double*)s->native_matrix)[BlockStats * nb_in + j] = s->matrix[BlockStats][j];

        *((double*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){

        // Only for dithering currently

//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_one)

            return AVERROR(ENOMEM);

//         for (i = 0; i < nb_out; i++)

//             for (j = 0; j < nb_in; j++)

//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);

    }else

        av_assert0(0);

    //FIXME quantize for integeres

    for (BlockStats = 0; BlockStats < SWR_CH_MAX; BlockStats++) {

        int ch_in=0;

        for (j = 0; j < SWR_CH_MAX; j++) {

            s->matrix32[BlockStats][j]= lrintf(s->matrix[BlockStats][j] * 32768);

            if(s->matrix[BlockStats][j])

                s->matrix_ch[BlockStats][++ch_in]= j;

        }

        s->matrix_ch[BlockStats][0]= ch_in;

    }



    if(HAVE_YASM && HAVE_MMX)

        return swri_rematrix_init_x86(s);



    return 0;

}
",1,1,0,1,i,-0.06261450052261353,1,25,{'i': 'BlockStats'},MHM-Origin,22,0.010301530361175537
190,"static int kvm_get_msrs(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;

    int ret, i;

    uint64_t mtrr_top_bits;



    kvm_msr_buf_reset(cpu);



    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(cpu, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(cpu, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);

    }

    if (has_msr_feature_control) {

        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);

    }

    if (has_msr_bndcfgs) {

        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);

    }

    if (has_msr_xss) {

        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);

    }





    if (!env->tsc_valid) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);

        env->tsc_valid = !runstate_is_running();

    }



#ifdef TARGET_X86_64

    if (lm_capable_kernel) {

        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);

        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);

        kvm_msr_entry_add(cpu, MSR_FMASK, 0);

        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);

    }

#endif

    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);

    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);

    if (has_msr_async_pf_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);

    }

    if (has_msr_pv_eoi_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);

    }

    if (has_msr_kvm_steal_time) {

        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);

    }

    if (has_msr_architectural_pmu) {

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);

        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {

            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);

        }

        for (i = 0; i < num_architectural_pmu_counters; i++) {

            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);

            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);

        }

    }



    if (env->mcg_cap) {

        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);

        if (has_msr_mcg_ext_ctl) {

            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);

        }

        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {

            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);

        }

    }



    if (has_msr_hv_hypercall) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);

    }

    if (has_msr_hv_vapic) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);

    }

    if (has_msr_hv_tsc) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);

    }

    if (has_msr_hv_crash) {

        int j;



        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {

            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);

        }

    }

    if (has_msr_hv_runtime) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);

    }

    if (cpu->hyperv_synic) {

        uint32_t msr;



        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);

        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_hv_stimer) {

        uint32_t msr;



        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;

             msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_mtrr) {

        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);

        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {

            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);

            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);

        }

    }



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);

    if (ret < 0) {

        return ret;

    }



    assert(ret == cpu->kvm_msr_buf->nmsrs);

    /*

     * MTRR masks: Each mask consists of 5 parts

     * a  10..0: must be zero

     * b  11   : valid bit

     * c n-1.12: actual mask bits

     * d  51..n: reserved must be zero

     * e  63.52: reserved must be zero

     *

     * 'n' is the number of physical bits supported by the CPU and is

     * apparently always <= 52.   We know our 'n' but don't know what

     * the destinations 'n' is; it might be smaller, in which case

     * it masks (c) on loading. It might be larger, in which case

     * we fill 'd' so that d..c is consistent irrespetive of the 'n'

     * we're migrating to.

     */



    if (cpu->fill_mtrr_mask) {

        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);

        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);

        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);

    } else {

        mtrr_top_bits = 0;

    }



    for (i = 0; i < ret; i++) {

        uint32_t index = msrs[i].index;

        switch (index) {

        case MSR_IA32_SYSENTER_CS:

            env->sysenter_cs = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_ESP:

            env->sysenter_esp = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_EIP:

            env->sysenter_eip = msrs[i].data;

            break;

        case MSR_PAT:

            env->pat = msrs[i].data;

            break;

        case MSR_STAR:

            env->star = msrs[i].data;

            break;

#ifdef TARGET_X86_64

        case MSR_CSTAR:

            env->cstar = msrs[i].data;

            break;

        case MSR_KERNELGSBASE:

            env->kernelgsbase = msrs[i].data;

            break;

        case MSR_FMASK:

            env->fmask = msrs[i].data;

            break;

        case MSR_LSTAR:

            env->lstar = msrs[i].data;

            break;

#endif

        case MSR_IA32_TSC:

            env->tsc = msrs[i].data;

            break;

        case MSR_TSC_AUX:

            env->tsc_aux = msrs[i].data;

            break;

        case MSR_TSC_ADJUST:

            env->tsc_adjust = msrs[i].data;

            break;

        case MSR_IA32_TSCDEADLINE:

            env->tsc_deadline = msrs[i].data;

            break;

        case MSR_VM_HSAVE_PA:

            env->vm_hsave = msrs[i].data;

            break;

        case MSR_KVM_SYSTEM_TIME:

            env->system_time_msr = msrs[i].data;

            break;

        case MSR_KVM_WALL_CLOCK:

            env->wall_clock_msr = msrs[i].data;

            break;

        case MSR_MCG_STATUS:

            env->mcg_status = msrs[i].data;

            break;

        case MSR_MCG_CTL:

            env->mcg_ctl = msrs[i].data;

            break;

        case MSR_MCG_EXT_CTL:

            env->mcg_ext_ctl = msrs[i].data;

            break;

        case MSR_IA32_MISC_ENABLE:

            env->msr_ia32_misc_enable = msrs[i].data;

            break;

        case MSR_IA32_SMBASE:

            env->smbase = msrs[i].data;

            break;

        case MSR_IA32_FEATURE_CONTROL:

            env->msr_ia32_feature_control = msrs[i].data;

            break;

        case MSR_IA32_BNDCFGS:

            env->msr_bndcfgs = msrs[i].data;

            break;

        case MSR_IA32_XSS:

            env->xss = msrs[i].data;

            break;

        default:

            if (msrs[i].index >= MSR_MC0_CTL &&

                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {

                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;

            }

            break;

        case MSR_KVM_ASYNC_PF_EN:

            env->async_pf_en_msr = msrs[i].data;

            break;

        case MSR_KVM_PV_EOI_EN:

            env->pv_eoi_en_msr = msrs[i].data;

            break;

        case MSR_KVM_STEAL_TIME:

            env->steal_time_msr = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR_CTRL:

            env->msr_fixed_ctr_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_CTRL:

            env->msr_global_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_STATUS:

            env->msr_global_status = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:

            env->msr_global_ovf_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:

            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;

            break;

        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;

            break;

        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;

            break;

        case HV_X64_MSR_HYPERCALL:

            env->msr_hv_hypercall = msrs[i].data;

            break;

        case HV_X64_MSR_GUEST_OS_ID:

            env->msr_hv_guest_os_id = msrs[i].data;

            break;

        case HV_X64_MSR_APIC_ASSIST_PAGE:

            env->msr_hv_vapic = msrs[i].data;

            break;

        case HV_X64_MSR_REFERENCE_TSC:

            env->msr_hv_tsc = msrs[i].data;

            break;

        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:

            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;

            break;

        case HV_X64_MSR_VP_RUNTIME:

            env->msr_hv_runtime = msrs[i].data;

            break;

        case HV_X64_MSR_SCONTROL:

            env->msr_hv_synic_control = msrs[i].data;

            break;

        case HV_X64_MSR_SVERSION:

            env->msr_hv_synic_version = msrs[i].data;

            break;

        case HV_X64_MSR_SIEFP:

            env->msr_hv_synic_evt_page = msrs[i].data;

            break;

        case HV_X64_MSR_SIMP:

            env->msr_hv_synic_msg_page = msrs[i].data;

            break;

        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:

            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_CONFIG:

        case HV_X64_MSR_STIMER1_CONFIG:

        case HV_X64_MSR_STIMER2_CONFIG:

        case HV_X64_MSR_STIMER3_CONFIG:

            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =

                                msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_COUNT:

        case HV_X64_MSR_STIMER1_COUNT:

        case HV_X64_MSR_STIMER2_COUNT:

        case HV_X64_MSR_STIMER3_COUNT:

            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =

                                msrs[i].data;

            break;

        case MSR_MTRRdefType:

            env->mtrr_deftype = msrs[i].data;

            break;

        case MSR_MTRRfix64K_00000:

            env->mtrr_fixed[0] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_80000:

            env->mtrr_fixed[1] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_A0000:

            env->mtrr_fixed[2] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C0000:

            env->mtrr_fixed[3] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C8000:

            env->mtrr_fixed[4] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D0000:

            env->mtrr_fixed[5] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D8000:

            env->mtrr_fixed[6] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E0000:

            env->mtrr_fixed[7] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E8000:

            env->mtrr_fixed[8] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F0000:

            env->mtrr_fixed[9] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F8000:

            env->mtrr_fixed[10] = msrs[i].data;

            break;

        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):

            if (index & 1) {

                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |

                                                               mtrr_top_bits;

            } else {

                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;

            }

            break;

        }

    }



    return 0;

}
",2211,"static int kvm_get_msrs(X86CPU *tcg_gen_qemu_st_i32)

{

    CPUX86State *env = &tcg_gen_qemu_st_i32->env;

    struct kvm_msr_entry *huff_reader_get_symbol = tcg_gen_qemu_st_i32->kvm_msr_buf->entries;

    int ret, md5_ctx;

    uint64_t mtrr_top_bits;



    kvm_msr_buf_reset(tcg_gen_qemu_st_i32);



    kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_IA32_SMBASE, 0);

    }

    if (has_msr_feature_control) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_IA32_FEATURE_CONTROL, 0);

    }

    if (has_msr_bndcfgs) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_IA32_BNDCFGS, 0);

    }

    if (has_msr_xss) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_IA32_XSS, 0);

    }





    if (!env->tsc_valid) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_IA32_TSC, 0);

        env->tsc_valid = !runstate_is_running();

    }



#ifdef TARGET_X86_64

    if (lm_capable_kernel) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_CSTAR, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_KERNELGSBASE, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_FMASK, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_LSTAR, 0);

    }

#endif

    kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_KVM_SYSTEM_TIME, 0);

    kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_KVM_WALL_CLOCK, 0);

    if (has_msr_async_pf_en) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_KVM_ASYNC_PF_EN, 0);

    }

    if (has_msr_pv_eoi_en) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_KVM_PV_EOI_EN, 0);

    }

    if (has_msr_kvm_steal_time) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_KVM_STEAL_TIME, 0);

    }

    if (has_msr_architectural_pmu) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_CORE_PERF_GLOBAL_CTRL, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_CORE_PERF_GLOBAL_STATUS, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);

        for (md5_ctx = 0; md5_ctx < MAX_FIXED_COUNTERS; md5_ctx++) {

            kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_CORE_PERF_FIXED_CTR0 + md5_ctx, 0);

        }

        for (md5_ctx = 0; md5_ctx < num_architectural_pmu_counters; md5_ctx++) {

            kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_P6_PERFCTR0 + md5_ctx, 0);

            kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_P6_EVNTSEL0 + md5_ctx, 0);

        }

    }



    if (env->mcg_cap) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MCG_STATUS, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MCG_CTL, 0);

        if (has_msr_mcg_ext_ctl) {

            kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MCG_EXT_CTL, 0);

        }

        for (md5_ctx = 0; md5_ctx < (env->mcg_cap & 0xff) * 4; md5_ctx++) {

            kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MC0_CTL + md5_ctx, 0);

        }

    }



    if (has_msr_hv_hypercall) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, HV_X64_MSR_HYPERCALL, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, HV_X64_MSR_GUEST_OS_ID, 0);

    }

    if (has_msr_hv_vapic) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, HV_X64_MSR_APIC_ASSIST_PAGE, 0);

    }

    if (has_msr_hv_tsc) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, HV_X64_MSR_REFERENCE_TSC, 0);

    }

    if (has_msr_hv_crash) {

        int hg;



        for (hg = 0; hg < HV_X64_MSR_CRASH_PARAMS; hg++) {

            kvm_msr_entry_add(tcg_gen_qemu_st_i32, HV_X64_MSR_CRASH_P0 + hg, 0);

        }

    }

    if (has_msr_hv_runtime) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, HV_X64_MSR_VP_RUNTIME, 0);

    }

    if (tcg_gen_qemu_st_i32->hyperv_synic) {

        uint32_t msr;



        kvm_msr_entry_add(tcg_gen_qemu_st_i32, HV_X64_MSR_SCONTROL, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, HV_X64_MSR_SVERSION, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, HV_X64_MSR_SIEFP, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, HV_X64_MSR_SIMP, 0);

        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {

            kvm_msr_entry_add(tcg_gen_qemu_st_i32, msr, 0);

        }

    }

    if (has_msr_hv_stimer) {

        uint32_t msr;



        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;

             msr++) {

            kvm_msr_entry_add(tcg_gen_qemu_st_i32, msr, 0);

        }

    }

    if (has_msr_mtrr) {

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRdefType, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix64K_00000, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix16K_80000, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix16K_A0000, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix4K_C0000, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix4K_C8000, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix4K_D0000, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix4K_D8000, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix4K_E0000, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix4K_E8000, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix4K_F0000, 0);

        kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRfix4K_F8000, 0);

        for (md5_ctx = 0; md5_ctx < MSR_MTRRcap_VCNT; md5_ctx++) {

            kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRphysBase(md5_ctx), 0);

            kvm_msr_entry_add(tcg_gen_qemu_st_i32, MSR_MTRRphysMask(md5_ctx), 0);

        }

    }



    ret = kvm_vcpu_ioctl(CPU(tcg_gen_qemu_st_i32), KVM_GET_MSRS, tcg_gen_qemu_st_i32->kvm_msr_buf);

    if (ret < 0) {

        return ret;

    }



    assert(ret == tcg_gen_qemu_st_i32->kvm_msr_buf->nmsrs);

    /*

     * MTRR masks: Each mask consists of 5 parts

     * a  10..0: must be zero

     * b  11   : valid bit

     * c n-1.12: actual mask bits

     * d  51..n: reserved must be zero

     * e  63.52: reserved must be zero

     *

     * 'n' is the number of physical bits supported by the CPU and is

     * apparently always <= 52.   We know our 'n' but don't know what

     * the destinations 'n' is; it might be smaller, in which case

     * it masks (c) on loading. It might be larger, in which case

     * we fill 'd' so that d..c is consistent irrespetive of the 'n'

     * we're migrating to.

     */



    if (tcg_gen_qemu_st_i32->fill_mtrr_mask) {

        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);

        assert(tcg_gen_qemu_st_i32->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);

        mtrr_top_bits = MAKE_64BIT_MASK(tcg_gen_qemu_st_i32->phys_bits, 52 - tcg_gen_qemu_st_i32->phys_bits);

    } else {

        mtrr_top_bits = 0;

    }



    for (md5_ctx = 0; md5_ctx < ret; md5_ctx++) {

        uint32_t index = huff_reader_get_symbol[md5_ctx].index;

        switch (index) {

        case MSR_IA32_SYSENTER_CS:

            env->sysenter_cs = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_IA32_SYSENTER_ESP:

            env->sysenter_esp = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_IA32_SYSENTER_EIP:

            env->sysenter_eip = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_PAT:

            env->pat = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_STAR:

            env->star = huff_reader_get_symbol[md5_ctx].data;

            break;

#ifdef TARGET_X86_64

        case MSR_CSTAR:

            env->cstar = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_KERNELGSBASE:

            env->kernelgsbase = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_FMASK:

            env->fmask = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_LSTAR:

            env->lstar = huff_reader_get_symbol[md5_ctx].data;

            break;

#endif

        case MSR_IA32_TSC:

            env->tsc = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_TSC_AUX:

            env->tsc_aux = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_TSC_ADJUST:

            env->tsc_adjust = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_IA32_TSCDEADLINE:

            env->tsc_deadline = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_VM_HSAVE_PA:

            env->vm_hsave = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_KVM_SYSTEM_TIME:

            env->system_time_msr = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_KVM_WALL_CLOCK:

            env->wall_clock_msr = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MCG_STATUS:

            env->mcg_status = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MCG_CTL:

            env->mcg_ctl = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MCG_EXT_CTL:

            env->mcg_ext_ctl = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_IA32_MISC_ENABLE:

            env->msr_ia32_misc_enable = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_IA32_SMBASE:

            env->smbase = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_IA32_FEATURE_CONTROL:

            env->msr_ia32_feature_control = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_IA32_BNDCFGS:

            env->msr_bndcfgs = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_IA32_XSS:

            env->xss = huff_reader_get_symbol[md5_ctx].data;

            break;

        default:

            if (huff_reader_get_symbol[md5_ctx].index >= MSR_MC0_CTL &&

                huff_reader_get_symbol[md5_ctx].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {

                env->mce_banks[huff_reader_get_symbol[md5_ctx].index - MSR_MC0_CTL] = huff_reader_get_symbol[md5_ctx].data;

            }

            break;

        case MSR_KVM_ASYNC_PF_EN:

            env->async_pf_en_msr = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_KVM_PV_EOI_EN:

            env->pv_eoi_en_msr = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_KVM_STEAL_TIME:

            env->steal_time_msr = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR_CTRL:

            env->msr_fixed_ctr_ctrl = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_CORE_PERF_GLOBAL_CTRL:

            env->msr_global_ctrl = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_CORE_PERF_GLOBAL_STATUS:

            env->msr_global_status = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:

            env->msr_global_ovf_ctrl = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:

            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_HYPERCALL:

            env->msr_hv_hypercall = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_GUEST_OS_ID:

            env->msr_hv_guest_os_id = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_APIC_ASSIST_PAGE:

            env->msr_hv_vapic = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_REFERENCE_TSC:

            env->msr_hv_tsc = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:

            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_VP_RUNTIME:

            env->msr_hv_runtime = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_SCONTROL:

            env->msr_hv_synic_control = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_SVERSION:

            env->msr_hv_synic_version = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_SIEFP:

            env->msr_hv_synic_evt_page = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_SIMP:

            env->msr_hv_synic_msg_page = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:

            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_STIMER0_CONFIG:

        case HV_X64_MSR_STIMER1_CONFIG:

        case HV_X64_MSR_STIMER2_CONFIG:

        case HV_X64_MSR_STIMER3_CONFIG:

            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =

                                huff_reader_get_symbol[md5_ctx].data;

            break;

        case HV_X64_MSR_STIMER0_COUNT:

        case HV_X64_MSR_STIMER1_COUNT:

        case HV_X64_MSR_STIMER2_COUNT:

        case HV_X64_MSR_STIMER3_COUNT:

            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =

                                huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRdefType:

            env->mtrr_deftype = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix64K_00000:

            env->mtrr_fixed[0] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix16K_80000:

            env->mtrr_fixed[1] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix16K_A0000:

            env->mtrr_fixed[2] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix4K_C0000:

            env->mtrr_fixed[3] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix4K_C8000:

            env->mtrr_fixed[4] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix4K_D0000:

            env->mtrr_fixed[5] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix4K_D8000:

            env->mtrr_fixed[6] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix4K_E0000:

            env->mtrr_fixed[7] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix4K_E8000:

            env->mtrr_fixed[8] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix4K_F0000:

            env->mtrr_fixed[9] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRfix4K_F8000:

            env->mtrr_fixed[10] = huff_reader_get_symbol[md5_ctx].data;

            break;

        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):

            if (index & 1) {

                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = huff_reader_get_symbol[md5_ctx].data |

                                                               mtrr_top_bits;

            } else {

                env->mtrr_var[MSR_MTRRphysIndex(index)].base = huff_reader_get_symbol[md5_ctx].data;

            }

            break;

        }

    }



    return 0;

}
",0,0,1,1,msrs,0.4959147274494171,4,233,"{'j': 'hg', 'i': 'md5_ctx', 'cpu': 'tcg_gen_qemu_st_i32', 'msrs': 'huff_reader_get_symbol'}",MHM-Origin,104,0.08061866760253907
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
",48,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *ARGB;



    ARGB = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(ARGB)) {

        return false;

    } else {

        return true;

    }

}
",0,0,1,1,mr,0.053457558155059814,1,3,{'mr': 'ARGB'},MHM-Origin,22,0.008170243104298909
193,"static void omap_pwt_write(void *opaque, target_phys_addr_t addr,

                           uint64_t value, unsigned size)

{

    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;

    int offset = addr & OMAP_MPUI_REG_MASK;



    if (size != 1) {

        return omap_badwidth_write8(opaque, addr, value);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        s->frc = value & 0x3f;

        break;

    case 0x04:	/* VRC */

        if ((value ^ s->vrc) & 1) {

            if (value & 1)

                printf(""%s: %iHz buzz on\n"", __FUNCTION__, (int)

                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */

                                ((omap_clk_getrate(s->clk) >> 3) /

                                 /* Pre-multiplexer divider */

                                 ((s->gcr & 2) ? 1 : 154) /

                                 /* Octave multiplexer */

                                 (2 << (value & 3)) *

                                 /* 101/107 divider */

                                 ((value & (1 << 2)) ? 101 : 107) *

                                 /*  49/55 divider */

                                 ((value & (1 << 3)) ?  49 : 55) *

                                 /*  50/63 divider */

                                 ((value & (1 << 4)) ?  50 : 63) *

                                 /*  80/127 divider */

                                 ((value & (1 << 5)) ?  80 : 127) /

                                 (107 * 55 * 63 * 127)));

            else

                printf(""%s: silence!\n"", __FUNCTION__);

        }

        s->vrc = value & 0x7f;

        break;

    case 0x08:	/* GCR */

        s->gcr = value & 3;

        break;

    default:

        OMAP_BAD_REG(addr);

        return;

    }

}
",263,"static void omap_pwt_write(void *dma, target_phys_addr_t IS_SKIP,

                           uint64_t BDRVCURLState, unsigned qemu_open)

{

    struct omap_pwt_s *HF_MPX_EN_MASK = (struct omap_pwt_s *) dma;

    int offset = IS_SKIP & OMAP_MPUI_REG_MASK;



    if (qemu_open != 1) {

        return omap_badwidth_write8(dma, IS_SKIP, BDRVCURLState);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        HF_MPX_EN_MASK->frc = BDRVCURLState & 0x3f;

        break;

    case 0x04:	/* VRC */

        if ((BDRVCURLState ^ HF_MPX_EN_MASK->vrc) & 1) {

            if (BDRVCURLState & 1)

                printf(""%s: %iHz buzz on
"", __FUNCTION__, (int)

                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */

                                ((omap_clk_getrate(HF_MPX_EN_MASK->clk) >> 3) /

                                 /* Pre-multiplexer divider */

                                 ((HF_MPX_EN_MASK->gcr & 2) ? 1 : 154) /

                                 /* Octave multiplexer */

                                 (2 << (BDRVCURLState & 3)) *

                                 /* 101/107 divider */

                                 ((BDRVCURLState & (1 << 2)) ? 101 : 107) *

                                 /*  49/55 divider */

                                 ((BDRVCURLState & (1 << 3)) ?  49 : 55) *

                                 /*  50/63 divider */

                                 ((BDRVCURLState & (1 << 4)) ?  50 : 63) *

                                 /*  80/127 divider */

                                 ((BDRVCURLState & (1 << 5)) ?  80 : 127) /

                                 (107 * 55 * 63 * 127)));

            else

                printf(""%s: silence!
"", __FUNCTION__);

        }

        HF_MPX_EN_MASK->vrc = BDRVCURLState & 0x7f;

        break;

    case 0x08:	/* GCR */

        HF_MPX_EN_MASK->gcr = BDRVCURLState & 3;

        break;

    default:

        OMAP_BAD_REG(IS_SKIP);

        return;

    }

}
",0,0,0,-1,value,-0.003618092741817236,5,28,"{'size': 'qemu_open', 'value': 'BDRVCURLState', 'opaque': 'dma', 's': 'HF_MPX_EN_MASK', 'addr': 'IS_SKIP'}",MHM-Origin,398,0.17551398277282715
194,"static void predictor_decode_mono(APEContext *ctx, int count)

{

    APEPredictor *p = &ctx->predictor;

    int32_t *decoded0 = ctx->decoded[0];

    int32_t predictionA, currentA, A, sign;



    currentA = p->lastA[0];



    while (count--) {

        A = *decoded0;



        p->buf[YDELAYA] = currentA;

        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];



        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +

                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +

                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +

                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];



        currentA = A + (predictionA >> 10);



        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);

        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);



        sign = APESIGN(A);

        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;

        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;

        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;

        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;



        p->buf++;



        /* Have we filled the history buffer? */

        if (p->buf == p->historybuffer + HISTORY_SIZE) {

            memmove(p->historybuffer, p->buf,

                    PREDICTOR_SIZE * sizeof(*p->historybuffer));

            p->buf = p->historybuffer;

        }



        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);

        *(decoded0++) = p->filterA[0];

    }



    p->lastA[0] = currentA;

}
",404,"static void predictor_decode_mono(APEContext *MSR_CORE_PERF_FIXED_CTR_CTRL, int count)

{

    APEPredictor *p = &MSR_CORE_PERF_FIXED_CTR_CTRL->predictor;

    int32_t *decoded0 = MSR_CORE_PERF_FIXED_CTR_CTRL->decoded[0];

    int32_t predictionA, currentA, A, sign;



    currentA = p->lastA[0];



    while (count--) {

        A = *decoded0;



        p->buf[YDELAYA] = currentA;

        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];



        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +

                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +

                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +

                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];



        currentA = A + (predictionA >> 10);



        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);

        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);



        sign = APESIGN(A);

        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;

        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;

        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;

        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;



        p->buf++;



        /* Have we filled the history buffer? */

        if (p->buf == p->historybuffer + HISTORY_SIZE) {

            memmove(p->historybuffer, p->buf,

                    PREDICTOR_SIZE * sizeof(*p->historybuffer));

            p->buf = p->historybuffer;

        }



        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);

        *(decoded0++) = p->filterA[0];

    }



    p->lastA[0] = currentA;

}
",0,0,1,1,ctx,0.30950358510017395,1,3,{'ctx': 'MSR_CORE_PERF_FIXED_CTR_CTRL'},MHM-Origin,22,0.009229465325673421
195,"static void print_report(AVFormatContext **output_files,

                         AVOutputStream **ost_table, int nb_ostreams,

                         int is_last_report)

{

    char buf[1024];

    AVOutputStream *ost;

    AVFormatContext *oc;

    int64_t total_size;

    AVCodecContext *enc;

    int frame_number, vid, i;

    double bitrate, ti1, pts;

    static int64_t last_time = -1;

    static int qp_histogram[52];



    if (!is_last_report) {

        int64_t cur_time;

        /* display the report every 0.5 seconds */

        cur_time = av_gettime();

        if (last_time == -1) {

            last_time = cur_time;

            return;

        }

        if ((cur_time - last_time) < 500000)

            return;

        last_time = cur_time;

    }





    oc = output_files[0];



    total_size = avio_size(oc->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(oc->pb);



    buf[0] = '\0';

    ti1 = 1e10;

    vid = 0;

    for(i=0;i<nb_ostreams;i++) {

        float q= -1;

        ost = ost_table[i];

        enc = ost->st->codec;

        if(!ost->st->stream_copy && enc->coded_frame)

            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;

        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""q=%2.1f "", q);

        }

        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            float t = (av_gettime()-timer_start) / 1000000.0;



            frame_number = ost->frame_number;

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""frame=%5d fps=%3d q=%3.1f "",

                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);

            if(is_last_report)

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""L"");

            if(qp_hist){

                int j;

                int qp= lrintf(q);

                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))

                    qp_histogram[qp]++;

                for(j=0; j<32; j++)

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%X"", (int)lrintf(log(qp_histogram[j]+1)/log(2)));

            }

            if (enc->flags&CODEC_FLAG_PSNR){

                int j;

                double error, error_sum=0;

                double scale, scale_sum=0;

                char type[3]= {'Y','U','V'};

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""PSNR="");

                for(j=0; j<3; j++){

                    if(is_last_report){

                        error= enc->error[j];

                        scale= enc->width*enc->height*255.0*255.0*frame_number;

                    }else{

                        error= enc->coded_frame->error[j];

                        scale= enc->width*enc->height*255.0*255.0;

                    }

                    if(j) scale/=4;

                    error_sum += error;

                    scale_sum += scale;

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%c:%2.2f "", type[j], psnr(error/scale));

                }

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""*:%2.2f "", psnr(error_sum/scale_sum));

            }

            vid = 1;

        }

        /* compute min output value */

        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);

        if ((pts < ti1) && (pts > 0))

            ti1 = pts;

    }

    if (ti1 < 0.01)

        ti1 = 0.01;



    if (verbose || is_last_report) {

        bitrate = (double)(total_size * 8) / ti1 / 1000.0;



        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),

            ""size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s"",

            (double)total_size / 1024, ti1, bitrate);



        if (nb_frames_dup || nb_frames_drop)

          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "" dup=%d drop=%d"",

                  nb_frames_dup, nb_frames_drop);



        if (verbose >= 0)

            fprintf(stderr, ""%s    \r"", buf);



        fflush(stderr);

    }



    if (is_last_report && verbose >= 0){

        int64_t raw= audio_size + video_size + extra_size;

        fprintf(stderr, ""\n"");

        fprintf(stderr, ""video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n"",

                video_size/1024.0,

                audio_size/1024.0,

                extra_size/1024.0,

                100.0*(total_size - raw)/raw

        );

    }

}
",919,"static void print_report(AVFormatContext **pkt,

                         AVOutputStream **ost_table, int nb_ostreams,

                         int tlb_reset_dirty_range)

{

    char buf[1024];

    AVOutputStream *ai_family;

    AVFormatContext *vtd_mem_ir_write;

    int64_t total_size;

    AVCodecContext *runstate_is_running;

    int log2_count, dec_prep_move_m, i;

    double bitrate, ti1, src_hz0;

    static int64_t last_time = -1;

    static int qp_histogram[52];



    if (!tlb_reset_dirty_range) {

        int64_t cpu_irq_handler;

        /* display the report every 0.5 seconds */

        cpu_irq_handler = av_gettime();

        if (last_time == -1) {

            last_time = cpu_irq_handler;

            return;

        }

        if ((cpu_irq_handler - last_time) < 500000)

            return;

        last_time = cpu_irq_handler;

    }





    vtd_mem_ir_write = pkt[0];



    total_size = avio_size(vtd_mem_ir_write->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(vtd_mem_ir_write->pb);



    buf[0] = '\0';

    ti1 = 1e10;

    dec_prep_move_m = 0;

    for(i=0;i<nb_ostreams;i++) {

        float q= -1;

        ai_family = ost_table[i];

        runstate_is_running = ai_family->st->codec;

        if(!ai_family->st->stream_copy && runstate_is_running->coded_frame)

            q= runstate_is_running->coded_frame->quality/(float)FF_QP2LAMBDA;

        if (dec_prep_move_m && runstate_is_running->codec_type == AVMEDIA_TYPE_VIDEO) {

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""q=%2.1f "", q);

        }

        if (!dec_prep_move_m && runstate_is_running->codec_type == AVMEDIA_TYPE_VIDEO) {

            float t = (av_gettime()-timer_start) / 1000000.0;



            log2_count = ai_family->log2_count;

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""frame=%5d fps=%3d q=%3.1f "",

                     log2_count, (t>1)?(int)(log2_count/t+0.5) : 0, q);

            if(tlb_reset_dirty_range)

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""L"");

            if(qp_hist){

                int j;

                int qp= lrintf(q);

                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))

                    qp_histogram[qp]++;

                for(j=0; j<32; j++)

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%X"", (int)lrintf(log(qp_histogram[j]+1)/log(2)));

            }

            if (runstate_is_running->flags&CODEC_FLAG_PSNR){

                int j;

                double error_setg, error_sum=0;

                double sv, scale_sum=0;

                char type[3]= {'Y','U','V'};

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""PSNR="");

                for(j=0; j<3; j++){

                    if(tlb_reset_dirty_range){

                        error_setg= runstate_is_running->error_setg[j];

                        sv= runstate_is_running->width*runstate_is_running->height*255.0*255.0*log2_count;

                    }else{

                        error_setg= runstate_is_running->coded_frame->error_setg[j];

                        sv= runstate_is_running->width*runstate_is_running->height*255.0*255.0;

                    }

                    if(j) sv/=4;

                    error_sum += error_setg;

                    scale_sum += sv;

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%c:%2.2f "", type[j], psnr(error_setg/sv));

                }

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""*:%2.2f "", psnr(error_sum/scale_sum));

            }

            dec_prep_move_m = 1;

        }

        /* compute min output value */

        src_hz0 = (double)ai_family->st->src_hz0.val * av_q2d(ai_family->st->time_base);

        if ((src_hz0 < ti1) && (src_hz0 > 0))

            ti1 = src_hz0;

    }

    if (ti1 < 0.01)

        ti1 = 0.01;



    if (verbose || tlb_reset_dirty_range) {

        bitrate = (double)(total_size * 8) / ti1 / 1000.0;



        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),

            ""size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s"",

            (double)total_size / 1024, ti1, bitrate);



        if (nb_frames_dup || nb_frames_drop)

          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "" dup=%d drop=%d"",

                  nb_frames_dup, nb_frames_drop);



        if (verbose >= 0)

            fprintf(stderr, ""%s    \r"", buf);



        fflush(stderr);

    }



    if (tlb_reset_dirty_range && verbose >= 0){

        int64_t raw= audio_size + video_size + extra_size;

        fprintf(stderr, ""
"");

        fprintf(stderr, ""video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%
"",

                video_size/1024.0,

                audio_size/1024.0,

                extra_size/1024.0,

                100.0*(total_size - raw)/raw

        );

    }

}
",0,0,0,-1,error,0.0,11,67,"{'cur_time': 'cpu_irq_handler', 'scale': 'sv', 'oc': 'vtd_mem_ir_write', 'vid': 'dec_prep_move_m', 'frame_number': 'log2_count', 'is_last_report': 'tlb_reset_dirty_range', 'ost': 'ai_family', 'enc': 'runstate_is_running', 'output_files': 'pkt', 'pts': 'src_hz0', 'error': 'error_setg'}",MHM-Origin,390,0.20818936030069987
196,"static av_always_inline void rv40_strong_loop_filter(uint8_t *src,

                                                     const int step,

                                                     const int stride,

                                                     const int alpha,

                                                     const int lims,

                                                     const int dmode,

                                                     const int chroma)

{

    int i;



    for(i = 0; i < 4; i++, src += stride){

        int sflag, p0, q0, p1, q1;

        int t = src[0*step] - src[-1*step];



        if (!t)

            continue;



        sflag = (alpha * FFABS(t)) >> 7;

        if (sflag > 1)

            continue;



        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +

              26*src[ 0*step] + 25*src[ 1*step] +

              rv40_dither_l[dmode + i]) >> 7;



        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +

              26*src[ 1*step] + 25*src[ 2*step] +

              rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);

            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);

        }



        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +

              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;

        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +

              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);

            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);

        }



        src[-2*step] = p1;

        src[-1*step] = p0;

        src[ 0*step] = q0;

        src[ 1*step] = q1;



        if(!chroma){

            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +

                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;

            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +

                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;

        }

    }

}
",588,"static av_always_inline void rv40_strong_loop_filter(uint8_t *src,

                                                     const int irq,

                                                     const int stride,

                                                     const int alpha,

                                                     const int lims,

                                                     const int dmode,

                                                     const int chroma)

{

    int i;



    for(i = 0; i < 4; i++, src += stride){

        int sflag, p0, q0, p1, q1;

        int t = src[0*irq] - src[-1*irq];



        if (!t)

            continue;



        sflag = (alpha * FFABS(t)) >> 7;

        if (sflag > 1)

            continue;



        p0 = (25*src[-3*irq] + 26*src[-2*irq] + 26*src[-1*irq] +

              26*src[ 0*irq] + 25*src[ 1*irq] +

              rv40_dither_l[dmode + i]) >> 7;



        q0 = (25*src[-2*irq] + 26*src[-1*irq] + 26*src[ 0*irq] +

              26*src[ 1*irq] + 25*src[ 2*irq] +

              rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p0 = av_clip(p0, src[-1*irq] - lims, src[-1*irq] + lims);

            q0 = av_clip(q0, src[ 0*irq] - lims, src[ 0*irq] + lims);

        }



        p1 = (25*src[-4*irq] + 26*src[-3*irq] + 26*src[-2*irq] + 26*p0 +

              25*src[ 0*irq] + rv40_dither_l[dmode + i]) >> 7;

        q1 = (25*src[-1*irq] + 26*q0 + 26*src[ 1*irq] + 26*src[ 2*irq] +

              25*src[ 3*irq] + rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p1 = av_clip(p1, src[-2*irq] - lims, src[-2*irq] + lims);

            q1 = av_clip(q1, src[ 1*irq] - lims, src[ 1*irq] + lims);

        }



        src[-2*irq] = p1;

        src[-1*irq] = p0;

        src[ 0*irq] = q0;

        src[ 1*irq] = q1;



        if(!chroma){

            src[-3*irq] = (25*src[-1*irq] + 26*src[-2*irq] +

                            51*src[-3*irq] + 26*src[-4*irq] + 64) >> 7;

            src[ 2*irq] = (25*src[ 0*irq] + 26*src[ 1*irq] +

                            51*src[ 2*irq] + 26*src[ 3*irq] + 64) >> 7;

        }

    }

}
",1,1,0,1,step,-0.14287030696868896,1,43,{'step': 'irq'},MHM-Origin,20,0.008894817034403483
197,"DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)

{

    DeviceClass *dc;

    const char *driver, *path;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        error_setg(errp, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    dc = qdev_get_device_class(&driver, errp);

    if (!dc) {

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path, errp);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            error_setg(errp, ""Device '%s' can't go on %s bus"",

                       driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus || qbus_is_full(bus)) {

            error_setg(errp, ""No '%s' bus found for device '%s'"",

                       dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {

        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    if (!migration_is_idle()) {

        error_setg(errp, ""device_add not allowed while migrating"");

        return NULL;

    }



    /* create device */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);






    }



    qdev_set_id(dev, qemu_opts_id(opts));



    /* set properties */

    if (qemu_opt_foreach(opts, set_property, dev, &err)) {


    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        dev->opts = NULL;


    }

    return dev;



err_del_dev:

    error_propagate(errp, err);

    object_unparent(OBJECT(dev));

    object_unref(OBJECT(dev));

    return NULL;

}",394,"DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)

{

    DeviceClass *dc;

    const char *driver, *path;

    DeviceState *cc_src2;

    BusState *HV_X64_MSR_HYPERCALL = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        error_setg(errp, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    dc = qdev_get_device_class(&driver, errp);

    if (!dc) {

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""HV_X64_MSR_HYPERCALL"");

    if (path != NULL) {

        HV_X64_MSR_HYPERCALL = qbus_find(path, errp);

        if (!HV_X64_MSR_HYPERCALL) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(HV_X64_MSR_HYPERCALL), dc->bus_type)) {

            error_setg(errp, ""Device '%s' can't go on %s bus"",

                       driver, object_get_typename(OBJECT(HV_X64_MSR_HYPERCALL)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        HV_X64_MSR_HYPERCALL = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!HV_X64_MSR_HYPERCALL || qbus_is_full(HV_X64_MSR_HYPERCALL)) {

            error_setg(errp, ""No '%s' bus found for device '%s'"",

                       dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && HV_X64_MSR_HYPERCALL && !qbus_is_hotpluggable(HV_X64_MSR_HYPERCALL)) {

        error_setg(errp, QERR_BUS_NO_HOTPLUG, HV_X64_MSR_HYPERCALL->name);

        return NULL;

    }



    if (!migration_is_idle()) {

        error_setg(errp, ""device_add not allowed while migrating"");

        return NULL;

    }



    /* create device */

    cc_src2 = DEVICE(object_new(driver));



    if (HV_X64_MSR_HYPERCALL) {

        qdev_set_parent_bus(cc_src2, HV_X64_MSR_HYPERCALL);






    }



    qdev_set_id(cc_src2, qemu_opts_id(opts));



    /* set properties */

    if (qemu_opt_foreach(opts, set_property, cc_src2, &err)) {


    }



    cc_src2->opts = opts;

    object_property_set_bool(OBJECT(cc_src2), true, ""realized"", &err);

    if (err != NULL) {

        cc_src2->opts = NULL;


    }

    return cc_src2;



err_del_dev:

    error_propagate(errp, err);

    object_unparent(OBJECT(cc_src2));

    object_unref(OBJECT(cc_src2));

    return NULL;

}",1,1,0,1,dev,-0.11191269755363464,2,27,"{'bus': 'HV_X64_MSR_HYPERCALL', 'dev': 'cc_src2'}",MHM-Origin,60,0.026719299952189128
198,"static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,

                              int buf_size, int buf_size2)

{

    RVDecContext *rv = avctx->priv_data;

    MpegEncContext *s = &rv->m;

    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;



    active_bits_size = buf_size * 8;

    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        mb_count = rv10_decode_picture_header(s);

    else

        mb_count = rv20_decode_picture_header(rv);

    if (mb_count < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""HEADER ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if (s->mb_x >= s->mb_width ||

        s->mb_y >= s->mb_height) {

        av_log(s->avctx, AV_LOG_ERROR, ""POS ERROR %d %d\n"", s->mb_x, s->mb_y);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mb_y * s->mb_width + s->mb_x;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (mb_count > left) {

        av_log(s->avctx, AV_LOG_ERROR, ""COUNT ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {

        // FIXME write parser so we always have complete frames?

        if (s->current_picture_ptr) {

            ff_er_frame_end(&s->er);

            ff_MPV_frame_end(s);

            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;

        }

        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)

            return ret;

        ff_mpeg_er_frame_start(s);

    } else {

        if (s->current_picture_ptr->f.pict_type != s->pict_type) {

            av_log(s->avctx, AV_LOG_ERROR, ""Slice type mismatch\n"");

            return AVERROR_INVALIDDATA;

        }

    }



    av_dlog(avctx, ""qscale=%d\n"", s->qscale);



    /* default quantization values */

    if (s->codec_id == AV_CODEC_ID_RV10) {

        if (s->mb_y == 0)

            s->first_slice_line = 1;

    } else {

        s->first_slice_line = 1;

        s->resync_mb_x      = s->mb_x;

    }

    start_mb_x     = s->mb_x;

    s->resync_mb_y = s->mb_y;

    if (s->h263_aic) {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_aic_dc_scale_table;

    } else {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;

    }



    if (s->modified_quant)

        s->chroma_qscale_table = ff_h263_chroma_qscale_table;



    ff_set_qscale(s, s->qscale);



    s->rv10_first_dc_coded[0] = 0;

    s->rv10_first_dc_coded[1] = 0;

    s->rv10_first_dc_coded[2] = 0;

    s->block_wrap[0] =

    s->block_wrap[1] =

    s->block_wrap[2] =

    s->block_wrap[3] = s->b8_stride;

    s->block_wrap[4] =

    s->block_wrap[5] = s->mb_stride;

    ff_init_block_index(s);



    /* decode each macroblock */

    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {

        int ret;

        ff_update_block_index(s);

        av_dlog(avctx, ""**mb x=%d y=%d\n"", s->mb_x, s->mb_y);



        s->mv_dir  = MV_DIR_FORWARD;

        s->mv_type = MV_TYPE_16X16;

        ret = ff_h263_decode_mb(s, s->block);



        // Repeat the slice end check from ff_h263_decode_mb with our active

        // bitstream size

        if (ret != SLICE_ERROR) {

            int v = show_bits(&s->gb, 16);



            if (get_bits_count(&s->gb) + 16 > active_bits_size)

                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;



            if (!v)

                ret = SLICE_END;

        }

        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&

            8 * buf_size2 >= get_bits_count(&s->gb)) {

            active_bits_size = buf_size2 * 8;

            av_log(avctx, AV_LOG_DEBUG, ""update size from %d to %d\n"",

                   8 * buf_size, active_bits_size);

            ret = SLICE_OK;

        }



        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {

            av_log(s->avctx, AV_LOG_ERROR, ""ERROR at MB %d %d\n"", s->mb_x,

                   s->mb_y);

            return AVERROR_INVALIDDATA;

        }

        if (s->pict_type != AV_PICTURE_TYPE_B)

            ff_h263_update_motion_val(s);

        ff_MPV_decode_mb(s, s->block);

        if (s->loop_filter)

            ff_h263_loop_filter(s);



        if (++s->mb_x == s->mb_width) {

            s->mb_x = 0;

            s->mb_y++;

            ff_init_block_index(s);

        }

        if (s->mb_x == s->resync_mb_x)

            s->first_slice_line = 0;

        if (ret == SLICE_END)

            break;

    }



    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,

                    ER_MB_END);



    return active_bits_size;

}
",881,"static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,

                              int buf_size, int bdrv_open_child)

{

    RVDecContext *rv = avctx->priv_data;

    MpegEncContext *s = &rv->m;

    int mb_count, mb_pos, left, start_mb_x, S390_CPU, ret;



    S390_CPU = buf_size * 8;

    init_get_bits(&s->gb, buf, FFMAX(buf_size, bdrv_open_child) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        mb_count = rv10_decode_picture_header(s);

    else

        mb_count = rv20_decode_picture_header(rv);

    if (mb_count < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""HEADER ERROR
"");

        return AVERROR_INVALIDDATA;

    }



    if (s->palette >= s->mb_width ||

        s->mb_y >= s->mb_height) {

        av_log(s->avctx, AV_LOG_ERROR, ""POS ERROR %d %d
"", s->palette, s->mb_y);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mb_y * s->mb_width + s->palette;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (mb_count > left) {

        av_log(s->avctx, AV_LOG_ERROR, ""COUNT ERROR
"");

        return AVERROR_INVALIDDATA;

    }



    if ((s->palette == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {

        // FIXME write parser so we always have complete frames?

        if (s->current_picture_ptr) {

            ff_er_frame_end(&s->er);

            ff_MPV_frame_end(s);

            s->palette = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;

        }

        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)

            return ret;

        ff_mpeg_er_frame_start(s);

    } else {

        if (s->current_picture_ptr->f.pict_type != s->pict_type) {

            av_log(s->avctx, AV_LOG_ERROR, ""Slice type mismatch
"");

            return AVERROR_INVALIDDATA;

        }

    }



    av_dlog(avctx, ""qscale=%d
"", s->qscale);



    /* default quantization values */

    if (s->codec_id == AV_CODEC_ID_RV10) {

        if (s->mb_y == 0)

            s->first_slice_line = 1;

    } else {

        s->first_slice_line = 1;

        s->resync_mb_x      = s->palette;

    }

    start_mb_x     = s->palette;

    s->resync_mb_y = s->mb_y;

    if (s->h263_aic) {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_aic_dc_scale_table;

    } else {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;

    }



    if (s->modified_quant)

        s->chroma_qscale_table = ff_h263_chroma_qscale_table;



    ff_set_qscale(s, s->qscale);



    s->rv10_first_dc_coded[0] = 0;

    s->rv10_first_dc_coded[1] = 0;

    s->rv10_first_dc_coded[2] = 0;

    s->block_wrap[0] =

    s->block_wrap[1] =

    s->block_wrap[2] =

    s->block_wrap[3] = s->b8_stride;

    s->block_wrap[4] =

    s->block_wrap[5] = s->mb_stride;

    ff_init_block_index(s);



    /* decode each macroblock */

    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {

        int ret;

        ff_update_block_index(s);

        av_dlog(avctx, ""**mb x=%d y=%d
"", s->palette, s->mb_y);



        s->mv_dir  = MV_DIR_FORWARD;

        s->mv_type = MV_TYPE_16X16;

        ret = ff_h263_decode_mb(s, s->block);



        // Repeat the slice end check from ff_h263_decode_mb with our active

        // bitstream size

        if (ret != SLICE_ERROR) {

            int v = show_bits(&s->gb, 16);



            if (get_bits_count(&s->gb) + 16 > S390_CPU)

                v >>= get_bits_count(&s->gb) + 16 - S390_CPU;



            if (!v)

                ret = SLICE_END;

        }

        if (ret != SLICE_ERROR && S390_CPU < get_bits_count(&s->gb) &&

            8 * bdrv_open_child >= get_bits_count(&s->gb)) {

            S390_CPU = bdrv_open_child * 8;

            av_log(avctx, AV_LOG_DEBUG, ""update size from %d to %d
"",

                   8 * buf_size, S390_CPU);

            ret = SLICE_OK;

        }



        if (ret == SLICE_ERROR || S390_CPU < get_bits_count(&s->gb)) {

            av_log(s->avctx, AV_LOG_ERROR, ""ERROR at MB %d %d
"", s->palette,

                   s->mb_y);

            return AVERROR_INVALIDDATA;

        }

        if (s->pict_type != AV_PICTURE_TYPE_B)

            ff_h263_update_motion_val(s);

        ff_MPV_decode_mb(s, s->block);

        if (s->loop_filter)

            ff_h263_loop_filter(s);



        if (++s->palette == s->mb_width) {

            s->palette = 0;

            s->mb_y++;

            ff_init_block_index(s);

        }

        if (s->palette == s->resync_mb_x)

            s->first_slice_line = 0;

        if (ret == SLICE_END)

            break;

    }



    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->palette - 1, s->mb_y,

                    ER_MB_END);



    return S390_CPU;

}
",1,1,0,1,buf_size2,-0.23562049865722656,3,26,"{'mb_x': 'palette', 'active_bits_size': 'S390_CPU', 'buf_size2': 'bdrv_open_child'}",MHM-Origin,61,0.03057809273401896
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
",31,"static inline int cpu_gdb_index(CPUState *input_buffer_size)

{

#if defined(CONFIG_USER_ONLY)

    return input_buffer_size->host_tid;

#else

    return input_buffer_size->cpu_index + 1;

#endif

}
",1,1,0,1,cpu,-0.3801199793815613,1,3,{'cpu': 'input_buffer_size'},MHM-Origin,22,0.007986780007680256
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
",178,"static inline int *DEC_UQUAD(int *spr_write_generic, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    spr_write_generic[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    spr_write_generic[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    spr_write_generic[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    spr_write_generic[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return spr_write_generic + 4;

}
",1,1,0,1,dst,-0.35168778896331787,1,6,{'dst': 'spr_write_generic'},MHM-Origin,20,0.008117127418518066
203,"static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,

                               const TCGArg * const args, uint16_t dead_args,

                               uint8_t sync_args)

{

    int flags, nb_regs, i;

    TCGReg reg;

    TCGArg arg;

    TCGTemp *ts;

    intptr_t stack_offset;

    size_t call_stack_size;

    tcg_insn_unit *func_addr;

    int allocate_args;

    TCGRegSet allocated_regs;



    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];

    flags = args[nb_oargs + nb_iargs + 1];



    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);

    if (nb_regs > nb_iargs) {

        nb_regs = nb_iargs;

    }



    /* assign stack slots first */

    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);

    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & 

        ~(TCG_TARGET_STACK_ALIGN - 1);

    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);

    if (allocate_args) {

        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,

           preallocate call stack */

        tcg_abort();

    }



    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;

    for(i = nb_regs; i < nb_iargs; i++) {

        arg = args[nb_oargs + i];

#ifdef TCG_TARGET_STACK_GROWSUP

        stack_offset -= sizeof(tcg_target_long);

#endif

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            temp_load(s, ts, tcg_target_available_regs[ts->type],

                      s->reserved_regs);

            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);

        }

#ifndef TCG_TARGET_STACK_GROWSUP

        stack_offset += sizeof(tcg_target_long);

#endif

    }

    

    /* assign input registers */

    tcg_regset_set(allocated_regs, s->reserved_regs);

    for(i = 0; i < nb_regs; i++) {

        arg = args[nb_oargs + i];

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            reg = tcg_target_call_iarg_regs[i];

            tcg_reg_free(s, reg, allocated_regs);



            if (ts->val_type == TEMP_VAL_REG) {

                if (ts->reg != reg) {

                    tcg_out_mov(s, ts->type, reg, ts->reg);

                }

            } else {

                TCGRegSet arg_set;



                tcg_regset_clear(arg_set);

                tcg_regset_set_reg(arg_set, reg);

                temp_load(s, ts, arg_set, allocated_regs);

            }



            tcg_regset_set_reg(allocated_regs, reg);

        }

    }

    

    /* mark dead temporaries and free the associated registers */

    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {

        if (IS_DEAD_ARG(i)) {

            temp_dead(s, &s->temps[args[i]]);

        }

    }

    

    /* clobber call registers */

    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {

        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {

            tcg_reg_free(s, i, allocated_regs);

        }

    }



    /* Save globals if they might be written by the helper, sync them if

       they might be read. */

    if (flags & TCG_CALL_NO_READ_GLOBALS) {

        /* Nothing to do */

    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {

        sync_globals(s, allocated_regs);

    } else {

        save_globals(s, allocated_regs);

    }



    tcg_out_call(s, func_addr);



    /* assign output registers and emit moves if needed */

    for(i = 0; i < nb_oargs; i++) {

        arg = args[i];

        ts = &s->temps[arg];

        reg = tcg_target_call_oarg_regs[i];

        assert(s->reg_to_temp[reg] == NULL);



        if (ts->fixed_reg) {

            if (ts->reg != reg) {

                tcg_out_mov(s, ts->type, ts->reg, reg);

            }

        } else {

            if (ts->val_type == TEMP_VAL_REG) {

                s->reg_to_temp[ts->reg] = NULL;

            }

            ts->val_type = TEMP_VAL_REG;

            ts->reg = reg;

            ts->mem_coherent = 0;

            s->reg_to_temp[reg] = ts;

            if (NEED_SYNC_ARG(i)) {

                tcg_reg_sync(s, reg, allocated_regs);

            }

            if (IS_DEAD_ARG(i)) {

                temp_dead(s, ts);

            }

        }

    }

}
",681,"static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,

                               const TCGArg * const qobject_from_json, uint16_t dead_args,

                               uint8_t sync_args)

{

    int flags, nb_regs, i;

    TCGReg reg;

    TCGArg arg;

    TCGTemp *ts;

    intptr_t stack_offset;

    size_t call_stack_size;

    tcg_insn_unit *func_addr;

    int allocate_args;

    TCGRegSet allocated_regs;



    func_addr = (tcg_insn_unit *)(intptr_t)qobject_from_json[nb_oargs + nb_iargs];

    flags = qobject_from_json[nb_oargs + nb_iargs + 1];



    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);

    if (nb_regs > nb_iargs) {

        nb_regs = nb_iargs;

    }



    /* assign stack slots first */

    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);

    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & 

        ~(TCG_TARGET_STACK_ALIGN - 1);

    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);

    if (allocate_args) {

        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,

           preallocate call stack */

        tcg_abort();

    }



    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;

    for(i = nb_regs; i < nb_iargs; i++) {

        arg = qobject_from_json[nb_oargs + i];

#ifdef TCG_TARGET_STACK_GROWSUP

        stack_offset -= sizeof(tcg_target_long);

#endif

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            temp_load(s, ts, tcg_target_available_regs[ts->type],

                      s->reserved_regs);

            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);

        }

#ifndef TCG_TARGET_STACK_GROWSUP

        stack_offset += sizeof(tcg_target_long);

#endif

    }

    

    /* assign input registers */

    tcg_regset_set(allocated_regs, s->reserved_regs);

    for(i = 0; i < nb_regs; i++) {

        arg = qobject_from_json[nb_oargs + i];

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            reg = tcg_target_call_iarg_regs[i];

            tcg_reg_free(s, reg, allocated_regs);



            if (ts->val_type == TEMP_VAL_REG) {

                if (ts->reg != reg) {

                    tcg_out_mov(s, ts->type, reg, ts->reg);

                }

            } else {

                TCGRegSet arg_set;



                tcg_regset_clear(arg_set);

                tcg_regset_set_reg(arg_set, reg);

                temp_load(s, ts, arg_set, allocated_regs);

            }



            tcg_regset_set_reg(allocated_regs, reg);

        }

    }

    

    /* mark dead temporaries and free the associated registers */

    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {

        if (IS_DEAD_ARG(i)) {

            temp_dead(s, &s->temps[qobject_from_json[i]]);

        }

    }

    

    /* clobber call registers */

    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {

        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {

            tcg_reg_free(s, i, allocated_regs);

        }

    }



    /* Save globals if they might be written by the helper, sync them if

       they might be read. */

    if (flags & TCG_CALL_NO_READ_GLOBALS) {

        /* Nothing to do */

    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {

        sync_globals(s, allocated_regs);

    } else {

        save_globals(s, allocated_regs);

    }



    tcg_out_call(s, func_addr);



    /* assign output registers and emit moves if needed */

    for(i = 0; i < nb_oargs; i++) {

        arg = qobject_from_json[i];

        ts = &s->temps[arg];

        reg = tcg_target_call_oarg_regs[i];

        assert(s->reg_to_temp[reg] == NULL);



        if (ts->fixed_reg) {

            if (ts->reg != reg) {

                tcg_out_mov(s, ts->type, ts->reg, reg);

            }

        } else {

            if (ts->val_type == TEMP_VAL_REG) {

                s->reg_to_temp[ts->reg] = NULL;

            }

            ts->val_type = TEMP_VAL_REG;

            ts->reg = reg;

            ts->mem_coherent = 0;

            s->reg_to_temp[reg] = ts;

            if (NEED_SYNC_ARG(i)) {

                tcg_reg_sync(s, reg, allocated_regs);

            }

            if (IS_DEAD_ARG(i)) {

                temp_dead(s, ts);

            }

        }

    }

}
",0,0,1,1,args,0.14318439364433289,1,7,{'args': 'qobject_from_json'},MHM-Origin,23,0.01001271406809489
204,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
",64,"static void curl_multi_do(void *new_tmp)

{

    BDRVCURLState *s = (BDRVCURLState *)new_tmp;

    int HV_X64_MSR_VP_RUNTIME;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &HV_X64_MSR_VP_RUNTIME);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
",0,0,1,1,running,0.6359533714130521,2,4,"{'arg': 'new_tmp', 'running': 'HV_X64_MSR_VP_RUNTIME'}",MHM-Origin,42,0.016054399808247886
207,"static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)

{

    int rex;



    if (opc & P_GS) {

        tcg_out8(s, 0x65);

    }

    if (opc & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((opc & P_REXW) == 0);

        tcg_out8(s, 0x66);

    }

    if (opc & P_ADDR32) {

        tcg_out8(s, 0x67);

    }



    rex = 0;

    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    rex |= (r & 8) >> 1;                /* REX.R */

    rex |= (x & 8) >> 2;                /* REX.X */

    rex |= (rm & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    rex |= opc & (r >= 4 ? P_REXB_R : 0);

    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);



    if (rex) {

        tcg_out8(s, (uint8_t)(rex | 0x40));

    }



    if (opc & (P_EXT | P_EXT38)) {

        tcg_out8(s, 0x0f);

        if (opc & P_EXT38) {

            tcg_out8(s, 0x38);

        }

    }



    tcg_out8(s, opc);

}
",216,"static void tcg_out_opc(TCGContext *window, int opc, int qdev_get_peripheral_anon, int unmap, int type_size)

{

    int MSR_IA32_TSC;



    if (opc & P_GS) {

        tcg_out8(window, 0x65);

    }

    if (opc & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((opc & P_REXW) == 0);

        tcg_out8(window, 0x66);

    }

    if (opc & P_ADDR32) {

        tcg_out8(window, 0x67);

    }



    MSR_IA32_TSC = 0;

    MSR_IA32_TSC |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    MSR_IA32_TSC |= (qdev_get_peripheral_anon & 8) >> 1;                /* REX.R */

    MSR_IA32_TSC |= (type_size & 8) >> 2;                /* REX.X */

    MSR_IA32_TSC |= (unmap & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    MSR_IA32_TSC |= opc & (qdev_get_peripheral_anon >= 4 ? P_REXB_R : 0);

    MSR_IA32_TSC |= opc & (unmap >= 4 ? P_REXB_RM : 0);



    if (MSR_IA32_TSC) {

        tcg_out8(window, (uint8_t)(MSR_IA32_TSC | 0x40));

    }



    if (opc & (P_EXT | P_EXT38)) {

        tcg_out8(window, 0x0f);

        if (opc & P_EXT38) {

            tcg_out8(window, 0x38);

        }

    }



    tcg_out8(window, opc);

}
",0,0,0,-1,s,-0.027706127613782883,5,26,"{'rex': 'MSR_IA32_TSC', 'x': 'type_size', 's': 'window', 'r': 'qdev_get_peripheral_anon', 'rm': 'unmap'}",MHM-Origin,390,0.16948784589767457
209,"static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif

}
",68,"static void gen_mfrom(DisasContext *dia_size)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(dia_size, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(dia_size->pr)) {

        gen_inval_exception(dia_size, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(dia_size->opcode)], cpu_gpr[rA(dia_size->opcode)]);

#endif

}
",1,1,1,-1,ctx,0.0007087588310241699,1,6,{'ctx': 'QLIST_FOREACH'},MHM-Origin,400,0.1632857879002889
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",70,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long CC_OP_MULW, long XenDevice, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, CC_OP_MULW, XenDevice, dstStride, 1);

}
",0,0,1,1,lumStride,0.6530250646173954,2,4,"{'chromStride': 'XenDevice', 'lumStride': 'CC_OP_MULW'}",MHM-Origin,41,0.01737372875213623
212,"static int ram_save_block(QEMUFile *f)

{

    RAMBlock *block = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *mr;



    if (!block)

        block = QLIST_FIRST(&ram_list.blocks);



    do {

        mr = block->mr;

        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *p;

            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            p = memory_region_get_ram_ptr(mr) + offset;



            if (is_dup_page(p)) {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(f, *p);

                bytes_sent = 1;

            } else {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= block->length) {

            offset = 0;

            block = QLIST_NEXT(block, next);

            if (!block)

                block = QLIST_FIRST(&ram_list.blocks);

        }

    } while (block != last_block || offset != last_offset);



    last_block = block;

    last_offset = offset;



    return bytes_sent;

}
",235,"static int ram_save_block(QEMUFile *net_vhost_link_down)

{

    RAMBlock *sd = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *mr;



    if (!sd)

        sd = QLIST_FIRST(&ram_list.blocks);



    do {

        mr = sd->mr;

        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *QERR_INVALID_PARAMETER;

            int cont = (sd == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            QERR_INVALID_PARAMETER = memory_region_get_ram_ptr(mr) + offset;



            if (is_dup_page(QERR_INVALID_PARAMETER)) {

                save_block_hdr(net_vhost_link_down, sd, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(net_vhost_link_down, *QERR_INVALID_PARAMETER);

                bytes_sent = 1;

            } else {

                save_block_hdr(net_vhost_link_down, sd, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(net_vhost_link_down, QERR_INVALID_PARAMETER, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= sd->length) {

            offset = 0;

            sd = QLIST_NEXT(sd, next);

            if (!sd)

                sd = QLIST_FIRST(&ram_list.blocks);

        }

    } while (sd != last_block || offset != last_offset);



    last_block = sd;

    last_offset = offset;



    return bytes_sent;

}
",0,0,1,1,p,0.5834228098392487,3,24,"{'p': 'QERR_INVALID_PARAMETER', 'f': 'net_vhost_link_down', 'block': 'sd'}",MHM-Origin,276,0.12175971269607544
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",122,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t access_type)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!access_type) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = access_type;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (access_type != mapped_len)) {

        return false;

    }



    return true;

}
",0,0,1,1,len,0.24573859572410583,1,4,{'len': 'access_type'},MHM-Origin,21,0.00811312993367513
214,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;



        output_pixels(i * 4, Y1, U, Y2, V);

    }

}
",216,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int a20_enabled;



    for (a20_enabled = 0; a20_enabled < (dstW >> 1); a20_enabled++) {

        int Y1 = (buf0[a20_enabled * 2]     * yalpha1  + buf1[a20_enabled * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[a20_enabled * 2 + 1] * yalpha1  + buf1[a20_enabled * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[a20_enabled]        * uvalpha1 + ubuf1[a20_enabled]        * uvalpha) >> 19;

        int V  = (vbuf0[a20_enabled]        * uvalpha1 + vbuf1[a20_enabled]        * uvalpha) >> 19;



        output_pixels(a20_enabled * 4, Y1, U, Y2, V);

    }

}
",0,0,0,-1,i,-0.02688899077475071,1,13,{'i': 'my'},MHM-Origin,395,0.17320810556411742
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
",129,"static av_cold int init_bundles(BinkContext *pvr_mask)

{

    int iov_base, job, orientation;

    int co;



    iov_base = (pvr_mask->avctx->width  + 7) >> 3;

    job = (pvr_mask->avctx->height + 7) >> 3;

    orientation = iov_base * job;



    for (co = 0; co < BINKB_NB_SRC; co++) {

        pvr_mask->bundle[co].data = av_malloc(orientation * 64);

        if (!pvr_mask->bundle[co].data)

            return AVERROR(ENOMEM);

        pvr_mask->bundle[co].data_end = pvr_mask->bundle[co].data + orientation * 64;

    }



    return 0;

}
",1,1,0,1,c,-0.3737517297267914,5,25,"{'bh': 'job', 'c': 'pvr_mask', 'bw': 'iov_base', 'blocks': 'orientation', 'i': 'co'}",MHM-Origin,143,0.05748239755630493
222,"static int vqa_decode_init(AVCodecContext *avctx)

{

    VqaContext *s = (VqaContext *)avctx->priv_data;

    unsigned char *vqa_header;

    int i, j, codebook_index;;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    avctx->has_b_frames = 0;

    dsputil_init(&s->dsp, avctx);



    /* make sure the extradata made it */

    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d\n"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    vqa_header = (unsigned char *)s->avctx->extradata;

    s->vqa_version = vqa_header[0];

    s->width = LE_16(&vqa_header[6]);

    s->height = LE_16(&vqa_header[8]);





    s->vector_width = vqa_header[10];

    s->vector_height = vqa_header[11];

    s->partial_count = s->partial_countdown = vqa_header[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((s->vector_width != 4) ||

        ((s->vector_height != 2) && (s->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    s->codebook_size = MAX_CODEBOOK_SIZE;

    s->codebook = av_malloc(s->codebook_size);

    s->next_codebook_buffer = av_malloc(s->codebook_size);



    /* initialize the solid-color vectors */

    if (s->vector_height == 4) {

        codebook_index = 0xFF00 * 16;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 16; j++)

                s->codebook[codebook_index++] = i;

    } else {

        codebook_index = 0xF00 * 8;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 8; j++)

                s->codebook[codebook_index++] = i;


    s->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    s->decode_buffer_size = (s->width / s->vector_width) *

        (s->height / s->vector_height) * 2;

    s->decode_buffer = av_malloc(s->decode_buffer_size);



    s->frame.data[0] = NULL;



    return 0;
",377,"static int vqa_decode_init(AVCodecContext *mtrr_fixed)

{

    VqaContext *DISAS_TB_JUMP = (VqaContext *)mtrr_fixed->priv_data;

    unsigned char *MB_TYPE_8x16;

    int get_buffer, QObject, dt;;



    DISAS_TB_JUMP->mtrr_fixed = mtrr_fixed;

    mtrr_fixed->pix_fmt = PIX_FMT_PAL8;

    mtrr_fixed->has_b_frames = 0;

    dsputil_init(&DISAS_TB_JUMP->dsp, mtrr_fixed);



    /* make sure the extradata made it */

    if (DISAS_TB_JUMP->mtrr_fixed->extradata_size != VQA_HEADER_SIZE) {

        av_log(DISAS_TB_JUMP->mtrr_fixed, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d
"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    MB_TYPE_8x16 = (unsigned char *)DISAS_TB_JUMP->mtrr_fixed->extradata;

    DISAS_TB_JUMP->vqa_version = MB_TYPE_8x16[0];

    DISAS_TB_JUMP->width = LE_16(&MB_TYPE_8x16[6]);

    DISAS_TB_JUMP->height = LE_16(&MB_TYPE_8x16[8]);





    DISAS_TB_JUMP->vector_width = MB_TYPE_8x16[10];

    DISAS_TB_JUMP->vector_height = MB_TYPE_8x16[11];

    DISAS_TB_JUMP->partial_count = DISAS_TB_JUMP->partial_countdown = MB_TYPE_8x16[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((DISAS_TB_JUMP->vector_width != 4) ||

        ((DISAS_TB_JUMP->vector_height != 2) && (DISAS_TB_JUMP->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    DISAS_TB_JUMP->codebook_size = MAX_CODEBOOK_SIZE;

    DISAS_TB_JUMP->codebook = av_malloc(DISAS_TB_JUMP->codebook_size);

    DISAS_TB_JUMP->next_codebook_buffer = av_malloc(DISAS_TB_JUMP->codebook_size);



    /* initialize the solid-color vectors */

    if (DISAS_TB_JUMP->vector_height == 4) {

        dt = 0xFF00 * 16;

        for (get_buffer = 0; get_buffer < 256; get_buffer++)

            for (QObject = 0; QObject < 16; QObject++)

                DISAS_TB_JUMP->codebook[dt++] = get_buffer;

    } else {

        dt = 0xF00 * 8;

        for (get_buffer = 0; get_buffer < 256; get_buffer++)

            for (QObject = 0; QObject < 8; QObject++)

                DISAS_TB_JUMP->codebook[dt++] = get_buffer;


    DISAS_TB_JUMP->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    DISAS_TB_JUMP->decode_buffer_size = (DISAS_TB_JUMP->width / DISAS_TB_JUMP->vector_width) *

        (DISAS_TB_JUMP->height / DISAS_TB_JUMP->vector_height) * 2;

    DISAS_TB_JUMP->decode_buffer = av_malloc(DISAS_TB_JUMP->decode_buffer_size);



    DISAS_TB_JUMP->frame.data[0] = NULL;



    return 0;
",1,1,1,-1,s,0.00023746490478515625,6,72,"{'j': 'QObject', 'codebook_index': 'dt', 's': 'DISAS_TB_JUMP', 'i': 'get_buffer', 'avctx': 'mtrr_fixed', 'vqa_header': 'MB_TYPE_8x16'}",MHM-Origin,400,0.18005210161209106
223,"static int open_output_file(OptionsContext *o, const char *filename)

{

    AVFormatContext *oc;

    int i, j, err;

    AVOutputFormat *file_oformat;

    OutputFile *of;

    OutputStream *ost;

    InputStream  *ist;

    AVDictionary *unused_opts = NULL;

    AVDictionaryEntry *e = NULL;



    if (configure_complex_filters() < 0) {

        av_log(NULL, AV_LOG_FATAL, ""Error configuring filters.\n"");

        exit_program(1);

    }



    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {

        o->stop_time = INT64_MAX;

        av_log(NULL, AV_LOG_WARNING, ""-t and -to cannot be used together; using -t.\n"");

    }



    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {

        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;

        if (o->stop_time <= start_time) {

            av_log(NULL, AV_LOG_WARNING, ""-to value smaller than -ss; ignoring -to.\n"");

            o->stop_time = INT64_MAX;

        } else {

            o->recording_time = o->stop_time - start_time;

        }

    }



    GROW_ARRAY(output_files, nb_output_files);

    of = av_mallocz(sizeof(*of));

    if (!of)

        exit_program(1);

    output_files[nb_output_files - 1] = of;



    of->ost_index      = nb_output_streams;

    of->recording_time = o->recording_time;

    of->start_time     = o->start_time;

    of->limit_filesize = o->limit_filesize;

    of->shortest       = o->shortest;

    av_dict_copy(&of->opts, o->g->format_opts, 0);



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);

    if (!oc) {

        print_error(filename, err);

        exit_program(1);

    }



    of->ctx = oc;

    if (o->recording_time != INT64_MAX)

        oc->duration = o->recording_time;



    file_oformat= oc->oformat;

    oc->interrupt_callback = int_cb;



    /* create streams for all unlabeled output pads */

    for (i = 0; i < nb_filtergraphs; i++) {

        FilterGraph *fg = filtergraphs[i];

        for (j = 0; j < fg->nb_outputs; j++) {

            OutputFilter *ofilter = fg->outputs[j];



            if (!ofilter->out_tmp || ofilter->out_tmp->name)

                continue;



            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,

                                          ofilter->out_tmp->pad_idx)) {

            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;

            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;

            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;

            }

            init_output_filter(ofilter, o, oc);

        }

    }



    /* ffserver seeking with date=... needs a date reference */

    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        int err = parse_option(o, ""metadata"", ""creation_time=now"", options);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    if (!strcmp(file_oformat->name, ""ffm"") && !override_ffserver &&

        av_strstart(filename, ""http:"", NULL)) {

        int j;

        /* special case for files sent to ffserver: we get the stream

           parameters from ffserver */

        int err = read_ffserver_streams(o, oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {

            ost = output_streams[j];

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if(ist->st->codec->codec_type == ost->st->codec->codec_type){

                    ost->sync_ist= ist;

                    ost->source_index= i;

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(""anull"");

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(""null"");

                    ist->discard = 0;

                    ist->st->discard = AVDISCARD_NONE;

                    break;

                }

            }

            if(!ost->sync_ist){

                av_log(NULL, AV_LOG_FATAL, ""Missing %s stream which is required by this ffm\n"", av_get_media_type_string(ost->st->codec->codec_type));

                exit_program(1);

            }

        }

    } else if (!o->nb_stream_maps) {

        char *subtitle_codec_name = NULL;

        /* pick the ""best"" stream of each type */



        /* video: highest resolution */

        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {

            int area = 0, idx = -1;

            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);

            for (i = 0; i < nb_input_streams; i++) {

                int new_area;

                ist = input_streams[i];

                new_area = ist->st->codec->width * ist->st->codec->height;

                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                    new_area = 1;

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    new_area > area) {

                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                        continue;

                    area = new_area;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_video_stream(o, oc, idx);

        }



        /* audio: most channels */

        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_audio_stream(o, oc, idx);

        }



        /* subtitles: pick first */

        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, ""s"");

        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    new_subtitle_stream(o, oc, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < o->nb_stream_maps; i++) {

            StreamMap *map = &o->stream_maps[i];



            if (map->disabled)

                continue;



            if (map->linklabel) {

                FilterGraph *fg;

                OutputFilter *ofilter = NULL;

                int j, k;



                for (j = 0; j < nb_filtergraphs; j++) {

                    fg = filtergraphs[j];

                    for (k = 0; k < fg->nb_outputs; k++) {

                        AVFilterInOut *out = fg->outputs[k]->out_tmp;

                        if (out && !strcmp(out->name, map->linklabel)) {

                            ofilter = fg->outputs[k];

                            goto loop_end;

                        }

                    }

                }

loop_end:

                if (!ofilter) {

                    av_log(NULL, AV_LOG_FATAL, ""Output with label '%s' does not exist ""

                           ""in any defined filter graph, or was already used elsewhere.\n"", map->linklabel);

                    exit_program(1);

                }

                init_output_filter(ofilter, o, oc);

            } else {

                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;



                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];

                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)

                    continue;

                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)

                    continue;

                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

                    continue;

                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)

                    continue;



                switch (ist->st->codec->codec_type) {

                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;

                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;

                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;

                default:

                    av_log(NULL, AV_LOG_FATAL, ""Cannot map stream #%d:%d - unsupported type.\n"",

                           map->file_index, map->stream_index);

                    exit_program(1);

                }

            }

        }

    }



    /* handle attached files */

    for (i = 0; i < o->nb_attachments; i++) {

        AVIOContext *pb;

        uint8_t *attachment;

        const char *p;

        int64_t len;



        if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not open attachment file %s.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        if ((len = avio_size(pb)) <= 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not get size of the attachment %s.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        if (!(attachment = av_malloc(len))) {

            av_log(NULL, AV_LOG_FATAL, ""Attachment %s too large to fit into memory.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        avio_read(pb, attachment, len);



        ost = new_attachment_stream(o, oc, -1);

        ost->stream_copy               = 0;

        ost->attachment_filename       = o->attachments[i];

        ost->finished                  = 1;

        ost->st->codec->extradata      = attachment;

        ost->st->codec->extradata_size = len;



        p = strrchr(o->attachments[i], '/');

        av_dict_set(&ost->st->metadata, ""filename"", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);

        avio_close(pb);

    }



    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { //for all streams of this output file

        AVDictionaryEntry *e;

        ost = output_streams[i];



        if ((ost->stream_copy || ost->attachment_filename)

            && (e = av_dict_get(o->g->codec_opts, ""flags"", NULL, AV_DICT_IGNORE_SUFFIX))

            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))

            if (av_opt_set(ost->st->codec, ""flags"", e->value, 0) < 0)

                exit_program(1);

    }



    /* check if all codec options have been used */

    unused_opts = strip_specifiers(o->g->codec_opts);

    for (i = of->ost_index; i < nb_output_streams; i++) {

        e = NULL;

        while ((e = av_dict_get(output_streams[i]->opts, """", e,

                                AV_DICT_IGNORE_SUFFIX)))

            av_dict_set(&unused_opts, e->key, NULL, 0);

    }



    e = NULL;

    while ((e = av_dict_get(unused_opts, """", e, AV_DICT_IGNORE_SUFFIX))) {

        const AVClass *class = avcodec_get_class();

        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,

                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);

        if (!option)

            continue;

        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {

            av_log(NULL, AV_LOG_ERROR, ""Codec AVOption %s (%s) specified for ""

                   ""output file #%d (%s) is not an encoding option.\n"", e->key,

                   option->help ? option->help : """", nb_output_files - 1,

                   filename);

            exit_program(1);

        }



        // gop_timecode is injected by generic code but not always used

        if (!strcmp(e->key, ""gop_timecode""))

            continue;



        av_log(NULL, AV_LOG_WARNING, ""Codec AVOption %s (%s) specified for ""

               ""output file #%d (%s) has not been used for any stream. The most ""

               ""likely reason is either wrong type (e.g. a video option with ""

               ""no video streams) or that it is a private option of some encoder ""

               ""which was not actually used for any stream.\n"", e->key,

               option->help ? option->help : """", nb_output_files - 1, filename);

    }

    av_dict_free(&unused_opts);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid losing precious files */

        assert_file_overwrite(filename);



        /* open the file */

        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,

                              &oc->interrupt_callback,

                              &of->opts)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (strcmp(oc->oformat->name, ""image2"")==0 && !av_filename_number_test(filename))

        assert_file_overwrite(filename);



    if (o->mux_preload) {

        uint8_t buf[64];

        snprintf(buf, sizeof(buf), ""%d"", (int)(o->mux_preload*AV_TIME_BASE));

        av_dict_set(&of->opts, ""preload"", buf, 0);

    }

    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);



    /* copy metadata */

    for (i = 0; i < o->nb_metadata_map; i++) {

        char *p;

        int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0);



        if (in_file_index >= nb_input_files) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d while processing metadata maps\n"", in_file_index);

            exit_program(1);

        }

        copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc,

                      in_file_index >= 0 ?

                      input_files[in_file_index]->ctx : NULL, o);

    }



    /* copy chapters */

    if (o->chapters_input_file >= nb_input_files) {

        if (o->chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            o->chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i]->ctx->nb_chapters) {

                    o->chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d in chapter mapping.\n"",

                   o->chapters_input_file);

            exit_program(1);

        }

    }

    if (o->chapters_input_file >= 0)

        copy_chapters(input_files[o->chapters_input_file], of,

                      !o->metadata_chapters_manual);



    /* copy global metadata by default */

    if (!o->metadata_global_manual && nb_input_files){

        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

        if(o->recording_time != INT64_MAX)

            av_dict_set(&oc->metadata, ""duration"", NULL, 0);

        av_dict_set(&oc->metadata, ""creation_time"", NULL, 0);

    }

    if (!o->metadata_streams_manual)

        for (i = of->ost_index; i < nb_output_streams; i++) {

            InputStream *ist;

            if (output_streams[i]->source_index < 0)         /* this is true e.g. for attached files */

                continue;

            ist = input_streams[output_streams[i]->source_index];

            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    /* process manually set metadata */

    for (i = 0; i < o->nb_metadata; i++) {

        AVDictionary **m;

        char type, *val;

        const char *stream_spec;

        int index = 0, j, ret = 0;



        val = strchr(o->metadata[i].u.str, '=');

        if (!val) {

            av_log(NULL, AV_LOG_FATAL, ""No '=' character in metadata string %s.\n"",

                   o->metadata[i].u.str);

            exit_program(1);

        }

        *val++ = 0;



        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);

        if (type == 's') {

            for (j = 0; j < oc->nb_streams; j++) {

                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {

                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);

                } else if (ret < 0)

                    exit_program(1);

            }

        }

        else {

            switch (type) {

            case 'g':

                m = &oc->metadata;

                break;

            case 'c':

                if (index < 0 || index >= oc->nb_chapters) {

                    av_log(NULL, AV_LOG_FATAL, ""Invalid chapter index %d in metadata specifier.\n"", index);

                    exit_program(1);

                }

                m = &oc->chapters[index]->metadata;

                break;

            default:

                av_log(NULL, AV_LOG_FATAL, ""Invalid metadata specifier %s.\n"", o->metadata[i].specifier);

                exit_program(1);

            }

            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);

        }

    }



    return 0;

}
",3171,"static int open_output_file(OptionsContext *o, const char *filename)

{

    AVFormatContext *oc;

    int i, j, err;

    AVOutputFormat *ROUND_UP;

    OutputFile *of;

    OutputStream *ost;

    InputStream  *ist;

    AVDictionary *unused_opts = NULL;

    AVDictionaryEntry *e = NULL;



    if (configure_complex_filters() < 0) {

        av_log(NULL, AV_LOG_FATAL, ""Error configuring filters.
"");

        exit_program(1);

    }



    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {

        o->stop_time = INT64_MAX;

        av_log(NULL, AV_LOG_WARNING, ""-t and -to cannot be used together; using -t.
"");

    }



    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {

        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;

        if (o->stop_time <= start_time) {

            av_log(NULL, AV_LOG_WARNING, ""-to value smaller than -ss; ignoring -to.
"");

            o->stop_time = INT64_MAX;

        } else {

            o->recording_time = o->stop_time - start_time;

        }

    }



    GROW_ARRAY(output_files, nb_output_files);

    of = av_mallocz(sizeof(*of));

    if (!of)

        exit_program(1);

    output_files[nb_output_files - 1] = of;



    of->ost_index      = nb_output_streams;

    of->recording_time = o->recording_time;

    of->start_time     = o->start_time;

    of->limit_filesize = o->limit_filesize;

    of->shortest       = o->shortest;

    av_dict_copy(&of->opts, o->g->format_opts, 0);



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);

    if (!oc) {

        print_error(filename, err);

        exit_program(1);

    }



    of->ctx = oc;

    if (o->recording_time != INT64_MAX)

        oc->duration = o->recording_time;



    ROUND_UP= oc->oformat;

    oc->interrupt_callback = int_cb;



    /* create streams for all unlabeled output pads */

    for (i = 0; i < nb_filtergraphs; i++) {

        FilterGraph *fg = filtergraphs[i];

        for (j = 0; j < fg->nb_outputs; j++) {

            OutputFilter *ofilter = fg->outputs[j];



            if (!ofilter->out_tmp || ofilter->out_tmp->name)

                continue;



            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,

                                          ofilter->out_tmp->pad_idx)) {

            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;

            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;

            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;

            }

            init_output_filter(ofilter, o, oc);

        }

    }



    /* ffserver seeking with date=... needs a date reference */

    if (!strcmp(ROUND_UP->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        int err = parse_option(o, ""metadata"", ""creation_time=now"", options);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    if (!strcmp(ROUND_UP->name, ""ffm"") && !override_ffserver &&

        av_strstart(filename, ""http:"", NULL)) {

        int j;

        /* special case for files sent to ffserver: we get the stream

           parameters from ffserver */

        int err = read_ffserver_streams(o, oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {

            ost = output_streams[j];

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if(ist->st->codec->codec_type == ost->st->codec->codec_type){

                    ost->sync_ist= ist;

                    ost->source_index= i;

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(""anull"");

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(""null"");

                    ist->discard = 0;

                    ist->st->discard = AVDISCARD_NONE;

                    break;

                }

            }

            if(!ost->sync_ist){

                av_log(NULL, AV_LOG_FATAL, ""Missing %s stream which is required by this ffm
"", av_get_media_type_string(ost->st->codec->codec_type));

                exit_program(1);

            }

        }

    } else if (!o->nb_stream_maps) {

        char *subtitle_codec_name = NULL;

        /* pick the ""best"" stream of each type */



        /* video: highest resolution */

        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {

            int area = 0, idx = -1;

            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);

            for (i = 0; i < nb_input_streams; i++) {

                int new_area;

                ist = input_streams[i];

                new_area = ist->st->codec->width * ist->st->codec->height;

                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                    new_area = 1;

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    new_area > area) {

                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                        continue;

                    area = new_area;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_video_stream(o, oc, idx);

        }



        /* audio: most channels */

        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_audio_stream(o, oc, idx);

        }



        /* subtitles: pick first */

        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, ""s"");

        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    new_subtitle_stream(o, oc, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < o->nb_stream_maps; i++) {

            StreamMap *map = &o->stream_maps[i];



            if (map->disabled)

                continue;



            if (map->linklabel) {

                FilterGraph *fg;

                OutputFilter *ofilter = NULL;

                int j, k;



                for (j = 0; j < nb_filtergraphs; j++) {

                    fg = filtergraphs[j];

                    for (k = 0; k < fg->nb_outputs; k++) {

                        AVFilterInOut *out = fg->outputs[k]->out_tmp;

                        if (out && !strcmp(out->name, map->linklabel)) {

                            ofilter = fg->outputs[k];

                            goto loop_end;

                        }

                    }

                }

loop_end:

                if (!ofilter) {

                    av_log(NULL, AV_LOG_FATAL, ""Output with label '%s' does not exist ""

                           ""in any defined filter graph, or was already used elsewhere.
"", map->linklabel);

                    exit_program(1);

                }

                init_output_filter(ofilter, o, oc);

            } else {

                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;



                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];

                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)

                    continue;

                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)

                    continue;

                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

                    continue;

                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)

                    continue;



                switch (ist->st->codec->codec_type) {

                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;

                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;

                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;

                default:

                    av_log(NULL, AV_LOG_FATAL, ""Cannot map stream #%d:%d - unsupported type.
"",

                           map->file_index, map->stream_index);

                    exit_program(1);

                }

            }

        }

    }



    /* handle attached files */

    for (i = 0; i < o->nb_attachments; i++) {

        AVIOContext *pb;

        uint8_t *attachment;

        const char *p;

        int64_t len;



        if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not open attachment file %s.
"",

                   o->attachments[i]);

            exit_program(1);

        }

        if ((len = avio_size(pb)) <= 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not get size of the attachment %s.
"",

                   o->attachments[i]);

            exit_program(1);

        }

        if (!(attachment = av_malloc(len))) {

            av_log(NULL, AV_LOG_FATAL, ""Attachment %s too large to fit into memory.
"",

                   o->attachments[i]);

            exit_program(1);

        }

        avio_read(pb, attachment, len);



        ost = new_attachment_stream(o, oc, -1);

        ost->stream_copy               = 0;

        ost->attachment_filename       = o->attachments[i];

        ost->finished                  = 1;

        ost->st->codec->extradata      = attachment;

        ost->st->codec->extradata_size = len;



        p = strrchr(o->attachments[i], '/');

        av_dict_set(&ost->st->metadata, ""filename"", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);

        avio_close(pb);

    }



    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { //for all streams of this output file

        AVDictionaryEntry *e;

        ost = output_streams[i];



        if ((ost->stream_copy || ost->attachment_filename)

            && (e = av_dict_get(o->g->codec_opts, ""flags"", NULL, AV_DICT_IGNORE_SUFFIX))

            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))

            if (av_opt_set(ost->st->codec, ""flags"", e->value, 0) < 0)

                exit_program(1);

    }



    /* check if all codec options have been used */

    unused_opts = strip_specifiers(o->g->codec_opts);

    for (i = of->ost_index; i < nb_output_streams; i++) {

        e = NULL;

        while ((e = av_dict_get(output_streams[i]->opts, """", e,

                                AV_DICT_IGNORE_SUFFIX)))

            av_dict_set(&unused_opts, e->key, NULL, 0);

    }



    e = NULL;

    while ((e = av_dict_get(unused_opts, """", e, AV_DICT_IGNORE_SUFFIX))) {

        const AVClass *class = avcodec_get_class();

        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,

                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);

        if (!option)

            continue;

        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {

            av_log(NULL, AV_LOG_ERROR, ""Codec AVOption %s (%s) specified for ""

                   ""output file #%d (%s) is not an encoding option.
"", e->key,

                   option->help ? option->help : """", nb_output_files - 1,

                   filename);

            exit_program(1);

        }



        // gop_timecode is injected by generic code but not always used

        if (!strcmp(e->key, ""gop_timecode""))

            continue;



        av_log(NULL, AV_LOG_WARNING, ""Codec AVOption %s (%s) specified for ""

               ""output file #%d (%s) has not been used for any stream. The most ""

               ""likely reason is either wrong type (e.g. a video option with ""

               ""no video streams) or that it is a private option of some encoder ""

               ""which was not actually used for any stream.
"", e->key,

               option->help ? option->help : """", nb_output_files - 1, filename);

    }

    av_dict_free(&unused_opts);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid losing precious files */

        assert_file_overwrite(filename);



        /* open the file */

        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,

                              &oc->interrupt_callback,

                              &of->opts)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (strcmp(oc->oformat->name, ""image2"")==0 && !av_filename_number_test(filename))

        assert_file_overwrite(filename);



    if (o->mux_preload) {

        uint8_t buf[64];

        snprintf(buf, sizeof(buf), ""%d"", (int)(o->mux_preload*AV_TIME_BASE));

        av_dict_set(&of->opts, ""preload"", buf, 0);

    }

    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);



    /* copy metadata */

    for (i = 0; i < o->nb_metadata_map; i++) {

        char *p;

        int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0);



        if (in_file_index >= nb_input_files) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d while processing metadata maps
"", in_file_index);

            exit_program(1);

        }

        copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc,

                      in_file_index >= 0 ?

                      input_files[in_file_index]->ctx : NULL, o);

    }



    /* copy chapters */

    if (o->chapters_input_file >= nb_input_files) {

        if (o->chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            o->chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i]->ctx->nb_chapters) {

                    o->chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d in chapter mapping.
"",

                   o->chapters_input_file);

            exit_program(1);

        }

    }

    if (o->chapters_input_file >= 0)

        copy_chapters(input_files[o->chapters_input_file], of,

                      !o->metadata_chapters_manual);



    /* copy global metadata by default */

    if (!o->metadata_global_manual && nb_input_files){

        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

        if(o->recording_time != INT64_MAX)

            av_dict_set(&oc->metadata, ""duration"", NULL, 0);

        av_dict_set(&oc->metadata, ""creation_time"", NULL, 0);

    }

    if (!o->metadata_streams_manual)

        for (i = of->ost_index; i < nb_output_streams; i++) {

            InputStream *ist;

            if (output_streams[i]->source_index < 0)         /* this is true e.g. for attached files */

                continue;

            ist = input_streams[output_streams[i]->source_index];

            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    /* process manually set metadata */

    for (i = 0; i < o->nb_metadata; i++) {

        AVDictionary **m;

        char type, *val;

        const char *stream_spec;

        int index = 0, j, ret = 0;



        val = strchr(o->metadata[i].u.str, '=');

        if (!val) {

            av_log(NULL, AV_LOG_FATAL, ""No '=' character in metadata string %s.
"",

                   o->metadata[i].u.str);

            exit_program(1);

        }

        *val++ = 0;



        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);

        if (type == 's') {

            for (j = 0; j < oc->nb_streams; j++) {

                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {

                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);

                } else if (ret < 0)

                    exit_program(1);

            }

        }

        else {

            switch (type) {

            case 'g':

                m = &oc->metadata;

                break;

            case 'c':

                if (index < 0 || index >= oc->nb_chapters) {

                    av_log(NULL, AV_LOG_FATAL, ""Invalid chapter index %d in metadata specifier.
"", index);

                    exit_program(1);

                }

                m = &oc->chapters[index]->metadata;

                break;

            default:

                av_log(NULL, AV_LOG_FATAL, ""Invalid metadata specifier %s.
"", o->metadata[i].specifier);

                exit_program(1);

            }

            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);

        }

    }



    return 0;

}
",0,0,1,1,file_oformat,0.05815926194190979,1,4,{'file_oformat': 'ROUND_UP'},MHM-Origin,40,0.038125820954640705
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,

                                   unsigned int imms, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int len;



    assert(immn < 2 && imms < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>

     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>

     * Notice that immn = 0, imms = 11111x is the only combination

     * not covered by one of the above options; this is reserved.

     * Further, <length of run - 1> all-ones is a reserved pattern.

     *

     * In all cases the rotation is by immr % e (and immr is 6 bits).

     */



    /* First determine the element size */

    len = 31 - clz32((immn << 6) | (~imms & 0x3f));

    if (len < 1) {

        /* This is the immn == 0, imms == 0x11111x case */

        return false;

    }

    e = 1 << len;



    levels = e - 1;

    s = imms & levels;

    r = immr & levels;



    if (s == levels) {

        /* <length of run - 1> mustn't be all-ones. */

        return false;

    }



    /* Create the value of one element: s+1 set bits rotated

     * by r within the element (which is e bits wide)...

     */

    mask = bitmask64(s + 1);

    mask = (mask >> r) | (mask << (e - r));

    /* ...then replicate the element over the whole 64 bit value */

    mask = bitfield_replicate(mask, e);

    *result = mask;

    return true;

}
",162,"static bool logic_imm_decode_wmask(uint64_t *checksum, unsigned int immn,

                                   unsigned int imms, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int len;



    assert(immn < 2 && imms < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>

     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>

     * Notice that immn = 0, imms = 11111x is the only combination

     * not covered by one of the above options; this is reserved.

     * Further, <length of run - 1> all-ones is a reserved pattern.

     *

     * In all cases the rotation is by immr % e (and immr is 6 bits).

     */



    /* First determine the element size */

    len = 31 - clz32((immn << 6) | (~imms & 0x3f));

    if (len < 1) {

        /* This is the immn == 0, imms == 0x11111x case */

        return false;

    }

    e = 1 << len;



    levels = e - 1;

    s = imms & levels;

    r = immr & levels;



    if (s == levels) {

        /* <length of run - 1> mustn't be all-ones. */

        return false;

    }



    /* Create the value of one element: s+1 set bits rotated

     * by r within the element (which is e bits wide)...

     */

    mask = bitmask64(s + 1);

    mask = (mask >> r) | (mask << (e - r));

    /* ...then replicate the element over the whole 64 bit value */

    mask = bitfield_replicate(mask, e);

    *checksum = mask;

    return true;

}
",1,1,0,1,result,-0.42002493143081665,1,2,{'result': 'checksum'},MHM-Origin,21,0.008892552057902018
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,

                                         src - (stride * 2) +

                                         sizeof(uint8_t), stride, dst, stride);

}
",43,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *stream_spec, const uint8_t *farg,

                                ptrdiff_t OPC_SRA_CP2)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(farg - 2,

                                         farg - (OPC_SRA_CP2 * 2) +

                                         sizeof(uint8_t), OPC_SRA_CP2, stream_spec, OPC_SRA_CP2);

}
",0,0,0,-1,src,-0.00035180896520614624,3,9,"{'stride': 'OPC_SRA_CP2', 'dst': 'stream_spec', 'src': 'farg'}",MHM-Origin,392,0.15730353196461996
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",83,"static int flv_probe(AVProbeData *FLAC_SUBFRAME_CONSTANT)

{

    const uint8_t *sbd;



    if (FLAC_SUBFRAME_CONSTANT->buf_size < 6)

        return 0;

    sbd = FLAC_SUBFRAME_CONSTANT->buf;

    if (sbd[0] == 'F' && sbd[1] == 'L' && sbd[2] == 'V' && sbd[3] < 5 && sbd[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",0,0,0,-1,p,0.0014687515795230865,2,10,"{'p': 'FLAC_SUBFRAME_CONSTANT', 'd': 'sbd'}",MHM-Origin,400,0.15997494459152223
232,"static void opt_output_file(void *optctx, const char *filename)

{

    OptionsContext *o = optctx;

    AVFormatContext *oc;

    int i, err;

    AVOutputFormat *file_oformat;

    OutputStream *ost;

    InputStream  *ist;



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    oc = avformat_alloc_context();

    if (!oc) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }



    if (last_asked_format) {

        file_oformat = av_guess_format(last_asked_format, NULL, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Requested output format '%s' is not a suitable output format\n"", last_asked_format);

            exit_program(1);

        }

        last_asked_format = NULL;

    } else {

        file_oformat = av_guess_format(NULL, filename, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Unable to find a suitable output format for '%s'\n"",

                    filename);

            exit_program(1);

        }

    }



    oc->oformat = file_oformat;

    av_strlcpy(oc->filename, filename, sizeof(oc->filename));



    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        /* special case for files sent to avserver: we get the stream

           parameters from avserver */

        int err = read_avserver_streams(oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (!o->nb_stream_maps) {

        /* pick the ""best"" stream of each type */

#define NEW_STREAM(type, index)\

        if (index >= 0) {\

            ost = new_ ## type ## _stream(oc);\

            ost->source_index = index;\

            ost->sync_ist     = &input_streams[index];\

            input_streams[index].discard = 0;\

        }



        /* video: highest resolution */

        if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) {

            int area = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = &input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    ist->st->codec->width * ist->st->codec->height > area) {

                    area = ist->st->codec->width * ist->st->codec->height;

                    idx = i;

                }

            }

            NEW_STREAM(video, idx);

        }



        /* audio: most channels */

        if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = &input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            NEW_STREAM(audio, idx);

        }



        /* subtitles: pick first */

        if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    NEW_STREAM(subtitle, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < o->nb_stream_maps; i++) {

            StreamMap *map = &o->stream_maps[i];



            if (map->disabled)

                continue;



            ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index];

            switch (ist->st->codec->codec_type) {

            case AVMEDIA_TYPE_VIDEO:    ost = new_video_stream(oc);    break;

            case AVMEDIA_TYPE_AUDIO:    ost = new_audio_stream(oc);    break;

            case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break;

            case AVMEDIA_TYPE_DATA:     ost = new_data_stream(oc);     break;

            default:

                av_log(NULL, AV_LOG_ERROR, ""Cannot map stream #%d.%d - unsupported type.\n"",

                       map->file_index, map->stream_index);

                exit_program(1);

            }



            ost->source_index = input_files[map->file_index].ist_index + map->stream_index;

            ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index +

                                           map->sync_stream_index];

            ist->discard = 0;

        }

    }



    av_dict_copy(&oc->metadata, metadata, 0);

    av_dict_free(&metadata);





    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);

    output_files[nb_output_files - 1].ctx       = oc;

    output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams;

    output_files[nb_output_files - 1].recording_time = o->recording_time;

    output_files[nb_output_files - 1].start_time     = o->start_time;

    output_files[nb_output_files - 1].limit_filesize = limit_filesize;

    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid loosing precious files */

        if (!file_overwrite &&

            (strchr(filename, ':') == NULL ||

             filename[1] == ':' ||

             av_strstart(filename, ""file:"", NULL))) {

            if (avio_check(filename, 0) == 0) {

                if (!using_stdin) {

                    fprintf(stderr,""File '%s' already exists. Overwrite ? [y/N] "", filename);

                    fflush(stderr);

                    if (!read_yesno()) {

                        fprintf(stderr, ""Not overwriting - exiting\n"");

                        exit_program(1);

                    }

                }

                else {

                    fprintf(stderr,""File '%s' already exists. Exiting.\n"", filename);

                    exit_program(1);

                }

            }

        }



        /* open the file */

        if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    oc->preload= (int)(mux_preload*AV_TIME_BASE);

    oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE);

    oc->flags |= AVFMT_FLAG_NONBLOCK;



    /* copy chapters */

    if (chapters_input_file >= nb_input_files) {

        if (chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i].ctx->nb_chapters) {

                    chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_ERROR, ""Invalid input file index %d in chapter mapping.\n"",

                   chapters_input_file);

            exit_program(1);

        }

    }

    if (chapters_input_file >= 0)

        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);



    /* copy metadata */

    for (i = 0; i < nb_meta_data_maps; i++) {

        AVFormatContext *files[2];

        AVDictionary    **meta[2];

        int j;



#define METADATA_CHECK_INDEX(index, nb_elems, desc)\

        if ((index) < 0 || (index) >= (nb_elems)) {\

            av_log(NULL, AV_LOG_ERROR, ""Invalid %s index %d while processing metadata maps\n"",\

                     (desc), (index));\

            exit_program(1);\

        }



        int in_file_index = meta_data_maps[i][1].file;

        if (in_file_index < 0)

            continue;

        METADATA_CHECK_INDEX(in_file_index, nb_input_files, ""input file"")



        files[0] = oc;

        files[1] = input_files[in_file_index].ctx;



        for (j = 0; j < 2; j++) {

            MetadataMap *map = &meta_data_maps[i][j];



            switch (map->type) {

            case 'g':

                meta[j] = &files[j]->metadata;

                break;

            case 's':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, ""stream"")

                meta[j] = &files[j]->streams[map->index]->metadata;

                break;

            case 'c':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, ""chapter"")

                meta[j] = &files[j]->chapters[map->index]->metadata;

                break;

            case 'p':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, ""program"")

                meta[j] = &files[j]->programs[map->index]->metadata;

                break;

            }

        }



        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);

    }



    /* copy global metadata by default */

    if (metadata_global_autocopy && nb_input_files)

        av_dict_copy(&oc->metadata, input_files[0].ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

    if (metadata_streams_autocopy)

        for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) {

            InputStream *ist = &input_streams[output_streams[i].source_index];

            av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    frame_rate    = (AVRational){0, 0};

    frame_width   = 0;

    frame_height  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    chapters_input_file = INT_MAX;

    limit_filesize = UINT64_MAX;



    av_freep(&meta_data_maps);

    nb_meta_data_maps = 0;

    metadata_global_autocopy   = 1;

    metadata_streams_autocopy  = 1;

    metadata_chapters_autocopy = 1;

    av_freep(&streamid_map);

    nb_streamid_map = 0;



    av_dict_free(&codec_names);



    av_freep(&forced_key_frames);

    reset_options(o);

}
",1644,"static void opt_output_file(void *MSR_MTRRfix4K_E0000, const char *filename)

{

    OptionsContext *formatConvBuffer = MSR_MTRRfix4K_E0000;

    AVFormatContext *do_show_frames;

    int uint32_t, err;

    AVOutputFormat *out_nofid;

    OutputStream *as;

    InputStream  *num_rematrixing_bands;



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    do_show_frames = avformat_alloc_context();

    if (!do_show_frames) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }



    if (last_asked_format) {

        out_nofid = av_guess_format(last_asked_format, NULL, NULL);

        if (!out_nofid) {

            fprintf(stderr, ""Requested output format '%s' is not a suitable output format
"", last_asked_format);

            exit_program(1);

        }

        last_asked_format = NULL;

    } else {

        out_nofid = av_guess_format(NULL, filename, NULL);

        if (!out_nofid) {

            fprintf(stderr, ""Unable to find a suitable output format for '%s'
"",

                    filename);

            exit_program(1);

        }

    }



    do_show_frames->oformat = out_nofid;

    av_strlcpy(do_show_frames->filename, filename, sizeof(do_show_frames->filename));



    if (!strcmp(out_nofid->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        /* special case for files sent to avserver: we get the stream

           parameters from avserver */

        int err = read_avserver_streams(do_show_frames, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (!formatConvBuffer->nb_stream_maps) {

        /* pick the ""best"" stream of each type */

#define NEW_STREAM(type, index)\

        if (index >= 0) {\

            as = new_ ## type ## _stream(oc);\

            as->source_index = index;\

            as->sync_ist     = &input_streams[index];\

            input_streams[index].discard = 0;\

        }



        /* video: highest resolution */

        if (!video_disable && do_show_frames->oformat->video_codec != CODEC_ID_NONE) {

            int area = 0, idx = -1;

            for (uint32_t = 0; uint32_t < nb_input_streams; uint32_t++) {

                num_rematrixing_bands = &input_streams[uint32_t];

                if (num_rematrixing_bands->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    num_rematrixing_bands->st->codec->width * num_rematrixing_bands->st->codec->height > area) {

                    area = num_rematrixing_bands->st->codec->width * num_rematrixing_bands->st->codec->height;

                    idx = uint32_t;

                }

            }

            NEW_STREAM(video, idx);

        }



        /* audio: most channels */

        if (!audio_disable && do_show_frames->oformat->audio_codec != CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (uint32_t = 0; uint32_t < nb_input_streams; uint32_t++) {

                num_rematrixing_bands = &input_streams[uint32_t];

                if (num_rematrixing_bands->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    num_rematrixing_bands->st->codec->channels > channels) {

                    channels = num_rematrixing_bands->st->codec->channels;

                    idx = uint32_t;

                }

            }

            NEW_STREAM(audio, idx);

        }



        /* subtitles: pick first */

        if (!subtitle_disable && do_show_frames->oformat->subtitle_codec != CODEC_ID_NONE) {

            for (uint32_t = 0; uint32_t < nb_input_streams; uint32_t++)

                if (input_streams[uint32_t].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    NEW_STREAM(subtitle, uint32_t);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (uint32_t = 0; uint32_t < formatConvBuffer->nb_stream_maps; uint32_t++) {

            StreamMap *substr = &formatConvBuffer->stream_maps[uint32_t];



            if (substr->disabled)

                continue;



            num_rematrixing_bands = &input_streams[input_files[substr->file_index].ist_index + substr->stream_index];

            switch (num_rematrixing_bands->st->codec->codec_type) {

            case AVMEDIA_TYPE_VIDEO:    as = new_video_stream(do_show_frames);    break;

            case AVMEDIA_TYPE_AUDIO:    as = new_audio_stream(do_show_frames);    break;

            case AVMEDIA_TYPE_SUBTITLE: as = new_subtitle_stream(do_show_frames); break;

            case AVMEDIA_TYPE_DATA:     as = new_data_stream(do_show_frames);     break;

            default:

                av_log(NULL, AV_LOG_ERROR, ""Cannot map stream #%d.%d - unsupported type.
"",

                       substr->file_index, substr->stream_index);

                exit_program(1);

            }



            as->source_index = input_files[substr->file_index].ist_index + substr->stream_index;

            as->sync_ist = &input_streams[input_files[substr->sync_file_index].ist_index +

                                           substr->sync_stream_index];

            num_rematrixing_bands->discard = 0;

        }

    }



    av_dict_copy(&do_show_frames->metadata, metadata, 0);

    av_dict_free(&metadata);





    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);

    output_files[nb_output_files - 1].ctx       = do_show_frames;

    output_files[nb_output_files - 1].ost_index = nb_output_streams - do_show_frames->nb_streams;

    output_files[nb_output_files - 1].recording_time = formatConvBuffer->recording_time;

    output_files[nb_output_files - 1].start_time     = formatConvBuffer->start_time;

    output_files[nb_output_files - 1].limit_filesize = limit_filesize;

    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);



    /* check filename in case of an image number is expected */

    if (do_show_frames->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(do_show_frames->filename)) {

            print_error(do_show_frames->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(do_show_frames->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid loosing precious files */

        if (!file_overwrite &&

            (strchr(filename, ':') == NULL ||

             filename[1] == ':' ||

             av_strstart(filename, ""file:"", NULL))) {

            if (avio_check(filename, 0) == 0) {

                if (!using_stdin) {

                    fprintf(stderr,""File '%s' already exists. Overwrite ? [y/N] "", filename);

                    fflush(stderr);

                    if (!read_yesno()) {

                        fprintf(stderr, ""Not overwriting - exiting
"");

                        exit_program(1);

                    }

                }

                else {

                    fprintf(stderr,""File '%s' already exists. Exiting.
"", filename);

                    exit_program(1);

                }

            }

        }



        /* open the file */

        if ((err = avio_open(&do_show_frames->pb, filename, AVIO_FLAG_WRITE)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    do_show_frames->preload= (int)(mux_preload*AV_TIME_BASE);

    do_show_frames->max_delay= (int)(mux_max_delay*AV_TIME_BASE);

    do_show_frames->flags |= AVFMT_FLAG_NONBLOCK;



    /* copy chapters */

    if (chapters_input_file >= nb_input_files) {

        if (chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            chapters_input_file = -1;

            for (uint32_t = 0; uint32_t < nb_input_files; uint32_t++)

                if (input_files[uint32_t].ctx->nb_chapters) {

                    chapters_input_file = uint32_t;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_ERROR, ""Invalid input file index %d in chapter mapping.
"",

                   chapters_input_file);

            exit_program(1);

        }

    }

    if (chapters_input_file >= 0)

        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);



    /* copy metadata */

    for (uint32_t = 0; uint32_t < nb_meta_data_maps; uint32_t++) {

        AVFormatContext *grp2[2];

        AVDictionary    **init_rl[2];

        int FLAT;



#define METADATA_CHECK_INDEX(index, nb_elems, desc)\

        if ((index) < 0 || (index) >= (nb_elems)) {\

            av_log(NULL, AV_LOG_ERROR, ""Invalid %s index %d while processing metadata maps
"",\

                     (desc), (index));\

            exit_program(1);\

        }



        int in_file_index = meta_data_maps[uint32_t][1].file;

        if (in_file_index < 0)

            continue;

        METADATA_CHECK_INDEX(in_file_index, nb_input_files, ""input file"")



        grp2[0] = do_show_frames;

        grp2[1] = input_files[in_file_index].ctx;



        for (FLAT = 0; FLAT < 2; FLAT++) {

            MetadataMap *substr = &meta_data_maps[uint32_t][FLAT];



            switch (substr->type) {

            case 'g':

                init_rl[FLAT] = &grp2[FLAT]->metadata;

                break;

            case 's':

                METADATA_CHECK_INDEX(substr->index, grp2[FLAT]->nb_streams, ""stream"")

                init_rl[FLAT] = &grp2[FLAT]->streams[substr->index]->metadata;

                break;

            case 'c':

                METADATA_CHECK_INDEX(substr->index, grp2[FLAT]->nb_chapters, ""chapter"")

                init_rl[FLAT] = &grp2[FLAT]->chapters[substr->index]->metadata;

                break;

            case 'p':

                METADATA_CHECK_INDEX(substr->index, grp2[FLAT]->nb_programs, ""program"")

                init_rl[FLAT] = &grp2[FLAT]->programs[substr->index]->metadata;

                break;

            }

        }



        av_dict_copy(init_rl[0], *init_rl[1], AV_DICT_DONT_OVERWRITE);

    }



    /* copy global metadata by default */

    if (metadata_global_autocopy && nb_input_files)

        av_dict_copy(&do_show_frames->metadata, input_files[0].ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

    if (metadata_streams_autocopy)

        for (uint32_t = output_files[nb_output_files - 1].ost_index; uint32_t < nb_output_streams; uint32_t++) {

            InputStream *num_rematrixing_bands = &input_streams[output_streams[uint32_t].source_index];

            av_dict_copy(&output_streams[uint32_t].st->metadata, num_rematrixing_bands->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    frame_rate    = (AVRational){0, 0};

    frame_width   = 0;

    frame_height  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    chapters_input_file = INT_MAX;

    limit_filesize = UINT64_MAX;



    av_freep(&meta_data_maps);

    nb_meta_data_maps = 0;

    metadata_global_autocopy   = 1;

    metadata_streams_autocopy  = 1;

    metadata_chapters_autocopy = 1;

    av_freep(&streamid_map);

    nb_streamid_map = 0;



    av_dict_free(&codec_names);



    av_freep(&forced_key_frames);

    reset_options(formatConvBuffer);

}
",0,0,1,1,optctx,0.46110883355140686,11,154,"{'file_oformat': 'out_nofid', 'j': 'FLAT', 'map': 'substr', 'meta': 'init_rl', 'optctx': 'MSR_MTRRfix4K_E0000', 'i': 'uint32_t', 'files': 'grp2', 'ost': 'as', 'ist': 'num_rematrixing_bands', 'oc': 'do_show_frames', 'o': 'formatConvBuffer'}",MHM-Origin,340,0.24450787703196208
235,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
",14,"bool machine_iommu(MachineState *err_after_open)

{

    return err_after_open->iommu;

}
",0,0,1,1,machine,0.7490197960287333,1,2,{'machine': 'err_after_open'},MHM-Origin,41,0.016918436686197916
237,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
",37,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *readsamplesize, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
",0,0,1,1,ret,0.36578741669654846,1,1,{'ret': 'readsamplesize'},MHM-Origin,23,0.007977354526519775
239,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)

{

    CPU_DoubleU farg;

    float32 f32;



    farg.ll = arg;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

    }

    f32 = float64_to_float32(farg.d, &env->fp_status);

    farg.d = float32_to_float64(f32, &env->fp_status);



    return farg.ll;

}
",78,"uint64_t helper_frsp(CPUPPCState *pstrcpy_targphys, uint64_t bt_op)

{

    CPU_DoubleU g_malloc;

    float32 async_context_id;



    g_malloc.ll = bt_op;



    if (unlikely(float64_is_signaling_nan(g_malloc.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(pstrcpy_targphys, POWERPC_EXCP_FP_VXSNAN);

    }

    async_context_id = float64_to_float32(g_malloc.d, &pstrcpy_targphys->fp_status);

    g_malloc.d = float32_to_float64(async_context_id, &pstrcpy_targphys->fp_status);



    return g_malloc.ll;

}
",0,0,0,-1,arg,-0.0003131893463432789,4,15,"{'f32': 'async_context_id', 'env': 'pstrcpy_targphys', 'arg': 'bt_op', 'farg': 'g_malloc'}",MHM-Origin,392,0.16247455279032388
240,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
",67,"int gen_new_label(void)

{

    TCGContext *fg = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (fg->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = fg->nb_labels++;

    l = &fg->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
",0,0,1,1,s,0.3395948112010956,1,4,{'s': 'fg'},MHM-Origin,22,0.008056100209554036
243,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",117,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *cow_bs = bs->opaque;
    BlkdebugRule *AddressSpaceDispatch = NULL;
    QSIMPLEQ_FOREACH(AddressSpaceDispatch, &cow_bs->active_rules, active_next) {
        uint64_t inject_offset = AddressSpaceDispatch->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (AddressSpaceDispatch && AddressSpaceDispatch->options.inject.error) {
        return inject_error(bs, AddressSpaceDispatch);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",1,1,1,-1,rule,-0.00025206804275512695,2,8,"{'rule': 'AddressSpaceDispatch', 's': 'cow_bs'}",MHM-Origin,398,0.1657121777534485
244,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
",75,"static int idreg_init1(SysBusDevice *cc_x)

{

    IDRegState *raise_exception_err = MACIO_ID_REGISTER(cc_x);



    memory_region_init_ram(&raise_exception_err->mem, OBJECT(raise_exception_err),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&raise_exception_err->mem);

    memory_region_set_readonly(&raise_exception_err->mem, true);

    sysbus_init_mmio(cc_x, &raise_exception_err->mem);

    return 0;

}
",1,1,0,1,s,-0.44802817702293396,2,9,"{'s': 'raise_exception_err', 'dev': 'cc_x'}",MHM-Origin,82,0.032465231418609616
245,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,

                                  tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);

    if (arg != (arg & 0xfff))

        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |

              INSN_IMM13(arg & 0x3ff));

#else

    tcg_out_ld_raw(s, ret, arg);

#endif

}
",122,"static inline void tcg_out_ld_ptr(TCGContext *rm, int HV_X64_MSR_GUEST_OS_ID,

                                  tcg_target_long is_chroma)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (is_chroma != (is_chroma & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld
"", __func__, is_chroma);

    if (is_chroma != (is_chroma & 0xfff))

        tcg_out32(rm, SETHI | INSN_RD(HV_X64_MSR_GUEST_OS_ID) | (((uint32_t)is_chroma & 0xfffffc00) >> 10));

    tcg_out32(rm, LDX | INSN_RD(HV_X64_MSR_GUEST_OS_ID) | INSN_RS1(HV_X64_MSR_GUEST_OS_ID) |

              INSN_IMM13(is_chroma & 0x3ff));

#else

    tcg_out_ld_raw(rm, HV_X64_MSR_GUEST_OS_ID, is_chroma);

#endif

}
",0,0,0,-1,arg,-0.001527629792690277,3,18,"{'arg': 'is_chroma', 's': 'rm', 'ret': 'HV_X64_MSR_GUEST_OS_ID'}",MHM-Origin,394,0.16406072775522867
246,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
",237,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *HV_X64_MSR_SINT15    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s
"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""HV_X64_MSR_SINT15"",            HV_X64_MSR_SINT15);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
",0,0,1,1,mode,0.6243548095226288,1,3,{'mode': 'HV_X64_MSR_SINT15'},MHM-Origin,21,0.008839587370554606
248,"static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)

{

    IVShmemState *s = IVSHMEM(dev);

    Error *err = NULL;

    uint8_t *pci_conf;

    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |

        PCI_BASE_ADDRESS_MEM_PREFETCH;



    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {

        error_setg(errp,

                   ""You must specify either 'shm', 'chardev' or 'x-memdev'"");

        return;

    }



    if (s->hostmem) {

        MemoryRegion *mr;



        if (s->sizearg) {

            g_warning(""size argument ignored with hostmem"");

        }



        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);

        s->ivshmem_size = memory_region_size(mr);

    } else if (s->sizearg == NULL) {

        s->ivshmem_size = 4 << 20; /* 4 MB default */

    } else {

        char *end;

        int64_t size = qemu_strtosz(s->sizearg, &end);

        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {

            error_setg(errp, ""Invalid size %s"", s->sizearg);

            return;

        }

        s->ivshmem_size = size;

    }



    /* IRQFD requires MSI */

    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&

        !ivshmem_has_feature(s, IVSHMEM_MSI)) {

        error_setg(errp, ""ioeventfd/irqfd requires MSI"");

        return;

    }



    /* check that role is reasonable */

    if (s->role) {

        if (strncmp(s->role, ""peer"", 5) == 0) {

            s->role_val = IVSHMEM_PEER;

        } else if (strncmp(s->role, ""master"", 7) == 0) {

            s->role_val = IVSHMEM_MASTER;

        } else {

            error_setg(errp, ""'role' must be 'peer' or 'master'"");

            return;

        }

    } else {

        s->role_val = IVSHMEM_MASTER; /* default */

    }



    pci_conf = dev->config;

    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;



    /*

     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a

     * bald-faced lie then.  But it's a backwards compatible lie.

     */

    pci_config_set_interrupt_pin(pci_conf, 1);



    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,

                          ""ivshmem-mmio"", IVSHMEM_REG_BAR_SIZE);



    /* region for registers*/

    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,

                     &s->ivshmem_mmio);



    memory_region_init(&s->bar, OBJECT(s), ""ivshmem-bar2-container"", s->ivshmem_size);

    if (s->ivshmem_64bit) {

        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;

    }



    if (s->hostmem != NULL) {

        MemoryRegion *mr;



        IVSHMEM_DPRINTF(""using hostmem\n"");



        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),

                                            &error_abort);

        vmstate_register_ram(mr, DEVICE(s));

        memory_region_add_subregion(&s->bar, 0, mr);

        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);

    } else if (s->server_chr != NULL) {

        /* FIXME do not rely on what chr drivers put into filename */

        if (strncmp(s->server_chr->filename, ""unix:"", 5)) {

            error_setg(errp, ""chardev is not a unix client socket"");

            return;

        }



        /* if we get a UNIX socket as the parameter we will talk

         * to the ivshmem server to receive the memory region */



        IVSHMEM_DPRINTF(""using shared memory server (socket = %s)\n"",

                        s->server_chr->filename);



        if (ivshmem_setup_interrupts(s) < 0) {

            error_setg(errp, ""failed to initialize interrupts"");

            return;

        }



        /* we allocate enough space for 16 peers and grow as needed */

        resize_peers(s, 16);

        s->vm_id = -1;



        pci_register_bar(dev, 2, attr, &s->bar);



        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,

                              ivshmem_check_version, NULL, s);

    } else {

        /* just map the file immediately, we're not using a server */

        int fd;



        IVSHMEM_DPRINTF(""using shm_open (shm object = %s)\n"", s->shmobj);



        /* try opening with O_EXCL and if it succeeds zero the memory

         * by truncating to 0 */

        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,

                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {

           /* truncate file to length PCI device's memory */

            if (ftruncate(fd, s->ivshmem_size) != 0) {

                error_report(""could not truncate shared file"");

            }



        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,

                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {

            error_setg(errp, ""could not open shared file"");

            return;

        }



        if (check_shm_size(s, fd, errp) == -1) {

            return;

        }



        create_shared_memory_BAR(s, fd, attr, &err);

        if (err) {

            error_propagate(errp, err);

            return;

        }

    }



    fifo8_create(&s->incoming_fifo, sizeof(int64_t));



    if (s->role_val == IVSHMEM_PEER) {

        error_setg(&s->migration_blocker,

                   ""Migration is disabled when using feature 'peer mode' in device 'ivshmem'"");

        migrate_add_blocker(s->migration_blocker);

    }

}
",796,"static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)

{

    IVShmemState *s = IVSHMEM(dev);

    Error *err = NULL;

    uint8_t *AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH;

    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |

        PCI_BASE_ADDRESS_MEM_PREFETCH;



    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {

        error_setg(errp,

                   ""You must specify either 'shm', 'chardev' or 'x-memdev'"");

        return;

    }



    if (s->hostmem) {

        MemoryRegion *mr;



        if (s->sizearg) {

            g_warning(""size argument ignored with hostmem"");

        }



        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);

        s->ivshmem_size = memory_region_size(mr);

    } else if (s->sizearg == NULL) {

        s->ivshmem_size = 4 << 20; /* 4 MB default */

    } else {

        char *end;

        int64_t size = qemu_strtosz(s->sizearg, &end);

        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {

            error_setg(errp, ""Invalid size %s"", s->sizearg);

            return;

        }

        s->ivshmem_size = size;

    }



    /* IRQFD requires MSI */

    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&

        !ivshmem_has_feature(s, IVSHMEM_MSI)) {

        error_setg(errp, ""ioeventfd/irqfd requires MSI"");

        return;

    }



    /* check that role is reasonable */

    if (s->role) {

        if (strncmp(s->role, ""peer"", 5) == 0) {

            s->role_val = IVSHMEM_PEER;

        } else if (strncmp(s->role, ""master"", 7) == 0) {

            s->role_val = IVSHMEM_MASTER;

        } else {

            error_setg(errp, ""'role' must be 'peer' or 'master'"");

            return;

        }

    } else {

        s->role_val = IVSHMEM_MASTER; /* default */

    }



    AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH = dev->config;

    AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;



    /*

     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a

     * bald-faced lie then.  But it's a backwards compatible lie.

     */

    pci_config_set_interrupt_pin(AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH, 1);



    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,

                          ""ivshmem-mmio"", IVSHMEM_REG_BAR_SIZE);



    /* region for registers*/

    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,

                     &s->ivshmem_mmio);



    memory_region_init(&s->bar, OBJECT(s), ""ivshmem-bar2-container"", s->ivshmem_size);

    if (s->ivshmem_64bit) {

        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;

    }



    if (s->hostmem != NULL) {

        MemoryRegion *mr;



        IVSHMEM_DPRINTF(""using hostmem
"");



        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),

                                            &error_abort);

        vmstate_register_ram(mr, DEVICE(s));

        memory_region_add_subregion(&s->bar, 0, mr);

        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);

    } else if (s->server_chr != NULL) {

        /* FIXME do not rely on what chr drivers put into filename */

        if (strncmp(s->server_chr->filename, ""unix:"", 5)) {

            error_setg(errp, ""chardev is not a unix client socket"");

            return;

        }



        /* if we get a UNIX socket as the parameter we will talk

         * to the ivshmem server to receive the memory region */



        IVSHMEM_DPRINTF(""using shared memory server (socket = %s)
"",

                        s->server_chr->filename);



        if (ivshmem_setup_interrupts(s) < 0) {

            error_setg(errp, ""failed to initialize interrupts"");

            return;

        }



        /* we allocate enough space for 16 peers and grow as needed */

        resize_peers(s, 16);

        s->vm_id = -1;



        pci_register_bar(dev, 2, attr, &s->bar);



        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,

                              ivshmem_check_version, NULL, s);

    } else {

        /* just map the file immediately, we're not using a server */

        int fd;



        IVSHMEM_DPRINTF(""using shm_open (shm object = %s)
"", s->shmobj);



        /* try opening with O_EXCL and if it succeeds zero the memory

         * by truncating to 0 */

        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,

                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {

           /* truncate file to length PCI device's memory */

            if (ftruncate(fd, s->ivshmem_size) != 0) {

                error_report(""could not truncate shared file"");

            }



        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,

                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {

            error_setg(errp, ""could not open shared file"");

            return;

        }



        if (check_shm_size(s, fd, errp) == -1) {

            return;

        }



        create_shared_memory_BAR(s, fd, attr, &err);

        if (err) {

            error_propagate(errp, err);

            return;

        }

    }



    fifo8_create(&s->incoming_fifo, sizeof(int64_t));



    if (s->role_val == IVSHMEM_PEER) {

        error_setg(&s->migration_blocker,

                   ""Migration is disabled when using feature 'peer mode' in device 'ivshmem'"");

        migrate_add_blocker(s->migration_blocker);

    }

}
",1,1,0,1,pci_conf,-0.1889801323413849,1,4,{'pci_conf': 'AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH'},MHM-Origin,22,0.010300135612487793
252,"static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int i;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""pxor %%mm2, %%mm2		\n\t"" // 2*xalpha

			""movd %5, %%mm6			\n\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""movq %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	\n\t""

			""movd %4, %%mm6			\n\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""xorl %%eax, %%eax		\n\t"" // i

			""movl %0, %%esi			\n\t"" // src

			""movl %1, %%edi			\n\t"" // buf1

			""movl %3, %%edx			\n\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		\n\t""

			""xorl %%ebx, %%ebx		\n\t""

			""movw %4, %%bx			\n\t"" // (xInc*4)&0xFFFF



#define FUNNY_Y_CODE \

			PREFETCH"" 1024(%%esi)		\n\t""\

			PREFETCH"" 1056(%%esi)		\n\t""\

			PREFETCH"" 1088(%%esi)		\n\t""\

			""call ""MANGLE(funnyYCode)""	\n\t""\

			""movq ""MANGLE(temp0)"", %%mm2	\n\t""\

			""xorl %%ecx, %%ecx		\n\t""



FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE



			:: ""m"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" ((xInc*4)>>16),

			""m"" ((xInc*4)&0xFFFF), ""m"" (xInc&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		\n\t"" // i

		""xorl %%ebx, %%ebx		\n\t"" // xx

		""xorl %%ecx, %%ecx		\n\t"" // 2*xalpha

		"".balign 16			\n\t""

		""1:				\n\t""

		""movzbl  (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, (%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, 2(%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			\n\t""

		""cmpl %2, %%eax			\n\t""

		"" jb 1b				\n\t""





		:: ""r"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" (xInc>>16), ""m"" (xInc&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int i;

	unsigned int xpos=0;

	for(i=0;i<dstWidth;i++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

		xpos+=xInc;

	}

#endif

    }

}
",635,"static inline void RENAME(hyscale)(uint16_t *gen_helper_write_eflags, int AV_CODEC_ID_ADPCM_G726, uint8_t *pfd, int srcW, int XBZRLE)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(gen_helper_write_eflags, AV_CODEC_ID_ADPCM_G726, pfd, srcW, XBZRLE, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int entry_point;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		
\t""

			""pxor %%mm2, %%mm2		
\t"" // 2*xalpha

			""movd %5, %%mm6			
\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		
\t""

			""punpcklwd %%mm6, %%mm6		
\t""

			""movq %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t""

			""paddw %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t""

			""paddw %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	
\t""

			""movd %4, %%mm6			
\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		
\t""

			""punpcklwd %%mm6, %%mm6		
\t""

			""xorl %%eax, %%eax		
\t"" // i

			""movl %0, %%esi			
\t"" // src

			""movl %1, %%edi			
\t"" // buf1

			""movl %3, %%edx			
\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		
\t""

			""xorl %%ebx, %%ebx		
\t""

			""movw %4, %%bx			
\t"" // (xInc*4)&0xFFFF



#define hflags \

			PREFETCH"" 1024(%%esi)		
\t""\

			PREFETCH"" 1056(%%esi)		
\t""\

			PREFETCH"" 1088(%%esi)		
\t""\

			""call ""MANGLE(funnyYCode)""	
\t""\

			""movq ""MANGLE(temp0)"", %%mm2	
\t""\

			""xorl %%ecx, %%ecx		
\t""



hflags

hflags

hflags

hflags

hflags

hflags

hflags

hflags



			:: ""m"" (pfd), ""m"" (gen_helper_write_eflags), ""m"" (AV_CODEC_ID_ADPCM_G726), ""m"" ((XBZRLE*4)>>16),

			""m"" ((XBZRLE*4)&0xFFFF), ""m"" (XBZRLE&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(entry_point=AV_CODEC_ID_ADPCM_G726-1; (entry_point*XBZRLE)>>16 >=srcW-1; entry_point--) gen_helper_write_eflags[entry_point] = pfd[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		
\t"" // i

		""xorl %%ebx, %%ebx		
\t"" // xx

		""xorl %%ecx, %%ecx		
\t"" // 2*xalpha

		"".balign 16			
\t""

		""1:				
\t""

		""movzbl  (%0, %%ebx), %%edi	
\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	
\t"" //src[xx+1]

		""subl %%edi, %%esi		
\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		
\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		
\t""

		""addl %%edi, %%esi		
\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			
\t""

		""shrl $9, %%esi			
\t""

		""movw %%si, (%%edi, %%eax, 2)	
\t""

		""addw %4, %%cx			
\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			
\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	
\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	
\t"" //src[xx+1]

		""subl %%edi, %%esi		
\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		
\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		
\t""

		""addl %%edi, %%esi		
\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			
\t""

		""shrl $9, %%esi			
\t""

		""movw %%si, 2(%%edi, %%eax, 2)	
\t""

		""addw %4, %%cx			
\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			
\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			
\t""

		""cmpl %2, %%eax			
\t""

		"" jb 1b				
\t""





		:: ""r"" (pfd), ""m"" (gen_helper_write_eflags), ""m"" (AV_CODEC_ID_ADPCM_G726), ""m"" (XBZRLE>>16), ""m"" (XBZRLE&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int entry_point;

	unsigned int xpos=0;

	for(entry_point=0;entry_point<AV_CODEC_ID_ADPCM_G726;entry_point++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		gen_helper_write_eflags[entry_point]= (pfd[xx]<<7) + (pfd[xx+1] - pfd[xx])*xalpha;

		xpos+=XBZRLE;

	}

#endif

    }

}
",1,1,0,1,dstWidth,-0.21749001741409302,6,48,"{'i': 'entry_point', 'dst': 'gen_helper_write_eflags', 'xInc': 'XBZRLE', 'src': 'pfd', 'FUNNY_Y_CODE': 'hflags', 'dstWidth': 'AV_CODEC_ID_ADPCM_G726'}",MHM-Origin,124,0.06359083652496338
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",50,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t ev_signo)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",1,1,0,1,size,-0.9585405513644218,1,1,{'size': 'ev_signo'},MHM-Origin,22,0.008180832862854004
254,"static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,

                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,

                              const uint8_t *buf, int len, uint16_t seq,

                              int flags)

{

    uint8_t nal;

    uint8_t type;

    int result = 0;



    if (!len) {

        av_log(ctx, AV_LOG_ERROR, ""Empty H264 RTP packet\n"");

        return AVERROR_INVALIDDATA;

    }

    nal  = buf[0];

    type = nal & 0x1f;



    assert(data);

    assert(buf);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (type >= 1 && type <= 23)

        type = 1;

    switch (type) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(pkt, len + sizeof(start_sequence));

        memcpy(pkt->data, start_sequence, sizeof(start_sequence));

        memcpy(pkt->data + sizeof(start_sequence), buf, len);

        COUNT_NAL_TYPE(data, nal);

        break;



    case 24:                   // STAP-A (one packet, multiple nals)

        // consume the STAP-A NAL

        buf++;

        len--;

        // first we are going to figure out the total size

        {

            int pass         = 0;

            int total_length = 0;

            uint8_t *dst     = NULL;



            for (pass = 0; pass < 2; pass++) {

                const uint8_t *src = buf;

                int src_len        = len;



                while (src_len > 2) {

                    uint16_t nal_size = AV_RB16(src);



                    // consume the length of the aggregate

                    src     += 2;

                    src_len -= 2;



                    if (nal_size <= src_len) {

                        if (pass == 0) {

                            // counting

                            total_length += sizeof(start_sequence) + nal_size;

                        } else {

                            // copying

                            assert(dst);

                            memcpy(dst, start_sequence, sizeof(start_sequence));

                            dst += sizeof(start_sequence);

                            memcpy(dst, src, nal_size);

                            COUNT_NAL_TYPE(data, *src);

                            dst += nal_size;

                        }

                    } else {

                        av_log(ctx, AV_LOG_ERROR,

                               ""nal size exceeds length: %d %d\n"", nal_size, src_len);

                    }



                    // eat what we handled

                    src     += nal_size;

                    src_len -= nal_size;



                    if (src_len < 0)

                        av_log(ctx, AV_LOG_ERROR,

                               ""Consumed more bytes than we got! (%d)\n"", src_len);

                }



                if (pass == 0) {

                    /* now we know the total size of the packet (with the

                     * start sequences added) */

                    av_new_packet(pkt, total_length);

                    dst = pkt->data;

                } else {

                    assert(dst - pkt->data == total_length);

                }

            }

        }

        break;



    case 25:                   // STAP-B

    case 26:                   // MTAP-16

    case 27:                   // MTAP-24

    case 29:                   // FU-B

        av_log(ctx, AV_LOG_ERROR,

               ""Unhandled type (%d) (See RFC for implementation details\n"",

               type);

        result = AVERROR(ENOSYS);

        break;



    case 28:                   // FU-A (fragmented nal)

        buf++;

        len--;                 // skip the fu_indicator

        if (len > 1) {

            // these are the same as above, we just redo them here for clarity

            uint8_t fu_indicator      = nal;

            uint8_t fu_header         = *buf;

            uint8_t start_bit         = fu_header >> 7;

            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;

            uint8_t nal_type          = fu_header & 0x1f;

            uint8_t reconstructed_nal;



            // Reconstruct this packet's true nal; only the data follows.

            /* The original nal forbidden bit and NRI are stored in this

             * packet's nal. */

            reconstructed_nal  = fu_indicator & 0xe0;

            reconstructed_nal |= nal_type;



            // skip the fu_header

            buf++;

            len--;



            if (start_bit)

                COUNT_NAL_TYPE(data, nal_type);

            if (start_bit) {

                /* copy in the start sequence, and the reconstructed nal */

                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);

                memcpy(pkt->data, start_sequence, sizeof(start_sequence));

                pkt->data[sizeof(start_sequence)] = reconstructed_nal;

                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);

            } else {

                av_new_packet(pkt, len);

                memcpy(pkt->data, buf, len);

            }

        } else {

            av_log(ctx, AV_LOG_ERROR, ""Too short data for FU-A H264 RTP packet\n"");

            result = AVERROR_INVALIDDATA;

        }

        break;



    case 30:                   // undefined

    case 31:                   // undefined

    default:

        av_log(ctx, AV_LOG_ERROR, ""Undefined type (%d)\n"", type);

        result = AVERROR_INVALIDDATA;

        break;

    }



    pkt->stream_index = st->index;



    return result;

}
",672,"static int h264_handle_packet(AVFormatContext *MO_16, PayloadContext *data,

                              AVStream *st, AVPacket *object_class_is_abstract, uint32_t *timestamp,

                              const uint8_t *buf, int avio_close, uint16_t omap_gpio_init,

                              int MO_32)

{

    uint8_t attachments;

    uint8_t edge_emu_buffer;

    int result = 0;



    if (!avio_close) {

        av_log(MO_16, AV_LOG_ERROR, ""Empty H264 RTP packet
"");

        return AVERROR_INVALIDDATA;

    }

    attachments  = buf[0];

    edge_emu_buffer = attachments & 0x1f;



    assert(data);

    assert(buf);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (edge_emu_buffer >= 1 && edge_emu_buffer <= 23)

        edge_emu_buffer = 1;

    switch (edge_emu_buffer) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(object_class_is_abstract, avio_close + sizeof(start_sequence));

        memcpy(object_class_is_abstract->data, start_sequence, sizeof(start_sequence));

        memcpy(object_class_is_abstract->data + sizeof(start_sequence), buf, avio_close);

        COUNT_NAL_TYPE(data, attachments);

        break;



    case 24:                   // STAP-A (one packet, multiple nals)

        // consume the STAP-A NAL

        buf++;

        avio_close--;

        // first we are going to figure out the total size

        {

            int pass         = 0;

            int total_length = 0;

            uint8_t *dst     = NULL;



            for (pass = 0; pass < 2; pass++) {

                const uint8_t *src = buf;

                int src_len        = avio_close;



                while (src_len > 2) {

                    uint16_t nal_size = AV_RB16(src);



                    // consume the length of the aggregate

                    src     += 2;

                    src_len -= 2;



                    if (nal_size <= src_len) {

                        if (pass == 0) {

                            // counting

                            total_length += sizeof(start_sequence) + nal_size;

                        } else {

                            // copying

                            assert(dst);

                            memcpy(dst, start_sequence, sizeof(start_sequence));

                            dst += sizeof(start_sequence);

                            memcpy(dst, src, nal_size);

                            COUNT_NAL_TYPE(data, *src);

                            dst += nal_size;

                        }

                    } else {

                        av_log(MO_16, AV_LOG_ERROR,

                               ""nal size exceeds length: %d %d
"", nal_size, src_len);

                    }



                    // eat what we handled

                    src     += nal_size;

                    src_len -= nal_size;



                    if (src_len < 0)

                        av_log(MO_16, AV_LOG_ERROR,

                               ""Consumed more bytes than we got! (%d)
"", src_len);

                }



                if (pass == 0) {

                    /* now we know the total size of the packet (with the

                     * start sequences added) */

                    av_new_packet(object_class_is_abstract, total_length);

                    dst = object_class_is_abstract->data;

                } else {

                    assert(dst - object_class_is_abstract->data == total_length);

                }

            }

        }

        break;



    case 25:                   // STAP-B

    case 26:                   // MTAP-16

    case 27:                   // MTAP-24

    case 29:                   // FU-B

        av_log(MO_16, AV_LOG_ERROR,

               ""Unhandled type (%d) (See RFC for implementation details
"",

               edge_emu_buffer);

        result = AVERROR(ENOSYS);

        break;



    case 28:                   // FU-A (fragmented nal)

        buf++;

        avio_close--;                 // skip the fu_indicator

        if (avio_close > 1) {

            // these are the same as above, we just redo them here for clarity

            uint8_t fu_indicator      = attachments;

            uint8_t fu_header         = *buf;

            uint8_t start_bit         = fu_header >> 7;

            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;

            uint8_t nal_type          = fu_header & 0x1f;

            uint8_t reconstructed_nal;



            // Reconstruct this packet's true nal; only the data follows.

            /* The original nal forbidden bit and NRI are stored in this

             * packet's nal. */

            reconstructed_nal  = fu_indicator & 0xe0;

            reconstructed_nal |= nal_type;



            // skip the fu_header

            buf++;

            avio_close--;



            if (start_bit)

                COUNT_NAL_TYPE(data, nal_type);

            if (start_bit) {

                /* copy in the start sequence, and the reconstructed nal */

                av_new_packet(object_class_is_abstract, sizeof(start_sequence) + sizeof(attachments) + avio_close);

                memcpy(object_class_is_abstract->data, start_sequence, sizeof(start_sequence));

                object_class_is_abstract->data[sizeof(start_sequence)] = reconstructed_nal;

                memcpy(object_class_is_abstract->data + sizeof(start_sequence) + sizeof(attachments), buf, avio_close);

            } else {

                av_new_packet(object_class_is_abstract, avio_close);

                memcpy(object_class_is_abstract->data, buf, avio_close);

            }

        } else {

            av_log(MO_16, AV_LOG_ERROR, ""Too short data for FU-A H264 RTP packet
"");

            result = AVERROR_INVALIDDATA;

        }

        break;



    case 30:                   // undefined

    case 31:                   // undefined

    default:

        av_log(MO_16, AV_LOG_ERROR, ""Undefined type (%d)
"", edge_emu_buffer);

        result = AVERROR_INVALIDDATA;

        break;

    }



    object_class_is_abstract->stream_index = st->index;



    return result;

}
",1,1,0,1,seq,-0.20044204592704773,7,54,"{'pkt': 'object_class_is_abstract', 'ctx': 'MO_16', 'type': 'edge_emu_buffer', 'len': 'avio_close', 'nal': 'attachments', 'seq': 'omap_gpio_init', 'flags': 'MO_32'}",MHM-Origin,221,0.11195654074350993
255,"void bdrv_refresh_filename(BlockDriverState *bs)

{

    BlockDriver *drv = bs->drv;

    QDict *opts;



    if (!drv) {

        return;

    }



    /* This BDS's file name will most probably depend on its file's name, so

     * refresh that first */

    if (bs->file) {

        bdrv_refresh_filename(bs->file->bs);

    }



    if (drv->bdrv_refresh_filename) {

        /* Obsolete information is of no use here, so drop the old file name

         * information before refreshing it */

        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        drv->bdrv_refresh_filename(bs);

    } else if (bs->file) {

        /* Try to reconstruct valid information from the underlying file */

        bool has_open_options;



        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        opts = qdict_new();

        has_open_options = append_open_options(opts, bs);



        /* If no specific options have been given for this BDS, the filename of

         * the underlying file should suffice for this one as well */

        if (bs->file->bs->exact_filename[0] && !has_open_options) {

            strcpy(bs->exact_filename, bs->file->bs->exact_filename);

        }

        /* Reconstructing the full options QDict is simple for most format block

         * drivers, as long as the full options are known for the underlying

         * file BDS. The full options QDict of that file BDS should somehow

         * contain a representation of the filename, therefore the following

         * suffices without querying the (exact_)filename of this BDS. */

        if (bs->file->bs->full_open_options) {

            qdict_put_obj(opts, ""driver"",

                          QOBJECT(qstring_from_str(drv->format_name)));

            QINCREF(bs->file->bs->full_open_options);

            qdict_put_obj(opts, ""file"",

                          QOBJECT(bs->file->bs->full_open_options));



            bs->full_open_options = opts;

        } else {

            QDECREF(opts);

        }

    } else if (!bs->full_open_options && qdict_size(bs->options)) {

        /* There is no underlying file BDS (at least referenced by BDS.file),

         * so the full options QDict should be equal to the options given

         * specifically for this block device when it was opened (plus the

         * driver specification).

         * Because those options don't change, there is no need to update

         * full_open_options when it's already set. */



        opts = qdict_new();

        append_open_options(opts, bs);

        qdict_put_obj(opts, ""driver"",

                      QOBJECT(qstring_from_str(drv->format_name)));



        if (bs->exact_filename[0]) {

            /* This may not work for all block protocol drivers (some may

             * require this filename to be parsed), but we have to find some

             * default solution here, so just include it. If some block driver

             * does not support pure options without any filename at all or

             * needs some special format of the options QDict, it needs to

             * implement the driver-specific bdrv_refresh_filename() function.

             */

            qdict_put_obj(opts, ""filename"",

                          QOBJECT(qstring_from_str(bs->exact_filename)));

        }



        bs->full_open_options = opts;

    }



    if (bs->exact_filename[0]) {

        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);

    } else if (bs->full_open_options) {

        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));

        snprintf(bs->filename, sizeof(bs->filename), ""json:%s"",

                 qstring_get_str(json));

        QDECREF(json);

    }

}
",427,"void bdrv_refresh_filename(BlockDriverState *data_cb_or_cr)

{

    BlockDriver *drv = data_cb_or_cr->drv;

    QDict *opts;



    if (!drv) {

        return;

    }



    /* This BDS's file name will most probably depend on its file's name, so

     * refresh that first */

    if (data_cb_or_cr->file) {

        bdrv_refresh_filename(data_cb_or_cr->file->data_cb_or_cr);

    }



    if (drv->bdrv_refresh_filename) {

        /* Obsolete information is of no use here, so drop the old file name

         * information before refreshing it */

        data_cb_or_cr->exact_filename[0] = '\0';

        if (data_cb_or_cr->full_open_options) {

            QDECREF(data_cb_or_cr->full_open_options);

            data_cb_or_cr->full_open_options = NULL;

        }



        drv->bdrv_refresh_filename(data_cb_or_cr);

    } else if (data_cb_or_cr->file) {

        /* Try to reconstruct valid information from the underlying file */

        bool has_open_options;



        data_cb_or_cr->exact_filename[0] = '\0';

        if (data_cb_or_cr->full_open_options) {

            QDECREF(data_cb_or_cr->full_open_options);

            data_cb_or_cr->full_open_options = NULL;

        }



        opts = qdict_new();

        has_open_options = append_open_options(opts, data_cb_or_cr);



        /* If no specific options have been given for this BDS, the filename of

         * the underlying file should suffice for this one as well */

        if (data_cb_or_cr->file->data_cb_or_cr->exact_filename[0] && !has_open_options) {

            strcpy(data_cb_or_cr->exact_filename, data_cb_or_cr->file->data_cb_or_cr->exact_filename);

        }

        /* Reconstructing the full options QDict is simple for most format block

         * drivers, as long as the full options are known for the underlying

         * file BDS. The full options QDict of that file BDS should somehow

         * contain a representation of the filename, therefore the following

         * suffices without querying the (exact_)filename of this BDS. */

        if (data_cb_or_cr->file->data_cb_or_cr->full_open_options) {

            qdict_put_obj(opts, ""driver"",

                          QOBJECT(qstring_from_str(drv->format_name)));

            QINCREF(data_cb_or_cr->file->data_cb_or_cr->full_open_options);

            qdict_put_obj(opts, ""file"",

                          QOBJECT(data_cb_or_cr->file->data_cb_or_cr->full_open_options));



            data_cb_or_cr->full_open_options = opts;

        } else {

            QDECREF(opts);

        }

    } else if (!data_cb_or_cr->full_open_options && qdict_size(data_cb_or_cr->options)) {

        /* There is no underlying file BDS (at least referenced by BDS.file),

         * so the full options QDict should be equal to the options given

         * specifically for this block device when it was opened (plus the

         * driver specification).

         * Because those options don't change, there is no need to update

         * full_open_options when it's already set. */



        opts = qdict_new();

        append_open_options(opts, data_cb_or_cr);

        qdict_put_obj(opts, ""driver"",

                      QOBJECT(qstring_from_str(drv->format_name)));



        if (data_cb_or_cr->exact_filename[0]) {

            /* This may not work for all block protocol drivers (some may

             * require this filename to be parsed), but we have to find some

             * default solution here, so just include it. If some block driver

             * does not support pure options without any filename at all or

             * needs some special format of the options QDict, it needs to

             * implement the driver-specific bdrv_refresh_filename() function.

             */

            qdict_put_obj(opts, ""filename"",

                          QOBJECT(qstring_from_str(data_cb_or_cr->exact_filename)));

        }



        data_cb_or_cr->full_open_options = opts;

    }



    if (data_cb_or_cr->exact_filename[0]) {

        pstrcpy(data_cb_or_cr->filename, sizeof(data_cb_or_cr->filename), data_cb_or_cr->exact_filename);

    } else if (data_cb_or_cr->full_open_options) {

        QString *json = qobject_to_json(QOBJECT(data_cb_or_cr->full_open_options));

        snprintf(data_cb_or_cr->filename, sizeof(data_cb_or_cr->filename), ""json:%s"",

                 qstring_get_str(json));

        QDECREF(json);

    }

}
",0,0,1,1,bs,0.19459643959999084,1,42,{'bs': 'data_cb_or_cr'},MHM-Origin,19,0.009171052773793539
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",39,"void ff_dnxhdenc_init_x86(DNXHDEncContext *predictor)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & predictor) {

        if (predictor->cid_table->bit_depth == 8)

            predictor->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",0,0,0,-1,ctx,-2.4211592972278595e-05,1,3,{'ctx': 'predictor'},MHM-Origin,395,0.1607943892478943
258,"uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)

{

    CPU_DoubleU farg1, farg2;



    farg1.ll = arg1;

    farg2.ll = arg2;



    if (unlikely(float64_is_infinity(farg1.d) &&

                 float64_is_infinity(farg2.d))) {

        /* Division of infinity by infinity */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {

        /* Division of zero by zero */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(farg1.d) ||

                     float64_is_signaling_nan(farg2.d))) {

            /* sNaN division */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

        }

        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);

    }



    return farg1.ll;

}
",153,"uint64_t helper_fdiv(CPUPPCState *tail_size, uint64_t BLOCKDEV_ON_ERROR_STOP, uint64_t fuzz_tag)

{

    CPU_DoubleU mdct, SYS_BUS_DEVICE;



    mdct.ll = BLOCKDEV_ON_ERROR_STOP;

    SYS_BUS_DEVICE.ll = fuzz_tag;



    if (unlikely(float64_is_infinity(mdct.d) &&

                 float64_is_infinity(SYS_BUS_DEVICE.d))) {

        /* Division of infinity by infinity */

        mdct.ll = fload_invalid_op_excp(tail_size, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(mdct.d) && float64_is_zero(SYS_BUS_DEVICE.d))) {

        /* Division of zero by zero */

        mdct.ll = fload_invalid_op_excp(tail_size, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(mdct.d) ||

                     float64_is_signaling_nan(SYS_BUS_DEVICE.d))) {

            /* sNaN division */

            fload_invalid_op_excp(tail_size, POWERPC_EXCP_FP_VXSNAN);

        }

        mdct.d = float64_div(mdct.d, SYS_BUS_DEVICE.d, &tail_size->fp_status);

    }



    return mdct.ll;

}
",0,0,0,-1,arg1,-0.0008847042918205261,5,25,"{'arg1': 'BLOCKDEV_ON_ERROR_STOP', 'arg2': 'fuzz_tag', 'farg2': 'SYS_BUS_DEVICE', 'env': 'tail_size', 'farg1': 'mdct'}",MHM-Origin,403,0.16991392374038697
259,"static void test_io_channel_ipv4(bool async)

{

    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    SocketAddress *connect_addr = g_new0(SocketAddress, 1);



    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    listen_addr->u.inet = g_new0(InetSocketAddress, 1);

    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");

    listen_addr->u.inet->port = NULL; /* Auto-select */



    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);



    qapi_free_SocketAddress(listen_addr);

    qapi_free_SocketAddress(connect_addr);

}
",138,"static void test_io_channel_ipv4(bool HV_X64_MSR_SIEFP)

{

    SocketAddress *prot = g_new0(SocketAddress, 1);

    SocketAddress *DC_VLC_BITS = g_new0(SocketAddress, 1);



    prot->type = SOCKET_ADDRESS_KIND_INET;

    prot->u.inet = g_new0(InetSocketAddress, 1);

    prot->u.inet->host = g_strdup(""0.0.0.0"");

    prot->u.inet->port = NULL; /* Auto-select */



    DC_VLC_BITS->type = SOCKET_ADDRESS_KIND_INET;

    DC_VLC_BITS->u.inet = g_new0(InetSocketAddress, 1);

    DC_VLC_BITS->u.inet->host = g_strdup(""127.0.0.1"");

    DC_VLC_BITS->u.inet->port = NULL; /* Filled in later */



    test_io_channel(HV_X64_MSR_SIEFP, prot, DC_VLC_BITS);



    qapi_free_SocketAddress(prot);

    qapi_free_SocketAddress(DC_VLC_BITS);

}
",0,0,0,-1,connect_addr,-0.0015431172214448452,3,16,"{'async': 'HV_X64_MSR_SIEFP', 'listen_addr': 'prot', 'connect_addr': 'DC_VLC_BITS'}",MHM-Origin,390,0.16602031389872232
260,"static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)

{

    const char *opn = ""loongson_cp2"";

    uint32_t opc, shift_max;

    TCGv_i64 t0, t1;



    opc = MASK_LMI(ctx->opcode);

    switch (opc) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        t0 = tcg_temp_local_new_i64();

        t1 = tcg_temp_local_new_i64();

        break;

    default:

        t0 = tcg_temp_new_i64();

        t1 = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(ctx, t0, rs);

    gen_load_fpr64(ctx, t1, rt);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (opc) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPER(PADDW, paddw);

    LMI_HELPER(PADDSB, paddsb);

    LMI_HELPER(PADDUSB, paddusb);

    LMI_HELPER(PADDB, paddb);



    LMI_HELPER(PSUBSH, psubsh);

    LMI_HELPER(PSUBUSH, psubush);

    LMI_HELPER(PSUBH, psubh);

    LMI_HELPER(PSUBW, psubw);

    LMI_HELPER(PSUBSB, psubsb);

    LMI_HELPER(PSUBUSB, psubusb);

    LMI_HELPER(PSUBB, psubb);



    LMI_HELPER(PSHUFH, pshufh);

    LMI_HELPER(PACKSSWH, packsswh);

    LMI_HELPER(PACKSSHB, packsshb);

    LMI_HELPER(PACKUSHB, packushb);



    LMI_HELPER(PUNPCKLHW, punpcklhw);

    LMI_HELPER(PUNPCKHHW, punpckhhw);

    LMI_HELPER(PUNPCKLBH, punpcklbh);

    LMI_HELPER(PUNPCKHBH, punpckhbh);

    LMI_HELPER(PUNPCKLWD, punpcklwd);

    LMI_HELPER(PUNPCKHWD, punpckhwd);



    LMI_HELPER(PAVGH, pavgh);

    LMI_HELPER(PAVGB, pavgb);

    LMI_HELPER(PMAXSH, pmaxsh);

    LMI_HELPER(PMINSH, pminsh);

    LMI_HELPER(PMAXUB, pmaxub);

    LMI_HELPER(PMINUB, pminub);



    LMI_HELPER(PCMPEQW, pcmpeqw);

    LMI_HELPER(PCMPGTW, pcmpgtw);

    LMI_HELPER(PCMPEQH, pcmpeqh);

    LMI_HELPER(PCMPGTH, pcmpgth);

    LMI_HELPER(PCMPEQB, pcmpeqb);

    LMI_HELPER(PCMPGTB, pcmpgtb);



    LMI_HELPER(PSLLW, psllw);

    LMI_HELPER(PSLLH, psllh);

    LMI_HELPER(PSRLW, psrlw);

    LMI_HELPER(PSRLH, psrlh);

    LMI_HELPER(PSRAW, psraw);

    LMI_HELPER(PSRAH, psrah);



    LMI_HELPER(PMULLH, pmullh);

    LMI_HELPER(PMULHH, pmulhh);

    LMI_HELPER(PMULHUH, pmulhuh);

    LMI_HELPER(PMADDHW, pmaddhw);



    LMI_HELPER(PASUBUB, pasubub);

    LMI_HELPER_1(BIADD, biadd);

    LMI_HELPER_1(PMOVMSKB, pmovmskb);



    LMI_DIRECT(PADDD, paddd, add);

    LMI_DIRECT(PSUBD, psubd, sub);

    LMI_DIRECT(XOR_CP2, xor, xor);

    LMI_DIRECT(NOR_CP2, nor, nor);

    LMI_DIRECT(AND_CP2, and, and);

    LMI_DIRECT(PANDN, pandn, andc);

    LMI_DIRECT(OR, or, or);



    case OPC_PINSRH_0:

        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);

        opn = ""pinsrh_0"";

        break;

    case OPC_PINSRH_1:

        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);

        opn = ""pinsrh_1"";

        break;

    case OPC_PINSRH_2:

        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);

        opn = ""pinsrh_2"";

        break;

    case OPC_PINSRH_3:

        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);

        opn = ""pinsrh_3"";

        break;



    case OPC_PEXTRH:

        tcg_gen_andi_i64(t1, t1, 3);

        tcg_gen_shli_i64(t1, t1, 4);

        tcg_gen_shr_i64(t0, t0, t1);

        tcg_gen_ext16u_i64(t0, t0);

        opn = ""pextrh"";

        break;



    case OPC_ADDU_CP2:

        tcg_gen_add_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;

    case OPC_SUBU_CP2:

        tcg_gen_sub_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;



    case OPC_SLL_CP2:

        opn = ""sll"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRL_CP2:

        opn = ""srl"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRA_CP2:

        opn = ""sra"";

        shift_max = 32;

        goto do_shift;

    case OPC_DSLL_CP2:

        opn = ""dsll"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRL_CP2:

        opn = ""dsrl"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRA_CP2:

        opn = ""dsra"";

        shift_max = 64;

        goto do_shift;

    do_shift:

        /* Make sure shift count isn't TCG undefined behaviour.  */

        tcg_gen_andi_i64(t1, t1, shift_max - 1);



        switch (opc) {

        case OPC_SLL_CP2:

        case OPC_DSLL_CP2:

            tcg_gen_shl_i64(t0, t0, t1);

            break;

        case OPC_SRA_CP2:

        case OPC_DSRA_CP2:

            /* Since SRA is UndefinedResult without sign-extended inputs,

               we can treat SRA and DSRA the same.  */

            tcg_gen_sar_i64(t0, t0, t1);

            break;

        case OPC_SRL_CP2:

            /* We want to shift in zeros for SRL; zero-extend first.  */

            tcg_gen_ext32u_i64(t0, t0);

            /* FALLTHRU */

        case OPC_DSRL_CP2:

            tcg_gen_shr_i64(t0, t0, t1);

            break;

        }



        if (shift_max == 32) {

            tcg_gen_ext32s_i64(t0, t0);

        }



        /* Shifts larger than MAX produce zero.  */

        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);

        tcg_gen_neg_i64(t1, t1);

        tcg_gen_and_i64(t0, t0, t1);

        break;



    case OPC_ADD_CP2:

    case OPC_DADD_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_add_i64(t0, t1, t2);

            if (opc == OPC_ADD_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_andc_i64(t1, t2, t1);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_ADD_CP2 ? ""add"" : ""dadd"");

            break;

        }



    case OPC_SUB_CP2:

    case OPC_DSUB_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_sub_i64(t0, t1, t2);

            if (opc == OPC_SUB_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_and_i64(t1, t1, t2);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_SUB_CP2 ? ""sub"" : ""dsub"");

            break;

        }



    case OPC_PMULUW:

        tcg_gen_ext32u_i64(t0, t0);

        tcg_gen_ext32u_i64(t1, t1);

        tcg_gen_mul_i64(t0, t0, t1);

        opn = ""pmuluw"";

        break;



    case OPC_SEQU_CP2:

    case OPC_SEQ_CP2:

    case OPC_SLTU_CP2:

    case OPC_SLT_CP2:

    case OPC_SLEU_CP2:

    case OPC_SLE_CP2:

        /* ??? Document is unclear: Set FCC[CC].  Does that mean the

           FD field is the CC field?  */

    default:

        MIPS_INVAL(opn);

        generate_exception(ctx, EXCP_RI);

        return;

    }



#undef LMI_HELPER

#undef LMI_DIRECT



    gen_store_fpr64(ctx, t0, rd);



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s, %s"", opn,

               fregnames[rd], fregnames[rs], fregnames[rt]);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i64(t1);

}
",1335,"static void gen_loongson_multimedia(DisasContext *ctx, int rd, int O_NONBLOCK, int rt)

{

    const char *opn = ""loongson_cp2"";

    uint32_t opc, shift_max;

    TCGv_i64 t0, bytestream2_init;



    opc = MASK_LMI(ctx->opcode);

    switch (opc) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        t0 = tcg_temp_local_new_i64();

        bytestream2_init = tcg_temp_local_new_i64();

        break;

    default:

        t0 = tcg_temp_new_i64();

        bytestream2_init = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(ctx, t0, O_NONBLOCK);

    gen_load_fpr64(ctx, bytestream2_init, rt);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (opc) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPER(PADDW, paddw);

    LMI_HELPER(PADDSB, paddsb);

    LMI_HELPER(PADDUSB, paddusb);

    LMI_HELPER(PADDB, paddb);



    LMI_HELPER(PSUBSH, psubsh);

    LMI_HELPER(PSUBUSH, psubush);

    LMI_HELPER(PSUBH, psubh);

    LMI_HELPER(PSUBW, psubw);

    LMI_HELPER(PSUBSB, psubsb);

    LMI_HELPER(PSUBUSB, psubusb);

    LMI_HELPER(PSUBB, psubb);



    LMI_HELPER(PSHUFH, pshufh);

    LMI_HELPER(PACKSSWH, packsswh);

    LMI_HELPER(PACKSSHB, packsshb);

    LMI_HELPER(PACKUSHB, packushb);



    LMI_HELPER(PUNPCKLHW, punpcklhw);

    LMI_HELPER(PUNPCKHHW, punpckhhw);

    LMI_HELPER(PUNPCKLBH, punpcklbh);

    LMI_HELPER(PUNPCKHBH, punpckhbh);

    LMI_HELPER(PUNPCKLWD, punpcklwd);

    LMI_HELPER(PUNPCKHWD, punpckhwd);



    LMI_HELPER(PAVGH, pavgh);

    LMI_HELPER(PAVGB, pavgb);

    LMI_HELPER(PMAXSH, pmaxsh);

    LMI_HELPER(PMINSH, pminsh);

    LMI_HELPER(PMAXUB, pmaxub);

    LMI_HELPER(PMINUB, pminub);



    LMI_HELPER(PCMPEQW, pcmpeqw);

    LMI_HELPER(PCMPGTW, pcmpgtw);

    LMI_HELPER(PCMPEQH, pcmpeqh);

    LMI_HELPER(PCMPGTH, pcmpgth);

    LMI_HELPER(PCMPEQB, pcmpeqb);

    LMI_HELPER(PCMPGTB, pcmpgtb);



    LMI_HELPER(PSLLW, psllw);

    LMI_HELPER(PSLLH, psllh);

    LMI_HELPER(PSRLW, psrlw);

    LMI_HELPER(PSRLH, psrlh);

    LMI_HELPER(PSRAW, psraw);

    LMI_HELPER(PSRAH, psrah);



    LMI_HELPER(PMULLH, pmullh);

    LMI_HELPER(PMULHH, pmulhh);

    LMI_HELPER(PMULHUH, pmulhuh);

    LMI_HELPER(PMADDHW, pmaddhw);



    LMI_HELPER(PASUBUB, pasubub);

    LMI_HELPER_1(BIADD, biadd);

    LMI_HELPER_1(PMOVMSKB, pmovmskb);



    LMI_DIRECT(PADDD, paddd, add);

    LMI_DIRECT(PSUBD, psubd, sub);

    LMI_DIRECT(XOR_CP2, xor, xor);

    LMI_DIRECT(NOR_CP2, nor, nor);

    LMI_DIRECT(AND_CP2, and, and);

    LMI_DIRECT(PANDN, pandn, andc);

    LMI_DIRECT(OR, or, or);



    case OPC_PINSRH_0:

        tcg_gen_deposit_i64(t0, t0, bytestream2_init, 0, 16);

        opn = ""pinsrh_0"";

        break;

    case OPC_PINSRH_1:

        tcg_gen_deposit_i64(t0, t0, bytestream2_init, 16, 16);

        opn = ""pinsrh_1"";

        break;

    case OPC_PINSRH_2:

        tcg_gen_deposit_i64(t0, t0, bytestream2_init, 32, 16);

        opn = ""pinsrh_2"";

        break;

    case OPC_PINSRH_3:

        tcg_gen_deposit_i64(t0, t0, bytestream2_init, 48, 16);

        opn = ""pinsrh_3"";

        break;



    case OPC_PEXTRH:

        tcg_gen_andi_i64(bytestream2_init, bytestream2_init, 3);

        tcg_gen_shli_i64(bytestream2_init, bytestream2_init, 4);

        tcg_gen_shr_i64(t0, t0, bytestream2_init);

        tcg_gen_ext16u_i64(t0, t0);

        opn = ""pextrh"";

        break;



    case OPC_ADDU_CP2:

        tcg_gen_add_i64(t0, t0, bytestream2_init);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;

    case OPC_SUBU_CP2:

        tcg_gen_sub_i64(t0, t0, bytestream2_init);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;



    case OPC_SLL_CP2:

        opn = ""sll"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRL_CP2:

        opn = ""srl"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRA_CP2:

        opn = ""sra"";

        shift_max = 32;

        goto do_shift;

    case OPC_DSLL_CP2:

        opn = ""dsll"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRL_CP2:

        opn = ""dsrl"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRA_CP2:

        opn = ""dsra"";

        shift_max = 64;

        goto do_shift;

    do_shift:

        /* Make sure shift count isn't TCG undefined behaviour.  */

        tcg_gen_andi_i64(bytestream2_init, bytestream2_init, shift_max - 1);



        switch (opc) {

        case OPC_SLL_CP2:

        case OPC_DSLL_CP2:

            tcg_gen_shl_i64(t0, t0, bytestream2_init);

            break;

        case OPC_SRA_CP2:

        case OPC_DSRA_CP2:

            /* Since SRA is UndefinedResult without sign-extended inputs,

               we can treat SRA and DSRA the same.  */

            tcg_gen_sar_i64(t0, t0, bytestream2_init);

            break;

        case OPC_SRL_CP2:

            /* We want to shift in zeros for SRL; zero-extend first.  */

            tcg_gen_ext32u_i64(t0, t0);

            /* FALLTHRU */

        case OPC_DSRL_CP2:

            tcg_gen_shr_i64(t0, t0, bytestream2_init);

            break;

        }



        if (shift_max == 32) {

            tcg_gen_ext32s_i64(t0, t0);

        }



        /* Shifts larger than MAX produce zero.  */

        tcg_gen_setcondi_i64(TCG_COND_LTU, bytestream2_init, bytestream2_init, shift_max);

        tcg_gen_neg_i64(bytestream2_init, bytestream2_init);

        tcg_gen_and_i64(t0, t0, bytestream2_init);

        break;



    case OPC_ADD_CP2:

    case OPC_DADD_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_add_i64(t0, bytestream2_init, t2);

            if (opc == OPC_ADD_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(bytestream2_init, bytestream2_init, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_andc_i64(bytestream2_init, t2, bytestream2_init);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, bytestream2_init, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_ADD_CP2 ? ""add"" : ""dadd"");

            break;

        }



    case OPC_SUB_CP2:

    case OPC_DSUB_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_sub_i64(t0, bytestream2_init, t2);

            if (opc == OPC_SUB_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(bytestream2_init, bytestream2_init, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_and_i64(bytestream2_init, bytestream2_init, t2);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, bytestream2_init, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_SUB_CP2 ? ""sub"" : ""dsub"");

            break;

        }



    case OPC_PMULUW:

        tcg_gen_ext32u_i64(t0, t0);

        tcg_gen_ext32u_i64(bytestream2_init, bytestream2_init);

        tcg_gen_mul_i64(t0, t0, bytestream2_init);

        opn = ""pmuluw"";

        break;



    case OPC_SEQU_CP2:

    case OPC_SEQ_CP2:

    case OPC_SLTU_CP2:

    case OPC_SLT_CP2:

    case OPC_SLEU_CP2:

    case OPC_SLE_CP2:

        /* ??? Document is unclear: Set FCC[CC].  Does that mean the

           FD field is the CC field?  */

    default:

        MIPS_INVAL(opn);

        generate_exception(ctx, EXCP_RI);

        return;

    }



#undef LMI_HELPER

#undef LMI_DIRECT



    gen_store_fpr64(ctx, t0, rd);



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s, %s"", opn,

               fregnames[rd], fregnames[O_NONBLOCK], fregnames[rt]);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i64(bytestream2_init);

}
",0,0,1,1,rs,0.3369518518447876,2,44,"{'t1': 'bytestream2_init', 'rs': 'O_NONBLOCK'}",MHM-Origin,41,0.026037863890329995
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}
",72,"uint64_t helper_addlv (uint64_t showed_multi_packet_warning, uint64_t op2)

{

    uint64_t tmp = showed_multi_packet_warning;

    showed_multi_packet_warning = (uint32_t)(showed_multi_packet_warning + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ showed_multi_packet_warning) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return showed_multi_packet_warning;

}
",1,1,0,1,op1,-0.9023061990737915,1,6,{'op1': 'showed_multi_packet_warning'},MHM-Origin,40,0.015943237145741782
263,"static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,

                                   RockerTlv **group_tlvs)

{

    OfDpaGroup *l2_group;

    RockerTlv **tlvs;

    int err;

    int i;



    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||

        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {

        return -ROCKER_EINVAL;

    }



    group->l2_flood.group_count =

        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);



    tlvs = g_malloc0((group->l2_flood.group_count + 1) *

                     sizeof(RockerTlv *));

    if (!tlvs) {

        return -ROCKER_ENOMEM;

    }



    g_free(group->l2_flood.group_ids);

    group->l2_flood.group_ids =

        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));

    if (!group->l2_flood.group_ids) {

        err = -ROCKER_ENOMEM;

        goto err_out;

    }



    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,

                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);



    for (i = 0; i < group->l2_flood.group_count; i++) {

        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);

    }



    /* All of the L2 interface groups referenced by the L2 flood

     * must have same VLAN

     */



    for (i = 0; i < group->l2_flood.group_count; i++) {

        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);

        if (!l2_group) {

            continue;

        }

        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==

             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&

            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=

             ROCKER_GROUP_VLAN_GET(group->id))) {

            DPRINTF(""l2 interface group 0x%08x VLAN doesn't match l2 ""

                    ""flood group 0x%08x\n"",

                    group->l2_flood.group_ids[i], group->id);

            err = -ROCKER_EINVAL;

            goto err_out;

        }

    }



    g_free(tlvs);

    return ROCKER_OK;



err_out:

    group->l2_flood.group_count = 0;

    g_free(group->l2_flood.group_ids);

    g_free(tlvs);



    return err;

}
",343,"static int of_dpa_cmd_add_l2_flood(OfDpa *r0_name, OfDpaGroup *group,

                                   RockerTlv **channel_layout_thd_stream2)

{

    OfDpaGroup *MSR_IA32_FEATURE_CONTROL;

    RockerTlv **tlvs;

    int gen_jr;

    int i;



    if (!channel_layout_thd_stream2[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||

        !channel_layout_thd_stream2[ROCKER_TLV_OF_DPA_GROUP_IDS]) {

        return -ROCKER_EINVAL;

    }



    group->l2_flood.group_count =

        rocker_tlv_get_le16(channel_layout_thd_stream2[ROCKER_TLV_OF_DPA_GROUP_COUNT]);



    tlvs = g_malloc0((group->l2_flood.group_count + 1) *

                     sizeof(RockerTlv *));

    if (!tlvs) {

        return -ROCKER_ENOMEM;

    }



    g_free(group->l2_flood.group_ids);

    group->l2_flood.group_ids =

        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));

    if (!group->l2_flood.group_ids) {

        gen_jr = -ROCKER_ENOMEM;

        goto err_out;

    }



    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,

                            channel_layout_thd_stream2[ROCKER_TLV_OF_DPA_GROUP_IDS]);



    for (i = 0; i < group->l2_flood.group_count; i++) {

        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);

    }



    /* All of the L2 interface groups referenced by the L2 flood

     * must have same VLAN

     */



    for (i = 0; i < group->l2_flood.group_count; i++) {

        MSR_IA32_FEATURE_CONTROL = of_dpa_group_find(r0_name, group->l2_flood.group_ids[i]);

        if (!MSR_IA32_FEATURE_CONTROL) {

            continue;

        }

        if ((ROCKER_GROUP_TYPE_GET(MSR_IA32_FEATURE_CONTROL->id) ==

             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&

            (ROCKER_GROUP_VLAN_GET(MSR_IA32_FEATURE_CONTROL->id) !=

             ROCKER_GROUP_VLAN_GET(group->id))) {

            DPRINTF(""l2 interface group 0x%08x VLAN doesn't match l2 ""

                    ""flood group 0x%08x
"",

                    group->l2_flood.group_ids[i], group->id);

            gen_jr = -ROCKER_EINVAL;

            goto err_out;

        }

    }



    g_free(tlvs);

    return ROCKER_OK;



err_out:

    group->l2_flood.group_count = 0;

    g_free(group->l2_flood.group_ids);

    g_free(tlvs);



    return gen_jr;

}
",1,1,0,1,of_dpa,-0.1325560212135315,4,16,"{'err': 'gen_jr', 'group_tlvs': 'channel_layout_thd_stream2', 'l2_group': 'MSR_IA32_FEATURE_CONTROL', 'of_dpa': 'r0_name'}",MHM-Origin,120,0.052731808026631674
264,"int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {

    const uint64_t fuzz_tag = FUZZ_TAG;

    FuzzDataBuffer buffer;

    const uint8_t *last = data;

    const uint8_t *end = data + size;

    uint32_t it = 0;



    if (!c)

        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.



    AVCodecContext* ctx = avcodec_alloc_context3(NULL);

    if (!ctx)

        error(""Failed memory allocation"");



    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs



    int res = avcodec_open2(ctx, c, NULL);

    if (res < 0)

        return res;



    FDBCreate(&buffer);

    int got_frame;

    AVFrame *frame = av_frame_alloc();

    if (!frame)

        error(""Failed memory allocation"");



    // Read very simple container

    AVPacket avpkt;

    while (data < end && it < maxiteration) {

        // Search for the TAG

        while (data + sizeof(fuzz_tag) < end) {

            if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag)

                break;

            data++;

        }

        if (data + sizeof(fuzz_tag) > end)

            data = end;



        FDBPrepare(&buffer, &avpkt, last, data - last);

        data += sizeof(fuzz_tag);

        last = data;



        // Iterate through all data

        while (avpkt.size > 0 && it++ < maxiteration) {

            av_frame_unref(frame);

            int ret = decode_handler(ctx, frame, &got_frame, &avpkt);



            if (it > 20)

                ctx->error_concealment = 0;



            if (ret <= 0 || ret > avpkt.size)

               break;



            avpkt.data += ret;

            avpkt.size -= ret;

        }

    }



    av_init_packet(&avpkt);

    avpkt.data = NULL;

    avpkt.size = 0;



    do {

        got_frame = 0;

        decode_handler(ctx, frame, &got_frame, &avpkt);

    } while (got_frame == 1 && it++ < maxiteration);



    av_frame_free(&frame);

    avcodec_free_context(&ctx);

    av_freep(&ctx);

    FDBDesroy(&buffer);

    return 0;

}",384,"int LLVMFuzzerTestOneInput(const uint8_t *trace_megasas_dcmd_internal_submit, size_t height) {

    const uint64_t fuzz_tag = FUZZ_TAG;

    FuzzDataBuffer hcScale;

    const uint8_t *val_type = trace_megasas_dcmd_internal_submit;

    const uint8_t *bdrv_pwrite_sync = trace_megasas_dcmd_internal_submit + height;

    uint32_t extent_path = 0;



    if (!c)

        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.



    AVCodecContext* mix_any_f = avcodec_alloc_context3(NULL);

    if (!mix_any_f)

        error(""Failed memory allocation"");



    mix_any_f->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs



    int res = avcodec_open2(mix_any_f, c, NULL);

    if (res < 0)

        return res;



    FDBCreate(&hcScale);

    int progress_mutex;

    AVFrame *frame = av_frame_alloc();

    if (!frame)

        error(""Failed memory allocation"");



    // Read very simple container

    AVPacket vector_height;

    while (trace_megasas_dcmd_internal_submit < bdrv_pwrite_sync && extent_path < maxiteration) {

        // Search for the TAG

        while (trace_megasas_dcmd_internal_submit + sizeof(fuzz_tag) < bdrv_pwrite_sync) {

            if (trace_megasas_dcmd_internal_submit[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(trace_megasas_dcmd_internal_submit) == fuzz_tag)

                break;

            trace_megasas_dcmd_internal_submit++;

        }

        if (trace_megasas_dcmd_internal_submit + sizeof(fuzz_tag) > bdrv_pwrite_sync)

            trace_megasas_dcmd_internal_submit = bdrv_pwrite_sync;



        FDBPrepare(&hcScale, &vector_height, val_type, trace_megasas_dcmd_internal_submit - val_type);

        trace_megasas_dcmd_internal_submit += sizeof(fuzz_tag);

        val_type = trace_megasas_dcmd_internal_submit;



        // Iterate through all data

        while (vector_height.height > 0 && extent_path++ < maxiteration) {

            av_frame_unref(frame);

            int ret = decode_handler(mix_any_f, frame, &progress_mutex, &vector_height);



            if (extent_path > 20)

                mix_any_f->error_concealment = 0;



            if (ret <= 0 || ret > vector_height.height)

               break;



            vector_height.trace_megasas_dcmd_internal_submit += ret;

            vector_height.height -= ret;

        }

    }



    av_init_packet(&vector_height);

    vector_height.trace_megasas_dcmd_internal_submit = NULL;

    vector_height.height = 0;



    do {

        progress_mutex = 0;

        decode_handler(mix_any_f, frame, &progress_mutex, &vector_height);

    } while (progress_mutex == 1 && extent_path++ < maxiteration);



    av_frame_free(&frame);

    avcodec_free_context(&mix_any_f);

    av_freep(&mix_any_f);

    FDBDesroy(&hcScale);

    return 0;

}",1,1,1,-1,size,-0.030300676822662354,9,64,"{'last': 'val_type', 'buffer': 'hcScale', 'end': 'bdrv_pwrite_sync', 'size': 'height', 'it': 'extent_path', 'data': 'trace_megasas_dcmd_internal_submit', 'ctx': 'mix_any_f', 'got_frame': 'progress_mutex', 'avpkt': 'vector_height'}",MHM-Origin,395,0.42938187917073567
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)

{

    uint32_t insn;



    insn = arm_ldl_code(env, s->pc, s->bswap_code);

    s->insn = insn;

    s->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(s);

        break;

    }



    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        s->is_jmp = DISAS_JUMP;

    }

}
",89,"void disas_a64_insn(CPUARMState *blk_insert_bs, DisasContext *bytes_sent)

{

    uint32_t CC_OP_MULL;



    CC_OP_MULL = arm_ldl_code(blk_insert_bs, bytes_sent->pc, bytes_sent->bswap_code);

    bytes_sent->CC_OP_MULL = CC_OP_MULL;

    bytes_sent->pc += 4;



    switch ((CC_OP_MULL >> 24) & 0x1f) {

    default:

        unallocated_encoding(bytes_sent);

        break;

    }



    if (unlikely(bytes_sent->singlestep_enabled) && (bytes_sent->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        bytes_sent->is_jmp = DISAS_JUMP;

    }

}
",0,0,0,-1,insn,-0.003395440522581339,3,16,"{'insn': 'CC_OP_MULL', 's': 'bytes_sent', 'env': 'blk_insert_bs'}",MHM-Origin,397,0.173246959845225
267,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(t0, t0);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(t0, cpu_regs[reg]);

        break;

    }

}
",87,"static inline void gen_op_mov_v_reg(int rv, TCGv QCowHeader, int O_RDWR)

{

    switch(rv) {

    case OT_BYTE:

        if (O_RDWR < 4 X86_64_DEF( || O_RDWR >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(QCowHeader, cpu_regs[O_RDWR - 4], 8);

            tcg_gen_ext8u_tl(QCowHeader, QCowHeader);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(QCowHeader, cpu_regs[O_RDWR]);

        break;

    }

}
",0,0,1,1,t0,0.44876527041196823,3,12,"{'ot': 'rv', 'reg': 'O_RDWR', 't0': 'QCowHeader'}",MHM-Origin,236,0.0978257417678833
268,"static int hdev_open(BlockDriverState *bs, const char *filename, int flags)

{

    BDRVRawState *s = bs->opaque;

    int access_flags, create_flags;

    DWORD overlapped;

    char device_name[64];



    if (strstart(filename, ""/dev/cdrom"", NULL)) {

        if (find_cdrom(device_name, sizeof(device_name)) < 0)

            return -ENOENT;

        filename = device_name;

    } else {

        /* transform drive letters into device name */

        if (((filename[0] >= 'a' && filename[0] <= 'z') ||

             (filename[0] >= 'A' && filename[0] <= 'Z')) &&

            filename[1] == ':' && filename[2] == '\0') {

            snprintf(device_name, sizeof(device_name), ""\\\\.\\%c:"", filename[0]);

            filename = device_name;

        }

    }

    s->type = find_device_type(bs, filename);

    

    if ((flags & BDRV_O_ACCESS) == O_RDWR) {

        access_flags = GENERIC_READ | GENERIC_WRITE;

    } else {

        access_flags = GENERIC_READ;

    }

    create_flags = OPEN_EXISTING;



#ifdef QEMU_TOOL

    overlapped = FILE_ATTRIBUTE_NORMAL;

#else

    overlapped = FILE_FLAG_OVERLAPPED;

#endif

    s->hfile = CreateFile(filename, access_flags, 

                          FILE_SHARE_READ, NULL,

                          create_flags, overlapped, NULL);

    if (s->hfile == INVALID_HANDLE_VALUE) 

        return -1;

    return 0;

}
",258,"static int hdev_open(BlockDriverState *pci_status, const char *tcg_gen_andi_tl, int MSR_MCG_CTL)

{

    BDRVRawState *srs = pci_status->opaque;

    int BLK_PERM_WRITE_UNCHANGED, AVERROR_PATCHWELCOME;

    DWORD qstring_get_str;

    char gen_io_start[64];



    if (strstart(tcg_gen_andi_tl, ""/dev/cdrom"", NULL)) {

        if (find_cdrom(gen_io_start, sizeof(gen_io_start)) < 0)

            return -ENOENT;

        tcg_gen_andi_tl = gen_io_start;

    } else {

        /* transform drive letters into device name */

        if (((tcg_gen_andi_tl[0] >= 'a' && tcg_gen_andi_tl[0] <= 'z') ||

             (tcg_gen_andi_tl[0] >= 'A' && tcg_gen_andi_tl[0] <= 'Z')) &&

            tcg_gen_andi_tl[1] == ':' && tcg_gen_andi_tl[2] == '\0') {

            snprintf(gen_io_start, sizeof(gen_io_start), ""\\\\.\\%c:"", tcg_gen_andi_tl[0]);

            tcg_gen_andi_tl = gen_io_start;

        }

    }

    srs->type = find_device_type(pci_status, tcg_gen_andi_tl);

    

    if ((MSR_MCG_CTL & BDRV_O_ACCESS) == O_RDWR) {

        BLK_PERM_WRITE_UNCHANGED = GENERIC_READ | GENERIC_WRITE;

    } else {

        BLK_PERM_WRITE_UNCHANGED = GENERIC_READ;

    }

    AVERROR_PATCHWELCOME = OPEN_EXISTING;



#ifdef QEMU_TOOL

    qstring_get_str = FILE_ATTRIBUTE_NORMAL;

#else

    qstring_get_str = FILE_FLAG_OVERLAPPED;

#endif

    srs->hfile = CreateFile(tcg_gen_andi_tl, BLK_PERM_WRITE_UNCHANGED, 

                          FILE_SHARE_READ, NULL,

                          AVERROR_PATCHWELCOME, qstring_get_str, NULL);

    if (srs->hfile == INVALID_HANDLE_VALUE) 

        return -1;

    return 0;

}
",0,0,1,1,create_flags,0.23234081268310547,8,40,"{'filename': 'tcg_gen_andi_tl', 'bs': 'pci_status', 's': 'srs', 'overlapped': 'qstring_get_str', 'flags': 'MSR_MCG_CTL', 'device_name': 'gen_io_start', 'access_flags': 'BLK_PERM_WRITE_UNCHANGED', 'create_flags': 'AVERROR_PATCHWELCOME'}",MHM-Origin,335,0.14485283692677817
269,"static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)

{

    S390CPU *cpu = S390_CPU(cs);

    SigpInfo *si = arg.host_ptr;



    if (!s390_has_feat(S390_FEAT_VECTOR)) {

        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);

        return;

    }



    /* cpu has to be stopped */

    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {

        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);

        return;

    }



    /* parameter must be aligned to 1024-byte boundary */

    if (si->param & 0x3ff) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }



    cpu_synchronize_state(cs);



    if (kvm_s390_store_adtl_status(cpu, si->param)) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }

    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
",121,"static void sigp_store_adtl_status(CPUState *stl_phys, run_on_cpu_data nested_url)

{

    S390CPU *TCGReg = S390_CPU(stl_phys);

    SigpInfo *cbits = nested_url.host_ptr;



    if (!s390_has_feat(S390_FEAT_VECTOR)) {

        set_sigp_status(cbits, SIGP_STAT_INVALID_ORDER);

        return;

    }



    /* cpu has to be stopped */

    if (s390_cpu_get_state(TCGReg) != CPU_STATE_STOPPED) {

        set_sigp_status(cbits, SIGP_STAT_INCORRECT_STATE);

        return;

    }



    /* parameter must be aligned to 1024-byte boundary */

    if (cbits->param & 0x3ff) {

        set_sigp_status(cbits, SIGP_STAT_INVALID_PARAMETER);

        return;

    }



    cpu_synchronize_state(stl_phys);



    if (kvm_s390_store_adtl_status(TCGReg, cbits->param)) {

        set_sigp_status(cbits, SIGP_STAT_INVALID_PARAMETER);

        return;

    }

    cbits->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
",0,0,0,-1,cs,0.001576907467097044,4,16,"{'si': 'cbits', 'cs': 'stl_phys', 'cpu': 'TCGReg', 'arg': 'nested_url'}",MHM-Origin,401,0.16504939397176108
270,"static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)

{

    target_ulong tmp;



    tmp = ldtul_p(mem_buf);



    if (n < 32) {

        env->active_tc.gpr[n] = tmp;

        return sizeof(target_ulong);

    }

    if (env->CP0_Config1 & (1 << CP0C1_FP)

            && n >= 38 && n < 73) {

        if (n < 70) {

            if (env->CP0_Status & (1 << CP0St_FR))

              env->active_fpu.fpr[n - 38].d = tmp;

            else

              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;

        }

        switch (n) {

        case 70:

            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;

            /* set rounding mode */

            RESTORE_ROUNDING_MODE;

#ifndef CONFIG_SOFTFLOAT

            /* no floating point exception for native float */

            SET_FP_ENABLE(env->active_fpu.fcr31, 0);

#endif

            break;

        case 71: env->active_fpu.fcr0 = tmp; break;

        }

        return sizeof(target_ulong);

    }

    switch (n) {

    case 32: env->CP0_Status = tmp; break;

    case 33: env->active_tc.LO[0] = tmp; break;

    case 34: env->active_tc.HI[0] = tmp; break;

    case 35: env->CP0_BadVAddr = tmp; break;

    case 36: env->CP0_Cause = tmp; break;

    case 37: env->active_tc.PC = tmp; break;

    case 72: /* fp, ignored */ break;

    default: 

	if (n > 89)

	    return 0;

	/* Other registers are readonly.  Ignore writes.  */

	break;

    }



    return sizeof(target_ulong);

}
",292,"static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)

{

    target_ulong AV_OPT_FLAG_ENCODING_PARAM;



    AV_OPT_FLAG_ENCODING_PARAM = ldtul_p(mem_buf);



    if (n < 32) {

        env->active_tc.gpr[n] = AV_OPT_FLAG_ENCODING_PARAM;

        return sizeof(target_ulong);

    }

    if (env->CP0_Config1 & (1 << CP0C1_FP)

            && n >= 38 && n < 73) {

        if (n < 70) {

            if (env->CP0_Status & (1 << CP0St_FR))

              env->active_fpu.fpr[n - 38].d = AV_OPT_FLAG_ENCODING_PARAM;

            else

              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = AV_OPT_FLAG_ENCODING_PARAM;

        }

        switch (n) {

        case 70:

            env->active_fpu.fcr31 = AV_OPT_FLAG_ENCODING_PARAM & 0xFF83FFFF;

            /* set rounding mode */

            RESTORE_ROUNDING_MODE;

#ifndef CONFIG_SOFTFLOAT

            /* no floating point exception for native float */

            SET_FP_ENABLE(env->active_fpu.fcr31, 0);

#endif

            break;

        case 71: env->active_fpu.fcr0 = AV_OPT_FLAG_ENCODING_PARAM; break;

        }

        return sizeof(target_ulong);

    }

    switch (n) {

    case 32: env->CP0_Status = AV_OPT_FLAG_ENCODING_PARAM; break;

    case 33: env->active_tc.LO[0] = AV_OPT_FLAG_ENCODING_PARAM; break;

    case 34: env->active_tc.HI[0] = AV_OPT_FLAG_ENCODING_PARAM; break;

    case 35: env->CP0_BadVAddr = AV_OPT_FLAG_ENCODING_PARAM; break;

    case 36: env->CP0_Cause = AV_OPT_FLAG_ENCODING_PARAM; break;

    case 37: env->active_tc.PC = AV_OPT_FLAG_ENCODING_PARAM; break;

    case 72: /* fp, ignored */ break;

    default: 

	if (n > 89)

	    return 0;

	/* Other registers are readonly.  Ignore writes.  */

	break;

    }



    return sizeof(target_ulong);

}
",0,0,1,1,tmp,0.7748052179813385,1,13,{'tmp': 'AV_OPT_FLAG_ENCODING_PARAM'},MHM-Origin,21,0.008740309874216716
271,"QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)

{

    QEMUBH *bh;

    bh = g_malloc0(sizeof(QEMUBH));

    bh->ctx = ctx;

    bh->cb = cb;

    bh->opaque = opaque;

    qemu_mutex_lock(&ctx->bh_lock);

    bh->next = ctx->first_bh;

    /* Make sure that the members are ready before putting bh into list */

    smp_wmb();

    ctx->first_bh = bh;

    qemu_mutex_unlock(&ctx->bh_lock);

    return bh;

}
",87,"QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *HEVC_NAL_RADL_R, void *opaque)

{

    QEMUBH *bh;

    bh = g_malloc0(sizeof(QEMUBH));

    bh->ctx = ctx;

    bh->HEVC_NAL_RADL_R = HEVC_NAL_RADL_R;

    bh->opaque = opaque;

    qemu_mutex_lock(&ctx->bh_lock);

    bh->next = ctx->first_bh;

    /* Make sure that the members are ready before putting bh into list */

    smp_wmb();

    ctx->first_bh = bh;

    qemu_mutex_unlock(&ctx->bh_lock);

    return bh;

}
",0,0,1,1,cb,0.45769043266773224,1,3,{'cb': 'HEVC_NAL_RADL_R'},MHM-Origin,39,0.01584734916687012
272,"static void audiogen(void *data, enum AVSampleFormat sample_fmt,

                     int channels, int sample_rate, int nb_samples)

{

    int i, ch, k;

    double v, f, a, ampa;

    double tabf1[SWR_CH_MAX];

    double tabf2[SWR_CH_MAX];

    double taba[SWR_CH_MAX];

    unsigned static rnd;



#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);

#define uint_rand(x) (x = x * 1664525 + 1013904223)

#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)

    k = 0;



    /* 1 second of single freq sinus at 1000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        a += M_PI * 1000.0 * 2.0 / sample_rate;

    }



    /* 1 second of varying frequency between 100 and 10000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        f  = 100.0 + (((10000.0 - 100.0) * i) / sample_rate);

        a += M_PI * f * 2.0 / sample_rate;

    }



    /* 0.5 second of low amplitude white noise */

    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {

        v = dbl_rand(rnd) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

    }



    /* 0.5 second of high amplitude white noise */

    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {

        v = dbl_rand(rnd);

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

    }



    /* 1 second of unrelated ramps for each channel */

    for (ch = 0; ch < channels; ch++) {

        taba[ch]  = 0;

        tabf1[ch] = 100 + uint_rand(rnd) % 5000;

        tabf2[ch] = 100 + uint_rand(rnd) % 5000;

    }

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        for (ch = 0; ch < channels; ch++) {

            v = sin(taba[ch]) * 0.30;

            PUT_SAMPLE

            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);

            taba[ch] += M_PI * f * 2.0 / sample_rate;

        }

    }



    /* 2 seconds of 500 Hz with varying volume */

    a    = 0;

    ampa = 0;

    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {

        for (ch = 0; ch < channels; ch++) {

            double amp = (1.0 + sin(ampa)) * 0.15;

            if (ch & 1)

                amp = 0.30 - amp;

            v = sin(a) * amp;

            PUT_SAMPLE

            a    += M_PI * 500.0 * 2.0 / sample_rate;

            ampa += M_PI *  2.0 / sample_rate;

        }

    }

}
",557,"static void audiogen(void *data, enum AVSampleFormat sample_fmt,

                     int channels, int sample_rate, int nb_samples)

{

    int bdrv_set_backing_hd, ch, k;

    double v, f, a, ampa;

    double tabf1[SWR_CH_MAX];

    double tabf2[SWR_CH_MAX];

    double taba[SWR_CH_MAX];

    unsigned static rnd;



#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);

#define uint_rand(x) (x = x * 1664525 + 1013904223)

#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)

    k = 0;



    /* 1 second of single freq sinus at 1000 Hz */

    a = 0;

    for (bdrv_set_backing_hd = 0; bdrv_set_backing_hd < 1 * sample_rate && k < nb_samples; bdrv_set_backing_hd++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        a += M_PI * 1000.0 * 2.0 / sample_rate;

    }



    /* 1 second of varying frequency between 100 and 10000 Hz */

    a = 0;

    for (bdrv_set_backing_hd = 0; bdrv_set_backing_hd < 1 * sample_rate && k < nb_samples; bdrv_set_backing_hd++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        f  = 100.0 + (((10000.0 - 100.0) * bdrv_set_backing_hd) / sample_rate);

        a += M_PI * f * 2.0 / sample_rate;

    }



    /* 0.5 second of low amplitude white noise */

    for (bdrv_set_backing_hd = 0; bdrv_set_backing_hd < sample_rate / 2 && k < nb_samples; bdrv_set_backing_hd++, k++) {

        v = dbl_rand(rnd) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

    }



    /* 0.5 second of high amplitude white noise */

    for (bdrv_set_backing_hd = 0; bdrv_set_backing_hd < sample_rate / 2 && k < nb_samples; bdrv_set_backing_hd++, k++) {

        v = dbl_rand(rnd);

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

    }



    /* 1 second of unrelated ramps for each channel */

    for (ch = 0; ch < channels; ch++) {

        taba[ch]  = 0;

        tabf1[ch] = 100 + uint_rand(rnd) % 5000;

        tabf2[ch] = 100 + uint_rand(rnd) % 5000;

    }

    for (bdrv_set_backing_hd = 0; bdrv_set_backing_hd < 1 * sample_rate && k < nb_samples; bdrv_set_backing_hd++, k++) {

        for (ch = 0; ch < channels; ch++) {

            v = sin(taba[ch]) * 0.30;

            PUT_SAMPLE

            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * bdrv_set_backing_hd) / sample_rate);

            taba[ch] += M_PI * f * 2.0 / sample_rate;

        }

    }



    /* 2 seconds of 500 Hz with varying volume */

    a    = 0;

    ampa = 0;

    for (bdrv_set_backing_hd = 0; bdrv_set_backing_hd < 2 * sample_rate && k < nb_samples; bdrv_set_backing_hd++, k++) {

        for (ch = 0; ch < channels; ch++) {

            double amp = (1.0 + sin(ampa)) * 0.15;

            if (ch & 1)

                amp = 0.30 - amp;

            v = sin(a) * amp;

            PUT_SAMPLE

            a    += M_PI * 500.0 * 2.0 / sample_rate;

            ampa += M_PI *  2.0 / sample_rate;

        }

    }

}
",0,0,1,1,i,0.08141538500785828,1,21,{'i': 'bdrv_set_backing_hd'},MHM-Origin,21,0.00941166083017985
275,"void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->peer);



    /* remove from list, if necessary */

    if (bs->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, bs, list);

    }



    bdrv_close(bs);

    if (bs->file != NULL) {

        bdrv_delete(bs->file);

    }



    assert(bs != bs_snapshots);

    qemu_free(bs);

}
",76,"void bdrv_delete(BlockDriverState *vq)

{

    assert(!vq->peer);



    /* remove from list, if necessary */

    if (vq->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, vq, list);

    }



    bdrv_close(vq);

    if (vq->file != NULL) {

        bdrv_delete(vq->file);

    }



    assert(vq != bs_snapshots);

    qemu_free(vq);

}
",1,1,0,1,bs,-0.4227465093135834,1,9,{'bs': 'vq'},MHM-Origin,22,0.008005928993225098
277,"int kvm_arch_on_sigbus(int code, void *addr)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t ram_addr;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = addr;

        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p\n"", addr);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (code == BUS_MCEERR_AO) {

            return 0;

        } else if (code == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
",132,"int kvm_arch_on_sigbus(int NEW_STREAM, void *lexer)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && lexer && NEW_STREAM == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t ram_addr;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = lexer;

        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p
"", lexer);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (NEW_STREAM == BUS_MCEERR_AO) {

            return 0;

        } else if (NEW_STREAM == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
",0,0,1,1,addr,0.21032938361167908,2,8,"{'code': 'NEW_STREAM', 'addr': 'lexer'}",MHM-Origin,40,0.016266600290934245
280,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    return l;

}
",29,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *do_interrupt;



    init_types();



    do_interrupt = &init_type_list[type];



    return do_interrupt;

}
",0,0,1,1,l,0.3849029242992401,1,3,{'l': 'do_interrupt'},MHM-Origin,23,0.0077899535497029625
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
",40,"void ff_put_h264_qpel8_mc21_msa(uint8_t *RV34_MB_P_16x16, const uint8_t *cq,

                                ptrdiff_t y8)

{

    avc_luma_midv_qrt_8w_msa(cq - (2 * y8) - 2, y8, RV34_MB_P_16x16, y8, 8, 0);

}
",0,0,0,-1,dst,8.784933015704155e-05,3,8,"{'dst': 'RV34_MB_P_16x16', 'src': 'cq', 'stride': 'y8'}",MHM-Origin,398,0.16399502754211426
284,"static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
",91,"static void serial_tx_done(void *opaque)

{

    SerialState *filter = opaque;



    if (filter->tx_burst < 0) {

        uint16_t divider;



        if (filter->divider)

          divider = filter->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        filter->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (filter->baudbase / divider));

    }

    filter->thr_ipending = 1;

    filter->lsr |= UART_LSR_THRE;

    filter->lsr |= UART_LSR_TEMT;

    serial_update_irq(filter);

}
",1,1,0,1,s,-0.23111623525619507,1,10,{'s': 'filter'},MHM-Origin,18,0.00790764093399048
286,"static void init_proc_750fx (CPUPPCState *env)

{

    gen_spr_ne_601(env);

    gen_spr_7xx(env);

    /* XXX : not implemented */

    spr_register(env, SPR_L2CR, ""L2CR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, NULL,

                 0x00000000);

    /* Time base */

    gen_tbl(env);

    /* Thermal management */

    gen_spr_thrm(env);

    /* XXX : not implemented */

    spr_register(env, SPR_750_THRM4, ""THRM4"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(env, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_750FX_HID2, ""HID2"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Memory management */

    gen_low_BATs(env);

    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */

    gen_high_BATs(env);

    init_excp_7x0(env);

    env->dcache_line_size = 32;

    env->icache_line_size = 32;

    /* Allocate hardware IRQ controller */

    ppc6xx_irq_init(env);

}
",176,"static void init_proc_750fx (CPUPPCState *error)

{

    gen_spr_ne_601(error);

    gen_spr_7xx(error);

    /* XXX : not implemented */

    spr_register(error, SPR_L2CR, ""L2CR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, NULL,

                 0x00000000);

    /* Time base */

    gen_tbl(error);

    /* Thermal management */

    gen_spr_thrm(error);

    /* XXX : not implemented */

    spr_register(error, SPR_750_THRM4, ""THRM4"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(error, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(error, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(error, SPR_750FX_HID2, ""HID2"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Memory management */

    gen_low_BATs(error);

    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */

    gen_high_BATs(error);

    init_excp_7x0(error);

    error->dcache_line_size = 32;

    error->icache_line_size = 32;

    /* Allocate hardware IRQ controller */

    ppc6xx_irq_init(error);

}
",1,1,0,1,env,-0.2849274277687073,1,16,{'env': 'error'},MHM-Origin,21,0.008561134338378906
290,"av_cold void ff_sws_init_swScale_mmx(SwsContext *c)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_INLINE_ASM

    if (cpu_flags & AV_CPU_FLAG_MMX)

        sws_init_swScale_MMX(c);

#if HAVE_MMXEXT_INLINE

    if (cpu_flags & AV_CPU_FLAG_MMXEXT)

        sws_init_swScale_MMX2(c);

#endif

#endif /* HAVE_INLINE_ASM */



#if HAVE_YASM

#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (c->srcBpc == 8) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 9) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 10) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \

    } else /* c->srcBpc == 16 */ { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \

    } \

} while (0)

#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \

    }

#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \

switch(c->dstBpc){ \

    case 16:                          do_16_case;                          break; \

    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \

    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \

    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \

    }

#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \

    switch(c->dstBpc){ \

    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \

    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \

    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \

    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \

    }

#define case_rgb(x, X, opt) \

        case PIX_FMT_ ## X: \

            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \

            if (!c->chrSrcHSubSample) \

                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \

            break

#if ARCH_X86_32

    if (cpu_flags & AV_CPU_FLAG_MMX) {

        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);

        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);



        switch (c->srcFormat) {

        case PIX_FMT_Y400A:

            c->lumToYV12 = ff_yuyvToY_mmx;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_mmx;

            break;

        case PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_mmx;

            c->chrToYV12 = ff_yuyvToUV_mmx;

            break;

        case PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_mmx;

            c->chrToYV12 = ff_uyvyToUV_mmx;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_mmx;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_mmx;

            break;

        case_rgb(rgb24, RGB24, mmx);

        case_rgb(bgr24, BGR24, mmx);

        case_rgb(bgra,  BGRA,  mmx);

        case_rgb(rgba,  RGBA,  mmx);

        case_rgb(abgr,  ABGR,  mmx);

        case_rgb(argb,  ARGB,  mmx);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);

    }

#endif /* ARCH_X86_32 */

#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \

             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \

             break; \

    }

    if (cpu_flags & AV_CPU_FLAG_SSE2) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);



        switch (c->srcFormat) {

        case PIX_FMT_Y400A:

            c->lumToYV12 = ff_yuyvToY_sse2;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_sse2;

            break;

        case PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_sse2;

            c->chrToYV12 = ff_yuyvToUV_sse2;

            break;

        case PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_sse2;

            c->chrToYV12 = ff_uyvyToUV_sse2;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_sse2;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_sse2;

            break;

        case_rgb(rgb24, RGB24, sse2);

        case_rgb(bgr24, BGR24, sse2);

        case_rgb(bgra,  BGRA,  sse2);

        case_rgb(rgba,  RGBA,  sse2);

        case_rgb(abgr,  ABGR,  sse2);

        case_rgb(argb,  ARGB,  sse2);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSSE3) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);

        switch (c->srcFormat) {

        case_rgb(rgb24, RGB24, ssse3);

        case_rgb(bgr24, BGR24, ssse3);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSE4) {

        /* Xto15 don't need special sse4 functions */

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,

                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        if (c->dstBpc == 16 && !isBE(c->dstFormat))

            c->yuv2plane1 = ff_yuv2plane1_16_sse4;

    }



    if (cpu_flags & AV_CPU_FLAG_AVX) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);



        switch (c->srcFormat) {

        case PIX_FMT_YUYV422:

            c->chrToYV12 = ff_yuyvToUV_avx;

            break;

        case PIX_FMT_UYVY422:

            c->chrToYV12 = ff_uyvyToUV_avx;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_avx;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_avx;

            break;

        case_rgb(rgb24, RGB24, avx);

        case_rgb(bgr24, BGR24, avx);

        case_rgb(bgra,  BGRA,  avx);

        case_rgb(rgba,  RGBA,  avx);

        case_rgb(abgr,  ABGR,  avx);

        case_rgb(argb,  ARGB,  avx);

        default:

            break;

        }

    }

#endif

}
",855,"av_cold void ff_sws_init_swScale_mmx(SwsContext *HEVC_NAL_TRAIL_R)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_INLINE_ASM

    if (cpu_flags & AV_CPU_FLAG_MMX)

        sws_init_swScale_MMX(HEVC_NAL_TRAIL_R);

#if HAVE_MMXEXT_INLINE

    if (cpu_flags & AV_CPU_FLAG_MMXEXT)

        sws_init_swScale_MMX2(HEVC_NAL_TRAIL_R);

#endif

#endif /* HAVE_INLINE_ASM */



#if HAVE_YASM

#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (HEVC_NAL_TRAIL_R->srcBpc == 8) { \

        hscalefn = HEVC_NAL_TRAIL_R->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (HEVC_NAL_TRAIL_R->srcBpc == 9) { \

        hscalefn = HEVC_NAL_TRAIL_R->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (HEVC_NAL_TRAIL_R->srcBpc == 10) { \

        hscalefn = HEVC_NAL_TRAIL_R->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \

    } else /* c->srcBpc == 16 */ { \

        hscalefn = HEVC_NAL_TRAIL_R->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \

    } \

} while (0)

#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \

    }

#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \

switch(c->dstBpc){ \

    case 16:                          do_16_case;                          break; \

    case 10: if (!isBE(HEVC_NAL_TRAIL_R->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \

    case 9:  if (!isBE(HEVC_NAL_TRAIL_R->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \

    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \

    }

#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \

    switch(c->dstBpc){ \

    case 16: if (!isBE(HEVC_NAL_TRAIL_R->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \

    case 10: if (!isBE(HEVC_NAL_TRAIL_R->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \

    case 9:  if (!isBE(HEVC_NAL_TRAIL_R->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \

    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \

    }

#define case_rgb(x, X, opt) \

        case PIX_FMT_ ## X: \

            HEVC_NAL_TRAIL_R->lumToYV12 = ff_ ## x ## ToY_ ## opt; \

            if (!HEVC_NAL_TRAIL_R->chrSrcHSubSample) \

                HEVC_NAL_TRAIL_R->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \

            break

#if ARCH_X86_32

    if (cpu_flags & AV_CPU_FLAG_MMX) {

        ASSIGN_MMX_SCALE_FUNC(HEVC_NAL_TRAIL_R->hyScale, HEVC_NAL_TRAIL_R->hLumFilterSize, mmx, mmx);

        ASSIGN_MMX_SCALE_FUNC(HEVC_NAL_TRAIL_R->hcScale, HEVC_NAL_TRAIL_R->hChrFilterSize, mmx, mmx);

        ASSIGN_VSCALE_FUNC(HEVC_NAL_TRAIL_R->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);



        switch (HEVC_NAL_TRAIL_R->srcFormat) {

        case PIX_FMT_Y400A:

            HEVC_NAL_TRAIL_R->lumToYV12 = ff_yuyvToY_mmx;

            if (HEVC_NAL_TRAIL_R->alpPixBuf)

                HEVC_NAL_TRAIL_R->alpToYV12 = ff_uyvyToY_mmx;

            break;

        case PIX_FMT_YUYV422:

            HEVC_NAL_TRAIL_R->lumToYV12 = ff_yuyvToY_mmx;

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_yuyvToUV_mmx;

            break;

        case PIX_FMT_UYVY422:

            HEVC_NAL_TRAIL_R->lumToYV12 = ff_uyvyToY_mmx;

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_uyvyToUV_mmx;

            break;

        case PIX_FMT_NV12:

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_nv12ToUV_mmx;

            break;

        case PIX_FMT_NV21:

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_nv21ToUV_mmx;

            break;

        case_rgb(rgb24, RGB24, mmx);

        case_rgb(bgr24, BGR24, mmx);

        case_rgb(bgra,  BGRA,  mmx);

        case_rgb(rgba,  RGBA,  mmx);

        case_rgb(abgr,  ABGR,  mmx);

        case_rgb(argb,  ARGB,  mmx);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {

        ASSIGN_VSCALEX_FUNC(HEVC_NAL_TRAIL_R->yuv2planeX, mmx2, , 1);

    }

#endif /* ARCH_X86_32 */

#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \

             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \

             break; \

    }

    if (cpu_flags & AV_CPU_FLAG_SSE2) {

        ASSIGN_SSE_SCALE_FUNC(HEVC_NAL_TRAIL_R->hyScale, HEVC_NAL_TRAIL_R->hLumFilterSize, sse2, sse2);

        ASSIGN_SSE_SCALE_FUNC(HEVC_NAL_TRAIL_R->hcScale, HEVC_NAL_TRAIL_R->hChrFilterSize, sse2, sse2);

        ASSIGN_VSCALEX_FUNC(HEVC_NAL_TRAIL_R->yuv2planeX, sse2, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(HEVC_NAL_TRAIL_R->yuv2plane1, sse2, sse2, 1);



        switch (HEVC_NAL_TRAIL_R->srcFormat) {

        case PIX_FMT_Y400A:

            HEVC_NAL_TRAIL_R->lumToYV12 = ff_yuyvToY_sse2;

            if (HEVC_NAL_TRAIL_R->alpPixBuf)

                HEVC_NAL_TRAIL_R->alpToYV12 = ff_uyvyToY_sse2;

            break;

        case PIX_FMT_YUYV422:

            HEVC_NAL_TRAIL_R->lumToYV12 = ff_yuyvToY_sse2;

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_yuyvToUV_sse2;

            break;

        case PIX_FMT_UYVY422:

            HEVC_NAL_TRAIL_R->lumToYV12 = ff_uyvyToY_sse2;

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_uyvyToUV_sse2;

            break;

        case PIX_FMT_NV12:

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_nv12ToUV_sse2;

            break;

        case PIX_FMT_NV21:

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_nv21ToUV_sse2;

            break;

        case_rgb(rgb24, RGB24, sse2);

        case_rgb(bgr24, BGR24, sse2);

        case_rgb(bgra,  BGRA,  sse2);

        case_rgb(rgba,  RGBA,  sse2);

        case_rgb(abgr,  ABGR,  sse2);

        case_rgb(argb,  ARGB,  sse2);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSSE3) {

        ASSIGN_SSE_SCALE_FUNC(HEVC_NAL_TRAIL_R->hyScale, HEVC_NAL_TRAIL_R->hLumFilterSize, ssse3, ssse3);

        ASSIGN_SSE_SCALE_FUNC(HEVC_NAL_TRAIL_R->hcScale, HEVC_NAL_TRAIL_R->hChrFilterSize, ssse3, ssse3);

        switch (HEVC_NAL_TRAIL_R->srcFormat) {

        case_rgb(rgb24, RGB24, ssse3);

        case_rgb(bgr24, BGR24, ssse3);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSE4) {

        /* Xto15 don't need special sse4 functions */

        ASSIGN_SSE_SCALE_FUNC(HEVC_NAL_TRAIL_R->hyScale, HEVC_NAL_TRAIL_R->hLumFilterSize, sse4, ssse3);

        ASSIGN_SSE_SCALE_FUNC(HEVC_NAL_TRAIL_R->hcScale, HEVC_NAL_TRAIL_R->hChrFilterSize, sse4, ssse3);

        ASSIGN_VSCALEX_FUNC(HEVC_NAL_TRAIL_R->yuv2planeX, sse4,

                            if (!isBE(HEVC_NAL_TRAIL_R->dstFormat)) HEVC_NAL_TRAIL_R->yuv2planeX = ff_yuv2planeX_16_sse4,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        if (HEVC_NAL_TRAIL_R->dstBpc == 16 && !isBE(HEVC_NAL_TRAIL_R->dstFormat))

            HEVC_NAL_TRAIL_R->yuv2plane1 = ff_yuv2plane1_16_sse4;

    }



    if (cpu_flags & AV_CPU_FLAG_AVX) {

        ASSIGN_VSCALEX_FUNC(HEVC_NAL_TRAIL_R->yuv2planeX, avx, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(HEVC_NAL_TRAIL_R->yuv2plane1, avx, avx, 1);



        switch (HEVC_NAL_TRAIL_R->srcFormat) {

        case PIX_FMT_YUYV422:

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_yuyvToUV_avx;

            break;

        case PIX_FMT_UYVY422:

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_uyvyToUV_avx;

            break;

        case PIX_FMT_NV12:

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_nv12ToUV_avx;

            break;

        case PIX_FMT_NV21:

            HEVC_NAL_TRAIL_R->chrToYV12 = ff_nv21ToUV_avx;

            break;

        case_rgb(rgb24, RGB24, avx);

        case_rgb(bgr24, BGR24, avx);

        case_rgb(bgra,  BGRA,  avx);

        case_rgb(rgba,  RGBA,  avx);

        case_rgb(abgr,  ABGR,  avx);

        case_rgb(argb,  ARGB,  avx);

        default:

            break;

        }

    }

#endif

}
",0,0,1,1,c,0.5459078699350357,1,57,{'c': 'HEVC_NAL_TRAIL_R'},MHM-Origin,24,0.012650060653686523
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
",27,"uint32_t div32(uint32_t *audio_stream_num, uint64_t num, uint32_t den)

{

    *audio_stream_num = num / den;

    return num % den;

}
",1,1,0,1,q_ptr,-0.6327145397663116,1,2,{'q_ptr': 'audio_stream_num'},MHM-Origin,24,0.007989056905110677
295,"void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)

{

    int i;



    s->dts    =

    s->pts    = AV_NOPTS_VALUE;

    s->pos    = -1;

    s->offset = 0;

    for (i = 0; i < AV_PARSER_PTS_NB; i++) {

        if (s->cur_offset + off >= s->cur_frame_offset[i] &&

            (s->frame_offset < s->cur_frame_offset[i] ||

             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame

            // check disabled since MPEG-TS does not send complete PES packets

            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){



            s->dts    = s->cur_frame_dts[i];

            s->pts    = s->cur_frame_pts[i];

            s->pos    = s->cur_frame_pos[i];

            s->offset = s->next_frame_offset - s->cur_frame_offset[i];

            if (remove)

                s->cur_frame_offset[i] = INT64_MAX;

            if (s->cur_offset + off < s->cur_frame_end[i])

                break;

        }

    }

}
",182,"void ff_fetch_timestamp(AVCodecParserContext *s, int vm86, int remove)

{

    int i;



    s->dts    =

    s->pts    = AV_NOPTS_VALUE;

    s->pos    = -1;

    s->offset = 0;

    for (i = 0; i < AV_PARSER_PTS_NB; i++) {

        if (s->cur_offset + vm86 >= s->cur_frame_offset[i] &&

            (s->frame_offset < s->cur_frame_offset[i] ||

             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame

            // check disabled since MPEG-TS does not send complete PES packets

            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){



            s->dts    = s->cur_frame_dts[i];

            s->pts    = s->cur_frame_pts[i];

            s->pos    = s->cur_frame_pos[i];

            s->offset = s->next_frame_offset - s->cur_frame_offset[i];

            if (remove)

                s->cur_frame_offset[i] = INT64_MAX;

            if (s->cur_offset + vm86 < s->cur_frame_end[i])

                break;

        }

    }

}
",1,1,0,1,off,-0.07844635844230652,1,3,{'off': 'vm86'},MHM-Origin,20,0.008401286602020264
296,"static void simple_whitespace(void)

{

    int i;

    struct {

        const char *encoded;

        LiteralQObject decoded;

    } test_cases[] = {

        {

            .encoded = "" [ 43 , 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { ""a"", QLIT_QINT(32) },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        { }

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_json(test_cases[i].encoded, NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);



        str = qobject_to_json(obj);

        qobject_decref(obj);



        obj = qobject_from_json(qstring_get_str(str), NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);



        qobject_decref(obj);

        QDECREF(str);

    }

}
",352,"static void simple_whitespace(void)

{

    int max_cpus;

    struct {

        const char *encoded;

        LiteralQObject decoded;

    } test_cases[] = {

        {

            .encoded = "" [ 43 , 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { ""a"", QLIT_QINT(32) },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        { }

    };



    for (max_cpus = 0; test_cases[max_cpus].encoded; max_cpus++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_json(test_cases[max_cpus].encoded, NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[max_cpus].decoded, obj) == 1);



        str = qobject_to_json(obj);

        qobject_decref(obj);



        obj = qobject_from_json(qstring_get_str(str), NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[max_cpus].decoded, obj) == 1);



        qobject_decref(obj);

        QDECREF(str);

    }

}
",1,1,0,1,i,-0.3185993432998657,1,7,{'i': 'max_cpus'},MHM-Origin,21,0.009008491039276123
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",173,"static void gen_check_sr(DisasContext *dc, uint32_t numSubbands, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[numSubbands].opt_bits)) {

        if (sregnames[numSubbands].name) {

            qemu_log(""SR %s is not configured
"", sregnames[numSubbands].name);

        } else {

            qemu_log(""SR %d is not implemented
"", numSubbands);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[numSubbands].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s
"", sregnames[numSubbands].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",1,1,0,1,sr,-0.28344616293907166,1,7,{'sr': 'numSubbands'},MHM-Origin,21,0.008296485741933186
299,"static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,

                        float **out_samples)

{

    ATRAC3Context *q = avctx->priv_data;

    int ret, i;

    uint8_t *ptr1;



    if (q->coding_mode == JOINT_STEREO) {

        /* channel coupling mode */

        /* decode Sound Unit 1 */

        init_get_bits(&q->gb, databuf, avctx->block_align * 8);



        ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,

                                        JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Framedata of the su2 in the joint-stereo mode is encoded in

         * reverse byte order so we need to swap it first. */

        if (databuf == q->decoded_bytes_buffer) {

            uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1;

            ptr1          = q->decoded_bytes_buffer;

            for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--)

                FFSWAP(uint8_t, *ptr1, *ptr2);

        } else {

            const uint8_t *ptr2 = databuf + avctx->block_align - 1;

            for (i = 0; i < avctx->block_align; i++)

                q->decoded_bytes_buffer[i] = *ptr2--;

        }



        /* Skip the sync codes (0xF8). */

        ptr1 = q->decoded_bytes_buffer;

        for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {

            if (i >= avctx->block_align)

                return AVERROR_INVALIDDATA;

        }





        /* set the bitstream reader at the start of the second Sound Unit*/

        init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + avctx->block_align - ptr1);



        /* Fill the Weighting coeffs delay buffer */

        memmove(q->weighting_delay, &q->weighting_delay[2],

                4 * sizeof(*q->weighting_delay));

        q->weighting_delay[4] = get_bits1(&q->gb);

        q->weighting_delay[5] = get_bits(&q->gb, 3);



        for (i = 0; i < 4; i++) {

            q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i];

            q->matrix_coeff_index_now[i]  = q->matrix_coeff_index_next[i];

            q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2);

        }



        /* Decode Sound Unit 2. */

        ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],

                                        out_samples[1], 1, JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Reconstruct the channel coefficients. */

        reverse_matrixing(out_samples[0], out_samples[1],

                          q->matrix_coeff_index_prev,

                          q->matrix_coeff_index_now);



        channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);

    } else {

        /* single channels */

        /* Decode the channel sound units. */

        for (i = 0; i < avctx->channels; i++) {

            /* Set the bitstream reader at the start of a channel sound unit. */

            init_get_bits(&q->gb,

                          databuf + i * avctx->block_align / avctx->channels,

                          avctx->block_align * 8 / avctx->channels);



            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],

                                            out_samples[i], i, q->coding_mode);

            if (ret != 0)

                return ret;

        }

    }



    /* Apply the iQMF synthesis filter. */

    for (i = 0; i < avctx->channels; i++) {

        float *p1 = out_samples[i];

        float *p2 = p1 + 256;

        float *p3 = p2 + 256;

        float *p4 = p3 + 256;

        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);

        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);

        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);

    }



    return 0;

}
",667,"static int decode_frame(AVCodecContext *imms, const uint8_t *databuf,

                        float **out_samples)

{

    ATRAC3Context *q = imms->priv_data;

    int ret, i;

    uint8_t *ptr1;



    if (q->coding_mode == JOINT_STEREO) {

        /* channel coupling mode */

        /* decode Sound Unit 1 */

        init_get_bits(&q->gb, databuf, imms->block_align * 8);



        ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,

                                        JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Framedata of the su2 in the joint-stereo mode is encoded in

         * reverse byte order so we need to swap it first. */

        if (databuf == q->decoded_bytes_buffer) {

            uint8_t *ptr2 = q->decoded_bytes_buffer + imms->block_align - 1;

            ptr1          = q->decoded_bytes_buffer;

            for (i = 0; i < imms->block_align / 2; i++, ptr1++, ptr2--)

                FFSWAP(uint8_t, *ptr1, *ptr2);

        } else {

            const uint8_t *ptr2 = databuf + imms->block_align - 1;

            for (i = 0; i < imms->block_align; i++)

                q->decoded_bytes_buffer[i] = *ptr2--;

        }



        /* Skip the sync codes (0xF8). */

        ptr1 = q->decoded_bytes_buffer;

        for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {

            if (i >= imms->block_align)

                return AVERROR_INVALIDDATA;

        }





        /* set the bitstream reader at the start of the second Sound Unit*/

        init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + imms->block_align - ptr1);



        /* Fill the Weighting coeffs delay buffer */

        memmove(q->weighting_delay, &q->weighting_delay[2],

                4 * sizeof(*q->weighting_delay));

        q->weighting_delay[4] = get_bits1(&q->gb);

        q->weighting_delay[5] = get_bits(&q->gb, 3);



        for (i = 0; i < 4; i++) {

            q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i];

            q->matrix_coeff_index_now[i]  = q->matrix_coeff_index_next[i];

            q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2);

        }



        /* Decode Sound Unit 2. */

        ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],

                                        out_samples[1], 1, JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Reconstruct the channel coefficients. */

        reverse_matrixing(out_samples[0], out_samples[1],

                          q->matrix_coeff_index_prev,

                          q->matrix_coeff_index_now);



        channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);

    } else {

        /* single channels */

        /* Decode the channel sound units. */

        for (i = 0; i < imms->channels; i++) {

            /* Set the bitstream reader at the start of a channel sound unit. */

            init_get_bits(&q->gb,

                          databuf + i * imms->block_align / imms->channels,

                          imms->block_align * 8 / imms->channels);



            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],

                                            out_samples[i], i, q->coding_mode);

            if (ret != 0)

                return ret;

        }

    }



    /* Apply the iQMF synthesis filter. */

    for (i = 0; i < imms->channels; i++) {

        float *p1 = out_samples[i];

        float *p2 = p1 + 256;

        float *p3 = p2 + 256;

        float *p4 = p3 + 256;

        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);

        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);

        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);

    }



    return 0;

}
",0,0,1,1,avctx,0.02641350030899048,1,15,{'avctx': 'imms'},MHM-Origin,22,0.010020101070404052
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
",92,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t backing;

    uint32_t sub_packet_list_D;



    shift &= 63;

    backing = (uint64_t)val << 32 >> shift;

    sub_packet_list_D = backing >> 32;



    env->cc_c = (backing >> 31) & 1;

    env->cc_n = sub_packet_list_D;

    env->cc_z = sub_packet_list_D;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return sub_packet_list_D;

}
",1,1,0,1,result,-0.6446668207645416,2,9,"{'temp': 'backing', 'result': 'sub_packet_list_D'}",MHM-Origin,61,0.024213345845540364
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
",227,"static int decode_cabac_mb_cbp_luma( H264Context *vnc_display_listen_addr) {

    int cbp_b, init_vlc, link_status_changed, cbp = 0;



    init_vlc = vnc_display_listen_addr->slice_table[vnc_display_listen_addr->left_mb_xy[0]] == vnc_display_listen_addr->slice_num ? vnc_display_listen_addr->left_cbp : -1;

    cbp_b = vnc_display_listen_addr->slice_table[vnc_display_listen_addr->top_mb_xy]     == vnc_display_listen_addr->slice_num ? vnc_display_listen_addr->top_cbp  : -1;



    link_status_changed = !(init_vlc & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&vnc_display_listen_addr->cabac, &vnc_display_listen_addr->cabac_state[73 + link_status_changed]);

    link_status_changed = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&vnc_display_listen_addr->cabac, &vnc_display_listen_addr->cabac_state[73 + link_status_changed]) << 1;

    link_status_changed = !(init_vlc & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&vnc_display_listen_addr->cabac, &vnc_display_listen_addr->cabac_state[73 + link_status_changed]) << 2;

    link_status_changed = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&vnc_display_listen_addr->cabac, &vnc_display_listen_addr->cabac_state[73 + link_status_changed]) << 3;

    return cbp;

}
",0,0,0,-1,h,0.0003580627962946892,3,30,"{'ctx': 'link_status_changed', 'h': 'vnc_display_listen_addr', 'cbp_a': 'init_vlc'}",MHM-Origin,392,0.17366834878921508
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
",103,"target_ulong helper_sdiv(target_ulong ABGR, target_ulong gettimeofday)

{

    int64_t cpu_handle_halt;

    int32_t cbSize;



    cpu_handle_halt = (ABGR & 0xffffffff) | ((int64_t) (env->y) << 32);

    cbSize = (gettimeofday & 0xffffffff);



    if (cbSize == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    cpu_handle_halt = cpu_handle_halt / cbSize;

    if ((int32_t) cpu_handle_halt != cpu_handle_halt) {

        env->cc_src2 = 1;

        return cpu_handle_halt < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return cpu_handle_halt;

    }

}
",1,1,1,-1,b,-0.0039629340171813965,4,16,"{'a': 'ABGR', 'b': 'gettimeofday', 'x1': 'cbSize', 'x0': 'cpu_handle_halt'}",MHM-Origin,396,0.16353199481964112
307,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
",80,"void helper_tlb_update(uint32_t ricemodifier)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t FF_THREAD_SLICE;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	FF_THREAD_SLICE = cris_mmu_tlb_latest_update(env, ricemodifier);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x
"", FF_THREAD_SLICE, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, ricemodifier));

	tlb_flush_page(env, FF_THREAD_SLICE);

#endif

}
",0,0,0,-1,T0,0.03450937010347843,2,7,"{'vaddr': 'FF_THREAD_SLICE', 'T0': 'ricemodifier'}",MHM-Origin,401,0.16536689201990765
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",93,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t QERR_BAD_BUS_FOR_DEVICE)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!QERR_BAD_BUS_FOR_DEVICE) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",0,0,1,1,eject,0.6302835121750832,1,2,{'eject': 'QERR_BAD_BUS_FOR_DEVICE'},MHM-Origin,20,0.008531959851582845
309,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",205,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *l1_table_offset)

{

    int cpu_T1 = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = l1_table_offset;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; cpu_T1 <= y; cpu_T1++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + cpu_T1 * main_stride)], main_stride,

                                &ref[4 * (x + cpu_T1 * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",0,0,1,1,z,0.041536688804626465,2,7,"{'temp': 'l1_table_offset', 'z': 'cpu_T1'}",MHM-Origin,43,0.01712383031845093
311,"static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,

                          Error **errp)

{

    BDRVBlkverifyState *s = bs->opaque;

    QemuOpts *opts;

    Error *local_err = NULL;

    int ret;



    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(opts, options, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto fail;




    /* Open the raw file */

    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-raw""), options, ""raw"",

                               bs, &child_file, false, &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    /* Open the test file */

    s->test_file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options,

                                   ""test"", bs, &child_format, false,

                                   &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    ret = 0;

fail:




    qemu_opts_del(opts);

    return ret;
",205,"static int blkverify_open(BlockDriverState *dma_memory_write, QDict *wwn, int OPUS_MODE_HYBRID,

                          Error **n)

{

    BDRVBlkverifyState *dest_byte_c = dma_memory_write->opaque;

    QemuOpts *get_bits_left;

    Error *l2_cache = NULL;

    int ret;



    get_bits_left = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(get_bits_left, wwn, &l2_cache);

    if (l2_cache) {

        error_propagate(n, l2_cache);

        ret = -EINVAL;

        goto fail;




    /* Open the raw file */

    dma_memory_write->file = bdrv_open_child(qemu_opt_get(get_bits_left, ""x-raw""), wwn, ""raw"",

                               dma_memory_write, &child_file, false, &l2_cache);

    if (l2_cache) {

        ret = -EINVAL;

        error_propagate(n, l2_cache);

        goto fail;




    /* Open the test file */

    dest_byte_c->test_file = bdrv_open_child(qemu_opt_get(get_bits_left, ""x-image""), wwn,

                                   ""test"", dma_memory_write, &child_format, false,

                                   &l2_cache);

    if (l2_cache) {

        ret = -EINVAL;

        error_propagate(n, l2_cache);

        goto fail;




    ret = 0;

fail:




    qemu_opts_del(get_bits_left);

    return ret;
",1,1,1,-1,bs,-0.00048220157623291016,7,32,"{'local_err': 'l2_cache', 'opts': 'get_bits_left', 's': 'dest_byte_c', 'bs': 'dma_memory_write', 'options': 'wwn', 'flags': 'OPUS_MODE_HYBRID', 'errp': 'n'}",MHM-Origin,394,0.18575989405314128
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",127,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *bdrv_guess_geometry,

                          int gen_op_arith_compute_ca)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= bdrv_guess_geometry[i];

        int val=0;

        for (j=0; j<gen_op_arith_compute_ca; j++) {

            val += ((int)src[srcPos + j])*filter[gen_op_arith_compute_ca*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",1,1,0,1,filterPos,-0.7070275545120239,2,5,"{'filterSize': 'gen_op_arith_compute_ca', 'filterPos': 'bdrv_guess_geometry'}",MHM-Origin,42,0.016355574131011963
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",127,"qemu_co_sendv_recvv(int mpeg1_aspect, struct iovec *peers_ptr, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t virtio_cleanup;

    while (done < bytes) {

        virtio_cleanup = iov_send_recv(mpeg1_aspect, peers_ptr,

                            offset + done, bytes - done, do_send);

        if (virtio_cleanup > 0) {

            done += virtio_cleanup;

        } else if (virtio_cleanup < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (virtio_cleanup == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",1,1,0,1,iov,-0.42532020807266235,3,10,"{'sockfd': 'mpeg1_aspect', 'ret': 'virtio_cleanup', 'iov': 'peers_ptr'}",MHM-Origin,80,0.0332607905069987
318,"static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {

    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);

    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",218,"static void av_always_inline filter_mb_edgech( uint8_t *CF_COUNT_MASK, int qemu_coroutine_yield, const int16_t pflag[4], unsigned int other_job, H264Context *handler ) {

    const int qp_bd_offset = 6 * (handler->sps.bit_depth_luma - 8);

    const unsigned int index_a = other_job - qp_bd_offset + handler->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[other_job - qp_bd_offset + handler->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( pflag[0] < 4 ) {

        int8_t nb_ostreams[4];

        nb_ostreams[0] = tc0_table[index_a][pflag[0]]+1;

        nb_ostreams[1] = tc0_table[index_a][pflag[1]]+1;

        nb_ostreams[2] = tc0_table[index_a][pflag[2]]+1;

        nb_ostreams[3] = tc0_table[index_a][pflag[3]]+1;

        handler->h264dsp.h264_v_loop_filter_chroma(CF_COUNT_MASK, qemu_coroutine_yield, alpha, beta, nb_ostreams);

    } else {

        handler->h264dsp.h264_v_loop_filter_chroma_intra(CF_COUNT_MASK, qemu_coroutine_yield, alpha, beta);

    }

}
",0,0,0,-1,tc,-0.0017810040153563023,6,27,"{'stride': 'qemu_coroutine_yield', 'h': 'handler', 'bS': 'pflag', 'pix': 'CF_COUNT_MASK', 'tc': 'nb_ostreams', 'qp': 'other_job'}",MHM-Origin,403,0.17667617003122965
319,"static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size,

                          const char *boot_device,

                          DisplayState *ds, const char *kernel_filename,

                          const char *kernel_cmdline,

                          const char *initrd_filename, const char *cpu_model)

{

    CPUState *env, *envs[MAX_CPUS];

    unsigned int i;

    void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;

    qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq,

        *espdma_irq, *ledma_irq;

    qemu_irq *esp_reset, *le_reset;

    ram_addr_t ram_offset, prom_offset, tcx_offset;

    unsigned long kernel_size;

    int ret;

    char buf[1024];

    int drive_index;

    void *fw_cfg;



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");

            exit(1);

        }

        cpu_sparc_set_id(env, i);

        envs[i] = env;

        if (i == 0) {

            qemu_register_reset(main_cpu_reset, env);

        } else {

            qemu_register_reset(secondary_cpu_reset, env);

            env->halted = 1;

        }

        cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);

        env->prom_addr = hwdef->slavio_base;

    }



    for (i = smp_cpus; i < MAX_CPUS; i++)

        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);



    /* allocate RAM */

    if ((uint64_t)RAM_size > hwdef->max_mem) {

        fprintf(stderr,

                ""qemu: Too much memory for this machine: %d, maximum %d\n"",

                (unsigned int)(RAM_size / (1024 * 1024)),

                (unsigned int)(hwdef->max_mem / (1024 * 1024)));

        exit(1);

    }

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    /* load boot prom */

    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->slavio_base,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    snprintf(buf, sizeof(buf), ""%s/%s"", bios_dir, bios_name);

    ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);

    if (ret < 0 || ret > PROM_SIZE_MAX)

        ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);

    if (ret < 0 || ret > PROM_SIZE_MAX) {

        fprintf(stderr, ""qemu: could not load prom '%s'\n"",

                buf);

        exit(1);

    }



    /* set up devices */

    sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs);



    for (i = 0; i < MAX_IOUNITS; i++)

        if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1)

            iounits[i] = iommu_init(hwdef->iounit_bases[i],

                                    hwdef->iounit_version,

                                    sbi_irq[hwdef->me_irq]);



    espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq],

                              iounits[0], &espdma_irq, &esp_reset);



    ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq],

                             iounits[0], &ledma_irq, &le_reset);



    if (graphic_depth != 8 && graphic_depth != 24) {

        fprintf(stderr, ""qemu: Unsupported depth: %d\n"", graphic_depth);

        exit (1);

    }

    tcx_offset = qemu_ram_alloc(hwdef->vram_size);

    tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset,

             hwdef->vram_size, graphic_width, graphic_height, graphic_depth);



    if (nd_table[0].model == NULL)

        nd_table[0].model = ""lance"";

    if (strcmp(nd_table[0].model, ""lance"") == 0) {

        lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);

    } else if (strcmp(nd_table[0].model, ""?"") == 0) {

        fprintf(stderr, ""qemu: Supported NICs: lance\n"");

        exit (1);

    } else {

        fprintf(stderr, ""qemu: Unsupported NIC: %s\n"", nd_table[0].model);

        exit (1);

    }



    nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0,

                        hwdef->nvram_size, 8);



    slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq],

                          sbi_cpu_irq, smp_cpus);



    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq],

                              nographic, ESCC_CLOCK, 1);

    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device

    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device

    escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1],

              serial_hds[0], ESCC_CLOCK, 1);



    if (drive_get_max_bus(IF_SCSI) > 0) {

        fprintf(stderr, ""qemu: too many SCSI bus\n"");

        exit(1);

    }



    main_esp = esp_init(hwdef->esp_base, 2,

                        espdma_memory_read, espdma_memory_write,

                        espdma, *espdma_irq, esp_reset);



    for (i = 0; i < ESP_MAX_DEVS; i++) {

        drive_index = drive_get_index(IF_SCSI, 0, i);

        if (drive_index == -1)

            continue;

        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i);

    }



    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,

                                    RAM_size);



    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,

               boot_device, RAM_size, kernel_size, graphic_width,

               graphic_height, graphic_depth, hwdef->nvram_machine_id,

               ""Sun4d"");



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

}
",1071,"static void sun4d_hw_init(const struct sun4d_hwdef *ref_stride, ram_addr_t reopen_queue,

                          const char *FF_LAMBDA_SCALE,

                          DisplayState *ds, const char *kernel_filename,

                          const char *I2CBus,

                          const char *initrd_filename, const char *cpu_model)

{

    CPUState *env, *OPC_SUB_CP2[tcg_gen_sub_i32];

    unsigned int i;

    void *sysbus_create_simple[TCG_CALL_DUMMY_ARG], *espdma, *PRIu32, *pmcw, *append, *sbi;

    qemu_irq *cpu_irqs[tcg_gen_sub_i32], *tcg_gen_qemu_st16, *AV_CODEC_ID_H264,

        *espdma_irq, *colour2;

    qemu_irq *DISAS_NEXT, *le_reset;

    ram_addr_t ram_offset, prom_offset, end_pts;

    unsigned long kernel_size;

    int ret;

    char buf[1024];

    int drive_index;

    void *fw_cfg;



    /* init CPUs */

    if (!cpu_model)

        cpu_model = ref_stride->default_cpu_model;



    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""qemu: Unable to find Sparc CPU definition
"");

            exit(1);

        }

        cpu_sparc_set_id(env, i);

        OPC_SUB_CP2[i] = env;

        if (i == 0) {

            qemu_register_reset(main_cpu_reset, env);

        } else {

            qemu_register_reset(secondary_cpu_reset, env);

            env->halted = 1;

        }

        cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, OPC_SUB_CP2[i], MAX_PILS);

        env->prom_addr = ref_stride->slavio_base;

    }



    for (i = smp_cpus; i < tcg_gen_sub_i32; i++)

        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);



    /* allocate RAM */

    if ((uint64_t)reopen_queue > ref_stride->max_mem) {

        fprintf(stderr,

                ""qemu: Too much memory for this machine: %d, maximum %d
"",

                (unsigned int)(reopen_queue / (1024 * 1024)),

                (unsigned int)(ref_stride->max_mem / (1024 * 1024)));

        exit(1);

    }

    ram_offset = qemu_ram_alloc(reopen_queue);

    cpu_register_physical_memory(0, reopen_queue, ram_offset);



    /* load boot prom */

    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(ref_stride->slavio_base,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    snprintf(buf, sizeof(buf), ""%s/%s"", bios_dir, bios_name);

    ret = load_elf(buf, ref_stride->slavio_base - PROM_VADDR, NULL, NULL, NULL);

    if (ret < 0 || ret > PROM_SIZE_MAX)

        ret = load_image_targphys(buf, ref_stride->slavio_base, PROM_SIZE_MAX);

    if (ret < 0 || ret > PROM_SIZE_MAX) {

        fprintf(stderr, ""qemu: could not load prom '%s'
"",

                buf);

        exit(1);

    }



    /* set up devices */

    sbi = sbi_init(ref_stride->sbi_base, &tcg_gen_qemu_st16, &AV_CODEC_ID_H264, cpu_irqs);



    for (i = 0; i < TCG_CALL_DUMMY_ARG; i++)

        if (ref_stride->iounit_bases[i] != (target_phys_addr_t)-1)

            sysbus_create_simple[i] = iommu_init(ref_stride->iounit_bases[i],

                                    ref_stride->iounit_version,

                                    tcg_gen_qemu_st16[ref_stride->me_irq]);



    espdma = sparc32_dma_init(ref_stride->espdma_base, tcg_gen_qemu_st16[ref_stride->esp_irq],

                              sysbus_create_simple[0], &espdma_irq, &DISAS_NEXT);



    PRIu32 = sparc32_dma_init(ref_stride->ledma_base, tcg_gen_qemu_st16[ref_stride->le_irq],

                             sysbus_create_simple[0], &colour2, &le_reset);



    if (graphic_depth != 8 && graphic_depth != 24) {

        fprintf(stderr, ""qemu: Unsupported depth: %d
"", graphic_depth);

        exit (1);

    }

    end_pts = qemu_ram_alloc(ref_stride->vram_size);

    tcx_init(ds, ref_stride->tcx_base, phys_ram_base + end_pts, end_pts,

             ref_stride->vram_size, graphic_width, graphic_height, graphic_depth);



    if (nd_table[0].model == NULL)

        nd_table[0].model = ""lance"";

    if (strcmp(nd_table[0].model, ""lance"") == 0) {

        lance_init(&nd_table[0], ref_stride->le_base, PRIu32, *colour2, le_reset);

    } else if (strcmp(nd_table[0].model, ""?"") == 0) {

        fprintf(stderr, ""qemu: Supported NICs: lance
"");

        exit (1);

    } else {

        fprintf(stderr, ""qemu: Unsupported NIC: %s
"", nd_table[0].model);

        exit (1);

    }



    append = m48t59_init(tcg_gen_qemu_st16[0], ref_stride->nvram_base, 0,

                        ref_stride->nvram_size, 8);



    slavio_timer_init_all(ref_stride->counter_base, tcg_gen_qemu_st16[ref_stride->clock1_irq],

                          AV_CODEC_ID_H264, smp_cpus);



    slavio_serial_ms_kbd_init(ref_stride->ms_kb_base, tcg_gen_qemu_st16[ref_stride->ms_kb_irq],

                              nographic, ESCC_CLOCK, 1);

    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device

    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device

    escc_init(ref_stride->serial_base, tcg_gen_qemu_st16[ref_stride->ser_irq], serial_hds[1],

              serial_hds[0], ESCC_CLOCK, 1);



    if (drive_get_max_bus(IF_SCSI) > 0) {

        fprintf(stderr, ""qemu: too many SCSI bus
"");

        exit(1);

    }



    pmcw = esp_init(ref_stride->esp_base, 2,

                        espdma_memory_read, espdma_memory_write,

                        espdma, *espdma_irq, DISAS_NEXT);



    for (i = 0; i < ESP_MAX_DEVS; i++) {

        drive_index = drive_get_index(IF_SCSI, 0, i);

        if (drive_index == -1)

            continue;

        esp_scsi_attach(pmcw, drives_table[drive_index].bdrv, i);

    }



    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,

                                    reopen_queue);



    nvram_init(append, (uint8_t *)&nd_table[0].macaddr, I2CBus,

               FF_LAMBDA_SCALE, reopen_queue, kernel_size, graphic_width,

               graphic_height, graphic_depth, ref_stride->nvram_machine_id,

               ""Sun4d"");



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, ref_stride->machine_id);

}
",0,0,0,-1,ledma_irq,0.008626237511634827,16,86,"{'nvram': 'append', 'ledma': 'PRIu32', 'sbi_cpu_irq': 'AV_CODEC_ID_H264', 'main_esp': 'pmcw', 'iounits': 'sysbus_create_simple', 'hwdef': 'ref_stride', 'sbi_irq': 'tcg_gen_qemu_st16', 'MAX_IOUNITS': 'TCG_CALL_DUMMY_ARG', 'boot_device': 'FF_LAMBDA_SCALE', 'tcx_offset': 'end_pts', 'RAM_size': 'reopen_queue', 'esp_reset': 'DISAS_NEXT', 'MAX_CPUS': 'tcg_gen_sub_i32', 'envs': 'OPC_SUB_CP2', 'kernel_cmdline': 'I2CBus', 'ledma_irq': 'colour2'}",MHM-Origin,398,0.2325054923693339
321,"static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t *)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    __asm__ volatile(""pxor    %%mm7,%%mm7    \n\t"":::""memory"");

    __asm__ volatile(""pcmpeqd %%mm6,%%mm6    \n\t"":::""memory"");

    mm_end = end - 3;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            PACK_RGB32

            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r)

            :""memory"");

        d += 16;

        s += 4;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

        *d++ = 255;

    }

}
",304,"static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *samplesInChunk, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = samplesInChunk;

    const uint16_t *s = (const uint16_t *)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    __asm__ volatile(""pxor    %%mm7,%%mm7    
\t"":::""memory"");

    __asm__ volatile(""pcmpeqd %%mm6,%%mm6    
\t"":::""memory"");

    mm_end = end - 3;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movq          %1, %%mm0    
\t""

            ""movq          %1, %%mm1    
\t""

            ""movq          %1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            PACK_RGB32

            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r)

            :""memory"");

        d += 16;

        s += 4;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

        *d++ = 255;

    }

}
",1,1,0,1,dst,-0.49673721194267273,1,2,{'dst': 'samplesInChunk'},MHM-Origin,22,0.009189315636952718
328,"static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x,

                                                 const uint8_t *src_y,

                                                 int32_t src_stride,

                                                 uint8_t *dst,

                                                 int32_t dst_stride)

{

    v16i8 src_hz0, src_hz1, src_hz2, src_hz3;

    v16u8 dst0, dst1, dst2, dst3;

    v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4;

    v16i8 src_vt5, src_vt6, src_vt7, src_vt8;

    v16i8 mask0, mask1, mask2;

    v8i16 hz_out0, hz_out1, vert_out0, vert_out1;

    v8i16 res0, res1;

    v16u8 res;



    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);

    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);

    src_y += (5 * src_stride);



    src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1);

    src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2);

    src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3);

    src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4);



    XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3);

    LD_SB4(src_x, src_stride, src_hz0, src_hz1, src_hz2, src_hz3);

    LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);

    XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3);

    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1,

                                                          mask0, mask1, mask2);

    hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3,

                                                          mask0, mask1, mask2);

    SRARI_H2_SH(hz_out0, hz_out1, 5);

    SAT_SH2_SH(hz_out0, hz_out1, 7);

    LD_SB4(src_y, src_stride, src_vt5, src_vt6, src_vt7, src_vt8);



    src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5);

    src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6);

    src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7);

    src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8);



    XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7);



    /* filter calc */

    vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2,

                                                  src_vt3, src_vt4, src_vt5);

    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4,

                                                  src_vt5, src_vt6, src_vt7);

    SRARI_H2_SH(vert_out0, vert_out1, 5);

    SAT_SH2_SH(vert_out0, vert_out1, 7);



    res1 = __msa_srari_h((hz_out1 + vert_out1), 1);

    res0 = __msa_srari_h((hz_out0 + vert_out0), 1);



    SAT_SH2_SH(res0, res1, 7);

    res = PCKEV_XORI128_UB(res0, res1);



    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);

    dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3);

    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);

    dst0 = __msa_aver_u_b(res, dst0);



    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride);

}
",600,"static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *TCG_REG_R2,

                                                 const uint8_t *stream_printf,

                                                 int32_t src_stride,

                                                 uint8_t *dst,

                                                 int32_t tcpname)

{

    v16i8 SCSI_DMA_BUF_SIZE, img, src_hz2, src_hz3;

    v16u8 dst0, dst1, dst2, essence_offset;

    v16i8 src_vt0, block0, src_vt2, nb_terminationsinc, src_vt4;

    v16i8 src_vt5, src_vt6, tcg_gen_andi_i32, numchannels;

    v16i8 tcg_gen_mov_i64, mask1, raw_samples;

    v8i16 hz_out0, ref_plane, coord, vert_out1;

    v8i16 disabled, codec;

    v16u8 res;



    LD_SB3(&luma_mask_arr[48], 16, tcg_gen_mov_i64, mask1, raw_samples);

    LD_SB5(stream_printf, src_stride, src_vt0, block0, src_vt2, nb_terminationsinc, src_vt4);

    stream_printf += (5 * src_stride);



    src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) block0);

    block0 = (v16i8) __msa_insve_w((v4i32) block0, 1, (v4i32) src_vt2);

    src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) nb_terminationsinc);

    nb_terminationsinc = (v16i8) __msa_insve_w((v4i32) nb_terminationsinc, 1, (v4i32) src_vt4);



    XORI_B4_128_SB(src_vt0, block0, src_vt2, nb_terminationsinc);

    LD_SB4(TCG_REG_R2, src_stride, SCSI_DMA_BUF_SIZE, img, src_hz2, src_hz3);

    LD_UB4(dst, tcpname, dst0, dst1, dst2, essence_offset);

    XORI_B4_128_SB(SCSI_DMA_BUF_SIZE, img, src_hz2, src_hz3);

    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(SCSI_DMA_BUF_SIZE, img,

                                                          tcg_gen_mov_i64, mask1, raw_samples);

    ref_plane = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3,

                                                          tcg_gen_mov_i64, mask1, raw_samples);

    SRARI_H2_SH(hz_out0, ref_plane, 5);

    SAT_SH2_SH(hz_out0, ref_plane, 7);

    LD_SB4(stream_printf, src_stride, src_vt5, src_vt6, tcg_gen_andi_i32, numchannels);



    src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5);

    src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6);

    src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) tcg_gen_andi_i32);

    tcg_gen_andi_i32 = (v16i8) __msa_insve_w((v4i32) tcg_gen_andi_i32, 1, (v4i32) numchannels);



    XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, tcg_gen_andi_i32);



    /* filter calc */

    coord = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, block0, src_vt2,

                                                  nb_terminationsinc, src_vt4, src_vt5);

    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, nb_terminationsinc, src_vt4,

                                                  src_vt5, src_vt6, tcg_gen_andi_i32);

    SRARI_H2_SH(coord, vert_out1, 5);

    SAT_SH2_SH(coord, vert_out1, 7);



    codec = __msa_srari_h((ref_plane + vert_out1), 1);

    disabled = __msa_srari_h((hz_out0 + coord), 1);



    SAT_SH2_SH(disabled, codec, 7);

    res = PCKEV_XORI128_UB(disabled, codec);



    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);

    dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) essence_offset);

    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);

    dst0 = __msa_aver_u_b(res, dst0);



    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, tcpname);

}
",0,0,0,-1,src_y,-0.00013885600492358208,16,71,"{'mask0': 'tcg_gen_mov_i64', 'src_x': 'TCG_REG_R2', 'src_vt1': 'block0', 'src_hz1': 'img', 'src_vt7': 'tcg_gen_andi_i32', 'dst3': 'essence_offset', 'res1': 'codec', 'res0': 'disabled', 'dst_stride': 'tcpname', 'src_vt8': 'numchannels', 'mask2': 'raw_samples', 'hz_out1': 'ref_plane', 'src_hz0': 'SCSI_DMA_BUF_SIZE', 'src_vt3': 'nb_terminationsinc', 'vert_out0': 'coord', 'src_y': 'stream_printf'}",MHM-Origin,398,0.19957160552342731
329,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

                         BlockDriverCompletionFunc *cb, void *opaque)

{

    BDRVRawState *s = bs->opaque;

    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,

                       cb, opaque, QEMU_AIO_READ);

}
",59,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector *EXCP_INTERRUPT, int nb_sectors,

                         BlockDriverCompletionFunc *is_pipe, void *ROCKER_EINVAL)

{

    BDRVRawState *MO_LEUW = bs->ROCKER_EINVAL;

    return paio_submit(bs, MO_LEUW->hfile, sector_num, EXCP_INTERRUPT, nb_sectors,

                       is_pipe, ROCKER_EINVAL, QEMU_AIO_READ);

}
",0,0,1,1,opaque,0.9210036508738995,4,9,"{'s': 'MO_LEUW', 'cb': 'is_pipe', 'opaque': 'ROCKER_EINVAL', 'qiov': 'EXCP_INTERRUPT'}",MHM-Origin,138,0.057068447271982826
330,"static void tcx_blit_writel(void *opaque, hwaddr addr,

                            uint64_t val, unsigned size)

{

    TCXState *s = opaque;

    uint32_t adsr, len;

    int i;



    if (!(addr & 4)) {

        s->tmpblit = val;

    } else {

        addr = (addr >> 3) & 0xfffff;

        adsr = val & 0xffffff;

        len = ((val >> 24) & 0x1f) + 1;

        if (adsr == 0xffffff) {

            memset(&s->vram[addr], s->tmpblit, len);

            if (s->depth == 24) {

                val = s->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (i = 0; i < len; i++) {

                    s->vram24[addr + i] = val;

                }

            }

        } else {

            memcpy(&s->vram[addr], &s->vram[adsr], len);

            if (s->depth == 24) {

                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);

            }

        }

        memory_region_set_dirty(&s->vram_mem, addr, len);

    }

}
",228,"static void tcx_blit_writel(void *qemu_loglevel_mask, hwaddr addr,

                            uint64_t tcg_reg_free, unsigned data_bit_start)

{

    TCXState *IPMVEContext = qemu_loglevel_mask;

    uint32_t adsr, fs_ctx;

    int i;



    if (!(addr & 4)) {

        IPMVEContext->tmpblit = tcg_reg_free;

    } else {

        addr = (addr >> 3) & 0xfffff;

        adsr = tcg_reg_free & 0xffffff;

        fs_ctx = ((tcg_reg_free >> 24) & 0x1f) + 1;

        if (adsr == 0xffffff) {

            memset(&IPMVEContext->vram[addr], IPMVEContext->tmpblit, fs_ctx);

            if (IPMVEContext->depth == 24) {

                tcg_reg_free = IPMVEContext->tmpblit & 0xffffff;

                tcg_reg_free = cpu_to_be32(tcg_reg_free);

                for (i = 0; i < fs_ctx; i++) {

                    IPMVEContext->vram24[addr + i] = tcg_reg_free;

                }

            }

        } else {

            memcpy(&IPMVEContext->vram[addr], &IPMVEContext->vram[adsr], fs_ctx);

            if (IPMVEContext->depth == 24) {

                memcpy(&IPMVEContext->vram24[addr], &IPMVEContext->vram24[adsr], fs_ctx * 4);

            }

        }

        memory_region_set_dirty(&IPMVEContext->vram_mem, addr, fs_ctx);

    }

}
",0,0,1,1,size,0.31564250588417053,5,31,"{'s': 'IPMVEContext', 'len': 'fs_ctx', 'val': 'tcg_reg_free', 'size': 'data_bit_start', 'opaque': 'qemu_loglevel_mask'}",MHM-Origin,142,0.0591086745262146
331,"static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,

                                                       uint8_t alpha_in,

                                                       uint8_t beta_in,

                                                       uint32_t img_width)

{

    uint16_t out0, out1, out2, out3;

    v8i16 tmp1;

    v16u8 alpha, beta, is_less_than;

    v8i16 p0_or_q0, q0_or_p0;

    v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org;

    v16i8 zero = { 0 };

    v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0;

    v16u8 is_less_than_alpha, is_less_than_beta;

    v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r;



    {

        v16u8 row0, row1, row2, row3, row4, row5, row6, row7;



        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,

                      row0, row1, row2, row3, row4, row5, row6, row7);



        TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7,

                          p1_or_q1_org, p0_or_q0_org,

                          q0_or_p0_org, q1_or_p1_org);

    }



    alpha = (v16u8) __msa_fill_b(alpha_in);

    beta = (v16u8) __msa_fill_b(beta_in);



    p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org);

    p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org);

    q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org);



    is_less_than_alpha = (p0_asub_q0 < alpha);

    is_less_than_beta = (p1_asub_p0 < beta);

    is_less_than = is_less_than_beta & is_less_than_alpha;

    is_less_than_beta = (q1_asub_q0 < beta);

    is_less_than = is_less_than_beta & is_less_than;



    is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than);



    if (!__msa_test_bz_v(is_less_than)) {

        p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org);

        p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org);

        q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org);

        q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org);



        AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, p0_or_q0);

        AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0);



        /* convert 16 bit output into 8 bit output */

        p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0);

        q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0);



        p0_or_q0_org =

            __msa_bmnz_v(p0_or_q0_org, (v16u8) p0_or_q0, is_less_than);

        q0_or_p0_org =

            __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than);



        tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org);



        data_cb_or_cr -= 1;



        out0 = __msa_copy_u_h(tmp1, 0);

        out1 = __msa_copy_u_h(tmp1, 1);

        out2 = __msa_copy_u_h(tmp1, 2);

        out3 = __msa_copy_u_h(tmp1, 3);



        STORE_HWORD(data_cb_or_cr, out0);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out1);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out3);

        data_cb_or_cr += img_width;



        out0 = __msa_copy_u_h(tmp1, 4);

        out1 = __msa_copy_u_h(tmp1, 5);

        out2 = __msa_copy_u_h(tmp1, 6);

        out3 = __msa_copy_u_h(tmp1, 7);



        STORE_HWORD(data_cb_or_cr, out0);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out1);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out3);

    }

}
",582,"static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,

                                                       uint8_t i8042_init,

                                                       uint8_t beta_in,

                                                       uint32_t img_width)

{

    uint16_t out0, rma_alloc_size, out2, BusState;

    v8i16 tmp1;

    v16u8 alpha, frame_number, is_less_than;

    v8i16 hotplugged, FF_THREAD_FRAME;

    v16u8 handle_destroy, p0_or_q0_org, FFTContext, omap1;

    v16i8 zero = { 0 };

    v16u8 sc, sye, ObjectClass;

    v16u8 is_less_than_alpha, is_less_than_beta;

    v8i16 ram_size, p0_org_r, spapr_vscsi_create, q1_org_r;



    {

        v16u8 row0, dir_path, row2, l2_cache, row4, CP0_Config1, row6, BLOCKDEV_ON_ERROR_ENOSPC;



        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,

                      row0, dir_path, row2, l2_cache, row4, CP0_Config1, row6, BLOCKDEV_ON_ERROR_ENOSPC);



        TRANSPOSE8x4_B_UB(row0, dir_path, row2, l2_cache, row4, CP0_Config1, row6, BLOCKDEV_ON_ERROR_ENOSPC,

                          handle_destroy, p0_or_q0_org,

                          FFTContext, omap1);

    }



    alpha = (v16u8) __msa_fill_b(i8042_init);

    frame_number = (v16u8) __msa_fill_b(beta_in);



    sc = __msa_asub_u_b(p0_or_q0_org, FFTContext);

    sye = __msa_asub_u_b(handle_destroy, p0_or_q0_org);

    ObjectClass = __msa_asub_u_b(omap1, FFTContext);



    is_less_than_alpha = (sc < alpha);

    is_less_than_beta = (sye < frame_number);

    is_less_than = is_less_than_beta & is_less_than_alpha;

    is_less_than_beta = (ObjectClass < frame_number);

    is_less_than = is_less_than_beta & is_less_than;



    is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than);



    if (!__msa_test_bz_v(is_less_than)) {

        ram_size = (v8i16) __msa_ilvr_b(zero, (v16i8) handle_destroy);

        p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org);

        spapr_vscsi_create = (v8i16) __msa_ilvr_b(zero, (v16i8) FFTContext);

        q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) omap1);



        AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, ram_size, hotplugged);

        AVC_LOOP_FILTER_P0_OR_Q0(spapr_vscsi_create, ram_size, q1_org_r, FF_THREAD_FRAME);



        /* convert 16 bit output into 8 bit output */

        hotplugged = (v8i16) __msa_pckev_b(zero, (v16i8) hotplugged);

        FF_THREAD_FRAME = (v8i16) __msa_pckev_b(zero, (v16i8) FF_THREAD_FRAME);



        p0_or_q0_org =

            __msa_bmnz_v(p0_or_q0_org, (v16u8) hotplugged, is_less_than);

        FFTContext =

            __msa_bmnz_v(FFTContext, (v16u8) FF_THREAD_FRAME, is_less_than);



        tmp1 = (v8i16) __msa_ilvr_b((v16i8) FFTContext, (v16i8) p0_or_q0_org);



        data_cb_or_cr -= 1;



        out0 = __msa_copy_u_h(tmp1, 0);

        rma_alloc_size = __msa_copy_u_h(tmp1, 1);

        out2 = __msa_copy_u_h(tmp1, 2);

        BusState = __msa_copy_u_h(tmp1, 3);



        STORE_HWORD(data_cb_or_cr, out0);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, rma_alloc_size);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, BusState);

        data_cb_or_cr += img_width;



        out0 = __msa_copy_u_h(tmp1, 4);

        rma_alloc_size = __msa_copy_u_h(tmp1, 5);

        out2 = __msa_copy_u_h(tmp1, 6);

        BusState = __msa_copy_u_h(tmp1, 7);



        STORE_HWORD(data_cb_or_cr, out0);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, rma_alloc_size);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, BusState);

    }

}
",0,0,0,-1,p1_org_r,-3.6428216844797134e-05,18,70,"{'row1': 'dir_path', 'alpha_in': 'i8042_init', 'q0_or_p0': 'FF_THREAD_FRAME', 'q0_or_p0_org': 'FFTContext', 'q0_org_r': 'spapr_vscsi_create', 'out3': 'BusState', 'p0_or_q0': 'hotplugged', 'p1_or_q1_org': 'handle_destroy', 'p1_asub_p0': 'sye', 'row7': 'BLOCKDEV_ON_ERROR_ENOSPC', 'out1': 'rma_alloc_size', 'q1_or_p1_org': 'omap1', 'beta': 'frame_number', 'row3': 'l2_cache', 'q1_asub_q0': 'ObjectClass', 'row5': 'CP0_Config1', 'p0_asub_q0': 'sc', 'p1_org_r': 'ram_size'}",MHM-Origin,392,0.19605385462443034
333,"static int vdpau_mpeg_start_frame(AVCodecContext *avctx,

                                  const uint8_t *buffer, uint32_t size)

{

    MpegEncContext * const s = avctx->priv_data;

    Picture *pic             = s->current_picture_ptr;

    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;

    VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;

    VdpVideoSurface ref;

    int i;



    /* fill VdpPictureInfoMPEG1Or2 struct */

    info->forward_reference  = VDP_INVALID_HANDLE;

    info->backward_reference = VDP_INVALID_HANDLE;



    switch (s->pict_type) {

    case AV_PICTURE_TYPE_B:

        ref = ff_vdpau_get_surface_id(&s->next_picture.f);

        assert(ref != VDP_INVALID_HANDLE);

        info->backward_reference = ref;

        /* fall through to forward prediction */

    case AV_PICTURE_TYPE_P:

        ref = ff_vdpau_get_surface_id(&s->last_picture.f);

        info->forward_reference  = ref;

    }



    info->slice_count                = 0;

    info->picture_structure          = s->picture_structure;

    info->picture_coding_type        = s->pict_type;

    info->intra_dc_precision         = s->intra_dc_precision;

    info->frame_pred_frame_dct       = s->frame_pred_frame_dct;

    info->concealment_motion_vectors = s->concealment_motion_vectors;

    info->intra_vlc_format           = s->intra_vlc_format;

    info->alternate_scan             = s->alternate_scan;

    info->q_scale_type               = s->q_scale_type;

    info->top_field_first            = s->top_field_first;

    // Both for MPEG-1 only, zero for MPEG-2:

    info->full_pel_forward_vector    = s->full_pel[0];

    info->full_pel_backward_vector   = s->full_pel[1];

    // For MPEG-1 fill both horizontal & vertical:

    info->f_code[0][0]               = s->mpeg_f_code[0][0];

    info->f_code[0][1]               = s->mpeg_f_code[0][1];

    info->f_code[1][0]               = s->mpeg_f_code[1][0];

    info->f_code[1][1]               = s->mpeg_f_code[1][1];

    for (i = 0; i < 64; ++i) {

        info->intra_quantizer_matrix[i]     = s->intra_matrix[i];

        info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];

    }



    return ff_vdpau_common_start_frame(pic_ctx, buffer, size);

}
",363,"static int vdpau_mpeg_start_frame(AVCodecContext *avctx,

                                  const uint8_t *qemu_input_queue_abs, uint32_t size)

{

    MpegEncContext * const s = avctx->priv_data;

    Picture *pic             = s->current_picture_ptr;

    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;

    VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;

    VdpVideoSurface ref;

    int i;



    /* fill VdpPictureInfoMPEG1Or2 struct */

    info->forward_reference  = VDP_INVALID_HANDLE;

    info->backward_reference = VDP_INVALID_HANDLE;



    switch (s->pict_type) {

    case AV_PICTURE_TYPE_B:

        ref = ff_vdpau_get_surface_id(&s->next_picture.f);

        assert(ref != VDP_INVALID_HANDLE);

        info->backward_reference = ref;

        /* fall through to forward prediction */

    case AV_PICTURE_TYPE_P:

        ref = ff_vdpau_get_surface_id(&s->last_picture.f);

        info->forward_reference  = ref;

    }



    info->slice_count                = 0;

    info->picture_structure          = s->picture_structure;

    info->picture_coding_type        = s->pict_type;

    info->intra_dc_precision         = s->intra_dc_precision;

    info->frame_pred_frame_dct       = s->frame_pred_frame_dct;

    info->concealment_motion_vectors = s->concealment_motion_vectors;

    info->intra_vlc_format           = s->intra_vlc_format;

    info->alternate_scan             = s->alternate_scan;

    info->q_scale_type               = s->q_scale_type;

    info->top_field_first            = s->top_field_first;

    // Both for MPEG-1 only, zero for MPEG-2:

    info->full_pel_forward_vector    = s->full_pel[0];

    info->full_pel_backward_vector   = s->full_pel[1];

    // For MPEG-1 fill both horizontal & vertical:

    info->f_code[0][0]               = s->mpeg_f_code[0][0];

    info->f_code[0][1]               = s->mpeg_f_code[0][1];

    info->f_code[1][0]               = s->mpeg_f_code[1][0];

    info->f_code[1][1]               = s->mpeg_f_code[1][1];

    for (i = 0; i < 64; ++i) {

        info->intra_quantizer_matrix[i]     = s->intra_matrix[i];

        info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];

    }



    return ff_vdpau_common_start_frame(pic_ctx, qemu_input_queue_abs, size);

}
",1,1,0,1,buffer,-0.1827113926410675,1,2,{'buffer': 'qemu_input_queue_abs'},MHM-Origin,21,0.009271820386250814
334,"void h263_decode_init_vlc(MpegEncContext *s)

{

    static int done = 0;



    if (!done) {

        done = 1;



        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, 

                 intra_MCBPC_bits, 1, 1,

                 intra_MCBPC_code, 1, 1);

        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, 

                 inter_MCBPC_bits, 1, 1,

                 inter_MCBPC_code, 1, 1);

        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,

                 &cbpy_tab[0][1], 2, 1,

                 &cbpy_tab[0][0], 2, 1);

        init_vlc(&mv_vlc, MV_VLC_BITS, 33,

                 &mvtab[0][1], 2, 1,

                 &mvtab[0][0], 2, 1);

        init_rl(&rl_inter);

        init_rl(&rl_intra);

        init_rl(&rvlc_rl_inter);

        init_rl(&rvlc_rl_intra);

        init_rl(&rl_intra_aic);

        init_vlc_rl(&rl_inter);

        init_vlc_rl(&rl_intra);

        init_vlc_rl(&rvlc_rl_inter);

        init_vlc_rl(&rvlc_rl_intra);

        init_vlc_rl(&rl_intra_aic);

        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_lum[0][1], 2, 1,

                 &DCtab_lum[0][0], 2, 1);

        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_chrom[0][1], 2, 1,

                 &DCtab_chrom[0][0], 2, 1);

        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,

                 &sprite_trajectory_tab[0][1], 4, 2,

                 &sprite_trajectory_tab[0][0], 4, 2);

        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,

                 &mb_type_b_tab[0][1], 2, 1,

                 &mb_type_b_tab[0][0], 2, 1);

        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,

                 &h263_mbtype_b_tab[0][1], 2, 1,

                 &h263_mbtype_b_tab[0][0], 2, 1);

        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,

                 &cbpc_b_tab[0][1], 2, 1,

                 &cbpc_b_tab[0][0], 2, 1);

    }

}
",418,"void h263_decode_init_vlc(MpegEncContext *blocker)

{

    static int done = 0;



    if (!done) {

        done = 1;



        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, 

                 intra_MCBPC_bits, 1, 1,

                 intra_MCBPC_code, 1, 1);

        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, 

                 inter_MCBPC_bits, 1, 1,

                 inter_MCBPC_code, 1, 1);

        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,

                 &cbpy_tab[0][1], 2, 1,

                 &cbpy_tab[0][0], 2, 1);

        init_vlc(&mv_vlc, MV_VLC_BITS, 33,

                 &mvtab[0][1], 2, 1,

                 &mvtab[0][0], 2, 1);

        init_rl(&rl_inter);

        init_rl(&rl_intra);

        init_rl(&rvlc_rl_inter);

        init_rl(&rvlc_rl_intra);

        init_rl(&rl_intra_aic);

        init_vlc_rl(&rl_inter);

        init_vlc_rl(&rl_intra);

        init_vlc_rl(&rvlc_rl_inter);

        init_vlc_rl(&rvlc_rl_intra);

        init_vlc_rl(&rl_intra_aic);

        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_lum[0][1], 2, 1,

                 &DCtab_lum[0][0], 2, 1);

        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_chrom[0][1], 2, 1,

                 &DCtab_chrom[0][0], 2, 1);

        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,

                 &sprite_trajectory_tab[0][1], 4, 2,

                 &sprite_trajectory_tab[0][0], 4, 2);

        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,

                 &mb_type_b_tab[0][1], 2, 1,

                 &mb_type_b_tab[0][0], 2, 1);

        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,

                 &h263_mbtype_b_tab[0][1], 2, 1,

                 &h263_mbtype_b_tab[0][0], 2, 1);

        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,

                 &cbpc_b_tab[0][1], 2, 1,

                 &cbpc_b_tab[0][0], 2, 1);

    }

}
",1,1,1,-1,s,0.024702906608581543,1,1,{'s': 'H265RawSPS'},MHM-Origin,390,0.18260084788004557
337,"void ff_rfps_calculate(AVFormatContext *ic)
{
    int i, j;
    for (i = 0; i<ic->nb_streams; i++) {
        AVStream *st = ic->streams[i];
        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)
        // the check for tb_unreliable() is not completely correct, since this is not about handling
        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
        // ipmovie.c produces.
        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)
            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);
        if (st->info->duration_count>1 && !st->r_frame_rate.num
            && tb_unreliable(st->codec)) {
            int num = 0;
            double best_error= 0.01;
            for (j=0; j<MAX_STD_TIMEBASES; j++) {
                int k;
                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))
                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))
                for(k=0; k<2; k++){
                    int n= st->info->duration_count;
                    double a= st->info->duration_error[k][0][j] / n;
                    double error= st->info->duration_error[k][1][j]/n - a*a;
                    if(error < best_error && best_error> 0.000000001){
                        best_error= error;
                        num = get_std_framerate(j);
                    }
                    if(error < 0.02)
                        av_log(NULL, AV_LOG_DEBUG, ""rfps: %f %f\n"", get_std_framerate(j) / 12.0/1001, error);
                }
            }
            // do not increase frame rate by more than 1 % in order to match a standard rate.
            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))
                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);
        }
        av_freep(&st->info->duration_error);
        st->info->last_dts = AV_NOPTS_VALUE;
        st->info->duration_count = 0;
        st->info->rfps_duration_sum = 0;
    }
}",459,"void ff_rfps_calculate(AVFormatContext *ic)
{
    int i, j;
    for (i = 0; i<ic->nb_streams; i++) {
        AVStream *xyz_pix_fmts = ic->streams[i];
        if (xyz_pix_fmts->codec->codec_type != AVMEDIA_TYPE_VIDEO)
        // the check for tb_unreliable() is not completely correct, since this is not about handling
        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
        // ipmovie.c produces.
        if (tb_unreliable(xyz_pix_fmts->codec) && xyz_pix_fmts->info->duration_count > 15 && xyz_pix_fmts->info->duration_gcd > FFMAX(1, xyz_pix_fmts->time_base.den/(500LL*xyz_pix_fmts->time_base.num)) && !xyz_pix_fmts->r_frame_rate.num)
            av_reduce(&xyz_pix_fmts->r_frame_rate.num, &xyz_pix_fmts->r_frame_rate.den, xyz_pix_fmts->time_base.den, xyz_pix_fmts->time_base.num * xyz_pix_fmts->info->duration_gcd, INT_MAX);
        if (xyz_pix_fmts->info->duration_count>1 && !xyz_pix_fmts->r_frame_rate.num
            && tb_unreliable(xyz_pix_fmts->codec)) {
            int num = 0;
            double best_error= 0.01;
            for (j=0; j<MAX_STD_TIMEBASES; j++) {
                int k;
                if(xyz_pix_fmts->info->codec_info_duration && xyz_pix_fmts->info->codec_info_duration*av_q2d(xyz_pix_fmts->time_base) < (1001*12.0)/get_std_framerate(j))
                if(!xyz_pix_fmts->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))
                for(k=0; k<2; k++){
                    int n= xyz_pix_fmts->info->duration_count;
                    double a= xyz_pix_fmts->info->duration_error[k][0][j] / n;
                    double error= xyz_pix_fmts->info->duration_error[k][1][j]/n - a*a;
                    if(error < best_error && best_error> 0.000000001){
                        best_error= error;
                        num = get_std_framerate(j);
                    }
                    if(error < 0.02)
                        av_log(NULL, AV_LOG_DEBUG, ""rfps: %f %f
"", get_std_framerate(j) / 12.0/1001, error);
                }
            }
            // do not increase frame rate by more than 1 % in order to match a standard rate.
            if (num && (!xyz_pix_fmts->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(xyz_pix_fmts->r_frame_rate)))
                av_reduce(&xyz_pix_fmts->r_frame_rate.num, &xyz_pix_fmts->r_frame_rate.den, num, 12*1001, INT_MAX);
        }
        av_freep(&xyz_pix_fmts->info->duration_error);
        xyz_pix_fmts->info->last_dts = AV_NOPTS_VALUE;
        xyz_pix_fmts->info->duration_count = 0;
        xyz_pix_fmts->info->rfps_duration_sum = 0;
    }
}",1,1,0,1,st,-0.2879800796508789,1,31,{'st': 'xyz_pix_fmts'},MHM-Origin,24,0.010761884848276775
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
",36,"static void gen_compute_eflags_o(DisasContext *MSR_MTRRfix4K_C0000, TCGv reg)

{

    gen_compute_eflags(MSR_MTRRfix4K_C0000);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
",0,0,1,1,s,0.840210534632206,1,2,{'s': 'MSR_MTRRfix4K_C0000'},MHM-Origin,19,0.007744149367014567
339,"static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,

                                       int *mb_type)

{

    int b8_stride = 2;

    int b4_stride = h->b_stride;

    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;

    int mb_type_col[2];

    const int16_t (*l1mv0)[2], (*l1mv1)[2];

    const int8_t *l1ref0, *l1ref1;

    const int is_b8x8 = IS_8X8(*mb_type);

    unsigned int sub_mb_type = MB_TYPE_L0L1;

    int i8, i4;

    int ref[2];

    int mv[2];

    int list;



    assert(sl->ref_list[1][0].reference & 3);



    await_reference_mb_row(h, sl->ref_list[1][0].parent,

                           sl->mb_y + !!IS_INTERLACED(*mb_type));



#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \

                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)



    /* ref = min(neighbors) */

    for (list = 0; list < 2; list++) {

        int left_ref     = sl->ref_cache[list][scan8[0] - 1];

        int top_ref      = sl->ref_cache[list][scan8[0] - 8];

        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];

        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];

        if (refc == PART_NOT_AVAILABLE) {

            refc = sl->ref_cache[list][scan8[0] - 8 - 1];

            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];

        }

        ref[list] = FFMIN3((unsigned)left_ref,

                           (unsigned)top_ref,

                           (unsigned)refc);

        if (ref[list] >= 0) {

            /* This is just pred_motion() but with the cases removed that

             * cannot happen for direct blocks. */

            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];

            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];



            int match_count = (left_ref == ref[list]) +

                              (top_ref  == ref[list]) +

                              (refc     == ref[list]);



            if (match_count > 1) { // most common

                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),

                                      mid_pred(A[1], B[1], C[1]));

            } else {

                assert(match_count == 1);

                if (left_ref == ref[list])

                    mv[list] = AV_RN32A(A);

                else if (top_ref == ref[list])

                    mv[list] = AV_RN32A(B);

                else

                    mv[list] = AV_RN32A(C);

            }

        } else {

            int mask = ~(MB_TYPE_L0 << (2 * list));

            mv[list]  = 0;

            ref[list] = -1;

            if (!is_b8x8)

                *mb_type &= mask;

            sub_mb_type &= mask;

        }

    }

    if (ref[0] < 0 && ref[1] < 0) {

        ref[0] = ref[1] = 0;

        if (!is_b8x8)

            *mb_type |= MB_TYPE_L0L1;

        sub_mb_type |= MB_TYPE_L0L1;

    }



    if (!(is_b8x8 | mv[0] | mv[1])) {

        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);

        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;

        return;

    }



    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL

        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL

            mb_y  = (sl->mb_y & ~1) + sl->col_parity;

            mb_xy = sl->mb_x +

                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;

            b8_stride = 0;

        } else {

            mb_y  += sl->col_fieldoff;

            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity

        }

        goto single_col;

    } else {                                             // AFL/AFR/FR/FL -> AFR/FR

        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR

            mb_y           =  sl->mb_y & ~1;

            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;

            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];

            b8_stride      = 2 + 4 * h->mb_stride;

            b4_stride     *= 6;

            if (IS_INTERLACED(mb_type_col[0]) !=

                IS_INTERLACED(mb_type_col[1])) {

                mb_type_col[0] &= ~MB_TYPE_INTERLACED;

                mb_type_col[1] &= ~MB_TYPE_INTERLACED;

            }



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&

                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&

                !is_b8x8) {

                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */

            } else {

                *mb_type |= MB_TYPE_8x8;

            }

        } else {                                         //     AFR/FR    -> AFR/FR

single_col:

            mb_type_col[0] =

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {

                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */

            } else if (!is_b8x8 &&

                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {

                *mb_type |= MB_TYPE_DIRECT2 |

                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));

            } else {

                if (!h->sps.direct_8x8_inference_flag) {

                    /* FIXME: Save sub mb types from previous frames (or derive

                     * from MVs) so we know exactly what block size to use. */

                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */

                }

                *mb_type |= MB_TYPE_8x8;

            }

        }

    }



    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);



    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];

    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];

    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];

    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];

    if (!b8_stride) {

        if (sl->mb_y & 1) {

            l1ref0 += 2;

            l1ref1 += 2;

            l1mv0  += 2 * b4_stride;

            l1mv1  += 2 * b4_stride;

        }

    }



    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            int x8  = i8 & 1;

            int y8  = i8 >> 1;

            int xy8 = x8     + y8 * b8_stride;

            int xy4 = x8 * 3 + y8 * b4_stride;

            int a, b;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);

            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&

                ((l1ref0[xy8] == 0 &&

                  FFABS(l1mv0[xy4][0]) <= 1 &&

                  FFABS(l1mv0[xy4][1]) <= 1) ||

                 (l1ref0[xy8] < 0 &&

                  l1ref1[xy8] == 0 &&

                  FFABS(l1mv1[xy4][0]) <= 1 &&

                  FFABS(l1mv1[xy4][1]) <= 1))) {

                a =

                b = 0;

                if (ref[0] > 0)

                    a = mv[0];

                if (ref[1] > 0)

                    b = mv[1];

                n++;

            } else {

                a = mv[0];

                b = mv[1];

            }

            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);

        }

        if (!is_b8x8 && !(n & 3))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    } else if (IS_16X16(*mb_type)) {

        int a, b;



        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

            ((l1ref0[0] == 0 &&

              FFABS(l1mv0[0][0]) <= 1 &&

              FFABS(l1mv0[0][1]) <= 1) ||

             (l1ref0[0] < 0 && !l1ref1[0] &&

              FFABS(l1mv1[0][0]) <= 1 &&

              FFABS(l1mv1[0][1]) <= 1 &&

              h->x264_build > 33U))) {

            a = b = 0;

            if (ref[0] > 0)

                a = mv[0];

            if (ref[1] > 0)

                b = mv[1];

        } else {

            a = mv[0];

            b = mv[1];

        }

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);

    } else {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            const int x8 = i8 & 1;

            const int y8 = i8 >> 1;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);

            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);



            assert(b8_stride == 2);

            /* col_zero_flag */

            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

                (l1ref0[i8] == 0 ||

                 (l1ref0[i8] < 0 &&

                  l1ref1[i8] == 0 &&

                  h->x264_build > 33U))) {

                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;

                if (IS_SUB_8X8(sub_mb_type)) {

                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];

                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                        if (ref[0] == 0)

                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        if (ref[1] == 0)

                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        n += 4;

                    }

                } else {

                    int m = 0;

                    for (i4 = 0; i4 < 4; i4++) {

                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +

                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];

                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                            if (ref[0] == 0)

                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);

                            if (ref[1] == 0)

                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);

                            m++;

                        }

                    }

                    if (!(m & 3))

                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;

                    n += m;

                }

            }

        }

        if (!is_b8x8 && !(n & 15))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    }

}
",2703,"static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *job_id,

                                       int *bdrv_get_node_name)

{

    int b8_stride = 2;

    int b4_stride = h->b_stride;

    int mb_xy = job_id->mb_xy, mb_y = job_id->mb_y;

    int clk[2];

    const int16_t (*l1mv0)[2], (*l1mv1)[2];

    const int8_t *i, *parser;

    const int is_b8x8 = IS_8X8(*bdrv_get_node_name);

    unsigned int sub_mb_type = MB_TYPE_L0L1;

    int ROUND_UP, tcg_gen_neg_tl;

    int ref[2];

    int mv[2];

    int list;



    assert(job_id->ref_list[1][0].reference & 3);



    await_reference_mb_row(h, job_id->ref_list[1][0].parent,

                           job_id->mb_y + !!IS_INTERLACED(*bdrv_get_node_name));



#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \

                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)



    /* ref = min(neighbors) */

    for (list = 0; list < 2; list++) {

        int left_ref     = job_id->ref_cache[list][scan8[0] - 1];

        int top_ref      = job_id->ref_cache[list][scan8[0] - 8];

        int refc         = job_id->ref_cache[list][scan8[0] - 8 + 4];

        const int16_t *vscalefn = job_id->mv_cache[list][scan8[0]  - 8 + 4];

        if (refc == PART_NOT_AVAILABLE) {

            refc = job_id->ref_cache[list][scan8[0] - 8 - 1];

            vscalefn    = job_id->mv_cache[list][scan8[0]  - 8 - 1];

        }

        ref[list] = FFMIN3((unsigned)left_ref,

                           (unsigned)top_ref,

                           (unsigned)refc);

        if (ref[list] >= 0) {

            /* This is just pred_motion() but with the cases removed that

             * cannot happen for direct blocks. */

            const int16_t *const HELPER = job_id->mv_cache[list][scan8[0] - 1];

            const int16_t *const aflag = job_id->mv_cache[list][scan8[0] - 8];



            int match_count = (left_ref == ref[list]) +

                              (top_ref  == ref[list]) +

                              (refc     == ref[list]);



            if (match_count > 1) { // most common

                mv[list] = pack16to32(mid_pred(HELPER[0], aflag[0], vscalefn[0]),

                                      mid_pred(HELPER[1], aflag[1], vscalefn[1]));

            } else {

                assert(match_count == 1);

                if (left_ref == ref[list])

                    mv[list] = AV_RN32A(HELPER);

                else if (top_ref == ref[list])

                    mv[list] = AV_RN32A(aflag);

                else

                    mv[list] = AV_RN32A(vscalefn);

            }

        } else {

            int mask = ~(MB_TYPE_L0 << (2 * list));

            mv[list]  = 0;

            ref[list] = -1;

            if (!is_b8x8)

                *bdrv_get_node_name &= mask;

            sub_mb_type &= mask;

        }

    }

    if (ref[0] < 0 && ref[1] < 0) {

        ref[0] = ref[1] = 0;

        if (!is_b8x8)

            *bdrv_get_node_name |= MB_TYPE_L0L1;

        sub_mb_type |= MB_TYPE_L0L1;

    }



    if (!(is_b8x8 | mv[0] | mv[1])) {

        fill_rectangle(&job_id->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&job_id->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        fill_rectangle(&job_id->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);

        fill_rectangle(&job_id->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);

        *bdrv_get_node_name = (*bdrv_get_node_name & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;

        return;

    }



    if (IS_INTERLACED(job_id->ref_list[1][0].parent->bdrv_get_node_name[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL

        if (!IS_INTERLACED(*bdrv_get_node_name)) {                    //     AFR/FR    -> AFL/FL

            mb_y  = (job_id->mb_y & ~1) + job_id->col_parity;

            mb_xy = job_id->mb_x +

                    ((job_id->mb_y & ~1) + job_id->col_parity) * h->mb_stride;

            b8_stride = 0;

        } else {

            mb_y  += job_id->col_fieldoff;

            mb_xy += h->mb_stride * job_id->col_fieldoff; // non-zero for FL -> FL & differ parity

        }

        goto single_col;

    } else {                                             // AFL/AFR/FR/FL -> AFR/FR

        if (IS_INTERLACED(*bdrv_get_node_name)) {                   // AFL       /FL -> AFR/FR

            mb_y           =  job_id->mb_y & ~1;

            mb_xy          = (job_id->mb_y & ~1) * h->mb_stride + job_id->mb_x;

            clk[0] = job_id->ref_list[1][0].parent->bdrv_get_node_name[mb_xy];

            clk[1] = job_id->ref_list[1][0].parent->bdrv_get_node_name[mb_xy + h->mb_stride];

            b8_stride      = 2 + 4 * h->mb_stride;

            b4_stride     *= 6;

            if (IS_INTERLACED(clk[0]) !=

                IS_INTERLACED(clk[1])) {

                clk[0] &= ~MB_TYPE_INTERLACED;

                clk[1] &= ~MB_TYPE_INTERLACED;

            }



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if ((clk[0] & MB_TYPE_16x16_OR_INTRA) &&

                (clk[1] & MB_TYPE_16x16_OR_INTRA) &&

                !is_b8x8) {

                *bdrv_get_node_name |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */

            } else {

                *bdrv_get_node_name |= MB_TYPE_8x8;

            }

        } else {                                         //     AFR/FR    -> AFR/FR

single_col:

            clk[0] =

            clk[1] = job_id->ref_list[1][0].parent->bdrv_get_node_name[mb_xy];



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if (!is_b8x8 && (clk[0] & MB_TYPE_16x16_OR_INTRA)) {

                *bdrv_get_node_name |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */

            } else if (!is_b8x8 &&

                       (clk[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {

                *bdrv_get_node_name |= MB_TYPE_DIRECT2 |

                            (clk[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));

            } else {

                if (!h->sps.direct_8x8_inference_flag) {

                    /* FIXME: Save sub mb types from previous frames (or derive

                     * from MVs) so we know exactly what block size to use. */

                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */

                }

                *bdrv_get_node_name |= MB_TYPE_8x8;

            }

        }

    }



    await_reference_mb_row(h, job_id->ref_list[1][0].parent, mb_y);



    l1mv0  = &job_id->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];

    l1mv1  = &job_id->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];

    i = &job_id->ref_list[1][0].parent->ref_index[0][4 * mb_xy];

    parser = &job_id->ref_list[1][0].parent->ref_index[1][4 * mb_xy];

    if (!b8_stride) {

        if (job_id->mb_y & 1) {

            i += 2;

            parser += 2;

            l1mv0  += 2 * b4_stride;

            l1mv1  += 2 * b4_stride;

        }

    }



    if (IS_INTERLACED(*bdrv_get_node_name) != IS_INTERLACED(clk[0])) {

        int n = 0;

        for (ROUND_UP = 0; ROUND_UP < 4; ROUND_UP++) {

            int x8  = ROUND_UP & 1;

            int y8  = ROUND_UP >> 1;

            int xy8 = x8     + y8 * b8_stride;

            int xy4 = x8 * 3 + y8 * b4_stride;

            int l, nb_mmco;



            if (is_b8x8 && !IS_DIRECT(job_id->sub_mb_type[ROUND_UP]))

                continue;

            job_id->sub_mb_type[ROUND_UP] = sub_mb_type;



            fill_rectangle(&job_id->ref_cache[0][scan8[ROUND_UP * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&job_id->ref_cache[1][scan8[ROUND_UP * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);

            if (!IS_INTRA(clk[y8]) && !job_id->ref_list[1][0].parent->long_ref &&

                ((i[xy8] == 0 &&

                  FFABS(l1mv0[xy4][0]) <= 1 &&

                  FFABS(l1mv0[xy4][1]) <= 1) ||

                 (i[xy8] < 0 &&

                  parser[xy8] == 0 &&

                  FFABS(l1mv1[xy4][0]) <= 1 &&

                  FFABS(l1mv1[xy4][1]) <= 1))) {

                l =

                nb_mmco = 0;

                if (ref[0] > 0)

                    l = mv[0];

                if (ref[1] > 0)

                    nb_mmco = mv[1];

                n++;

            } else {

                l = mv[0];

                nb_mmco = mv[1];

            }

            fill_rectangle(&job_id->mv_cache[0][scan8[ROUND_UP * 4]], 2, 2, 8, l, 4);

            fill_rectangle(&job_id->mv_cache[1][scan8[ROUND_UP * 4]], 2, 2, 8, nb_mmco, 4);

        }

        if (!is_b8x8 && !(n & 3))

            *bdrv_get_node_name = (*bdrv_get_node_name & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    } else if (IS_16X16(*bdrv_get_node_name)) {

        int l, nb_mmco;



        fill_rectangle(&job_id->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&job_id->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        if (!IS_INTRA(clk[0]) && !job_id->ref_list[1][0].parent->long_ref &&

            ((i[0] == 0 &&

              FFABS(l1mv0[0][0]) <= 1 &&

              FFABS(l1mv0[0][1]) <= 1) ||

             (i[0] < 0 && !parser[0] &&

              FFABS(l1mv1[0][0]) <= 1 &&

              FFABS(l1mv1[0][1]) <= 1 &&

              h->x264_build > 33U))) {

            l = nb_mmco = 0;

            if (ref[0] > 0)

                l = mv[0];

            if (ref[1] > 0)

                nb_mmco = mv[1];

        } else {

            l = mv[0];

            nb_mmco = mv[1];

        }

        fill_rectangle(&job_id->mv_cache[0][scan8[0]], 4, 4, 8, l, 4);

        fill_rectangle(&job_id->mv_cache[1][scan8[0]], 4, 4, 8, nb_mmco, 4);

    } else {

        int n = 0;

        for (ROUND_UP = 0; ROUND_UP < 4; ROUND_UP++) {

            const int x8 = ROUND_UP & 1;

            const int y8 = ROUND_UP >> 1;



            if (is_b8x8 && !IS_DIRECT(job_id->sub_mb_type[ROUND_UP]))

                continue;

            job_id->sub_mb_type[ROUND_UP] = sub_mb_type;



            fill_rectangle(&job_id->mv_cache[0][scan8[ROUND_UP * 4]], 2, 2, 8, mv[0], 4);

            fill_rectangle(&job_id->mv_cache[1][scan8[ROUND_UP * 4]], 2, 2, 8, mv[1], 4);

            fill_rectangle(&job_id->ref_cache[0][scan8[ROUND_UP * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&job_id->ref_cache[1][scan8[ROUND_UP * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);



            assert(b8_stride == 2);

            /* col_zero_flag */

            if (!IS_INTRA(clk[0]) && !job_id->ref_list[1][0].parent->long_ref &&

                (i[ROUND_UP] == 0 ||

                 (i[ROUND_UP] < 0 &&

                  parser[ROUND_UP] == 0 &&

                  h->x264_build > 33U))) {

                const int16_t (*l1mv)[2] = i[ROUND_UP] == 0 ? l1mv0 : l1mv1;

                if (IS_SUB_8X8(sub_mb_type)) {

                    const int16_t *nr = l1mv[x8 * 3 + y8 * 3 * b4_stride];

                    if (FFABS(nr[0]) <= 1 && FFABS(nr[1]) <= 1) {

                        if (ref[0] == 0)

                            fill_rectangle(&job_id->mv_cache[0][scan8[ROUND_UP * 4]], 2, 2,

                                           8, 0, 4);

                        if (ref[1] == 0)

                            fill_rectangle(&job_id->mv_cache[1][scan8[ROUND_UP * 4]], 2, 2,

                                           8, 0, 4);

                        n += 4;

                    }

                } else {

                    int m = 0;

                    for (tcg_gen_neg_tl = 0; tcg_gen_neg_tl < 4; tcg_gen_neg_tl++) {

                        const int16_t *nr = l1mv[x8 * 2 + (tcg_gen_neg_tl & 1) +

                                                     (y8 * 2 + (tcg_gen_neg_tl >> 1)) * b4_stride];

                        if (FFABS(nr[0]) <= 1 && FFABS(nr[1]) <= 1) {

                            if (ref[0] == 0)

                                AV_ZERO32(job_id->mv_cache[0][scan8[ROUND_UP * 4 + tcg_gen_neg_tl]]);

                            if (ref[1] == 0)

                                AV_ZERO32(job_id->mv_cache[1][scan8[ROUND_UP * 4 + tcg_gen_neg_tl]]);

                            m++;

                        }

                    }

                    if (!(m & 3))

                        job_id->sub_mb_type[ROUND_UP] += MB_TYPE_16x16 - MB_TYPE_8x8;

                    n += m;

                }

            }

        }

        if (!is_b8x8 && !(n & 15))

            *bdrv_get_node_name = (*bdrv_get_node_name & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    }

}
",0,0,1,1,i4,0.011127293109893799,13,199,"{'l1ref0': 'i', 'i8': 'ROUND_UP', 'a': 'l', 'mb_type_col': 'clk', 'mb_type': 'bdrv_get_node_name', 'mv_col': 'nr', 'C': 'vscalefn', 'l1ref1': 'parser', 'sl': 'job_id', 'A': 'HELPER', 'i4': 'tcg_gen_neg_tl', 'B': 'aflag', 'b': 'nb_mmco'}",MHM-Origin,392,0.36154890855153404
340,"static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,

        unsigned size)

{

    GemState *s = (GemState *)opaque;

    uint32_t readonly;



    DB_PRINT(""offset: 0x%04x write: 0x%08x "", offset, (unsigned)val);

    offset >>= 2;



    /* Squash bits which are read only in write value */

    val &= ~(s->regs_ro[offset]);

    /* Preserve (only) bits which are read only in register */

    readonly = s->regs[offset];

    readonly &= s->regs_ro[offset];



    /* Squash bits which are write 1 to clear */

    val &= ~(s->regs_w1c[offset] & val);



    /* Copy register write to backing store */

    s->regs[offset] = val | readonly;



    /* Handle register write side effects */

    switch (offset) {

    case GEM_NWCTRL:

        if (val & GEM_NWCTRL_TXSTART) {

            gem_transmit(s);

        }

        if (!(val & GEM_NWCTRL_TXENA)) {

            /* Reset to start of Q when transmit disabled. */

            s->tx_desc_addr = s->regs[GEM_TXQBASE];

        }

        if (!(val & GEM_NWCTRL_RXENA)) {

            /* Reset to start of Q when receive disabled. */

            s->rx_desc_addr = s->regs[GEM_RXQBASE];

        }

        break;



    case GEM_TXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_RXQBASE:

        s->rx_desc_addr = val;

        break;

    case GEM_TXQBASE:

        s->tx_desc_addr = val;

        break;

    case GEM_RXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_IER:

        s->regs[GEM_IMR] &= ~val;

        gem_update_int_status(s);

        break;

    case GEM_IDR:

        s->regs[GEM_IMR] |= val;

        gem_update_int_status(s);

        break;

    case GEM_PHYMNTNC:

        if (val & GEM_PHYMNTNC_OP_W) {

            uint32_t phy_addr, reg_num;



            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;

            if (phy_addr == BOARD_PHY_ADDRESS) {

                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;

                gem_phy_write(s, reg_num, val);

            }

        }

        break;

    }



    DB_PRINT(""newval: 0x%08x\n"", s->regs[offset]);

}
",323,"static void gem_write(void *opaque, target_phys_addr_t dsp, uint64_t pxa2xx_i2c_init,

        unsigned MAX_RING_ORDER)

{

    GemState *s = (GemState *)opaque;

    uint32_t POWER9;



    DB_PRINT(""offset: 0x%04x write: 0x%08x "", dsp, (unsigned)pxa2xx_i2c_init);

    dsp >>= 2;



    /* Squash bits which are read only in write value */

    pxa2xx_i2c_init &= ~(s->regs_ro[dsp]);

    /* Preserve (only) bits which are read only in register */

    POWER9 = s->regs[dsp];

    POWER9 &= s->regs_ro[dsp];



    /* Squash bits which are write 1 to clear */

    pxa2xx_i2c_init &= ~(s->regs_w1c[dsp] & pxa2xx_i2c_init);



    /* Copy register write to backing store */

    s->regs[dsp] = pxa2xx_i2c_init | POWER9;



    /* Handle register write side effects */

    switch (dsp) {

    case GEM_NWCTRL:

        if (pxa2xx_i2c_init & GEM_NWCTRL_TXSTART) {

            gem_transmit(s);

        }

        if (!(pxa2xx_i2c_init & GEM_NWCTRL_TXENA)) {

            /* Reset to start of Q when transmit disabled. */

            s->tx_desc_addr = s->regs[GEM_TXQBASE];

        }

        if (!(pxa2xx_i2c_init & GEM_NWCTRL_RXENA)) {

            /* Reset to start of Q when receive disabled. */

            s->rx_desc_addr = s->regs[GEM_RXQBASE];

        }

        break;



    case GEM_TXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_RXQBASE:

        s->rx_desc_addr = pxa2xx_i2c_init;

        break;

    case GEM_TXQBASE:

        s->tx_desc_addr = pxa2xx_i2c_init;

        break;

    case GEM_RXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_IER:

        s->regs[GEM_IMR] &= ~pxa2xx_i2c_init;

        gem_update_int_status(s);

        break;

    case GEM_IDR:

        s->regs[GEM_IMR] |= pxa2xx_i2c_init;

        gem_update_int_status(s);

        break;

    case GEM_PHYMNTNC:

        if (pxa2xx_i2c_init & GEM_PHYMNTNC_OP_W) {

            uint32_t PVR2_USE_PCMP_INSTR, reg_num;



            PVR2_USE_PCMP_INSTR = (pxa2xx_i2c_init & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;

            if (PVR2_USE_PCMP_INSTR == BOARD_PHY_ADDRESS) {

                reg_num = (pxa2xx_i2c_init & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;

                gem_phy_write(s, reg_num, pxa2xx_i2c_init);

            }

        }

        break;

    }



    DB_PRINT(""newval: 0x%08x
"", s->regs[dsp]);

}
",0,0,1,1,offset,0.3233942985534668,5,35,"{'offset': 'dsp', 'val': 'pxa2xx_i2c_init', 'phy_addr': 'PVR2_USE_PCMP_INSTR', 'readonly': 'POWER9', 'size': 'MAX_RING_ORDER'}",MHM-Origin,139,0.06681600411732992
341,"void cpu_loop(CPUMIPSState *env)

{

    target_siginfo_t info;

    int trapnr, ret;

    unsigned int syscall_num;



    for(;;) {

        trapnr = cpu_mips_exec(env);

        switch(trapnr) {

        case EXCP_SYSCALL:

            syscall_num = env->active_tc.gpr[2] - 4000;

            env->active_tc.PC += 4;

            if (syscall_num >= sizeof(mips_syscall_args)) {

                ret = -ENOSYS;

            } else {

                int nb_args;

                abi_ulong sp_reg;

                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;



                nb_args = mips_syscall_args[syscall_num];

                sp_reg = env->active_tc.gpr[29];

                switch (nb_args) {

                /* these arguments are taken from the stack */

                /* FIXME - what to do if get_user() fails? */

                case 8: get_user_ual(arg8, sp_reg + 28);

                case 7: get_user_ual(arg7, sp_reg + 24);

                case 6: get_user_ual(arg6, sp_reg + 20);

                case 5: get_user_ual(arg5, sp_reg + 16);

                default:



                ret = do_syscall(env, env->active_tc.gpr[2],

                                 env->active_tc.gpr[4],

                                 env->active_tc.gpr[5],

                                 env->active_tc.gpr[6],

                                 env->active_tc.gpr[7],

                                 arg5, arg6/*, arg7, arg8*/);







            if ((unsigned int)ret >= (unsigned int)(-1133)) {

                env->active_tc.gpr[7] = 1; /* error flag */

                ret = -ret;

            } else {

                env->active_tc.gpr[7] = 0; /* error flag */


            env->active_tc.gpr[2] = ret;


        case EXCP_TLBL:

        case EXCP_TLBS:

            info.si_signo = TARGET_SIGSEGV;

            info.si_errno = 0;

            /* XXX: check env->error_code */

            info.si_code = TARGET_SEGV_MAPERR;

            info._sifields._sigfault._addr = env->CP0_BadVAddr;

            queue_signal(env, info.si_signo, &info);


        case EXCP_CpU:

        case EXCP_RI:

            info.si_signo = TARGET_SIGILL;

            info.si_errno = 0;

            info.si_code = 0;

            queue_signal(env, info.si_signo, &info);


        case EXCP_INTERRUPT:

            /* just indicate that signals should be handled asap */


        case EXCP_DEBUG:

            {

                int sig;



                sig = gdb_handlesig (env, TARGET_SIGTRAP);

                if (sig)

                  {

                    info.si_signo = sig;

                    info.si_errno = 0;

                    info.si_code = TARGET_TRAP_BRKPT;

                    queue_signal(env, info.si_signo, &info);




        default:

            //        error:

            fprintf(stderr, ""qemu: unhandled CPU exception 0x%x - aborting\n"",

                    trapnr);

            cpu_dump_state(env, stderr, fprintf, 0);

            abort();


        process_pending_signals(env);

",461,"void cpu_loop(CPUMIPSState *env)

{

    target_siginfo_t PCI_BRIDGE_CTL_DISCARD;

    int trapnr, tcg_gen_muls2_i64;

    unsigned int syscall_num;



    for(;;) {

        trapnr = cpu_mips_exec(env);

        switch(trapnr) {

        case EXCP_SYSCALL:

            syscall_num = env->active_tc.gpr[2] - 4000;

            env->active_tc.PC += 4;

            if (syscall_num >= sizeof(mips_syscall_args)) {

                tcg_gen_muls2_i64 = -ENOSYS;

            } else {

                int nb_args;

                abi_ulong sp_reg;

                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;



                nb_args = mips_syscall_args[syscall_num];

                sp_reg = env->active_tc.gpr[29];

                switch (nb_args) {

                /* these arguments are taken from the stack */

                /* FIXME - what to do if get_user() fails? */

                case 8: get_user_ual(arg8, sp_reg + 28);

                case 7: get_user_ual(arg7, sp_reg + 24);

                case 6: get_user_ual(arg6, sp_reg + 20);

                case 5: get_user_ual(arg5, sp_reg + 16);

                default:



                tcg_gen_muls2_i64 = do_syscall(env, env->active_tc.gpr[2],

                                 env->active_tc.gpr[4],

                                 env->active_tc.gpr[5],

                                 env->active_tc.gpr[6],

                                 env->active_tc.gpr[7],

                                 arg5, arg6/*, arg7, arg8*/);







            if ((unsigned int)tcg_gen_muls2_i64 >= (unsigned int)(-1133)) {

                env->active_tc.gpr[7] = 1; /* error flag */

                tcg_gen_muls2_i64 = -tcg_gen_muls2_i64;

            } else {

                env->active_tc.gpr[7] = 0; /* error flag */


            env->active_tc.gpr[2] = tcg_gen_muls2_i64;


        case EXCP_TLBL:

        case EXCP_TLBS:

            PCI_BRIDGE_CTL_DISCARD.si_signo = TARGET_SIGSEGV;

            PCI_BRIDGE_CTL_DISCARD.si_errno = 0;

            /* XXX: check env->error_code */

            PCI_BRIDGE_CTL_DISCARD.si_code = TARGET_SEGV_MAPERR;

            PCI_BRIDGE_CTL_DISCARD._sifields._sigfault._addr = env->CP0_BadVAddr;

            queue_signal(env, PCI_BRIDGE_CTL_DISCARD.si_signo, &PCI_BRIDGE_CTL_DISCARD);


        case EXCP_CpU:

        case EXCP_RI:

            PCI_BRIDGE_CTL_DISCARD.si_signo = TARGET_SIGILL;

            PCI_BRIDGE_CTL_DISCARD.si_errno = 0;

            PCI_BRIDGE_CTL_DISCARD.si_code = 0;

            queue_signal(env, PCI_BRIDGE_CTL_DISCARD.si_signo, &PCI_BRIDGE_CTL_DISCARD);


        case EXCP_INTERRUPT:

            /* just indicate that signals should be handled asap */


        case EXCP_DEBUG:

            {

                int sig;



                sig = gdb_handlesig (env, TARGET_SIGTRAP);

                if (sig)

                  {

                    PCI_BRIDGE_CTL_DISCARD.si_signo = sig;

                    PCI_BRIDGE_CTL_DISCARD.si_errno = 0;

                    PCI_BRIDGE_CTL_DISCARD.si_code = TARGET_TRAP_BRKPT;

                    queue_signal(env, PCI_BRIDGE_CTL_DISCARD.si_signo, &PCI_BRIDGE_CTL_DISCARD);




        default:

            //        error:

            fprintf(stderr, ""qemu: unhandled CPU exception 0x%x - aborting
"",

                    trapnr);

            cpu_dump_state(env, stderr, fprintf, 0);

            abort();


        process_pending_signals(env);

",1,1,0,1,info,-0.7736643552780151,2,24,"{'ret': 'tcg_gen_muls2_i64', 'info': 'PCI_BRIDGE_CTL_DISCARD'}",MHM-Origin,38,0.01842798391977946
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
",77,"static int tmv_read_seek(AVFormatContext *ASSIGN_VSCALE_FUNC, int stream_index,

                         int64_t qemu_opts_set_id, int bdrv_unref)

{

    TMVContext *qp_histogram = ASSIGN_VSCALE_FUNC->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = qemu_opts_set_id *

          (qp_histogram->audio_chunk_size + qp_histogram->video_chunk_size + qp_histogram->padding);



    avio_seek(ASSIGN_VSCALE_FUNC->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    qp_histogram->stream_index = 0;

    return 0;

}
",1,1,0,1,flags,-0.6339768618345261,4,11,"{'tmv': 'qp_histogram', 'timestamp': 'qemu_opts_set_id', 's': 'ASSIGN_VSCALE_FUNC', 'flags': 'bdrv_unref'}",MHM-Origin,120,0.048360133171081544
343,"static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = opaque;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;",50,"static void bonito_ldma_writel(void *LMI_HELPER, hwaddr IN_START,
                               uint64_t channel_layout_thd_stream2, unsigned size)
{
    PCIBonitoState *get_async_context_id = LMI_HELPER;
    ((uint32_t *)(&get_async_context_id->bonldma))[IN_START/sizeof(uint32_t)] = channel_layout_thd_stream2 & 0xffffffff;",1,1,0,1,val,-0.6671010255813599,4,8,"{'opaque': 'LMI_HELPER', 'val': 'channel_layout_thd_stream2', 'addr': 'IN_START', 's': 'get_async_context_id'}",MHM-Origin,333,0.13907346725463868
344,"static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,

                                  Jpeg2000CodingStyle *codsty,

                                  Jpeg2000ResLevel *rlevel, int precno,

                                  int layno, uint8_t *expn, int numgbits)

{

    int bandno, cblkno, ret, nb_code_blocks;

    int cwsno;



    if (layno < rlevel->band[0].prec[precno].decoded_layers)

        return 0;

    rlevel->band[0].prec[precno].decoded_layers = layno + 1;



    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {

        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {

            s->g = tile->tile_part[++(*tp_index)].tpg;

        }

    }



    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)

        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);



    if (!(ret = get_bits(s, 1))) {

        jpeg2000_flush(s);

        return 0;

    } else if (ret < 0)

        return ret;



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        if (band->coord[0][0] == band->coord[0][1] ||

            band->coord[1][0] == band->coord[1][1])

            continue;

        nb_code_blocks =  prec->nb_codeblocks_height *

                          prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            int incl, newpasses, llen;



            if (cblk->npasses)

                incl = get_bits(s, 1);

            else

                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;

            if (!incl)

                continue;

            else if (incl < 0)

                return incl;



            if (!cblk->npasses) {

                int v = expn[bandno] + numgbits - 1 -

                        tag_tree_decode(s, prec->zerobits + cblkno, 100);

                if (v < 0 || v > 30) {

                    av_log(s->avctx, AV_LOG_ERROR,

                           ""nonzerobits %d invalid or unsupported\n"", v);

                    return AVERROR_INVALIDDATA;

                }

                cblk->nonzerobits = v;

            }

            if ((newpasses = getnpasses(s)) < 0)

                return newpasses;

            av_assert2(newpasses > 0);

            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {

                avpriv_request_sample(s->avctx, ""Too many passes"");

                return AVERROR_PATCHWELCOME;

            }

            if ((llen = getlblockinc(s)) < 0)

                return llen;

            if (cblk->lblock + llen + av_log2(newpasses) > 16) {

                avpriv_request_sample(s->avctx,

                                      ""Block with length beyond 16 bits"");

                return AVERROR_PATCHWELCOME;

            }



            cblk->lblock += llen;



            cblk->nb_lengthinc = 0;

            cblk->nb_terminationsinc = 0;

            do {

                int newpasses1 = 0;



                while (newpasses1 < newpasses) {

                    newpasses1 ++;

                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {

                        cblk->nb_terminationsinc ++;

                        break;

                    }

                }



                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)

                    return ret;

                if (ret > sizeof(cblk->data)) {

                    avpriv_request_sample(s->avctx,

                                        ""Block with lengthinc greater than %""SIZE_SPECIFIER"""",

                                        sizeof(cblk->data));

                    return AVERROR_PATCHWELCOME;

                }

                cblk->lengthinc[cblk->nb_lengthinc++] = ret;

                cblk->npasses  += newpasses1;

                newpasses -= newpasses1;

            } while(newpasses);

        }

    }

    jpeg2000_flush(s);



    if (codsty->csty & JPEG2000_CSTY_EPH) {

        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)

            bytestream2_skip(&s->g, 2);

        else

            av_log(s->avctx, AV_LOG_ERROR, ""EPH marker not found. instead %X\n"", bytestream2_peek_be32(&s->g));

    }



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {

                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]

                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4

                ) {

                    av_log(s->avctx, AV_LOG_ERROR,

                        ""Block length %""PRIu16"" or lengthinc %d is too large, left %d\n"",

                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));

                    return AVERROR_INVALIDDATA;

                }



                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);

                cblk->length   += cblk->lengthinc[cwsno];

                cblk->lengthinc[cwsno] = 0;

                if (cblk->nb_terminationsinc) {

                    cblk->nb_terminationsinc--;

                    cblk->nb_terminations++;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data_start[cblk->nb_terminations] = cblk->length;

                }

            }

        }

    }

    return 0;

}
",1019,"static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *blocks_clusters, int *new_pkt,

                                  Jpeg2000CodingStyle *cbs_h265_replace_sps,

                                  Jpeg2000ResLevel *audio_kbitrate, int precno,

                                  int layno, uint8_t *gpad_keycode, int numgbits)

{

    int bandno, cblkno, init_vlc_rl, rtce;

    int raw_aio_pool;



    if (layno < audio_kbitrate->band[0].prec[precno].decoded_layers)

        return 0;

    audio_kbitrate->band[0].prec[precno].decoded_layers = layno + 1;



    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {

        if (*new_pkt < FF_ARRAY_ELEMS(blocks_clusters->tile_part) - 1) {

            s->g = blocks_clusters->tile_part[++(*new_pkt)].tpg;

        }

    }



    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)

        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);



    if (!(init_vlc_rl = get_bits(s, 1))) {

        jpeg2000_flush(s);

        return 0;

    } else if (init_vlc_rl < 0)

        return init_vlc_rl;



    for (bandno = 0; bandno < audio_kbitrate->nbands; bandno++) {

        Jpeg2000Band *band = audio_kbitrate->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        if (band->coord[0][0] == band->coord[0][1] ||

            band->coord[1][0] == band->coord[1][1])

            continue;

        rtce =  prec->nb_codeblocks_height *

                          prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < rtce; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            int incl, high, llen;



            if (cblk->npasses)

                incl = get_bits(s, 1);

            else

                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;

            if (!incl)

                continue;

            else if (incl < 0)

                return incl;



            if (!cblk->npasses) {

                int v = gpad_keycode[bandno] + numgbits - 1 -

                        tag_tree_decode(s, prec->zerobits + cblkno, 100);

                if (v < 0 || v > 30) {

                    av_log(s->avctx, AV_LOG_ERROR,

                           ""nonzerobits %d invalid or unsupported
"", v);

                    return AVERROR_INVALIDDATA;

                }

                cblk->nonzerobits = v;

            }

            if ((high = getnpasses(s)) < 0)

                return high;

            av_assert2(high > 0);

            if (cblk->npasses + high >= JPEG2000_MAX_PASSES) {

                avpriv_request_sample(s->avctx, ""Too many passes"");

                return AVERROR_PATCHWELCOME;

            }

            if ((llen = getlblockinc(s)) < 0)

                return llen;

            if (cblk->lblock + llen + av_log2(high) > 16) {

                avpriv_request_sample(s->avctx,

                                      ""Block with length beyond 16 bits"");

                return AVERROR_PATCHWELCOME;

            }



            cblk->lblock += llen;



            cblk->nb_lengthinc = 0;

            cblk->nb_terminationsinc = 0;

            do {

                int newpasses1 = 0;



                while (newpasses1 < high) {

                    newpasses1 ++;

                    if (needs_termination(cbs_h265_replace_sps->cblk_style, cblk->npasses + newpasses1 - 1)) {

                        cblk->nb_terminationsinc ++;

                        break;

                    }

                }



                if ((init_vlc_rl = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)

                    return init_vlc_rl;

                if (init_vlc_rl > sizeof(cblk->data)) {

                    avpriv_request_sample(s->avctx,

                                        ""Block with lengthinc greater than %""SIZE_SPECIFIER"""",

                                        sizeof(cblk->data));

                    return AVERROR_PATCHWELCOME;

                }

                cblk->lengthinc[cblk->nb_lengthinc++] = init_vlc_rl;

                cblk->npasses  += newpasses1;

                high -= newpasses1;

            } while(high);

        }

    }

    jpeg2000_flush(s);



    if (cbs_h265_replace_sps->csty & JPEG2000_CSTY_EPH) {

        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)

            bytestream2_skip(&s->g, 2);

        else

            av_log(s->avctx, AV_LOG_ERROR, ""EPH marker not found. instead %X
"", bytestream2_peek_be32(&s->g));

    }



    for (bandno = 0; bandno < audio_kbitrate->nbands; bandno++) {

        Jpeg2000Band *band = audio_kbitrate->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        rtce = prec->nb_codeblocks_height * prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < rtce; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            for (raw_aio_pool = 0; raw_aio_pool < cblk->nb_lengthinc; raw_aio_pool ++) {

                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[raw_aio_pool]

                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[raw_aio_pool] + 4

                ) {

                    av_log(s->avctx, AV_LOG_ERROR,

                        ""Block length %""PRIu16"" or lengthinc %d is too large, left %d
"",

                        cblk->length, cblk->lengthinc[raw_aio_pool], bytestream2_get_bytes_left(&s->g));

                    return AVERROR_INVALIDDATA;

                }



                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[raw_aio_pool]);

                cblk->length   += cblk->lengthinc[raw_aio_pool];

                cblk->lengthinc[raw_aio_pool] = 0;

                if (cblk->nb_terminationsinc) {

                    cblk->nb_terminationsinc--;

                    cblk->pci_bus++;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data_start[cblk->pci_bus] = cblk->length;

                }

            }

        }

    }

    return 0;

}
",1,1,0,1,codsty,-0.09817424416542053,10,52,"{'ret': 'init_vlc_rl', 'tile': 'blocks_clusters', 'nb_code_blocks': 'rtce', 'rlevel': 'audio_kbitrate', 'expn': 'gpad_keycode', 'nb_terminations': 'pci_bus', 'tp_index': 'new_pkt', 'cwsno': 'raw_aio_pool', 'newpasses': 'high', 'codsty': 'cbs_h265_replace_sps'}",MHM-Origin,213,0.11438968578974405
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",75,"static int64_t read_ts(char **num_slaves, int *cbs_h265_read_slice_segment_header)

{

    int64_t hChrFilter, gen_op_mov_reg_v;



    if (sscanf(*num_slaves, ""%""SCNd64"",%""SCNd64, &hChrFilter, &gen_op_mov_reg_v) == 2) {

        *num_slaves += strcspn(*num_slaves, ""\"""") + 1;

        *cbs_h265_read_slice_segment_header = gen_op_mov_reg_v - hChrFilter;

        return hChrFilter;

    }

    return AV_NOPTS_VALUE;

}
",1,1,0,1,duration,-0.8949173465371132,4,13,"{'end': 'gen_op_mov_reg_v', 'duration': 'cbs_h265_read_slice_segment_header', 'start': 'hChrFilter', 'line': 'num_slaves'}",MHM-Origin,180,0.07130225499471028
347,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",83,"static void raven_class_init(ObjectClass *klass, void *opt_xfer_len)

{

    PCIDeviceClass *parallel_io = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    parallel_io->init = raven_init;

    parallel_io->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    parallel_io->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    parallel_io->revision = 0x00;

    parallel_io->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",1,1,0,1,data,-0.9144036769866943,2,7,"{'data': 'opt_xfer_len', 'k': 'parallel_io'}",MHM-Origin,62,0.023981769879659016
350,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)

{

    char *path = NULL, *buf = NULL, *host = NULL;



    /* Get the PCI VFIO host id */

    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);

    if (!host) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);

    g_free(host);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(path);



    /* Construct and read from host device tree the loc-code */

    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(path);

    return NULL;

}
",153,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)

{

    char *qstring_new = NULL, *buf = NULL, *vsrc = NULL;



    /* Get the PCI VFIO host id */

    vsrc = object_property_get_str(OBJECT(pdev), ""vsrc"", NULL);

    if (!vsrc) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    qstring_new = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", vsrc);

    g_free(vsrc);

    if (!qstring_new || !g_file_get_contents(qstring_new, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(qstring_new);



    /* Construct and read from host device tree the loc-code */

    qstring_new = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!qstring_new || !g_file_get_contents(qstring_new, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(qstring_new);

    return NULL;

}
",1,1,0,1,path,-0.32756248116493225,2,15,"{'host': 'vsrc', 'path': 'qstring_new'}",MHM-Origin,63,0.025103819370269776
351,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)

{

    //FIXME Optimize (just quickly writen not opti..)

    int i;

    for (i=0; i<dstW; i++)

    {

        int val=1<<18;

        int j;

        for (j=0; j<lumFilterSize; j++)

            val += lumSrc[j][i] * lumFilter[j];



        dest[i]= av_clip_uint8(val>>19);

    }



    if (!uDest)

        return;



    if (dstFormat == PIX_FMT_NV12)

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(u>>19);

            uDest[2*i+1]= av_clip_uint8(v>>19);

        }

    else

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(v>>19);

            uDest[2*i+1]= av_clip_uint8(u>>19);

        }

}
",348,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **tcg_out_tlb_read, int lumFilterSize,

                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)

{

    //FIXME Optimize (just quickly writen not opti..)

    int i;

    for (i=0; i<dstW; i++)

    {

        int val=1<<18;

        int j;

        for (j=0; j<lumFilterSize; j++)

            val += tcg_out_tlb_read[j][i] * lumFilter[j];



        dest[i]= av_clip_uint8(val>>19);

    }



    if (!uDest)

        return;



    if (dstFormat == PIX_FMT_NV12)

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(u>>19);

            uDest[2*i+1]= av_clip_uint8(v>>19);

        }

    else

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(v>>19);

            uDest[2*i+1]= av_clip_uint8(u>>19);

        }

}
",1,1,0,1,lumSrc,-0.6654276251792908,1,2,{'lumSrc': 'tcg_out_tlb_read'},MHM-Origin,20,0.008857142925262452
352,"static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)

{

    uint32_t qid;



    if (addr & ((1 << 2) - 1)) {

        return;

    }



    if (((addr - 0x1000) >> 2) & 1) {

        uint16_t new_head = val & 0xffff;

        int start_sqs;

        NvmeCQueue *cq;



        qid = (addr - (0x1000 + (1 << 2))) >> 3;

        if (nvme_check_cqid(n, qid)) {

            return;

        }



        cq = n->cq[qid];

        if (new_head >= cq->size) {

            return;

        }



        start_sqs = nvme_cq_full(cq) ? 1 : 0;

        cq->head = new_head;

        if (start_sqs) {

            NvmeSQueue *sq;

            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {

                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

            }

            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

        }



        if (cq->tail != cq->head) {

            nvme_isr_notify(n, cq);

        }

    } else {

        uint16_t new_tail = val & 0xffff;

        NvmeSQueue *sq;



        qid = (addr - 0x1000) >> 3;

        if (nvme_check_sqid(n, qid)) {

            return;

        }



        sq = n->sq[qid];

        if (new_tail >= sq->size) {

            return;

        }



        sq->tail = new_tail;

        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

    }

}
",285,"static void nvme_process_db(NvmeCtrl *xy8, hwaddr nb_streams, int tcg_gen_shr_i64)

{

    uint32_t qid;



    if (nb_streams & ((1 << 2) - 1)) {

        return;

    }



    if (((nb_streams - 0x1000) >> 2) & 1) {

        uint16_t new_head = tcg_gen_shr_i64 & 0xffff;

        int start_sqs;

        NvmeCQueue *predictor_coef_table;



        qid = (nb_streams - (0x1000 + (1 << 2))) >> 3;

        if (nvme_check_cqid(xy8, qid)) {

            return;

        }



        predictor_coef_table = xy8->predictor_coef_table[qid];

        if (new_head >= predictor_coef_table->size) {

            return;

        }



        start_sqs = nvme_cq_full(predictor_coef_table) ? 1 : 0;

        predictor_coef_table->head = new_head;

        if (start_sqs) {

            NvmeSQueue *filterPos;

            QTAILQ_FOREACH(filterPos, &predictor_coef_table->sq_list, entry) {

                timer_mod(filterPos->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

            }

            timer_mod(predictor_coef_table->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

        }



        if (predictor_coef_table->tail != predictor_coef_table->head) {

            nvme_isr_notify(xy8, predictor_coef_table);

        }

    } else {

        uint16_t new_tail = tcg_gen_shr_i64 & 0xffff;

        NvmeSQueue *filterPos;



        qid = (nb_streams - 0x1000) >> 3;

        if (nvme_check_sqid(xy8, qid)) {

            return;

        }



        filterPos = xy8->filterPos[qid];

        if (new_tail >= filterPos->size) {

            return;

        }



        filterPos->tail = new_tail;

        timer_mod(filterPos->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

    }

}
",1,1,0,1,n,-0.29668429493904114,5,34,"{'val': 'tcg_gen_shr_i64', 'n': 'xy8', 'addr': 'nb_streams', 'cq': 'predictor_coef_table', 'sq': 'filterPos'}",MHM-Origin,121,0.05192420482635498
353,"static av_cold void build_modpred(Indeo3DecodeContext *s)

{

  int i, j;



  s->ModPred = av_malloc(8 * 128);



  for (i=0; i < 128; ++i) {

    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));

    s->ModPred[i+1*128] = i ==   7 ?  20 :

                          i == 119 ||

                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));

    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));

    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));

    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));

    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));

    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));

    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));

  }



  s->corrector_type = av_malloc(24 * 256);



  for (i=0; i < 24; ++i) {

    for (j=0; j < 256; ++j) {

      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :

                                   j < 248 || (i == 16 && j == 248) ? 0 :

                                   corrector_type_2[j - 248];

    }

  }

}
",398,"static av_cold void build_modpred(Indeo3DecodeContext *s)

{

  int get_user_ual, j;



  s->ModPred = av_malloc(8 * 128);



  for (get_user_ual=0; get_user_ual < 128; ++get_user_ual) {

    s->ModPred[get_user_ual+0*128] = get_user_ual >  126 ? 254 : 2*(get_user_ual + 1 - ((get_user_ual + 1) % 2));

    s->ModPred[get_user_ual+1*128] = get_user_ual ==   7 ?  20 :

                          get_user_ual == 119 ||

                          get_user_ual == 120 ? 236 : 2*(get_user_ual + 2 - ((get_user_ual + 1) % 3));

    s->ModPred[get_user_ual+2*128] = get_user_ual >  125 ? 248 : 2*(get_user_ual + 2 - ((get_user_ual + 2) % 4));

    s->ModPred[get_user_ual+3*128] =                  2*(get_user_ual + 1 - ((get_user_ual - 3) % 5));

    s->ModPred[get_user_ual+4*128] = get_user_ual ==   8 ?  20 : 2*(get_user_ual + 1 - ((get_user_ual - 3) % 6));

    s->ModPred[get_user_ual+5*128] =                  2*(get_user_ual + 4 - ((get_user_ual + 3) % 7));

    s->ModPred[get_user_ual+6*128] = get_user_ual >  123 ? 240 : 2*(get_user_ual + 4 - ((get_user_ual + 4) % 8));

    s->ModPred[get_user_ual+7*128] =                  2*(get_user_ual + 5 - ((get_user_ual + 4) % 9));

  }



  s->corrector_type = av_malloc(24 * 256);



  for (get_user_ual=0; get_user_ual < 24; ++get_user_ual) {

    for (j=0; j < 256; ++j) {

      s->corrector_type[get_user_ual*256+j] = j < corrector_type_0[get_user_ual]          ? 1 :

                                   j < 248 || (get_user_ual == 16 && j == 248) ? 0 :

                                   corrector_type_2[j - 248];

    }

  }

}
",0,0,1,1,i,0.5607045739889145,1,41,{'i': 'get_user_ual'},MHM-Origin,22,0.009125153223673502
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",75,"static void gen_storeq_reg(DisasContext *s, int rlow, int blk_insert_bs, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, blk_insert_bs, tmp);

}
",1,1,0,1,rhigh,-0.8469134792685509,1,2,{'rhigh': 'blk_insert_bs'},MHM-Origin,20,0.00797491470972697
356,"static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)

{

    int16_t icoef;

    int recent = s->cdlms[ich][ilms].recent;

    int16_t range = 1 << (s->bits_per_sample - 1);

    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample



    if (input > pred) {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] +=

                s->cdlms[ich][ilms].lms_updates[icoef + recent];

    } else {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] -=

                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?

    }

    s->cdlms[ich][ilms].recent--;

    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);



    if (input > pred)

        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];

    else if (input < pred)

        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];



    /* XXX: spec says:

    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;

    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;



        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two

        seperate buffers? Here I've assumed that the two are same which makes

        more sense to me.

    */

    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;

    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;

    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */



    if (s->cdlms[ich][ilms].recent == 0) {

        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.

                follow kshishkov's suggestion of using a union. */

        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,

               s->cdlms[ich][ilms].lms_prevvalues,

               bps * s->cdlms[ich][ilms].order);

        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,

               s->cdlms[ich][ilms].lms_updates,

               bps * s->cdlms[ich][ilms].order);

        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;

    }

}
",493,"static void lms_update(WmallDecodeCtx *tick_irq, int MATROSKA_ID_DURATION, int ilms, int16_t input, int16_t setup_state)

{

    int16_t icoef;

    int tcg_gen_deposit_i64 = tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].tcg_gen_deposit_i64;

    int16_t range = 1 << (tick_irq->bits_per_sample - 1);

    int bps = tick_irq->bits_per_sample > 16 ? 4 : 2; // bytes per sample



    if (input > setup_state) {

        for (icoef = 0; icoef < tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].order; icoef++)

            tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].coefs[icoef] +=

                tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_updates[icoef + tcg_gen_deposit_i64];

    } else {

        for (icoef = 0; icoef < tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].order; icoef++)

            tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].coefs[icoef] -=

                tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?

    }

    tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].tcg_gen_deposit_i64--;

    tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_prevvalues[tcg_gen_deposit_i64] = av_clip(input, -range, range - 1);



    if (input > setup_state)

        tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_updates[tcg_gen_deposit_i64] = tick_irq->update_speed[MATROSKA_ID_DURATION];

    else if (input < setup_state)

        tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_updates[tcg_gen_deposit_i64] = -tick_irq->update_speed[MATROSKA_ID_DURATION];



    /* XXX: spec says:

    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;

    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;



        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two

        seperate buffers? Here I've assumed that the two are same which makes

        more sense to me.

    */

    tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_updates[tcg_gen_deposit_i64 + tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].order >> 4] >>= 2;

    tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_updates[tcg_gen_deposit_i64 + tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].order >> 3] >>= 1;

    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */



    if (tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].tcg_gen_deposit_i64 == 0) {

        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.

                follow kshishkov's suggestion of using a union. */

        memcpy(tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_prevvalues + tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].order,

               tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_prevvalues,

               bps * tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].order);

        memcpy(tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_updates + tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].order,

               tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].lms_updates,

               bps * tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].order);

        tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].tcg_gen_deposit_i64 = tick_irq->cdlms[MATROSKA_ID_DURATION][ilms].order;

    }

}
",1,1,0,1,recent,-0.10843372344970703,4,75,"{'pred': 'setup_state', 'ich': 'MATROSKA_ID_DURATION', 'recent': 'tcg_gen_deposit_i64', 's': 'tick_irq'}",MHM-Origin,97,0.04800140857696533
358,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
",223,"static void decode_mclms(WmallDecodeCtx *APB_SPECIAL_BASE)

{

    APB_SPECIAL_BASE->mclms_order = (get_bits(&APB_SPECIAL_BASE->gb, 4) + 1) * 2;

    APB_SPECIAL_BASE->mclms_scaling = get_bits(&APB_SPECIAL_BASE->gb, 4);

    if(get_bits1(&APB_SPECIAL_BASE->gb)) {

	// mclms_send_coef

	int q0_org_r;

	int mtime_fail;

	int buf_size2 = av_log2(APB_SPECIAL_BASE->mclms_scaling + 1);

	assert(buf_size2 == my_log2(APB_SPECIAL_BASE->mclms_scaling + 1));

	if(1 << buf_size2 < APB_SPECIAL_BASE->mclms_scaling + 1)

	    buf_size2++;



	mtime_fail = (buf_size2 ? get_bits(&APB_SPECIAL_BASE->gb, buf_size2) : 0) + 2;



	for(q0_org_r = 0; q0_org_r < APB_SPECIAL_BASE->mclms_order * APB_SPECIAL_BASE->num_channels * APB_SPECIAL_BASE->num_channels; q0_org_r++) {

	    APB_SPECIAL_BASE->mclms_coeffs[q0_org_r] = get_bits(&APB_SPECIAL_BASE->gb, mtime_fail);

	}



	for(q0_org_r = 0; q0_org_r < APB_SPECIAL_BASE->num_channels; q0_org_r++) {

	    int out0;

	    for(out0 = 0; out0 < q0_org_r; out0++) {

		APB_SPECIAL_BASE->mclms_coeffs_cur[q0_org_r * APB_SPECIAL_BASE->num_channels + out0] = get_bits(&APB_SPECIAL_BASE->gb, mtime_fail);

	    }

	}

    }

}
",1,1,1,-1,c,-0.0030528903007507324,5,44,"{'c': 'out0', 'send_coef_bits': 'mtime_fail', 's': 'APB_SPECIAL_BASE', 'cbits': 'buf_size2', 'i': 'q0_org_r'}",MHM-Origin,393,0.17547320922215778
359,"static void ppc_spapr_init(ram_addr_t ram_size,
                           const char *boot_device,
                           const char *kernel_filename,
                           const char *kernel_cmdline,
                           const char *initrd_filename,
                           const char *cpu_model)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    int i;
    MemoryRegion *sysmem = get_system_memory();
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    target_phys_addr_t rma_alloc_size, rma_size;
    uint32_t initrd_base = 0;
    long kernel_size = 0, initrd_size = 0;
    long load_limit, rtas_limit, fw_size;
    long pteg_shift = 17;
    char *filename;
    spapr = g_malloc0(sizeof(*spapr));
    QLIST_INIT(&spapr->phbs);
    cpu_ppc_hypercall = emulate_spapr_hypercall;
    /* Allocate RMA if necessary */
    rma_alloc_size = kvmppc_alloc_rma(""ppc_spapr.rma"", sysmem);
    if (rma_alloc_size == -1) {
        hw_error(""qemu: Unable to create RMA\n"");
        exit(1);
    }
    if (rma_alloc_size && (rma_alloc_size < ram_size)) {
        rma_size = rma_alloc_size;
    } else {
        rma_size = ram_size;
    }
    /* We place the device tree and RTAS just below either the top of the RMA,
     * or just below 2GB, whichever is lowere, so that it can be
     * processed with 32-bit real mode code if necessary */
    rtas_limit = MIN(rma_size, 0x80000000);
    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;
    load_limit = spapr->fdt_addr - FW_OVERHEAD;
    /* init CPUs */
    if (cpu_model == NULL) {
        cpu_model = kvm_enabled() ? ""host"" : ""POWER7"";
    }
    for (i = 0; i < smp_cpus; i++) {
        cpu = cpu_ppc_init(cpu_model);
        if (cpu == NULL) {
            fprintf(stderr, ""Unable to find PowerPC CPU definition\n"");
            exit(1);
        }
        env = &cpu->env;
        /* Set time-base frequency to 512 MHz */
        cpu_ppc_tb_init(env, TIMEBASE_FREQ);
        qemu_register_reset(spapr_cpu_reset, cpu);
        env->hreset_vector = 0x60;
        env->hreset_excp_prefix = 0;
        env->gpr[3] = env->cpu_index;
    }
    /* allocate RAM */
    spapr->ram_limit = ram_size;
    if (spapr->ram_limit > rma_alloc_size) {
        ram_addr_t nonrma_base = rma_alloc_size;
        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;
        memory_region_init_ram(ram, ""ppc_spapr.ram"", nonrma_size);
        vmstate_register_ram_global(ram);
        memory_region_add_subregion(sysmem, nonrma_base, ram);
    }
    /* allocate hash page table.  For now we always make this 16mb,
     * later we should probably make it scale to the size of guest
     * RAM */
    spapr->htab_size = 1ULL << (pteg_shift + 7);
    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->external_htab = spapr->htab;
        env->htab_base = -1;
        env->htab_mask = spapr->htab_size - 1;
        /* Tell KVM that we're in PAPR mode */
        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |
                             ((pteg_shift + 7) - 18);
        env->spr[SPR_HIOR] = 0;
        if (kvm_enabled()) {
            kvmppc_set_papr(env);
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                           rtas_limit - spapr->rtas_addr);
    if (spapr->rtas_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'\n"", filename);
        exit(1);
    }
    if (spapr->rtas_size > RTAS_MAX_SIZE) {
        hw_error(""RTAS too big ! 0x%lx bytes (max is 0x%x)\n"",
                 spapr->rtas_size, RTAS_MAX_SIZE);
        exit(1);
    }
    g_free(filename);
    /* Set up Interrupt Controller */
    spapr->icp = xics_system_init(XICS_IRQS);
    spapr->next_irq = 16;
    /* Set up VIO bus */
    spapr->vio_bus = spapr_vio_bus_init();
    for (i = 0; i < MAX_SERIAL_PORTS; i++) {
        if (serial_hds[i]) {
            spapr_vty_create(spapr->vio_bus, serial_hds[i]);
        }
    }
    /* Set up PCI */
    spapr_create_phb(spapr, ""pci"", SPAPR_PCI_BUID,
                     SPAPR_PCI_MEM_WIN_ADDR,
                     SPAPR_PCI_MEM_WIN_SIZE,
                     SPAPR_PCI_IO_WIN_ADDR);
    for (i = 0; i < nb_nics; i++) {
        NICInfo *nd = &nd_table[i];
        if (!nd->model) {
            nd->model = g_strdup(""ibmveth"");
        }
        if (strcmp(nd->model, ""ibmveth"") == 0) {
            spapr_vlan_create(spapr->vio_bus, nd);
        } else {
            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);
        }
    }
    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {
        spapr_vscsi_create(spapr->vio_bus);
    }
    if (rma_size < (MIN_RMA_SLOF << 20)) {
        fprintf(stderr, ""qemu: pSeries SLOF firmware requires >= ""
                ""%ldM guest RMA (Real Mode Area memory)\n"", MIN_RMA_SLOF);
        exit(1);
    }
    fprintf(stderr, ""sPAPR memory map:\n"");
    fprintf(stderr, ""RTAS                 : 0x%08lx..%08lx\n"",
            (unsigned long)spapr->rtas_addr,
            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));
    fprintf(stderr, ""FDT                  : 0x%08lx..%08lx\n"",
            (unsigned long)spapr->fdt_addr,
            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));
    if (kernel_filename) {
        uint64_t lowaddr = 0;
        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,
                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);
        if (kernel_size < 0) {
            kernel_size = load_image_targphys(kernel_filename,
                                              KERNEL_LOAD_ADDR,
                                              load_limit - KERNEL_LOAD_ADDR);
        }
        if (kernel_size < 0) {
            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",
                    kernel_filename);
            exit(1);
        }
        fprintf(stderr, ""Kernel               : 0x%08x..%08lx\n"",
                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);
        /* load initrd */
        if (initrd_filename) {
            /* Try to locate the initrd in the gap between the kernel
             * and the firmware. Add a bit of space just in case
             */
            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;
            initrd_size = load_image_targphys(initrd_filename, initrd_base,
                                              load_limit - initrd_base);
            if (initrd_size < 0) {
                fprintf(stderr, ""qemu: could not load initial ram disk '%s'\n"",
                        initrd_filename);
                exit(1);
            }
            fprintf(stderr, ""Ramdisk              : 0x%08lx..%08lx\n"",
                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));
        } else {
            initrd_base = 0;
            initrd_size = 0;
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (fw_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'\n"", filename);
        exit(1);
    }
    g_free(filename);
    fprintf(stderr, ""Firmware load        : 0x%08x..%08lx\n"",
            0, fw_size);
    fprintf(stderr, ""Firmware runtime     : 0x%08lx..%08lx\n"",
            load_limit, (unsigned long)spapr->fdt_addr);
    spapr->entry_point = 0x100;
    /* SLOF will startup the secondary CPUs using RTAS */
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->halted = 1;
    }
    /* Prepare the device tree */
    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,
                                            initrd_base, initrd_size,
                                            kernel_size,
                                            boot_device, kernel_cmdline,
                                            pteg_shift + 7);
    assert(spapr->fdt_skel != NULL);
    qemu_register_reset(spapr_reset, spapr);
}",1212,"static void ppc_spapr_init(ram_addr_t ram_size,
                           const char *boot_device,
                           const char *kernel_filename,
                           const char *kernel_cmdline,
                           const char *initrd_filename,
                           const char *cpu_model)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    int i;
    MemoryRegion *sysmem = get_system_memory();
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    target_phys_addr_t rma_alloc_size, it;
    uint32_t initrd_base = 0;
    long kernel_size = 0, initrd_size = 0;
    long load_limit, rtas_limit, fw_size;
    long pteg_shift = 17;
    char *filename;
    spapr = g_malloc0(sizeof(*spapr));
    QLIST_INIT(&spapr->phbs);
    cpu_ppc_hypercall = emulate_spapr_hypercall;
    /* Allocate RMA if necessary */
    rma_alloc_size = kvmppc_alloc_rma(""ppc_spapr.rma"", sysmem);
    if (rma_alloc_size == -1) {
        hw_error(""qemu: Unable to create RMA
"");
        exit(1);
    }
    if (rma_alloc_size && (rma_alloc_size < ram_size)) {
        it = rma_alloc_size;
    } else {
        it = ram_size;
    }
    /* We place the device tree and RTAS just below either the top of the RMA,
     * or just below 2GB, whichever is lowere, so that it can be
     * processed with 32-bit real mode code if necessary */
    rtas_limit = MIN(it, 0x80000000);
    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;
    load_limit = spapr->fdt_addr - FW_OVERHEAD;
    /* init CPUs */
    if (cpu_model == NULL) {
        cpu_model = kvm_enabled() ? ""host"" : ""POWER7"";
    }
    for (i = 0; i < smp_cpus; i++) {
        cpu = cpu_ppc_init(cpu_model);
        if (cpu == NULL) {
            fprintf(stderr, ""Unable to find PowerPC CPU definition
"");
            exit(1);
        }
        env = &cpu->env;
        /* Set time-base frequency to 512 MHz */
        cpu_ppc_tb_init(env, TIMEBASE_FREQ);
        qemu_register_reset(spapr_cpu_reset, cpu);
        env->hreset_vector = 0x60;
        env->hreset_excp_prefix = 0;
        env->gpr[3] = env->cpu_index;
    }
    /* allocate RAM */
    spapr->ram_limit = ram_size;
    if (spapr->ram_limit > rma_alloc_size) {
        ram_addr_t nonrma_base = rma_alloc_size;
        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;
        memory_region_init_ram(ram, ""ppc_spapr.ram"", nonrma_size);
        vmstate_register_ram_global(ram);
        memory_region_add_subregion(sysmem, nonrma_base, ram);
    }
    /* allocate hash page table.  For now we always make this 16mb,
     * later we should probably make it scale to the size of guest
     * RAM */
    spapr->htab_size = 1ULL << (pteg_shift + 7);
    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->external_htab = spapr->htab;
        env->htab_base = -1;
        env->htab_mask = spapr->htab_size - 1;
        /* Tell KVM that we're in PAPR mode */
        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |
                             ((pteg_shift + 7) - 18);
        env->spr[SPR_HIOR] = 0;
        if (kvm_enabled()) {
            kvmppc_set_papr(env);
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                           rtas_limit - spapr->rtas_addr);
    if (spapr->rtas_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'
"", filename);
        exit(1);
    }
    if (spapr->rtas_size > RTAS_MAX_SIZE) {
        hw_error(""RTAS too big ! 0x%lx bytes (max is 0x%x)
"",
                 spapr->rtas_size, RTAS_MAX_SIZE);
        exit(1);
    }
    g_free(filename);
    /* Set up Interrupt Controller */
    spapr->icp = xics_system_init(XICS_IRQS);
    spapr->next_irq = 16;
    /* Set up VIO bus */
    spapr->vio_bus = spapr_vio_bus_init();
    for (i = 0; i < MAX_SERIAL_PORTS; i++) {
        if (serial_hds[i]) {
            spapr_vty_create(spapr->vio_bus, serial_hds[i]);
        }
    }
    /* Set up PCI */
    spapr_create_phb(spapr, ""pci"", SPAPR_PCI_BUID,
                     SPAPR_PCI_MEM_WIN_ADDR,
                     SPAPR_PCI_MEM_WIN_SIZE,
                     SPAPR_PCI_IO_WIN_ADDR);
    for (i = 0; i < nb_nics; i++) {
        NICInfo *nd = &nd_table[i];
        if (!nd->model) {
            nd->model = g_strdup(""ibmveth"");
        }
        if (strcmp(nd->model, ""ibmveth"") == 0) {
            spapr_vlan_create(spapr->vio_bus, nd);
        } else {
            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);
        }
    }
    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {
        spapr_vscsi_create(spapr->vio_bus);
    }
    if (it < (MIN_RMA_SLOF << 20)) {
        fprintf(stderr, ""qemu: pSeries SLOF firmware requires >= ""
                ""%ldM guest RMA (Real Mode Area memory)
"", MIN_RMA_SLOF);
        exit(1);
    }
    fprintf(stderr, ""sPAPR memory map:
"");
    fprintf(stderr, ""RTAS                 : 0x%08lx..%08lx
"",
            (unsigned long)spapr->rtas_addr,
            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));
    fprintf(stderr, ""FDT                  : 0x%08lx..%08lx
"",
            (unsigned long)spapr->fdt_addr,
            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));
    if (kernel_filename) {
        uint64_t lowaddr = 0;
        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,
                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);
        if (kernel_size < 0) {
            kernel_size = load_image_targphys(kernel_filename,
                                              KERNEL_LOAD_ADDR,
                                              load_limit - KERNEL_LOAD_ADDR);
        }
        if (kernel_size < 0) {
            fprintf(stderr, ""qemu: could not load kernel '%s'
"",
                    kernel_filename);
            exit(1);
        }
        fprintf(stderr, ""Kernel               : 0x%08x..%08lx
"",
                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);
        /* load initrd */
        if (initrd_filename) {
            /* Try to locate the initrd in the gap between the kernel
             * and the firmware. Add a bit of space just in case
             */
            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;
            initrd_size = load_image_targphys(initrd_filename, initrd_base,
                                              load_limit - initrd_base);
            if (initrd_size < 0) {
                fprintf(stderr, ""qemu: could not load initial ram disk '%s'
"",
                        initrd_filename);
                exit(1);
            }
            fprintf(stderr, ""Ramdisk              : 0x%08lx..%08lx
"",
                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));
        } else {
            initrd_base = 0;
            initrd_size = 0;
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (fw_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'
"", filename);
        exit(1);
    }
    g_free(filename);
    fprintf(stderr, ""Firmware load        : 0x%08x..%08lx
"",
            0, fw_size);
    fprintf(stderr, ""Firmware runtime     : 0x%08lx..%08lx
"",
            load_limit, (unsigned long)spapr->fdt_addr);
    spapr->entry_point = 0x100;
    /* SLOF will startup the secondary CPUs using RTAS */
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->halted = 1;
    }
    /* Prepare the device tree */
    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, it,
                                            initrd_base, initrd_size,
                                            kernel_size,
                                            boot_device, kernel_cmdline,
                                            pteg_shift + 7);
    assert(spapr->fdt_skel != NULL);
    qemu_register_reset(spapr_reset, spapr);
}",1,1,0,1,rma_size,-0.07923907041549683,1,6,{'rma_size': 'it'},MHM-Origin,21,0.011954939365386963
360,"static av_cold int sonic_encode_init(AVCodecContext *avctx)

{

    SonicContext *s = avctx->priv_data;

    PutBitContext pb;

    int i, version = 0;



    if (avctx->channels > MAX_CHANNELS)

    {

        av_log(avctx, AV_LOG_ERROR, ""Only mono and stereo streams are supported by now\n"");

        return AVERROR(EINVAL); /* only stereo or mono for now */

    }



    if (avctx->channels == 2)

        s->decorrelation = MID_SIDE;

    else

        s->decorrelation = 3;



    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)

    {

        s->lossless = 1;

        s->num_taps = 32;

        s->downsampling = 1;

        s->quantization = 0.0;

    }

    else

    {

        s->num_taps = 128;

        s->downsampling = 2;

        s->quantization = 1.0;

    }



    // max tap 2048

    if ((s->num_taps < 32) || (s->num_taps > 1024) ||

        ((s->num_taps>>5)<<5 != s->num_taps))

    {

        av_log(avctx, AV_LOG_ERROR, ""Invalid number of taps\n"");

        return AVERROR_INVALIDDATA;

    }



    // generate taps

    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));

    for (i = 0; i < s->num_taps; i++)

        s->tap_quant[i] = ff_sqrt(i+1);



    s->channels = avctx->channels;

    s->samplerate = avctx->sample_rate;



    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);

    s->frame_size = s->channels*s->block_align*s->downsampling;



    s->tail_size = s->num_taps*s->channels;

    s->tail = av_calloc(s->tail_size, sizeof(*s->tail));

    if (!s->tail)

        return AVERROR(ENOMEM);



    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) );

    if (!s->predictor_k)

        return AVERROR(ENOMEM);



    for (i = 0; i < s->channels; i++)

    {

        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));

        if (!s->coded_samples[i])

            return AVERROR(ENOMEM);

    }



    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));



    s->window_size = ((2*s->tail_size)+s->frame_size);

    s->window = av_calloc(s->window_size, sizeof(*s->window));

    if (!s->window)

        return AVERROR(ENOMEM);



    avctx->extradata = av_mallocz(16);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    init_put_bits(&pb, avctx->extradata, 16*8);



    put_bits(&pb, 2, version); // version

    if (version == 1)

    {

        put_bits(&pb, 2, s->channels);

        put_bits(&pb, 4, code_samplerate(s->samplerate));

    }

    put_bits(&pb, 1, s->lossless);

    if (!s->lossless)

        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision

    put_bits(&pb, 2, s->decorrelation);

    put_bits(&pb, 2, s->downsampling);

    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024

    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table



    flush_put_bits(&pb);

    avctx->extradata_size = put_bits_count(&pb)/8;



    av_log(avctx, AV_LOG_INFO, ""Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n"",

        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);



    avctx->frame_size = s->block_align*s->downsampling;



    return 0;

}
",715,"static av_cold int sonic_encode_init(AVCodecContext *virtio_blk_handle_output)

{

    SonicContext *htab = virtio_blk_handle_output->priv_data;

    PutBitContext DIRTY_MEMORY_MIGRATION;

    int qemu_iovec_add, version = 0;



    if (virtio_blk_handle_output->channels > MAX_CHANNELS)

    {

        av_log(virtio_blk_handle_output, AV_LOG_ERROR, ""Only mono and stereo streams are supported by now
"");

        return AVERROR(EINVAL); /* only stereo or mono for now */

    }



    if (virtio_blk_handle_output->channels == 2)

        htab->decorrelation = MID_SIDE;

    else

        htab->decorrelation = 3;



    if (virtio_blk_handle_output->codec->id == AV_CODEC_ID_SONIC_LS)

    {

        htab->lossless = 1;

        htab->num_taps = 32;

        htab->downsampling = 1;

        htab->quantization = 0.0;

    }

    else

    {

        htab->num_taps = 128;

        htab->downsampling = 2;

        htab->quantization = 1.0;

    }



    // max tap 2048

    if ((htab->num_taps < 32) || (htab->num_taps > 1024) ||

        ((htab->num_taps>>5)<<5 != htab->num_taps))

    {

        av_log(virtio_blk_handle_output, AV_LOG_ERROR, ""Invalid number of taps
"");

        return AVERROR_INVALIDDATA;

    }



    // generate taps

    htab->tap_quant = av_calloc(htab->num_taps, sizeof(*htab->tap_quant));

    for (qemu_iovec_add = 0; qemu_iovec_add < htab->num_taps; qemu_iovec_add++)

        htab->tap_quant[qemu_iovec_add] = ff_sqrt(qemu_iovec_add+1);



    htab->channels = virtio_blk_handle_output->channels;

    htab->samplerate = virtio_blk_handle_output->sample_rate;



    htab->block_align = 2048LL*htab->samplerate/(44100*htab->downsampling);

    htab->frame_size = htab->channels*htab->block_align*htab->downsampling;



    htab->tail_size = htab->num_taps*htab->channels;

    htab->tail = av_calloc(htab->tail_size, sizeof(*htab->tail));

    if (!htab->tail)

        return AVERROR(ENOMEM);



    htab->predictor_k = av_calloc(htab->num_taps, sizeof(*htab->predictor_k) );

    if (!htab->predictor_k)

        return AVERROR(ENOMEM);



    for (qemu_iovec_add = 0; qemu_iovec_add < htab->channels; qemu_iovec_add++)

    {

        htab->coded_samples[qemu_iovec_add] = av_calloc(htab->block_align, sizeof(**htab->coded_samples));

        if (!htab->coded_samples[qemu_iovec_add])

            return AVERROR(ENOMEM);

    }



    htab->int_samples = av_calloc(htab->frame_size, sizeof(*htab->int_samples));



    htab->window_size = ((2*htab->tail_size)+htab->frame_size);

    htab->window = av_calloc(htab->window_size, sizeof(*htab->window));

    if (!htab->window)

        return AVERROR(ENOMEM);



    virtio_blk_handle_output->extradata = av_mallocz(16);

    if (!virtio_blk_handle_output->extradata)

        return AVERROR(ENOMEM);

    init_put_bits(&DIRTY_MEMORY_MIGRATION, virtio_blk_handle_output->extradata, 16*8);



    put_bits(&DIRTY_MEMORY_MIGRATION, 2, version); // version

    if (version == 1)

    {

        put_bits(&DIRTY_MEMORY_MIGRATION, 2, htab->channels);

        put_bits(&DIRTY_MEMORY_MIGRATION, 4, code_samplerate(htab->samplerate));

    }

    put_bits(&DIRTY_MEMORY_MIGRATION, 1, htab->lossless);

    if (!htab->lossless)

        put_bits(&DIRTY_MEMORY_MIGRATION, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision

    put_bits(&DIRTY_MEMORY_MIGRATION, 2, htab->decorrelation);

    put_bits(&DIRTY_MEMORY_MIGRATION, 2, htab->downsampling);

    put_bits(&DIRTY_MEMORY_MIGRATION, 5, (htab->num_taps >> 5)-1); // 32..1024

    put_bits(&DIRTY_MEMORY_MIGRATION, 1, 0); // XXX FIXME: no custom tap quant table



    flush_put_bits(&DIRTY_MEMORY_MIGRATION);

    virtio_blk_handle_output->extradata_size = put_bits_count(&DIRTY_MEMORY_MIGRATION)/8;



    av_log(virtio_blk_handle_output, AV_LOG_INFO, ""Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d
"",

        version, htab->lossless, htab->decorrelation, htab->num_taps, htab->block_align, htab->frame_size, htab->downsampling);



    virtio_blk_handle_output->frame_size = htab->block_align*htab->downsampling;



    return 0;

}
",0,0,1,1,pb,0.34333719313144684,4,108,"{'s': 'htab', 'i': 'qemu_iovec_add', 'pb': 'DIRTY_MEMORY_MIGRATION', 'avctx': 'virtio_blk_handle_output'}",MHM-Origin,236,0.12840291659037273
361,"int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)

{

    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };

    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };



    if (mode > 6U) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""out of range intra chroma pred mode at %d %d\n"",

               h->mb_x, h->mb_y);

        return -1;

    }



    if (!(h->top_samples_available & 0x8000)) {

        mode = top[mode];

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""top block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    if ((h->left_samples_available & 0x8080) != 0x8080) {

        mode = left[mode];

        if (is_chroma && (h->left_samples_available & 0x8080)) {

            // mad cow disease mode, aka MBAFF + constrained_intra_pred

            mode = ALZHEIMER_DC_L0T_PRED8x8 +

                   (!(h->left_samples_available & 0x8000)) +

                   2 * (mode == DC_128_PRED8x8);

        }

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""left block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    return mode;

}
",230,"int ff_h264_check_intra_pred_mode(H264Context *XenDevice, int mode, int gen_eob_worker)

{

    static const int8_t diff_pixels[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };

    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };



    if (mode > 6U) {

        av_log(XenDevice->avctx, AV_LOG_ERROR,

               ""out of range intra chroma pred mode at %d %d
"",

               XenDevice->mb_x, XenDevice->mb_y);

        return -1;

    }



    if (!(XenDevice->top_samples_available & 0x8000)) {

        mode = diff_pixels[mode];

        if (mode < 0) {

            av_log(XenDevice->avctx, AV_LOG_ERROR,

                   ""top block unavailable for requested intra mode at %d %d
"",

                   XenDevice->mb_x, XenDevice->mb_y);

            return -1;

        }

    }



    if ((XenDevice->left_samples_available & 0x8080) != 0x8080) {

        mode = left[mode];

        if (gen_eob_worker && (XenDevice->left_samples_available & 0x8080)) {

            // mad cow disease mode, aka MBAFF + constrained_intra_pred

            mode = ALZHEIMER_DC_L0T_PRED8x8 +

                   (!(XenDevice->left_samples_available & 0x8000)) +

                   2 * (mode == DC_128_PRED8x8);

        }

        if (mode < 0) {

            av_log(XenDevice->avctx, AV_LOG_ERROR,

                   ""left block unavailable for requested intra mode at %d %d
"",

                   XenDevice->mb_x, XenDevice->mb_y);

            return -1;

        }

    }



    return mode;

}
",0,0,1,1,h,0.12479886412620544,3,19,"{'top': 'diff_pixels', 'is_chroma': 'gen_eob_worker', 'h': 'XenDevice'}",MHM-Origin,223,0.10106545686721802
362,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
",167,"void audio_pcm_init_info (struct audio_pcm_info *total_size, audsettings_t *crypto+)

{

    int bits = 8, sign = 0, shift = 0;



    switch (crypto+->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    total_size->freq = crypto+->freq;

    total_size->bits = bits;

    total_size->sign = sign;

    total_size->nchannels = crypto+->nchannels;

    total_size->shift = (crypto+->nchannels == 2) + shift;

    total_size->align = (1 << total_size->shift) - 1;

    total_size->bytes_per_second = total_size->freq << total_size->shift;

    total_size->swap_endianness = (crypto+->endianness != AUDIO_HOST_ENDIANNESS);

}
",0,0,0,-1,info,0.04780421406030655,2,18,"{'info': 'total_size', 'as': 'time_base'}",MHM-Origin,393,0.17520671288172404
363,"static void block_job_completed_txn_abort(BlockJob *job)

{

    AioContext *ctx;

    BlockJobTxn *txn = job->txn;

    BlockJob *other_job, *next;



    if (txn->aborting) {

        /*

         * We are cancelled by another job, which will handle everything.

         */

        return;

    }

    txn->aborting = true;

    /* We are the first failed job. Cancel other jobs. */

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        ctx = blk_get_aio_context(other_job->blk);

        aio_context_acquire(ctx);

    }

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        if (other_job == job || other_job->completed) {

            /* Other jobs are ""effectively"" cancelled by us, set the status for

             * them; this job, however, may or may not be cancelled, depending

             * on the caller, so leave it. */

            if (other_job != job) {

                block_job_cancel_async(other_job);

            }

            continue;

        }

        block_job_cancel_sync(other_job);

        assert(other_job->completed);

    }

    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {

        ctx = blk_get_aio_context(other_job->blk);

        block_job_completed_single(other_job);

        aio_context_release(ctx);

    }

}
",161,"static void block_job_completed_txn_abort(BlockJob *job)

{

    AioContext *BLK_PERM_GRAPH_MOD;

    BlockJobTxn *txn = job->txn;

    BlockJob *other_job, *next;



    if (txn->aborting) {

        /*

         * We are cancelled by another job, which will handle everything.

         */

        return;

    }

    txn->aborting = true;

    /* We are the first failed job. Cancel other jobs. */

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        BLK_PERM_GRAPH_MOD = blk_get_aio_context(other_job->blk);

        aio_context_acquire(BLK_PERM_GRAPH_MOD);

    }

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        if (other_job == job || other_job->completed) {

            /* Other jobs are ""effectively"" cancelled by us, set the status for

             * them; this job, however, may or may not be cancelled, depending

             * on the caller, so leave it. */

            if (other_job != job) {

                block_job_cancel_async(other_job);

            }

            continue;

        }

        block_job_cancel_sync(other_job);

        assert(other_job->completed);

    }

    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {

        BLK_PERM_GRAPH_MOD = blk_get_aio_context(other_job->blk);

        block_job_completed_single(other_job);

        aio_context_release(BLK_PERM_GRAPH_MOD);

    }

}
",0,0,1,1,ctx,0.3504736125469208,1,5,{'ctx': 'BLK_PERM_GRAPH_MOD'},MHM-Origin,42,0.01785003344217936
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
",28,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t current_migration)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", current_migration);

}
",0,0,1,1,size,0.7551819197833538,1,2,{'size': 'current_migration'},MHM-Origin,21,0.007965075969696044
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",94,"int qio_channel_socket_dgram_sync(QIOChannelSocket *floppy_probe_device,

                                  SocketAddressLegacy *p_mv_table,

                                  SocketAddressLegacy *prop,

                                  Error **v2)

{

    int __msa_srari_h;



    trace_qio_channel_socket_dgram_sync(floppy_probe_device, p_mv_table, prop);

    __msa_srari_h = socket_dgram(prop, p_mv_table, v2);

    if (__msa_srari_h < 0) {

        trace_qio_channel_socket_dgram_fail(floppy_probe_device);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(floppy_probe_device, __msa_srari_h);

    if (qio_channel_socket_set_fd(floppy_probe_device, __msa_srari_h, v2) < 0) {

        close(__msa_srari_h);

        return -1;

    }



    return 0;

}
",0,0,0,-1,ioc,-0.0014861365780234337,5,20,"{'errp': 'v2', 'remoteAddr': 'prop', 'localAddr': 'p_mv_table', 'ioc': 'floppy_probe_device', 'fd': '__msa_srari_h'}",MHM-Origin,402,0.16863014300664267
366,"static void dec_bit(DisasContext *dc)

{

    TCGv t0, t1;

    unsigned int op;

    int mem_index = cpu_mmu_index(dc->env);



    op = dc->ir & ((1 << 9) - 1);

    switch (op) {

        case 0x21:

            /* src.  */

            t0 = tcg_temp_new();



            LOG_DIS(""src r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);

            if (dc->rd) {

                t1 = tcg_temp_new();

                read_carry(dc, t1);

                tcg_gen_shli_tl(t1, t1, 31);



                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);

                tcg_temp_free(t1);

            }



            /* Update carry.  */

            write_carry(dc, t0);

            tcg_temp_free(t0);

            break;



        case 0x1:

        case 0x41:

            /* srl.  */

            t0 = tcg_temp_new();

            LOG_DIS(""srl r%d r%d\n"", dc->rd, dc->ra);



            /* Update carry.  */

            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);

            write_carry(dc, t0);

            tcg_temp_free(t0);

            if (dc->rd) {

                if (op == 0x41)

                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                else

                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

            }

            break;

        case 0x60:

            LOG_DIS(""ext8s r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x61:

            LOG_DIS(""ext16s r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x64:

        case 0x66:

        case 0x74:

        case 0x76:

            /* wdc.  */

            LOG_DIS(""wdc r%d\n"", dc->ra);

            if ((dc->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0x68:

            /* wic.  */

            LOG_DIS(""wic r%d\n"", dc->ra);

            if ((dc->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0xe0:

            if ((dc->tb_flags & MSR_EE_FLAG)

                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)

                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

            }

            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {

                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);

            }

            break;

        case 0x1e0:

            /* swapb */

            LOG_DIS(""swapb r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x1e2:

            /*swaph */

            LOG_DIS(""swaph r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);

            break;

        default:

            cpu_abort(dc->env, ""unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\n"",

                     dc->pc, op, dc->rd, dc->ra, dc->rb);

            break;

    }

}
",679,"static void dec_bit(DisasContext *raise_exception_err)

{

    TCGv HF_MPX_IU_MASK, t1;

    unsigned int bl;

    int mem_index = cpu_mmu_index(raise_exception_err->env);



    bl = raise_exception_err->ir & ((1 << 9) - 1);

    switch (bl) {

        case 0x21:

            /* src.  */

            HF_MPX_IU_MASK = tcg_temp_new();



            LOG_DIS(""src r%d r%d
"", raise_exception_err->rd, raise_exception_err->ra);

            tcg_gen_andi_tl(HF_MPX_IU_MASK, cpu_R[raise_exception_err->ra], 1);

            if (raise_exception_err->rd) {

                t1 = tcg_temp_new();

                read_carry(raise_exception_err, t1);

                tcg_gen_shli_tl(t1, t1, 31);



                tcg_gen_shri_tl(cpu_R[raise_exception_err->rd], cpu_R[raise_exception_err->ra], 1);

                tcg_gen_or_tl(cpu_R[raise_exception_err->rd], cpu_R[raise_exception_err->rd], t1);

                tcg_temp_free(t1);

            }



            /* Update carry.  */

            write_carry(raise_exception_err, HF_MPX_IU_MASK);

            tcg_temp_free(HF_MPX_IU_MASK);

            break;



        case 0x1:

        case 0x41:

            /* srl.  */

            HF_MPX_IU_MASK = tcg_temp_new();

            LOG_DIS(""srl r%d r%d
"", raise_exception_err->rd, raise_exception_err->ra);



            /* Update carry.  */

            tcg_gen_andi_tl(HF_MPX_IU_MASK, cpu_R[raise_exception_err->ra], 1);

            write_carry(raise_exception_err, HF_MPX_IU_MASK);

            tcg_temp_free(HF_MPX_IU_MASK);

            if (raise_exception_err->rd) {

                if (bl == 0x41)

                    tcg_gen_shri_tl(cpu_R[raise_exception_err->rd], cpu_R[raise_exception_err->ra], 1);

                else

                    tcg_gen_sari_tl(cpu_R[raise_exception_err->rd], cpu_R[raise_exception_err->ra], 1);

            }

            break;

        case 0x60:

            LOG_DIS(""ext8s r%d r%d
"", raise_exception_err->rd, raise_exception_err->ra);

            tcg_gen_ext8s_i32(cpu_R[raise_exception_err->rd], cpu_R[raise_exception_err->ra]);

            break;

        case 0x61:

            LOG_DIS(""ext16s r%d r%d
"", raise_exception_err->rd, raise_exception_err->ra);

            tcg_gen_ext16s_i32(cpu_R[raise_exception_err->rd], cpu_R[raise_exception_err->ra]);

            break;

        case 0x64:

        case 0x66:

        case 0x74:

        case 0x76:

            /* wdc.  */

            LOG_DIS(""wdc r%d
"", raise_exception_err->ra);

            if ((raise_exception_err->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(raise_exception_err, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0x68:

            /* wic.  */

            LOG_DIS(""wic r%d
"", raise_exception_err->ra);

            if ((raise_exception_err->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(raise_exception_err, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0xe0:

            if ((raise_exception_err->tb_flags & MSR_EE_FLAG)

                && (raise_exception_err->env->HF_MPX_IU_MASK.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)

                && !((raise_exception_err->env->HF_MPX_IU_MASK.regs[2] & PVR2_USE_PCMP_INSTR))) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);

                t_gen_raise_exception(raise_exception_err, EXCP_HW_EXCP);

            }

            if (raise_exception_err->env->HF_MPX_IU_MASK.regs[2] & PVR2_USE_PCMP_INSTR) {

                gen_helper_clz(cpu_R[raise_exception_err->rd], cpu_R[raise_exception_err->ra]);

            }

            break;

        case 0x1e0:

            /* swapb */

            LOG_DIS(""swapb r%d r%d
"", raise_exception_err->rd, raise_exception_err->ra);

            tcg_gen_bswap32_i32(cpu_R[raise_exception_err->rd], cpu_R[raise_exception_err->ra]);

            break;

        case 0x1e2:

            /*swaph */

            LOG_DIS(""swaph r%d r%d
"", raise_exception_err->rd, raise_exception_err->ra);

            tcg_gen_rotri_i32(cpu_R[raise_exception_err->rd], cpu_R[raise_exception_err->ra], 16);

            break;

        default:

            cpu_abort(raise_exception_err->env, ""unknown bit oc=%x op=%x rd=%d ra=%d rb=%d
"",

                     raise_exception_err->pc, bl, raise_exception_err->rd, raise_exception_err->ra, raise_exception_err->rb);

            break;

    }

}
",0,0,1,1,t0,0.5225542858242989,3,70,"{'t0': 'HF_MPX_IU_MASK', 'dc': 'raise_exception_err', 'op': 'bl'}",MHM-Origin,232,0.1186423142751058
367,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
",42,"int memory_region_get_fd(MemoryRegion *avpriv_report_missing_feature)

{

    if (avpriv_report_missing_feature->alias) {

        return memory_region_get_fd(avpriv_report_missing_feature->alias);

    }



    assert(avpriv_report_missing_feature->terminates);



    return qemu_get_ram_fd(avpriv_report_missing_feature->ram_addr & TARGET_PAGE_MASK);

}
",0,0,0,-1,mr,-0.09669173695147038,1,5,{'mr': 'avpriv_report_missing_feature'},MHM-Origin,387,0.16610129276911417
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool pre, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= pre << 24;

    insn |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);

}
",103,"static void tcg_out_insn_3314(TCGContext *Object, AArch64Insn avformat_new_stream,

                              TCGReg numComponents, TCGReg fw_size, TCGReg st_mode,

                              tcg_target_long omap_pwt_s, bool ModPred, bool blocker)

{

    avformat_new_stream |= 1u << 31; /* ext */

    avformat_new_stream |= ModPred << 24;

    avformat_new_stream |= blocker << 23;



    assert(omap_pwt_s >= -0x200 && omap_pwt_s < 0x200 && (omap_pwt_s & 7) == 0);

    avformat_new_stream |= (omap_pwt_s & (0x7f << 3)) << (15 - 3);



    tcg_out32(Object, avformat_new_stream | fw_size << 10 | st_mode << 5 | numComponents);

}
",0,0,0,-1,pre,0.0006337990052998066,8,23,"{'r2': 'fw_size', 's': 'Object', 'w': 'blocker', 'ofs': 'omap_pwt_s', 'r1': 'numComponents', 'rn': 'st_mode', 'insn': 'avformat_new_stream', 'pre': 'ModPred'}",MHM-Origin,386,0.16421939929326376
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, errp);

    if (error_is_set(errp)) {

        return;

    }

    if (value < min || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }



    cpu->env.tsc_khz = value / 1000;

}
",123,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *audio_pkt_cnt, void *fmt,

                                   const char *pdu, Error **nb_input_files)

{

    X86CPU *celt = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t ist;



    visit_type_int(audio_pkt_cnt, &ist, pdu, nb_input_files);

    if (error_is_set(nb_input_files)) {

        return;

    }

    if (ist < min || ist > max) {

        error_set(nb_input_files, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  pdu ? pdu : ""null"", ist, min, max);

        return;

    }



    celt->env.tsc_khz = ist / 1000;

}
",0,0,0,-1,errp,0.012410540133714676,6,19,"{'name': 'pdu', 'cpu': 'celt', 'v': 'audio_pkt_cnt', 'errp': 'nb_input_files', 'value': 'ist', 'opaque': 'fmt'}",MHM-Origin,396,0.16909391085306805
371,"static av_cold int check_format(AVCodecContext *avctx)

{

    AVCodecParserContext *parser;

    uint8_t *pout;

    int psize;

    int index;

    H264Context *h;

    int ret = -1;



    /* init parser & parse file */

    parser = av_parser_init(avctx->codec->id);

    if (!parser) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");

        goto final;

    }

    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;

    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);

    if (index < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");

        goto release_parser;

    }



    /* check if support */

    h = parser->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");

    }



release_parser:

    av_parser_close(parser);



final:

    return ret;

}
",185,"static av_cold int check_format(AVCodecContext *DeviceClass)

{

    AVCodecParserContext *parser;

    uint8_t *BDRV_O_RDWR;

    int AV_OPT_SEARCH_CHILDREN;

    int dumpdtb;

    H264Context *gen_helper_fpush;

    int ret = -1;



    /* init parser & parse file */

    parser = av_parser_init(DeviceClass->codec->id);

    if (!parser) {

        av_log(DeviceClass, AV_LOG_ERROR, ""Failed to open H.264 parser.
"");

        goto final;

    }

    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;

    dumpdtb = av_parser_parse2(parser, DeviceClass, &BDRV_O_RDWR, &AV_OPT_SEARCH_CHILDREN, NULL, 0, 0, 0, 0);

    if (dumpdtb < 0) {

        av_log(DeviceClass, AV_LOG_ERROR, ""Failed to parse this file.
"");

        goto release_parser;

    }



    /* check if support */

    gen_helper_fpush = parser->priv_data;

    switch (gen_helper_fpush->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(gen_helper_fpush) && !CHROMA422(gen_helper_fpush)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(DeviceClass, AV_LOG_ERROR, ""Unsupported file.
"");

    }



release_parser:

    av_parser_close(parser);



final:

    return ret;

}
",0,0,1,1,psize,0.18453481793403625,5,18,"{'index': 'dumpdtb', 'psize': 'AV_OPT_SEARCH_CHILDREN', 'avctx': 'DeviceClass', 'pout': 'BDRV_O_RDWR', 'h': 'gen_helper_fpush'}",MHM-Origin,275,0.1196526050567627
372,"static unsigned int dec_move_mr(DisasContext *dc)

{

	int memsize = memsize_zz(dc);

	int insn_len;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),

		    dc->op1, dc->postinc ? ""+]"" : ""]"",

		    dc->op2));



	if (memsize == 4) {

		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_update_cc_op(dc, CC_OP_MOVE, 4);

		cris_update_cc_x(dc);

		cris_update_result(dc, cpu_R[dc->op2]);

	}

	else {

		TCGv t0;



		t0 = tcg_temp_new(TCG_TYPE_TL);

		insn_len = dec_prep_move_m(dc, 0, memsize, t0);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_alu(dc, CC_OP_MOVE,

			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);

		tcg_temp_free(t0);

	}

	do_postinc(dc, memsize);

	return insn_len;

}
",191,"static unsigned int dec_move_mr(DisasContext *single_col)

{

	int memsize = memsize_zz(single_col);

	int HV_X64_MSR_SIMP;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u
"",

		    memsize_char(memsize),

		    single_col->op1, single_col->postinc ? ""+]"" : ""]"",

		    single_col->op2));



	if (memsize == 4) {

		HV_X64_MSR_SIMP = dec_prep_move_m(single_col, 0, 4, cpu_R[single_col->op2]);

		cris_cc_mask(single_col, CC_MASK_NZ);

		cris_update_cc_op(single_col, CC_OP_MOVE, 4);

		cris_update_cc_x(single_col);

		cris_update_result(single_col, cpu_R[single_col->op2]);

	}

	else {

		TCGv filesize;



		filesize = tcg_temp_new(TCG_TYPE_TL);

		HV_X64_MSR_SIMP = dec_prep_move_m(single_col, 0, memsize, filesize);

		cris_cc_mask(single_col, CC_MASK_NZ);

		cris_alu(single_col, CC_OP_MOVE,

			    cpu_R[single_col->op2], cpu_R[single_col->op2], filesize, memsize);

		tcg_temp_free(filesize);

	}

	do_postinc(single_col, memsize);

	return HV_X64_MSR_SIMP;

}
",0,0,0,-1,dc,0.00011330749839544296,3,27,"{'insn_len': 'HV_X64_MSR_SIMP', 'dc': 'single_col', 't0': 'filesize'}",MHM-Origin,394,0.17534933090209961
373,"static int rtc_initfn(ISADevice *dev)

{

    RTCState *s = DO_UPCAST(RTCState, dev, dev);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(dev, &s->irq, isairq);



    s->cmos_data[RTC_REG_A] = 0x26;

    s->cmos_data[RTC_REG_B] = 0x02;

    s->cmos_data[RTC_REG_C] = 0x00;

    s->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(s);



    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        s->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);

#endif

    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);

    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);



    s->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(s->second_timer2, s->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, s);

    register_ioport_read(base, 2, 1, cmos_ioport_read, s);



    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, s);

#endif

    qemu_register_reset(rtc_reset, s);

    return 0;

}
",252,"static int rtc_initfn(ISADevice *duration_error)

{

    RTCState *opus_fade = DO_UPCAST(RTCState, duration_error, duration_error);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(duration_error, &opus_fade->irq, isairq);



    opus_fade->cmos_data[RTC_REG_A] = 0x26;

    opus_fade->cmos_data[RTC_REG_B] = 0x02;

    opus_fade->cmos_data[RTC_REG_C] = 0x00;

    opus_fade->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(opus_fade);



    opus_fade->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, opus_fade);

#ifdef TARGET_I386

    if (rtc_td_hack)

        opus_fade->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, opus_fade);

#endif

    opus_fade->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, opus_fade);

    opus_fade->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, opus_fade);



    opus_fade->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(opus_fade->second_timer2, opus_fade->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, opus_fade);

    register_ioport_read(base, 2, 1, cmos_ioport_read, opus_fade);



    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, opus_fade);

#ifdef TARGET_I386

    if (rtc_td_hack)

        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, opus_fade);

#endif

    qemu_register_reset(rtc_reset, opus_fade);

    return 0;

}
",0,0,0,-1,s,0.017289843410253525,2,27,"{'dev': 'duration_error', 's': 'opus_fade'}",MHM-Origin,394,0.18665839831034342
375,"static int read_packet(AVFormatContext *s1, AVPacket *pkt)

{

    VideoDemuxData *s = s1->priv_data;

    char filename_bytes[1024];

    char *filename = filename_bytes;

    int i;

    int size[3]={0}, ret[3]={0};

    AVIOContext *f[3] = {NULL};

    AVCodecContext *codec= s1->streams[0]->codec;



    if (!s->is_pipe) {

        /* loop over input */

        if (s->loop && s->img_number > s->img_last) {

            s->img_number = s->img_first;

        }

        if (s->img_number > s->img_last)

            return AVERROR_EOF;

        if (s->use_glob) {

#if HAVE_GLOB

            filename = s->globstate.gl_pathv[s->img_number];

#endif

        } else {

        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),

                                  s->path, s->img_number)<0 && s->img_number > 1)

            return AVERROR(EIO);

        }

        for(i=0; i<3; i++){

            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,

                           &s1->interrupt_callback, NULL) < 0) {

                if(i>=1)

                    break;

                av_log(s1, AV_LOG_ERROR, ""Could not open file : %s\n"",filename);

                return AVERROR(EIO);

            }

            size[i]= avio_size(f[i]);



            if(!s->split_planes)

                break;

            filename[ strlen(filename) - 1 ]= 'U' + i;

        }



        if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)

            infer_size(&codec->width, &codec->height, size[0]);

    } else {

        f[0] = s1->pb;

        if (url_feof(f[0]))

            return AVERROR(EIO);

        size[0]= 4096;

    }



    av_new_packet(pkt, size[0] + size[1] + size[2]);

    pkt->stream_index = 0;

    pkt->flags |= AV_PKT_FLAG_KEY;



    pkt->size= 0;

    for(i=0; i<3; i++){

        if(f[i]){

            ret[i]= avio_read(f[i], pkt->data + pkt->size, size[i]);

            if (!s->is_pipe)

                avio_close(f[i]);

            if(ret[i]>0)

                pkt->size += ret[i];

        }

    }



    if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) {

        av_free_packet(pkt);

        return AVERROR(EIO); /* signal EOF */

    } else {

        s->img_count++;

        s->img_number++;

        return 0;

    }

}
",533,"static int read_packet(AVFormatContext *s1, AVPacket *shm_open)

{

    VideoDemuxData *s = s1->priv_data;

    char filename_bytes[1024];

    char *filename = filename_bytes;

    int i;

    int size[3]={0}, ret[3]={0};

    AVIOContext *f[3] = {NULL};

    AVCodecContext *codec= s1->streams[0]->codec;



    if (!s->is_pipe) {

        /* loop over input */

        if (s->loop && s->ga_channel_listen_add > s->img_last) {

            s->ga_channel_listen_add = s->img_first;

        }

        if (s->ga_channel_listen_add > s->img_last)

            return AVERROR_EOF;

        if (s->use_glob) {

#if HAVE_GLOB

            filename = s->globstate.gl_pathv[s->ga_channel_listen_add];

#endif

        } else {

        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),

                                  s->path, s->ga_channel_listen_add)<0 && s->ga_channel_listen_add > 1)

            return AVERROR(EIO);

        }

        for(i=0; i<3; i++){

            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,

                           &s1->interrupt_callback, NULL) < 0) {

                if(i>=1)

                    break;

                av_log(s1, AV_LOG_ERROR, ""Could not open file : %s
"",filename);

                return AVERROR(EIO);

            }

            size[i]= avio_size(f[i]);



            if(!s->split_planes)

                break;

            filename[ strlen(filename) - 1 ]= 'U' + i;

        }



        if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)

            infer_size(&codec->width, &codec->height, size[0]);

    } else {

        f[0] = s1->pb;

        if (url_feof(f[0]))

            return AVERROR(EIO);

        size[0]= 4096;

    }



    av_new_packet(shm_open, size[0] + size[1] + size[2]);

    shm_open->stream_index = 0;

    shm_open->flags |= AV_PKT_FLAG_KEY;



    shm_open->size= 0;

    for(i=0; i<3; i++){

        if(f[i]){

            ret[i]= avio_read(f[i], shm_open->data + shm_open->size, size[i]);

            if (!s->is_pipe)

                avio_close(f[i]);

            if(ret[i]>0)

                shm_open->size += ret[i];

        }

    }



    if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) {

        av_free_packet(shm_open);

        return AVERROR(EIO); /* signal EOF */

    } else {

        s->img_count++;

        s->ga_channel_listen_add++;

        return 0;

    }

}
",0,0,1,1,img_number,0.05947160720825195,2,16,"{'pkt': 'shm_open', 'img_number': 'ga_channel_listen_add'}",MHM-Origin,39,0.01781719128290812
376,"static int smacker_read_header(AVFormatContext *s)
{
    AVIOContext *pb = s->pb;
    SmackerContext *smk = s->priv_data;
    AVStream *st, *ast[7];
    int i, ret;
    int tbase;
    /* read and check header */
    smk->magic = avio_rl32(pb);
    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))
    smk->width = avio_rl32(pb);
    smk->height = avio_rl32(pb);
    smk->frames = avio_rl32(pb);
    smk->pts_inc = (int32_t)avio_rl32(pb);
    smk->flags = avio_rl32(pb);
    if(smk->flags & SMACKER_FLAG_RING_FRAME)
        smk->frames++;
    for(i = 0; i < 7; i++)
        smk->audio[i] = avio_rl32(pb);
    smk->treesize = avio_rl32(pb);
    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)
        av_log(s, AV_LOG_ERROR, ""treesize too large\n"");
//FIXME remove extradata ""rebuilding""
    smk->mmap_size = avio_rl32(pb);
    smk->mclr_size = avio_rl32(pb);
    smk->full_size = avio_rl32(pb);
    smk->type_size = avio_rl32(pb);
    for(i = 0; i < 7; i++) {
        smk->rates[i]  = avio_rl24(pb);
        smk->aflags[i] = avio_r8(pb);
    smk->pad = avio_rl32(pb);
    /* setup data */
    if(smk->frames > 0xFFFFFF) {
        av_log(s, AV_LOG_ERROR, ""Too many frames: %""PRIu32""\n"", smk->frames);
    smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size));
    smk->frm_flags = av_malloc(smk->frames);
    if (!smk->frm_size || !smk->frm_flags) {
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(ENOMEM);
    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));
    /* read frame info */
    for(i = 0; i < smk->frames; i++) {
        smk->frm_size[i] = avio_rl32(pb);
    for(i = 0; i < smk->frames; i++) {
        smk->frm_flags[i] = avio_r8(pb);
    /* init video codec */
    st = avformat_new_stream(s, NULL);
    if (!st)
        return AVERROR(ENOMEM);
    smk->videoindex = st->index;
    st->codec->width = smk->width;
    st->codec->height = smk->height;
    st->codec->pix_fmt = AV_PIX_FMT_PAL8;
    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;
    st->codec->codec_tag = smk->magic;
    /* Smacker uses 100000 as internal timebase */
    if(smk->pts_inc < 0)
        smk->pts_inc = -smk->pts_inc;
    else
        smk->pts_inc *= 100;
    tbase = 100000;
    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);
    avpriv_set_pts_info(st, 33, smk->pts_inc, tbase);
    st->duration = smk->frames;
    /* handle possible audio streams */
    for(i = 0; i < 7; i++) {
        smk->indexes[i] = -1;
        if (smk->rates[i]) {
            ast[i] = avformat_new_stream(s, NULL);
            if (!ast[i])
                return AVERROR(ENOMEM);
            smk->indexes[i] = ast[i]->index;
            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;
            if (smk->aflags[i] & SMK_AUD_BINKAUD) {
                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;
            } else if (smk->aflags[i] & SMK_AUD_USEDCT) {
                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;
            } else if (smk->aflags[i] & SMK_AUD_PACKED){
                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;
                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');
            } else {
                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;
            if (smk->aflags[i] & SMK_AUD_STEREO) {
                ast[i]->codec->channels       = 2;
                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;
            } else {
                ast[i]->codec->channels       = 1;
                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;
            ast[i]->codec->sample_rate = smk->rates[i];
            ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;
            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)
                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;
            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate
                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);
    /* load trees to extradata, they will be unpacked by decoder */
    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){
        av_log(s, AV_LOG_ERROR,
               ""Cannot allocate %""PRIu32"" bytes of extradata\n"",
               smk->treesize + 16);
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(ENOMEM);
    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);
    if(ret != st->codec->extradata_size - 16){
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(EIO);
    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);
    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);
    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);
    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);
    smk->curstream = -1;
    smk->nextpos = avio_tell(pb);
    return 0;",1230,"static int smacker_read_header(AVFormatContext *netclient_type)
{
    AVIOContext *update_speed = netclient_type->update_speed;
    SmackerContext *security_model = netclient_type->priv_data;
    AVStream *alpha_in, *peripherals[7];
    int nd_table, vector_width;
    int AddressParts;
    /* read and check header */
    security_model->magic = avio_rl32(update_speed);
    if (security_model->magic != MKTAG('S', 'M', 'K', '2') && security_model->magic != MKTAG('S', 'M', 'K', '4'))
    security_model->width = avio_rl32(update_speed);
    security_model->height = avio_rl32(update_speed);
    security_model->av_fifo_reset = avio_rl32(update_speed);
    security_model->pts_inc = (int32_t)avio_rl32(update_speed);
    security_model->flags = avio_rl32(update_speed);
    if(security_model->flags & SMACKER_FLAG_RING_FRAME)
        security_model->av_fifo_reset++;
    for(nd_table = 0; nd_table < 7; nd_table++)
        security_model->audio[nd_table] = avio_rl32(update_speed);
    security_model->treesize = avio_rl32(update_speed);
    if(security_model->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)
        av_log(netclient_type, AV_LOG_ERROR, ""treesize too large
"");
//FIXME remove extradata ""rebuilding""
    security_model->mmap_size = avio_rl32(update_speed);
    security_model->mclr_size = avio_rl32(update_speed);
    security_model->full_size = avio_rl32(update_speed);
    security_model->type_size = avio_rl32(update_speed);
    for(nd_table = 0; nd_table < 7; nd_table++) {
        security_model->rates[nd_table]  = avio_rl24(update_speed);
        security_model->aflags[nd_table] = avio_r8(update_speed);
    security_model->pad = avio_rl32(update_speed);
    /* setup data */
    if(security_model->av_fifo_reset > 0xFFFFFF) {
        av_log(netclient_type, AV_LOG_ERROR, ""Too many frames: %""PRIu32""
"", security_model->av_fifo_reset);
    security_model->frm_size = av_malloc_array(security_model->av_fifo_reset, sizeof(*security_model->frm_size));
    security_model->frm_flags = av_malloc(security_model->av_fifo_reset);
    if (!security_model->frm_size || !security_model->frm_flags) {
        av_freep(&security_model->frm_size);
        av_freep(&security_model->frm_flags);
        return AVERROR(ENOMEM);
    security_model->is_ver4 = (security_model->magic != MKTAG('S', 'M', 'K', '2'));
    /* read frame info */
    for(nd_table = 0; nd_table < security_model->av_fifo_reset; nd_table++) {
        security_model->frm_size[nd_table] = avio_rl32(update_speed);
    for(nd_table = 0; nd_table < security_model->av_fifo_reset; nd_table++) {
        security_model->frm_flags[nd_table] = avio_r8(update_speed);
    /* init video codec */
    alpha_in = avformat_new_stream(netclient_type, NULL);
    if (!alpha_in)
        return AVERROR(ENOMEM);
    security_model->videoindex = alpha_in->index;
    alpha_in->codec->width = security_model->width;
    alpha_in->codec->height = security_model->height;
    alpha_in->codec->pix_fmt = AV_PIX_FMT_PAL8;
    alpha_in->codec->codec_type = AVMEDIA_TYPE_VIDEO;
    alpha_in->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;
    alpha_in->codec->codec_tag = security_model->magic;
    /* Smacker uses 100000 as internal timebase */
    if(security_model->pts_inc < 0)
        security_model->pts_inc = -security_model->pts_inc;
    else
        security_model->pts_inc *= 100;
    AddressParts = 100000;
    av_reduce(&AddressParts, &security_model->pts_inc, AddressParts, security_model->pts_inc, (1UL<<31)-1);
    avpriv_set_pts_info(alpha_in, 33, security_model->pts_inc, AddressParts);
    alpha_in->duration = security_model->av_fifo_reset;
    /* handle possible audio streams */
    for(nd_table = 0; nd_table < 7; nd_table++) {
        security_model->indexes[nd_table] = -1;
        if (security_model->rates[nd_table]) {
            peripherals[nd_table] = avformat_new_stream(netclient_type, NULL);
            if (!peripherals[nd_table])
                return AVERROR(ENOMEM);
            security_model->indexes[nd_table] = peripherals[nd_table]->index;
            peripherals[nd_table]->codec->codec_type = AVMEDIA_TYPE_AUDIO;
            if (security_model->aflags[nd_table] & SMK_AUD_BINKAUD) {
                peripherals[nd_table]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;
            } else if (security_model->aflags[nd_table] & SMK_AUD_USEDCT) {
                peripherals[nd_table]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;
            } else if (security_model->aflags[nd_table] & SMK_AUD_PACKED){
                peripherals[nd_table]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;
                peripherals[nd_table]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');
            } else {
                peripherals[nd_table]->codec->codec_id = AV_CODEC_ID_PCM_U8;
            if (security_model->aflags[nd_table] & SMK_AUD_STEREO) {
                peripherals[nd_table]->codec->channels       = 2;
                peripherals[nd_table]->codec->channel_layout = AV_CH_LAYOUT_STEREO;
            } else {
                peripherals[nd_table]->codec->channels       = 1;
                peripherals[nd_table]->codec->channel_layout = AV_CH_LAYOUT_MONO;
            peripherals[nd_table]->codec->sample_rate = security_model->rates[nd_table];
            peripherals[nd_table]->codec->bits_per_coded_sample = (security_model->aflags[nd_table] & SMK_AUD_16BITS) ? 16 : 8;
            if(peripherals[nd_table]->codec->bits_per_coded_sample == 16 && peripherals[nd_table]->codec->codec_id == AV_CODEC_ID_PCM_U8)
                peripherals[nd_table]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;
            avpriv_set_pts_info(peripherals[nd_table], 64, 1, peripherals[nd_table]->codec->sample_rate
                    * peripherals[nd_table]->codec->channels * peripherals[nd_table]->codec->bits_per_coded_sample / 8);
    /* load trees to extradata, they will be unpacked by decoder */
    if(ff_alloc_extradata(alpha_in->codec, security_model->treesize + 16)){
        av_log(netclient_type, AV_LOG_ERROR,
               ""Cannot allocate %""PRIu32"" bytes of extradata
"",
               security_model->treesize + 16);
        av_freep(&security_model->frm_size);
        av_freep(&security_model->frm_flags);
        return AVERROR(ENOMEM);
    vector_width = avio_read(update_speed, alpha_in->codec->extradata + 16, alpha_in->codec->extradata_size - 16);
    if(vector_width != alpha_in->codec->extradata_size - 16){
        av_freep(&security_model->frm_size);
        av_freep(&security_model->frm_flags);
        return AVERROR(EIO);
    ((int32_t*)alpha_in->codec->extradata)[0] = av_le2ne32(security_model->mmap_size);
    ((int32_t*)alpha_in->codec->extradata)[1] = av_le2ne32(security_model->mclr_size);
    ((int32_t*)alpha_in->codec->extradata)[2] = av_le2ne32(security_model->full_size);
    ((int32_t*)alpha_in->codec->extradata)[3] = av_le2ne32(security_model->type_size);
    security_model->curstream = -1;
    security_model->nextpos = avio_tell(update_speed);
    return 0;",1,1,1,-1,st,-0.012192249298095703,9,212,"{'frames': 'av_fifo_reset', 's': 'netclient_type', 'smk': 'security_model', 'st': 'alpha_in', 'i': 'nd_table', 'pb': 'update_speed', 'ret': 'vector_width', 'tbase': 'AddressParts', 'ast': 'peripherals'}",MHM-Origin,389,0.23870822588602703
377,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,

                                       int64_t sector_num, int nb_sectors)

{

    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);

}
",31,"static int coroutine_fn raw_co_discard(BlockDriverState *chrFilter,

                                       int64_t mfi_pd_info, int tcg_gen_mul_tl)

{

    return bdrv_co_discard(chrFilter->file->chrFilter, mfi_pd_info, tcg_gen_mul_tl);

}
",0,0,1,1,nb_sectors,0.7388105634599924,3,7,"{'bs': 'chrFilter', 'nb_sectors': 'tcg_gen_mul_tl', 'sector_num': 'mfi_pd_info'}",MHM-Origin,354,0.15252430041631063
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
",62,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *outputsamples_buffer,

        int64_t bl1, int x86_ldsw_code, BdrvRequestFlags RV34_MB_P_16x8,

        BlockCompletionFunc *QERR_MISSING_PARAMETER, void *put_mspel_pixels_tab)

{

    trace_bdrv_aio_write_zeroes(outputsamples_buffer, bl1, x86_ldsw_code, RV34_MB_P_16x8, put_mspel_pixels_tab);



    return bdrv_co_aio_rw_vector(outputsamples_buffer, bl1, NULL, x86_ldsw_code,

                                 BDRV_REQ_ZERO_WRITE | RV34_MB_P_16x8,

                                 QERR_MISSING_PARAMETER, put_mspel_pixels_tab, true);

}
",0,0,1,1,cb,0.9298574738204479,6,17,"{'flags': 'RV34_MB_P_16x8', 'bs': 'outputsamples_buffer', 'nb_sectors': 'x86_ldsw_code', 'sector_num': 'bl1', 'cb': 'QERR_MISSING_PARAMETER', 'opaque': 'put_mspel_pixels_tab'}",MHM-Origin,371,0.16156553427378337
379,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
",46,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *new_head = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(new_head->vdev);

    msix_reset(&new_head->pci_dev);

    new_head->flags = 0;

}
",0,0,1,1,proxy,0.2932479679584503,1,4,{'proxy': 'new_head'},MHM-Origin,21,0.007908153533935546
380,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = opinv;

        }

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
",125,"static void tcg_out_dat_rIK(TCGContext *y_dc_scale_table, int cond, int new_picture, int opinv,

                            TCGReg rlow, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            new_picture = opinv;

        }

        tcg_out_dat_imm(y_dc_scale_table, cond, new_picture, rlow, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(y_dc_scale_table, cond, new_picture, rlow, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
",0,0,1,1,opc,0.3368545025587082,3,10,"{'s': 'y_dc_scale_table', 'dst': 'rlow', 'opc': 'new_picture'}",MHM-Origin,63,0.026348658402760825
381,"static int twl92230_init(i2c_slave *i2c)

{

    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);



    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);

    /* Three output pins plus one interrupt pin.  */

    qdev_init_gpio_out(&i2c->qdev, s->out, 4);

    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);

    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];



    menelaus_reset(&s->i2c);



    return 0;

}
",89,"static int twl92230_init(i2c_slave *src_hz1)

{

    MenelausState *icon_error = FROM_I2C_SLAVE(MenelausState, src_hz1);



    icon_error->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, icon_error);

    /* Three output pins plus one interrupt pin.  */

    qdev_init_gpio_out(&src_hz1->qdev, icon_error->out, 4);

    qdev_init_gpio_in(&src_hz1->qdev, menelaus_gpio_set, 3);

    icon_error->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, icon_error, 1)[0];



    menelaus_reset(&icon_error->src_hz1);



    return 0;

}
",0,0,0,-1,s,0.022959575057029724,2,12,"{'i2c': 'src_hz1', 's': 'icon_error'}",MHM-Origin,408,0.17616068919499714
388,"static inline void ide_dma_submit_check(IDEState *s,

          BlockDriverCompletionFunc *dma_cb)

{

    if (s->bus->dma->aiocb)

	return;

    dma_cb(s, -1);

}
",34,"static inline void ide_dma_submit_check(IDEState *s,

          BlockDriverCompletionFunc *QLIST_FIRST)

{

    if (s->bus->dma->aiocb)

	return;

    QLIST_FIRST(s, -1);

}
",1,1,0,1,dma_cb,-0.5655557811260223,1,2,{'dma_cb': 'QLIST_FIRST'},MHM-Origin,28,0.008731643358866373
390,"static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,

                                    const uint8_t *src, const uint8_t *src_end,

                                    int width, int esc_count)

{

    int i = 0;

    int count;

    uint8_t zero_run = 0;

    const uint8_t *src_start = src;

    uint8_t mask1 = -(esc_count < 2);

    uint8_t mask2 = -(esc_count < 3);

    uint8_t *end = dst + (width - 2);



    avpriv_request_sample(l->avctx, ""zero_run_line"");

    return AVERROR_PATCHWELCOME;



output_zeros:

    if (l->zeros_rem) {

        count = FFMIN(l->zeros_rem, width - i);

        if (end - dst < count) {

            av_log(l->avctx, AV_LOG_ERROR, ""Too many zeros remaining.\n"");

            return AVERROR_INVALIDDATA;

        }



        memset(dst, 0, count);

        l->zeros_rem -= count;

        dst += count;

    }



    while (dst < end) {

        i = 0;

        while (!zero_run && dst + i < end) {

            i++;

            if (i+2 >= src_end - src)

                return AVERROR_INVALIDDATA;

            zero_run =

                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));

        }

        if (zero_run) {

            zero_run = 0;

            i += esc_count;

            memcpy(dst, src, i);

            dst += i;

            l->zeros_rem = lag_calc_zero_run(src[i]);



            src += i + 1;

            goto output_zeros;

        } else {

            memcpy(dst, src, i);

            src += i;

            dst += i;

        }

    }

    return  src - src_start;

}
",310,"static int lag_decode_zero_run_line(LagarithContext *cpu_index, uint8_t *dst,

                                    const uint8_t *src, const uint8_t *MAX_CPUS,

                                    int width, int newpasses1)

{

    int SCSIDiskState = 0;

    int count;

    uint8_t zero_run = 0;

    const uint8_t *src_start = src;

    uint8_t mask1 = -(newpasses1 < 2);

    uint8_t mask2 = -(newpasses1 < 3);

    uint8_t *end = dst + (width - 2);



    avpriv_request_sample(cpu_index->avctx, ""zero_run_line"");

    return AVERROR_PATCHWELCOME;



output_zeros:

    if (cpu_index->zeros_rem) {

        count = FFMIN(cpu_index->zeros_rem, width - SCSIDiskState);

        if (end - dst < count) {

            av_log(cpu_index->avctx, AV_LOG_ERROR, ""Too many zeros remaining.
"");

            return AVERROR_INVALIDDATA;

        }



        memset(dst, 0, count);

        cpu_index->zeros_rem -= count;

        dst += count;

    }



    while (dst < end) {

        SCSIDiskState = 0;

        while (!zero_run && dst + SCSIDiskState < end) {

            SCSIDiskState++;

            if (SCSIDiskState+2 >= MAX_CPUS - src)

                return AVERROR_INVALIDDATA;

            zero_run =

                !(src[SCSIDiskState] | (src[SCSIDiskState + 1] & mask1) | (src[SCSIDiskState + 2] & mask2));

        }

        if (zero_run) {

            zero_run = 0;

            SCSIDiskState += newpasses1;

            memcpy(dst, src, SCSIDiskState);

            dst += SCSIDiskState;

            cpu_index->zeros_rem = lag_calc_zero_run(src[SCSIDiskState]);



            src += SCSIDiskState + 1;

            goto output_zeros;

        } else {

            memcpy(dst, src, SCSIDiskState);

            src += SCSIDiskState;

            dst += SCSIDiskState;

        }

    }

    return  src - src_start;

}
",1,1,0,1,esc_count,-0.2846453785896301,4,30,"{'i': 'SCSIDiskState', 'src_end': 'MAX_CPUS', 'l': 'cpu_index', 'esc_count': 'newpasses1'}",MHM-Origin,77,0.03698971271514893
391,"static int ram_init_all(RAMState **rsp)

{

    Error *local_err = NULL;



    if (ram_state_init(rsp)) {

        return -1;

    }



    if (migrate_use_xbzrle()) {

        XBZRLE_cache_lock();

        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);

        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),

                                  TARGET_PAGE_SIZE, &local_err);

        if (!XBZRLE.cache) {

            XBZRLE_cache_unlock();

            error_report_err(local_err);

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

        XBZRLE_cache_unlock();



        /* We prefer not to abort if there is no memory */

        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);

        if (!XBZRLE.encoded_buf) {

            error_report(""Error allocating encoded_buf"");

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }



        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);

        if (!XBZRLE.current_buf) {

            error_report(""Error allocating current_buf"");

            g_free(XBZRLE.encoded_buf);

            XBZRLE.encoded_buf = NULL;

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

    }



    /* For memory_global_dirty_log_start below.  */

    qemu_mutex_lock_iothread();



    qemu_mutex_lock_ramlist();

    rcu_read_lock();



    /* Skip setting bitmap if there is no RAM */

    if (ram_bytes_total()) {

        RAMBlock *block;



        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {

            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;



            block->bmap = bitmap_new(pages);

            bitmap_set(block->bmap, 0, pages);

            if (migrate_postcopy_ram()) {

                block->unsentmap = bitmap_new(pages);

                bitmap_set(block->unsentmap, 0, pages);

            }

        }

    }



    memory_global_dirty_log_start();

    migration_bitmap_sync(*rsp);

    qemu_mutex_unlock_ramlist();

    qemu_mutex_unlock_iothread();

    rcu_read_unlock();



    return 0;

}
",314,"static int ram_init_all(RAMState **CC_OP_SUBB)

{

    Error *RTP_H261_PAYLOAD_HEADER_SIZE = NULL;



    if (ram_state_init(CC_OP_SUBB)) {

        return -1;

    }



    if (migrate_use_xbzrle()) {

        XBZRLE_cache_lock();

        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);

        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),

                                  TARGET_PAGE_SIZE, &RTP_H261_PAYLOAD_HEADER_SIZE);

        if (!XBZRLE.cache) {

            XBZRLE_cache_unlock();

            error_report_err(RTP_H261_PAYLOAD_HEADER_SIZE);

            g_free(*CC_OP_SUBB);

            *CC_OP_SUBB = NULL;

            return -1;

        }

        XBZRLE_cache_unlock();



        /* We prefer not to abort if there is no memory */

        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);

        if (!XBZRLE.encoded_buf) {

            error_report(""Error allocating encoded_buf"");

            g_free(*CC_OP_SUBB);

            *CC_OP_SUBB = NULL;

            return -1;

        }



        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);

        if (!XBZRLE.current_buf) {

            error_report(""Error allocating current_buf"");

            g_free(XBZRLE.encoded_buf);

            XBZRLE.encoded_buf = NULL;

            g_free(*CC_OP_SUBB);

            *CC_OP_SUBB = NULL;

            return -1;

        }

    }



    /* For memory_global_dirty_log_start below.  */

    qemu_mutex_lock_iothread();



    qemu_mutex_lock_ramlist();

    rcu_read_lock();



    /* Skip setting bitmap if there is no RAM */

    if (ram_bytes_total()) {

        RAMBlock *lms_prevvalues;



        QLIST_FOREACH_RCU(lms_prevvalues, &ram_list.blocks, next) {

            unsigned long pages = lms_prevvalues->max_length >> TARGET_PAGE_BITS;



            lms_prevvalues->bmap = bitmap_new(pages);

            bitmap_set(lms_prevvalues->bmap, 0, pages);

            if (migrate_postcopy_ram()) {

                lms_prevvalues->unsentmap = bitmap_new(pages);

                bitmap_set(lms_prevvalues->unsentmap, 0, pages);

            }

        }

    }



    memory_global_dirty_log_start();

    migration_bitmap_sync(*CC_OP_SUBB);

    qemu_mutex_unlock_ramlist();

    qemu_mutex_unlock_iothread();

    rcu_read_unlock();



    return 0;

}
",1,1,1,-1,block,0.004024207592010498,3,19,"{'local_err': 'RTP_H261_PAYLOAD_HEADER_SIZE', 'block': 'lms_prevvalues', 'rsp': 'CC_OP_SUBB'}",MHM-Origin,395,0.19102489550908405
392,"static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",197,"static void av_always_inline filter_mb_edgecv( uint8_t *gen_jr, int xenevtchn_open, int16_t error_sum[4], unsigned int LM32_CPU, H264Context *s ) {

    const unsigned int index_a = LM32_CPU + s->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[LM32_CPU + s->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( error_sum[0] < 4 ) {

        int8_t func[4];

        func[0] = tc0_table[index_a][error_sum[0]]+1;

        func[1] = tc0_table[index_a][error_sum[1]]+1;

        func[2] = tc0_table[index_a][error_sum[2]]+1;

        func[3] = tc0_table[index_a][error_sum[3]]+1;

        s->h264dsp.h264_h_loop_filter_chroma(gen_jr, xenevtchn_open, alpha, beta, func);

    } else {

        s->h264dsp.h264_h_loop_filter_chroma_intra(gen_jr, xenevtchn_open, alpha, beta);

    }

}
",0,0,0,-1,pix,2.9141083359718323e-05,6,26,"{'qp': 'LM32_CPU', 'stride': 'xenevtchn_open', 'h': 's', 'tc': 'func', 'bS': 'error_sum', 'pix': 'gen_jr'}",MHM-Origin,400,0.17334773143132529
393,"static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,

                                      int w, int h)

{

    ImageContext *img;

    HuffReader *hg;

    int i, j, ret, x, y, width;



    img       = &s->image[role];

    img->role = role;



    if (!img->frame) {

        img->frame = av_frame_alloc();

        if (!img->frame)

            return AVERROR(ENOMEM);

    }



    img->frame->format = AV_PIX_FMT_ARGB;

    img->frame->width  = w;

    img->frame->height = h;



    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {

        ThreadFrame pt = { .f = img->frame };

        ret = ff_thread_get_buffer(s->avctx, &pt, 0);

    } else

        ret = av_frame_get_buffer(img->frame, 1);

    if (ret < 0)

        return ret;



    if (get_bits1(&s->gb)) {

        img->color_cache_bits = get_bits(&s->gb, 4);

        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {

            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d\n"",

                   img->color_cache_bits);

            return AVERROR_INVALIDDATA;

        }

        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,

                                            sizeof(*img->color_cache));

        if (!img->color_cache)

            return AVERROR(ENOMEM);

    } else {

        img->color_cache_bits = 0;

    }



    img->nb_huffman_groups = 1;

    if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {

        ret = decode_entropy_image(s);

        if (ret < 0)

            return ret;

        img->nb_huffman_groups = s->nb_huffman_groups;

    }

    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *

                                           HUFFMAN_CODES_PER_META_CODE,

                                           sizeof(*img->huffman_groups));

    if (!img->huffman_groups)

        return AVERROR(ENOMEM);



    for (i = 0; i < img->nb_huffman_groups; i++) {

        hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];

        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {

            int alphabet_size = alphabet_sizes[j];

            if (!j && img->color_cache_bits > 0)

                alphabet_size += 1 << img->color_cache_bits;



            if (get_bits1(&s->gb)) {

                read_huffman_code_simple(s, &hg[j]);

            } else {

                ret = read_huffman_code_normal(s, &hg[j], alphabet_size);

                if (ret < 0)

                    return ret;

            }

        }

    }



    width = img->frame->width;

    if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0)

        width = s->reduced_width;



    x = 0; y = 0;

    while (y < img->frame->height) {

        int v;



        hg = get_huffman_group(s, img, x, y);

        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb);

        if (v < NUM_LITERAL_CODES) {

            /* literal pixel values */

            uint8_t *p = GET_PIXEL(img->frame, x, y);

            p[2] = v;

            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &s->gb);

            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &s->gb);

            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb);

            if (img->color_cache_bits)

                color_cache_put(img, AV_RB32(p));

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {

            /* LZ77 backwards mapping */

            int prefix_code, length, distance, ref_x, ref_y;



            /* parse length and distance */

            prefix_code = v - NUM_LITERAL_CODES;

            if (prefix_code < 4) {

                length = prefix_code + 1;

            } else {

                int extra_bits = (prefix_code - 2) >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                length = offset + get_bits(&s->gb, extra_bits) + 1;

            }

            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb);

            if (prefix_code > 39) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""distance prefix code too large: %d\n"", prefix_code);

                return AVERROR_INVALIDDATA;

            }

            if (prefix_code < 4) {

                distance = prefix_code + 1;

            } else {

                int extra_bits = prefix_code - 2 >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                distance = offset + get_bits(&s->gb, extra_bits) + 1;

            }



            /* find reference location */

            if (distance <= NUM_SHORT_DISTANCES) {

                int xi = lz77_distance_offsets[distance - 1][0];

                int yi = lz77_distance_offsets[distance - 1][1];

                distance = FFMAX(1, xi + yi * width);

            } else {

                distance -= NUM_SHORT_DISTANCES;

            }

            ref_x = x;

            ref_y = y;

            if (distance <= x) {

                ref_x -= distance;

                distance = 0;

            } else {

                ref_x = 0;

                distance -= x;

            }

            while (distance >= width) {

                ref_y--;

                distance -= width;

            }

            if (distance > 0) {

                ref_x = width - distance;

                ref_y--;

            }

            ref_x = FFMAX(0, ref_x);

            ref_y = FFMAX(0, ref_y);



            /* copy pixels

             * source and dest regions can overlap and wrap lines, so just

             * copy per-pixel */

            for (i = 0; i < length; i++) {

                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);

                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);



                AV_COPY32(p, p_ref);

                if (img->color_cache_bits)

                    color_cache_put(img, AV_RB32(p));

                x++;

                ref_x++;

                if (x == width) {

                    x = 0;

                    y++;

                }

                if (ref_x == width) {

                    ref_x = 0;

                    ref_y++;

                }

                if (y == img->frame->height || ref_y == img->frame->height)

                    break;

            }

        } else {

            /* read from color cache */

            uint8_t *p = GET_PIXEL(img->frame, x, y);

            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);



            if (!img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR, ""color cache not found\n"");

                return AVERROR_INVALIDDATA;

            }

            if (cache_idx >= 1 << img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""color cache index out-of-bounds\n"");

                return AVERROR_INVALIDDATA;

            }

            AV_WB32(p, img->color_cache[cache_idx]);

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        }

    }



    return 0;

}
",1236,"static int decode_entropy_coded_image(WebPContext *s, enum ImageRole TCG_COND_GTU,

                                      int w, int h)

{

    ImageContext *img;

    HuffReader *S;

    int forward_reference, vpd_page83, VMFS, virtio_common_init, boot_order, width;



    img       = &s->image[TCG_COND_GTU];

    img->TCG_COND_GTU = TCG_COND_GTU;



    if (!img->frame) {

        img->frame = av_frame_alloc();

        if (!img->frame)

            return AVERROR(ENOMEM);

    }



    img->frame->format = AV_PIX_FMT_ARGB;

    img->frame->width  = w;

    img->frame->height = h;



    if (TCG_COND_GTU == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {

        ThreadFrame pt = { .f = img->frame };

        VMFS = ff_thread_get_buffer(s->avctx, &pt, 0);

    } else

        VMFS = av_frame_get_buffer(img->frame, 1);

    if (VMFS < 0)

        return VMFS;



    if (get_bits1(&s->gb)) {

        img->color_cache_bits = get_bits(&s->gb, 4);

        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {

            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d
"",

                   img->color_cache_bits);

            return AVERROR_INVALIDDATA;

        }

        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,

                                            sizeof(*img->color_cache));

        if (!img->color_cache)

            return AVERROR(ENOMEM);

    } else {

        img->color_cache_bits = 0;

    }



    img->nb_huffman_groups = 1;

    if (TCG_COND_GTU == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {

        VMFS = decode_entropy_image(s);

        if (VMFS < 0)

            return VMFS;

        img->nb_huffman_groups = s->nb_huffman_groups;

    }

    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *

                                           HUFFMAN_CODES_PER_META_CODE,

                                           sizeof(*img->huffman_groups));

    if (!img->huffman_groups)

        return AVERROR(ENOMEM);



    for (forward_reference = 0; forward_reference < img->nb_huffman_groups; forward_reference++) {

        S = &img->huffman_groups[forward_reference * HUFFMAN_CODES_PER_META_CODE];

        for (vpd_page83 = 0; vpd_page83 < HUFFMAN_CODES_PER_META_CODE; vpd_page83++) {

            int alphabet_size = alphabet_sizes[vpd_page83];

            if (!vpd_page83 && img->color_cache_bits > 0)

                alphabet_size += 1 << img->color_cache_bits;



            if (get_bits1(&s->gb)) {

                read_huffman_code_simple(s, &S[vpd_page83]);

            } else {

                VMFS = read_huffman_code_normal(s, &S[vpd_page83], alphabet_size);

                if (VMFS < 0)

                    return VMFS;

            }

        }

    }



    width = img->frame->width;

    if (TCG_COND_GTU == IMAGE_ROLE_ARGB && s->reduced_width > 0)

        width = s->reduced_width;



    virtio_common_init = 0; boot_order = 0;

    while (boot_order < img->frame->height) {

        int ALT_CODE;



        S = get_huffman_group(s, img, virtio_common_init, boot_order);

        ALT_CODE = huff_reader_get_symbol(&S[HUFF_IDX_GREEN], &s->gb);

        if (ALT_CODE < NUM_LITERAL_CODES) {

            /* literal pixel values */

            uint8_t *p = GET_PIXEL(img->frame, virtio_common_init, boot_order);

            p[2] = ALT_CODE;

            p[1] = huff_reader_get_symbol(&S[HUFF_IDX_RED],   &s->gb);

            p[3] = huff_reader_get_symbol(&S[HUFF_IDX_BLUE],  &s->gb);

            p[0] = huff_reader_get_symbol(&S[HUFF_IDX_ALPHA], &s->gb);

            if (img->color_cache_bits)

                color_cache_put(img, AV_RB32(p));

            virtio_common_init++;

            if (virtio_common_init == width) {

                virtio_common_init = 0;

                boot_order++;

            }

        } else if (ALT_CODE < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {

            /* LZ77 backwards mapping */

            int prefix_code, LM32CPU, distance, er, ref_y;



            /* parse length and distance */

            prefix_code = ALT_CODE - NUM_LITERAL_CODES;

            if (prefix_code < 4) {

                LM32CPU = prefix_code + 1;

            } else {

                int extra_bits = (prefix_code - 2) >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                LM32CPU = offset + get_bits(&s->gb, extra_bits) + 1;

            }

            prefix_code = huff_reader_get_symbol(&S[HUFF_IDX_DIST], &s->gb);

            if (prefix_code > 39) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""distance prefix code too large: %d
"", prefix_code);

                return AVERROR_INVALIDDATA;

            }

            if (prefix_code < 4) {

                distance = prefix_code + 1;

            } else {

                int extra_bits = prefix_code - 2 >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                distance = offset + get_bits(&s->gb, extra_bits) + 1;

            }



            /* find reference location */

            if (distance <= NUM_SHORT_DISTANCES) {

                int xi = lz77_distance_offsets[distance - 1][0];

                int yi = lz77_distance_offsets[distance - 1][1];

                distance = FFMAX(1, xi + yi * width);

            } else {

                distance -= NUM_SHORT_DISTANCES;

            }

            er = virtio_common_init;

            ref_y = boot_order;

            if (distance <= virtio_common_init) {

                er -= distance;

                distance = 0;

            } else {

                er = 0;

                distance -= virtio_common_init;

            }

            while (distance >= width) {

                ref_y--;

                distance -= width;

            }

            if (distance > 0) {

                er = width - distance;

                ref_y--;

            }

            er = FFMAX(0, er);

            ref_y = FFMAX(0, ref_y);



            /* copy pixels

             * source and dest regions can overlap and wrap lines, so just

             * copy per-pixel */

            for (forward_reference = 0; forward_reference < LM32CPU; forward_reference++) {

                uint8_t *metadata_streams_autocopy = GET_PIXEL(img->frame, er, ref_y);

                uint8_t *p     = GET_PIXEL(img->frame,     virtio_common_init,     boot_order);



                AV_COPY32(p, metadata_streams_autocopy);

                if (img->color_cache_bits)

                    color_cache_put(img, AV_RB32(p));

                virtio_common_init++;

                er++;

                if (virtio_common_init == width) {

                    virtio_common_init = 0;

                    boot_order++;

                }

                if (er == width) {

                    er = 0;

                    ref_y++;

                }

                if (boot_order == img->frame->height || ref_y == img->frame->height)

                    break;

            }

        } else {

            /* read from color cache */

            uint8_t *p = GET_PIXEL(img->frame, virtio_common_init, boot_order);

            int cache_idx = ALT_CODE - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);



            if (!img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR, ""color cache not found
"");

                return AVERROR_INVALIDDATA;

            }

            if (cache_idx >= 1 << img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""color cache index out-of-bounds
"");

                return AVERROR_INVALIDDATA;

            }

            AV_WB32(p, img->color_cache[cache_idx]);

            virtio_common_init++;

            if (virtio_common_init == width) {

                virtio_common_init = 0;

                boot_order++;

            }

        }

    }



    return 0;

}
",1,1,1,-1,length,0.0,11,98,"{'i': 'forward_reference', 'x': 'virtio_common_init', 'hg': 'S', 'ret': 'VMFS', 'role': 'TCG_COND_GTU', 'ref_x': 'er', 'length': 'LM32CPU', 'j': 'vpd_page83', 'y': 'boot_order', 'p_ref': 'metadata_streams_autocopy', 'v': 'ALT_CODE'}",MHM-Origin,397,0.24485762119293214
394,"void ff_mspel_motion(MpegEncContext *s,

                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,

                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],

                               int motion_x, int motion_y, int h)

{

    Wmv2Context * const w= (Wmv2Context*)s;

    uint8_t *ptr;

    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;

    int emu=0;



    dxy = ((motion_y & 1) << 1) | (motion_x & 1);

    dxy = 2*dxy + w->hshift;

    src_x = s->mb_x * 16 + (motion_x >> 1);

    src_y = s->mb_y * 16 + (motion_y >> 1);



    /* WARNING: do no forget half pels */

    v_edge_pos = s->v_edge_pos;

    src_x = av_clip(src_x, -16, s->width);

    src_y = av_clip(src_y, -16, s->height);



    if(src_x<=-16 || src_x >= s->width)

        dxy &= ~3;

    if(src_y<=-16 || src_y >= s->height)

        dxy &= ~4;



    linesize   = s->linesize;

    uvlinesize = s->uvlinesize;

    ptr = ref_picture[0] + (src_y * linesize) + src_x;



        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos

                              || src_y + h+1 >= v_edge_pos){

            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,

                             src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos);

            ptr= s->edge_emu_buffer + 1 + s->linesize;

            emu=1;

        }



    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);



    if(s->flags&CODEC_FLAG_GRAY) return;



    if (s->out_format == FMT_H263) {

        dxy = 0;

        if ((motion_x & 3) != 0)

            dxy |= 1;

        if ((motion_y & 3) != 0)

            dxy |= 2;

        mx = motion_x >> 2;

        my = motion_y >> 2;

    } else {

        mx = motion_x / 2;

        my = motion_y / 2;

        dxy = ((my & 1) << 1) | (mx & 1);

        mx >>= 1;

        my >>= 1;

    }



    src_x = s->mb_x * 8 + mx;

    src_y = s->mb_y * 8 + my;

    src_x = av_clip(src_x, -8, s->width >> 1);

    if (src_x == (s->width >> 1))

        dxy &= ~1;

    src_y = av_clip(src_y, -8, s->height >> 1);

    if (src_y == (s->height >> 1))

        dxy &= ~2;

    offset = (src_y * uvlinesize) + src_x;

    ptr = ref_picture[1] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);

        ptr= s->edge_emu_buffer;

    }

    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);



    ptr = ref_picture[2] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);

        ptr= s->edge_emu_buffer;

    }

    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);

}
",760,"void ff_mspel_motion(MpegEncContext *s,

                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,

                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],

                               int motion_x, int motion_y, int h)

{

    Wmv2Context * const w= (Wmv2Context*)s;

    uint8_t *ptr;

    int dxy, offset, mx, my, src_x, src_y, dest, linesize, uvlinesize;

    int emu=0;



    dxy = ((motion_y & 1) << 1) | (motion_x & 1);

    dxy = 2*dxy + w->hshift;

    src_x = s->mb_x * 16 + (motion_x >> 1);

    src_y = s->mb_y * 16 + (motion_y >> 1);



    /* WARNING: do no forget half pels */

    dest = s->dest;

    src_x = av_clip(src_x, -16, s->width);

    src_y = av_clip(src_y, -16, s->height);



    if(src_x<=-16 || src_x >= s->width)

        dxy &= ~3;

    if(src_y<=-16 || src_y >= s->height)

        dxy &= ~4;



    linesize   = s->linesize;

    uvlinesize = s->uvlinesize;

    ptr = ref_picture[0] + (src_y * linesize) + src_x;



        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos

                              || src_y + h+1 >= dest){

            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,

                             src_x-1, src_y-1, s->h_edge_pos, s->dest);

            ptr= s->edge_emu_buffer + 1 + s->linesize;

            emu=1;

        }



    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);



    if(s->flags&CODEC_FLAG_GRAY) return;



    if (s->out_format == FMT_H263) {

        dxy = 0;

        if ((motion_x & 3) != 0)

            dxy |= 1;

        if ((motion_y & 3) != 0)

            dxy |= 2;

        mx = motion_x >> 2;

        my = motion_y >> 2;

    } else {

        mx = motion_x / 2;

        my = motion_y / 2;

        dxy = ((my & 1) << 1) | (mx & 1);

        mx >>= 1;

        my >>= 1;

    }



    src_x = s->mb_x * 8 + mx;

    src_y = s->mb_y * 8 + my;

    src_x = av_clip(src_x, -8, s->width >> 1);

    if (src_x == (s->width >> 1))

        dxy &= ~1;

    src_y = av_clip(src_y, -8, s->height >> 1);

    if (src_y == (s->height >> 1))

        dxy &= ~2;

    offset = (src_y * uvlinesize) + src_x;

    ptr = ref_picture[1] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->dest>>1);

        ptr= s->edge_emu_buffer;

    }

    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);



    ptr = ref_picture[2] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->dest>>1);

        ptr= s->edge_emu_buffer;

    }

    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);

}
",1,1,0,1,v_edge_pos,-0.06155076622962952,1,7,{'v_edge_pos': 'dest'},MHM-Origin,21,0.0098808487256368
395,"static int svq1_encode_plane(SVQ1Context *s, int plane,

                             unsigned char *src_plane,

                             unsigned char *ref_plane,

                             unsigned char *decoded_plane,

                             int width, int height, int src_stride, int stride)

{

    const AVFrame *f = s->avctx->coded_frame;

    int x, y;

    int i;

    int block_width, block_height;

    int level;

    int threshold[6];

    uint8_t *src     = s->scratchbuf + stride * 16;

    const int lambda = (f->quality * f->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    threshold[5] = QUALITY_THRESHOLD;

    for (level = 4; level >= 0; level--)

        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    block_height = (height + 15) / 16;



    if (f->pict_type == AV_PICTURE_TYPE_P) {

        s->m.avctx                         = s->avctx;

        s->m.current_picture_ptr           = &s->m.current_picture;

        s->m.last_picture_ptr              = &s->m.last_picture;

        s->m.last_picture.f.data[0]        = ref_plane;

        s->m.linesize                      =

        s->m.last_picture.f.linesize[0]    =

        s->m.new_picture.f.linesize[0]     =

        s->m.current_picture.f.linesize[0] = stride;

        s->m.width                         = width;

        s->m.height                        = height;

        s->m.mb_width                      = block_width;

        s->m.mb_height                     = block_height;

        s->m.mb_stride                     = s->m.mb_width + 1;

        s->m.b8_stride                     = 2 * s->m.mb_width + 1;

        s->m.f_code                        = 1;

        s->m.pict_type                     = f->pict_type;

        s->m.me_method                     = s->avctx->me_method;

        s->m.me.scene_change_score         = 0;

        s->m.flags                         = s->avctx->flags;

        // s->m.out_format                    = FMT_H263;

        // s->m.unrestricted_mv               = 1;

        s->m.lambda                        = f->quality;

        s->m.qscale                        = s->m.lambda * 139 +

                                             FF_LAMBDA_SCALE * 64 >>

                                             FF_LAMBDA_SHIFT + 7;

        s->m.lambda2                       = s->m.lambda * s->m.lambda +

                                             FF_LAMBDA_SCALE / 2 >>

                                             FF_LAMBDA_SHIFT;



        if (!s->motion_val8[plane]) {

            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *

                                                 block_height * 2 + 2) *

                                                2 * sizeof(int16_t));

            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *

                                                 (block_height + 2) + 1) *

                                                2 * sizeof(int16_t));

        }



        s->m.mb_type = s->mb_type;



        // dummies, to avoid segfaults

        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;

        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;

        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;

        s->m.current_picture.mb_type = s->dummy;



        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;

        s->m.p_mv_table                      = s->motion_val16[plane] +

                                               s->m.mb_stride + 1;

        s->m.dsp                             = s->dsp; // move

        ff_init_me(&s->m);



        s->m.me.dia_size      = s->avctx->dia_size;

        s->m.first_slice_line = 1;

        for (y = 0; y < block_height; y++) {

            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly

            s->m.mb_y                  = y;



            for (i = 0; i < 16 && i + 16 * y < height; i++) {

                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                       width);

                for (x = width; x < 16 * block_width; x++)

                    src[i * stride + x] = src[i * stride + x - 1];

            }

            for (; i < 16 && i + 16 * y < 16 * block_height; i++)

                memcpy(&src[i * stride], &src[(i - 1) * stride],

                       16 * block_width);



            for (x = 0; x < block_width; x++) {

                s->m.mb_x = x;

                ff_init_block_index(&s->m);

                ff_update_block_index(&s->m);



                ff_estimate_p_frame_motion(&s->m, x, y);

            }

            s->m.first_slice_line = 0;

        }



        ff_fix_long_p_mvs(&s->m);

        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,

                        CANDIDATE_MB_TYPE_INTER, 0);

    }



    s->m.first_slice_line = 1;

    for (y = 0; y < block_height; y++) {

        for (i = 0; i < 16 && i + 16 * y < height; i++) {

            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                   width);

            for (x = width; x < 16 * block_width; x++)

                src[i * stride + x] = src[i * stride + x - 1];

        }

        for (; i < 16 && i + 16 * y < 16 * block_height; i++)

            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);



        s->m.mb_y = y;

        for (x = 0; x < block_width; x++) {

            uint8_t reorder_buffer[3][6][7 * 32];

            int count[3][6];

            int offset       = y * 16 * stride + x * 16;

            uint8_t *decoded = decoded_plane + offset;

            uint8_t *ref     = ref_plane + offset;

            int score[4]     = { 0, 0, 0, 0 }, best;

            uint8_t *temp    = s->scratchbuf;



            if (s->pb.buf_end - s->pb.buf -

                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size

                av_log(s->avctx, AV_LOG_ERROR, ""encoded frame too large\n"");

                return -1;

            }



            s->m.mb_x = x;

            ff_init_block_index(&s->m);

            ff_update_block_index(&s->m);



            if (f->pict_type == AV_PICTURE_TYPE_I ||

                (s->m.mb_type[x + y * s->m.mb_stride] &

                 CANDIDATE_MB_TYPE_INTRA)) {

                for (i = 0; i < 6; i++)

                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],

                                  7 * 32);

                if (f->pict_type == AV_PICTURE_TYPE_P) {

                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);

                    score[0] = vlc[1] * lambda;

                }

                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,

                                         5, 64, lambda, 1);

                for (i = 0; i < 6; i++) {

                    count[0][i] = put_bits_count(&s->reorder_pb[i]);

                    flush_put_bits(&s->reorder_pb[i]);

                }

            } else

                score[0] = INT_MAX;



            best = 0;



            if (f->pict_type == AV_PICTURE_TYPE_P) {

                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, my, pred_x, pred_y, dxy;

                int16_t *motion_ptr;



                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);

                if (s->m.mb_type[x + y * s->m.mb_stride] &

                    CANDIDATE_MB_TYPE_INTER) {

                    for (i = 0; i < 6; i++)

                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],

                                      7 * 32);



                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);



                    s->m.pb = s->reorder_pb[5];

                    mx      = motion_ptr[0];

                    my      = motion_ptr[1];

                    assert(mx     >= -32 && mx     <= 31);

                    assert(my     >= -32 && my     <= 31);

                    assert(pred_x >= -32 && pred_x <= 31);

                    assert(pred_y >= -32 && pred_y <= 31);

                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);

                    ff_h263_encode_motion(&s->m, my - pred_y, 1);

                    s->reorder_pb[5] = s->m.pb;

                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);



                    dxy = (mx & 1) + 2 * (my & 1);



                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,

                                                   ref + (mx >> 1) +

                                                   stride * (my >> 1),

                                                   stride, 16);



                    score[1] += encode_block(s, src + 16 * x, temp + 16,

                                             decoded, stride, 5, 64, lambda, 0);

                    best      = score[1] <= score[0];



                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,

                                              stride, 16);

                    score[2] += vlc[1] * lambda;

                    if (score[2] < score[best] && mx == 0 && my == 0) {

                        best = 2;

                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);

                        for (i = 0; i < 6; i++)

                            count[2][i] = 0;

                        put_bits(&s->pb, vlc[1], vlc[0]);

                    }

                }



                if (best == 1) {

                    for (i = 0; i < 6; i++) {

                        count[1][i] = put_bits_count(&s->reorder_pb[i]);

                        flush_put_bits(&s->reorder_pb[i]);

                    }

                } else {

                    motion_ptr[0]                      =

                    motion_ptr[1]                      =

                    motion_ptr[2]                      =

                    motion_ptr[3]                      =

                    motion_ptr[0 + 2 * s->m.b8_stride] =

                    motion_ptr[1 + 2 * s->m.b8_stride] =

                    motion_ptr[2 + 2 * s->m.b8_stride] =

                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;

                }

            }



            s->rd_total += score[best];



            for (i = 5; i >= 0; i--)

                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],

                                 count[best][i]);

            if (best == 0)

                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);

        }

        s->m.first_slice_line = 0;

    }

    return 0;

}
",2180,"static int svq1_encode_plane(SVQ1Context *s, int FFSchroQueueElement,

                             unsigned char *bdrv_pwrite_sync,

                             unsigned char *ref_plane,

                             unsigned char *e3,

                             int width, int height, int src_stride, int stride)

{

    const AVFrame *f = s->avctx->coded_frame;

    int x, y;

    int i;

    int block_width, LM32CPU;

    int tcg_gen_qemu_st_i32;

    int QEMUFile[6];

    uint8_t *trace_mirror_start     = s->scratchbuf + stride * 16;

    const int lambda = (f->quality * f->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    QEMUFile[5] = QUALITY_THRESHOLD;

    for (tcg_gen_qemu_st_i32 = 4; tcg_gen_qemu_st_i32 >= 0; tcg_gen_qemu_st_i32--)

        QEMUFile[tcg_gen_qemu_st_i32] = QEMUFile[tcg_gen_qemu_st_i32 + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    LM32CPU = (height + 15) / 16;



    if (f->pict_type == AV_PICTURE_TYPE_P) {

        s->m.avctx                         = s->avctx;

        s->m.current_picture_ptr           = &s->m.current_picture;

        s->m.last_picture_ptr              = &s->m.last_picture;

        s->m.last_picture.f.data[0]        = ref_plane;

        s->m.linesize                      =

        s->m.last_picture.f.linesize[0]    =

        s->m.new_picture.f.linesize[0]     =

        s->m.current_picture.f.linesize[0] = stride;

        s->m.width                         = width;

        s->m.height                        = height;

        s->m.mb_width                      = block_width;

        s->m.mb_height                     = LM32CPU;

        s->m.mb_stride                     = s->m.mb_width + 1;

        s->m.b8_stride                     = 2 * s->m.mb_width + 1;

        s->m.f_code                        = 1;

        s->m.pict_type                     = f->pict_type;

        s->m.me_method                     = s->avctx->me_method;

        s->m.me.scene_change_score         = 0;

        s->m.flags                         = s->avctx->flags;

        // s->m.out_format                    = FMT_H263;

        // s->m.unrestricted_mv               = 1;

        s->m.lambda                        = f->quality;

        s->m.qscale                        = s->m.lambda * 139 +

                                             FF_LAMBDA_SCALE * 64 >>

                                             FF_LAMBDA_SHIFT + 7;

        s->m.lambda2                       = s->m.lambda * s->m.lambda +

                                             FF_LAMBDA_SCALE / 2 >>

                                             FF_LAMBDA_SHIFT;



        if (!s->motion_val8[FFSchroQueueElement]) {

            s->motion_val8[FFSchroQueueElement]  = av_mallocz((s->m.b8_stride *

                                                 LM32CPU * 2 + 2) *

                                                2 * sizeof(int16_t));

            s->motion_val16[FFSchroQueueElement] = av_mallocz((s->m.mb_stride *

                                                 (LM32CPU + 2) + 1) *

                                                2 * sizeof(int16_t));

        }



        s->m.mb_type = s->mb_type;



        // dummies, to avoid segfaults

        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;

        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;

        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;

        s->m.current_picture.mb_type = s->dummy;



        s->m.current_picture.motion_val[0]   = s->motion_val8[FFSchroQueueElement] + 2;

        s->m.p_mv_table                      = s->motion_val16[FFSchroQueueElement] +

                                               s->m.mb_stride + 1;

        s->m.dsp                             = s->dsp; // move

        ff_init_me(&s->m);



        s->m.me.dia_size      = s->avctx->dia_size;

        s->m.first_slice_line = 1;

        for (y = 0; y < LM32CPU; y++) {

            s->m.new_picture.f.data[0] = trace_mirror_start - y * 16 * stride; // ugly

            s->m.mb_y                  = y;



            for (i = 0; i < 16 && i + 16 * y < height; i++) {

                memcpy(&trace_mirror_start[i * stride], &bdrv_pwrite_sync[(i + 16 * y) * src_stride],

                       width);

                for (x = width; x < 16 * block_width; x++)

                    trace_mirror_start[i * stride + x] = trace_mirror_start[i * stride + x - 1];

            }

            for (; i < 16 && i + 16 * y < 16 * LM32CPU; i++)

                memcpy(&trace_mirror_start[i * stride], &trace_mirror_start[(i - 1) * stride],

                       16 * block_width);



            for (x = 0; x < block_width; x++) {

                s->m.mb_x = x;

                ff_init_block_index(&s->m);

                ff_update_block_index(&s->m);



                ff_estimate_p_frame_motion(&s->m, x, y);

            }

            s->m.first_slice_line = 0;

        }



        ff_fix_long_p_mvs(&s->m);

        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,

                        CANDIDATE_MB_TYPE_INTER, 0);

    }



    s->m.first_slice_line = 1;

    for (y = 0; y < LM32CPU; y++) {

        for (i = 0; i < 16 && i + 16 * y < height; i++) {

            memcpy(&trace_mirror_start[i * stride], &bdrv_pwrite_sync[(i + 16 * y) * src_stride],

                   width);

            for (x = width; x < 16 * block_width; x++)

                trace_mirror_start[i * stride + x] = trace_mirror_start[i * stride + x - 1];

        }

        for (; i < 16 && i + 16 * y < 16 * LM32CPU; i++)

            memcpy(&trace_mirror_start[i * stride], &trace_mirror_start[(i - 1) * stride], 16 * block_width);



        s->m.mb_y = y;

        for (x = 0; x < block_width; x++) {

            uint8_t reorder_buffer[3][6][7 * 32];

            int count[3][6];

            int offset       = y * 16 * stride + x * 16;

            uint8_t *decoded = e3 + offset;

            uint8_t *ref     = ref_plane + offset;

            int score[4]     = { 0, 0, 0, 0 }, best;

            uint8_t *temp    = s->scratchbuf;



            if (s->pb.buf_end - s->pb.buf -

                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size

                av_log(s->avctx, AV_LOG_ERROR, ""encoded frame too large
"");

                return -1;

            }



            s->m.mb_x = x;

            ff_init_block_index(&s->m);

            ff_update_block_index(&s->m);



            if (f->pict_type == AV_PICTURE_TYPE_I ||

                (s->m.mb_type[x + y * s->m.mb_stride] &

                 CANDIDATE_MB_TYPE_INTRA)) {

                for (i = 0; i < 6; i++)

                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],

                                  7 * 32);

                if (f->pict_type == AV_PICTURE_TYPE_P) {

                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);

                    score[0] = vlc[1] * lambda;

                }

                score[0] += encode_block(s, trace_mirror_start + 16 * x, NULL, temp, stride,

                                         5, 64, lambda, 1);

                for (i = 0; i < 6; i++) {

                    count[0][i] = put_bits_count(&s->reorder_pb[i]);

                    flush_put_bits(&s->reorder_pb[i]);

                }

            } else

                score[0] = INT_MAX;



            best = 0;



            if (f->pict_type == AV_PICTURE_TYPE_P) {

                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, my, pred_x, pred_y, dxy;

                int16_t *motion_ptr;



                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);

                if (s->m.mb_type[x + y * s->m.mb_stride] &

                    CANDIDATE_MB_TYPE_INTER) {

                    for (i = 0; i < 6; i++)

                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],

                                      7 * 32);



                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);



                    s->m.pb = s->reorder_pb[5];

                    mx      = motion_ptr[0];

                    my      = motion_ptr[1];

                    assert(mx     >= -32 && mx     <= 31);

                    assert(my     >= -32 && my     <= 31);

                    assert(pred_x >= -32 && pred_x <= 31);

                    assert(pred_y >= -32 && pred_y <= 31);

                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);

                    ff_h263_encode_motion(&s->m, my - pred_y, 1);

                    s->reorder_pb[5] = s->m.pb;

                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);



                    dxy = (mx & 1) + 2 * (my & 1);



                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,

                                                   ref + (mx >> 1) +

                                                   stride * (my >> 1),

                                                   stride, 16);



                    score[1] += encode_block(s, trace_mirror_start + 16 * x, temp + 16,

                                             decoded, stride, 5, 64, lambda, 0);

                    best      = score[1] <= score[0];



                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    score[2]  = s->dsp.sse[0](NULL, trace_mirror_start + 16 * x, ref,

                                              stride, 16);

                    score[2] += vlc[1] * lambda;

                    if (score[2] < score[best] && mx == 0 && my == 0) {

                        best = 2;

                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);

                        for (i = 0; i < 6; i++)

                            count[2][i] = 0;

                        put_bits(&s->pb, vlc[1], vlc[0]);

                    }

                }



                if (best == 1) {

                    for (i = 0; i < 6; i++) {

                        count[1][i] = put_bits_count(&s->reorder_pb[i]);

                        flush_put_bits(&s->reorder_pb[i]);

                    }

                } else {

                    motion_ptr[0]                      =

                    motion_ptr[1]                      =

                    motion_ptr[2]                      =

                    motion_ptr[3]                      =

                    motion_ptr[0 + 2 * s->m.b8_stride] =

                    motion_ptr[1 + 2 * s->m.b8_stride] =

                    motion_ptr[2 + 2 * s->m.b8_stride] =

                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;

                }

            }



            s->rd_total += score[best];



            for (i = 5; i >= 0; i--)

                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],

                                 count[best][i]);

            if (best == 0)

                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);

        }

        s->m.first_slice_line = 0;

    }

    return 0;

}
",1,1,0,1,level,-0.2874554693698883,7,45,"{'src': 'trace_mirror_start', 'decoded_plane': 'e3', 'src_plane': 'bdrv_pwrite_sync', 'threshold': 'QEMUFile', 'plane': 'FFSchroQueueElement', 'block_height': 'LM32CPU', 'level': 'tcg_gen_qemu_st_i32'}",MHM-Origin,154,0.11145355701446533
396,"static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,

                             int is_extradata)

{

    MMALDecodeContext *ctx = avctx->priv_data;

    AVBufferRef *buf = NULL;

    int size = 0;

    uint8_t *data = (uint8_t *)"""";

    uint8_t *start;

    int ret = 0;



    if (avpkt->size) {

        if (avpkt->buf) {

            buf = av_buffer_ref(avpkt->buf);

            size = avpkt->size;

            data = avpkt->data;

        } else {

            buf = av_buffer_alloc(avpkt->size);

            if (buf) {

                memcpy(buf->data, avpkt->data, avpkt->size);

                size = buf->size;

                data = buf->data;

            }

        }

        if (!buf) {

            ret = AVERROR(ENOMEM);

            goto done;

        }

        if (!is_extradata)

            ctx->packets_sent++;

    } else {

        if (!ctx->packets_sent) {

            // Short-cut the flush logic to avoid upsetting MMAL.

            ctx->eos_sent = 1;

            ctx->eos_received = 1;

            goto done;

        }

    }



    start = data;



    do {

        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));

        if (!buffer) {

            ret = AVERROR(ENOMEM);

            goto done;

        }



        buffer->data = data;

        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);



        if (is_extradata)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;



        if (data == start)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;



        data += buffer->length;

        size -= buffer->length;



        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;

        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;



        if (!size)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;



        if (!buffer->length) {

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;

            ctx->eos_sent = 1;

        }



        if (buf) {

            buffer->ref = av_buffer_ref(buf);

            if (!buffer->ref) {

                av_free(buffer);

                ret = AVERROR(ENOMEM);

                goto done;

            }

        }



        // Insert at end of the list

        if (!ctx->waiting_buffers)

            ctx->waiting_buffers = buffer;

        if (ctx->waiting_buffers_tail)

            ctx->waiting_buffers_tail->next = buffer;

        ctx->waiting_buffers_tail = buffer;

    } while (size);



done:

    av_buffer_unref(&buf);

    return ret;

}
",441,"static int ffmmal_add_packet(AVCodecContext *src_hz1, AVPacket *flat_start_offset,

                             int is_extradata)

{

    MMALDecodeContext *capabilities = src_hz1->priv_data;

    AVBufferRef *buf = NULL;

    int size = 0;

    uint8_t *dom = (uint8_t *)"""";

    uint8_t *SAMPLES_NEEDED_2;

    int ret = 0;



    if (flat_start_offset->size) {

        if (flat_start_offset->buf) {

            buf = av_buffer_ref(flat_start_offset->buf);

            size = flat_start_offset->size;

            dom = flat_start_offset->dom;

        } else {

            buf = av_buffer_alloc(flat_start_offset->size);

            if (buf) {

                memcpy(buf->dom, flat_start_offset->dom, flat_start_offset->size);

                size = buf->size;

                dom = buf->dom;

            }

        }

        if (!buf) {

            ret = AVERROR(ENOMEM);

            goto done;

        }

        if (!is_extradata)

            capabilities->parallel_hds++;

    } else {

        if (!capabilities->parallel_hds) {

            // Short-cut the flush logic to avoid upsetting MMAL.

            capabilities->eos_sent = 1;

            capabilities->eos_received = 1;

            goto done;

        }

    }



    SAMPLES_NEEDED_2 = dom;



    do {

        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));

        if (!buffer) {

            ret = AVERROR(ENOMEM);

            goto done;

        }



        buffer->dom = dom;

        buffer->length = FFMIN(size, capabilities->decoder->input[0]->buffer_size);



        if (is_extradata)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;



        if (dom == SAMPLES_NEEDED_2)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;



        dom += buffer->length;

        size -= buffer->length;



        buffer->pts = flat_start_offset->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : flat_start_offset->pts;

        buffer->dts = flat_start_offset->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : flat_start_offset->dts;



        if (!size)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;



        if (!buffer->length) {

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;

            capabilities->eos_sent = 1;

        }



        if (buf) {

            buffer->ref = av_buffer_ref(buf);

            if (!buffer->ref) {

                av_free(buffer);

                ret = AVERROR(ENOMEM);

                goto done;

            }

        }



        // Insert at end of the list

        if (!capabilities->waiting_buffers)

            capabilities->waiting_buffers = buffer;

        if (capabilities->waiting_buffers_tail)

            capabilities->waiting_buffers_tail->next = buffer;

        capabilities->waiting_buffers_tail = buffer;

    } while (size);



done:

    av_buffer_unref(&buf);

    return ret;

}
",1,1,0,1,data,-0.10822084546089172,6,44,"{'avpkt': 'flat_start_offset', 'avctx': 'src_hz1', 'ctx': 'capabilities', 'packets_sent': 'parallel_hds', 'start': 'SAMPLES_NEEDED_2', 'data': 'dom'}",MHM-Origin,137,0.06438218355178833
397,"static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)

{

    AVBitStreamFilterContext *bsfc = ost->bitstream_filters;

    AVCodecContext          *avctx = ost->st->codec;

    int ret;



    if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||

        (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))

        pkt->pts = pkt->dts = AV_NOPTS_VALUE;



    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) {

        int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);

        if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt->dts) {

            av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, ""Audio timestamp %""PRId64"" < %""PRId64"" invalid, cliping\n"", pkt->dts, max);

            pkt->pts = pkt->dts = max;





    /*

     * Audio encoders may split the packets --  #frames in != #packets out.

     * But there is no reordering, so we can limit the number of output packets

     * by simply dropping them here.

     * Counting encoded video frames needs to be done separately because of

     * reordering, see do_video_out()

     */

    if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) {

        if (ost->frame_number >= ost->max_frames) {

            av_free_packet(pkt);

            return;


        ost->frame_number++;




    while (bsfc) {

        AVPacket new_pkt = *pkt;

        int a = av_bitstream_filter_filter(bsfc, avctx, NULL,

                                           &new_pkt.data, &new_pkt.size,

                                           pkt->data, pkt->size,

                                           pkt->flags & AV_PKT_FLAG_KEY);











        if (a > 0) {

            av_free_packet(pkt);

            new_pkt.destruct = av_destruct_packet;

        } else if (a < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Failed to open bitstream filter %s for stream %d with codec %s"",

                   bsfc->filter->name, pkt->stream_index,

                   avctx->codec ? avctx->codec->name : ""copy"");

            print_error("""", a);

            if (exit_on_error)

                exit_program(1);


        *pkt = new_pkt;



        bsfc = bsfc->next;




    pkt->stream_index = ost->index;

    ret = av_interleaved_write_frame(s, pkt);

    if (ret < 0) {

        print_error(""av_interleaved_write_frame()"", ret);

        exit_program(1);

",391,"static void write_frame(AVFormatContext *reg2, AVPacket *lms_prevvalues, OutputStream *address)

{

    AVBitStreamFilterContext *on = address->bitstream_filters;

    AVCodecContext          *MSR_P6_EVNTSEL0 = address->st->codec;

    int file_index;



    if ((MSR_P6_EVNTSEL0->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||

        (MSR_P6_EVNTSEL0->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))

        lms_prevvalues->pts = lms_prevvalues->dts = AV_NOPTS_VALUE;



    if (MSR_P6_EVNTSEL0->codec_type == AVMEDIA_TYPE_AUDIO && lms_prevvalues->dts != AV_NOPTS_VALUE) {

        int64_t max = address->st->cur_dts + !(reg2->oformat->flags & AVFMT_TS_NONSTRICT);

        if (address->st->cur_dts && address->st->cur_dts != AV_NOPTS_VALUE &&  max > lms_prevvalues->dts) {

            av_log(reg2, max - lms_prevvalues->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, ""Audio timestamp %""PRId64"" < %""PRId64"" invalid, cliping
"", lms_prevvalues->dts, max);

            lms_prevvalues->pts = lms_prevvalues->dts = max;





    /*

     * Audio encoders may split the packets --  #frames in != #packets out.

     * But there is no reordering, so we can limit the number of output packets

     * by simply dropping them here.

     * Counting encoded video frames needs to be done separately because of

     * reordering, see do_video_out()

     */

    if (!(MSR_P6_EVNTSEL0->codec_type == AVMEDIA_TYPE_VIDEO && MSR_P6_EVNTSEL0->codec)) {

        if (address->SFENCE >= address->max_frames) {

            av_free_packet(lms_prevvalues);

            return;


        address->SFENCE++;




    while (on) {

        AVPacket new_pkt = *lms_prevvalues;

        int a = av_bitstream_filter_filter(on, MSR_P6_EVNTSEL0, NULL,

                                           &new_pkt.data, &new_pkt.size,

                                           lms_prevvalues->data, lms_prevvalues->size,

                                           lms_prevvalues->flags & AV_PKT_FLAG_KEY);











        if (a > 0) {

            av_free_packet(lms_prevvalues);

            new_pkt.destruct = av_destruct_packet;

        } else if (a < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Failed to open bitstream filter %s for stream %d with codec %s"",

                   on->filter->name, lms_prevvalues->stream_index,

                   MSR_P6_EVNTSEL0->codec ? MSR_P6_EVNTSEL0->codec->name : ""copy"");

            print_error("""", a);

            if (exit_on_error)

                exit_program(1);


        *lms_prevvalues = new_pkt;



        on = on->next;




    lms_prevvalues->stream_index = address->index;

    file_index = av_interleaved_write_frame(reg2, lms_prevvalues);

    if (file_index < 0) {

        print_error(""av_interleaved_write_frame()"", file_index);

        exit_program(1);

",1,1,1,-1,frame_number,0.00011658668518066406,7,54,"{'s': 'reg2', 'bsfc': 'on', 'avctx': 'MSR_P6_EVNTSEL0', 'pkt': 'lms_prevvalues', 'ret': 'file_index', 'frame_number': 'SFENCE', 'ost': 'address'}",MHM-Origin,398,0.18323177496592205

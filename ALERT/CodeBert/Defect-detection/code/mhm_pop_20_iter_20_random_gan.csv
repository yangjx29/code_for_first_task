Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,No. Changed Names,No. Changed Tokens,Replaced Names,Attack Type,Query Times,Time Cost
1,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *s = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int ring_order;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {


            goto out;

        }




        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->xendev.gnttabdev,

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        ring_order = xen_9pdev->rings[i].intf->ring_order;

        if (ring_order > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].ring_order = ring_order;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->xendev.gnttabdev,

                (1 << ring_order),

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(ring_order);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             xendev->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(xendev, 0,

                          ""xenevtchn_bind_interdomain failed port=%d\n"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(xendev, 2, ""bind evtchn port %d\n"", xendev->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(xendev, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(xendev, ""path"");

    xen_9pdev->id = s->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", xendev->dev);

    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, ""tag"");

    v9fs_register_transport(s, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            s->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(s, NULL);



    return 0;



out:

    xen_9pfs_free(xendev);

    return -1;

}",812,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *celt_output_samples = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int sps;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {


            goto out;

        }




        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->xendev.gnttabdev,

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        sps = xen_9pdev->rings[i].intf->sps;

        if (sps > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].sps = sps;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->xendev.gnttabdev,

                (1 << sps),

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(sps);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             xendev->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(xendev, 0,

                          ""xenevtchn_bind_interdomain failed port=%d
"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(xendev, 2, ""bind evtchn port %d
"", xendev->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(xendev, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(xendev, ""path"");

    xen_9pdev->id = celt_output_samples->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", xendev->dev);

    xen_9pdev->tag = celt_output_samples->fsconf.tag = xenstore_read_fe_str(xendev, ""tag"");

    v9fs_register_transport(celt_output_samples, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            celt_output_samples->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, celt_output_samples->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(celt_output_samples, NULL);



    return 0;



out:

    xen_9pfs_free(xendev);

    return -1;

}",1,1,0,1,s,-0.16662496328353882,2,15,"{'ring_order': 'sps', 's': 'celt_output_samples'}",MHM-Origin,43,0.011227126916249592
4,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    float aspect;



    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    s->aspect_ratio_info= get_bits(&s->gb, 4);

    if(!s->mpeg2){

        aspect= mpeg1_aspect[s->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        avctx->has_b_frames= 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        if (s->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            avctx->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        }

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_intra_matrix[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->inter_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_non_intra_matrix[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    avctx->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",753,"static int mpeg1_decode_sequence(AVCodecContext *SVM_EXIT_WRITE_CR0, 

                                 UINT8 *EM_LATTICEMICO32, int buf_size)

{

    Mpeg1Context *s1 = SVM_EXIT_WRITE_CR0->priv_data;

    MpegEncContext *gen_exts = &s1->mpeg_enc_ctx;

    int width, height, i, tcg_gen_shr_tl, j;

    float tcg_gen_qemu_ld16u;



    init_get_bits(&gen_exts->gb, EM_LATTICEMICO32, buf_size);



    width = get_bits(&gen_exts->gb, 12);

    height = get_bits(&gen_exts->gb, 12);

    gen_exts->aspect_ratio_info= get_bits(&gen_exts->gb, 4);

    if(!gen_exts->mpeg2){

        tcg_gen_qemu_ld16u= mpeg1_aspect[gen_exts->aspect_ratio_info];

        if(tcg_gen_qemu_ld16u!=0.0) SVM_EXIT_WRITE_CR0->aspect_ratio= width/(tcg_gen_qemu_ld16u*height);

    }



    gen_exts->frame_rate_index = get_bits(&gen_exts->gb, 4);

    if (gen_exts->frame_rate_index == 0)

        return -1;

    gen_exts->bit_rate = get_bits(&gen_exts->gb, 18) * 400;

    if (get_bits1(&gen_exts->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != gen_exts->width ||

        height != gen_exts->height) {

        /* start new mpeg1 context decoding */

        gen_exts->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(gen_exts);

        }

        gen_exts->width = width;

        gen_exts->height = height;

        SVM_EXIT_WRITE_CR0->has_b_frames= 1;

        gen_exts->SVM_EXIT_WRITE_CR0 = SVM_EXIT_WRITE_CR0;

        SVM_EXIT_WRITE_CR0->width = width;

        SVM_EXIT_WRITE_CR0->height = height;

        if (gen_exts->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            SVM_EXIT_WRITE_CR0->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            SVM_EXIT_WRITE_CR0->frame_rate = frame_rate_tab[gen_exts->frame_rate_index];

        }

        gen_exts->frame_rate = SVM_EXIT_WRITE_CR0->frame_rate;

        SVM_EXIT_WRITE_CR0->bit_rate = gen_exts->bit_rate;

        

        if (MPV_common_init(gen_exts) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&gen_exts->gb, 10); /* vbv_buffer_size */

    skip_bits(&gen_exts->gb, 1);



    /* get matrix */

    if (get_bits1(&gen_exts->gb)) {

        for(i=0;i<64;i++) {

            tcg_gen_shr_tl = get_bits(&gen_exts->gb, 8);

            j = gen_exts->intra_scantable.permutated[i];

            gen_exts->intra_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_intra_matrix[j] = tcg_gen_shr_tl;

        }

#ifdef DEBUG

        dprintf(""intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", gen_exts->intra_matrix[gen_exts->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= gen_exts->idct_permutation[i];

            tcg_gen_shr_tl = ff_mpeg1_default_intra_matrix[i];

            gen_exts->intra_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_intra_matrix[j] = tcg_gen_shr_tl;

        }

    }

    if (get_bits1(&gen_exts->gb)) {

        for(i=0;i<64;i++) {

            tcg_gen_shr_tl = get_bits(&gen_exts->gb, 8);

            j = gen_exts->intra_scantable.permutated[i];

            gen_exts->inter_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_inter_matrix[j] = tcg_gen_shr_tl;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", gen_exts->inter_matrix[gen_exts->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= gen_exts->idct_permutation[i];

            tcg_gen_shr_tl = ff_mpeg1_default_non_intra_matrix[i];

            gen_exts->inter_matrix[j] = tcg_gen_shr_tl;

            gen_exts->chroma_inter_matrix[j] = tcg_gen_shr_tl;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    gen_exts->progressive_sequence = 1;

    gen_exts->progressive_frame = 1;

    gen_exts->picture_structure = PICT_FRAME;

    gen_exts->frame_pred_frame_dct = 1;

    gen_exts->mpeg2 = 0;

    SVM_EXIT_WRITE_CR0->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",0,0,1,1,avctx,0.289772093296051,5,85,"{'s': 'gen_exts', 'buf': 'EM_LATTICEMICO32', 'v': 'tcg_gen_shr_tl', 'aspect': 'tcg_gen_qemu_ld16u', 'avctx': 'SVM_EXIT_WRITE_CR0'}",MHM-Origin,106,0.026799972852071127
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
",45,"static uint32_t drc_set_unusable(sPAPRDRConnector *f32)

{

    f32->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (f32->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(f32);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(f32);

    }



    return RTAS_OUT_SUCCESS;

}
",0,0,0,-1,drc,-0.006166285835206509,1,5,{'drc': 'RockerTlv'},MHM-Origin,410,0.09214642842610678
6,"static void scsi_read_request(SCSIDiskReq *r)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    if (r->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd\n"", r->iov.iov_len);

        r->sector_count = 0;

        scsi_req_data(&r->req, r->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d\n"", r->sector_count);

    if (r->sector_count == 0) {

        scsi_command_complete(r, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    n = r->sector_count;

    if (n > SCSI_DMA_BUF_SIZE / 512)

        n = SCSI_DMA_BUF_SIZE / 512;



    r->iov.iov_len = n * 512;

    qemu_iovec_init_external(&r->qiov, &r->iov, 1);

    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,

                              scsi_read_complete, r);

    if (r->req.aiocb == NULL) {

        scsi_read_complete(r, -EIO);

    }

}
",212,"static void scsi_read_request(SCSIDiskReq *help)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, help->req.dev);

    uint32_t n;



    if (help->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd
"", help->iov.iov_len);

        help->sector_count = 0;

        scsi_req_data(&help->req, help->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d
"", help->sector_count);

    if (help->sector_count == 0) {

        scsi_command_complete(help, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(help->req.aiocb == NULL);



    n = help->sector_count;

    if (n > SCSI_DMA_BUF_SIZE / 512)

        n = SCSI_DMA_BUF_SIZE / 512;



    help->iov.iov_len = n * 512;

    qemu_iovec_init_external(&help->qiov, &help->iov, 1);

    help->req.aiocb = bdrv_aio_readv(s->bs, help->sector, &help->qiov, n,

                              scsi_read_complete, help);

    if (help->req.aiocb == NULL) {

        scsi_read_complete(help, -EIO);

    }

}
",1,1,0,1,r,-0.08649405837059021,1,21,{'r': 'help'},MHM-Origin,22,0.005487481753031413
8,"aio_write_f(int argc, char **argv)

{

	char *p;

	int count = 0;

	int nr_iov, i, c;

	int pattern = 0xcd;

	struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((c = getopt(argc, argv, ""CqP:"")) != EOF) {

		switch (c) {

		case 'C':

			ctx->Cflag = 1;

			break;

		case 'q':

			ctx->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	ctx->offset = cvtnum(argv[optind]);

	if (ctx->offset < 0) {

		printf(""non-numeric length argument -- %s\n"", argv[optind]);

		return 0;

	}

	optind++;



	if (ctx->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)ctx->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned\n"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"", argv[i]);

			return 0;

		}

		count += len;

	}



	nr_iov = argc - optind;

	qemu_iovec_init(&ctx->qiov, nr_iov);

	ctx->buf = p = qemu_io_alloc(count, pattern);

	for (i = 0; i < nr_iov; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"",

				argv[optind]);

			return 0;

		}



		qemu_iovec_add(&ctx->qiov, p, len);

		p += len;

		optind++;

	}



	gettimeofday(&ctx->t1, NULL);

	acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,

			      ctx->qiov.size >> 9, aio_write_done, ctx);

	if (!acb)

		return -EIO;



	return 0;

}
",430,"aio_write_f(int argc, char **AV_OPT_TYPE_CONST)

{

	char *p;

	int count = 0;

	int nr_iov, i, TARGET_PAGE_BITS;

	int pattern = 0xcd;

	struct aio_ctx *nb = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((TARGET_PAGE_BITS = getopt(argc, AV_OPT_TYPE_CONST, ""CqP:"")) != EOF) {

		switch (TARGET_PAGE_BITS) {

		case 'C':

			nb->Cflag = 1;

			break;

		case 'q':

			nb->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	nb->offset = cvtnum(AV_OPT_TYPE_CONST[optind]);

	if (nb->offset < 0) {

		printf(""non-numeric length argument -- %s
"", AV_OPT_TYPE_CONST[optind]);

		return 0;

	}

	optind++;



	if (nb->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned
"",

			(long long)nb->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned
"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t features;



		features = cvtnum(AV_OPT_TYPE_CONST[optind]);

		if (features < 0) {

			printf(""non-numeric length argument -- %s
"", AV_OPT_TYPE_CONST[i]);

			return 0;

		}

		count += features;

	}



	nr_iov = argc - optind;

	qemu_iovec_init(&nb->qiov, nr_iov);

	nb->buf = p = qemu_io_alloc(count, pattern);

	for (i = 0; i < nr_iov; i++) {

	        size_t features;



		features = cvtnum(AV_OPT_TYPE_CONST[optind]);

		if (features < 0) {

			printf(""non-numeric length argument -- %s
"",

				AV_OPT_TYPE_CONST[optind]);

			return 0;

		}



		qemu_iovec_add(&nb->qiov, p, features);

		p += features;

		optind++;

	}



	gettimeofday(&nb->t1, NULL);

	acb = bdrv_aio_writev(bs, nb->offset >> 9, &nb->qiov,

			      nb->qiov.size >> 9, aio_write_done, nb);

	if (!acb)

		return -EIO;



	return 0;

}
",0,0,1,1,c,0.036008983850479126,4,35,"{'len': 'features', 'ctx': 'nb', 'argv': 'AV_OPT_TYPE_CONST', 'c': 'TARGET_PAGE_BITS'}",MHM-Origin,105,0.027933533986409506
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int r2_name, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += r2_name;

    }

}
",1,1,0,1,linesize,-0.3720974922180176,1,2,{'linesize': 'r2_name'},MHM-Origin,22,0.00502705971399943
12,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();",70,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t print_cvtnum_err;
    uint32_t parallel_cpus;
    print_cvtnum_err = T0 | ((uint64_t) (env->y) << 32);
    parallel_cpus = T1;
    print_cvtnum_err = print_cvtnum_err / parallel_cpus;
    if (print_cvtnum_err > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = print_cvtnum_err;
	T1 = 0;
    FORCE_RET();",1,1,1,-1,x0,-0.0017576217651367188,2,9,"{'x0': 'print_cvtnum_err', 'x1': 'parallel_cpus'}",MHM-Origin,406,0.09596405426661174
13,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
",26,"void cpu_x86_init_mmu(CPUX86State *vector_fmul_scalar)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(vector_fmul_scalar);

}
",0,0,1,1,env,0.6656311620026827,1,2,{'env': 'vector_fmul_scalar'},MHM-Origin,83,0.01885148286819458
14,"int qemu_cpu_self(void *env)

{

    return 1;

}
",12,"int qemu_cpu_self(void *XEN_FLEX_RING_SIZE)

{

    return 1;

}
",0,0,1,1,env,0.6036330051720142,1,1,{'env': 'XEN_FLEX_RING_SIZE'},MHM-Origin,21,0.004582202434539795
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
",104,"static void net_vhost_link_down(VhostUserState *meta, bool mbap)

{

    meta->nc.mbap = mbap;



    if (meta->nc.peer) {

        meta->nc.peer->mbap = mbap;

    }



    if (meta->nc.info->link_status_changed) {

        meta->nc.info->link_status_changed(&meta->nc);

    }



    if (meta->nc.peer && meta->nc.peer->info->link_status_changed) {

        meta->nc.peer->info->link_status_changed(meta->nc.peer);

    }

}
",0,0,0,-1,s,-0.02365579828619957,2,16,"{'s': 'LMI_HELPER_1', 'link_down': 'mbap'}",MHM-Origin,409,0.10525778929392497
18,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",38,"START_TEST(qint_get_int_test)

{

    QInt *last_pg_state;

    const int value = 123456;



    last_pg_state = qint_from_int(value);

    fail_unless(qint_get_int(last_pg_state) == value);



    QDECREF(last_pg_state);

}
",0,0,0,-1,qi,3.88086773455143e-05,1,4,{'qi': 'last_pg_state'},MHM-Origin,413,0.1030992070833842
19,"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
{
    uint8_t symbols[256];
    uint8_t bits[256];
    uint16_t codes[256];
    int num_lens, num_codes, num_codes_sum, prefix;
    int i, j, count;
    prefix        = 0;
    count         = 0;
    num_codes_sum = 0;
    num_lens = get_bits(gb, 5);
    for (i = 0; i < num_lens; i++) {
        num_codes      = get_bits(gb, 9);
        num_codes_sum += num_codes;
        if (num_codes_sum > 256) {
            av_log(ctx->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.\n"", num_codes_sum);
        for (j = 0; j < num_codes; j++) {
            symbols[count] = get_bits(gb, 8);
            bits[count]    = i + 1;
            codes[count]   = prefix++;
            count++;
        if (prefix > (65535 - 256)/2) {
        prefix <<= 1;
    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);",213,"static int read_code_table(CLLCContext *float_flag_invalid, GetBitContext *pix, VLC *coeffsA)
{
    uint8_t sigsetjmp[256];
    uint8_t delayed_samples[256];
    uint16_t codes[256];
    int num_lens, num_codes, xen_pv_printf, SIGP_STAT_INVALID_PARAMETER;
    int PR_SRS, unmap, qemu_input_queue_rel;
    SIGP_STAT_INVALID_PARAMETER        = 0;
    qemu_input_queue_rel         = 0;
    xen_pv_printf = 0;
    num_lens = get_bits(pix, 5);
    for (PR_SRS = 0; PR_SRS < num_lens; PR_SRS++) {
        num_codes      = get_bits(pix, 9);
        xen_pv_printf += num_codes;
        if (xen_pv_printf > 256) {
            av_log(float_flag_invalid->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.
"", xen_pv_printf);
        for (unmap = 0; unmap < num_codes; unmap++) {
            sigsetjmp[qemu_input_queue_rel] = get_bits(pix, 8);
            delayed_samples[qemu_input_queue_rel]    = PR_SRS + 1;
            codes[qemu_input_queue_rel]   = SIGP_STAT_INVALID_PARAMETER++;
            qemu_input_queue_rel++;
        if (SIGP_STAT_INVALID_PARAMETER > (65535 - 256)/2) {
        SIGP_STAT_INVALID_PARAMETER <<= 1;
    return ff_init_vlc_sparse(coeffsA, VLC_BITS, qemu_input_queue_rel, delayed_samples, 1, 1,
                              codes, 2, 2, sigsetjmp, 1, 1, 0);",1,1,1,-1,prefix,0.00013786554336547852,10,40,"{'gb': 'pix', 'j': 'unmap', 'symbols': 'sigsetjmp', 'num_codes_sum': 'xen_pv_printf', 'ctx': 'float_flag_invalid', 'bits': 'delayed_samples', 'vlc': 'coeffsA', 'count': 'qemu_input_queue_rel', 'i': 'PR_SRS', 'prefix': 'SIGP_STAT_INVALID_PARAMETER'}",MHM-Origin,407,0.11182309786478678
22,"static void usbredir_bulk_packet(void *priv, uint32_t id,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,

            ep, len, id);



    aurb = async_find(dev, id);

    if (!aurb) {

        free(data);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!\n"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->data, data, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)\n"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(data);

}
",241,"static void usbredir_bulk_packet(void *priv, uint32_t CPUX86State,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *av_pix_fmt_desc_get, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u
"", bulk_packet->status,

            ep, len, CPUX86State);



    aurb = async_find(dev, CPUX86State);

    if (!aurb) {

        free(av_pix_fmt_desc_get);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!
"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", av_pix_fmt_desc_get, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->av_pix_fmt_desc_get, av_pix_fmt_desc_get, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)
"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(av_pix_fmt_desc_get);

}
",1,1,0,1,id,-0.10312420129776001,2,9,"{'data': 'av_pix_fmt_desc_get', 'id': 'CPUX86State'}",MHM-Origin,86,0.024029990037282307
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
",167,"static int decode_plte_chunk(AVCodecContext *gen_io_end, PNGDecContext *RV34_MB_P_8x16,

                             uint32_t qemu_clock_get_ns)

{

    int MB_TYPE_16x8, MSR_IA32_MISC_ENABLE, ch, chr_can_read, TCG_TARGET_STACK_ALIGN;



    if ((qemu_clock_get_ns % 3) != 0 || qemu_clock_get_ns > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    MB_TYPE_16x8 = qemu_clock_get_ns / 3;

    for (MSR_IA32_MISC_ENABLE = 0; MSR_IA32_MISC_ENABLE < MB_TYPE_16x8; MSR_IA32_MISC_ENABLE++) {

        ch = bytestream2_get_byte(&RV34_MB_P_8x16->gb);

        chr_can_read = bytestream2_get_byte(&RV34_MB_P_8x16->gb);

        TCG_TARGET_STACK_ALIGN = bytestream2_get_byte(&RV34_MB_P_8x16->gb);

        RV34_MB_P_8x16->palette[MSR_IA32_MISC_ENABLE] = (0xFFU << 24) | (ch << 16) | (chr_can_read << 8) | TCG_TARGET_STACK_ALIGN;

    }

    for (; MSR_IA32_MISC_ENABLE < 256; MSR_IA32_MISC_ENABLE++)

        RV34_MB_P_8x16->palette[MSR_IA32_MISC_ENABLE] = (0xFFU << 24);

    RV34_MB_P_8x16->state |= PNG_PLTE;

    bytestream2_skip(&RV34_MB_P_8x16->gb, 4);     /* crc */



    return 0;

}
",1,1,1,-1,r,-0.01481848955154419,8,33,"{'i': 'MSR_IA32_MISC_ENABLE', 'g': 'chr_can_read', 's': 'RV34_MB_P_8x16', 'n': 'MB_TYPE_16x8', 'length': 'qemu_clock_get_ns', 'b': 'TCG_TARGET_STACK_ALIGN', 'avctx': 'gen_io_end', 'r': 'ch'}",MHM-Origin,409,0.11045731703440348
27,"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,

                              char **serial)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;

    DriveInfo *dinfo;



    if (!conf->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(conf->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(conf->bs);

        if (*dinfo->serial) {

            *serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = virtio_blk_reset;

    s->bs = conf->bs;

    s->conf = conf;

    s->serial = *serial;

    s->rq = NULL;

    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);



    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);

    s->qdev = dev;

    register_savevm(dev, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, s);

    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);

    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);



    bdrv_iostatus_enable(s->bs);

    add_boot_device_path(conf->bootindex, dev, ""/disk@0,0"");



    return &s->vdev;

}
",317,"VirtIODevice *virtio_blk_init(DeviceState *smp_threads, BlockConf *error_code,

                              char **info_str)

{

    VirtIOBlock *wctx;

    int AV_RL16, ff_celt_window2, session;

    static int virtio_blk_id;

    DriveInfo *new_area;



    if (!error_code->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(error_code->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*info_str) {

        /* try to fall back to value set with legacy -drive serial=... */

        new_area = drive_get_by_blockdev(error_code->bs);

        if (*new_area->info_str) {

            *info_str = strdup(new_area->info_str);

        }

    }



    wctx = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    wctx->vdev.get_config = virtio_blk_update_config;

    wctx->vdev.get_features = virtio_blk_get_features;

    wctx->vdev.reset = virtio_blk_reset;

    wctx->bs = error_code->bs;

    wctx->error_code = error_code;

    wctx->info_str = *info_str;

    wctx->rq = NULL;

    wctx->sector_mask = (wctx->error_code->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(wctx->bs, &AV_RL16, &ff_celt_window2, &session);



    wctx->vq = virtio_add_queue(&wctx->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, wctx);

    wctx->qdev = smp_threads;

    register_savevm(smp_threads, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, wctx);

    bdrv_set_dev_ops(wctx->bs, &virtio_block_ops, wctx);

    bdrv_set_buffer_alignment(wctx->bs, error_code->logical_block_size);



    bdrv_iostatus_enable(wctx->bs);

    add_boot_device_path(error_code->bootindex, smp_threads, ""/disk@0,0"");



    return &wctx->vdev;

}
",0,0,0,-1,dev,0.028233081102371216,8,53,"{'dev': 'smp_threads', 'cylinders': 'AV_RL16', 'heads': 'ff_celt_window2', 's': 'wctx', 'conf': 'error_code', 'serial': 'info_str', 'secs': 'session', 'dinfo': 'new_area'}",MHM-Origin,411,0.1136890172958374
30,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",31,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *MSR_KVM_PV_EOI_EN = container_of(listener, AddressSpaceDispatch, listener);



    MSR_KVM_PV_EOI_EN->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",0,0,1,1,d,0.6952594816684723,1,2,{'d': 'MSR_KVM_PV_EOI_EN'},MHM-Origin,24,0.00487820307413737
31,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",218,"static uint32_t tight_palette_buf2rgb(int htab_mask, const uint8_t *iov_size)

{

    uint32_t rgb = 0;



    if (htab_mask == 32) {

        rgb |= ((iov_size[0] & ~1) | !((iov_size[4] >> 3) & 1)) << 24;

        rgb |= ((iov_size[1] & ~1) | !((iov_size[4] >> 2) & 1)) << 16;

        rgb |= ((iov_size[2] & ~1) | !((iov_size[4] >> 1) & 1)) <<  8;

        rgb |= ((iov_size[3] & ~1) | !((iov_size[4] >> 0) & 1)) <<  0;

    }

    if (htab_mask == 16) {

        rgb |= ((iov_size[0] & ~1) | !((iov_size[2] >> 1) & 1)) << 8;

        rgb |= ((iov_size[1] & ~1) | !((iov_size[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",0,0,0,-1,bpp,0.03503997623920441,2,16,"{'bpp': 'htab_mask', 'buf': 'iov_size'}",MHM-Origin,413,0.09976395765940348
33,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",135,"void stream_start(const char *bflag, BlockDriverState *bs,

                  BlockDriverState *base, const char *MSR_IA32_XSS,

                  int64_t imsg, BlockdevOnError on_error,

                  BlockCompletionFunc *opt_xfer_len, void *opaque, Error **EXCP03_INT3)

{

    StreamBlockJob *s;



    s = block_job_create(bflag, &stream_job_driver, bs, imsg,

                         opt_xfer_len, opaque, EXCP03_INT3);

    if (!s) {

        return;

    }



    s->base = base;

    s->MSR_IA32_XSS = g_strdup(MSR_IA32_XSS);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",1,1,0,1,cb,-0.5214820504188538,5,11,"{'backing_file_str': 'MSR_IA32_XSS', 'job_id': 'bflag', 'speed': 'imsg', 'errp': 'EXCP03_INT3', 'cb': 'opt_xfer_len'}",MHM-Origin,106,0.025040547053019207
34,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    picture->extended_data = picture->data;
    return ret;
}",212,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *sub_packet_cnt, AVFrame *has_fds,
                                              int *ss,
                                              AVPacket *MSIMessage)
{
    int cluster_size;
    *ss = 0;
    if ((sub_packet_cnt->coded_width || sub_packet_cnt->coded_height) && av_image_check_size(sub_packet_cnt->coded_width, sub_packet_cnt->coded_height, 0, sub_packet_cnt))
        return -1;
    sub_packet_cnt->pkt = MSIMessage;
    apply_param_change(sub_packet_cnt, MSIMessage);
    if ((sub_packet_cnt->codec->capabilities & CODEC_CAP_DELAY) || MSIMessage->size || (sub_packet_cnt->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && sub_packet_cnt->active_thread_type & FF_THREAD_FRAME)
            cluster_size = ff_thread_decode_frame(sub_packet_cnt, has_fds, ss,
                                         MSIMessage);
        else {
            cluster_size = sub_packet_cnt->codec->decode(sub_packet_cnt, has_fds, ss,
                                       MSIMessage);
            has_fds->pkt_dts             = MSIMessage->dts;
            has_fds->sample_aspect_ratio = sub_packet_cnt->sample_aspect_ratio;
            has_fds->width               = sub_packet_cnt->width;
            has_fds->height              = sub_packet_cnt->height;
            has_fds->format              = sub_packet_cnt->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*ss)
            sub_packet_cnt->height++;
    } else
        cluster_size = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    has_fds->extended_data = has_fds->data;
    return cluster_size;
}",1,1,0,1,avctx,-0.3521466851234436,6,47,"{'frame_number': 'height', 'got_picture_ptr': 'ss', 'ret': 'cluster_size', 'picture': 'has_fds', 'avctx': 'sub_packet_cnt', 'avpkt': 'MSIMessage'}",MHM-Origin,361,0.09308491945266724
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
",117,"static int omap_gpio_init(SysBusDevice *pout)

{

    DeviceState *dev = DEVICE(pout);

    struct omap_gpif_s *MSR_MTRRfix64K_00000 = OMAP1_GPIO(dev);



    if (!MSR_MTRRfix64K_00000->clk) {

        hw_error(""omap-gpio: clk not connected
"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, MSR_MTRRfix64K_00000->omap1.handler, 16);

    sysbus_init_irq(pout, &MSR_MTRRfix64K_00000->omap1.irq);

    memory_region_init_io(&MSR_MTRRfix64K_00000->iomem, OBJECT(MSR_MTRRfix64K_00000), &omap_gpio_ops, &MSR_MTRRfix64K_00000->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(pout, &MSR_MTRRfix64K_00000->iomem);

    return 0;

}
",1,1,0,1,s,-0.3035371005535126,2,12,"{'sbd': 'pout', 's': 'MSR_MTRRfix64K_00000'}",MHM-Origin,43,0.009991772969563802
36,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
",52,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *duration_error)

{

    s->codec = duration_error;

    duration_error->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    duration_error->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
",1,1,0,1,slave,-0.4837663769721985,1,4,{'slave': 'duration_error'},MHM-Origin,22,0.004890338579813639
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}
",129,"int floatx80_eq(floatx80 tag_tree_decode, floatx80 mapped_len, float_status *rl_inter)

{



    if (    (    ( extractFloatx80Exp( tag_tree_decode ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( tag_tree_decode )<<1 ) )

         || (    ( extractFloatx80Exp( mapped_len ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( mapped_len )<<1 ) )

       ) {

        float_raise(float_flag_invalid, rl_inter);

        return 0;

    }

    return

           ( tag_tree_decode.low == mapped_len.low )

        && (    ( tag_tree_decode.high == mapped_len.high )

             || (    ( tag_tree_decode.low == 0 )

                  && ( (uint16_t) ( ( tag_tree_decode.high | mapped_len.high )<<1 ) == 0 ) )

           );



}
",0,0,0,-1,a,0.004547647200524807,3,15,"{'b': 'mapped_len', 'status': 'rl_inter', 'a': 'tag_tree_decode'}",MHM-Origin,409,0.09723429282506307
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
",42,"void json_lexer_init(JSONLexer *CC_OP_MULQ, JSONLexerEmitter data_len)

{

    CC_OP_MULQ->emit = data_len;

    CC_OP_MULQ->state = IN_START;

    CC_OP_MULQ->token = qstring_new();

    CC_OP_MULQ->x = CC_OP_MULQ->y = 0;

}
",0,0,0,-1,lexer,-0.26266613602638245,2,8,"{'func': 'gen_exception_cause', 'lexer': 'CC_OP_MULQ'}",MHM-Origin,414,0.09324201345443725
39,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque, int type)

{

    struct qemu_paiocb *acb;



    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!acb)

        return NULL;

    acb->aio_type = type;

    acb->aio_fildes = fd;

    acb->ev_signo = SIGUSR2;

    acb->async_context_id = get_async_context_id();



    if (qiov) {

        acb->aio_iov = qiov->iov;

        acb->aio_niov = qiov->niov;

    }

    acb->aio_nbytes = nb_sectors * 512;

    acb->aio_offset = sector_num * 512;



    acb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = acb;



    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);

    qemu_paio_submit(acb);

    return &acb->common;

}
",163,"BlockDriverAIOCB *paio_submit(BlockDriverState *cpu_x86_update_cr0, int MSR_CORE_PERF_GLOBAL_STATUS,

        int64_t qemu_irq_invert, QEMUIOVector *gen_helper_cpuid, int out_nofid,

        BlockDriverCompletionFunc *prefixes, void *my, int color_cache_put)

{

    struct qemu_paiocb *gen_helper_rdpmc;



    gen_helper_rdpmc = qemu_aio_get(&raw_aio_pool, cpu_x86_update_cr0, prefixes, my);

    if (!gen_helper_rdpmc)

        return NULL;

    gen_helper_rdpmc->aio_type = color_cache_put;

    gen_helper_rdpmc->aio_fildes = MSR_CORE_PERF_GLOBAL_STATUS;

    gen_helper_rdpmc->ev_signo = SIGUSR2;

    gen_helper_rdpmc->async_context_id = get_async_context_id();



    if (gen_helper_cpuid) {

        gen_helper_rdpmc->aio_iov = gen_helper_cpuid->iov;

        gen_helper_rdpmc->aio_niov = gen_helper_cpuid->niov;

    }

    gen_helper_rdpmc->aio_nbytes = out_nofid * 512;

    gen_helper_rdpmc->aio_offset = qemu_irq_invert * 512;



    gen_helper_rdpmc->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = gen_helper_rdpmc;



    trace_paio_submit(gen_helper_rdpmc, my, qemu_irq_invert, out_nofid, color_cache_put);

    qemu_paio_submit(gen_helper_rdpmc);

    return &gen_helper_rdpmc->common;

}
",0,0,1,1,fd,0.38882315903902054,9,38,"{'opaque': 'my', 'bs': 'cpu_x86_update_cr0', 'qiov': 'gen_helper_cpuid', 'sector_num': 'qemu_irq_invert', 'cb': 'prefixes', 'type': 'color_cache_put', 'nb_sectors': 'out_nofid', 'acb': 'gen_helper_rdpmc', 'fd': 'MSR_CORE_PERF_GLOBAL_STATUS'}",MHM-Origin,305,0.07555678685506186
43,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *boot_devices,

                        const char *kernel_filename, const char *kernel_cmdline,

                        const char *initrd_filename, const char *cpu_model,

                        const struct hwdef *hwdef)

{

    CPUState *env;

    char *filename;

    m48t59_t *nvram;

    int ret, linux_boot;

    unsigned int i;

    ram_addr_t ram_offset, prom_offset;

    long initrd_size, kernel_size;

    PCIBus *pci_bus, *pci_bus2, *pci_bus3;

    QEMUBH *bh;

    qemu_irq *irq;

    int drive_index;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    void *fw_cfg;

    ResetData *reset_info;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    bh = qemu_bh_new(tick_irq, env);

    env->tick = ptimer_init(bh);

    ptimer_set_period(env->tick, 1ULL);



    bh = qemu_bh_new(stick_irq, env);

    env->stick = ptimer_init(bh);

    ptimer_set_period(env->stick, 1ULL);



    bh = qemu_bh_new(hstick_irq, env);

    env->hstick = ptimer_init(bh);

    ptimer_set_period(env->hstick, 1ULL);



    reset_info = qemu_mallocz(sizeof(ResetData));

    reset_info->env = env;

    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;

    qemu_register_reset(main_cpu_reset, reset_info);

    main_cpu_reset(reset_info);

    // Override warm reset address with cold start address

    env->pc = hwdef->prom_addr + 0x20ULL;

    env->npc = env->pc + 4;



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->prom_addr,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,

                       NULL, NULL, NULL);

        if (ret < 0) {

            ret = load_image_targphys(filename, hwdef->prom_addr,

                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                  TARGET_PAGE_MASK);

        }

        qemu_free(filename);

    } else {

        ret = -1;

    }

    if (ret < 0) {

        fprintf(stderr, ""qemu: could not load prom '%s'\n"",

                bios_name);

        exit(1);

    }



    kernel_size = 0;

    initrd_size = 0;

    if (linux_boot) {

        /* XXX: put correct offset */

        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,

                                    ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              KERNEL_LOAD_ADDR,

                                              ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",

                    kernel_filename);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            initrd_size = load_image_targphys(initrd_filename,

                                              INITRD_LOAD_ADDR,

                                              ram_size - INITRD_LOAD_ADDR);

            if (initrd_size < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'\n"",

                        initrd_filename);

                exit(1);

            }

        }

        if (initrd_size > 0) {

            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {

                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS

                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);

                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);

                    break;

                }

            }

        }

    }

    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,

                           &pci_bus3);

    isa_mem_base = VGA_BASE;

    pci_vga_init(pci_bus, 0, 0);



    // XXX Should be pci_bus3

    pci_ebus_init(pci_bus, -1);



    i = 0;

    if (hwdef->console_serial_base) {

        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,

                       serial_hds[i], 1);

        i++;

    }

    for(; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,

                        serial_hds[i]);

        }

    }



    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {

        if (parallel_hds[i]) {

            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,

                          parallel_hds[i]);

        }

    }



    for(i = 0; i < nb_nics; i++)

        pci_nic_init(&nd_table[i], ""ne2k_pci"", NULL);



    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);

    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus\n"");

        exit(1);

    }

    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,

                                      i % MAX_IDE_DEVS);

       if (drive_index != -1)

           hd[i] = drives_table[drive_index].bdrv;

       else

           hd[i] = NULL;

    }



    pci_cmd646_ide_init(pci_bus, hd, 1);



    /* FIXME: wire up interrupts.  */

    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);

    for(i = 0; i < MAX_FD; i++) {

        drive_index = drive_get_index(IF_FLOPPY, 0, i);

       if (drive_index != -1)

           fd[i] = drives_table[drive_index].bdrv;

       else

           fd[i] = NULL;

    }

    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);

    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);

    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, ""Sun4u"", RAM_size, boot_devices,

                           KERNEL_LOAD_ADDR, kernel_size,

                           kernel_cmdline,

                           INITRD_LOAD_ADDR, initrd_size,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);

    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",1195,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *sysmem,

                        const char *kernel_filename, const char *kernel_cmdline,

                        const char *initrd_filename, const char *log_ctx,

                        const struct hwdef *hwdef)

{

    CPUState *spapr_drc_index;

    char *filename;

    m48t59_t *G_IO_ERR;

    int tone_level_idx_hi1, linux_boot;

    unsigned int model;

    ram_addr_t ram_offset, opc_info;

    long initrd_size, kernel_size;

    PCIBus *pci_bus, *ist_index, *pci_bus3;

    QEMUBH *bh;

    qemu_irq *g2h;

    int CC_A;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    void *do_shiftd;

    ResetData *reset_info;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (!log_ctx)

        log_ctx = hwdef->default_cpu_model;



    spapr_drc_index = cpu_init(log_ctx);

    if (!spapr_drc_index) {

        fprintf(stderr, ""Unable to find Sparc CPU definition
"");

        exit(1);

    }

    bh = qemu_bh_new(tick_irq, spapr_drc_index);

    spapr_drc_index->tick = ptimer_init(bh);

    ptimer_set_period(spapr_drc_index->tick, 1ULL);



    bh = qemu_bh_new(stick_irq, spapr_drc_index);

    spapr_drc_index->stick = ptimer_init(bh);

    ptimer_set_period(spapr_drc_index->stick, 1ULL);



    bh = qemu_bh_new(hstick_irq, spapr_drc_index);

    spapr_drc_index->hstick = ptimer_init(bh);

    ptimer_set_period(spapr_drc_index->hstick, 1ULL);



    reset_info = qemu_mallocz(sizeof(ResetData));

    reset_info->spapr_drc_index = spapr_drc_index;

    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;

    qemu_register_reset(main_cpu_reset, reset_info);

    main_cpu_reset(reset_info);

    // Override warm reset address with cold start address

    spapr_drc_index->pc = hwdef->prom_addr + 0x20ULL;

    spapr_drc_index->npc = spapr_drc_index->pc + 4;



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    opc_info = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->prom_addr,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                 TARGET_PAGE_MASK,

                                 opc_info | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        tone_level_idx_hi1 = load_elf(filename, hwdef->prom_addr - PROM_VADDR,

                       NULL, NULL, NULL);

        if (tone_level_idx_hi1 < 0) {

            tone_level_idx_hi1 = load_image_targphys(filename, hwdef->prom_addr,

                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                  TARGET_PAGE_MASK);

        }

        qemu_free(filename);

    } else {

        tone_level_idx_hi1 = -1;

    }

    if (tone_level_idx_hi1 < 0) {

        fprintf(stderr, ""qemu: could not load prom '%s'
"",

                bios_name);

        exit(1);

    }



    kernel_size = 0;

    initrd_size = 0;

    if (linux_boot) {

        /* XXX: put correct offset */

        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,

                                    ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              KERNEL_LOAD_ADDR,

                                              ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'
"",

                    kernel_filename);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            initrd_size = load_image_targphys(initrd_filename,

                                              INITRD_LOAD_ADDR,

                                              ram_size - INITRD_LOAD_ADDR);

            if (initrd_size < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'
"",

                        initrd_filename);

                exit(1);

            }

        }

        if (initrd_size > 0) {

            for (model = 0; model < 64 * TARGET_PAGE_SIZE; model += TARGET_PAGE_SIZE) {

                if (ldl_phys(KERNEL_LOAD_ADDR + model) == 0x48647253) { // HdrS

                    stl_phys(KERNEL_LOAD_ADDR + model + 16, INITRD_LOAD_ADDR);

                    stl_phys(KERNEL_LOAD_ADDR + model + 20, initrd_size);

                    break;

                }

            }

        }

    }

    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &ist_index,

                           &pci_bus3);

    isa_mem_base = VGA_BASE;

    pci_vga_init(pci_bus, 0, 0);



    // XXX Should be pci_bus3

    pci_ebus_init(pci_bus, -1);



    model = 0;

    if (hwdef->console_serial_base) {

        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,

                       serial_hds[model], 1);

        model++;

    }

    for(; model < MAX_SERIAL_PORTS; model++) {

        if (serial_hds[model]) {

            serial_init(serial_io[model], NULL/*serial_irq[i]*/, 115200,

                        serial_hds[model]);

        }

    }



    for(model = 0; model < MAX_PARALLEL_PORTS; model++) {

        if (parallel_hds[model]) {

            parallel_init(parallel_io[model], NULL/*parallel_irq[i]*/,

                          parallel_hds[model]);

        }

    }



    for(model = 0; model < nb_nics; model++)

        pci_nic_init(&nd_table[model], ""ne2k_pci"", NULL);



    g2h = qemu_allocate_irqs(cpu_set_irq, spapr_drc_index, MAX_PILS);

    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus
"");

        exit(1);

    }

    for(model = 0; model < MAX_IDE_BUS * MAX_IDE_DEVS; model++) {

        CC_A = drive_get_index(IF_IDE, model / MAX_IDE_DEVS,

                                      model % MAX_IDE_DEVS);

       if (CC_A != -1)

           hd[model] = drives_table[CC_A].bdrv;

       else

           hd[model] = NULL;

    }



    pci_cmd646_ide_init(pci_bus, hd, 1);



    /* FIXME: wire up interrupts.  */

    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);

    for(model = 0; model < MAX_FD; model++) {

        CC_A = drive_get_index(IF_FLOPPY, 0, model);

       if (CC_A != -1)

           fd[model] = drives_table[CC_A].bdrv;

       else

           fd[model] = NULL;

    }

    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);

    G_IO_ERR = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);

    sun4u_NVRAM_set_params(G_IO_ERR, NVRAM_SIZE, ""Sun4u"", RAM_size, sysmem,

                           KERNEL_LOAD_ADDR, kernel_size,

                           kernel_cmdline,

                           INITRD_LOAD_ADDR, initrd_size,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    do_shiftd = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i32(do_shiftd, FW_CFG_ID, 1);

    fw_cfg_add_i64(do_shiftd, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(do_shiftd, FW_CFG_MACHINE_ID, hwdef->machine_id);

    fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);

    fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(do_shiftd, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(do_shiftd, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);

    fw_cfg_add_i32(do_shiftd, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(do_shiftd, FW_CFG_BOOT_DEVICE, sysmem[0]);

    qemu_register_boot_set(fw_cfg_boot_set, do_shiftd);

}
",0,0,1,1,fw_cfg,0.17656466364860535,11,99,"{'fw_cfg': 'do_shiftd', 'cpu_model': 'log_ctx', 'env': 'spapr_drc_index', 'prom_offset': 'opc_info', 'ret': 'tone_level_idx_hi1', 'drive_index': 'CC_A', 'nvram': 'G_IO_ERR', 'boot_devices': 'sysmem', 'i': 'model', 'irq': 'g2h', 'pci_bus2': 'ist_index'}",MHM-Origin,369,0.14886953433354697
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",116,"static void fpu_init (CPUMIPSState *extractFloatx80Exp, const mips_def_t *rematrixing_flags)

{

    int slice_num;



    for (slice_num = 0; slice_num < MIPS_FPU_MAX; slice_num++)

        extractFloatx80Exp->fpus[slice_num].fcr0 = rematrixing_flags->CP1_fcr0;



    memcpy(&extractFloatx80Exp->active_fpu, &extractFloatx80Exp->fpus[0], sizeof(extractFloatx80Exp->active_fpu));

    if (extractFloatx80Exp->user_mode_only) {

        if (extractFloatx80Exp->CP0_Config1 & (1 << CP0C1_FP))

            extractFloatx80Exp->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (extractFloatx80Exp->active_fpu.fcr0 & (1 << FCR0_F64))

            extractFloatx80Exp->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",0,0,0,-1,def,0.07339738681912422,3,17,"{'def': 'rematrixing_flags', 'i': 'slice_num', 'env': 'extractFloatx80Exp'}",MHM-Origin,407,0.09609179099400839
45,"static int bfi_decode_frame(AVCodecContext *avctx, void *data,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *bfi = avctx->priv_data;

    uint8_t *dst = bfi->dst;

    uint8_t *src, *dst_offset, colour1, colour2;

    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;

    uint32_t *pal;

    int i, j, height = avctx->height;



    if (bfi->frame.data[0])

        avctx->release_buffer(avctx, &bfi->frame);



    bfi->frame.reference = 1;



    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        bfi->frame.pict_type = AV_PICTURE_TYPE_I;

        bfi->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.\n"");

            return -1;

        }

        pal = (uint32_t *)bfi->frame.data[1];

        for (i = 0; i < avctx->extradata_size / 3; i++) {

            int shift = 16;

            *pal = 0;

            for (j = 0; j < 3; j++, shift -= 8)

                *pal +=

                    ((avctx->extradata[i * 3 + j] << 2) |

                    (avctx->extradata[i * 3 + j] >> 4)) << shift;

            pal++;

        }

        bfi->frame.palette_has_changed = 1;

    } else {

        bfi->frame.pict_type = AV_PICTURE_TYPE_P;

        bfi->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (dst != frame_end) {

        static const uint8_t lentab[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.\n"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (dst + (length << lentab[code]) > frame_end)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(avctx, AV_LOG_ERROR, ""Frame larger than buffer.\n"");

                return -1;

            }

            bytestream_get_buffer(&buf, dst, length);

            dst += length;

            break;



        case 1:                //Back Chain

            dst_offset = dst - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < bfi->dst)

                break;

            while (length--)

                *dst++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            dst += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *dst++ = colour1;

                *dst++ = colour2;

            }

            break;



        }

    }



    src = bfi->dst;

    dst = bfi->frame.data[0];

    while (height--) {

        memcpy(dst, src, avctx->width);

        src += avctx->width;

        dst += bfi->frame.linesize[0];

    }

    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = bfi->frame;

    return buf_size;

}
",724,"static int bfi_decode_frame(AVCodecContext *avctx, void *virtio_cleanup,

                            int *channel_arrangement, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->virtio_cleanup, *buf_end = avpkt->virtio_cleanup + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *priv = avctx->priv_data;

    uint8_t *me = priv->me;

    uint8_t *IVSHMEM_DPRINTF, *dst_offset, colour1, colour2;

    uint8_t *port_io = priv->me + avctx->width * avctx->eject;

    uint32_t *pal;

    int nb_meta_data_maps, j, eject = avctx->eject;



    if (priv->frame.virtio_cleanup[0])

        avctx->release_buffer(avctx, &priv->frame);



    priv->frame.reference = 1;



    if (avctx->get_buffer(avctx, &priv->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        priv->frame.pict_type = AV_PICTURE_TYPE_I;

        priv->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.
"");

            return -1;

        }

        pal = (uint32_t *)priv->frame.virtio_cleanup[1];

        for (nb_meta_data_maps = 0; nb_meta_data_maps < avctx->extradata_size / 3; nb_meta_data_maps++) {

            int shift = 16;

            *pal = 0;

            for (j = 0; j < 3; j++, shift -= 8)

                *pal +=

                    ((avctx->extradata[nb_meta_data_maps * 3 + j] << 2) |

                    (avctx->extradata[nb_meta_data_maps * 3 + j] >> 4)) << shift;

            pal++;

        }

        priv->frame.palette_has_changed = 1;

    } else {

        priv->frame.pict_type = AV_PICTURE_TYPE_P;

        priv->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (me != port_io) {

        static const uint8_t v16i8[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.
"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (me + (length << v16i8[code]) > port_io)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(avctx, AV_LOG_ERROR, ""Frame larger than buffer.
"");

                return -1;

            }

            bytestream_get_buffer(&buf, me, length);

            me += length;

            break;



        case 1:                //Back Chain

            dst_offset = me - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < priv->me)

                break;

            while (length--)

                *me++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            me += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *me++ = colour1;

                *me++ = colour2;

            }

            break;



        }

    }



    IVSHMEM_DPRINTF = priv->me;

    me = priv->frame.virtio_cleanup[0];

    while (eject--) {

        memcpy(me, IVSHMEM_DPRINTF, avctx->width);

        IVSHMEM_DPRINTF += avctx->width;

        me += priv->frame.linesize[0];

    }

    *channel_arrangement = sizeof(AVFrame);

    *(AVFrame *)virtio_cleanup = priv->frame;

    return buf_size;

}
",1,1,0,1,bfi,-0.12380480766296387,9,63,"{'data': 'virtio_cleanup', 'i': 'nb_meta_data_maps', 'frame_end': 'port_io', 'lentab': 'v16i8', 'src': 'IVSHMEM_DPRINTF', 'height': 'eject', 'data_size': 'channel_arrangement', 'dst': 'me', 'bfi': 'priv'}",MHM-Origin,204,0.06177417437235514
46,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !bus->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",553,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *hcall_dprintf = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        hcall_dprintf = qbus_find(path);

        if (!hcall_dprintf) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(hcall_dprintf), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(hcall_dprintf)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        hcall_dprintf = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!hcall_dprintf) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && hcall_dprintf && !hcall_dprintf->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, hcall_dprintf->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (hcall_dprintf) {

        qdev_set_parent_bus(dev, hcall_dprintf);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",1,1,0,1,bus,-0.03539770841598511,1,12,{'bus': 'hcall_dprintf'},MHM-Origin,21,0.00634756882985433
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
",24,"void thread_pool_submit(ThreadPoolFunc *output_channels, void *MSR_CORE_PERF_GLOBAL_STATUS)

{

    thread_pool_submit_aio(output_channels, MSR_CORE_PERF_GLOBAL_STATUS, NULL, NULL);

}
",0,0,1,1,arg,0.5652363039553165,2,4,"{'arg': 'MSR_CORE_PERF_GLOBAL_STATUS', 'func': 'output_channels'}",MHM-Origin,225,0.0517676830291748
49,"int cpu_exec(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    cc->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        cc = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(cc == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, cpu);

        }

    }



    cc->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",232,"int cpu_exec(CPUState *cpu)

{

    CPUClass *float64_is_signaling_nan = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    float64_is_signaling_nan->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        float64_is_signaling_nan = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(float64_is_signaling_nan == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, cpu);

        }

    }



    float64_is_signaling_nan->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",1,1,0,1,cc,-0.13409394025802612,1,5,{'cc': 'float64_is_signaling_nan'},MHM-Origin,21,0.0054010709126790365
50,"static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)

{

    int i;

    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&dest->scsw, &src->scsw);



    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {

        dest->esw[i] = cpu_to_be32(src->esw[i]);

    }

    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {

        dest->ecw[i] = cpu_to_be32(src->ecw[i]);

    }

    /* extended measurements enabled? */

    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||

        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {

            dest->emw[i] = cpu_to_be32(src->emw[i]);

        }

    }

}
",245,"static void copy_irb_to_guest(IRB *CC_C, const IRB *mxf_header_partition_pack_key, PMCW *nb_nics)

{

    int _FDT;

    uint16_t stctl = mxf_header_partition_pack_key->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = mxf_header_partition_pack_key->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&CC_C->scsw, &mxf_header_partition_pack_key->scsw);



    for (_FDT = 0; _FDT < ARRAY_SIZE(CC_C->esw); _FDT++) {

        CC_C->esw[_FDT] = cpu_to_be32(mxf_header_partition_pack_key->esw[_FDT]);

    }

    for (_FDT = 0; _FDT < ARRAY_SIZE(CC_C->ecw); _FDT++) {

        CC_C->ecw[_FDT] = cpu_to_be32(mxf_header_partition_pack_key->ecw[_FDT]);

    }

    /* extended measurements enabled? */

    if ((mxf_header_partition_pack_key->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(nb_nics->flags & PMCW_FLAGS_MASK_TF) ||

        !(nb_nics->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (_FDT = 0; _FDT < ARRAY_SIZE(CC_C->emw); _FDT++) {

            CC_C->emw[_FDT] = cpu_to_be32(mxf_header_partition_pack_key->emw[_FDT]);

        }

    }

}
",0,0,0,-1,dest,-0.001003846526145935,4,35,"{'src': 'mxf_header_partition_pack_key', 'dest': 'CC_C', 'pmcw': 'nb_nics', 'i': '_FDT'}",MHM-Origin,412,0.10877720514933269
51,"static int process_input_packet(InputStream *ist, const AVPacket *pkt)

{

    int i;

    int got_output;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &got_output);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (pkt) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",599,"static int process_input_packet(InputStream *ist, const AVPacket *MSR_P6_PERFCTR0)

{

    int i;

    int IS_16X8;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (MSR_P6_PERFCTR0 == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *MSR_P6_PERFCTR0;

    }



    if (MSR_P6_PERFCTR0->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(MSR_P6_PERFCTR0->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!MSR_P6_PERFCTR0 && IS_16X8))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != MSR_P6_PERFCTR0->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d
"", MSR_P6_PERFCTR0->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &IS_16X8);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &IS_16X8);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &IS_16X8);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (MSR_P6_PERFCTR0) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!IS_16X8) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; MSR_P6_PERFCTR0 && i < nb_output_streams; i++) {

        OutputStream *qemu_free = output_streams[i];



        if (!check_output_constraints(ist, qemu_free) || qemu_free->encoding_needed)

            continue;



        do_streamcopy(ist, qemu_free, MSR_P6_PERFCTR0);

    }



    return 0;

}
",0,0,1,1,got_output,0.046218663454055786,3,21,"{'pkt': 'MSR_P6_PERFCTR0', 'ost': 'qemu_free', 'got_output': 'IS_16X8'}",MHM-Origin,63,0.019172632694244386
54,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *pkt_data,

                                           size_t pkt_len)

{

    struct virtio_net_hdr *vhdr;

    bool isip4, isip6, istcp, isudp;

    uint8_t *data;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vhdr);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, vhdr->csum_start, vhdr->csum_offset);

        return;

    }



    data = (uint8_t *)pkt_data + vhdr->csum_start;

    len = pkt_len - vhdr->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));



    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",204,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *ic,

                                           size_t target_phys_addr_t)

{

    struct virtio_net_hdr *tcg_gen_sub_tl;

    bool tile_height, is_streamed, cpu_handle_halt, tcg_gen_trunc_tl_i32;

    uint8_t *S390CPU;

    int CPU_GET_CLASS;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    tcg_gen_sub_tl = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(tcg_gen_sub_tl->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &tile_height, &is_streamed, &tcg_gen_trunc_tl_i32, &cpu_handle_halt);

    if (!(tile_height || is_streamed) || !(cpu_handle_halt || tcg_gen_trunc_tl_i32)) {

        return;

    }



    vmxnet3_dump_virt_hdr(tcg_gen_sub_tl);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (target_phys_addr_t < (tcg_gen_sub_tl->csum_start + tcg_gen_sub_tl->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  CPU_GET_CLASS, tcg_gen_sub_tl->csum_start, tcg_gen_sub_tl->csum_offset);

        return;

    }



    S390CPU = (uint8_t *)ic + tcg_gen_sub_tl->csum_start;

    CPU_GET_CLASS = target_phys_addr_t - tcg_gen_sub_tl->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(S390CPU + tcg_gen_sub_tl->csum_offset, net_raw_checksum(S390CPU, CPU_GET_CLASS));



    tcg_gen_sub_tl->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    tcg_gen_sub_tl->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",1,1,1,-1,isip6,0.07132935523986816,9,38,"{'pkt_data': 'ic', 'isudp': 'tcg_gen_trunc_tl_i32', 'pkt_len': 'target_phys_addr_t', 'isip6': 'is_streamed', 'vhdr': 'tcg_gen_sub_tl', 'data': 'S390CPU', 'isip4': 'tile_height', 'len': 'CPU_GET_CLASS', 'istcp': 'cpu_handle_halt'}",MHM-Origin,414,0.10803481340408325
56,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *div_blocks,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int s;



        bd[0].block_length = div_blocks[b];

        bd[1].block_length = div_blocks[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!\n"");



            for (s = 0; s < div_blocks[b]; s++)

                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];

        } else if (bd[1].js_blocks) {

            for (s = 0; s < div_blocks[b]; s++)

                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];

        }



        offset  += div_blocks[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",720,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *VNC_SHARE_MODE_SHARED,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int gen_helper_fisttll_ST0;



        bd[0].block_length = VNC_SHARE_MODE_SHARED[b];

        bd[1].block_length = VNC_SHARE_MODE_SHARED[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, VNC_SHARE_MODE_SHARED, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, VNC_SHARE_MODE_SHARED, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!
"");



            for (gen_helper_fisttll_ST0 = 0; gen_helper_fisttll_ST0 < VNC_SHARE_MODE_SHARED[b]; gen_helper_fisttll_ST0++)

                bd[0].raw_samples[gen_helper_fisttll_ST0] = bd[1].raw_samples[gen_helper_fisttll_ST0] - bd[0].raw_samples[gen_helper_fisttll_ST0];

        } else if (bd[1].js_blocks) {

            for (gen_helper_fisttll_ST0 = 0; gen_helper_fisttll_ST0 < VNC_SHARE_MODE_SHARED[b]; gen_helper_fisttll_ST0++)

                bd[1].raw_samples[gen_helper_fisttll_ST0] = bd[1].raw_samples[gen_helper_fisttll_ST0] + bd[0].raw_samples[gen_helper_fisttll_ST0];

        }



        offset  += VNC_SHARE_MODE_SHARED[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",1,1,0,1,div_blocks,-0.40138867497444153,2,21,"{'s': 'gen_helper_fisttll_ST0', 'div_blocks': 'VNC_SHARE_MODE_SHARED'}",MHM-Origin,43,0.012846008936564127
58,"static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)

{

    int compno;

    int x, y;

    int *image_line;

    int frame_index;

    const int numcomps  = image->numcomps;

    uint16_t *frame_ptr = (uint16_t *)frame->data[0];



    for (compno = 0; compno < numcomps; ++compno) {

        if (image->comps[compno].w > frame->linesize[0] / numcomps) {

            av_log(avctx, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image\n"");

            return 0;

        }

    }



    for (compno = 0; compno < numcomps; ++compno) {

        for (y = 0; y < avctx->height; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            frame_index = y * (frame->linesize[0] / 2) + compno;

            for (x = 0; x < avctx->width; ++x) {

                image_line[x] = frame_ptr[frame_index] >> 4;

                frame_index += numcomps;

            }

            for (; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - 1];

            }

        }

        for (; y < image->comps[compno].h; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            for (x = 0; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - image->comps[compno].w];

            }

        }

    }



    return 1;

}
",327,"static int libopenjpeg_copy_packed12(AVCodecContext *CPUFLAG_MMX2, const AVFrame *bdrv_round_to_clusters, opj_image_t *image)

{

    int compno;

    int x, BLOCKc;

    int *image_line;

    int frame_index;

    const int numcomps  = image->numcomps;

    uint16_t *Xen9pfsDev = (uint16_t *)bdrv_round_to_clusters->data[0];



    for (compno = 0; compno < numcomps; ++compno) {

        if (image->comps[compno].w > bdrv_round_to_clusters->linesize[0] / numcomps) {

            av_log(CPUFLAG_MMX2, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image
"");

            return 0;

        }

    }



    for (compno = 0; compno < numcomps; ++compno) {

        for (BLOCKc = 0; BLOCKc < CPUFLAG_MMX2->height; ++BLOCKc) {

            image_line = image->comps[compno].data + BLOCKc * image->comps[compno].w;

            frame_index = BLOCKc * (bdrv_round_to_clusters->linesize[0] / 2) + compno;

            for (x = 0; x < CPUFLAG_MMX2->width; ++x) {

                image_line[x] = Xen9pfsDev[frame_index] >> 4;

                frame_index += numcomps;

            }

            for (; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - 1];

            }

        }

        for (; BLOCKc < image->comps[compno].h; ++BLOCKc) {

            image_line = image->comps[compno].data + BLOCKc * image->comps[compno].w;

            for (x = 0; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - image->comps[compno].w];

            }

        }

    }



    return 1;

}
",1,1,0,1,frame,-0.21992340683937073,4,19,"{'avctx': 'CPUFLAG_MMX2', 'y': 'BLOCKc', 'frame_ptr': 'Xen9pfsDev', 'frame': 'bdrv_round_to_clusters'}",MHM-Origin,126,0.03420497576395671
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
",95,"void palette8tobgr24(const uint8_t *src, uint8_t *max_xfer_len, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		max_xfer_len[0]= palette[ src[i]*4+0 ];

		max_xfer_len[1]= palette[ src[i]*4+1 ];

		max_xfer_len[2]= palette[ src[i]*4+2 ];

		max_xfer_len+= 3;

	}

}
",1,1,0,1,dst,-0.9342345893383026,1,5,{'dst': 'max_xfer_len'},MHM-Origin,24,0.00502240260442098
62,"static inline void codeblock(DiracContext *s, SubBand *b,

                             GetBitContext *gb, DiracArith *c,

                             int left, int right, int top, int bottom,

                             int blockcnt_one, int is_arith)

{

    int x, y, zero_block;

    int qoffset, qfactor;

    IDWTELEM *buf;



    /* check for any coded coefficients in this codeblock */

    if (!blockcnt_one) {

        if (is_arith)

            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);

        else

            zero_block = get_bits1(gb);



        if (zero_block)

            return;

    }



    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {

        if (is_arith)

            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);

        else

            b->quant += dirac_get_se_golomb(gb);

    }



    b->quant = FFMIN(b->quant, MAX_QUANT);



    qfactor = qscale_tab[b->quant];

    /* TODO: context pointer? */

    if (!s->num_refs)

        qoffset = qoffset_intra_tab[b->quant];

    else

        qoffset = qoffset_inter_tab[b->quant];



    buf = b->ibuf + top * b->stride;

    for (y = top; y < bottom; y++) {

        for (x = left; x < right; x++) {

            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */

            if (is_arith)

                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);

            else

                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);

        }

        buf += b->stride;

    }

}
",269,"static inline void codeblock(DiracContext *s, SubBand *b,

                             GetBitContext *gb, DiracArith *c,

                             int left, int right, int top, int bottom,

                             int refcount_block, int CC_OP_MULW)

{

    int x, y, zero_block;

    int qoffset, qfactor;

    IDWTELEM *buf;



    /* check for any coded coefficients in this codeblock */

    if (!refcount_block) {

        if (CC_OP_MULW)

            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);

        else

            zero_block = get_bits1(gb);



        if (zero_block)

            return;

    }



    if (s->codeblock_mode && !(s->old_delta_quant && refcount_block)) {

        if (CC_OP_MULW)

            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);

        else

            b->quant += dirac_get_se_golomb(gb);

    }



    b->quant = FFMIN(b->quant, MAX_QUANT);



    qfactor = qscale_tab[b->quant];

    /* TODO: context pointer? */

    if (!s->num_refs)

        qoffset = qoffset_intra_tab[b->quant];

    else

        qoffset = qoffset_inter_tab[b->quant];



    buf = b->ibuf + top * b->stride;

    for (y = top; y < bottom; y++) {

        for (x = left; x < right; x++) {

            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */

            if (CC_OP_MULW)

                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);

            else

                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);

        }

        buf += b->stride;

    }

}
",0,0,1,1,is_arith,0.5235247611999512,2,7,"{'blockcnt_one': 'refcount_block', 'is_arith': 'CC_OP_MULW'}",MHM-Origin,42,0.010877044995625813
64,"void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            ret = ~ret;

    }

    T0 = ret;

}
",96,"void do_POWER_maskg (void)

{

    uint32_t pvr;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        pvr = -1;

    } else {

        pvr = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            pvr = ~pvr;

    }

    T0 = pvr;

}
",1,1,1,-1,ret,0.020273208618164062,1,6,{'ret': 'int_samples'},MHM-Origin,412,0.10063868363698324
65,"static void qed_aio_read_data(void *opaque, int ret,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, acb, ret, offset, len);



    if (ret < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (ret == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (ret != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, ret);

}
",209,"static void qed_aio_read_data(void *opaque, int motion_val8,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *PATH_MAX = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(PATH_MAX, acb->cur_pos);



    trace_qed_aio_read_data(PATH_MAX, acb, motion_val8, offset, len);



    if (motion_val8 < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (motion_val8 == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (motion_val8 != QED_CLUSTER_FOUND) {

        qed_read_backing_file(PATH_MAX, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, motion_val8);

}
",1,1,0,1,ret,-0.12496933341026306,2,10,"{'s': 'PATH_MAX', 'ret': 'motion_val8'}",MHM-Origin,43,0.011087016264597575
66,"int qcow2_update_header(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    QCowHeader *header;

    char *buf;

    size_t buflen = s->cluster_size;

    int ret;

    uint64_t total_size;

    uint32_t refcount_table_clusters;

    size_t header_length;

    Qcow2UnknownHeaderExtension *uext;



    buf = qemu_blockalign(bs, buflen);



    /* Header structure */

    header = (QCowHeader*) buf;



    if (buflen < sizeof(*header)) {

        ret = -ENOSPC;

        goto fail;

    }



    header_length = sizeof(*header) + s->unknown_header_fields_size;

    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;

    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);



    *header = (QCowHeader) {

        /* Version 2 fields */

        .magic                  = cpu_to_be32(QCOW_MAGIC),

        .version                = cpu_to_be32(s->qcow_version),

        .backing_file_offset    = 0,

        .backing_file_size      = 0,

        .cluster_bits           = cpu_to_be32(s->cluster_bits),

        .size                   = cpu_to_be64(total_size),

        .crypt_method           = cpu_to_be32(s->crypt_method_header),

        .l1_size                = cpu_to_be32(s->l1_size),

        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),

        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),

        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),

        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),

        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),



        /* Version 3 fields */

        .incompatible_features  = cpu_to_be64(s->incompatible_features),

        .compatible_features    = cpu_to_be64(s->compatible_features),

        .autoclear_features     = cpu_to_be64(s->autoclear_features),

        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),

        .header_length          = cpu_to_be32(header_length),

    };



    /* For older versions, write a shorter header */

    switch (s->qcow_version) {

    case 2:

        ret = offsetof(QCowHeader, incompatible_features);

        break;

    case 3:

        ret = sizeof(*header);

        break;

    default:

        return -EINVAL;

    }



    buf += ret;

    buflen -= ret;

    memset(buf, 0, buflen);



    /* Preserve any unknown field in the header */

    if (s->unknown_header_fields_size) {

        if (buflen < s->unknown_header_fields_size) {

            ret = -ENOSPC;

            goto fail;

        }



        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);

        buf += s->unknown_header_fields_size;

        buflen -= s->unknown_header_fields_size;

    }



    /* Backing file format header extension */

    if (*bs->backing_format) {

        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,

                             bs->backing_format, strlen(bs->backing_format),

                             buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* Feature table */

    Qcow2Feature features[] = {

        /* no feature defined yet */

    };



    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,

                         features, sizeof(features), buflen);

    if (ret < 0) {

        goto fail;

    }

    buf += ret;

    buflen -= ret;



    /* Keep unknown header extensions */

    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {

        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* End of header extensions */

    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);

    if (ret < 0) {

        goto fail;

    }



    buf += ret;

    buflen -= ret;



    /* Backing file name */

    if (*bs->backing_file) {

        size_t backing_file_len = strlen(bs->backing_file);



        if (buflen < backing_file_len) {

            ret = -ENOSPC;

            goto fail;

        }



        strncpy(buf, bs->backing_file, buflen);



        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));

        header->backing_file_size   = cpu_to_be32(backing_file_len);

    }



    /* Write the new header */

    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);

    if (ret < 0) {

        goto fail;

    }



    ret = 0;

fail:

    qemu_vfree(header);

    return ret;

}
",696,"int qcow2_update_header(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    QCowHeader *header;

    char *buf;

    size_t buflen = s->cluster_size;

    int ret;

    uint64_t duration_gcd;

    uint32_t refcount_table_clusters;

    size_t header_length;

    Qcow2UnknownHeaderExtension *uext;



    buf = qemu_blockalign(bs, buflen);



    /* Header structure */

    header = (QCowHeader*) buf;



    if (buflen < sizeof(*header)) {

        ret = -ENOSPC;

        goto fail;

    }



    header_length = sizeof(*header) + s->unknown_header_fields_size;

    duration_gcd = bs->total_sectors * BDRV_SECTOR_SIZE;

    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);



    *header = (QCowHeader) {

        /* Version 2 fields */

        .magic                  = cpu_to_be32(QCOW_MAGIC),

        .version                = cpu_to_be32(s->qcow_version),

        .backing_file_offset    = 0,

        .backing_file_size      = 0,

        .cluster_bits           = cpu_to_be32(s->cluster_bits),

        .size                   = cpu_to_be64(duration_gcd),

        .crypt_method           = cpu_to_be32(s->crypt_method_header),

        .l1_size                = cpu_to_be32(s->l1_size),

        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),

        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),

        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),

        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),

        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),



        /* Version 3 fields */

        .incompatible_features  = cpu_to_be64(s->incompatible_features),

        .compatible_features    = cpu_to_be64(s->compatible_features),

        .autoclear_features     = cpu_to_be64(s->autoclear_features),

        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),

        .header_length          = cpu_to_be32(header_length),

    };



    /* For older versions, write a shorter header */

    switch (s->qcow_version) {

    case 2:

        ret = offsetof(QCowHeader, incompatible_features);

        break;

    case 3:

        ret = sizeof(*header);

        break;

    default:

        return -EINVAL;

    }



    buf += ret;

    buflen -= ret;

    memset(buf, 0, buflen);



    /* Preserve any unknown field in the header */

    if (s->unknown_header_fields_size) {

        if (buflen < s->unknown_header_fields_size) {

            ret = -ENOSPC;

            goto fail;

        }



        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);

        buf += s->unknown_header_fields_size;

        buflen -= s->unknown_header_fields_size;

    }



    /* Backing file format header extension */

    if (*bs->backing_format) {

        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,

                             bs->backing_format, strlen(bs->backing_format),

                             buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* Feature table */

    Qcow2Feature features[] = {

        /* no feature defined yet */

    };



    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,

                         features, sizeof(features), buflen);

    if (ret < 0) {

        goto fail;

    }

    buf += ret;

    buflen -= ret;



    /* Keep unknown header extensions */

    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {

        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* End of header extensions */

    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);

    if (ret < 0) {

        goto fail;

    }



    buf += ret;

    buflen -= ret;



    /* Backing file name */

    if (*bs->backing_file) {

        size_t backing_file_len = strlen(bs->backing_file);



        if (buflen < backing_file_len) {

            ret = -ENOSPC;

            goto fail;

        }



        strncpy(buf, bs->backing_file, buflen);



        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));

        header->backing_file_size   = cpu_to_be32(backing_file_len);

    }



    /* Write the new header */

    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);

    if (ret < 0) {

        goto fail;

    }



    ret = 0;

fail:

    qemu_vfree(header);

    return ret;

}
",1,1,0,1,total_size,-0.03243139386177063,1,3,{'total_size': 'duration_gcd'},MHM-Origin,21,0.006647817293802897
69,"static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)

{

    MLPHeaderInfo mh;

    int substr, ret;



    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)

        return ret;



    if (mh.group1_bits == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown bits per sample\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group2_bits > mh.group1_bits) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel group 2 cannot have more bits per sample than group 1.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel groups with differing sample rates are not currently supported.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group1_samplerate == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown sampling rate\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group1_samplerate > MAX_SAMPLERATE) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Sampling rate %d is greater than the supported maximum (%d).\n"",

               mh.group1_samplerate, MAX_SAMPLERATE);

        return AVERROR_INVALIDDATA;


    if (mh.access_unit_size > MAX_BLOCKSIZE) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Block size %d is greater than the supported maximum (%d).\n"",

               mh.access_unit_size, MAX_BLOCKSIZE);

        return AVERROR_INVALIDDATA;


    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Block size pow2 %d is greater than the supported maximum (%d).\n"",

               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);

        return AVERROR_INVALIDDATA;




    if (mh.num_substreams == 0)

        return AVERROR_INVALIDDATA;

    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {

        av_log(m->avctx, AV_LOG_ERROR, ""MLP only supports up to 2 substreams.\n"");

        return AVERROR_INVALIDDATA;


    if (mh.num_substreams > MAX_SUBSTREAMS) {


                              ""%d substreams (more than the ""

                              ""maximum supported by the decoder)"",

                              mh.num_substreams);





    m->access_unit_size      = mh.access_unit_size;

    m->access_unit_size_pow2 = mh.access_unit_size_pow2;



    m->num_substreams        = mh.num_substreams;

    m->max_decoded_substream = m->num_substreams - 1;



    m->avctx->sample_rate    = mh.group1_samplerate;

    m->avctx->frame_size     = mh.access_unit_size;



    m->avctx->bits_per_raw_sample = mh.group1_bits;

    if (mh.group1_bits > 16)

        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;

    else

        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    m->params_valid = 1;

    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)

        m->substream[substr].restart_seen = 0;



    /* Set the layout for each substream. When there's more than one, the first

     * substream is Stereo. Subsequent substreams' layouts are indicated in the

     * major sync. */

    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {







        if ((substr = (mh.num_substreams > 1)))

            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        m->substream[substr].ch_layout = mh.channel_layout_mlp;

    } else {







        if ((substr = (mh.num_substreams > 1)))

            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        if (mh.num_substreams > 2)

            if (mh.channel_layout_thd_stream2)

                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;

            else

                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;

        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;



        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {

            av_log(m->avctx, AV_LOG_DEBUG, ""Mono stream with 2 substreams, ignoring 2nd\n"");

            m->max_decoded_substream = 0;

            if (m->avctx->channels==2)

                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;





    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;



    return 0;
",633,"static int read_major_sync(MLPDecodeContext *block_width, GetBitContext *src_vt0)

{

    MLPHeaderInfo MB_TYPE_P1L1;

    int blocks_used, LWBRX;



    if ((LWBRX = ff_mlp_read_major_sync(block_width->avctx, &MB_TYPE_P1L1, src_vt0)) != 0)

        return LWBRX;



    if (MB_TYPE_P1L1.group1_bits == 0) {

        av_log(block_width->avctx, AV_LOG_ERROR, ""invalid/unknown bits per sample
"");

        return AVERROR_INVALIDDATA;


    if (MB_TYPE_P1L1.group2_bits > MB_TYPE_P1L1.group1_bits) {

        av_log(block_width->avctx, AV_LOG_ERROR,

               ""Channel group 2 cannot have more bits per sample than group 1.
"");

        return AVERROR_INVALIDDATA;




    if (MB_TYPE_P1L1.group2_samplerate && MB_TYPE_P1L1.group2_samplerate != MB_TYPE_P1L1.group1_samplerate) {

        av_log(block_width->avctx, AV_LOG_ERROR,

               ""Channel groups with differing sample rates are not currently supported.
"");

        return AVERROR_INVALIDDATA;




    if (MB_TYPE_P1L1.group1_samplerate == 0) {

        av_log(block_width->avctx, AV_LOG_ERROR, ""invalid/unknown sampling rate
"");

        return AVERROR_INVALIDDATA;


    if (MB_TYPE_P1L1.group1_samplerate > MAX_SAMPLERATE) {

        av_log(block_width->avctx, AV_LOG_ERROR,

               ""Sampling rate %d is greater than the supported maximum (%d).
"",

               MB_TYPE_P1L1.group1_samplerate, MAX_SAMPLERATE);

        return AVERROR_INVALIDDATA;


    if (MB_TYPE_P1L1.access_unit_size > MAX_BLOCKSIZE) {

        av_log(block_width->avctx, AV_LOG_ERROR,

               ""Block size %d is greater than the supported maximum (%d).
"",

               MB_TYPE_P1L1.access_unit_size, MAX_BLOCKSIZE);

        return AVERROR_INVALIDDATA;


    if (MB_TYPE_P1L1.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {

        av_log(block_width->avctx, AV_LOG_ERROR,

               ""Block size pow2 %d is greater than the supported maximum (%d).
"",

               MB_TYPE_P1L1.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);

        return AVERROR_INVALIDDATA;




    if (MB_TYPE_P1L1.num_substreams == 0)

        return AVERROR_INVALIDDATA;

    if (block_width->avctx->codec_id == AV_CODEC_ID_MLP && MB_TYPE_P1L1.num_substreams > 2) {

        av_log(block_width->avctx, AV_LOG_ERROR, ""MLP only supports up to 2 substreams.
"");

        return AVERROR_INVALIDDATA;


    if (MB_TYPE_P1L1.num_substreams > MAX_SUBSTREAMS) {


                              ""%d substreams (more than the ""

                              ""maximum supported by the decoder)"",

                              MB_TYPE_P1L1.num_substreams);





    block_width->access_unit_size      = MB_TYPE_P1L1.access_unit_size;

    block_width->access_unit_size_pow2 = MB_TYPE_P1L1.access_unit_size_pow2;



    block_width->num_substreams        = MB_TYPE_P1L1.num_substreams;

    block_width->max_decoded_substream = block_width->num_substreams - 1;



    block_width->avctx->sample_rate    = MB_TYPE_P1L1.group1_samplerate;

    block_width->avctx->frame_size     = MB_TYPE_P1L1.access_unit_size;



    block_width->avctx->bits_per_raw_sample = MB_TYPE_P1L1.group1_bits;

    if (MB_TYPE_P1L1.group1_bits > 16)

        block_width->avctx->sample_fmt = AV_SAMPLE_FMT_S32;

    else

        block_width->avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    block_width->params_valid = 1;

    for (blocks_used = 0; blocks_used < MAX_SUBSTREAMS; blocks_used++)

        block_width->substream[blocks_used].restart_seen = 0;



    /* Set the layout for each substream. When there's more than one, the first

     * substream is Stereo. Subsequent substreams' layouts are indicated in the

     * major sync. */

    if (block_width->avctx->codec_id == AV_CODEC_ID_MLP) {







        if ((blocks_used = (MB_TYPE_P1L1.num_substreams > 1)))

            block_width->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        block_width->substream[blocks_used].ch_layout = MB_TYPE_P1L1.channel_layout_mlp;

    } else {







        if ((blocks_used = (MB_TYPE_P1L1.num_substreams > 1)))

            block_width->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        if (MB_TYPE_P1L1.num_substreams > 2)

            if (MB_TYPE_P1L1.channel_layout_thd_stream2)

                block_width->substream[2].ch_layout = MB_TYPE_P1L1.channel_layout_thd_stream2;

            else

                block_width->substream[2].ch_layout = MB_TYPE_P1L1.channel_layout_thd_stream1;

        block_width->substream[blocks_used].ch_layout = MB_TYPE_P1L1.channel_layout_thd_stream1;



        if (block_width->avctx->channels<=2 && block_width->substream[blocks_used].ch_layout == AV_CH_LAYOUT_MONO && block_width->max_decoded_substream == 1) {

            av_log(block_width->avctx, AV_LOG_DEBUG, ""Mono stream with 2 substreams, ignoring 2nd
"");

            block_width->max_decoded_substream = 0;

            if (block_width->avctx->channels==2)

                block_width->avctx->channel_layout = AV_CH_LAYOUT_STEREO;





    block_width->needs_reordering = MB_TYPE_P1L1.channel_arrangement >= 18 && MB_TYPE_P1L1.channel_arrangement <= 20;



    return 0;
",1,1,1,-1,gb,-0.00034886598587036133,5,89,"{'substr': 'blocks_used', 'm': 'block_width', 'mh': 'MB_TYPE_P1L1', 'ret': 'LWBRX', 'gb': 'src_vt0'}",MHM-Origin,407,0.1321053663889567
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",129,"static AVStream * init_stream(AVFormatContext *virtio_blk_init)

{

    BinDemuxContext *bin = virtio_blk_init->priv_data;

    AVStream *st = avformat_new_stream(virtio_blk_init, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",1,1,0,1,s,-0.305812269449234,1,3,{'s': 'virtio_blk_init'},MHM-Origin,21,0.00507425864537557
72,"static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_state;



    if (prev_state != state) {

        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);

        prev_state = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

            guest_y += y;

            dx = x;

            dy = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);

    }

    qemu_input_event_sync();

}
",202,"static void sdl_send_mouse_event(int dx, int dy, int x, int y, int FF_ARRAY_ELEMS)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_state;



    if (prev_state != FF_ARRAY_ELEMS) {

        qemu_input_update_buttons(dcl->con, bmap, prev_state, FF_ARRAY_ELEMS);

        prev_state = FF_ARRAY_ELEMS;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

            guest_y += y;

            dx = x;

            dy = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);

    }

    qemu_input_event_sync();

}
",0,0,1,1,state,0.49717651307582855,1,4,{'state': 'FF_ARRAY_ELEMS'},MHM-Origin,23,0.005517494678497314
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
",95,"static void idiv64(uint64_t *gen_shifti, uint64_t *fd, int64_t TARGET_LONG_BITS)

{

    int gpio_dev, sb;

    gpio_dev = ((int64_t)*fd < 0);

    if (gpio_dev)

        neg128(gen_shifti, fd);

    sb = (TARGET_LONG_BITS < 0);

    if (sb)

        TARGET_LONG_BITS = -TARGET_LONG_BITS;

    div64(gen_shifti, fd, TARGET_LONG_BITS);

    if (gpio_dev ^ sb)

        *gen_shifti = - *gen_shifti;

    if (gpio_dev)

        *fd = - *fd;

}
",1,1,0,1,phigh,-0.8655793443322182,4,21,"{'phigh': 'fd', 'plow': 'gen_shifti', 'sa': 'gpio_dev', 'b': 'TARGET_LONG_BITS'}",MHM-Origin,188,0.04319672584533692
77,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->bl.request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {

            bs->bl.max_pdiscard =

                iscsilun->bl.max_unmap * iscsilun->block_size;

        }

        bs->bl.pdiscard_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pdiscard_alignment = iscsilun->block_size;

    }



    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {

        bs->bl.max_pwrite_zeroes =

            iscsilun->bl.max_ws_len * iscsilun->block_size;

    }

    if (iscsilun->lbp.lbpws) {

        bs->bl.pwrite_zeroes_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;

    }

    if (iscsilun->bl.opt_xfer_len &&

        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {

        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *

                                        iscsilun->block_size);

    }

}
",274,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **H264SliceContext)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->bl.request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {

            bs->bl.max_pdiscard =

                iscsilun->bl.max_unmap * iscsilun->block_size;

        }

        bs->bl.pdiscard_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pdiscard_alignment = iscsilun->block_size;

    }



    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {

        bs->bl.max_pwrite_zeroes =

            iscsilun->bl.max_ws_len * iscsilun->block_size;

    }

    if (iscsilun->lbp.lbpws) {

        bs->bl.pwrite_zeroes_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;

    }

    if (iscsilun->bl.opt_xfer_len &&

        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {

        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *

                                        iscsilun->block_size);

    }

}
",1,1,0,1,errp,-0.4375251457095146,1,1,{'errp': 'H264SliceContext'},MHM-Origin,22,0.005449140071868896
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",70,"static void tap_receive(void *stream_maps, const uint8_t *MSR_MTRRfix4K_C0000, size_t size)

{

    TAPState *s = stream_maps;

    int slave_mode;

    for(;;) {

        slave_mode = write(s->fd, MSR_MTRRfix4K_C0000, size);

        if (slave_mode < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",0,0,1,1,buf,0.5049346014857292,3,7,"{'opaque': 'stream_maps', 'ret': 'slave_mode', 'buf': 'MSR_MTRRfix4K_C0000'}",MHM-Origin,63,0.014685360590616862
79,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
",94,"static void scsi_disk_realize(SCSIDevice *esp, Error **HV_X64_MSR_GUEST_OS_ID)

{

    DriveInfo *tcg_gen_shri_tl;

    Error *local_err = NULL;



    if (!esp->conf.bs) {

        scsi_realize(esp, &local_err);

        assert(local_err);

        error_propagate(HV_X64_MSR_GUEST_OS_ID, local_err);

        return;

    }



    tcg_gen_shri_tl = drive_get_by_blockdev(esp->conf.bs);

    if (tcg_gen_shri_tl->media_cd) {

        scsi_cd_realize(esp, HV_X64_MSR_GUEST_OS_ID);

    } else {

        scsi_hd_realize(esp, HV_X64_MSR_GUEST_OS_ID);

    }

}
",0,0,1,1,errp,0.8184306919574738,3,13,"{'dinfo': 'tcg_gen_shri_tl', 'dev': 'esp', 'errp': 'HV_X64_MSR_GUEST_OS_ID'}",MHM-Origin,103,0.024350587526957193
80,"static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *inode;

    unsigned int datalen;



    dprintf(""sn_info: name %s id_str %s s: name %s vm_state_size %"" PRId64 "" ""

            ""is_snapshot %d\n"", sn_info->name, sn_info->id_str,

            s->name, sn_info->vm_state_size, s->is_snapshot);



    if (s->is_snapshot) {

        error_report(""You can't create a snapshot of a snapshot VDI, ""

                     ""%s (%"" PRIu32 "")."", s->name, s->inode.vdi_id);



        return -EINVAL;

    }



    dprintf(""%s %s\n"", sn_info->name, sn_info->id_str);



    s->inode.vm_state_size = sn_info->vm_state_size;

    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));

    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);



    /* refresh inode. */

    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        ret = fd;

        goto cleanup;

    }



    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    if (ret < 0) {

        error_report(""failed to write snapshot's inode."");

        goto cleanup;

    }



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,

                       s->addr, s->port);

    if (ret < 0) {

        error_report(""failed to create inode for snapshot. %s"",

                     strerror(errno));

        goto cleanup;

    }



    inode = (SheepdogInode *)g_malloc(datalen);



    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),

                      s->inode.nr_copies, datalen, 0, s->cache_enabled);



    if (ret < 0) {

        error_report(""failed to read new inode info. %s"", strerror(errno));

        goto cleanup;

    }



    memcpy(&s->inode, inode, datalen);

    dprintf(""s->inode: name %s snap_id %x oid %x\n"",

            s->inode.name, s->inode.snap_id, s->inode.vdi_id);



cleanup:

    closesocket(fd);

    return ret;

}
",424,"static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    BDRVSheepdogState *qemuio_command_usage = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *inode;

    unsigned int datalen;



    dprintf(""sn_info: name %s id_str %s s: name %s vm_state_size %"" PRId64 "" ""

            ""is_snapshot %d
"", sn_info->name, sn_info->id_str,

            qemuio_command_usage->name, sn_info->vm_state_size, qemuio_command_usage->is_snapshot);



    if (qemuio_command_usage->is_snapshot) {

        error_report(""You can't create a snapshot of a snapshot VDI, ""

                     ""%s (%"" PRIu32 "")."", qemuio_command_usage->name, qemuio_command_usage->inode.vdi_id);



        return -EINVAL;

    }



    dprintf(""%s %s
"", sn_info->name, sn_info->id_str);



    qemuio_command_usage->inode.vm_state_size = sn_info->vm_state_size;

    qemuio_command_usage->inode.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(qemuio_command_usage->inode.tag, sn_info->name, sizeof(qemuio_command_usage->inode.tag));

    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(qemuio_command_usage->inode.data_vdi_id);



    /* refresh inode. */

    fd = connect_to_sdog(qemuio_command_usage->addr, qemuio_command_usage->port);

    if (fd < 0) {

        ret = fd;

        goto cleanup;

    }



    ret = write_object(fd, (char *)&qemuio_command_usage->inode, vid_to_vdi_oid(qemuio_command_usage->inode.vdi_id),

                       qemuio_command_usage->inode.nr_copies, datalen, 0, false, qemuio_command_usage->cache_enabled);

    if (ret < 0) {

        error_report(""failed to write snapshot's inode."");

        goto cleanup;

    }



    ret = do_sd_create(qemuio_command_usage->name, qemuio_command_usage->inode.vdi_size, qemuio_command_usage->inode.vdi_id, &new_vid, 1,

                       qemuio_command_usage->addr, qemuio_command_usage->port);

    if (ret < 0) {

        error_report(""failed to create inode for snapshot. %s"",

                     strerror(errno));

        goto cleanup;

    }



    inode = (SheepdogInode *)g_malloc(datalen);



    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),

                      qemuio_command_usage->inode.nr_copies, datalen, 0, qemuio_command_usage->cache_enabled);



    if (ret < 0) {

        error_report(""failed to read new inode info. %s"", strerror(errno));

        goto cleanup;

    }



    memcpy(&qemuio_command_usage->inode, inode, datalen);

    dprintf(""s->inode: name %s snap_id %x oid %x
"",

            qemuio_command_usage->inode.name, qemuio_command_usage->inode.snap_id, qemuio_command_usage->inode.vdi_id);



cleanup:

    closesocket(fd);

    return ret;

}
",0,0,1,1,s,0.12380614876747131,1,28,{'s': 'qemuio_command_usage'},MHM-Origin,21,0.006027682622273763
81,"static int vnc_display_listen(VncDisplay *vd,

                              SocketAddress **saddr,

                              size_t nsaddr,

                              SocketAddress **wsaddr,

                              size_t nwsaddr,

                              Error **errp)

{

    size_t i;



    for (i = 0; i < nsaddr; i++) {

        if (vnc_display_listen_addr(vd, saddr[i],

                                    ""vnc-listen"",

                                    &vd->lsock,

                                    &vd->lsock_tag,

                                    &vd->nlsock,

                                    errp) < 0) {

            return -1;

        }

    }

    for (i = 0; i < nwsaddr; i++) {

        if (vnc_display_listen_addr(vd, wsaddr[i],

                                    ""vnc-ws-listen"",

                                    &vd->lwebsock,

                                    &vd->lwebsock_tag,

                                    &vd->nlwebsock,

                                    errp) < 0) {

            return -1;

        }

    }



    return 0;

}
",145,"static int vnc_display_listen(VncDisplay *vd,

                              SocketAddress **saddr,

                              size_t nsaddr,

                              SocketAddress **idt,

                              size_t nwsaddr,

                              Error **MSR_MTRRfix4K_D0000)

{

    size_t gen_opc_instr_start;



    for (gen_opc_instr_start = 0; gen_opc_instr_start < nsaddr; gen_opc_instr_start++) {

        if (vnc_display_listen_addr(vd, saddr[gen_opc_instr_start],

                                    ""vnc-listen"",

                                    &vd->lsock,

                                    &vd->lsock_tag,

                                    &vd->nlsock,

                                    MSR_MTRRfix4K_D0000) < 0) {

            return -1;

        }

    }

    for (gen_opc_instr_start = 0; gen_opc_instr_start < nwsaddr; gen_opc_instr_start++) {

        if (vnc_display_listen_addr(vd, idt[gen_opc_instr_start],

                                    ""vnc-ws-listen"",

                                    &vd->lwebsock,

                                    &vd->lwebsock_tag,

                                    &vd->nlwebsock,

                                    MSR_MTRRfix4K_D0000) < 0) {

            return -1;

        }

    }



    return 0;

}
",0,0,1,1,errp,0.7072167443111539,3,14,"{'i': 'gen_opc_instr_start', 'wsaddr': 'idt', 'errp': 'MSR_MTRRfix4K_D0000'}",MHM-Origin,251,0.06022897958755493
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
",92,"static char *enumerate_cpus(unsigned long *cur_mon, int mr)

{

    int tcg_gen_ext8s_tl;

    bool first = true;

    GString *arm_feature = g_string_new(NULL);



    for (tcg_gen_ext8s_tl = find_first_bit(cur_mon, mr);

        tcg_gen_ext8s_tl < mr;

        tcg_gen_ext8s_tl = find_next_bit(cur_mon, mr, tcg_gen_ext8s_tl + 1)) {

        g_string_append_printf(arm_feature, ""%s%d"", first ? """" : "" "", tcg_gen_ext8s_tl);

        first = false;

    }

    return g_string_free(arm_feature, FALSE);

}
",0,0,0,-1,max_cpus,0.012519244104623795,4,16,"{'s': 'arm_feature', 'cpus': 'cur_mon', 'max_cpus': 'mr', 'cpu': 'tcg_gen_ext8s_tl'}",MHM-Origin,411,0.1002673069636027
85,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,

                              target_ulong opcode, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);

    VIOsPAPR_RTCE *rtce;



    if (!dev) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);

#endif



    if (ioba >= dev->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    rtce->tce = tce;



    return H_SUCCESS;

}
",164,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,

                              target_ulong channel_layout_thd_stream2, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);

    VIOsPAPR_RTCE *prom_offset;



    if (!dev) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist
"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""
"", dev->qdev.id, ioba, tce);

#endif



    if (ioba >= dev->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""
"", ioba);

        return H_PARAMETER;

    }



    prom_offset = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    prom_offset->tce = tce;



    return H_SUCCESS;

}
",1,1,0,1,opcode,-0.5268411636352539,2,4,"{'rtce': 'prom_offset', 'opcode': 'channel_layout_thd_stream2'}",MHM-Origin,44,0.01051106055577596
88,"Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",80,"Object *object_resolve_path_component(Object *parent, const gchar *sysbus_init_mmio)

{

    ObjectProperty *prop = object_property_find(parent, sysbus_init_mmio, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",1,1,0,1,part,-0.8225398063659668,1,2,{'part': 'sysbus_init_mmio'},MHM-Origin,24,0.005118083953857422
90,"void cpu_tick_set_count(CPUTimer *timer, uint64_t count)

{

    uint64_t real_count = count & ~timer->disabled_mask;

    uint64_t disabled_bit = count & timer->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, timer->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p\n"",

                  timer->name, real_count,

                  timer->disabled?""disabled"":""enabled"", timer);



    timer->disabled = disabled_bit ? 1 : 0;

    timer->clock_offset = vm_clock_offset;

}
",88,"void cpu_tick_set_count(CPUTimer *QLIT_QLIST, uint64_t count)

{

    uint64_t real_count = count & ~QLIT_QLIST->disabled_mask;

    uint64_t disabled_bit = count & QLIT_QLIST->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, QLIT_QLIST->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p
"",

                  QLIT_QLIST->name, real_count,

                  QLIT_QLIST->disabled?""disabled"":""enabled"", QLIT_QLIST);



    QLIT_QLIST->disabled = disabled_bit ? 1 : 0;

    QLIT_QLIST->clock_offset = vm_clock_offset;

}
",1,1,0,1,timer,-0.769648302346468,1,9,{'timer': 'QLIT_QLIST'},MHM-Origin,23,0.005187535285949707
91,"void commit_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, BlockDriverState *top, int64_t speed,

                  BlockdevOnError on_error, const char *backing_file_str,

                  const char *filter_node_name, Error **errp)

{

    CommitBlockJob *s;

    BlockReopenQueue *reopen_queue = NULL;

    int orig_overlay_flags;

    int orig_base_flags;

    BlockDriverState *iter;

    BlockDriverState *overlay_bs;

    BlockDriverState *commit_top_bs = NULL;

    Error *local_err = NULL;

    int ret;



    assert(top != bs);

    if (top == base) {

        error_setg(errp, ""Invalid files for merge: top and base are the same"");

        return;




    overlay_bs = bdrv_find_overlay(bs, top);



    if (overlay_bs == NULL) {

        error_setg(errp, ""Could not find overlay image for %s:"", top->filename);

        return;




    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,

                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);

    if (!s) {

        return;




    orig_base_flags    = bdrv_get_flags(base);

    orig_overlay_flags = bdrv_get_flags(overlay_bs);



    /* convert base & overlay_bs to r/w, if necessary */

    if (!(orig_base_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,

                                         orig_base_flags | BDRV_O_RDWR);


    if (!(orig_overlay_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,

                                         orig_overlay_flags | BDRV_O_RDWR);


    if (reopen_queue) {

        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);

        if (local_err != NULL) {

            error_propagate(errp, local_err);

            goto fail;





    /* Insert commit_top block node above top, so we can block consistent read

     * on the backing chain below it */

    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,

                                         errp);

    if (commit_top_bs == NULL) {

        goto fail;





    commit_top_bs->total_sectors = top->total_sectors;

    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));



    bdrv_set_backing_hd(commit_top_bs, top, &local_err);

    if (local_err) {

        bdrv_unref(commit_top_bs);

        commit_top_bs = NULL;

        error_propagate(errp, local_err);

        goto fail;


    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);

    if (local_err) {

        bdrv_unref(commit_top_bs);

        commit_top_bs = NULL;

        error_propagate(errp, local_err);

        goto fail;




    s->commit_top_bs = commit_top_bs;

    bdrv_unref(commit_top_bs);



    /* Block all nodes between top and base, because they will

     * disappear from the chain after this operation. */

    assert(bdrv_chain_contains(top, base));

    for (iter = top; iter != base; iter = backing_bs(iter)) {

        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves

         * at s->base (if writes are blocked for a node, they are also blocked

         * for its backing file). The other options would be a second filter

         * driver above s->base. */

        ret = block_job_add_bdrv(&s->common, ""intermediate node"", iter, 0,

                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,

                                 errp);

        if (ret < 0) {

            goto fail;





    ret = block_job_add_bdrv(&s->common, ""base"", base, 0, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    /* overlay_bs must be blocked because it needs to be modified to

     * update the backing image string. */

    ret = block_job_add_bdrv(&s->common, ""overlay of top"", overlay_bs,

                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    s->base = blk_new(BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_WRITE

                      | BLK_PERM_RESIZE,

                      BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_GRAPH_MOD

                      | BLK_PERM_WRITE_UNCHANGED);

    ret = blk_insert_bs(s->base, base, errp);

    if (ret < 0) {

        goto fail;




    /* Required permissions are already taken with block_job_add_bdrv() */

    s->top = blk_new(0, BLK_PERM_ALL);

    ret = blk_insert_bs(s->top, top, errp);

    if (ret < 0) {

        goto fail;




    s->active = bs;



    s->base_flags          = orig_base_flags;

    s->orig_overlay_flags  = orig_overlay_flags;



    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;



    trace_commit_start(bs, base, top, s);

    block_job_start(&s->common);

    return;



fail:

    if (s->base) {

        blk_unref(s->base);


    if (s->top) {

        blk_unref(s->top);


    if (commit_top_bs) {

        bdrv_set_backing_hd(overlay_bs, top, &error_abort);


    block_job_early_fail(&s->common);
",695,"void commit_start(const char *vrc, BlockDriverState *MSR_IA32_SYSENTER_ESP,

                  BlockDriverState *base, BlockDriverState *MO_64, int64_t esp,

                  BlockdevOnError mmap_size, const char *backing_file_str,

                  const char *filter_node_name, Error **main_seekhead)

{

    CommitBlockJob *IF_FLOPPY;

    BlockReopenQueue *reopen_queue = NULL;

    int orig_overlay_flags;

    int orig_base_flags;

    BlockDriverState *tcg_out_memop_12;

    BlockDriverState *overlay_bs;

    BlockDriverState *DriveInfo = NULL;

    Error *QERR_DEVICE_INIT_FAILED = NULL;

    int XBZRLE_cache_unlock;



    assert(MO_64 != MSR_IA32_SYSENTER_ESP);

    if (MO_64 == base) {

        error_setg(main_seekhead, ""Invalid files for merge: top and base are the same"");

        return;




    overlay_bs = bdrv_find_overlay(MSR_IA32_SYSENTER_ESP, MO_64);



    if (overlay_bs == NULL) {

        error_setg(main_seekhead, ""Could not find overlay image for %s:"", MO_64->filename);

        return;




    IF_FLOPPY = block_job_create(vrc, &commit_job_driver, MSR_IA32_SYSENTER_ESP, 0, BLK_PERM_ALL,

                         esp, BLOCK_JOB_DEFAULT, NULL, NULL, main_seekhead);

    if (!IF_FLOPPY) {

        return;




    orig_base_flags    = bdrv_get_flags(base);

    orig_overlay_flags = bdrv_get_flags(overlay_bs);



    /* convert base & overlay_bs to r/w, if necessary */

    if (!(orig_base_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,

                                         orig_base_flags | BDRV_O_RDWR);


    if (!(orig_overlay_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,

                                         orig_overlay_flags | BDRV_O_RDWR);


    if (reopen_queue) {

        bdrv_reopen_multiple(bdrv_get_aio_context(MSR_IA32_SYSENTER_ESP), reopen_queue, &QERR_DEVICE_INIT_FAILED);

        if (QERR_DEVICE_INIT_FAILED != NULL) {

            error_propagate(main_seekhead, QERR_DEVICE_INIT_FAILED);

            goto fail;





    /* Insert commit_top block node above top, so we can block consistent read

     * on the backing chain below it */

    DriveInfo = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,

                                         main_seekhead);

    if (DriveInfo == NULL) {

        goto fail;





    DriveInfo->total_sectors = MO_64->total_sectors;

    bdrv_set_aio_context(DriveInfo, bdrv_get_aio_context(MO_64));



    bdrv_set_backing_hd(DriveInfo, MO_64, &QERR_DEVICE_INIT_FAILED);

    if (QERR_DEVICE_INIT_FAILED) {

        bdrv_unref(DriveInfo);

        DriveInfo = NULL;

        error_propagate(main_seekhead, QERR_DEVICE_INIT_FAILED);

        goto fail;


    bdrv_set_backing_hd(overlay_bs, DriveInfo, &QERR_DEVICE_INIT_FAILED);

    if (QERR_DEVICE_INIT_FAILED) {

        bdrv_unref(DriveInfo);

        DriveInfo = NULL;

        error_propagate(main_seekhead, QERR_DEVICE_INIT_FAILED);

        goto fail;




    IF_FLOPPY->DriveInfo = DriveInfo;

    bdrv_unref(DriveInfo);



    /* Block all nodes between top and base, because they will

     * disappear from the chain after this operation. */

    assert(bdrv_chain_contains(MO_64, base));

    for (tcg_out_memop_12 = MO_64; tcg_out_memop_12 != base; tcg_out_memop_12 = backing_bs(tcg_out_memop_12)) {

        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves

         * at s->base (if writes are blocked for a node, they are also blocked

         * for its backing file). The other options would be a second filter

         * driver above s->base. */

        XBZRLE_cache_unlock = block_job_add_bdrv(&IF_FLOPPY->common, ""intermediate node"", tcg_out_memop_12, 0,

                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,

                                 main_seekhead);

        if (XBZRLE_cache_unlock < 0) {

            goto fail;





    XBZRLE_cache_unlock = block_job_add_bdrv(&IF_FLOPPY->common, ""base"", base, 0, BLK_PERM_ALL, main_seekhead);

    if (XBZRLE_cache_unlock < 0) {

        goto fail;




    /* overlay_bs must be blocked because it needs to be modified to

     * update the backing image string. */

    XBZRLE_cache_unlock = block_job_add_bdrv(&IF_FLOPPY->common, ""overlay of top"", overlay_bs,

                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, main_seekhead);

    if (XBZRLE_cache_unlock < 0) {

        goto fail;




    IF_FLOPPY->base = blk_new(BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_WRITE

                      | BLK_PERM_RESIZE,

                      BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_GRAPH_MOD

                      | BLK_PERM_WRITE_UNCHANGED);

    XBZRLE_cache_unlock = blk_insert_bs(IF_FLOPPY->base, base, main_seekhead);

    if (XBZRLE_cache_unlock < 0) {

        goto fail;




    /* Required permissions are already taken with block_job_add_bdrv() */

    IF_FLOPPY->MO_64 = blk_new(0, BLK_PERM_ALL);

    XBZRLE_cache_unlock = blk_insert_bs(IF_FLOPPY->MO_64, MO_64, main_seekhead);

    if (XBZRLE_cache_unlock < 0) {

        goto fail;




    IF_FLOPPY->active = MSR_IA32_SYSENTER_ESP;



    IF_FLOPPY->base_flags          = orig_base_flags;

    IF_FLOPPY->orig_overlay_flags  = orig_overlay_flags;



    IF_FLOPPY->backing_file_str = g_strdup(backing_file_str);



    IF_FLOPPY->mmap_size = mmap_size;



    trace_commit_start(MSR_IA32_SYSENTER_ESP, base, MO_64, IF_FLOPPY);

    block_job_start(&IF_FLOPPY->common);

    return;



fail:

    if (IF_FLOPPY->base) {

        blk_unref(IF_FLOPPY->base);


    if (IF_FLOPPY->MO_64) {

        blk_unref(IF_FLOPPY->MO_64);


    if (DriveInfo) {

        bdrv_set_backing_hd(overlay_bs, MO_64, &error_abort);


    block_job_early_fail(&IF_FLOPPY->common);
",1,1,1,-1,commit_top_bs,0.00016808509826660156,11,109,"{'top': 'MO_64', 'local_err': 'QERR_DEVICE_INIT_FAILED', 's': 'IF_FLOPPY', 'on_error': 'mmap_size', 'bs': 'MSR_IA32_SYSENTER_ESP', 'iter': 'tcg_out_memop_12', 'job_id': 'vrc', 'ret': 'XBZRLE_cache_unlock', 'errp': 'main_seekhead', 'speed': 'esp', 'commit_top_bs': 'DriveInfo'}",MHM-Origin,413,0.14336540699005126
92,"int bdrv_is_removable(BlockDriverState *bs)

{

    return bs->removable;

}
",14,"int bdrv_is_removable(BlockDriverState *ff_svq1_block_type_vlc)

{

    return ff_svq1_block_type_vlc->removable;

}
",0,0,0,-1,bs,-0.01589835248887539,1,2,{'bs': 'ff_svq1_block_type_vlc'},MHM-Origin,409,0.09190051158269247
97,"static void handle_satn(ESPState *s)

{

    uint8_t buf[32];

    int len;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn;

        return;

    }

    len = get_cmd(s, buf);

    if (len)

        do_cmd(s, buf);

}
",60,"static void handle_satn(ESPState *s)

{

    uint8_t gen_op_jmp_v[32];

    int len;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn;

        return;

    }

    len = get_cmd(s, gen_op_jmp_v);

    if (len)

        do_cmd(s, gen_op_jmp_v);

}
",1,1,0,1,buf,-0.47013792395591736,1,3,{'buf': 'gen_op_jmp_v'},MHM-Origin,89,0.02102747360865275
99,"int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,

                   const char *version, const char *serial, const char *model,

                   uint64_t wwn,

                   uint32_t cylinders, uint32_t heads, uint32_t secs,

                   int chs_trans)

{

    uint64_t nb_sectors;



    s->blk = blk;

    s->drive_kind = kind;



    blk_get_geometry(blk, &nb_sectors);

    s->cylinders = cylinders;

    s->heads = heads;

    s->sectors = secs;

    s->chs_trans = chs_trans;

    s->nb_sectors = nb_sectors;

    s->wwn = wwn;

    /* The SMART values should be preserved across power cycles

       but they aren't.  */

    s->smart_enabled = 1;

    s->smart_autosave = 1;

    s->smart_errors = 0;

    s->smart_selftest_count = 0;

    if (kind == IDE_CD) {

        blk_set_dev_ops(blk, &ide_cd_block_ops, s);

        blk_set_guest_block_size(blk, 2048);

    } else {

        if (!blk_is_inserted(s->blk)) {

            error_report(""Device needs media, but drive is empty"");

            return -1;

        }

        if (blk_is_read_only(blk)) {

            error_report(""Can't use a read-only drive"");

            return -1;

        }

        blk_set_dev_ops(blk, &ide_hd_block_ops, s);

    }

    if (serial) {

        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);

    } else {

        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),

                 ""QM%05d"", s->drive_serial);

    }

    if (model) {

        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);

    } else {

        switch (kind) {

        case IDE_CD:

            strcpy(s->drive_model_str, ""QEMU DVD-ROM"");

            break;

        case IDE_CFATA:

            strcpy(s->drive_model_str, ""QEMU MICRODRIVE"");

            break;

        default:

            strcpy(s->drive_model_str, ""QEMU HARDDISK"");

            break;

        }

    }



    if (version) {

        pstrcpy(s->version, sizeof(s->version), version);

    } else {

        pstrcpy(s->version, sizeof(s->version), qemu_get_version());

    }



    ide_reset(s);

    blk_iostatus_enable(blk);

    return 0;

}
",383,"int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,

                   const char *version, const char *r0, const char *model,

                   uint64_t wwn,

                   uint32_t cylinders, uint32_t heads, uint32_t get_cabac_noinline,

                   int hostmem)

{

    uint64_t nb_sectors;



    s->blk = blk;

    s->drive_kind = kind;



    blk_get_geometry(blk, &nb_sectors);

    s->cylinders = cylinders;

    s->heads = heads;

    s->sectors = get_cabac_noinline;

    s->hostmem = hostmem;

    s->nb_sectors = nb_sectors;

    s->wwn = wwn;

    /* The SMART values should be preserved across power cycles

       but they aren't.  */

    s->smart_enabled = 1;

    s->smart_autosave = 1;

    s->smart_errors = 0;

    s->smart_selftest_count = 0;

    if (kind == IDE_CD) {

        blk_set_dev_ops(blk, &ide_cd_block_ops, s);

        blk_set_guest_block_size(blk, 2048);

    } else {

        if (!blk_is_inserted(s->blk)) {

            error_report(""Device needs media, but drive is empty"");

            return -1;

        }

        if (blk_is_read_only(blk)) {

            error_report(""Can't use a read-only drive"");

            return -1;

        }

        blk_set_dev_ops(blk, &ide_hd_block_ops, s);

    }

    if (r0) {

        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), r0);

    } else {

        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),

                 ""QM%05d"", s->drive_serial);

    }

    if (model) {

        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);

    } else {

        switch (kind) {

        case IDE_CD:

            strcpy(s->drive_model_str, ""QEMU DVD-ROM"");

            break;

        case IDE_CFATA:

            strcpy(s->drive_model_str, ""QEMU MICRODRIVE"");

            break;

        default:

            strcpy(s->drive_model_str, ""QEMU HARDDISK"");

            break;

        }

    }



    if (version) {

        pstrcpy(s->version, sizeof(s->version), version);

    } else {

        pstrcpy(s->version, sizeof(s->version), qemu_get_version());

    }



    ide_reset(s);

    blk_iostatus_enable(blk);

    return 0;

}
",0,0,1,1,serial,0.23589470982551575,3,8,"{'secs': 'get_cabac_noinline', 'chs_trans': 'hostmem', 'serial': 'r0'}",MHM-Origin,62,0.01740233103434245
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",51,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg output_zeros;



    output_zeros.iova = iova;

    output_zeros.size = len;

    output_zeros.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &output_zeros);

}
",1,1,0,1,imsg,-0.46808499097824097,1,5,{'imsg': 'output_zeros'},MHM-Origin,21,0.004660300413767497
101,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)

{

    uint32_t val;

    val = gic_dist_readb(opaque, offset);

    val |= gic_dist_readb(opaque, offset + 1) << 8;

    return val;

}
",41,"static uint32_t gic_dist_readw(void *NO_SENSE, target_phys_addr_t codingMode)

{

    uint32_t chapters_input_file;

    chapters_input_file = gic_dist_readb(NO_SENSE, codingMode);

    chapters_input_file |= gic_dist_readb(NO_SENSE, codingMode + 1) << 8;

    return chapters_input_file;

}
",0,0,1,1,val,0.7065444164909422,3,10,"{'offset': 'codingMode', 'opaque': 'NO_SENSE', 'val': 'chapters_input_file'}",MHM-Origin,370,0.08725515604019166
102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
",86,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *current_migration = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &current_migration, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(current_migration == str + strlen(str));

}
",0,0,1,1,endptr,0.4495672509074211,1,3,{'endptr': 'current_migration'},MHM-Origin,43,0.01025857130686442
103,"PXA2xxState *pxa255_init(unsigned int sdram_size)

{

    PXA2xxState *s;

    int iomemtype, i;

    DriveInfo *dinfo;



    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));



    s->env = cpu_init(""pxa255"");

    if (!s->env) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }

    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];



    /* SDRAM & Internal Memory Storage */

    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,

                    qemu_ram_alloc(NULL, ""pxa255.sdram"",

                                   sdram_size) | IO_MEM_RAM);

    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,

                    qemu_ram_alloc(NULL, ""pxa255.internal"",

                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);



    s->pic = pxa2xx_pic_init(0x40d00000, s->env);



    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);



    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);



    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);



    dinfo = drive_get(IF_SD, 0, 0);

    if (!dinfo) {

        fprintf(stderr, ""qemu: missing SecureDigital device\n"");

        exit(1);

    }

    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,

                              s->pic[PXA2XX_PIC_MMC], s->dma);



    for (i = 0; pxa255_serial[i].io_base; i ++)

        if (serial_hds[i]) {

#ifdef TARGET_WORDS_BIGENDIAN

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           s->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 1);

#else

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           s->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 0);

#endif

        } else {

            break;

        }

    if (serial_hds[i])

        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],

                        s->dma, serial_hds[i]);



    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);



    s->cm_base = 0x41300000;

    s->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */

    s->clkcfg = 0x00000009;		/* Turbo mode active */

    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,

                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_cm"", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);



    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);



    s->mm_base = 0x48000000;

    s->mm_regs[MDMRS >> 2] = 0x00020002;

    s->mm_regs[MDREFR >> 2] = 0x03ca4000;

    s->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */

    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,

                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_mm"", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);



    s->pm_base = 0x40f00000;

    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,

                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);

    register_savevm(NULL, ""pxa2xx_pm"", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);



    for (i = 0; pxa255_ssp[i].io_base; i ++);

    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);

    for (i = 0; pxa255_ssp[i].io_base; i ++) {

        DeviceState *dev;

        dev = sysbus_create_simple(""pxa2xx-ssp"", pxa255_ssp[i].io_base,

                                   s->pic[pxa255_ssp[i].irqn]);

        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, ""ssi"");

    }



    if (usb_enabled) {

        sysbus_create_simple(""sysbus-ohci"", 0x4c000000,

                             s->pic[PXA2XX_PIC_USBH1]);

    }



    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);

    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);



    s->rtc_base = 0x40900000;

    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,

                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);

    pxa2xx_rtc_init(s);

    register_savevm(NULL, ""pxa2xx_rtc"", 0, 0, pxa2xx_rtc_save,

                    pxa2xx_rtc_load, s);



    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);

    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);



    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);



    /* GPIO1 resets the processor */

    /* The handler can be overridden by board-specific code */

    qdev_connect_gpio_out(s->gpio, 1, s->reset);

    return s;

}
",885,"PXA2xxState *pxa255_init(unsigned int sdram_size)

{

    PXA2xxState *gen_helper_cmpxchg16b;

    int iomemtype, i;

    DriveInfo *dinfo;



    gen_helper_cmpxchg16b = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));



    gen_helper_cmpxchg16b->env = cpu_init(""pxa255"");

    if (!gen_helper_cmpxchg16b->env) {

        fprintf(stderr, ""Unable to find CPU definition
"");

        exit(1);

    }

    gen_helper_cmpxchg16b->reset = qemu_allocate_irqs(pxa2xx_reset, gen_helper_cmpxchg16b, 1)[0];



    /* SDRAM & Internal Memory Storage */

    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,

                    qemu_ram_alloc(NULL, ""pxa255.sdram"",

                                   sdram_size) | IO_MEM_RAM);

    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,

                    qemu_ram_alloc(NULL, ""pxa255.internal"",

                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);



    gen_helper_cmpxchg16b->pic = pxa2xx_pic_init(0x40d00000, gen_helper_cmpxchg16b->env);



    gen_helper_cmpxchg16b->dma = pxa255_dma_init(0x40000000, gen_helper_cmpxchg16b->pic[PXA2XX_PIC_DMA]);



    pxa25x_timer_init(0x40a00000, &gen_helper_cmpxchg16b->pic[PXA2XX_PIC_OST_0]);



    gen_helper_cmpxchg16b->gpio = pxa2xx_gpio_init(0x40e00000, gen_helper_cmpxchg16b->env, gen_helper_cmpxchg16b->pic, 85);



    dinfo = drive_get(IF_SD, 0, 0);

    if (!dinfo) {

        fprintf(stderr, ""qemu: missing SecureDigital device
"");

        exit(1);

    }

    gen_helper_cmpxchg16b->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,

                              gen_helper_cmpxchg16b->pic[PXA2XX_PIC_MMC], gen_helper_cmpxchg16b->dma);



    for (i = 0; pxa255_serial[i].io_base; i ++)

        if (serial_hds[i]) {

#ifdef TARGET_WORDS_BIGENDIAN

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           gen_helper_cmpxchg16b->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 1);

#else

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           gen_helper_cmpxchg16b->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 0);

#endif

        } else {

            break;

        }

    if (serial_hds[i])

        gen_helper_cmpxchg16b->fir = pxa2xx_fir_init(0x40800000, gen_helper_cmpxchg16b->pic[PXA2XX_PIC_ICP],

                        gen_helper_cmpxchg16b->dma, serial_hds[i]);



    gen_helper_cmpxchg16b->lcd = pxa2xx_lcdc_init(0x44000000, gen_helper_cmpxchg16b->pic[PXA2XX_PIC_LCD]);



    gen_helper_cmpxchg16b->cm_base = 0x41300000;

    gen_helper_cmpxchg16b->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */

    gen_helper_cmpxchg16b->clkcfg = 0x00000009;		/* Turbo mode active */

    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,

                    pxa2xx_cm_writefn, gen_helper_cmpxchg16b, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(gen_helper_cmpxchg16b->cm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_cm"", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, gen_helper_cmpxchg16b);



    cpu_arm_set_cp_io(gen_helper_cmpxchg16b->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, gen_helper_cmpxchg16b);



    gen_helper_cmpxchg16b->mm_base = 0x48000000;

    gen_helper_cmpxchg16b->mm_regs[MDMRS >> 2] = 0x00020002;

    gen_helper_cmpxchg16b->mm_regs[MDREFR >> 2] = 0x03ca4000;

    gen_helper_cmpxchg16b->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */

    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,

                    pxa2xx_mm_writefn, gen_helper_cmpxchg16b, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(gen_helper_cmpxchg16b->mm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_mm"", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, gen_helper_cmpxchg16b);



    gen_helper_cmpxchg16b->pm_base = 0x40f00000;

    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,

                    pxa2xx_pm_writefn, gen_helper_cmpxchg16b, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(gen_helper_cmpxchg16b->pm_base, 0x100, iomemtype);

    register_savevm(NULL, ""pxa2xx_pm"", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, gen_helper_cmpxchg16b);



    for (i = 0; pxa255_ssp[i].io_base; i ++);

    gen_helper_cmpxchg16b->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);

    for (i = 0; pxa255_ssp[i].io_base; i ++) {

        DeviceState *dev;

        dev = sysbus_create_simple(""pxa2xx-ssp"", pxa255_ssp[i].io_base,

                                   gen_helper_cmpxchg16b->pic[pxa255_ssp[i].irqn]);

        gen_helper_cmpxchg16b->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, ""ssi"");

    }



    if (usb_enabled) {

        sysbus_create_simple(""sysbus-ohci"", 0x4c000000,

                             gen_helper_cmpxchg16b->pic[PXA2XX_PIC_USBH1]);

    }



    gen_helper_cmpxchg16b->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);

    gen_helper_cmpxchg16b->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);



    gen_helper_cmpxchg16b->rtc_base = 0x40900000;

    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,

                    pxa2xx_rtc_writefn, gen_helper_cmpxchg16b, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(gen_helper_cmpxchg16b->rtc_base, 0x1000, iomemtype);

    pxa2xx_rtc_init(gen_helper_cmpxchg16b);

    register_savevm(NULL, ""pxa2xx_rtc"", 0, 0, pxa2xx_rtc_save,

                    pxa2xx_rtc_load, gen_helper_cmpxchg16b);



    gen_helper_cmpxchg16b->i2c[0] = pxa2xx_i2c_init(0x40301600, gen_helper_cmpxchg16b->pic[PXA2XX_PIC_I2C], 0xffff);

    gen_helper_cmpxchg16b->i2c[1] = pxa2xx_i2c_init(0x40f00100, gen_helper_cmpxchg16b->pic[PXA2XX_PIC_PWRI2C], 0xff);



    gen_helper_cmpxchg16b->i2s = pxa2xx_i2s_init(0x40400000, gen_helper_cmpxchg16b->pic[PXA2XX_PIC_I2S], gen_helper_cmpxchg16b->dma);



    /* GPIO1 resets the processor */

    /* The handler can be overridden by board-specific code */

    qdev_connect_gpio_out(gen_helper_cmpxchg16b->gpio, 1, gen_helper_cmpxchg16b->reset);

    return gen_helper_cmpxchg16b;

}
",0,0,1,1,s,0.243216872215271,1,64,{'s': 'gen_helper_cmpxchg16b'},MHM-Origin,22,0.00772327184677124
104,"int usb_device_delete_addr(int busnr, int addr)

{

    USBBus *bus;

    USBPort *port;

    USBDevice *dev;



    bus = usb_bus_find(busnr);

    if (!bus)

        return -1;



    TAILQ_FOREACH(port, &bus->used, next) {

        if (port->dev->addr == addr)

            break;

    }

    if (!port)

        return -1;



    dev = port->dev;

    TAILQ_REMOVE(&bus->used, port, next);

    bus->nused--;



    usb_attach(port, NULL);

    dev->info->handle_destroy(dev);



    TAILQ_INSERT_TAIL(&bus->free, port, next);

    bus->nfree++;

    return 0;

}
",131,"int usb_device_delete_addr(int HASH_PTE_SIZE_64, int meta_clusters)

{

    USBBus *listen_addr;

    USBPort *cbp;

    USBDevice *dflag;



    listen_addr = usb_bus_find(HASH_PTE_SIZE_64);

    if (!listen_addr)

        return -1;



    TAILQ_FOREACH(cbp, &listen_addr->used, next) {

        if (cbp->dflag->meta_clusters == meta_clusters)

            break;

    }

    if (!cbp)

        return -1;



    dflag = cbp->dflag;

    TAILQ_REMOVE(&listen_addr->used, cbp, next);

    listen_addr->bdi--;



    usb_attach(cbp, NULL);

    dflag->info->handle_destroy(dflag);



    TAILQ_INSERT_TAIL(&listen_addr->free, cbp, next);

    listen_addr->pict_type++;

    return 0;

}
",0,0,0,-1,dev,0.0001149703748524189,7,29,"{'nused': 'bdi', 'addr': 'meta_clusters', 'bus': 'listen_addr', 'nfree': 'pict_type', 'dev': 'dflag', 'port': 'cbp', 'busnr': 'HASH_PTE_SIZE_64'}",MHM-Origin,412,0.10265085299809774
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add(qov, name, qfloat_from_double(*obj));

}
",46,"static void qmp_output_type_number(Visitor *a0, const char *blocksize, double *gen_helper_fcom_ST0_FT0,

                                   Error **on_target_error)

{

    QmpOutputVisitor *D_FLAG = to_qov(a0);

    qmp_output_add(D_FLAG, blocksize, qfloat_from_double(*gen_helper_fcom_ST0_FT0));

}
",0,0,0,-1,name,-0.00039048073813319206,5,9,"{'obj': 'gen_helper_fcom_ST0_FT0', 'qov': 'D_FLAG', 'errp': 'on_target_error', 'v': 'a0', 'name': 'blocksize'}",MHM-Origin,414,0.09781548579533896
107,"static int alloc_refcount_block(BlockDriverState *bs,

    int64_t cluster_index, uint16_t **refcount_block)

{

    BDRVQcowState *s = bs->opaque;

    unsigned int refcount_table_index;

    int ret;



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    refcount_table_index = cluster_index >> s->refcount_block_bits;



    if (refcount_table_index < s->refcount_table_size) {



        uint64_t refcount_block_offset =

            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(s, refcount_block_offset)) {

                qcow2_signal_corruption(bs, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        refcount_table_index);

                return -EIO;

            }



             return load_refcount_block(bs, refcount_block_offset,

                 (void**) refcount_block);

        }

    }



    /*

     * If we came here, we need to allocate something. Something is at least

     * a cluster for the new refcount block. It may also include a new refcount

     * table if the old refcount table is too small.

     *

     * Note that allocating clusters here needs some special care:

     *

     * - We can't use the normal qcow2_alloc_clusters(), it would try to

     *   increase the refcount and very likely we would end up with an endless

     *   recursion. Instead we must place the refcount blocks in a way that

     *   they can describe them themselves.

     *

     * - We need to consider that at this point we are inside update_refcounts

     *   and potentially doing an initial refcount increase. This means that

     *   some clusters have already been allocated by the caller, but their

     *   refcount isn't accurate yet. If we allocate clusters for metadata, we

     *   need to return -EAGAIN to signal the caller that it needs to restart

     *   the search for free clusters.

     *

     * - alloc_clusters_noref and qcow2_free_clusters may load a different

     *   refcount block into the cache

     */



    *refcount_block = NULL;



    /* We write to the refcount table, so we might depend on L2 tables */

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {

        return ret;

    }



    /* Allocate the refcount block itself and mark it as used */

    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);

    if (new_block < 0) {

        return new_block;

    }



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Allocate refcount block %d for %"" PRIx64

        "" at %"" PRIx64 ""\n"",

        refcount_table_index, cluster_index << s->cluster_bits, new_block);

#endif



    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {

        /* Zero the new refcount block before updating it */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);



        /* The block describes itself, need to update the cache */

        int block_index = (new_block >> s->cluster_bits) &

            (s->refcount_block_size - 1);

        (*refcount_block)[block_index] = cpu_to_be16(1);

    } else {

        /* Described somewhere else. This can recurse at most twice before we

         * arrive at a block that describes itself. */

        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,

                              QCOW2_DISCARD_NEVER);

        if (ret < 0) {

            goto fail_block;

        }



        ret = qcow2_cache_flush(bs, s->refcount_block_cache);

        if (ret < 0) {

            goto fail_block;

        }



        /* Initialize the new refcount block only after updating its refcount,

         * update_refcount uses the refcount cache itself */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);

    }



    /* Now the new refcount block needs to be written to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);

    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);

    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {

        goto fail_block;

    }



    /* If the refcount table is big enough, just hook the block up there */

    if (refcount_table_index < s->refcount_table_size) {

        uint64_t data64 = cpu_to_be64(new_block);

        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);

        ret = bdrv_pwrite_sync(bs->file,

            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),

            &data64, sizeof(data64));

        if (ret < 0) {

            goto fail_block;

        }



        s->refcount_table[refcount_table_index] = new_block;



        /* The new refcount block may be where the caller intended to put its

         * data, so let it restart the search. */

        return -EAGAIN;

    }



    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    if (ret < 0) {

        goto fail_block;

    }



    /*

     * If we come here, we need to grow the refcount table. Again, a new

     * refcount table needs some space and we can't simply allocate to avoid

     * endless recursion.

     *

     * Therefore let's grab new refcount blocks at the end of the image, which

     * will describe themselves and the new refcount table. This way we can

     * reference them only in the new table and do the switch to the new

     * refcount table at once without producing an inconsistent state in

     * between.

     */

    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);



    /* Calculate the number of refcount blocks needed so far */

    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);



    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {

        return -EFBIG;

    }



    /* And now we need at least one block more for the new metadata */

    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);

    uint64_t last_table_size;

    uint64_t blocks_clusters;

    do {

        uint64_t table_clusters =

            size_to_clusters(s, table_size * sizeof(uint64_t));

        blocks_clusters = 1 +

            ((table_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size);

        uint64_t meta_clusters = table_clusters + blocks_clusters;



        last_table_size = table_size;

        table_size = next_refcount_table_size(s, blocks_used +

            ((meta_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size));



    } while (last_table_size != table_size);



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Grow refcount table %"" PRId32 "" => %"" PRId64 ""\n"",

        s->refcount_table_size, table_size);

#endif



    /* Create the new refcount table and blocks */

    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *

        s->cluster_size;

    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;

    uint64_t *new_table = g_try_new0(uint64_t, table_size);

    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);



    assert(table_size > 0 && blocks_clusters > 0);

    if (new_table == NULL || new_blocks == NULL) {

        ret = -ENOMEM;

        goto fail_table;

    }



    /* Fill the new refcount table */

    memcpy(new_table, s->refcount_table,

        s->refcount_table_size * sizeof(uint64_t));

    new_table[refcount_table_index] = new_block;



    int i;

    for (i = 0; i < blocks_clusters; i++) {

        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);

    }



    /* Fill the refcount blocks */

    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));

    int block = 0;

    for (i = 0; i < table_clusters + blocks_clusters; i++) {

        new_blocks[block++] = cpu_to_be16(1);

    }



    /* Write refcount blocks to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);

    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,

        blocks_clusters * s->cluster_size);

    g_free(new_blocks);

    new_blocks = NULL;

    if (ret < 0) {

        goto fail_table;

    }



    /* Write refcount table to disk */

    for(i = 0; i < table_size; i++) {

        cpu_to_be64s(&new_table[i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);

    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,

        table_size * sizeof(uint64_t));

    if (ret < 0) {

        goto fail_table;

    }



    for(i = 0; i < table_size; i++) {

        be64_to_cpus(&new_table[i]);

    }



    /* Hook up the new refcount table in the qcow2 header */

    uint8_t data[12];

    cpu_to_be64w((uint64_t*)data, table_offset);

    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);

    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),

        data, sizeof(data));

    if (ret < 0) {

        goto fail_table;

    }



    /* And switch it in memory */

    uint64_t old_table_offset = s->refcount_table_offset;

    uint64_t old_table_size = s->refcount_table_size;



    g_free(s->refcount_table);

    s->refcount_table = new_table;

    s->refcount_table_size = table_size;

    s->refcount_table_offset = table_offset;



    /* Free old table. */

    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),

                        QCOW2_DISCARD_OTHER);



    ret = load_refcount_block(bs, new_block, (void**) refcount_block);

    if (ret < 0) {

        return ret;

    }



    /* If we were trying to do the initial refcount update for some cluster

     * allocation, we might have used the same clusters to store newly

     * allocated metadata. Make the caller search some new space. */

    return -EAGAIN;



fail_table:

    g_free(new_blocks);

    g_free(new_table);

fail_block:

    if (*refcount_block != NULL) {

        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    }

    return ret;

}
",1235,"static int alloc_refcount_block(BlockDriverState *bs,

    int64_t cluster_index, uint16_t **mpeg_f_code)

{

    BDRVQcowState *s = bs->opaque;

    unsigned int refcount_table_index;

    int ret;



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    refcount_table_index = cluster_index >> s->refcount_block_bits;



    if (refcount_table_index < s->refcount_table_size) {



        uint64_t refcount_block_offset =

            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(s, refcount_block_offset)) {

                qcow2_signal_corruption(bs, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        refcount_table_index);

                return -EIO;

            }



             return load_refcount_block(bs, refcount_block_offset,

                 (void**) mpeg_f_code);

        }

    }



    /*

     * If we came here, we need to allocate something. Something is at least

     * a cluster for the new refcount block. It may also include a new refcount

     * table if the old refcount table is too small.

     *

     * Note that allocating clusters here needs some special care:

     *

     * - We can't use the normal qcow2_alloc_clusters(), it would try to

     *   increase the refcount and very likely we would end up with an endless

     *   recursion. Instead we must place the refcount blocks in a way that

     *   they can describe them themselves.

     *

     * - We need to consider that at this point we are inside update_refcounts

     *   and potentially doing an initial refcount increase. This means that

     *   some clusters have already been allocated by the caller, but their

     *   refcount isn't accurate yet. If we allocate clusters for metadata, we

     *   need to return -EAGAIN to signal the caller that it needs to restart

     *   the search for free clusters.

     *

     * - alloc_clusters_noref and qcow2_free_clusters may load a different

     *   refcount block into the cache

     */



    *mpeg_f_code = NULL;



    /* We write to the refcount table, so we might depend on L2 tables */

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {

        return ret;

    }



    /* Allocate the refcount block itself and mark it as used */

    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);

    if (new_block < 0) {

        return new_block;

    }



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Allocate refcount block %d for %"" PRIx64

        "" at %"" PRIx64 ""
"",

        refcount_table_index, cluster_index << s->cluster_bits, new_block);

#endif



    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {

        /* Zero the new refcount block before updating it */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) mpeg_f_code);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*mpeg_f_code, 0, s->cluster_size);



        /* The block describes itself, need to update the cache */

        int block_index = (new_block >> s->cluster_bits) &

            (s->refcount_block_size - 1);

        (*mpeg_f_code)[block_index] = cpu_to_be16(1);

    } else {

        /* Described somewhere else. This can recurse at most twice before we

         * arrive at a block that describes itself. */

        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,

                              QCOW2_DISCARD_NEVER);

        if (ret < 0) {

            goto fail_block;

        }



        ret = qcow2_cache_flush(bs, s->refcount_block_cache);

        if (ret < 0) {

            goto fail_block;

        }



        /* Initialize the new refcount block only after updating its refcount,

         * update_refcount uses the refcount cache itself */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) mpeg_f_code);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*mpeg_f_code, 0, s->cluster_size);

    }



    /* Now the new refcount block needs to be written to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);

    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *mpeg_f_code);

    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {

        goto fail_block;

    }



    /* If the refcount table is big enough, just hook the block up there */

    if (refcount_table_index < s->refcount_table_size) {

        uint64_t data64 = cpu_to_be64(new_block);

        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);

        ret = bdrv_pwrite_sync(bs->file,

            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),

            &data64, sizeof(data64));

        if (ret < 0) {

            goto fail_block;

        }



        s->refcount_table[refcount_table_index] = new_block;



        /* The new refcount block may be where the caller intended to put its

         * data, so let it restart the search. */

        return -EAGAIN;

    }



    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) mpeg_f_code);

    if (ret < 0) {

        goto fail_block;

    }



    /*

     * If we come here, we need to grow the refcount table. Again, a new

     * refcount table needs some space and we can't simply allocate to avoid

     * endless recursion.

     *

     * Therefore let's grab new refcount blocks at the end of the image, which

     * will describe themselves and the new refcount table. This way we can

     * reference them only in the new table and do the switch to the new

     * refcount table at once without producing an inconsistent state in

     * between.

     */

    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);



    /* Calculate the number of refcount blocks needed so far */

    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);



    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {

        return -EFBIG;

    }



    /* And now we need at least one block more for the new metadata */

    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);

    uint64_t last_table_size;

    uint64_t blocks_clusters;

    do {

        uint64_t table_clusters =

            size_to_clusters(s, table_size * sizeof(uint64_t));

        blocks_clusters = 1 +

            ((table_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size);

        uint64_t meta_clusters = table_clusters + blocks_clusters;



        last_table_size = table_size;

        table_size = next_refcount_table_size(s, blocks_used +

            ((meta_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size));



    } while (last_table_size != table_size);



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Grow refcount table %"" PRId32 "" => %"" PRId64 ""
"",

        s->refcount_table_size, table_size);

#endif



    /* Create the new refcount table and blocks */

    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *

        s->cluster_size;

    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;

    uint64_t *new_table = g_try_new0(uint64_t, table_size);

    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);



    assert(table_size > 0 && blocks_clusters > 0);

    if (new_table == NULL || new_blocks == NULL) {

        ret = -ENOMEM;

        goto fail_table;

    }



    /* Fill the new refcount table */

    memcpy(new_table, s->refcount_table,

        s->refcount_table_size * sizeof(uint64_t));

    new_table[refcount_table_index] = new_block;



    int i;

    for (i = 0; i < blocks_clusters; i++) {

        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);

    }



    /* Fill the refcount blocks */

    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));

    int block = 0;

    for (i = 0; i < table_clusters + blocks_clusters; i++) {

        new_blocks[block++] = cpu_to_be16(1);

    }



    /* Write refcount blocks to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);

    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,

        blocks_clusters * s->cluster_size);

    g_free(new_blocks);

    new_blocks = NULL;

    if (ret < 0) {

        goto fail_table;

    }



    /* Write refcount table to disk */

    for(i = 0; i < table_size; i++) {

        cpu_to_be64s(&new_table[i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);

    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,

        table_size * sizeof(uint64_t));

    if (ret < 0) {

        goto fail_table;

    }



    for(i = 0; i < table_size; i++) {

        be64_to_cpus(&new_table[i]);

    }



    /* Hook up the new refcount table in the qcow2 header */

    uint8_t data[12];

    cpu_to_be64w((uint64_t*)data, table_offset);

    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);

    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),

        data, sizeof(data));

    if (ret < 0) {

        goto fail_table;

    }



    /* And switch it in memory */

    uint64_t old_table_offset = s->refcount_table_offset;

    uint64_t old_table_size = s->refcount_table_size;



    g_free(s->refcount_table);

    s->refcount_table = new_table;

    s->refcount_table_size = table_size;

    s->refcount_table_offset = table_offset;



    /* Free old table. */

    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),

                        QCOW2_DISCARD_OTHER);



    ret = load_refcount_block(bs, new_block, (void**) mpeg_f_code);

    if (ret < 0) {

        return ret;

    }



    /* If we were trying to do the initial refcount update for some cluster

     * allocation, we might have used the same clusters to store newly

     * allocated metadata. Make the caller search some new space. */

    return -EAGAIN;



fail_table:

    g_free(new_blocks);

    g_free(new_table);

fail_block:

    if (*mpeg_f_code != NULL) {

        qcow2_cache_put(bs, s->refcount_block_cache, (void**) mpeg_f_code);

    }

    return ret;

}
",1,1,0,1,refcount_block,-0.18491899967193604,1,13,{'refcount_block': 'mpeg_f_code'},MHM-Origin,23,0.009428338209788004
109,"static int getopt(int argc, char *argv[], char *opts)

{

    static int sp = 1;

    int c;

    char *cp;



    if (sp == 1)

        if (optind >= argc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][sp];

    if (c == ':' || (cp = strchr(opts, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c\n"", c);

        if (argv[optind][++sp] == '\0') {

            optind++;

            sp = 1;

        }

        return '?';

    }

    if (*++cp == ':') {

        if (argv[optind][sp+1] != '\0')

            optarg = &argv[optind++][sp+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c\n"", c);

            sp = 1;

            return '?';

        } else

            optarg = argv[optind++];

        sp = 1;

    } else {

        if (argv[optind][++sp] == '\0') {

            sp = 1;

            optind++;

        }

        optarg = NULL;

    }



    return c;

}
",281,"static int getopt(int argc, char *argv[], char *QEMU_GNUC_PREREQ)

{

    static int save_cpu_state = 1;

    int c;

    char *opus_fade;



    if (save_cpu_state == 1)

        if (optind >= argc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][save_cpu_state];

    if (c == ':' || (opus_fade = strchr(QEMU_GNUC_PREREQ, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c
"", c);

        if (argv[optind][++save_cpu_state] == '\0') {

            optind++;

            save_cpu_state = 1;

        }

        return '?';

    }

    if (*++opus_fade == ':') {

        if (argv[optind][save_cpu_state+1] != '\0')

            optarg = &argv[optind++][save_cpu_state+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c
"", c);

            save_cpu_state = 1;

            return '?';

        } else

            optarg = argv[optind++];

        save_cpu_state = 1;

    } else {

        if (argv[optind][++save_cpu_state] == '\0') {

            save_cpu_state = 1;

            optind++;

        }

        optarg = NULL;

    }



    return c;

}
",0,0,1,1,opts,0.17627200484275818,3,16,"{'sp': 'save_cpu_state', 'cp': 'opus_fade', 'opts': 'QEMU_GNUC_PREREQ'}",MHM-Origin,85,0.021473304430643717
110,"static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,

                                    uint32_t val)

{

    SLAVIO_TIMERState *s = opaque;

    uint32_t saddr;

    int reload = 0;



    DPRINTF(""write "" TARGET_FMT_plx "" %08x\n"", addr, val);

    saddr = (addr & TIMER_MAXADDR) >> 2;

    switch (saddr) {

    case TIMER_LIMIT:

        if (slavio_timer_is_user(s)) {

            // set user counter MSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else {

            // set limit, reset counter

            qemu_irq_lower(s->irq);

            s->limit = val & TIMER_MAX_COUNT32;

            if (!s->limit)

                s->limit = TIMER_MAX_COUNT32;

            ptimer_set_limit(s->timer, s->limit >> 9, 1);

        }

        break;

    case TIMER_COUNTER:

        if (slavio_timer_is_user(s)) {

            // set user counter LSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else

            DPRINTF(""not user timer\n"");

        break;

    case TIMER_COUNTER_NORST:

        // set limit without resetting counter

        s->limit = val & TIMER_MAX_COUNT32;

        if (!s->limit)

            s->limit = TIMER_MAX_COUNT32;

        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);

        break;

    case TIMER_STATUS:

        if (slavio_timer_is_user(s)) {

            // start/stop user counter

            if ((val & 1) && !s->running) {

                DPRINTF(""processor %d user timer started\n"", s->slave_index);

                ptimer_run(s->timer, 0);

                s->running = 1;

            } else if (!(val & 1) && s->running) {

                DPRINTF(""processor %d user timer stopped\n"", s->slave_index);

                ptimer_stop(s->timer);

                s->running = 0;

            }

        }

        break;

    case TIMER_MODE:

        if (s->master == NULL) {

            unsigned int i;



            for (i = 0; i < s->num_slaves; i++) {

                if (val & (1 << i)) {

                    qemu_irq_lower(s->slave[i]->irq);

                    s->slave[i]->limit = -1ULL;

                }

                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {

                    ptimer_stop(s->slave[i]->timer);

                    ptimer_set_limit(s->slave[i]->timer,

                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);

                    DPRINTF(""processor %d timer changed\n"",

                            s->slave[i]->slave_index);

                    ptimer_run(s->slave[i]->timer, 0);

                }

            }

            s->slave_mode = val & ((1 << s->num_slaves) - 1);

        } else

            DPRINTF(""not system timer\n"");

        break;

    default:

        DPRINTF(""invalid write address "" TARGET_FMT_plx ""\n"", addr);

        break;

    }

}
",557,"static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,

                                    uint32_t SVM_EXIT_PUSHF)

{

    SLAVIO_TIMERState *s = opaque;

    uint32_t saddr;

    int reload = 0;



    DPRINTF(""write "" TARGET_FMT_plx "" %08x
"", addr, SVM_EXIT_PUSHF);

    saddr = (addr & TIMER_MAXADDR) >> 2;

    switch (saddr) {

    case TIMER_LIMIT:

        if (slavio_timer_is_user(s)) {

            // set user counter MSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset
"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else {

            // set limit, reset counter

            qemu_irq_lower(s->irq);

            s->limit = SVM_EXIT_PUSHF & TIMER_MAX_COUNT32;

            if (!s->limit)

                s->limit = TIMER_MAX_COUNT32;

            ptimer_set_limit(s->timer, s->limit >> 9, 1);

        }

        break;

    case TIMER_COUNTER:

        if (slavio_timer_is_user(s)) {

            // set user counter LSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset
"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else

            DPRINTF(""not user timer
"");

        break;

    case TIMER_COUNTER_NORST:

        // set limit without resetting counter

        s->limit = SVM_EXIT_PUSHF & TIMER_MAX_COUNT32;

        if (!s->limit)

            s->limit = TIMER_MAX_COUNT32;

        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);

        break;

    case TIMER_STATUS:

        if (slavio_timer_is_user(s)) {

            // start/stop user counter

            if ((SVM_EXIT_PUSHF & 1) && !s->running) {

                DPRINTF(""processor %d user timer started
"", s->slave_index);

                ptimer_run(s->timer, 0);

                s->running = 1;

            } else if (!(SVM_EXIT_PUSHF & 1) && s->running) {

                DPRINTF(""processor %d user timer stopped
"", s->slave_index);

                ptimer_stop(s->timer);

                s->running = 0;

            }

        }

        break;

    case TIMER_MODE:

        if (s->master == NULL) {

            unsigned int i;



            for (i = 0; i < s->num_slaves; i++) {

                if (SVM_EXIT_PUSHF & (1 << i)) {

                    qemu_irq_lower(s->slave[i]->irq);

                    s->slave[i]->limit = -1ULL;

                }

                if ((SVM_EXIT_PUSHF & (1 << i)) != (s->slave_mode & (1 << i))) {

                    ptimer_stop(s->slave[i]->timer);

                    ptimer_set_limit(s->slave[i]->timer,

                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);

                    DPRINTF(""processor %d timer changed
"",

                            s->slave[i]->slave_index);

                    ptimer_run(s->slave[i]->timer, 0);

                }

            }

            s->slave_mode = SVM_EXIT_PUSHF & ((1 << s->num_slaves) - 1);

        } else

            DPRINTF(""not system timer
"");

        break;

    default:

        DPRINTF(""invalid write address "" TARGET_FMT_plx ""
"", addr);

        break;

    }

}
",0,0,1,1,val,0.4996839463710785,1,9,{'val': 'SVM_EXIT_PUSHF'},MHM-Origin,21,0.0061825871467590336
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",104,"static void temp_allocate_frame(TCGContext *iovec, int temp)

{

    TCGTemp *ts;

    ts = &iovec->temps[temp];

    iovec->current_frame_offset = (iovec->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (iovec->current_frame_offset + sizeof(tcg_target_long) > iovec->frame_end)

        tcg_abort();

    ts->mem_offset = iovec->current_frame_offset;

    ts->mem_reg = iovec->frame_reg;

    ts->mem_allocated = 1;

    iovec->current_frame_offset += sizeof(tcg_target_long);

}
",0,0,1,1,s,0.28540563583374023,1,9,{'s': 'iovec'},MHM-Origin,23,0.005521225929260254
113,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",150,"void qmp_block_stream(const char *device, bool qemu_coroutine_yield,

                      const char *istcp, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (istcp) {

        base_bs = bdrv_find_backing_image(bs, istcp);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, istcp);

            return;

        }

    }



    stream_start(bs, base_bs, istcp, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",0,0,1,1,has_base,0.28622524440288544,2,6,"{'base': 'istcp', 'has_base': 'qemu_coroutine_yield'}",MHM-Origin,42,0.010863117376963298
115,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
",38,"static inline int num_effective_busses(XilinxSPIPS *samplerate)

{

    return (samplerate->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            samplerate->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? samplerate->num_busses : 1;

}
",0,0,0,-1,s,-0.043312844820320606,1,4,{'s': 'MirrorBlockJob'},MHM-Origin,411,0.0977219025293986
117,"static void gen_set_CF_bit31(TCGv var)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, var, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
",35,"static void gen_set_CF_bit31(TCGv grp2)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, grp2, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
",1,1,1,-1,var,-0.00016158819198608398,1,2,{'var': 'grp2'},MHM-Origin,413,0.09639643430709839
118,"static int get_siz(Jpeg2000DecoderContext *s)
{
    int i;
    int ncomponents;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *possible_fmts = NULL;
    int possible_fmts_nb = 0;
    if (bytestream2_get_bytes_left(&s->g) < 36) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for SIZ\n"");
    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz
    s->width          = bytestream2_get_be32u(&s->g); // Width
    s->height         = bytestream2_get_be32u(&s->g); // Height
    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz
    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz
    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz
    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz
    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz
    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz
    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz
    if (s->image_offset_x || s->image_offset_y) {
        avpriv_request_sample(s->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {
        avpriv_request_sample(s->avctx, ""Large Dimensions"");
        return AVERROR_PATCHWELCOME;
    if (ncomponents <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"",
    if (ncomponents > 4) {
        avpriv_request_sample(s->avctx, ""Support for %d components"",
                              ncomponents);
        return AVERROR_PATCHWELCOME;
    s->ncomponents = ncomponents;
    if (s->tile_width <= 0 || s->tile_height <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"",
               s->tile_width, s->tile_height);
    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for %d components in SIZ\n"", s->ncomponents);
    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i
        uint8_t x    = bytestream2_get_byteu(&s->g);
        s->cbps[i]   = (x & 0x7f) + 1;
        s->precision = FFMAX(s->cbps[i], s->precision);
        s->sgnd[i]   = !!(x & 0x80);
        s->cdx[i]    = bytestream2_get_byteu(&s->g);
        s->cdy[i]    = bytestream2_get_byteu(&s->g);
        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {
            av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d\n"", s->cdx[i], s->cdy[i]);
        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;
    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);
    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);
    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(EINVAL);
    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));
    if (!s->tile) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(ENOMEM);
    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {
        Jpeg2000Tile *tile = s->tile + i;
        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));
        if (!tile->comp)
            return AVERROR(ENOMEM);
    /* compute image size with reduction factor */
    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,
                                               s->reduction_factor);
    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,
                                               s->reduction_factor);
    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
        possible_fmts = xyz_pix_fmts;
        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
    } else {
        switch (s->colour_space) {
        case 16:
            possible_fmts = rgb_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
            break;
        case 17:
            possible_fmts = gray_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
            break;
        case 18:
            possible_fmts = yuv_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
            break;
        default:
            possible_fmts = all_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
            break;
    for (i = 0; i < possible_fmts_nb; ++i) {
        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {
            s->avctx->pix_fmt = possible_fmts[i];
            break;
    if (i == possible_fmts_nb) {
        if (ncomponents == 4 &&
            s->cdy[0] == 1 && s->cdx[0] == 1 &&
            s->cdy[1] == 1 && s->cdx[1] == 1 &&
            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {
            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {
                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
                s->cdef[0] = 0;
                s->cdef[1] = 1;
                s->cdef[2] = 2;
                s->cdef[3] = 3;
                i = 0;
    if (i == possible_fmts_nb) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d\n""
               ""cdx[0]: %d, cdy[0]: %d\n""
               ""cdx[1]: %d, cdy[1]: %d\n""
               ""cdx[2]: %d, cdy[2]: %d\n""
               ""cdx[3]: %d, cdy[3]: %d\n"",
               s->avctx->profile, s->colour_space, ncomponents, s->precision,
               s->cdx[0],
               s->cdy[0],
               ncomponents > 1 ? s->cdx[1] : 0,
               ncomponents > 1 ? s->cdy[1] : 0,
               ncomponents > 2 ? s->cdx[2] : 0,
               ncomponents > 2 ? s->cdy[2] : 0,
               ncomponents > 3 ? s->cdx[3] : 0,
               ncomponents > 3 ? s->cdy[3] : 0);
        return AVERROR_PATCHWELCOME;
    s->avctx->bits_per_raw_sample = s->precision;
    return 0;",1259,"static int get_siz(Jpeg2000DecoderContext *tcg_insn_unit)
{
    int mtime_fail;
    int drive_get_max_bus;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *CPU_LOG_TB_IN_ASM = NULL;
    int possible_fmts_nb = 0;
    if (bytestream2_get_bytes_left(&tcg_insn_unit->g) < 36) {
        av_log(tcg_insn_unit->avctx, AV_LOG_ERROR, ""Insufficient space for SIZ
"");
    tcg_insn_unit->avctx->profile = bytestream2_get_be16u(&tcg_insn_unit->g); // Rsiz
    tcg_insn_unit->width          = bytestream2_get_be32u(&tcg_insn_unit->g); // Width
    tcg_insn_unit->height         = bytestream2_get_be32u(&tcg_insn_unit->g); // Height
    tcg_insn_unit->image_offset_x = bytestream2_get_be32u(&tcg_insn_unit->g); // X0Siz
    tcg_insn_unit->image_offset_y = bytestream2_get_be32u(&tcg_insn_unit->g); // Y0Siz
    tcg_insn_unit->tile_width     = bytestream2_get_be32u(&tcg_insn_unit->g); // XTSiz
    tcg_insn_unit->tile_height    = bytestream2_get_be32u(&tcg_insn_unit->g); // YTSiz
    tcg_insn_unit->tile_offset_x  = bytestream2_get_be32u(&tcg_insn_unit->g); // XT0Siz
    tcg_insn_unit->tile_offset_y  = bytestream2_get_be32u(&tcg_insn_unit->g); // YT0Siz
    drive_get_max_bus       = bytestream2_get_be16u(&tcg_insn_unit->g); // CSiz
    if (tcg_insn_unit->image_offset_x || tcg_insn_unit->image_offset_y) {
        avpriv_request_sample(tcg_insn_unit->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    if (av_image_check_size(tcg_insn_unit->width, tcg_insn_unit->height, 0, tcg_insn_unit->avctx)) {
        avpriv_request_sample(tcg_insn_unit->avctx, ""Large Dimensions"");
        return AVERROR_PATCHWELCOME;
    if (drive_get_max_bus <= 0) {
        av_log(tcg_insn_unit->avctx, AV_LOG_ERROR, ""Invalid number of components: %d
"",
    if (drive_get_max_bus > 4) {
        avpriv_request_sample(tcg_insn_unit->avctx, ""Support for %d components"",
                              drive_get_max_bus);
        return AVERROR_PATCHWELCOME;
    tcg_insn_unit->drive_get_max_bus = drive_get_max_bus;
    if (tcg_insn_unit->tile_width <= 0 || tcg_insn_unit->tile_height <= 0) {
        av_log(tcg_insn_unit->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.
"",
               tcg_insn_unit->tile_width, tcg_insn_unit->tile_height);
    if (bytestream2_get_bytes_left(&tcg_insn_unit->g) < 3 * tcg_insn_unit->drive_get_max_bus) {
        av_log(tcg_insn_unit->avctx, AV_LOG_ERROR, ""Insufficient space for %d components in SIZ
"", tcg_insn_unit->drive_get_max_bus);
    for (mtime_fail = 0; mtime_fail < tcg_insn_unit->drive_get_max_bus; mtime_fail++) { // Ssiz_i XRsiz_i, YRsiz_i
        uint8_t x    = bytestream2_get_byteu(&tcg_insn_unit->g);
        tcg_insn_unit->cbps[mtime_fail]   = (x & 0x7f) + 1;
        tcg_insn_unit->precision = FFMAX(tcg_insn_unit->cbps[mtime_fail], tcg_insn_unit->precision);
        tcg_insn_unit->sgnd[mtime_fail]   = !!(x & 0x80);
        tcg_insn_unit->cdx[mtime_fail]    = bytestream2_get_byteu(&tcg_insn_unit->g);
        tcg_insn_unit->cdy[mtime_fail]    = bytestream2_get_byteu(&tcg_insn_unit->g);
        if (   !tcg_insn_unit->cdx[mtime_fail] || tcg_insn_unit->cdx[mtime_fail] == 3 || tcg_insn_unit->cdx[mtime_fail] > 4
            || !tcg_insn_unit->cdy[mtime_fail] || tcg_insn_unit->cdy[mtime_fail] == 3 || tcg_insn_unit->cdy[mtime_fail] > 4) {
            av_log(tcg_insn_unit->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d
"", tcg_insn_unit->cdx[mtime_fail], tcg_insn_unit->cdy[mtime_fail]);
        log2_chroma_wh |= tcg_insn_unit->cdy[mtime_fail] >> 1 << mtime_fail * 4 | tcg_insn_unit->cdx[mtime_fail] >> 1 << mtime_fail * 4 + 2;
    tcg_insn_unit->numXtiles = ff_jpeg2000_ceildiv(tcg_insn_unit->width  - tcg_insn_unit->tile_offset_x, tcg_insn_unit->tile_width);
    tcg_insn_unit->numYtiles = ff_jpeg2000_ceildiv(tcg_insn_unit->height - tcg_insn_unit->tile_offset_y, tcg_insn_unit->tile_height);
    if (tcg_insn_unit->numXtiles * (uint64_t)tcg_insn_unit->numYtiles > INT_MAX/sizeof(*tcg_insn_unit->BlockDriverAIOCB)) {
        tcg_insn_unit->numXtiles = tcg_insn_unit->numYtiles = 0;
        return AVERROR(EINVAL);
    tcg_insn_unit->BlockDriverAIOCB = av_mallocz_array(tcg_insn_unit->numXtiles * tcg_insn_unit->numYtiles, sizeof(*tcg_insn_unit->BlockDriverAIOCB));
    if (!tcg_insn_unit->BlockDriverAIOCB) {
        tcg_insn_unit->numXtiles = tcg_insn_unit->numYtiles = 0;
        return AVERROR(ENOMEM);
    for (mtime_fail = 0; mtime_fail < tcg_insn_unit->numXtiles * tcg_insn_unit->numYtiles; mtime_fail++) {
        Jpeg2000Tile *BlockDriverAIOCB = tcg_insn_unit->BlockDriverAIOCB + mtime_fail;
        BlockDriverAIOCB->comp = av_mallocz(tcg_insn_unit->drive_get_max_bus * sizeof(*BlockDriverAIOCB->comp));
        if (!BlockDriverAIOCB->comp)
            return AVERROR(ENOMEM);
    /* compute image size with reduction factor */
    tcg_insn_unit->avctx->width  = ff_jpeg2000_ceildivpow2(tcg_insn_unit->width  - tcg_insn_unit->image_offset_x,
                                               tcg_insn_unit->reduction_factor);
    tcg_insn_unit->avctx->height = ff_jpeg2000_ceildivpow2(tcg_insn_unit->height - tcg_insn_unit->image_offset_y,
                                               tcg_insn_unit->reduction_factor);
    if (tcg_insn_unit->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
        tcg_insn_unit->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
        CPU_LOG_TB_IN_ASM = xyz_pix_fmts;
        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
    } else {
        switch (tcg_insn_unit->colour_space) {
        case 16:
            CPU_LOG_TB_IN_ASM = rgb_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
            break;
        case 17:
            CPU_LOG_TB_IN_ASM = gray_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
            break;
        case 18:
            CPU_LOG_TB_IN_ASM = yuv_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
            break;
        default:
            CPU_LOG_TB_IN_ASM = all_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
            break;
    for (mtime_fail = 0; mtime_fail < possible_fmts_nb; ++mtime_fail) {
        if (pix_fmt_match(CPU_LOG_TB_IN_ASM[mtime_fail], drive_get_max_bus, tcg_insn_unit->precision, log2_chroma_wh, tcg_insn_unit->pal8)) {
            tcg_insn_unit->avctx->pix_fmt = CPU_LOG_TB_IN_ASM[mtime_fail];
            break;
    if (mtime_fail == possible_fmts_nb) {
        if (drive_get_max_bus == 4 &&
            tcg_insn_unit->cdy[0] == 1 && tcg_insn_unit->cdx[0] == 1 &&
            tcg_insn_unit->cdy[1] == 1 && tcg_insn_unit->cdx[1] == 1 &&
            tcg_insn_unit->cdy[2] == tcg_insn_unit->cdy[3] && tcg_insn_unit->cdx[2] == tcg_insn_unit->cdx[3]) {
            if (tcg_insn_unit->precision == 8 && tcg_insn_unit->cdy[2] == 2 && tcg_insn_unit->cdx[2] == 2 && !tcg_insn_unit->pal8) {
                tcg_insn_unit->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
                tcg_insn_unit->cdef[0] = 0;
                tcg_insn_unit->cdef[1] = 1;
                tcg_insn_unit->cdef[2] = 2;
                tcg_insn_unit->cdef[3] = 3;
                mtime_fail = 0;
    if (mtime_fail == possible_fmts_nb) {
        av_log(tcg_insn_unit->avctx, AV_LOG_ERROR,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d
""
               ""cdx[0]: %d, cdy[0]: %d
""
               ""cdx[1]: %d, cdy[1]: %d
""
               ""cdx[2]: %d, cdy[2]: %d
""
               ""cdx[3]: %d, cdy[3]: %d
"",
               tcg_insn_unit->avctx->profile, tcg_insn_unit->colour_space, drive_get_max_bus, tcg_insn_unit->precision,
               tcg_insn_unit->cdx[0],
               tcg_insn_unit->cdy[0],
               drive_get_max_bus > 1 ? tcg_insn_unit->cdx[1] : 0,
               drive_get_max_bus > 1 ? tcg_insn_unit->cdy[1] : 0,
               drive_get_max_bus > 2 ? tcg_insn_unit->cdx[2] : 0,
               drive_get_max_bus > 2 ? tcg_insn_unit->cdy[2] : 0,
               drive_get_max_bus > 3 ? tcg_insn_unit->cdx[3] : 0,
               drive_get_max_bus > 3 ? tcg_insn_unit->cdy[3] : 0);
        return AVERROR_PATCHWELCOME;
    tcg_insn_unit->avctx->bits_per_raw_sample = tcg_insn_unit->precision;
    return 0;",1,1,1,-1,i,-0.00042170286178588867,5,202,"{'s': 'tcg_insn_unit', 'possible_fmts': 'CPU_LOG_TB_IN_ASM', 'ncomponents': 'drive_get_max_bus', 'tile': 'BlockDriverAIOCB', 'i': 'mtime_fail'}",MHM-Origin,409,0.17273094256718954
120,"static void sd_1d97_int(int *p, int i0, int i1)

{

    int i;



    if (i1 <= i0 + 1) {

        if (i0 == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, i0, i1);

    i0++; i1++;



    for (i = i0/2 - 2; i < i1/2 + 1; i++)

        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2 + 1; i++)

        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2; i++)

        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2; i < i1/2; i++)

        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

}
",331,"static void sd_1d97_int(int *p, int cpuid_ext_features, int i1)

{

    int i;



    if (i1 <= cpuid_ext_features + 1) {

        if (cpuid_ext_features == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, cpuid_ext_features, i1);

    cpuid_ext_features++; i1++;



    for (i = cpuid_ext_features/2 - 2; i < i1/2 + 1; i++)

        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = cpuid_ext_features/2 - 1; i < i1/2 + 1; i++)

        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

    for (i = cpuid_ext_features/2 - 1; i < i1/2; i++)

        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = cpuid_ext_features/2; i < i1/2; i++)

        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

}
",1,1,0,1,i0,-0.6027644872665405,1,9,{'i0': 'cpuid_ext_features'},MHM-Origin,23,0.00558317502339681
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",128,"static inline void RENAME(rgb32ToY)(uint8_t *completed, uint8_t *xen_9pfs_free, int width)

{

	int allocated_size;

	for(allocated_size=0; allocated_size<width; allocated_size++)

	{

		int r=  ((uint32_t*)xen_9pfs_free)[allocated_size]&0xFF;

		int g= (((uint32_t*)xen_9pfs_free)[allocated_size]>>8)&0xFF;

		int b= (((uint32_t*)xen_9pfs_free)[allocated_size]>>16)&0xFF;



		completed[allocated_size]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",1,1,0,1,src,-0.883242167532444,3,14,"{'i': 'allocated_size', 'dst': 'completed', 'src': 'xen_9pfs_free'}",MHM-Origin,143,0.03478051821390788
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",61,"static uint32_t s390_pci_generate_fid(Error **trace_megasas_dcmd_internal_submit)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(trace_megasas_dcmd_internal_submit, ""no free fid could be found"");

    return 0;

}
",0,0,1,1,errp,0.7646681442856789,1,2,{'errp': 'trace_megasas_dcmd_internal_submit'},MHM-Origin,22,0.005081367492675781
123,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
",54,"static void virtio_9p_device_unrealize(DeviceState *optctx, Error **MIPS_FPU_MAX)

{

    VirtIODevice *selected_streams = VIRTIO_DEVICE(optctx);

    V9fsVirtioState *Mpeg1Context = VIRTIO_9P(optctx);

    V9fsState *level_table = &Mpeg1Context->state;



    virtio_cleanup(selected_streams);

    v9fs_device_unrealize_common(level_table, MIPS_FPU_MAX);

}
",0,0,0,-1,errp,-0.0013979990035295486,5,11,"{'s': 'level_table', 'dev': 'optctx', 'vdev': 'selected_streams', 'errp': 'MIPS_FPU_MAX', 'v': 'Mpeg1Context'}",MHM-Origin,406,0.09788467089335123
124,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",89,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *gen_helper_lcall_real = (IPMVEContext *)s->priv_data;

    ByteIOContext *nbits = &s->nbits;

    int ret;



    ret = process_ipmovie_chunk(gen_helper_lcall_real, nbits, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",1,1,0,1,ipmovie,-0.42775866389274597,2,5,"{'pb': 'nbits', 'ipmovie': 'gen_helper_lcall_real'}",MHM-Origin,59,0.014247310161590577
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",53,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *gen_helper_sysret;



    gen_helper_sysret = QSIMPLEQ_FIRST(&queue->entries);

    if (!gen_helper_sysret) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(gen_helper_sysret, NULL);

    return true;

}
",1,1,0,1,next,-0.16674932837486267,1,4,{'next': 'gen_helper_sysret'},MHM-Origin,23,0.00514672597249349
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
",39,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *drc_set_unusable = mon_get_cpu();

    if (!drc_set_unusable)

        return 0;

    return drc_set_unusable->regwptr[val];

}
",1,1,0,1,env,-0.9605918414890766,1,3,{'env': 'drc_set_unusable'},MHM-Origin,23,0.004979574680328369
131,"static void set_vlan(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *local_err = NULL;

    int32_t id;

    NetClientState *hubport;



    if (dev->realized) {

        qdev_prop_set_after_realize(dev, name, errp);





    visit_type_int32(v, &id, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);



    if (id == -1) {

        *ptr = NULL;









    hubport = net_hub_port_find(id);

    if (!hubport) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  name, prop->info->name);



    *ptr = hubport;
",165,"static void set_vlan(Object *EXCP_INTERRUPT, Visitor *MO_LEUL, void *num_mvs,

                     const char *alloc_fseg, Error **errp)

{

    DeviceState *gen_helper_sysret = DEVICE(EXCP_INTERRUPT);

    Property *MMCO_SET_MAX_LONG = num_mvs;

    NICPeers *KEY_MASK = qdev_get_prop_ptr(gen_helper_sysret, MMCO_SET_MAX_LONG);

    NetClientState **gen_helper_fabs_ST0 = &KEY_MASK->ncs[0];

    Error *IS_8X16 = NULL;

    int32_t ARITH_ADD;

    NetClientState *PCI_PREF_MEMORY_BASE;



    if (gen_helper_sysret->realized) {

        qdev_prop_set_after_realize(gen_helper_sysret, alloc_fseg, errp);





    visit_type_int32(MO_LEUL, &ARITH_ADD, alloc_fseg, &IS_8X16);

    if (IS_8X16) {

        error_propagate(errp, IS_8X16);



    if (ARITH_ADD == -1) {

        *gen_helper_fabs_ST0 = NULL;









    PCI_PREF_MEMORY_BASE = net_hub_port_find(ARITH_ADD);

    if (!PCI_PREF_MEMORY_BASE) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  alloc_fseg, MMCO_SET_MAX_LONG->info->alloc_fseg);



    *gen_helper_fabs_ST0 = PCI_PREF_MEMORY_BASE;
",1,1,1,-1,local_err,-0.00016427040100097656,11,35,"{'obj': 'EXCP_INTERRUPT', 'name': 'alloc_fseg', 'hubport': 'PCI_PREF_MEMORY_BASE', 'prop': 'MMCO_SET_MAX_LONG', 'peers_ptr': 'KEY_MASK', 'id': 'ARITH_ADD', 'dev': 'gen_helper_sysret', 'v': 'MO_LEUL', 'ptr': 'gen_helper_fabs_ST0', 'opaque': 'num_mvs', 'local_err': 'IS_8X16'}",MHM-Origin,415,0.10652490456899007
132,"static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",138,"static av_cold int png_dec_end(AVCodecContext *float_status)

{

    PNGDecContext *s = float_status->priv_data;



    ff_thread_release_buffer(float_status, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(float_status, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(float_status, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",1,1,0,1,avctx,-0.36742037534713745,1,5,{'avctx': 'float_status'},MHM-Origin,22,0.005261607964833577
136,"static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],

                   int dst_stride[3], int src_stride[3], int width,

                   int height, uint8_t *qp_store, int qp_stride)

{

    int x, y, i, j;

    const int count = 1<<p->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? p->hsub : 0);

        int h = height >> (is_chroma ? p->vsub : 0);

        int stride = p->temp_stride[i];

        int block = BLOCK >> (is_chroma ? p->hsub : 0);



        if (!src[i] || !dst[i])

            continue;

        for (y = 0; y < h; y++) {

            int index = block + block * stride + y * stride;



            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );

            for (x = 0; x < block; x++) {

                p->src[i][index     - x - 1] = p->src[i][index +     x    ];

                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];

            }

        }

        for (y = 0; y < block; y++) {

            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);

            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);

        }



        p->frame->linesize[i] = stride;

        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));

    }



    if (p->qp)

        p->frame->quality = p->qp * FF_QP2LAMBDA;

    else {

        int qpsum=0;

        int qpcount = (height>>4) * (height>>4);



        for (y = 0; y < (height>>4); y++) {

            for (x = 0; x < (width>>4); x++)

                qpsum += qp_store[x + y * qp_stride];

        }

        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;

    }

//    init per MB qscale stuff FIXME

    p->frame->height = height;

    p->frame->width  = width;



    for (i = 0; i < count; i++) {

        const int x1 = offset[i+count-1][0];

        const int y1 = offset[i+count-1][1];

        const int x1c = x1 >> p->hsub;

        const int y1c = y1 >> p->vsub;

        const int BLOCKc = BLOCK >> p->hsub;

        int offset;

        AVPacket pkt;

        int got_pkt_ptr;



        av_init_packet(&pkt);

        pkt.data = p->outbuf;

        pkt.size = p->outbuf_size;



        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];

        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];

        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];

        p->frame->format  = p->avctx_enc[i]->pix_fmt;



        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);

        p->frame_dec = p->avctx_enc[i]->coded_frame;



        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];



        for (y = 0; y < height; y++)

            for (x = 0; x < width; x++)

                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];



        if (!src[2] || !dst[2])

            continue;



        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];



        for (y = 0; y < height>>p->vsub; y++) {

            for (x = 0; x < width>>p->hsub; x++) {

                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];

                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];

            }

        }

    }



    for (j = 0; j < 3; j++) {

        int is_chroma = !!j;

        if (!dst[j])

            continue;

        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],

                      width  >> (is_chroma ? p->hsub : 0),

                      height >> (is_chroma ? p->vsub : 0),

                      8-p->log2_count);

    }

}
",1136,"static void filter(USPPContext *mb_xy, uint8_t *lz77_distance_offsets[3], uint8_t *src[3],

                   int dst_stride[3], int src_stride[3], int width,

                   int height, uint8_t *qp_store, int qp_stride)

{

    int x, y, i, tcg_gen_sub_i64;

    const int count = 1<<mb_xy->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? mb_xy->hsub : 0);

        int h = height >> (is_chroma ? mb_xy->vsub : 0);

        int stride = mb_xy->temp_stride[i];

        int block = BLOCK >> (is_chroma ? mb_xy->hsub : 0);



        if (!src[i] || !lz77_distance_offsets[i])

            continue;

        for (y = 0; y < h; y++) {

            int index = block + block * stride + y * stride;



            memcpy(mb_xy->src[i] + index, src[i] + y * src_stride[i], w );

            for (x = 0; x < block; x++) {

                mb_xy->src[i][index     - x - 1] = mb_xy->src[i][index +     x    ];

                mb_xy->src[i][index + w + x    ] = mb_xy->src[i][index + w - x - 1];

            }

        }

        for (y = 0; y < block; y++) {

            memcpy(mb_xy->src[i] + (  block-1-y) * stride, mb_xy->src[i] + (  y+block  ) * stride, stride);

            memcpy(mb_xy->src[i] + (h+block  +y) * stride, mb_xy->src[i] + (h-y+block-1) * stride, stride);

        }



        mb_xy->frame->linesize[i] = stride;

        memset(mb_xy->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));

    }



    if (mb_xy->qp)

        mb_xy->frame->quality = mb_xy->qp * FF_QP2LAMBDA;

    else {

        int qpsum=0;

        int qpcount = (height>>4) * (height>>4);



        for (y = 0; y < (height>>4); y++) {

            for (x = 0; x < (width>>4); x++)

                qpsum += qp_store[x + y * qp_stride];

        }

        mb_xy->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, mb_xy->qscale_type) * FF_QP2LAMBDA;

    }

//    init per MB qscale stuff FIXME

    mb_xy->frame->height = height;

    mb_xy->frame->width  = width;



    for (i = 0; i < count; i++) {

        const int x1 = offset[i+count-1][0];

        const int y1 = offset[i+count-1][1];

        const int x1c = x1 >> mb_xy->hsub;

        const int y1c = y1 >> mb_xy->vsub;

        const int BLOCKc = BLOCK >> mb_xy->hsub;

        int offset;

        AVPacket add_boot_device_path;

        int got_pkt_ptr;



        av_init_packet(&add_boot_device_path);

        add_boot_device_path.data = mb_xy->outbuf;

        add_boot_device_path.size = mb_xy->outbuf_size;



        mb_xy->frame->data[0] = mb_xy->src[0] + x1   + y1   * mb_xy->frame->linesize[0];

        mb_xy->frame->data[1] = mb_xy->src[1] + x1c  + y1c  * mb_xy->frame->linesize[1];

        mb_xy->frame->data[2] = mb_xy->src[2] + x1c  + y1c  * mb_xy->frame->linesize[2];

        mb_xy->frame->format  = mb_xy->avctx_enc[i]->pix_fmt;



        avcodec_encode_video2(mb_xy->avctx_enc[i], &add_boot_device_path, mb_xy->frame, &got_pkt_ptr);

        mb_xy->frame_dec = mb_xy->avctx_enc[i]->coded_frame;



        offset = (BLOCK-x1) + (BLOCK-y1) * mb_xy->frame_dec->linesize[0];



        for (y = 0; y < height; y++)

            for (x = 0; x < width; x++)

                mb_xy->temp[0][x + y * mb_xy->temp_stride[0]] += mb_xy->frame_dec->data[0][x + y * mb_xy->frame_dec->linesize[0] + offset];



        if (!src[2] || !lz77_distance_offsets[2])

            continue;



        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * mb_xy->frame_dec->linesize[1];



        for (y = 0; y < height>>mb_xy->vsub; y++) {

            for (x = 0; x < width>>mb_xy->hsub; x++) {

                mb_xy->temp[1][x + y * mb_xy->temp_stride[1]] += mb_xy->frame_dec->data[1][x + y * mb_xy->frame_dec->linesize[1] + offset];

                mb_xy->temp[2][x + y * mb_xy->temp_stride[2]] += mb_xy->frame_dec->data[2][x + y * mb_xy->frame_dec->linesize[2] + offset];

            }

        }

    }



    for (tcg_gen_sub_i64 = 0; tcg_gen_sub_i64 < 3; tcg_gen_sub_i64++) {

        int is_chroma = !!tcg_gen_sub_i64;

        if (!lz77_distance_offsets[tcg_gen_sub_i64])

            continue;

        store_slice_c(lz77_distance_offsets[tcg_gen_sub_i64], mb_xy->temp[tcg_gen_sub_i64], dst_stride[tcg_gen_sub_i64], mb_xy->temp_stride[tcg_gen_sub_i64],

                      width  >> (is_chroma ? mb_xy->hsub : 0),

                      height >> (is_chroma ? mb_xy->vsub : 0),

                      8-mb_xy->log2_count);

    }

}
",1,1,0,1,dst,-0.37470802664756775,4,85,"{'p': 'mb_xy', 'j': 'tcg_gen_sub_i64', 'pkt': 'add_boot_device_path', 'dst': 'lz77_distance_offsets'}",MHM-Origin,84,0.03195498387018839
137,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",61,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *pthread_cond_t;



    s = qfloat_suite();

    pthread_cond_t = srunner_create(s);



    srunner_run_all(pthread_cond_t, CK_NORMAL);

    nf = srunner_ntests_failed(pthread_cond_t);

    srunner_free(pthread_cond_t);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",0,0,1,1,sr,0.5531815513968468,1,5,{'sr': 'pthread_cond_t'},MHM-Origin,22,0.004779430230458578
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
",130,"static target_ulong put_tce_emu(sPAPRTCETable *JCC_BE, target_ulong bnd,

                                target_ulong chroma_non_intra_matrix)

{

    IOMMUTLBEntry TARGET_PHYS_ADDR_SPACE_BITS;

    hwaddr page_mask = IOMMU_PAGE_MASK(JCC_BE->page_shift);

    unsigned long index = (bnd - JCC_BE->bus_offset) >> JCC_BE->page_shift;



    if (index >= JCC_BE->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""
"", bnd);

        return H_PARAMETER;

    }



    JCC_BE->table[index] = chroma_non_intra_matrix;



    TARGET_PHYS_ADDR_SPACE_BITS.target_as = &address_space_memory,

    TARGET_PHYS_ADDR_SPACE_BITS.iova = bnd & page_mask;

    TARGET_PHYS_ADDR_SPACE_BITS.translated_addr = chroma_non_intra_matrix & page_mask;

    TARGET_PHYS_ADDR_SPACE_BITS.addr_mask = ~page_mask;

    TARGET_PHYS_ADDR_SPACE_BITS.perm = spapr_tce_iommu_access_flags(chroma_non_intra_matrix);

    memory_region_notify_iommu(&JCC_BE->iommu, TARGET_PHYS_ADDR_SPACE_BITS);



    return H_SUCCESS;

}
",0,0,1,1,entry,0.12929099798202515,4,22,"{'ioba': 'bnd', 'tcet': 'JCC_BE', 'tce': 'chroma_non_intra_matrix', 'entry': 'TARGET_PHYS_ADDR_SPACE_BITS'}",MHM-Origin,251,0.05934441089630127
140,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,

                                    TCGv arg2, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, t1;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, arg1, arg2);



    if (compute_ca) {

        gen_op_arith_compute_ca(ctx, t0, arg1, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, t1);

        gen_op_arith_compute_ca(ctx, t0, t1, 0);

        tcg_temp_free(t1);

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);

    }



    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
",251,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,

                                    TCGv get_async_context_id, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, newv;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, get_async_context_id)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        newv = tcg_temp_local_new();

        tcg_gen_mov_tl(newv, cpu_ca);

    } else {

        TCGV_UNUSED(newv);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, arg1, get_async_context_id);



    if (compute_ca) {

        gen_op_arith_compute_ca(ctx, t0, arg1, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, newv);

        gen_op_arith_compute_ca(ctx, t0, newv, 0);

        tcg_temp_free(newv);

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(ctx, t0, arg1, get_async_context_id, 0);

    }



    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
",1,1,0,1,arg2,-0.8787278085947037,2,11,"{'t1': 'newv', 'arg2': 'get_async_context_id'}",MHM-Origin,43,0.01099772055943807
141,"static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t*)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_end = end - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%mm0    \n\t""

            ""punpcklwd     %5, %%mm1    \n\t""

            ""punpcklwd     %5, %%mm2    \n\t""

            ""punpckhwd     %5, %%mm3    \n\t""

            ""punpckhwd     %5, %%mm4    \n\t""

            ""punpckhwd     %5, %%mm5    \n\t""

            ""psllq         $8, %%mm1    \n\t""

            ""psllq        $16, %%mm2    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""psllq         $8, %%mm4    \n\t""

            ""psllq        $16, %%mm5    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm5, %%mm3    \n\t""



            ""movq       %%mm0, %%mm6    \n\t""

            ""movq       %%mm3, %%mm7    \n\t""



            ""movq         8%1, %%mm0    \n\t""

            ""movq         8%1, %%mm1    \n\t""

            ""movq         8%1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%mm0    \n\t""

            ""punpcklwd     %5, %%mm1    \n\t""

            ""punpcklwd     %5, %%mm2    \n\t""

            ""punpckhwd     %5, %%mm3    \n\t""

            ""punpckhwd     %5, %%mm4    \n\t""

            ""punpckhwd     %5, %%mm5    \n\t""

            ""psllq         $8, %%mm1    \n\t""

            ""psllq        $16, %%mm2    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""psllq         $8, %%mm4    \n\t""

            ""psllq        $16, %%mm5    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm5, %%mm3    \n\t""



            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r), ""m""(mmx_null)

            :""memory"");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            ""movq       %%mm0, %%mm4    \n\t""

            ""movq       %%mm3, %%mm5    \n\t""

            ""movq       %%mm6, %%mm0    \n\t""

            ""movq       %%mm7, %%mm1    \n\t""



            ""movq       %%mm4, %%mm6    \n\t""

            ""movq       %%mm5, %%mm7    \n\t""

            ""movq       %%mm0, %%mm2    \n\t""

            ""movq       %%mm1, %%mm3    \n\t""



            STORE_BGR24_MMX



            :""=m""(*d)

            :""m""(*s)

            :""memory"");

        d += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

    }

}
",434,"static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *bdrv_get_node_name = dst;

    const uint16_t *s = (const uint16_t*)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_end = end - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movq          %1, %%mm0    
\t""

            ""movq          %1, %%mm1    
\t""

            ""movq          %1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            ""movq       %%mm0, %%mm3    
\t""

            ""movq       %%mm1, %%mm4    
\t""

            ""movq       %%mm2, %%mm5    
\t""

            ""punpcklwd     %5, %%mm0    
\t""

            ""punpcklwd     %5, %%mm1    
\t""

            ""punpcklwd     %5, %%mm2    
\t""

            ""punpckhwd     %5, %%mm3    
\t""

            ""punpckhwd     %5, %%mm4    
\t""

            ""punpckhwd     %5, %%mm5    
\t""

            ""psllq         $8, %%mm1    
\t""

            ""psllq        $16, %%mm2    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""psllq         $8, %%mm4    
\t""

            ""psllq        $16, %%mm5    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm5, %%mm3    
\t""



            ""movq       %%mm0, %%mm6    
\t""

            ""movq       %%mm3, %%mm7    
\t""



            ""movq         8%1, %%mm0    
\t""

            ""movq         8%1, %%mm1    
\t""

            ""movq         8%1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            ""movq       %%mm0, %%mm3    
\t""

            ""movq       %%mm1, %%mm4    
\t""

            ""movq       %%mm2, %%mm5    
\t""

            ""punpcklwd     %5, %%mm0    
\t""

            ""punpcklwd     %5, %%mm1    
\t""

            ""punpcklwd     %5, %%mm2    
\t""

            ""punpckhwd     %5, %%mm3    
\t""

            ""punpckhwd     %5, %%mm4    
\t""

            ""punpckhwd     %5, %%mm5    
\t""

            ""psllq         $8, %%mm1    
\t""

            ""psllq        $16, %%mm2    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""psllq         $8, %%mm4    
\t""

            ""psllq        $16, %%mm5    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm5, %%mm3    
\t""



            :""=m""(*bdrv_get_node_name)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r), ""m""(mmx_null)

            :""memory"");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            ""movq       %%mm0, %%mm4    
\t""

            ""movq       %%mm3, %%mm5    
\t""

            ""movq       %%mm6, %%mm0    
\t""

            ""movq       %%mm7, %%mm1    
\t""



            ""movq       %%mm4, %%mm6    
\t""

            ""movq       %%mm5, %%mm7    
\t""

            ""movq       %%mm0, %%mm2    
\t""

            ""movq       %%mm1, %%mm3    
\t""



            STORE_BGR24_MMX



            :""=m""(*bdrv_get_node_name)

            :""m""(*s)

            :""memory"");

        bdrv_get_node_name += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *bdrv_get_node_name++ = (bgr&0x1F)<<3;

        *bdrv_get_node_name++ = (bgr&0x3E0)>>2;

        *bdrv_get_node_name++ = (bgr&0x7C00)>>7;

    }

}
",1,1,0,1,d,-0.70123690366745,1,7,{'d': 'bdrv_get_node_name'},MHM-Origin,20,0.00604621171951294
143,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
",113,"static int ftp_file_size(FTPContext *ASSIGN_SSE_SCALE_FUNC)

{

    char ROCKER_TLV_OF_DPA_GROUP_COUNT[CONTROL_BUFFER_SIZE];

    char *op = NULL;

    const int irqn[] = {213, 0};



    snprintf(ROCKER_TLV_OF_DPA_GROUP_COUNT, sizeof(ROCKER_TLV_OF_DPA_GROUP_COUNT), ""SIZE %s\r
"", ASSIGN_SSE_SCALE_FUNC->path);

    if (ftp_send_command(ASSIGN_SSE_SCALE_FUNC, ROCKER_TLV_OF_DPA_GROUP_COUNT, irqn, &op)) {

        ASSIGN_SSE_SCALE_FUNC->filesize = strtoll(&op[4], NULL, 10);

    } else {

        ASSIGN_SSE_SCALE_FUNC->filesize = -1;

        av_free(op);

        return AVERROR(EIO);

    }



    av_free(op);

    return 0;

}
",0,0,0,-1,command,0.001167177688330412,4,16,"{'size_codes': 'irqn', 'res': 'op', 'command': 'ROCKER_TLV_OF_DPA_GROUP_COUNT', 's': 'ASSIGN_SSE_SCALE_FUNC'}",MHM-Origin,412,0.09557890097300212
146," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }



    tlb_flush(s, 1);

}
",85," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * second_timer2 = &s->utlb[i];

        second_timer2->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * second_timer2 = &s->utlb[i];

        second_timer2->v = 0;

    }



    tlb_flush(s, 1);

}
",0,0,1,1,entry,0.5845363587141037,1,4,{'entry': 'second_timer2'},MHM-Origin,24,0.004951675732930501
147,"uint16_t net_checksum_finish(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}
",32,"uint16_t net_checksum_finish(uint32_t qemu_opt_foreach)

{

    while (qemu_opt_foreach>>16)

	qemu_opt_foreach = (qemu_opt_foreach & 0xFFFF)+(qemu_opt_foreach >> 16);

    return ~qemu_opt_foreach;

}
",0,0,1,1,sum,0.5997979920357466,1,6,{'sum': 'qemu_opt_foreach'},MHM-Origin,165,0.03857925335566203
148,"static void pci_init_mask_bridge(PCIDevice *d)

{

    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and

       PCI_SEC_LETENCY_TIMER */

    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);



    /* base and limit */

    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;

    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;

    pci_set_word(d->wmask + PCI_MEMORY_BASE,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,

                 PCI_PREF_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,

                 PCI_PREF_RANGE_MASK & 0xffff);



    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */

    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);



    /* Supported memory and i/o types */

    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;

    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;

    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_64);

    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_64);



/* TODO: add this define to pci_regs.h in linux and then in qemu. */

#define  PCI_BRIDGE_CTL_VGA_16BIT	0x10	/* VGA 16-bit decode */

#define  PCI_BRIDGE_CTL_DISCARD		0x100	/* Primary discard timer */

#define  PCI_BRIDGE_CTL_SEC_DISCARD	0x200	/* Secondary discard timer */

#define  PCI_BRIDGE_CTL_DISCARD_STATUS	0x400	/* Discard timer status */

#define  PCI_BRIDGE_CTL_DISCARD_SERR	0x800	/* Discard timer SERR# enable */

/*

 * TODO: Bridges default to 10-bit VGA decoding but we currently only

 * implement 16-bit decoding (no alias support).

 */

    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_PARITY |

                 PCI_BRIDGE_CTL_SERR |

                 PCI_BRIDGE_CTL_ISA |

                 PCI_BRIDGE_CTL_VGA |

                 PCI_BRIDGE_CTL_VGA_16BIT |

                 PCI_BRIDGE_CTL_MASTER_ABORT |

                 PCI_BRIDGE_CTL_BUS_RESET |

                 PCI_BRIDGE_CTL_FAST_BACK |

                 PCI_BRIDGE_CTL_DISCARD |

                 PCI_BRIDGE_CTL_SEC_DISCARD |

                 PCI_BRIDGE_CTL_DISCARD_SERR);

    /* Below does not do anything as we never set this bit, put here for

     * completeness. */

    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_DISCARD_STATUS);

    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;

    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;

    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_MASK);

    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_MASK);

}
",252,"static void pci_init_mask_bridge(PCIDevice *VLC_BITS)

{

    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and

       PCI_SEC_LETENCY_TIMER */

    memset(VLC_BITS->wmask + PCI_PRIMARY_BUS, 0xff, 4);



    /* base and limit */

    VLC_BITS->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;

    VLC_BITS->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;

    pci_set_word(VLC_BITS->wmask + PCI_MEMORY_BASE,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(VLC_BITS->wmask + PCI_MEMORY_LIMIT,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(VLC_BITS->wmask + PCI_PREF_MEMORY_BASE,

                 PCI_PREF_RANGE_MASK & 0xffff);

    pci_set_word(VLC_BITS->wmask + PCI_PREF_MEMORY_LIMIT,

                 PCI_PREF_RANGE_MASK & 0xffff);



    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */

    memset(VLC_BITS->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);



    /* Supported memory and i/o types */

    VLC_BITS->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;

    VLC_BITS->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;

    pci_word_test_and_set_mask(VLC_BITS->config + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_64);

    pci_word_test_and_set_mask(VLC_BITS->config + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_64);



/* TODO: add this define to pci_regs.h in linux and then in qemu. */

#define  PCI_BRIDGE_CTL_VGA_16BIT	0x10	/* VGA 16-bit decode */

#define  PCI_BRIDGE_CTL_DISCARD		0x100	/* Primary discard timer */

#define  PCI_BRIDGE_CTL_SEC_DISCARD	0x200	/* Secondary discard timer */

#define  PCI_BRIDGE_CTL_DISCARD_STATUS	0x400	/* Discard timer status */

#define  PCI_BRIDGE_CTL_DISCARD_SERR	0x800	/* Discard timer SERR# enable */

/*

 * TODO: Bridges default to 10-bit VGA decoding but we currently only

 * implement 16-bit decoding (no alias support).

 */

    pci_set_word(VLC_BITS->wmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_PARITY |

                 PCI_BRIDGE_CTL_SERR |

                 PCI_BRIDGE_CTL_ISA |

                 PCI_BRIDGE_CTL_VGA |

                 PCI_BRIDGE_CTL_VGA_16BIT |

                 PCI_BRIDGE_CTL_MASTER_ABORT |

                 PCI_BRIDGE_CTL_BUS_RESET |

                 PCI_BRIDGE_CTL_FAST_BACK |

                 PCI_BRIDGE_CTL_DISCARD |

                 PCI_BRIDGE_CTL_SEC_DISCARD |

                 PCI_BRIDGE_CTL_DISCARD_SERR);

    /* Below does not do anything as we never set this bit, put here for

     * completeness. */

    pci_set_word(VLC_BITS->w1cmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_DISCARD_STATUS);

    VLC_BITS->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;

    VLC_BITS->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;

    pci_word_test_and_set_mask(VLC_BITS->cmask + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_MASK);

    pci_word_test_and_set_mask(VLC_BITS->cmask + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_MASK);

}
",0,0,0,-1,d,-0.12204242870211601,1,19,{'d': 'CPU_LOG_TB_OP_OPT'},MHM-Origin,414,0.11815209786097208
150,"static void gpollfds_from_select(void)

{

    int fd;

    for (fd = 0; fd <= nfds; fd++) {

        int events = 0;

        if (FD_ISSET(fd, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(fd, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(fd, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .fd = fd,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",114,"static void gpollfds_from_select(void)

{

    int imsg;

    for (imsg = 0; imsg <= nfds; imsg++) {

        int events = 0;

        if (FD_ISSET(imsg, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(imsg, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(imsg, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .imsg = imsg,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",0,0,0,-1,fd,0.0043384479358792305,1,9,{'fd': 'imsg'},MHM-Origin,412,0.10016419887542724
151,"static int decode_frame(AVCodecContext *avctx,

                        void *data, int *got_frame, AVPacket *avpkt)

{

    TiffContext *const s = avctx->priv_data;

    AVFrame *const p = data;

    ThreadFrame frame = { .f = data };

    unsigned off;

    int le, ret, plane, planes;

    int i, j, entries, stride;

    unsigned soff, ssize;

    uint8_t *dst;

    GetByteContext stripsizes;

    GetByteContext stripdata;



    bytestream2_init(&s->gb, avpkt->data, avpkt->size);



    // parse image header

    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header\n"");

        return ret;

    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {

        av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size\n"");

        return AVERROR_INVALIDDATA;

    }

    s->le          = le;

    // TIFF_BPP is not a required tag and defaults to 1

    s->bppcount    = s->bpp = 1;

    s->photometric = TIFF_PHOTOMETRIC_NONE;

    s->compr       = TIFF_RAW;

    s->fill_order  = 0;

    free_geotags(s);



    // Reset these offsets so we can tell if they were set this frame

    s->stripsizesoff = s->strippos = 0;

    /* parse image file directory */

    bytestream2_seek(&s->gb, off, SEEK_SET);

    entries = ff_tget_short(&s->gb, le);

    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)

        return AVERROR_INVALIDDATA;

    for (i = 0; i < entries; i++) {

        if ((ret = tiff_decode_tag(s, p)) < 0)

            return ret;

    }



    for (i = 0; i<s->geotag_count; i++) {

        const char *keyname = get_geokey_name(s->geotags[i].key);

        if (!keyname) {

            av_log(avctx, AV_LOG_WARNING, ""Unknown or unsupported GeoTIFF key %d\n"", s->geotags[i].key);

            continue;

        }

        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {

            av_log(avctx, AV_LOG_WARNING, ""Type of GeoTIFF key %d is wrong\n"", s->geotags[i].key);

            continue;

        }

        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);

        if (ret<0) {

            av_log(avctx, AV_LOG_ERROR, ""Writing metadata with key '%s' failed\n"", keyname);

            return ret;

        }

    }



    if (!s->strippos && !s->stripoff) {

        av_log(avctx, AV_LOG_ERROR, ""Image data is missing\n"");

        return AVERROR_INVALIDDATA;

    }

    /* now we have the data and may start decoding */

    if ((ret = init_image(s, &frame)) < 0)

        return ret;



    if (s->strips == 1 && !s->stripsize) {

        av_log(avctx, AV_LOG_WARNING, ""Image data size missing\n"");

        s->stripsize = avpkt->size - s->stripoff;

    }



    if (s->stripsizesoff) {

        if (s->stripsizesoff >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,

                         avpkt->size - s->stripsizesoff);

    }

    if (s->strippos) {

        if (s->strippos >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripdata, avpkt->data + s->strippos,

                         avpkt->size - s->strippos);

    }



    if (s->rps <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""rps %d invalid\n"", s->rps);

        return AVERROR_INVALIDDATA;

    }



    planes = s->planar ? s->bppcount : 1;

    for (plane = 0; plane < planes; plane++) {

        stride = p->linesize[plane];

        dst = p->data[plane];

        for (i = 0; i < s->height; i += s->rps) {

            if (s->stripsizesoff)

                ssize = ff_tget(&stripsizes, s->sstype, le);

            else

                ssize = s->stripsize;



            if (s->strippos)

                soff = ff_tget(&stripdata, s->sot, le);

            else

                soff = s->stripoff;



            if (soff > avpkt->size || ssize > avpkt->size - soff) {

                av_log(avctx, AV_LOG_ERROR, ""Invalid strip size/offset\n"");

                return AVERROR_INVALIDDATA;

            }

            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,

                                         FFMIN(s->rps, s->height - i))) < 0) {

                if (avctx->err_recognition & AV_EF_EXPLODE)

                    return ret;

                break;

            }

            dst += s->rps * stride;

        }

        if (s->predictor == 2) {

            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {

                av_log(s->avctx, AV_LOG_ERROR, ""predictor == 2 with YUV is unsupported"");

                return AVERROR_PATCHWELCOME;

            }

            dst   = p->data[plane];

            soff  = s->bpp >> 3;

            if (s->planar)

                soff  = FFMAX(soff / s->bppcount, 1);

            ssize = s->width * soff;

            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));

                    dst += stride;

                }

            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));

                    dst += stride;

                }

            } else {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j++)

                        dst[j] += dst[j - soff];

                    dst += stride;

                }

            }

        }



        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {

            dst = p->data[plane];

            for (i = 0; i < s->height; i++) {

                for (j = 0; j < stride; j++)

                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];

                dst += stride;

            }

        }

    }



    if (s->planar && s->bppcount > 2) {

        FFSWAP(uint8_t*, p->data[0],     p->data[2]);

        FFSWAP(int,      p->linesize[0], p->linesize[2]);

        FFSWAP(uint8_t*, p->data[0],     p->data[1]);

        FFSWAP(int,      p->linesize[0], p->linesize[1]);

    }



    *got_frame = 1;



    return avpkt->size;

}
",1397,"static int decode_frame(AVCodecContext *avctx,

                        void *data, int *got_frame, AVPacket *avpkt)

{

    TiffContext *const s = avctx->priv_data;

    AVFrame *const quorum = data;

    ThreadFrame frame = { .f = data };

    unsigned off;

    int le, ret, plane, planes;

    int i, j, entries, stride;

    unsigned soff, ssize;

    uint8_t *dst;

    GetByteContext stripsizes;

    GetByteContext stripdata;



    bytestream2_init(&s->gb, avpkt->data, avpkt->size);



    // parse image header

    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header
"");

        return ret;

    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {

        av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size
"");

        return AVERROR_INVALIDDATA;

    }

    s->le          = le;

    // TIFF_BPP is not a required tag and defaults to 1

    s->bppcount    = s->bpp = 1;

    s->photometric = TIFF_PHOTOMETRIC_NONE;

    s->compr       = TIFF_RAW;

    s->fill_order  = 0;

    free_geotags(s);



    // Reset these offsets so we can tell if they were set this frame

    s->stripsizesoff = s->strippos = 0;

    /* parse image file directory */

    bytestream2_seek(&s->gb, off, SEEK_SET);

    entries = ff_tget_short(&s->gb, le);

    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)

        return AVERROR_INVALIDDATA;

    for (i = 0; i < entries; i++) {

        if ((ret = tiff_decode_tag(s, quorum)) < 0)

            return ret;

    }



    for (i = 0; i<s->geotag_count; i++) {

        const char *keyname = get_geokey_name(s->geotags[i].key);

        if (!keyname) {

            av_log(avctx, AV_LOG_WARNING, ""Unknown or unsupported GeoTIFF key %d
"", s->geotags[i].key);

            continue;

        }

        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {

            av_log(avctx, AV_LOG_WARNING, ""Type of GeoTIFF key %d is wrong
"", s->geotags[i].key);

            continue;

        }

        ret = av_dict_set(avpriv_frame_get_metadatap(quorum), keyname, s->geotags[i].val, 0);

        if (ret<0) {

            av_log(avctx, AV_LOG_ERROR, ""Writing metadata with key '%s' failed
"", keyname);

            return ret;

        }

    }



    if (!s->strippos && !s->stripoff) {

        av_log(avctx, AV_LOG_ERROR, ""Image data is missing
"");

        return AVERROR_INVALIDDATA;

    }

    /* now we have the data and may start decoding */

    if ((ret = init_image(s, &frame)) < 0)

        return ret;



    if (s->strips == 1 && !s->stripsize) {

        av_log(avctx, AV_LOG_WARNING, ""Image data size missing
"");

        s->stripsize = avpkt->size - s->stripoff;

    }



    if (s->stripsizesoff) {

        if (s->stripsizesoff >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,

                         avpkt->size - s->stripsizesoff);

    }

    if (s->strippos) {

        if (s->strippos >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripdata, avpkt->data + s->strippos,

                         avpkt->size - s->strippos);

    }



    if (s->rps <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""rps %d invalid
"", s->rps);

        return AVERROR_INVALIDDATA;

    }



    planes = s->planar ? s->bppcount : 1;

    for (plane = 0; plane < planes; plane++) {

        stride = quorum->linesize[plane];

        dst = quorum->data[plane];

        for (i = 0; i < s->height; i += s->rps) {

            if (s->stripsizesoff)

                ssize = ff_tget(&stripsizes, s->sstype, le);

            else

                ssize = s->stripsize;



            if (s->strippos)

                soff = ff_tget(&stripdata, s->sot, le);

            else

                soff = s->stripoff;



            if (soff > avpkt->size || ssize > avpkt->size - soff) {

                av_log(avctx, AV_LOG_ERROR, ""Invalid strip size/offset
"");

                return AVERROR_INVALIDDATA;

            }

            if ((ret = tiff_unpack_strip(s, quorum, dst, stride, avpkt->data + soff, ssize, i,

                                         FFMIN(s->rps, s->height - i))) < 0) {

                if (avctx->err_recognition & AV_EF_EXPLODE)

                    return ret;

                break;

            }

            dst += s->rps * stride;

        }

        if (s->predictor == 2) {

            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {

                av_log(s->avctx, AV_LOG_ERROR, ""predictor == 2 with YUV is unsupported"");

                return AVERROR_PATCHWELCOME;

            }

            dst   = quorum->data[plane];

            soff  = s->bpp >> 3;

            if (s->planar)

                soff  = FFMAX(soff / s->bppcount, 1);

            ssize = s->width * soff;

            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));

                    dst += stride;

                }

            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));

                    dst += stride;

                }

            } else {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j++)

                        dst[j] += dst[j - soff];

                    dst += stride;

                }

            }

        }



        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {

            dst = quorum->data[plane];

            for (i = 0; i < s->height; i++) {

                for (j = 0; j < stride; j++)

                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];

                dst += stride;

            }

        }

    }



    if (s->planar && s->bppcount > 2) {

        FFSWAP(uint8_t*, quorum->data[0],     quorum->data[2]);

        FFSWAP(int,      quorum->linesize[0], quorum->linesize[2]);

        FFSWAP(uint8_t*, quorum->data[0],     quorum->data[1]);

        FFSWAP(int,      quorum->linesize[0], quorum->linesize[1]);

    }



    *got_frame = 1;



    return avpkt->size;

}
",0,0,1,1,p,0.007918179035186768,1,16,{'p': 'quorum'},MHM-Origin,21,0.008347511291503906
153,"static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,

                                      MegasasCmd *cmd)

{

    struct mfi_pd_info *info = cmd->iov_buf;

    size_t dcmd_size = sizeof(struct mfi_pd_info);

    uint64_t pd_size;

    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);

    uint8_t cmdbuf[6];

    SCSIRequest *req;

    size_t len, resid;



    if (!cmd->iov_buf) {

        cmd->iov_buf = g_malloc0(dcmd_size);

        info = cmd->iov_buf;

        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */

        info->vpd_page83[0] = 0x7f;

        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info std inquiry"");

            g_free(cmd->iov_buf);

            cmd->iov_buf = NULL;

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info std inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {

        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info vpd inquiry"");

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info vpd inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    }

    /* Finished, set FW state */

    if ((info->inquiry_data[0] >> 5) == 0) {

        if (megasas_is_jbod(cmd->state)) {

            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);

        } else {

            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);

        }

    } else {

        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);

    }



    info->ref.v.device_id = cpu_to_le16(pd_id);

    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|

                                          MFI_PD_DDF_TYPE_INTF_SAS);

    blk_get_geometry(sdev->conf.blk, &pd_size);

    info->raw_size = cpu_to_le64(pd_size);

    info->non_coerced_size = cpu_to_le64(pd_size);

    info->coerced_size = cpu_to_le64(pd_size);

    info->encl_device_id = 0xFFFF;

    info->slot_number = (sdev->id & 0xFF);

    info->path_info.count = 1;

    info->path_info.sas_addr[0] =

        cpu_to_le64(megasas_get_sata_addr(pd_id));

    info->connected_port_bitmap = 0x1;

    info->device_speed = 1;

    info->link_speed = 1;

    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);

    g_free(cmd->iov_buf);

    cmd->iov_size = dcmd_size - resid;

    cmd->iov_buf = NULL;

    return MFI_STAT_OK;

}
",565,"static int megasas_pd_get_info_submit(SCSIDevice *sdev, int omap_gpio_set,

                                      MegasasCmd *cmd)

{

    struct mfi_pd_info *mutex = cmd->iov_buf;

    size_t dcmd_size = sizeof(struct mfi_pd_info);

    uint64_t pd_size;

    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (omap_gpio_set & 0xFF);

    uint8_t bytestream_get_byte[6];

    SCSIRequest *req;

    size_t len, resid;



    if (!cmd->iov_buf) {

        cmd->iov_buf = g_malloc0(dcmd_size);

        mutex = cmd->iov_buf;

        mutex->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */

        mutex->vpd_page83[0] = 0x7f;

        megasas_setup_inquiry(bytestream_get_byte, 0, sizeof(mutex->inquiry_data));

        req = scsi_req_new(sdev, cmd->index, omap_gpio_set, bytestream_get_byte, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info std inquiry"");

            g_free(cmd->iov_buf);

            cmd->iov_buf = NULL;

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info std inquiry"", omap_gpio_set);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    } else if (mutex->inquiry_data[0] != 0x7f && mutex->vpd_page83[0] == 0x7f) {

        megasas_setup_inquiry(bytestream_get_byte, 0x83, sizeof(mutex->vpd_page83));

        req = scsi_req_new(sdev, cmd->index, omap_gpio_set, bytestream_get_byte, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info vpd inquiry"");

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info vpd inquiry"", omap_gpio_set);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    }

    /* Finished, set FW state */

    if ((mutex->inquiry_data[0] >> 5) == 0) {

        if (megasas_is_jbod(cmd->state)) {

            mutex->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);

        } else {

            mutex->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);

        }

    } else {

        mutex->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);

    }



    mutex->ref.v.device_id = cpu_to_le16(pd_id);

    mutex->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|

                                          MFI_PD_DDF_TYPE_INTF_SAS);

    blk_get_geometry(sdev->conf.blk, &pd_size);

    mutex->raw_size = cpu_to_le64(pd_size);

    mutex->non_coerced_size = cpu_to_le64(pd_size);

    mutex->coerced_size = cpu_to_le64(pd_size);

    mutex->encl_device_id = 0xFFFF;

    mutex->slot_number = (sdev->id & 0xFF);

    mutex->path_info.count = 1;

    mutex->path_info.sas_addr[0] =

        cpu_to_le64(megasas_get_sata_addr(pd_id));

    mutex->connected_port_bitmap = 0x1;

    mutex->device_speed = 1;

    mutex->link_speed = 1;

    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);

    g_free(cmd->iov_buf);

    cmd->iov_size = dcmd_size - resid;

    cmd->iov_buf = NULL;

    return MFI_STAT_OK;

}
",1,1,0,1,lun,-0.18932101130485535,3,35,"{'cmdbuf': 'bytestream_get_byte', 'info': 'mutex', 'lun': 'omap_gpio_set'}",MHM-Origin,103,0.031217424074808757
154,"static void gen_isel(DisasContext *ctx)

{

    int l1, l2;

    uint32_t bi = rC(ctx->opcode);

    uint32_t mask;

    TCGv_i32 t0;



    l1 = gen_new_label();

    l2 = gen_new_label();



    mask = 0x08 >> (bi & 0x03);

    t0 = tcg_temp_new_i32();

    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    if (rA(ctx->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);

    gen_set_label(l2);

    tcg_temp_free_i32(t0);

}
",177,"static void gen_isel(DisasContext *epow_irq)

{

    int virtio_blk_load, hcscale_fast;

    uint32_t bi = rC(epow_irq->opcode);

    uint32_t obj;

    TCGv_i32 mb_type;



    virtio_blk_load = gen_new_label();

    hcscale_fast = gen_new_label();



    obj = 0x08 >> (bi & 0x03);

    mb_type = tcg_temp_new_i32();

    tcg_gen_andi_i32(mb_type, cpu_crf[bi >> 2], obj);

    tcg_gen_brcondi_i32(TCG_COND_EQ, mb_type, 0, virtio_blk_load);

    if (rA(epow_irq->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(epow_irq->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(epow_irq->opcode)], cpu_gpr[rA(epow_irq->opcode)]);

    tcg_gen_br(hcscale_fast);

    gen_set_label(virtio_blk_load);

    tcg_gen_mov_tl(cpu_gpr[rD(epow_irq->opcode)], cpu_gpr[rB(epow_irq->opcode)]);

    gen_set_label(hcscale_fast);

    tcg_temp_free_i32(mb_type);

}
",0,0,0,-1,l2,0.000392131507396698,5,24,"{'l1': 'virtio_blk_load', 't0': 'mb_type', 'mask': 'obj', 'l2': 'hcscale_fast', 'ctx': 'epow_irq'}",MHM-Origin,410,0.10200781027475993
155,"static void stream_process_mem2s(struct Stream *s,

                                 StreamSlave *tx_dev)

{

    uint32_t prev_d;

    unsigned char txbuf[16 * 1024];

    unsigned int txlen;

    uint32_t app[6];



    if (!stream_running(s) || stream_idle(s)) {

        return;

    }



    while (1) {

        stream_desc_load(s, s->regs[R_CURDESC]);



        if (s->desc.status & SDESC_STATUS_COMPLETE) {

            s->regs[R_DMASR] |= DMASR_HALTED;

            break;

        }



        if (stream_desc_sof(&s->desc)) {

            s->pos = 0;

            memcpy(app, s->desc.app, sizeof app);

        }



        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;

        if ((txlen + s->pos) > sizeof txbuf) {

            hw_error(""%s: too small internal txbuf! %d\n"", __func__,

                     txlen + s->pos);

        }



        cpu_physical_memory_read(s->desc.buffer_address,

                                 txbuf + s->pos, txlen);

        s->pos += txlen;



        if (stream_desc_eof(&s->desc)) {

            stream_push(tx_dev, txbuf, s->pos, app);

            s->pos = 0;

            stream_complete(s);

        }



        /* Update the descriptor.  */

        s->desc.status = txlen | SDESC_STATUS_COMPLETE;

        stream_desc_store(s, s->regs[R_CURDESC]);



        /* Advance.  */

        prev_d = s->regs[R_CURDESC];

        s->regs[R_CURDESC] = s->desc.nxtdesc;

        if (prev_d == s->regs[R_TAILDESC]) {

            s->regs[R_DMASR] |= DMASR_IDLE;

            break;

        }

    }

}
",293,"static void stream_process_mem2s(struct Stream *s,

                                 StreamSlave *MSR_MTRRfix4K_C0000)

{

    uint32_t IR;

    unsigned char encoding_needed[16 * 1024];

    unsigned int r2_name;

    uint32_t app[6];



    if (!stream_running(s) || stream_idle(s)) {

        return;

    }



    while (1) {

        stream_desc_load(s, s->regs[R_CURDESC]);



        if (s->desc.status & SDESC_STATUS_COMPLETE) {

            s->regs[R_DMASR] |= DMASR_HALTED;

            break;

        }



        if (stream_desc_sof(&s->desc)) {

            s->pos = 0;

            memcpy(app, s->desc.app, sizeof app);

        }



        r2_name = s->desc.control & SDESC_CTRL_LEN_MASK;

        if ((r2_name + s->pos) > sizeof encoding_needed) {

            hw_error(""%s: too small internal txbuf! %d
"", __func__,

                     r2_name + s->pos);

        }



        cpu_physical_memory_read(s->desc.buffer_address,

                                 encoding_needed + s->pos, r2_name);

        s->pos += r2_name;



        if (stream_desc_eof(&s->desc)) {

            stream_push(MSR_MTRRfix4K_C0000, encoding_needed, s->pos, app);

            s->pos = 0;

            stream_complete(s);

        }



        /* Update the descriptor.  */

        s->desc.status = r2_name | SDESC_STATUS_COMPLETE;

        stream_desc_store(s, s->regs[R_CURDESC]);



        /* Advance.  */

        IR = s->regs[R_CURDESC];

        s->regs[R_CURDESC] = s->desc.nxtdesc;

        if (IR == s->regs[R_TAILDESC]) {

            s->regs[R_DMASR] |= DMASR_IDLE;

            break;

        }

    }

}
",0,0,1,1,tx_dev,0.406121164560318,4,16,"{'tx_dev': 'MSR_MTRRfix4K_C0000', 'txbuf': 'encoding_needed', 'txlen': 'r2_name', 'prev_d': 'IR'}",MHM-Origin,165,0.043279977639516194
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",81,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *fregnames = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &fregnames, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(fregnames == str);

}
",1,1,0,1,endptr,-0.28463196754455566,1,3,{'endptr': 'fregnames'},MHM-Origin,24,0.004891089598337809
161,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!tso_enable) {

        goto func_exit;

    }



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:

    return rc;

}
",80,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *PMCW_FLAGS_MASK_TF,

                                          bool bdrv_driver_preadv)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t cpu_to_le64;



    cpu_to_le64 = eth_get_l3_proto(PMCW_FLAGS_MASK_TF->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        PMCW_FLAGS_MASK_TF->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!bdrv_driver_preadv) {

        goto func_exit;

    }



    rc = eth_get_gso_type(cpu_to_le64, PMCW_FLAGS_MASK_TF->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          PMCW_FLAGS_MASK_TF->l4proto);



func_exit:

    return rc;

}
",0,0,0,-1,pkt,0.021798493340611458,3,10,"{'pkt': 'PMCW_FLAGS_MASK_TF', 'tso_enable': 'bdrv_driver_preadv', 'l3_proto': 'cpu_to_le64'}",MHM-Origin,411,0.0998373786608378
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
",75,"int ff_schro_queue_push_back(FFSchroQueue *xics_system_init, void *gen_new_label)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = gen_new_label;



    if (!xics_system_init->p_head)

        xics_system_init->p_head = p_new;

    else

        xics_system_init->p_tail->next = p_new;

    xics_system_init->p_tail = p_new;



    ++xics_system_init->RV34_MB_B_BIDIR;

    return 0;

}
",1,1,0,1,p_data,-0.6103658825159073,3,9,"{'queue': 'xics_system_init', 'size': 'RV34_MB_B_BIDIR', 'p_data': 'gen_new_label'}",MHM-Origin,64,0.01487737496693929
165,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    unsigned int offset, w, h, y, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_pixel = AV_RL16(buf+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.\n"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c\n"");



    buf += offset;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, p) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*bytes_per_pixel);

#endif

        ptr += stride;

        buf += w*bytes_per_pixel;

    }



    *picture = s->picture;

    *data_size = sizeof(AVPicture);



    return offset + w*h*bytes_per_pixel;

}",381,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *orientation) {

    const uint8_t *ram_addr_t = orientation->data;


    PTXContext * const ofs = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const pix_op = &ofs->picture;

    unsigned int offset, w, h, check_output_constraints, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(ram_addr_t);

    w               = AV_RL16(ram_addr_t+8);

    h               = AV_RL16(ram_addr_t+10);

    bytes_per_pixel = AV_RL16(ram_addr_t+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.
"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - ram_addr_t < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c
"");



    ram_addr_t += offset;



    if (pix_op->data[0])

        avctx->release_buffer(avctx, pix_op);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, pix_op) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    pix_op->pict_type = AV_PICTURE_TYPE_I;



    ptr    = pix_op->data[0];

    stride = pix_op->linesize[0];



    for (check_output_constraints=0; check_output_constraints<h; check_output_constraints++) {

        if (buf_end - ram_addr_t < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int ai_socktype;

        for (ai_socktype=0; ai_socktype<w*bytes_per_pixel; ai_socktype+=bytes_per_pixel)

            AV_WN16(ptr+ai_socktype, AV_RL16(ram_addr_t+ai_socktype));

#else

        memcpy(ptr, ram_addr_t, w*bytes_per_pixel);

#endif

        ptr += stride;

        ram_addr_t += w*bytes_per_pixel;

    }



    *picture = ofs->picture;

    *data_size = sizeof(AVPicture);



    return offset + w*h*bytes_per_pixel;

}",1,1,0,1,avpkt,-0.03790286183357239,6,33,"{'buf': 'ram_addr_t', 's': 'ofs', 'x': 'ai_socktype', 'y': 'check_output_constraints', 'p': 'pix_op', 'avpkt': 'orientation'}",MHM-Origin,123,0.03287594318389893
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",49,"static void vpc_close(BlockDriverState *NO_SENSE)

{

    BDRVVPCState *celt_output = NO_SENSE->opaque;

    g_free(celt_output->pagetable);

#ifdef CACHE

    g_free(celt_output->pageentry_u8);

#endif



    migrate_del_blocker(celt_output->migration_blocker);

    error_free(celt_output->migration_blocker);

}
",1,1,0,1,bs,-0.36654266715049744,2,7,"{'bs': 'NO_SENSE', 's': 'celt_output'}",MHM-Origin,122,0.02972093423207601
168,"static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!s->pb->eof_reached) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", klv.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_system_item_key)) {

            if (!mxf->current_partition->essence_offset) {

                compute_partition_essence_offset(s, mxf, &klv);

            }



            if (!essence_offset)

                essence_offset = klv.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&

                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

        }



        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {

            if (IS_KLV_KEY(klv.key, metadata->key)) {

                int res;

                if (klv.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);

                } else {

                    uint64_t next = avio_tell(s->pb) + klv.length;

                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);

                    avio_seek(s->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(s, AV_LOG_ERROR, ""error reading header metadata\n"");

                    return res;

                }

                break;

            }

        }

        if (!metadata->read)

            avio_skip(s->pb, klv.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(s, AV_LOG_ERROR, ""no essence\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    return mxf_parse_structural_metadata(mxf);

}
",514,"static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket CC_OP_INCQ;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key
"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!s->pb->eof_reached) {

        const MXFMetadataReadTableEntry *sample_fmt;



        if (klv_read_packet(&CC_OP_INCQ, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", CC_OP_INCQ.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""
"", CC_OP_INCQ.length, CC_OP_INCQ.offset);

        if (IS_KLV_KEY(CC_OP_INCQ.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(CC_OP_INCQ.key, mxf_essence_element_key) ||

            IS_KLV_KEY(CC_OP_INCQ.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(CC_OP_INCQ.key, mxf_system_item_key)) {

            if (!mxf->current_partition->essence_offset) {

                compute_partition_essence_offset(s, mxf, &CC_OP_INCQ);

            }



            if (!essence_offset)

                essence_offset = CC_OP_INCQ.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(CC_OP_INCQ.key, mxf_header_partition_pack_key, 13) &&

                   CC_OP_INCQ.key[13] >= 2 && CC_OP_INCQ.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

        }



        for (sample_fmt = mxf_metadata_read_table; sample_fmt->read; sample_fmt++) {

            if (IS_KLV_KEY(CC_OP_INCQ.key, sample_fmt->key)) {

                int res;

                if (CC_OP_INCQ.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &CC_OP_INCQ, sample_fmt->read, sample_fmt->ctx_size, sample_fmt->type);

                } else {

                    uint64_t next = avio_tell(s->pb) + CC_OP_INCQ.length;

                    res = sample_fmt->read(mxf, s->pb, 0, CC_OP_INCQ.length, CC_OP_INCQ.key, CC_OP_INCQ.offset);

                    avio_seek(s->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(s, AV_LOG_ERROR, ""error reading header metadata
"");

                    return res;

                }

                break;

            }

        }

        if (!sample_fmt->read)

            avio_skip(s->pb, CC_OP_INCQ.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(s, AV_LOG_ERROR, ""no essence
"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    return mxf_parse_structural_metadata(mxf);

}
",1,1,0,1,metadata,-0.06989198923110962,2,32,"{'klv': 'CC_OP_INCQ', 'metadata': 'sample_fmt'}",MHM-Origin,42,0.013070893287658692
169,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *img;
    int i;
    int sub_dx[4];
    int sub_dy[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    sub_dx[0] = sub_dx[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;
    numcomps = desc->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported\n"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = sub_dx[i];
        cmptparm[i].dy = sub_dy[i];
        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];
        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];
    }
    img = opj_image_create(numcomps, cmptparm, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    img->x0 = 0;
    img->y0 = 0;
    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;
    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;
    return img;
}",513,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *bfi_decode_frame;
    int i;
    int sub_dx[4];
    int sub_dy[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    sub_dx[0] = sub_dx[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;
    numcomps = desc->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported
"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = sub_dx[i];
        cmptparm[i].dy = sub_dy[i];
        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];
        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];
    }
    bfi_decode_frame = opj_image_create(numcomps, cmptparm, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    bfi_decode_frame->x0 = 0;
    bfi_decode_frame->y0 = 0;
    bfi_decode_frame->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;
    bfi_decode_frame->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;
    return bfi_decode_frame;
}",1,1,0,1,img,-0.3033882975578308,1,7,{'img': 'bfi_decode_frame'},MHM-Origin,21,0.006365438302357991
170,"static int xen_platform_initfn(PCIDevice *dev)

{

    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);

    uint8_t *pci_conf;



    pci_conf = d->pci_dev.config;



    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);



    pci_config_set_prog_interface(pci_conf, 0);



    pci_conf[PCI_INTERRUPT_PIN] = 1;



    pci_register_bar(&d->pci_dev, 0, 0x100,

            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);



    /* reserve 16MB mmio address for share memory*/

    pci_register_bar(&d->pci_dev, 1, 0x1000000,

            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);



    platform_fixed_ioport_init(d);



    return 0;

}
",100,"static int xen_platform_initfn(PCIDevice *StreamBlockJob)

{

    PCIXenPlatformState *CC_OP_MULB = DO_UPCAST(PCIXenPlatformState, pci_dev, StreamBlockJob);

    uint8_t *trace_megasas_dcmd_req_alloc_failed;



    trace_megasas_dcmd_req_alloc_failed = CC_OP_MULB->pci_dev.config;



    pci_set_word(trace_megasas_dcmd_req_alloc_failed + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);



    pci_config_set_prog_interface(trace_megasas_dcmd_req_alloc_failed, 0);



    trace_megasas_dcmd_req_alloc_failed[PCI_INTERRUPT_PIN] = 1;



    pci_register_bar(&CC_OP_MULB->pci_dev, 0, 0x100,

            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);



    /* reserve 16MB mmio address for share memory*/

    pci_register_bar(&CC_OP_MULB->pci_dev, 1, 0x1000000,

            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);



    platform_fixed_ioport_init(CC_OP_MULB);



    return 0;

}
",0,0,1,1,pci_conf,0.5236249715089798,3,12,"{'pci_conf': 'trace_megasas_dcmd_req_alloc_failed', 'dev': 'StreamBlockJob', 'd': 'CC_OP_MULB'}",MHM-Origin,184,0.046558531125386556
171,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *dir_path, const char *name, FsCred *credp)

{

    int retval;

    V9fsString fullname, target;



    v9fs_string_init(&fullname);

    v9fs_string_init(&target);



    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    v9fs_string_sprintf(&target, ""%s"", oldpath);



    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &target, &fullname, credp->fc_uid, credp->fc_gid);

    v9fs_string_free(&fullname);

    v9fs_string_free(&target);

    if (retval < 0) {

        errno = -retval;

        retval = -1;

    }

    return retval;

}
",136,"static int proxy_symlink(FsContext *SRARI_H2_SH, const char *object_property_add,

                         V9fsPath *vqa_header, const char *HV_X64_MSR_STIMER0_COUNT, FsCred *AVIOContext)

{

    int start_mb_x;

    V9fsString qemu_rdma_poll, qemu_irq;



    v9fs_string_init(&qemu_rdma_poll);

    v9fs_string_init(&qemu_irq);



    v9fs_string_sprintf(&qemu_rdma_poll, ""%s/%s"", vqa_header->data, HV_X64_MSR_STIMER0_COUNT);

    v9fs_string_sprintf(&qemu_irq, ""%s"", object_property_add);



    start_mb_x = v9fs_request(SRARI_H2_SH->private, T_SYMLINK, NULL, ""ssdd"",

                          &qemu_irq, &qemu_rdma_poll, AVIOContext->fc_uid, AVIOContext->fc_gid);

    v9fs_string_free(&qemu_rdma_poll);

    v9fs_string_free(&qemu_irq);

    if (start_mb_x < 0) {

        errno = -start_mb_x;

        start_mb_x = -1;

    }

    return start_mb_x;

}
",0,0,1,1,target,0.13238495588302612,8,27,"{'fs_ctx': 'SRARI_H2_SH', 'name': 'HV_X64_MSR_STIMER0_COUNT', 'fullname': 'qemu_rdma_poll', 'retval': 'start_mb_x', 'dir_path': 'vqa_header', 'target': 'qemu_irq', 'credp': 'AVIOContext', 'oldpath': 'object_property_add'}",MHM-Origin,325,0.08234767516454061
172,"static int vfio_enable_intx(VFIODevice *vdev)

{

    VFIOIRQSetFD irq_set_fd = {

        .irq_set = {

            .argsz = sizeof(irq_set_fd),

            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,

            .index = VFIO_PCI_INTX_IRQ_INDEX,

            .start = 0,

            .count = 1,

        },

    };

    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);

    int ret;



    if (vdev->intx.disabled || !pin) {

        return 0;

    }



    vfio_disable_interrupts(vdev);



    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */

    ret = event_notifier_init(&vdev->intx.interrupt, 0);

    if (ret) {

        error_report(""vfio: Error: event_notifier_init failed\n"");

        return ret;

    }



    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);

    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);



    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {

        error_report(""vfio: Error: Failed to setup INTx fd: %m\n"");

        return -errno;

    }



    /*

     * Disable mmaps so we can trap on BAR accesses.  We interpret any

     * access as a response to an interrupt and unmask the physical

     * device.  The device will re-assert if the interrupt is still

     * pending.  We'll likely retrigger on the host multiple times per

     * guest interrupt, but without EOI notification it's better than

     * nothing.  Acceleration paths through KVM will avoid this.

     */

    vfio_mmap_set_enabled(vdev, false);



    vdev->interrupt = VFIO_INT_INTx;



    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,

            vdev->host.bus, vdev->host.slot, vdev->host.function);



    return 0;

}
",231,"static int vfio_enable_intx(VFIODevice *MSR_CORE_PERF_GLOBAL_CTRL)

{

    VFIOIRQSetFD irq_set_fd = {

        .irq_set = {

            .argsz = sizeof(irq_set_fd),

            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,

            .index = VFIO_PCI_INTX_IRQ_INDEX,

            .start = 0,

            .count = 1,

        },

    };

    uint8_t pin = vfio_pci_read_config(&MSR_CORE_PERF_GLOBAL_CTRL->pdev, PCI_INTERRUPT_PIN, 1);

    int var;



    if (MSR_CORE_PERF_GLOBAL_CTRL->intx.disabled || !pin) {

        return 0;

    }



    vfio_disable_interrupts(MSR_CORE_PERF_GLOBAL_CTRL);



    MSR_CORE_PERF_GLOBAL_CTRL->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */

    var = event_notifier_init(&MSR_CORE_PERF_GLOBAL_CTRL->intx.interrupt, 0);

    if (var) {

        error_report(""vfio: Error: event_notifier_init failed
"");

        return var;

    }



    irq_set_fd.fd = event_notifier_get_fd(&MSR_CORE_PERF_GLOBAL_CTRL->intx.interrupt);

    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, MSR_CORE_PERF_GLOBAL_CTRL);



    if (ioctl(MSR_CORE_PERF_GLOBAL_CTRL->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {

        error_report(""vfio: Error: Failed to setup INTx fd: %m
"");

        return -errno;

    }



    /*

     * Disable mmaps so we can trap on BAR accesses.  We interpret any

     * access as a response to an interrupt and unmask the physical

     * device.  The device will re-assert if the interrupt is still

     * pending.  We'll likely retrigger on the host multiple times per

     * guest interrupt, but without EOI notification it's better than

     * nothing.  Acceleration paths through KVM will avoid this.

     */

    vfio_mmap_set_enabled(MSR_CORE_PERF_GLOBAL_CTRL, false);



    MSR_CORE_PERF_GLOBAL_CTRL->interrupt = VFIO_INT_INTx;



    DPRINTF(""%s(%04x:%02x:%02x.%x)
"", __func__, MSR_CORE_PERF_GLOBAL_CTRL->host.domain,

            MSR_CORE_PERF_GLOBAL_CTRL->host.bus, MSR_CORE_PERF_GLOBAL_CTRL->host.slot, MSR_CORE_PERF_GLOBAL_CTRL->host.function);



    return 0;

}
",0,0,1,1,vdev,0.1556316316127777,2,19,"{'ret': 'var', 'vdev': 'MSR_CORE_PERF_GLOBAL_CTRL'}",MHM-Origin,43,0.01155449946721395
173,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    /* mvc and memmove do not behave the same when areas overlap! */

    } else if ((dest < src) || (src + l < dest)) {

        memmove(g2h(dest), g2h(src), l + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if ((dest + 8 <= src) || (src + 8 <= dest)) {

        for (i = 0; i < l_64; i++) {

            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));

            x += 8;

        }

    }



    /* slow version with byte accesses which always work */

    for (i = x; i <= l; i++) {

        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));

    }

}
",333,"void HELPER(mvc)(CPUS390XState *env, uint32_t input_files, uint64_t num_rematrixing_bands, uint64_t LIBAVFORMAT_IDENT)

{

    int CC_O = 0;

    int x = 0;

    uint32_t l_64 = (input_files + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""
"",

               __func__, input_files, num_rematrixing_bands, LIBAVFORMAT_IDENT);



#ifndef CONFIG_USER_ONLY

    if ((input_files > 32) &&

        (LIBAVFORMAT_IDENT & TARGET_PAGE_MASK) == ((LIBAVFORMAT_IDENT + input_files) & TARGET_PAGE_MASK) &&

        (num_rematrixing_bands & TARGET_PAGE_MASK) == ((num_rematrixing_bands + input_files) & TARGET_PAGE_MASK)) {

        if (num_rematrixing_bands == (LIBAVFORMAT_IDENT + 1)) {

            mvc_fast_memset(env, input_files + 1, num_rematrixing_bands, cpu_ldub_data(env, LIBAVFORMAT_IDENT));

            return;

        } else if ((LIBAVFORMAT_IDENT & TARGET_PAGE_MASK) != (num_rematrixing_bands & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, input_files + 1, num_rematrixing_bands, LIBAVFORMAT_IDENT);

            return;

        }

    }

#else

    if (num_rematrixing_bands == (LIBAVFORMAT_IDENT + 1)) {

        memset(g2h(num_rematrixing_bands), cpu_ldub_data(env, LIBAVFORMAT_IDENT), input_files + 1);

        return;

    /* mvc and memmove do not behave the same when areas overlap! */

    } else if ((num_rematrixing_bands < LIBAVFORMAT_IDENT) || (LIBAVFORMAT_IDENT + input_files < num_rematrixing_bands)) {

        memmove(g2h(num_rematrixing_bands), g2h(LIBAVFORMAT_IDENT), input_files + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if ((num_rematrixing_bands + 8 <= LIBAVFORMAT_IDENT) || (LIBAVFORMAT_IDENT + 8 <= num_rematrixing_bands)) {

        for (CC_O = 0; CC_O < l_64; CC_O++) {

            cpu_stq_data(env, num_rematrixing_bands + x, cpu_ldq_data(env, LIBAVFORMAT_IDENT + x));

            x += 8;

        }

    }



    /* slow version with byte accesses which always work */

    for (CC_O = x; CC_O <= input_files; CC_O++) {

        cpu_stb_data(env, num_rematrixing_bands + CC_O, cpu_ldub_data(env, LIBAVFORMAT_IDENT + CC_O));

    }

}
",0,0,1,1,l,0.1689317524433136,4,55,"{'src': 'LIBAVFORMAT_IDENT', 'i': 'CC_O', 'dest': 'num_rematrixing_bands', 'l': 'input_files'}",MHM-Origin,267,0.07408609787623087
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",89,"void helper_store_fpcr (uint64_t CC_OP_INCB)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((CC_OP_INCB >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((CC_OP_INCB >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",0,0,1,1,val,0.5852909833192825,1,3,{'val': 'CC_OP_INCB'},MHM-Origin,125,0.030182953675587973
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
",18,"void spapr_tce_set_bypass(sPAPRTCETable *nonrma_base, bool SPR_NOACCESS)

{

    nonrma_base->SPR_NOACCESS = SPR_NOACCESS;

}
",0,0,0,-1,bypass,3.9966776967048645e-05,2,5,"{'tcet': 'nonrma_base', 'bypass': 'SPR_NOACCESS'}",MHM-Origin,405,0.09352213541666667
176,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",67,"void qemu_system_wakeup_request(WakeupReason MSR_MTRRfix4K_F0000)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << MSR_MTRRfix4K_F0000))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &MSR_MTRRfix4K_F0000);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",0,0,1,1,reason,0.6957287043333054,1,3,{'reason': 'MSR_MTRRfix4K_F0000'},MHM-Origin,185,0.043684681256612144
178,"int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,

                            VLC *vlc, const float *level_table,

                            const uint16_t *run_table, int version,

                            WMACoef *ptr, int offset, int num_coefs,

                            int block_len, int frame_len_bits,

                            int coef_nb_bits)

{

    int code, level, sign;

    const uint32_t *ilvl = (const uint32_t *) level_table;

    uint32_t *iptr = (uint32_t *) ptr;

    const unsigned int coef_mask = block_len - 1;

    for (; offset < num_coefs; offset++) {

        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);

        if (code > 1) {

            /** normal code */

            offset                  += run_table[code];

            sign                     = get_bits1(gb) - 1;

            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;

        } else if (code == 1) {

            /** EOB */

            break;

        } else {

            /** escape */

            if (!version) {

                level = get_bits(gb, coef_nb_bits);

                /** NOTE: this is rather suboptimal. reading

                 *  block_len_bits would be better */

                offset += get_bits(gb, frame_len_bits);

            } else {

                level = ff_wma_get_large_val(gb);

                /** escape decode */

                if (get_bits1(gb)) {

                    if (get_bits1(gb)) {

                        if (get_bits1(gb)) {

                            av_log(avctx, AV_LOG_ERROR,

                                   ""broken escape sequence\n"");

                            return -1;

                        } else

                            offset += get_bits(gb, frame_len_bits) + 4;

                    } else

                        offset += get_bits(gb, 2) + 1;

                }

            }

            sign                    = get_bits1(gb) - 1;

            ptr[offset & coef_mask] = (level ^ sign) - sign;

        }

    }

    /** NOTE: EOB can be omitted */

    if (offset > num_coefs) {

        av_log(avctx, AV_LOG_ERROR, ""overflow in spectral RLE, ignoring\n"");

        return -1;

    }



    return 0;

}
",315,"int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,

                            VLC *vlc, const float *level_table,

                            const uint16_t *run_table, int gpio_in,

                            WMACoef *ptr, int offset, int num_coefs,

                            int block_len, int frame_len_bits,

                            int coef_nb_bits)

{

    int code, level, sign;

    const uint32_t *ilvl = (const uint32_t *) level_table;

    uint32_t *AioContext = (uint32_t *) ptr;

    const unsigned int coef_mask = block_len - 1;

    for (; offset < num_coefs; offset++) {

        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);

        if (code > 1) {

            /** normal code */

            offset                  += run_table[code];

            sign                     = get_bits1(gb) - 1;

            AioContext[offset & coef_mask] = ilvl[code] ^ sign << 31;

        } else if (code == 1) {

            /** EOB */

            break;

        } else {

            /** escape */

            if (!gpio_in) {

                level = get_bits(gb, coef_nb_bits);

                /** NOTE: this is rather suboptimal. reading

                 *  block_len_bits would be better */

                offset += get_bits(gb, frame_len_bits);

            } else {

                level = ff_wma_get_large_val(gb);

                /** escape decode */

                if (get_bits1(gb)) {

                    if (get_bits1(gb)) {

                        if (get_bits1(gb)) {

                            av_log(avctx, AV_LOG_ERROR,

                                   ""broken escape sequence
"");

                            return -1;

                        } else

                            offset += get_bits(gb, frame_len_bits) + 4;

                    } else

                        offset += get_bits(gb, 2) + 1;

                }

            }

            sign                    = get_bits1(gb) - 1;

            ptr[offset & coef_mask] = (level ^ sign) - sign;

        }

    }

    /** NOTE: EOB can be omitted */

    if (offset > num_coefs) {

        av_log(avctx, AV_LOG_ERROR, ""overflow in spectral RLE, ignoring
"");

        return -1;

    }



    return 0;

}
",1,1,0,1,version,-0.20640483498573303,2,4,"{'iptr': 'AioContext', 'version': 'gpio_in'}",MHM-Origin,44,0.011468760172526042
179,"int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,

                         AVFilterInOut *open_inputs,

                         AVFilterInOut *open_outputs, AVClass *log_ctx)

{

    int index = 0, ret;

    char chr = 0;



    AVFilterInOut *curr_inputs = NULL;



    do {

        AVFilterContext *filter;

        filters += strspn(filters, WHITESPACES);



        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)

            goto fail;



        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)

            goto fail;



        if (filter->input_count == 1 && !curr_inputs && !index) {

            /* First input can be omitted if it is ""[in]"" */

            const char *tmp = ""[in]"";

            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)

                goto fail;

        }



        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)

            goto fail;



        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,

                                 log_ctx)) < 0)

            goto fail;



        filters += strspn(filters, WHITESPACES);

        chr = *filters++;



        if (chr == ';' && curr_inputs) {

            av_log(log_ctx, AV_LOG_ERROR,

                   ""Could not find a output to link when parsing \""%s\""\n"",

                   filters - 1);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        index++;

    } while (chr == ',' || chr == ';');



    if (chr) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Unable to parse graph description substring: \""%s\""\n"",

               filters - 1);

        ret = AVERROR(EINVAL);

        goto fail;

    }



    if (open_inputs && !strcmp(open_inputs->name, ""out"") && curr_inputs) {

        /* Last output can be omitted if it is ""[out]"" */

        const char *tmp = ""[out]"";

        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,

                                 log_ctx)) < 0)

            goto fail;

    }



    return 0;



 fail:

    avfilter_graph_free(graph);

    free_inout(open_inputs);

    free_inout(open_outputs);

    free_inout(curr_inputs);

    return ret;

}
",395,"int avfilter_graph_parse(AVFilterGraph *BDRVRawState, const char *qdev_connect_gpio_out,

                         AVFilterInOut *old_table_offset,

                         AVFilterInOut *FD_ISSET, AVClass *CPUX86State)

{

    int index = 0, sysbus_init_mmio;

    char chr = 0;



    AVFilterInOut *decode_buffer_size = NULL;



    do {

        AVFilterContext *block_job_create;

        qdev_connect_gpio_out += strspn(qdev_connect_gpio_out, WHITESPACES);



        if ((sysbus_init_mmio = parse_inputs(&qdev_connect_gpio_out, &decode_buffer_size, &FD_ISSET, CPUX86State)) < 0)

            goto fail;



        if ((sysbus_init_mmio = parse_filter(&block_job_create, &qdev_connect_gpio_out, BDRVRawState, index, CPUX86State)) < 0)

            goto fail;



        if (block_job_create->input_count == 1 && !decode_buffer_size && !index) {

            /* First input can be omitted if it is ""[in]"" */

            const char *opaque = ""[in]"";

            if ((sysbus_init_mmio = parse_inputs(&opaque, &decode_buffer_size, &FD_ISSET, CPUX86State)) < 0)

                goto fail;

        }



        if ((sysbus_init_mmio = link_filter_inouts(block_job_create, &decode_buffer_size, &old_table_offset, CPUX86State)) < 0)

            goto fail;



        if ((sysbus_init_mmio = parse_outputs(&qdev_connect_gpio_out, &decode_buffer_size, &old_table_offset, &FD_ISSET,

                                 CPUX86State)) < 0)

            goto fail;



        qdev_connect_gpio_out += strspn(qdev_connect_gpio_out, WHITESPACES);

        chr = *qdev_connect_gpio_out++;



        if (chr == ';' && decode_buffer_size) {

            av_log(CPUX86State, AV_LOG_ERROR,

                   ""Could not find a output to link when parsing \""%s\""
"",

                   qdev_connect_gpio_out - 1);

            sysbus_init_mmio = AVERROR(EINVAL);

            goto fail;

        }

        index++;

    } while (chr == ',' || chr == ';');



    if (chr) {

        av_log(CPUX86State, AV_LOG_ERROR,

               ""Unable to parse graph description substring: \""%s\""
"",

               qdev_connect_gpio_out - 1);

        sysbus_init_mmio = AVERROR(EINVAL);

        goto fail;

    }



    if (old_table_offset && !strcmp(old_table_offset->name, ""out"") && decode_buffer_size) {

        /* Last output can be omitted if it is ""[out]"" */

        const char *opaque = ""[out]"";

        if ((sysbus_init_mmio = parse_outputs(&opaque, &decode_buffer_size, &old_table_offset, &FD_ISSET,

                                 CPUX86State)) < 0)

            goto fail;

    }



    return 0;



 fail:

    avfilter_graph_free(BDRVRawState);

    free_inout(old_table_offset);

    free_inout(FD_ISSET);

    free_inout(decode_buffer_size);

    return sysbus_init_mmio;

}
",0,0,0,-1,open_inputs,-0.004898346960544586,9,64,"{'log_ctx': 'CPUX86State', 'tmp': 'opaque', 'open_outputs': 'FD_ISSET', 'ret': 'sysbus_init_mmio', 'filter': 'block_job_create', 'graph': 'BDRVRawState', 'filters': 'qdev_connect_gpio_out', 'open_inputs': 'old_table_offset', 'curr_inputs': 'decode_buffer_size'}",MHM-Origin,410,0.11487014293670654
182,"static int sd_create_branch(BDRVSheepdogState *s)

{

    int ret, fd;

    uint32_t vid;

    char *buf;



    dprintf(""%"" PRIx32 "" is snapshot.\n"", s->inode.vdi_id);



    buf = g_malloc(SD_INODE_SIZE);



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,

                       s->addr, s->port);

    if (ret) {

        goto out;

    }



    dprintf(""%"" PRIx32 "" is created.\n"", vid);



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        error_report(""failed to connect"");

        ret = fd;

        goto out;

    }



    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,

                      SD_INODE_SIZE, 0, s->cache_enabled);



    closesocket(fd);



    if (ret < 0) {

        goto out;

    }



    memcpy(&s->inode, buf, sizeof(s->inode));



    s->is_snapshot = false;

    ret = 0;

    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);



out:

    g_free(buf);



    return ret;

}
",228,"static int sd_create_branch(BDRVSheepdogState *s)

{

    int register_savevm, fd;

    uint32_t vid;

    char *buf;



    dprintf(""%"" PRIx32 "" is snapshot.
"", s->inode.vdi_id);



    buf = g_malloc(SD_INODE_SIZE);



    register_savevm = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,

                       s->addr, s->port);

    if (register_savevm) {

        goto out;

    }



    dprintf(""%"" PRIx32 "" is created.
"", vid);



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        error_report(""failed to connect"");

        register_savevm = fd;

        goto out;

    }



    register_savevm = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,

                      SD_INODE_SIZE, 0, s->cache_enabled);



    closesocket(fd);



    if (register_savevm < 0) {

        goto out;

    }



    memcpy(&s->inode, buf, sizeof(s->inode));



    s->is_snapshot = false;

    register_savevm = 0;

    dprintf(""%"" PRIx32 "" was newly created.
"", s->inode.vdi_id);



out:

    g_free(buf);



    return register_savevm;

}
",0,0,1,1,ret,0.012318164110183716,1,8,{'ret': 'register_savevm'},MHM-Origin,23,0.005161933104197184
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",77,"static int parse_uint8(DeviceState *hassize, Property *prop, const char *str)

{

    uint8_t *bdrv_get_node_name = qdev_get_prop_ptr(hassize, prop);

    const char *tn;



    /* accept both hex and decimal */

    tn = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, tn, bdrv_get_node_name) != 1)

        return -EINVAL;

    return 0;

}
",1,1,0,1,ptr,-0.6686297655105591,3,7,"{'dev': 'hassize', 'fmt': 'tn', 'ptr': 'bdrv_get_node_name'}",MHM-Origin,85,0.020059351126352945
184,"av_cold int swri_rematrix_init(SwrContext *s){

    int i, j;

    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);

    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);



    s->mix_any_f = NULL;



    if (!s->rematrix_custom) {

        int r = auto_matrix(s);

        if (r)

            return r;

    }

    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++) {

            double rem = 0;



            for (j = 0; j < nb_in; j++) {

                double target = s->matrix[i][j] * 32768 + rem;

                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);

                rem += target - ((int*)s->native_matrix)[i * nb_in + j];

            }

        }

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));

        s->native_one    = av_mallocz(sizeof(float));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((float*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(double));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((double*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){

        // Only for dithering currently

//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_one)

            return AVERROR(ENOMEM);

//         for (i = 0; i < nb_out; i++)

//             for (j = 0; j < nb_in; j++)

//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);

    }else

        av_assert0(0);

    //FIXME quantize for integeres

    for (i = 0; i < SWR_CH_MAX; i++) {

        int ch_in=0;

        for (j = 0; j < SWR_CH_MAX; j++) {

            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);

            if(s->matrix[i][j])

                s->matrix_ch[i][++ch_in]= j;

        }

        s->matrix_ch[i][0]= ch_in;

    }



    if(HAVE_YASM && HAVE_MMX)

        return swri_rematrix_init_x86(s);



    return 0;

}
",782,"av_cold int swri_rematrix_init(SwrContext *imsg){

    int i, j;

    int nb_in  = av_get_channel_layout_nb_channels(imsg->in_ch_layout);

    int nb_out = av_get_channel_layout_nb_channels(imsg->out_ch_layout);



    imsg->mix_any_f = NULL;



    if (!imsg->rematrix_custom) {

        int r = auto_matrix(imsg);

        if (r)

            return r;

    }

    if (imsg->midbuf.fmt == AV_SAMPLE_FMT_S16P){

        imsg->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));

        imsg->native_one    = av_mallocz(sizeof(int));

        if (!imsg->native_matrix || !imsg->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++) {

            double rem = 0;



            for (j = 0; j < nb_in; j++) {

                double target = imsg->matrix[i][j] * 32768 + rem;

                ((int*)imsg->native_matrix)[i * nb_in + j] = lrintf(target);

                rem += target - ((int*)imsg->native_matrix)[i * nb_in + j];

            }

        }

        *((int*)imsg->native_one) = 32768;

        imsg->mix_1_1_f = (mix_1_1_func_type*)copy_s16;

        imsg->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;

        imsg->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(imsg);

    }else if(imsg->midbuf.fmt == AV_SAMPLE_FMT_FLTP){

        imsg->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));

        imsg->native_one    = av_mallocz(sizeof(float));

        if (!imsg->native_matrix || !imsg->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((float*)imsg->native_matrix)[i * nb_in + j] = imsg->matrix[i][j];

        *((float*)imsg->native_one) = 1.0;

        imsg->mix_1_1_f = (mix_1_1_func_type*)copy_float;

        imsg->mix_2_1_f = (mix_2_1_func_type*)sum2_float;

        imsg->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(imsg);

    }else if(imsg->midbuf.fmt == AV_SAMPLE_FMT_DBLP){

        imsg->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        imsg->native_one    = av_mallocz(sizeof(double));

        if (!imsg->native_matrix || !imsg->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((double*)imsg->native_matrix)[i * nb_in + j] = imsg->matrix[i][j];

        *((double*)imsg->native_one) = 1.0;

        imsg->mix_1_1_f = (mix_1_1_func_type*)copy_double;

        imsg->mix_2_1_f = (mix_2_1_func_type*)sum2_double;

        imsg->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(imsg);

    }else if(imsg->midbuf.fmt == AV_SAMPLE_FMT_S32P){

        // Only for dithering currently

//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        imsg->native_one    = av_mallocz(sizeof(int));

        if (!imsg->native_one)

            return AVERROR(ENOMEM);

//         for (i = 0; i < nb_out; i++)

//             for (j = 0; j < nb_in; j++)

//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((int*)imsg->native_one) = 32768;

        imsg->mix_1_1_f = (mix_1_1_func_type*)copy_s32;

        imsg->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;

        imsg->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(imsg);

    }else

        av_assert0(0);

    //FIXME quantize for integeres

    for (i = 0; i < SWR_CH_MAX; i++) {

        int ch_in=0;

        for (j = 0; j < SWR_CH_MAX; j++) {

            imsg->matrix32[i][j]= lrintf(imsg->matrix[i][j] * 32768);

            if(imsg->matrix[i][j])

                imsg->matrix_ch[i][++ch_in]= j;

        }

        imsg->matrix_ch[i][0]= ch_in;

    }



    if(HAVE_YASM && HAVE_MMX)

        return swri_rematrix_init_x86(imsg);



    return 0;

}
",1,1,0,1,s,-0.10715088248252869,1,57,{'s': 'imsg'},MHM-Origin,21,0.006683238347371419
190,"static int kvm_get_msrs(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;

    int ret, i;

    uint64_t mtrr_top_bits;



    kvm_msr_buf_reset(cpu);



    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(cpu, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(cpu, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);

    }

    if (has_msr_feature_control) {

        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);

    }

    if (has_msr_bndcfgs) {

        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);

    }

    if (has_msr_xss) {

        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);

    }





    if (!env->tsc_valid) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);

        env->tsc_valid = !runstate_is_running();

    }



#ifdef TARGET_X86_64

    if (lm_capable_kernel) {

        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);

        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);

        kvm_msr_entry_add(cpu, MSR_FMASK, 0);

        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);

    }

#endif

    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);

    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);

    if (has_msr_async_pf_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);

    }

    if (has_msr_pv_eoi_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);

    }

    if (has_msr_kvm_steal_time) {

        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);

    }

    if (has_msr_architectural_pmu) {

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);

        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {

            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);

        }

        for (i = 0; i < num_architectural_pmu_counters; i++) {

            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);

            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);

        }

    }



    if (env->mcg_cap) {

        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);

        if (has_msr_mcg_ext_ctl) {

            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);

        }

        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {

            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);

        }

    }



    if (has_msr_hv_hypercall) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);

    }

    if (has_msr_hv_vapic) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);

    }

    if (has_msr_hv_tsc) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);

    }

    if (has_msr_hv_crash) {

        int j;



        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {

            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);

        }

    }

    if (has_msr_hv_runtime) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);

    }

    if (cpu->hyperv_synic) {

        uint32_t msr;



        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);

        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_hv_stimer) {

        uint32_t msr;



        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;

             msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_mtrr) {

        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);

        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {

            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);

            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);

        }

    }



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);

    if (ret < 0) {

        return ret;

    }



    assert(ret == cpu->kvm_msr_buf->nmsrs);

    /*

     * MTRR masks: Each mask consists of 5 parts

     * a  10..0: must be zero

     * b  11   : valid bit

     * c n-1.12: actual mask bits

     * d  51..n: reserved must be zero

     * e  63.52: reserved must be zero

     *

     * 'n' is the number of physical bits supported by the CPU and is

     * apparently always <= 52.   We know our 'n' but don't know what

     * the destinations 'n' is; it might be smaller, in which case

     * it masks (c) on loading. It might be larger, in which case

     * we fill 'd' so that d..c is consistent irrespetive of the 'n'

     * we're migrating to.

     */



    if (cpu->fill_mtrr_mask) {

        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);

        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);

        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);

    } else {

        mtrr_top_bits = 0;

    }



    for (i = 0; i < ret; i++) {

        uint32_t index = msrs[i].index;

        switch (index) {

        case MSR_IA32_SYSENTER_CS:

            env->sysenter_cs = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_ESP:

            env->sysenter_esp = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_EIP:

            env->sysenter_eip = msrs[i].data;

            break;

        case MSR_PAT:

            env->pat = msrs[i].data;

            break;

        case MSR_STAR:

            env->star = msrs[i].data;

            break;

#ifdef TARGET_X86_64

        case MSR_CSTAR:

            env->cstar = msrs[i].data;

            break;

        case MSR_KERNELGSBASE:

            env->kernelgsbase = msrs[i].data;

            break;

        case MSR_FMASK:

            env->fmask = msrs[i].data;

            break;

        case MSR_LSTAR:

            env->lstar = msrs[i].data;

            break;

#endif

        case MSR_IA32_TSC:

            env->tsc = msrs[i].data;

            break;

        case MSR_TSC_AUX:

            env->tsc_aux = msrs[i].data;

            break;

        case MSR_TSC_ADJUST:

            env->tsc_adjust = msrs[i].data;

            break;

        case MSR_IA32_TSCDEADLINE:

            env->tsc_deadline = msrs[i].data;

            break;

        case MSR_VM_HSAVE_PA:

            env->vm_hsave = msrs[i].data;

            break;

        case MSR_KVM_SYSTEM_TIME:

            env->system_time_msr = msrs[i].data;

            break;

        case MSR_KVM_WALL_CLOCK:

            env->wall_clock_msr = msrs[i].data;

            break;

        case MSR_MCG_STATUS:

            env->mcg_status = msrs[i].data;

            break;

        case MSR_MCG_CTL:

            env->mcg_ctl = msrs[i].data;

            break;

        case MSR_MCG_EXT_CTL:

            env->mcg_ext_ctl = msrs[i].data;

            break;

        case MSR_IA32_MISC_ENABLE:

            env->msr_ia32_misc_enable = msrs[i].data;

            break;

        case MSR_IA32_SMBASE:

            env->smbase = msrs[i].data;

            break;

        case MSR_IA32_FEATURE_CONTROL:

            env->msr_ia32_feature_control = msrs[i].data;

            break;

        case MSR_IA32_BNDCFGS:

            env->msr_bndcfgs = msrs[i].data;

            break;

        case MSR_IA32_XSS:

            env->xss = msrs[i].data;

            break;

        default:

            if (msrs[i].index >= MSR_MC0_CTL &&

                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {

                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;

            }

            break;

        case MSR_KVM_ASYNC_PF_EN:

            env->async_pf_en_msr = msrs[i].data;

            break;

        case MSR_KVM_PV_EOI_EN:

            env->pv_eoi_en_msr = msrs[i].data;

            break;

        case MSR_KVM_STEAL_TIME:

            env->steal_time_msr = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR_CTRL:

            env->msr_fixed_ctr_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_CTRL:

            env->msr_global_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_STATUS:

            env->msr_global_status = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:

            env->msr_global_ovf_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:

            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;

            break;

        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;

            break;

        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;

            break;

        case HV_X64_MSR_HYPERCALL:

            env->msr_hv_hypercall = msrs[i].data;

            break;

        case HV_X64_MSR_GUEST_OS_ID:

            env->msr_hv_guest_os_id = msrs[i].data;

            break;

        case HV_X64_MSR_APIC_ASSIST_PAGE:

            env->msr_hv_vapic = msrs[i].data;

            break;

        case HV_X64_MSR_REFERENCE_TSC:

            env->msr_hv_tsc = msrs[i].data;

            break;

        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:

            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;

            break;

        case HV_X64_MSR_VP_RUNTIME:

            env->msr_hv_runtime = msrs[i].data;

            break;

        case HV_X64_MSR_SCONTROL:

            env->msr_hv_synic_control = msrs[i].data;

            break;

        case HV_X64_MSR_SVERSION:

            env->msr_hv_synic_version = msrs[i].data;

            break;

        case HV_X64_MSR_SIEFP:

            env->msr_hv_synic_evt_page = msrs[i].data;

            break;

        case HV_X64_MSR_SIMP:

            env->msr_hv_synic_msg_page = msrs[i].data;

            break;

        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:

            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_CONFIG:

        case HV_X64_MSR_STIMER1_CONFIG:

        case HV_X64_MSR_STIMER2_CONFIG:

        case HV_X64_MSR_STIMER3_CONFIG:

            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =

                                msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_COUNT:

        case HV_X64_MSR_STIMER1_COUNT:

        case HV_X64_MSR_STIMER2_COUNT:

        case HV_X64_MSR_STIMER3_COUNT:

            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =

                                msrs[i].data;

            break;

        case MSR_MTRRdefType:

            env->mtrr_deftype = msrs[i].data;

            break;

        case MSR_MTRRfix64K_00000:

            env->mtrr_fixed[0] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_80000:

            env->mtrr_fixed[1] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_A0000:

            env->mtrr_fixed[2] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C0000:

            env->mtrr_fixed[3] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C8000:

            env->mtrr_fixed[4] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D0000:

            env->mtrr_fixed[5] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D8000:

            env->mtrr_fixed[6] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E0000:

            env->mtrr_fixed[7] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E8000:

            env->mtrr_fixed[8] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F0000:

            env->mtrr_fixed[9] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F8000:

            env->mtrr_fixed[10] = msrs[i].data;

            break;

        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):

            if (index & 1) {

                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |

                                                               mtrr_top_bits;

            } else {

                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;

            }

            break;

        }

    }



    return 0;

}
",2221,"static int kvm_get_msrs(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    struct kvm_msr_entry *HV_X64_MSR_CRASH_P0 = cpu->kvm_msr_buf->entries;

    int ret, i;

    uint64_t mtrr_top_bits;



    kvm_msr_buf_reset(cpu);



    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(cpu, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(cpu, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);

    }

    if (has_msr_feature_control) {

        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);

    }

    if (has_msr_bndcfgs) {

        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);

    }

    if (has_msr_xss) {

        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);

    }





    if (!env->tsc_valid) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);

        env->tsc_valid = !runstate_is_running();

    }



#ifdef TARGET_X86_64

    if (lm_capable_kernel) {

        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);

        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);

        kvm_msr_entry_add(cpu, MSR_FMASK, 0);

        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);

    }

#endif

    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);

    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);

    if (has_msr_async_pf_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);

    }

    if (has_msr_pv_eoi_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);

    }

    if (has_msr_kvm_steal_time) {

        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);

    }

    if (has_msr_architectural_pmu) {

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);

        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {

            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);

        }

        for (i = 0; i < num_architectural_pmu_counters; i++) {

            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);

            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);

        }

    }



    if (env->mcg_cap) {

        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);

        if (has_msr_mcg_ext_ctl) {

            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);

        }

        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {

            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);

        }

    }



    if (has_msr_hv_hypercall) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);

    }

    if (has_msr_hv_vapic) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);

    }

    if (has_msr_hv_tsc) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);

    }

    if (has_msr_hv_crash) {

        int j;



        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {

            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);

        }

    }

    if (has_msr_hv_runtime) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);

    }

    if (cpu->hyperv_synic) {

        uint32_t msr;



        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);

        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_hv_stimer) {

        uint32_t msr;



        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;

             msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_mtrr) {

        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);

        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {

            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);

            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);

        }

    }



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);

    if (ret < 0) {

        return ret;

    }



    assert(ret == cpu->kvm_msr_buf->nmsrs);

    /*

     * MTRR masks: Each mask consists of 5 parts

     * a  10..0: must be zero

     * b  11   : valid bit

     * c n-1.12: actual mask bits

     * d  51..n: reserved must be zero

     * e  63.52: reserved must be zero

     *

     * 'n' is the number of physical bits supported by the CPU and is

     * apparently always <= 52.   We know our 'n' but don't know what

     * the destinations 'n' is; it might be smaller, in which case

     * it masks (c) on loading. It might be larger, in which case

     * we fill 'd' so that d..c is consistent irrespetive of the 'n'

     * we're migrating to.

     */



    if (cpu->fill_mtrr_mask) {

        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);

        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);

        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);

    } else {

        mtrr_top_bits = 0;

    }



    for (i = 0; i < ret; i++) {

        uint32_t index = HV_X64_MSR_CRASH_P0[i].index;

        switch (index) {

        case MSR_IA32_SYSENTER_CS:

            env->sysenter_cs = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_IA32_SYSENTER_ESP:

            env->sysenter_esp = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_IA32_SYSENTER_EIP:

            env->sysenter_eip = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_PAT:

            env->pat = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_STAR:

            env->star = HV_X64_MSR_CRASH_P0[i].data;

            break;

#ifdef TARGET_X86_64

        case MSR_CSTAR:

            env->cstar = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_KERNELGSBASE:

            env->kernelgsbase = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_FMASK:

            env->fmask = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_LSTAR:

            env->lstar = HV_X64_MSR_CRASH_P0[i].data;

            break;

#endif

        case MSR_IA32_TSC:

            env->tsc = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_TSC_AUX:

            env->tsc_aux = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_TSC_ADJUST:

            env->tsc_adjust = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_IA32_TSCDEADLINE:

            env->tsc_deadline = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_VM_HSAVE_PA:

            env->vm_hsave = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_KVM_SYSTEM_TIME:

            env->system_time_msr = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_KVM_WALL_CLOCK:

            env->wall_clock_msr = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MCG_STATUS:

            env->mcg_status = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MCG_CTL:

            env->mcg_ctl = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MCG_EXT_CTL:

            env->mcg_ext_ctl = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_IA32_MISC_ENABLE:

            env->msr_ia32_misc_enable = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_IA32_SMBASE:

            env->smbase = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_IA32_FEATURE_CONTROL:

            env->msr_ia32_feature_control = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_IA32_BNDCFGS:

            env->msr_bndcfgs = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_IA32_XSS:

            env->xss = HV_X64_MSR_CRASH_P0[i].data;

            break;

        default:

            if (HV_X64_MSR_CRASH_P0[i].index >= MSR_MC0_CTL &&

                HV_X64_MSR_CRASH_P0[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {

                env->mce_banks[HV_X64_MSR_CRASH_P0[i].index - MSR_MC0_CTL] = HV_X64_MSR_CRASH_P0[i].data;

            }

            break;

        case MSR_KVM_ASYNC_PF_EN:

            env->async_pf_en_msr = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_KVM_PV_EOI_EN:

            env->pv_eoi_en_msr = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_KVM_STEAL_TIME:

            env->steal_time_msr = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR_CTRL:

            env->msr_fixed_ctr_ctrl = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_CTRL:

            env->msr_global_ctrl = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_STATUS:

            env->msr_global_status = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:

            env->msr_global_ovf_ctrl = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:

            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_HYPERCALL:

            env->msr_hv_hypercall = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_GUEST_OS_ID:

            env->msr_hv_guest_os_id = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_APIC_ASSIST_PAGE:

            env->msr_hv_vapic = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_REFERENCE_TSC:

            env->msr_hv_tsc = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:

            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_VP_RUNTIME:

            env->msr_hv_runtime = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_SCONTROL:

            env->msr_hv_synic_control = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_SVERSION:

            env->msr_hv_synic_version = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_SIEFP:

            env->msr_hv_synic_evt_page = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_SIMP:

            env->msr_hv_synic_msg_page = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:

            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_STIMER0_CONFIG:

        case HV_X64_MSR_STIMER1_CONFIG:

        case HV_X64_MSR_STIMER2_CONFIG:

        case HV_X64_MSR_STIMER3_CONFIG:

            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =

                                HV_X64_MSR_CRASH_P0[i].data;

            break;

        case HV_X64_MSR_STIMER0_COUNT:

        case HV_X64_MSR_STIMER1_COUNT:

        case HV_X64_MSR_STIMER2_COUNT:

        case HV_X64_MSR_STIMER3_COUNT:

            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =

                                HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRdefType:

            env->mtrr_deftype = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix64K_00000:

            env->mtrr_fixed[0] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix16K_80000:

            env->mtrr_fixed[1] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix16K_A0000:

            env->mtrr_fixed[2] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix4K_C0000:

            env->mtrr_fixed[3] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix4K_C8000:

            env->mtrr_fixed[4] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix4K_D0000:

            env->mtrr_fixed[5] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix4K_D8000:

            env->mtrr_fixed[6] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix4K_E0000:

            env->mtrr_fixed[7] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix4K_E8000:

            env->mtrr_fixed[8] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix4K_F0000:

            env->mtrr_fixed[9] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRfix4K_F8000:

            env->mtrr_fixed[10] = HV_X64_MSR_CRASH_P0[i].data;

            break;

        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):

            if (index & 1) {

                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = HV_X64_MSR_CRASH_P0[i].data |

                                                               mtrr_top_bits;

            } else {

                env->mtrr_var[MSR_MTRRphysIndex(index)].base = HV_X64_MSR_CRASH_P0[i].data;

            }

            break;

        }

    }



    return 0;

}
",0,0,1,1,msrs,0.3751598000526428,1,67,{'msrs': 'HV_X64_MSR_CRASH_P0'},MHM-Origin,26,0.01460873285929362
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
",48,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *frm_size;



    frm_size = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(frm_size)) {

        return false;

    } else {

        return true;

    }

}
",0,0,1,1,mr,0.041920483112335205,1,3,{'mr': 'frm_size'},MHM-Origin,21,0.0050405422846476235
193,"static void omap_pwt_write(void *opaque, target_phys_addr_t addr,

                           uint64_t value, unsigned size)

{

    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;

    int offset = addr & OMAP_MPUI_REG_MASK;



    if (size != 1) {

        return omap_badwidth_write8(opaque, addr, value);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        s->frc = value & 0x3f;

        break;

    case 0x04:	/* VRC */

        if ((value ^ s->vrc) & 1) {

            if (value & 1)

                printf(""%s: %iHz buzz on\n"", __FUNCTION__, (int)

                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */

                                ((omap_clk_getrate(s->clk) >> 3) /

                                 /* Pre-multiplexer divider */

                                 ((s->gcr & 2) ? 1 : 154) /

                                 /* Octave multiplexer */

                                 (2 << (value & 3)) *

                                 /* 101/107 divider */

                                 ((value & (1 << 2)) ? 101 : 107) *

                                 /*  49/55 divider */

                                 ((value & (1 << 3)) ?  49 : 55) *

                                 /*  50/63 divider */

                                 ((value & (1 << 4)) ?  50 : 63) *

                                 /*  80/127 divider */

                                 ((value & (1 << 5)) ?  80 : 127) /

                                 (107 * 55 * 63 * 127)));

            else

                printf(""%s: silence!\n"", __FUNCTION__);

        }

        s->vrc = value & 0x7f;

        break;

    case 0x08:	/* GCR */

        s->gcr = value & 3;

        break;

    default:

        OMAP_BAD_REG(addr);

        return;

    }

}
",261,"static void omap_pwt_write(void *ss, target_phys_addr_t vhostfdname,

                           uint64_t slavio_timer_is_user, unsigned HAVE_MMX)

{

    struct omap_pwt_s *float64_is_infinity = (struct omap_pwt_s *) ss;

    int offset = vhostfdname & OMAP_MPUI_REG_MASK;



    if (HAVE_MMX != 1) {

        return omap_badwidth_write8(ss, vhostfdname, slavio_timer_is_user);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        float64_is_infinity->frc = slavio_timer_is_user & 0x3f;

        break;

    case 0x04:	/* VRC */

        if ((slavio_timer_is_user ^ float64_is_infinity->vrc) & 1) {

            if (slavio_timer_is_user & 1)

                printf(""%s: %iHz buzz on
"", __FUNCTION__, (int)

                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */

                                ((omap_clk_getrate(float64_is_infinity->clk) >> 3) /

                                 /* Pre-multiplexer divider */

                                 ((float64_is_infinity->gcr & 2) ? 1 : 154) /

                                 /* Octave multiplexer */

                                 (2 << (slavio_timer_is_user & 3)) *

                                 /* 101/107 divider */

                                 ((slavio_timer_is_user & (1 << 2)) ? 101 : 107) *

                                 /*  49/55 divider */

                                 ((slavio_timer_is_user & (1 << 3)) ?  49 : 55) *

                                 /*  50/63 divider */

                                 ((slavio_timer_is_user & (1 << 4)) ?  50 : 63) *

                                 /*  80/127 divider */

                                 ((slavio_timer_is_user & (1 << 5)) ?  80 : 127) /

                                 (107 * 55 * 63 * 127)));

            else

                printf(""%s: silence!
"", __FUNCTION__);

        }

        float64_is_infinity->vrc = slavio_timer_is_user & 0x7f;

        break;

    case 0x08:	/* GCR */

        float64_is_infinity->gcr = slavio_timer_is_user & 3;

        break;

    default:

        OMAP_BAD_REG(vhostfdname);

        return;

    }

}
",0,0,0,-1,size,-0.0006457730196416378,5,28,"{'addr': 'vhostfdname', 's': 'float64_is_infinity', 'value': 'slavio_timer_is_user', 'size': 'HAVE_MMX', 'opaque': 'ss'}",MHM-Origin,411,0.11205652157465616
194,"static void predictor_decode_mono(APEContext *ctx, int count)

{

    APEPredictor *p = &ctx->predictor;

    int32_t *decoded0 = ctx->decoded[0];

    int32_t predictionA, currentA, A, sign;



    currentA = p->lastA[0];



    while (count--) {

        A = *decoded0;



        p->buf[YDELAYA] = currentA;

        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];



        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +

                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +

                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +

                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];



        currentA = A + (predictionA >> 10);



        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);

        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);



        sign = APESIGN(A);

        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;

        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;

        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;

        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;



        p->buf++;



        /* Have we filled the history buffer? */

        if (p->buf == p->historybuffer + HISTORY_SIZE) {

            memmove(p->historybuffer, p->buf,

                    PREDICTOR_SIZE * sizeof(*p->historybuffer));

            p->buf = p->historybuffer;

        }



        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);

        *(decoded0++) = p->filterA[0];

    }



    p->lastA[0] = currentA;

}
",404,"static void predictor_decode_mono(APEContext *matches, int count)

{

    APEPredictor *p = &matches->predictor;

    int32_t *decoded0 = matches->decoded[0];

    int32_t predictionA, currentA, A, sign;



    currentA = p->lastA[0];



    while (count--) {

        A = *decoded0;



        p->buf[YDELAYA] = currentA;

        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];



        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +

                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +

                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +

                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];



        currentA = A + (predictionA >> 10);



        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);

        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);



        sign = APESIGN(A);

        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;

        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;

        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;

        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;



        p->buf++;



        /* Have we filled the history buffer? */

        if (p->buf == p->historybuffer + HISTORY_SIZE) {

            memmove(p->historybuffer, p->buf,

                    PREDICTOR_SIZE * sizeof(*p->historybuffer));

            p->buf = p->historybuffer;

        }



        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);

        *(decoded0++) = p->filterA[0];

    }



    p->lastA[0] = currentA;

}
",0,0,1,1,ctx,0.2956911027431488,1,3,{'ctx': 'matches'},MHM-Origin,21,0.005512702465057373
195,"static void print_report(AVFormatContext **output_files,

                         AVOutputStream **ost_table, int nb_ostreams,

                         int is_last_report)

{

    char buf[1024];

    AVOutputStream *ost;

    AVFormatContext *oc;

    int64_t total_size;

    AVCodecContext *enc;

    int frame_number, vid, i;

    double bitrate, ti1, pts;

    static int64_t last_time = -1;

    static int qp_histogram[52];



    if (!is_last_report) {

        int64_t cur_time;

        /* display the report every 0.5 seconds */

        cur_time = av_gettime();

        if (last_time == -1) {

            last_time = cur_time;

            return;

        }

        if ((cur_time - last_time) < 500000)

            return;

        last_time = cur_time;

    }





    oc = output_files[0];



    total_size = avio_size(oc->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(oc->pb);



    buf[0] = '\0';

    ti1 = 1e10;

    vid = 0;

    for(i=0;i<nb_ostreams;i++) {

        float q= -1;

        ost = ost_table[i];

        enc = ost->st->codec;

        if(!ost->st->stream_copy && enc->coded_frame)

            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;

        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""q=%2.1f "", q);

        }

        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            float t = (av_gettime()-timer_start) / 1000000.0;



            frame_number = ost->frame_number;

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""frame=%5d fps=%3d q=%3.1f "",

                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);

            if(is_last_report)

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""L"");

            if(qp_hist){

                int j;

                int qp= lrintf(q);

                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))

                    qp_histogram[qp]++;

                for(j=0; j<32; j++)

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%X"", (int)lrintf(log(qp_histogram[j]+1)/log(2)));

            }

            if (enc->flags&CODEC_FLAG_PSNR){

                int j;

                double error, error_sum=0;

                double scale, scale_sum=0;

                char type[3]= {'Y','U','V'};

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""PSNR="");

                for(j=0; j<3; j++){

                    if(is_last_report){

                        error= enc->error[j];

                        scale= enc->width*enc->height*255.0*255.0*frame_number;

                    }else{

                        error= enc->coded_frame->error[j];

                        scale= enc->width*enc->height*255.0*255.0;

                    }

                    if(j) scale/=4;

                    error_sum += error;

                    scale_sum += scale;

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%c:%2.2f "", type[j], psnr(error/scale));

                }

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""*:%2.2f "", psnr(error_sum/scale_sum));

            }

            vid = 1;

        }

        /* compute min output value */

        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);

        if ((pts < ti1) && (pts > 0))

            ti1 = pts;

    }

    if (ti1 < 0.01)

        ti1 = 0.01;



    if (verbose || is_last_report) {

        bitrate = (double)(total_size * 8) / ti1 / 1000.0;



        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),

            ""size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s"",

            (double)total_size / 1024, ti1, bitrate);



        if (nb_frames_dup || nb_frames_drop)

          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "" dup=%d drop=%d"",

                  nb_frames_dup, nb_frames_drop);



        if (verbose >= 0)

            fprintf(stderr, ""%s    \r"", buf);



        fflush(stderr);

    }



    if (is_last_report && verbose >= 0){

        int64_t raw= audio_size + video_size + extra_size;

        fprintf(stderr, ""\n"");

        fprintf(stderr, ""video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n"",

                video_size/1024.0,

                audio_size/1024.0,

                extra_size/1024.0,

                100.0*(total_size - raw)/raw

        );

    }

}
",905,"static void print_report(AVFormatContext **HF_TS_MASK,

                         AVOutputStream **ost_table, int nb_ostreams,

                         int HV_X64_MSR_STIMER0_COUNT)

{

    char buf0[1024];

    AVOutputStream *ost;

    AVFormatContext *oc;

    int64_t total_size;

    AVCodecContext *term_cmd_buf;

    int frame_number, add_ca, std_case;

    double tcg_gen_andi_i64, ti1, pts;

    static int64_t last_time = -1;

    static int filename[52];



    if (!HV_X64_MSR_STIMER0_COUNT) {

        int64_t cur_time;

        /* display the report every 0.5 seconds */

        cur_time = av_gettime();

        if (last_time == -1) {

            last_time = cur_time;

            return;

        }

        if ((cur_time - last_time) < 500000)

            return;

        last_time = cur_time;

    }





    oc = HF_TS_MASK[0];



    total_size = avio_size(oc->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(oc->pb);



    buf0[0] = '\0';

    ti1 = 1e10;

    add_ca = 0;

    for(std_case=0;std_case<nb_ostreams;std_case++) {

        float q= -1;

        ost = ost_table[std_case];

        term_cmd_buf = ost->st->codec;

        if(!ost->st->stream_copy && term_cmd_buf->coded_frame)

            q= term_cmd_buf->coded_frame->quality/(float)FF_QP2LAMBDA;

        if (add_ca && term_cmd_buf->codec_type == AVMEDIA_TYPE_VIDEO) {

            snprintf(buf0 + strlen(buf0), sizeof(buf0) - strlen(buf0), ""q=%2.1f "", q);

        }

        if (!add_ca && term_cmd_buf->codec_type == AVMEDIA_TYPE_VIDEO) {

            float t = (av_gettime()-timer_start) / 1000000.0;



            frame_number = ost->frame_number;

            snprintf(buf0 + strlen(buf0), sizeof(buf0) - strlen(buf0), ""frame=%5d fps=%3d q=%3.1f "",

                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);

            if(HV_X64_MSR_STIMER0_COUNT)

                snprintf(buf0 + strlen(buf0), sizeof(buf0) - strlen(buf0), ""L"");

            if(qp_hist){

                int j;

                int dpl= lrintf(q);

                if(dpl>=0 && dpl<FF_ARRAY_ELEMS(filename))

                    filename[dpl]++;

                for(j=0; j<32; j++)

                    snprintf(buf0 + strlen(buf0), sizeof(buf0) - strlen(buf0), ""%X"", (int)lrintf(log(filename[j]+1)/log(2)));

            }

            if (term_cmd_buf->flags&CODEC_FLAG_PSNR){

                int j;

                double CPUClass, error_sum=0;

                double scale, scale_sum=0;

                char type[3]= {'Y','U','V'};

                snprintf(buf0 + strlen(buf0), sizeof(buf0) - strlen(buf0), ""PSNR="");

                for(j=0; j<3; j++){

                    if(HV_X64_MSR_STIMER0_COUNT){

                        CPUClass= term_cmd_buf->CPUClass[j];

                        scale= term_cmd_buf->width*term_cmd_buf->height*255.0*255.0*frame_number;

                    }else{

                        CPUClass= term_cmd_buf->coded_frame->CPUClass[j];

                        scale= term_cmd_buf->width*term_cmd_buf->height*255.0*255.0;

                    }

                    if(j) scale/=4;

                    error_sum += CPUClass;

                    scale_sum += scale;

                    snprintf(buf0 + strlen(buf0), sizeof(buf0) - strlen(buf0), ""%c:%2.2f "", type[j], psnr(CPUClass/scale));

                }

                snprintf(buf0 + strlen(buf0), sizeof(buf0) - strlen(buf0), ""*:%2.2f "", psnr(error_sum/scale_sum));

            }

            add_ca = 1;

        }

        /* compute min output value */

        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);

        if ((pts < ti1) && (pts > 0))

            ti1 = pts;

    }

    if (ti1 < 0.01)

        ti1 = 0.01;



    if (verbose || HV_X64_MSR_STIMER0_COUNT) {

        tcg_gen_andi_i64 = (double)(total_size * 8) / ti1 / 1000.0;



        snprintf(buf0 + strlen(buf0), sizeof(buf0) - strlen(buf0),

            ""size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s"",

            (double)total_size / 1024, ti1, tcg_gen_andi_i64);



        if (nb_frames_dup || nb_frames_drop)

          snprintf(buf0 + strlen(buf0), sizeof(buf0) - strlen(buf0), "" dup=%d drop=%d"",

                  nb_frames_dup, nb_frames_drop);



        if (verbose >= 0)

            fprintf(stderr, ""%s    \r"", buf0);



        fflush(stderr);

    }



    if (HV_X64_MSR_STIMER0_COUNT && verbose >= 0){

        int64_t raw= audio_size + video_size + extra_size;

        fprintf(stderr, ""
"");

        fprintf(stderr, ""video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%
"",

                video_size/1024.0,

                audio_size/1024.0,

                extra_size/1024.0,

                100.0*(total_size - raw)/raw

        );

    }

}
",0,0,1,1,is_last_report,0.12147867679595947,10,88,"{'output_files': 'HF_TS_MASK', 'qp_histogram': 'filename', 'buf': 'buf0', 'vid': 'add_ca', 'enc': 'term_cmd_buf', 'error': 'CPUClass', 'i': 'std_case', 'bitrate': 'tcg_gen_andi_i64', 'qp': 'dpl', 'is_last_report': 'HV_X64_MSR_STIMER0_COUNT'}",MHM-Origin,225,0.07792977094650269
196,"static av_always_inline void rv40_strong_loop_filter(uint8_t *src,

                                                     const int step,

                                                     const int stride,

                                                     const int alpha,

                                                     const int lims,

                                                     const int dmode,

                                                     const int chroma)

{

    int i;



    for(i = 0; i < 4; i++, src += stride){

        int sflag, p0, q0, p1, q1;

        int t = src[0*step] - src[-1*step];



        if (!t)

            continue;



        sflag = (alpha * FFABS(t)) >> 7;

        if (sflag > 1)

            continue;



        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +

              26*src[ 0*step] + 25*src[ 1*step] +

              rv40_dither_l[dmode + i]) >> 7;



        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +

              26*src[ 1*step] + 25*src[ 2*step] +

              rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);

            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);

        }



        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +

              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;

        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +

              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);

            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);

        }



        src[-2*step] = p1;

        src[-1*step] = p0;

        src[ 0*step] = q0;

        src[ 1*step] = q1;



        if(!chroma){

            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +

                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;

            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +

                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;

        }

    }

}
",588,"static av_always_inline void rv40_strong_loop_filter(uint8_t *src,

                                                     const int step,

                                                     const int stride,

                                                     const int alpha,

                                                     const int lims,

                                                     const int dmode,

                                                     const int chroma)

{

    int i;



    for(i = 0; i < 4; i++, src += stride){

        int sflag, p0, q0, p1, SCSIDiskState;

        int t = src[0*step] - src[-1*step];



        if (!t)

            continue;



        sflag = (alpha * FFABS(t)) >> 7;

        if (sflag > 1)

            continue;



        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +

              26*src[ 0*step] + 25*src[ 1*step] +

              rv40_dither_l[dmode + i]) >> 7;



        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +

              26*src[ 1*step] + 25*src[ 2*step] +

              rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);

            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);

        }



        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +

              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;

        SCSIDiskState = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +

              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);

            SCSIDiskState = av_clip(SCSIDiskState, src[ 1*step] - lims, src[ 1*step] + lims);

        }



        src[-2*step] = p1;

        src[-1*step] = p0;

        src[ 0*step] = q0;

        src[ 1*step] = SCSIDiskState;



        if(!chroma){

            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +

                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;

            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +

                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;

        }

    }

}
",1,1,0,1,q1,-0.1215888261795044,1,5,{'q1': 'SCSIDiskState'},MHM-Origin,20,0.00581057866414388
197,"DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)

{

    DeviceClass *dc;

    const char *driver, *path;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        error_setg(errp, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    dc = qdev_get_device_class(&driver, errp);

    if (!dc) {

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path, errp);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            error_setg(errp, ""Device '%s' can't go on %s bus"",

                       driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus || qbus_is_full(bus)) {

            error_setg(errp, ""No '%s' bus found for device '%s'"",

                       dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {

        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    if (!migration_is_idle()) {

        error_setg(errp, ""device_add not allowed while migrating"");

        return NULL;

    }



    /* create device */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);






    }



    qdev_set_id(dev, qemu_opts_id(opts));



    /* set properties */

    if (qemu_opt_foreach(opts, set_property, dev, &err)) {


    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        dev->opts = NULL;


    }

    return dev;



err_del_dev:

    error_propagate(errp, err);

    object_unparent(OBJECT(dev));

    object_unref(OBJECT(dev));

    return NULL;

}",387,"DeviceState *qdev_device_add(QemuOpts *fsconf, Error **errp)

{

    DeviceClass *pci_register_bar;

    const char *driver, *drive_index;

    DeviceState *SCSW_ACTL_SUSP;

    BusState *byte = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(fsconf, ""driver"");

    if (!driver) {

        error_setg(errp, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    pci_register_bar = qdev_get_device_class(&driver, errp);

    if (!pci_register_bar) {

        return NULL;

    }



    /* find bus */

    drive_index = qemu_opt_get(fsconf, ""bus"");

    if (drive_index != NULL) {

        byte = qbus_find(drive_index, errp);

        if (!byte) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(byte), pci_register_bar->bus_type)) {

            error_setg(errp, ""Device '%s' can't go on %s bus"",

                       driver, object_get_typename(OBJECT(byte)));

            return NULL;

        }

    } else if (pci_register_bar->bus_type != NULL) {

        byte = qbus_find_recursive(sysbus_get_default(), NULL, pci_register_bar->bus_type);

        if (!byte || qbus_is_full(byte)) {

            error_setg(errp, ""No '%s' bus found for device '%s'"",

                       pci_register_bar->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && byte && !qbus_is_hotpluggable(byte)) {

        error_setg(errp, QERR_BUS_NO_HOTPLUG, byte->name);

        return NULL;

    }



    if (!migration_is_idle()) {

        error_setg(errp, ""device_add not allowed while migrating"");

        return NULL;

    }



    /* create device */

    SCSW_ACTL_SUSP = DEVICE(object_new(driver));



    if (byte) {

        qdev_set_parent_bus(SCSW_ACTL_SUSP, byte);






    }



    qdev_set_id(SCSW_ACTL_SUSP, qemu_opts_id(fsconf));



    /* set properties */

    if (qemu_opt_foreach(fsconf, set_property, SCSW_ACTL_SUSP, &err)) {


    }



    SCSW_ACTL_SUSP->fsconf = fsconf;

    object_property_set_bool(OBJECT(SCSW_ACTL_SUSP), true, ""realized"", &err);

    if (err != NULL) {

        SCSW_ACTL_SUSP->fsconf = NULL;


    }

    return SCSW_ACTL_SUSP;



err_del_dev:

    error_propagate(errp, err);

    object_unparent(OBJECT(SCSW_ACTL_SUSP));

    object_unref(OBJECT(SCSW_ACTL_SUSP));

    return NULL;

}",1,1,0,1,dev,-0.0772821307182312,5,43,"{'dc': 'pci_register_bar', 'path': 'drive_index', 'opts': 'fsconf', 'bus': 'byte', 'dev': 'SCSW_ACTL_SUSP'}",MHM-Origin,122,0.03337762355804443
198,"static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,

                              int buf_size, int buf_size2)

{

    RVDecContext *rv = avctx->priv_data;

    MpegEncContext *s = &rv->m;

    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;



    active_bits_size = buf_size * 8;

    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        mb_count = rv10_decode_picture_header(s);

    else

        mb_count = rv20_decode_picture_header(rv);

    if (mb_count < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""HEADER ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if (s->mb_x >= s->mb_width ||

        s->mb_y >= s->mb_height) {

        av_log(s->avctx, AV_LOG_ERROR, ""POS ERROR %d %d\n"", s->mb_x, s->mb_y);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mb_y * s->mb_width + s->mb_x;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (mb_count > left) {

        av_log(s->avctx, AV_LOG_ERROR, ""COUNT ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {

        // FIXME write parser so we always have complete frames?

        if (s->current_picture_ptr) {

            ff_er_frame_end(&s->er);

            ff_MPV_frame_end(s);

            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;

        }

        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)

            return ret;

        ff_mpeg_er_frame_start(s);

    } else {

        if (s->current_picture_ptr->f.pict_type != s->pict_type) {

            av_log(s->avctx, AV_LOG_ERROR, ""Slice type mismatch\n"");

            return AVERROR_INVALIDDATA;

        }

    }



    av_dlog(avctx, ""qscale=%d\n"", s->qscale);



    /* default quantization values */

    if (s->codec_id == AV_CODEC_ID_RV10) {

        if (s->mb_y == 0)

            s->first_slice_line = 1;

    } else {

        s->first_slice_line = 1;

        s->resync_mb_x      = s->mb_x;

    }

    start_mb_x     = s->mb_x;

    s->resync_mb_y = s->mb_y;

    if (s->h263_aic) {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_aic_dc_scale_table;

    } else {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;

    }



    if (s->modified_quant)

        s->chroma_qscale_table = ff_h263_chroma_qscale_table;



    ff_set_qscale(s, s->qscale);



    s->rv10_first_dc_coded[0] = 0;

    s->rv10_first_dc_coded[1] = 0;

    s->rv10_first_dc_coded[2] = 0;

    s->block_wrap[0] =

    s->block_wrap[1] =

    s->block_wrap[2] =

    s->block_wrap[3] = s->b8_stride;

    s->block_wrap[4] =

    s->block_wrap[5] = s->mb_stride;

    ff_init_block_index(s);



    /* decode each macroblock */

    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {

        int ret;

        ff_update_block_index(s);

        av_dlog(avctx, ""**mb x=%d y=%d\n"", s->mb_x, s->mb_y);



        s->mv_dir  = MV_DIR_FORWARD;

        s->mv_type = MV_TYPE_16X16;

        ret = ff_h263_decode_mb(s, s->block);



        // Repeat the slice end check from ff_h263_decode_mb with our active

        // bitstream size

        if (ret != SLICE_ERROR) {

            int v = show_bits(&s->gb, 16);



            if (get_bits_count(&s->gb) + 16 > active_bits_size)

                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;



            if (!v)

                ret = SLICE_END;

        }

        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&

            8 * buf_size2 >= get_bits_count(&s->gb)) {

            active_bits_size = buf_size2 * 8;

            av_log(avctx, AV_LOG_DEBUG, ""update size from %d to %d\n"",

                   8 * buf_size, active_bits_size);

            ret = SLICE_OK;

        }



        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {

            av_log(s->avctx, AV_LOG_ERROR, ""ERROR at MB %d %d\n"", s->mb_x,

                   s->mb_y);

            return AVERROR_INVALIDDATA;

        }

        if (s->pict_type != AV_PICTURE_TYPE_B)

            ff_h263_update_motion_val(s);

        ff_MPV_decode_mb(s, s->block);

        if (s->loop_filter)

            ff_h263_loop_filter(s);



        if (++s->mb_x == s->mb_width) {

            s->mb_x = 0;

            s->mb_y++;

            ff_init_block_index(s);

        }

        if (s->mb_x == s->resync_mb_x)

            s->first_slice_line = 0;

        if (ret == SLICE_END)

            break;

    }



    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,

                    ER_MB_END);



    return active_bits_size;

}
",873,"static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *coded_width,

                              int buf_size, int buf_size2)

{

    RVDecContext *rv = avctx->priv_data;

    MpegEncContext *s = &rv->m;

    int mb_count, mb_pos, left, start_mb_x, HAVE_MMX2, ret;



    HAVE_MMX2 = buf_size * 8;

    init_get_bits(&s->gb, coded_width, FFMAX(buf_size, buf_size2) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        mb_count = rv10_decode_picture_header(s);

    else

        mb_count = rv20_decode_picture_header(rv);

    if (mb_count < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""HEADER ERROR
"");

        return AVERROR_INVALIDDATA;

    }



    if (s->mb_x >= s->mb_width ||

        s->mb_y >= s->mb_height) {

        av_log(s->avctx, AV_LOG_ERROR, ""POS ERROR %d %d
"", s->mb_x, s->mb_y);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mb_y * s->mb_width + s->mb_x;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (mb_count > left) {

        av_log(s->avctx, AV_LOG_ERROR, ""COUNT ERROR
"");

        return AVERROR_INVALIDDATA;

    }



    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {

        // FIXME write parser so we always have complete frames?

        if (s->current_picture_ptr) {

            ff_er_frame_end(&s->er);

            ff_MPV_frame_end(s);

            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;

        }

        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)

            return ret;

        ff_mpeg_er_frame_start(s);

    } else {

        if (s->current_picture_ptr->f.pict_type != s->pict_type) {

            av_log(s->avctx, AV_LOG_ERROR, ""Slice type mismatch
"");

            return AVERROR_INVALIDDATA;

        }

    }



    av_dlog(avctx, ""qscale=%d
"", s->qscale);



    /* default quantization values */

    if (s->codec_id == AV_CODEC_ID_RV10) {

        if (s->mb_y == 0)

            s->first_slice_line = 1;

    } else {

        s->first_slice_line = 1;

        s->resync_mb_x      = s->mb_x;

    }

    start_mb_x     = s->mb_x;

    s->resync_mb_y = s->mb_y;

    if (s->h263_aic) {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_aic_dc_scale_table;

    } else {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;

    }



    if (s->modified_quant)

        s->chroma_qscale_table = ff_h263_chroma_qscale_table;



    ff_set_qscale(s, s->qscale);



    s->rv10_first_dc_coded[0] = 0;

    s->rv10_first_dc_coded[1] = 0;

    s->rv10_first_dc_coded[2] = 0;

    s->block_wrap[0] =

    s->block_wrap[1] =

    s->block_wrap[2] =

    s->block_wrap[3] = s->b8_stride;

    s->block_wrap[4] =

    s->block_wrap[5] = s->mb_stride;

    ff_init_block_index(s);



    /* decode each macroblock */

    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {

        int ret;

        ff_update_block_index(s);

        av_dlog(avctx, ""**mb x=%d y=%d
"", s->mb_x, s->mb_y);



        s->mv_dir  = MV_DIR_FORWARD;

        s->mv_type = MV_TYPE_16X16;

        ret = ff_h263_decode_mb(s, s->block);



        // Repeat the slice end check from ff_h263_decode_mb with our active

        // bitstream size

        if (ret != SLICE_ERROR) {

            int v = show_bits(&s->gb, 16);



            if (get_bits_count(&s->gb) + 16 > HAVE_MMX2)

                v >>= get_bits_count(&s->gb) + 16 - HAVE_MMX2;



            if (!v)

                ret = SLICE_END;

        }

        if (ret != SLICE_ERROR && HAVE_MMX2 < get_bits_count(&s->gb) &&

            8 * buf_size2 >= get_bits_count(&s->gb)) {

            HAVE_MMX2 = buf_size2 * 8;

            av_log(avctx, AV_LOG_DEBUG, ""update size from %d to %d
"",

                   8 * buf_size, HAVE_MMX2);

            ret = SLICE_OK;

        }



        if (ret == SLICE_ERROR || HAVE_MMX2 < get_bits_count(&s->gb)) {

            av_log(s->avctx, AV_LOG_ERROR, ""ERROR at MB %d %d
"", s->mb_x,

                   s->mb_y);

            return AVERROR_INVALIDDATA;

        }

        if (s->pict_type != AV_PICTURE_TYPE_B)

            ff_h263_update_motion_val(s);

        ff_MPV_decode_mb(s, s->block);

        if (s->loop_filter)

            ff_h263_loop_filter(s);



        if (++s->mb_x == s->mb_width) {

            s->mb_x = 0;

            s->mb_y++;

            ff_init_block_index(s);

        }

        if (s->mb_x == s->resync_mb_x)

            s->first_slice_line = 0;

        if (ret == SLICE_END)

            break;

    }



    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,

                    ER_MB_END);



    return HAVE_MMX2;

}
",1,1,0,1,buf,-0.11404737830162048,2,11,"{'active_bits_size': 'HAVE_MMX2', 'buf': 'coded_width'}",MHM-Origin,41,0.013624056180318197
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
",31,"static inline int cpu_gdb_index(CPUState *bdrv_get_flags)

{

#if defined(CONFIG_USER_ONLY)

    return bdrv_get_flags->host_tid;

#else

    return bdrv_get_flags->cpu_index + 1;

#endif

}
",1,1,0,1,cpu,-0.26667553186416626,1,3,{'cpu': 'bdrv_get_flags'},MHM-Origin,21,0.004623933633168539
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
",178,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned mb_xy)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)mb_xy >> 31) << 1));

    mb_xy <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)mb_xy >> 31) << 1));

    mb_xy <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)mb_xy >> 31) << 1));

    mb_xy <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)mb_xy >> 31) << 1));



    return dst + 4;

}
",1,1,0,1,sign,-0.3610250949859619,1,8,{'sign': 'mb_xy'},MHM-Origin,21,0.004928286870320638
203,"static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,

                               const TCGArg * const args, uint16_t dead_args,

                               uint8_t sync_args)

{

    int flags, nb_regs, i;

    TCGReg reg;

    TCGArg arg;

    TCGTemp *ts;

    intptr_t stack_offset;

    size_t call_stack_size;

    tcg_insn_unit *func_addr;

    int allocate_args;

    TCGRegSet allocated_regs;



    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];

    flags = args[nb_oargs + nb_iargs + 1];



    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);

    if (nb_regs > nb_iargs) {

        nb_regs = nb_iargs;

    }



    /* assign stack slots first */

    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);

    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & 

        ~(TCG_TARGET_STACK_ALIGN - 1);

    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);

    if (allocate_args) {

        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,

           preallocate call stack */

        tcg_abort();

    }



    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;

    for(i = nb_regs; i < nb_iargs; i++) {

        arg = args[nb_oargs + i];

#ifdef TCG_TARGET_STACK_GROWSUP

        stack_offset -= sizeof(tcg_target_long);

#endif

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            temp_load(s, ts, tcg_target_available_regs[ts->type],

                      s->reserved_regs);

            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);

        }

#ifndef TCG_TARGET_STACK_GROWSUP

        stack_offset += sizeof(tcg_target_long);

#endif

    }

    

    /* assign input registers */

    tcg_regset_set(allocated_regs, s->reserved_regs);

    for(i = 0; i < nb_regs; i++) {

        arg = args[nb_oargs + i];

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            reg = tcg_target_call_iarg_regs[i];

            tcg_reg_free(s, reg, allocated_regs);



            if (ts->val_type == TEMP_VAL_REG) {

                if (ts->reg != reg) {

                    tcg_out_mov(s, ts->type, reg, ts->reg);

                }

            } else {

                TCGRegSet arg_set;



                tcg_regset_clear(arg_set);

                tcg_regset_set_reg(arg_set, reg);

                temp_load(s, ts, arg_set, allocated_regs);

            }



            tcg_regset_set_reg(allocated_regs, reg);

        }

    }

    

    /* mark dead temporaries and free the associated registers */

    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {

        if (IS_DEAD_ARG(i)) {

            temp_dead(s, &s->temps[args[i]]);

        }

    }

    

    /* clobber call registers */

    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {

        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {

            tcg_reg_free(s, i, allocated_regs);

        }

    }



    /* Save globals if they might be written by the helper, sync them if

       they might be read. */

    if (flags & TCG_CALL_NO_READ_GLOBALS) {

        /* Nothing to do */

    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {

        sync_globals(s, allocated_regs);

    } else {

        save_globals(s, allocated_regs);

    }



    tcg_out_call(s, func_addr);



    /* assign output registers and emit moves if needed */

    for(i = 0; i < nb_oargs; i++) {

        arg = args[i];

        ts = &s->temps[arg];

        reg = tcg_target_call_oarg_regs[i];

        assert(s->reg_to_temp[reg] == NULL);



        if (ts->fixed_reg) {

            if (ts->reg != reg) {

                tcg_out_mov(s, ts->type, ts->reg, reg);

            }

        } else {

            if (ts->val_type == TEMP_VAL_REG) {

                s->reg_to_temp[ts->reg] = NULL;

            }

            ts->val_type = TEMP_VAL_REG;

            ts->reg = reg;

            ts->mem_coherent = 0;

            s->reg_to_temp[reg] = ts;

            if (NEED_SYNC_ARG(i)) {

                tcg_reg_sync(s, reg, allocated_regs);

            }

            if (IS_DEAD_ARG(i)) {

                temp_dead(s, ts);

            }

        }

    }

}
",681,"static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int pxa2xx_i2c_init,

                               const TCGArg * const args, uint16_t dead_args,

                               uint8_t sync_args)

{

    int flags, nb_regs, i;

    TCGReg reg;

    TCGArg arg;

    TCGTemp *ts;

    intptr_t stack_offset;

    size_t call_stack_size;

    tcg_insn_unit *func_addr;

    int allocate_args;

    TCGRegSet allocated_regs;



    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + pxa2xx_i2c_init];

    flags = args[nb_oargs + pxa2xx_i2c_init + 1];



    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);

    if (nb_regs > pxa2xx_i2c_init) {

        nb_regs = pxa2xx_i2c_init;

    }



    /* assign stack slots first */

    call_stack_size = (pxa2xx_i2c_init - nb_regs) * sizeof(tcg_target_long);

    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & 

        ~(TCG_TARGET_STACK_ALIGN - 1);

    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);

    if (allocate_args) {

        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,

           preallocate call stack */

        tcg_abort();

    }



    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;

    for(i = nb_regs; i < pxa2xx_i2c_init; i++) {

        arg = args[nb_oargs + i];

#ifdef TCG_TARGET_STACK_GROWSUP

        stack_offset -= sizeof(tcg_target_long);

#endif

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            temp_load(s, ts, tcg_target_available_regs[ts->type],

                      s->reserved_regs);

            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);

        }

#ifndef TCG_TARGET_STACK_GROWSUP

        stack_offset += sizeof(tcg_target_long);

#endif

    }

    

    /* assign input registers */

    tcg_regset_set(allocated_regs, s->reserved_regs);

    for(i = 0; i < nb_regs; i++) {

        arg = args[nb_oargs + i];

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            reg = tcg_target_call_iarg_regs[i];

            tcg_reg_free(s, reg, allocated_regs);



            if (ts->val_type == TEMP_VAL_REG) {

                if (ts->reg != reg) {

                    tcg_out_mov(s, ts->type, reg, ts->reg);

                }

            } else {

                TCGRegSet arg_set;



                tcg_regset_clear(arg_set);

                tcg_regset_set_reg(arg_set, reg);

                temp_load(s, ts, arg_set, allocated_regs);

            }



            tcg_regset_set_reg(allocated_regs, reg);

        }

    }

    

    /* mark dead temporaries and free the associated registers */

    for(i = nb_oargs; i < pxa2xx_i2c_init + nb_oargs; i++) {

        if (IS_DEAD_ARG(i)) {

            temp_dead(s, &s->temps[args[i]]);

        }

    }

    

    /* clobber call registers */

    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {

        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {

            tcg_reg_free(s, i, allocated_regs);

        }

    }



    /* Save globals if they might be written by the helper, sync them if

       they might be read. */

    if (flags & TCG_CALL_NO_READ_GLOBALS) {

        /* Nothing to do */

    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {

        sync_globals(s, allocated_regs);

    } else {

        save_globals(s, allocated_regs);

    }



    tcg_out_call(s, func_addr);



    /* assign output registers and emit moves if needed */

    for(i = 0; i < nb_oargs; i++) {

        arg = args[i];

        ts = &s->temps[arg];

        reg = tcg_target_call_oarg_regs[i];

        assert(s->reg_to_temp[reg] == NULL);



        if (ts->fixed_reg) {

            if (ts->reg != reg) {

                tcg_out_mov(s, ts->type, ts->reg, reg);

            }

        } else {

            if (ts->val_type == TEMP_VAL_REG) {

                s->reg_to_temp[ts->reg] = NULL;

            }

            ts->val_type = TEMP_VAL_REG;

            ts->reg = reg;

            ts->mem_coherent = 0;

            s->reg_to_temp[reg] = ts;

            if (NEED_SYNC_ARG(i)) {

                tcg_reg_sync(s, reg, allocated_regs);

            }

            if (IS_DEAD_ARG(i)) {

                temp_dead(s, ts);

            }

        }

    }

}
",0,0,1,1,nb_iargs,0.1933390200138092,1,8,{'nb_iargs': 'pxa2xx_i2c_init'},MHM-Origin,24,0.006923353672027588
204,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
",64,"static void curl_multi_do(void *cpu_generic_init)

{

    BDRVCURLState *rot = (BDRVCURLState *)cpu_generic_init;

    int num_codes_sum;

    int MigrationState;



    if (!rot->multi) {

        return;

    }



    do {

        MigrationState = curl_multi_socket_all(rot->multi, &num_codes_sum);

    } while(MigrationState == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(rot);

}
",0,0,0,-1,arg,-0.002585025504231453,4,11,"{'r': 'MigrationState', 'running': 'num_codes_sum', 's': 'rot', 'arg': 'cpu_generic_init'}",MHM-Origin,408,0.09664990901947021
207,"static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)

{

    int rex;



    if (opc & P_GS) {

        tcg_out8(s, 0x65);

    }

    if (opc & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((opc & P_REXW) == 0);

        tcg_out8(s, 0x66);

    }

    if (opc & P_ADDR32) {

        tcg_out8(s, 0x67);

    }



    rex = 0;

    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    rex |= (r & 8) >> 1;                /* REX.R */

    rex |= (x & 8) >> 2;                /* REX.X */

    rex |= (rm & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    rex |= opc & (r >= 4 ? P_REXB_R : 0);

    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);



    if (rex) {

        tcg_out8(s, (uint8_t)(rex | 0x40));

    }



    if (opc & (P_EXT | P_EXT38)) {

        tcg_out8(s, 0x0f);

        if (opc & P_EXT38) {

            tcg_out8(s, 0x38);

        }

    }



    tcg_out8(s, opc);

}
",216,"static void tcg_out_opc(TCGContext *is_pipe, int omap_mcbsp_i2s_start, int tcg_gen_concat_tl_i64, int PRIx64, int ModuleTypeList)

{

    int PREFIX_ADR;



    if (omap_mcbsp_i2s_start & P_GS) {

        tcg_out8(is_pipe, 0x65);

    }

    if (omap_mcbsp_i2s_start & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((omap_mcbsp_i2s_start & P_REXW) == 0);

        tcg_out8(is_pipe, 0x66);

    }

    if (omap_mcbsp_i2s_start & P_ADDR32) {

        tcg_out8(is_pipe, 0x67);

    }



    PREFIX_ADR = 0;

    PREFIX_ADR |= (omap_mcbsp_i2s_start & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    PREFIX_ADR |= (tcg_gen_concat_tl_i64 & 8) >> 1;                /* REX.R */

    PREFIX_ADR |= (ModuleTypeList & 8) >> 2;                /* REX.X */

    PREFIX_ADR |= (PRIx64 & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    PREFIX_ADR |= omap_mcbsp_i2s_start & (tcg_gen_concat_tl_i64 >= 4 ? P_REXB_R : 0);

    PREFIX_ADR |= omap_mcbsp_i2s_start & (PRIx64 >= 4 ? P_REXB_RM : 0);



    if (PREFIX_ADR) {

        tcg_out8(is_pipe, (uint8_t)(PREFIX_ADR | 0x40));

    }



    if (omap_mcbsp_i2s_start & (P_EXT | P_EXT38)) {

        tcg_out8(is_pipe, 0x0f);

        if (omap_mcbsp_i2s_start & P_EXT38) {

            tcg_out8(is_pipe, 0x38);

        }

    }



    tcg_out8(is_pipe, omap_mcbsp_i2s_start);

}
",0,0,0,-1,s,-0.005354893393814564,6,37,"{'rm': 'PRIx64', 's': 'is_pipe', 'rex': 'PREFIX_ADR', 'x': 'ModuleTypeList', 'r': 'tcg_gen_concat_tl_i64', 'opc': 'omap_mcbsp_i2s_start'}",MHM-Origin,410,0.10728628238042195
209,"static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif

}
",68,"static void gen_mfrom(DisasContext *MSR_MCG_STATUS)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(MSR_MCG_STATUS, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(MSR_MCG_STATUS->pr)) {

        gen_inval_exception(MSR_MCG_STATUS, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(MSR_MCG_STATUS->opcode)], cpu_gpr[rA(MSR_MCG_STATUS->opcode)]);

#endif

}
",1,1,1,-1,ctx,0.0009511113166809082,1,6,{'ctx': 'tcg_temp_new_i32'},MHM-Origin,408,0.09727036952972412
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",70,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *AV_DICT_DONT_OVERWRITE, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, AV_DICT_DONT_OVERWRITE, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",0,0,1,1,usrc,0.5709627605974674,1,2,{'usrc': 'AV_DICT_DONT_OVERWRITE'},MHM-Origin,21,0.004924448331197103
212,"static int ram_save_block(QEMUFile *f)

{

    RAMBlock *block = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *mr;



    if (!block)

        block = QLIST_FIRST(&ram_list.blocks);



    do {

        mr = block->mr;

        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *p;

            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            p = memory_region_get_ram_ptr(mr) + offset;



            if (is_dup_page(p)) {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(f, *p);

                bytes_sent = 1;

            } else {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= block->length) {

            offset = 0;

            block = QLIST_NEXT(block, next);

            if (!block)

                block = QLIST_FIRST(&ram_list.blocks);

        }

    } while (block != last_block || offset != last_offset);



    last_block = block;

    last_offset = offset;



    return bytes_sent;

}
",235,"static int ram_save_block(QEMUFile *gen_set_hflag)

{

    RAMBlock *redundancy_size = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *QERR_INVALID_PARAMETER;



    if (!redundancy_size)

        redundancy_size = QLIST_FIRST(&ram_list.blocks);



    do {

        QERR_INVALID_PARAMETER = redundancy_size->QERR_INVALID_PARAMETER;

        if (memory_region_get_dirty(QERR_INVALID_PARAMETER, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *src_y;

            int cont = (redundancy_size == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(QERR_INVALID_PARAMETER, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            src_y = memory_region_get_ram_ptr(QERR_INVALID_PARAMETER) + offset;



            if (is_dup_page(src_y)) {

                save_block_hdr(gen_set_hflag, redundancy_size, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(gen_set_hflag, *src_y);

                bytes_sent = 1;

            } else {

                save_block_hdr(gen_set_hflag, redundancy_size, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(gen_set_hflag, src_y, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= redundancy_size->length) {

            offset = 0;

            redundancy_size = QLIST_NEXT(redundancy_size, next);

            if (!redundancy_size)

                redundancy_size = QLIST_FIRST(&ram_list.blocks);

        }

    } while (redundancy_size != last_block || offset != last_offset);



    last_block = redundancy_size;

    last_offset = offset;



    return bytes_sent;

}
",0,0,1,1,mr,0.3314635157585144,4,30,"{'p': 'src_y', 'f': 'gen_set_hflag', 'block': 'redundancy_size', 'mr': 'QERR_INVALID_PARAMETER'}",MHM-Origin,168,0.043083409468332924
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",122,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr sprite_trajectory_tab,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(sprite_trajectory_tab, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",0,0,1,1,pa,0.30156996846199036,1,2,{'pa': 'sprite_trajectory_tab'},MHM-Origin,19,0.004768578211466471
214,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;



        output_pixels(i * 4, Y1, U, Y2, V);

    }

}
",216,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int tcg_gen_extu_tl_i64;



    for (tcg_gen_extu_tl_i64 = 0; tcg_gen_extu_tl_i64 < (dstW >> 1); tcg_gen_extu_tl_i64++) {

        int Y1 = (buf0[tcg_gen_extu_tl_i64 * 2]     * yalpha1  + buf1[tcg_gen_extu_tl_i64 * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[tcg_gen_extu_tl_i64 * 2 + 1] * yalpha1  + buf1[tcg_gen_extu_tl_i64 * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[tcg_gen_extu_tl_i64]        * uvalpha1 + ubuf1[tcg_gen_extu_tl_i64]        * uvalpha) >> 19;

        int V  = (vbuf0[tcg_gen_extu_tl_i64]        * uvalpha1 + vbuf1[tcg_gen_extu_tl_i64]        * uvalpha) >> 19;



        output_pixels(tcg_gen_extu_tl_i64 * 4, Y1, U, Y2, V);

    }

}
",0,0,0,-1,i,-0.0030419304966926575,1,13,{'i': 'tcg_gen_extu_tl_i64'},MHM-Origin,409,0.10910525321960449
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
",129,"static av_cold int init_bundles(BinkContext *c)

{

    int CLLCContext, bh, blocks;

    int out_len;



    CLLCContext = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = CLLCContext * bh;



    for (out_len = 0; out_len < BINKB_NB_SRC; out_len++) {

        c->bundle[out_len].data = av_malloc(blocks * 64);

        if (!c->bundle[out_len].data)

            return AVERROR(ENOMEM);

        c->bundle[out_len].data_end = c->bundle[out_len].data + blocks * 64;

    }



    return 0;

}
",1,1,0,1,i,-0.4495144188404083,2,11,"{'bw': 'CLLCContext', 'i': 'out_len'}",MHM-Origin,42,0.009980495770772297
222,"static int vqa_decode_init(AVCodecContext *avctx)

{

    VqaContext *s = (VqaContext *)avctx->priv_data;

    unsigned char *vqa_header;

    int i, j, codebook_index;;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    avctx->has_b_frames = 0;

    dsputil_init(&s->dsp, avctx);



    /* make sure the extradata made it */

    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d\n"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    vqa_header = (unsigned char *)s->avctx->extradata;

    s->vqa_version = vqa_header[0];

    s->width = LE_16(&vqa_header[6]);

    s->height = LE_16(&vqa_header[8]);





    s->vector_width = vqa_header[10];

    s->vector_height = vqa_header[11];

    s->partial_count = s->partial_countdown = vqa_header[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((s->vector_width != 4) ||

        ((s->vector_height != 2) && (s->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    s->codebook_size = MAX_CODEBOOK_SIZE;

    s->codebook = av_malloc(s->codebook_size);

    s->next_codebook_buffer = av_malloc(s->codebook_size);



    /* initialize the solid-color vectors */

    if (s->vector_height == 4) {

        codebook_index = 0xFF00 * 16;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 16; j++)

                s->codebook[codebook_index++] = i;

    } else {

        codebook_index = 0xF00 * 8;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 8; j++)

                s->codebook[codebook_index++] = i;


    s->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    s->decode_buffer_size = (s->width / s->vector_width) *

        (s->height / s->vector_height) * 2;

    s->decode_buffer = av_malloc(s->decode_buffer_size);



    s->frame.data[0] = NULL;



    return 0;
",376,"static int vqa_decode_init(AVCodecContext *allocation_state)

{

    VqaContext *shmobj = (VqaContext *)allocation_state->priv_data;

    unsigned char *OPUS_MODE_CELT;

    int dinfo, gen_helper_fistll_ST0, q_ptr;;



    shmobj->allocation_state = allocation_state;

    allocation_state->pix_fmt = PIX_FMT_PAL8;

    allocation_state->has_b_frames = 0;

    dsputil_init(&shmobj->dsp, allocation_state);



    /* make sure the extradata made it */

    if (shmobj->allocation_state->extradata_size != VQA_HEADER_SIZE) {

        av_log(shmobj->allocation_state, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d
"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    OPUS_MODE_CELT = (unsigned char *)shmobj->allocation_state->extradata;

    shmobj->vqa_version = OPUS_MODE_CELT[0];

    shmobj->width = LE_16(&OPUS_MODE_CELT[6]);

    shmobj->height = LE_16(&OPUS_MODE_CELT[8]);





    shmobj->vector_width = OPUS_MODE_CELT[10];

    shmobj->vector_height = OPUS_MODE_CELT[11];

    shmobj->partial_count = shmobj->partial_countdown = OPUS_MODE_CELT[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((shmobj->vector_width != 4) ||

        ((shmobj->vector_height != 2) && (shmobj->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    shmobj->codebook_size = MAX_CODEBOOK_SIZE;

    shmobj->codebook = av_malloc(shmobj->codebook_size);

    shmobj->next_codebook_buffer = av_malloc(shmobj->codebook_size);



    /* initialize the solid-color vectors */

    if (shmobj->vector_height == 4) {

        q_ptr = 0xFF00 * 16;

        for (dinfo = 0; dinfo < 256; dinfo++)

            for (gen_helper_fistll_ST0 = 0; gen_helper_fistll_ST0 < 16; gen_helper_fistll_ST0++)

                shmobj->codebook[q_ptr++] = dinfo;

    } else {

        q_ptr = 0xF00 * 8;

        for (dinfo = 0; dinfo < 256; dinfo++)

            for (gen_helper_fistll_ST0 = 0; gen_helper_fistll_ST0 < 8; gen_helper_fistll_ST0++)

                shmobj->codebook[q_ptr++] = dinfo;


    shmobj->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    shmobj->decode_buffer_size = (shmobj->width / shmobj->vector_width) *

        (shmobj->height / shmobj->vector_height) * 2;

    shmobj->decode_buffer = av_malloc(shmobj->decode_buffer_size);



    shmobj->frame.data[0] = NULL;



    return 0;
",1,1,1,-1,i,0.0005699396133422852,6,72,"{'codebook_index': 'q_ptr', 'vqa_header': 'OPUS_MODE_CELT', 'j': 'gen_helper_fistll_ST0', 'i': 'dinfo', 's': 'shmobj', 'avctx': 'allocation_state'}",MHM-Origin,416,0.11616957585016886
223,"static int open_output_file(OptionsContext *o, const char *filename)

{

    AVFormatContext *oc;

    int i, j, err;

    AVOutputFormat *file_oformat;

    OutputFile *of;

    OutputStream *ost;

    InputStream  *ist;

    AVDictionary *unused_opts = NULL;

    AVDictionaryEntry *e = NULL;



    if (configure_complex_filters() < 0) {

        av_log(NULL, AV_LOG_FATAL, ""Error configuring filters.\n"");

        exit_program(1);

    }



    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {

        o->stop_time = INT64_MAX;

        av_log(NULL, AV_LOG_WARNING, ""-t and -to cannot be used together; using -t.\n"");

    }



    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {

        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;

        if (o->stop_time <= start_time) {

            av_log(NULL, AV_LOG_WARNING, ""-to value smaller than -ss; ignoring -to.\n"");

            o->stop_time = INT64_MAX;

        } else {

            o->recording_time = o->stop_time - start_time;

        }

    }



    GROW_ARRAY(output_files, nb_output_files);

    of = av_mallocz(sizeof(*of));

    if (!of)

        exit_program(1);

    output_files[nb_output_files - 1] = of;



    of->ost_index      = nb_output_streams;

    of->recording_time = o->recording_time;

    of->start_time     = o->start_time;

    of->limit_filesize = o->limit_filesize;

    of->shortest       = o->shortest;

    av_dict_copy(&of->opts, o->g->format_opts, 0);



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);

    if (!oc) {

        print_error(filename, err);

        exit_program(1);

    }



    of->ctx = oc;

    if (o->recording_time != INT64_MAX)

        oc->duration = o->recording_time;



    file_oformat= oc->oformat;

    oc->interrupt_callback = int_cb;



    /* create streams for all unlabeled output pads */

    for (i = 0; i < nb_filtergraphs; i++) {

        FilterGraph *fg = filtergraphs[i];

        for (j = 0; j < fg->nb_outputs; j++) {

            OutputFilter *ofilter = fg->outputs[j];



            if (!ofilter->out_tmp || ofilter->out_tmp->name)

                continue;



            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,

                                          ofilter->out_tmp->pad_idx)) {

            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;

            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;

            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;

            }

            init_output_filter(ofilter, o, oc);

        }

    }



    /* ffserver seeking with date=... needs a date reference */

    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        int err = parse_option(o, ""metadata"", ""creation_time=now"", options);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    if (!strcmp(file_oformat->name, ""ffm"") && !override_ffserver &&

        av_strstart(filename, ""http:"", NULL)) {

        int j;

        /* special case for files sent to ffserver: we get the stream

           parameters from ffserver */

        int err = read_ffserver_streams(o, oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {

            ost = output_streams[j];

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if(ist->st->codec->codec_type == ost->st->codec->codec_type){

                    ost->sync_ist= ist;

                    ost->source_index= i;

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(""anull"");

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(""null"");

                    ist->discard = 0;

                    ist->st->discard = AVDISCARD_NONE;

                    break;

                }

            }

            if(!ost->sync_ist){

                av_log(NULL, AV_LOG_FATAL, ""Missing %s stream which is required by this ffm\n"", av_get_media_type_string(ost->st->codec->codec_type));

                exit_program(1);

            }

        }

    } else if (!o->nb_stream_maps) {

        char *subtitle_codec_name = NULL;

        /* pick the ""best"" stream of each type */



        /* video: highest resolution */

        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {

            int area = 0, idx = -1;

            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);

            for (i = 0; i < nb_input_streams; i++) {

                int new_area;

                ist = input_streams[i];

                new_area = ist->st->codec->width * ist->st->codec->height;

                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                    new_area = 1;

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    new_area > area) {

                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                        continue;

                    area = new_area;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_video_stream(o, oc, idx);

        }



        /* audio: most channels */

        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_audio_stream(o, oc, idx);

        }



        /* subtitles: pick first */

        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, ""s"");

        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    new_subtitle_stream(o, oc, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < o->nb_stream_maps; i++) {

            StreamMap *map = &o->stream_maps[i];



            if (map->disabled)

                continue;



            if (map->linklabel) {

                FilterGraph *fg;

                OutputFilter *ofilter = NULL;

                int j, k;



                for (j = 0; j < nb_filtergraphs; j++) {

                    fg = filtergraphs[j];

                    for (k = 0; k < fg->nb_outputs; k++) {

                        AVFilterInOut *out = fg->outputs[k]->out_tmp;

                        if (out && !strcmp(out->name, map->linklabel)) {

                            ofilter = fg->outputs[k];

                            goto loop_end;

                        }

                    }

                }

loop_end:

                if (!ofilter) {

                    av_log(NULL, AV_LOG_FATAL, ""Output with label '%s' does not exist ""

                           ""in any defined filter graph, or was already used elsewhere.\n"", map->linklabel);

                    exit_program(1);

                }

                init_output_filter(ofilter, o, oc);

            } else {

                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;



                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];

                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)

                    continue;

                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)

                    continue;

                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

                    continue;

                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)

                    continue;



                switch (ist->st->codec->codec_type) {

                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;

                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;

                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;

                default:

                    av_log(NULL, AV_LOG_FATAL, ""Cannot map stream #%d:%d - unsupported type.\n"",

                           map->file_index, map->stream_index);

                    exit_program(1);

                }

            }

        }

    }



    /* handle attached files */

    for (i = 0; i < o->nb_attachments; i++) {

        AVIOContext *pb;

        uint8_t *attachment;

        const char *p;

        int64_t len;



        if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not open attachment file %s.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        if ((len = avio_size(pb)) <= 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not get size of the attachment %s.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        if (!(attachment = av_malloc(len))) {

            av_log(NULL, AV_LOG_FATAL, ""Attachment %s too large to fit into memory.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        avio_read(pb, attachment, len);



        ost = new_attachment_stream(o, oc, -1);

        ost->stream_copy               = 0;

        ost->attachment_filename       = o->attachments[i];

        ost->finished                  = 1;

        ost->st->codec->extradata      = attachment;

        ost->st->codec->extradata_size = len;



        p = strrchr(o->attachments[i], '/');

        av_dict_set(&ost->st->metadata, ""filename"", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);

        avio_close(pb);

    }



    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { //for all streams of this output file

        AVDictionaryEntry *e;

        ost = output_streams[i];



        if ((ost->stream_copy || ost->attachment_filename)

            && (e = av_dict_get(o->g->codec_opts, ""flags"", NULL, AV_DICT_IGNORE_SUFFIX))

            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))

            if (av_opt_set(ost->st->codec, ""flags"", e->value, 0) < 0)

                exit_program(1);

    }



    /* check if all codec options have been used */

    unused_opts = strip_specifiers(o->g->codec_opts);

    for (i = of->ost_index; i < nb_output_streams; i++) {

        e = NULL;

        while ((e = av_dict_get(output_streams[i]->opts, """", e,

                                AV_DICT_IGNORE_SUFFIX)))

            av_dict_set(&unused_opts, e->key, NULL, 0);

    }



    e = NULL;

    while ((e = av_dict_get(unused_opts, """", e, AV_DICT_IGNORE_SUFFIX))) {

        const AVClass *class = avcodec_get_class();

        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,

                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);

        if (!option)

            continue;

        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {

            av_log(NULL, AV_LOG_ERROR, ""Codec AVOption %s (%s) specified for ""

                   ""output file #%d (%s) is not an encoding option.\n"", e->key,

                   option->help ? option->help : """", nb_output_files - 1,

                   filename);

            exit_program(1);

        }



        // gop_timecode is injected by generic code but not always used

        if (!strcmp(e->key, ""gop_timecode""))

            continue;



        av_log(NULL, AV_LOG_WARNING, ""Codec AVOption %s (%s) specified for ""

               ""output file #%d (%s) has not been used for any stream. The most ""

               ""likely reason is either wrong type (e.g. a video option with ""

               ""no video streams) or that it is a private option of some encoder ""

               ""which was not actually used for any stream.\n"", e->key,

               option->help ? option->help : """", nb_output_files - 1, filename);

    }

    av_dict_free(&unused_opts);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid losing precious files */

        assert_file_overwrite(filename);



        /* open the file */

        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,

                              &oc->interrupt_callback,

                              &of->opts)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (strcmp(oc->oformat->name, ""image2"")==0 && !av_filename_number_test(filename))

        assert_file_overwrite(filename);



    if (o->mux_preload) {

        uint8_t buf[64];

        snprintf(buf, sizeof(buf), ""%d"", (int)(o->mux_preload*AV_TIME_BASE));

        av_dict_set(&of->opts, ""preload"", buf, 0);

    }

    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);



    /* copy metadata */

    for (i = 0; i < o->nb_metadata_map; i++) {

        char *p;

        int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0);



        if (in_file_index >= nb_input_files) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d while processing metadata maps\n"", in_file_index);

            exit_program(1);

        }

        copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc,

                      in_file_index >= 0 ?

                      input_files[in_file_index]->ctx : NULL, o);

    }



    /* copy chapters */

    if (o->chapters_input_file >= nb_input_files) {

        if (o->chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            o->chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i]->ctx->nb_chapters) {

                    o->chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d in chapter mapping.\n"",

                   o->chapters_input_file);

            exit_program(1);

        }

    }

    if (o->chapters_input_file >= 0)

        copy_chapters(input_files[o->chapters_input_file], of,

                      !o->metadata_chapters_manual);



    /* copy global metadata by default */

    if (!o->metadata_global_manual && nb_input_files){

        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

        if(o->recording_time != INT64_MAX)

            av_dict_set(&oc->metadata, ""duration"", NULL, 0);

        av_dict_set(&oc->metadata, ""creation_time"", NULL, 0);

    }

    if (!o->metadata_streams_manual)

        for (i = of->ost_index; i < nb_output_streams; i++) {

            InputStream *ist;

            if (output_streams[i]->source_index < 0)         /* this is true e.g. for attached files */

                continue;

            ist = input_streams[output_streams[i]->source_index];

            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    /* process manually set metadata */

    for (i = 0; i < o->nb_metadata; i++) {

        AVDictionary **m;

        char type, *val;

        const char *stream_spec;

        int index = 0, j, ret = 0;



        val = strchr(o->metadata[i].u.str, '=');

        if (!val) {

            av_log(NULL, AV_LOG_FATAL, ""No '=' character in metadata string %s.\n"",

                   o->metadata[i].u.str);

            exit_program(1);

        }

        *val++ = 0;



        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);

        if (type == 's') {

            for (j = 0; j < oc->nb_streams; j++) {

                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {

                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);

                } else if (ret < 0)

                    exit_program(1);

            }

        }

        else {

            switch (type) {

            case 'g':

                m = &oc->metadata;

                break;

            case 'c':

                if (index < 0 || index >= oc->nb_chapters) {

                    av_log(NULL, AV_LOG_FATAL, ""Invalid chapter index %d in metadata specifier.\n"", index);

                    exit_program(1);

                }

                m = &oc->chapters[index]->metadata;

                break;

            default:

                av_log(NULL, AV_LOG_FATAL, ""Invalid metadata specifier %s.\n"", o->metadata[i].specifier);

                exit_program(1);

            }

            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);

        }

    }



    return 0;

}
",3116,"static int open_output_file(OptionsContext *o, const char *filename)

{

    AVFormatContext *oc;

    int pl061_init_arm, j, err;

    AVOutputFormat *file_oformat;

    OutputFile *of;

    OutputStream *ost;

    InputStream  *ist;

    AVDictionary *unused_opts = NULL;

    AVDictionaryEntry *e = NULL;



    if (configure_complex_filters() < 0) {

        av_log(NULL, AV_LOG_FATAL, ""Error configuring filters.
"");

        exit_program(1);

    }



    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {

        o->stop_time = INT64_MAX;

        av_log(NULL, AV_LOG_WARNING, ""-t and -to cannot be used together; using -t.
"");

    }



    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {

        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;

        if (o->stop_time <= start_time) {

            av_log(NULL, AV_LOG_WARNING, ""-to value smaller than -ss; ignoring -to.
"");

            o->stop_time = INT64_MAX;

        } else {

            o->recording_time = o->stop_time - start_time;

        }

    }



    GROW_ARRAY(output_files, nb_output_files);

    of = av_mallocz(sizeof(*of));

    if (!of)

        exit_program(1);

    output_files[nb_output_files - 1] = of;



    of->ost_index      = nb_output_streams;

    of->recording_time = o->recording_time;

    of->start_time     = o->start_time;

    of->limit_filesize = o->limit_filesize;

    of->shortest       = o->shortest;

    av_dict_copy(&of->opts, o->g->format_opts, 0);



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);

    if (!oc) {

        print_error(filename, err);

        exit_program(1);

    }



    of->ctx = oc;

    if (o->recording_time != INT64_MAX)

        oc->duration = o->recording_time;



    file_oformat= oc->oformat;

    oc->interrupt_callback = int_cb;



    /* create streams for all unlabeled output pads */

    for (pl061_init_arm = 0; pl061_init_arm < nb_filtergraphs; pl061_init_arm++) {

        FilterGraph *fg = filtergraphs[pl061_init_arm];

        for (j = 0; j < fg->nb_outputs; j++) {

            OutputFilter *ofilter = fg->outputs[j];



            if (!ofilter->out_tmp || ofilter->out_tmp->name)

                continue;



            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,

                                          ofilter->out_tmp->pad_idx)) {

            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;

            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;

            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;

            }

            init_output_filter(ofilter, o, oc);

        }

    }



    /* ffserver seeking with date=... needs a date reference */

    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        int err = parse_option(o, ""metadata"", ""creation_time=now"", options);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    if (!strcmp(file_oformat->name, ""ffm"") && !override_ffserver &&

        av_strstart(filename, ""http:"", NULL)) {

        int j;

        /* special case for files sent to ffserver: we get the stream

           parameters from ffserver */

        int err = read_ffserver_streams(o, oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {

            ost = output_streams[j];

            for (pl061_init_arm = 0; pl061_init_arm < nb_input_streams; pl061_init_arm++) {

                ist = input_streams[pl061_init_arm];

                if(ist->st->codec->codec_type == ost->st->codec->codec_type){

                    ost->sync_ist= ist;

                    ost->source_index= pl061_init_arm;

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(""anull"");

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(""null"");

                    ist->discard = 0;

                    ist->st->discard = AVDISCARD_NONE;

                    break;

                }

            }

            if(!ost->sync_ist){

                av_log(NULL, AV_LOG_FATAL, ""Missing %s stream which is required by this ffm
"", av_get_media_type_string(ost->st->codec->codec_type));

                exit_program(1);

            }

        }

    } else if (!o->nb_stream_maps) {

        char *subtitle_codec_name = NULL;

        /* pick the ""best"" stream of each type */



        /* video: highest resolution */

        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {

            int area = 0, idx = -1;

            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);

            for (pl061_init_arm = 0; pl061_init_arm < nb_input_streams; pl061_init_arm++) {

                int new_area;

                ist = input_streams[pl061_init_arm];

                new_area = ist->st->codec->width * ist->st->codec->height;

                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                    new_area = 1;

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    new_area > area) {

                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                        continue;

                    area = new_area;

                    idx = pl061_init_arm;

                }

            }

            if (idx >= 0)

                new_video_stream(o, oc, idx);

        }



        /* audio: most channels */

        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (pl061_init_arm = 0; pl061_init_arm < nb_input_streams; pl061_init_arm++) {

                ist = input_streams[pl061_init_arm];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = pl061_init_arm;

                }

            }

            if (idx >= 0)

                new_audio_stream(o, oc, idx);

        }



        /* subtitles: pick first */

        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, ""s"");

        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {

            for (pl061_init_arm = 0; pl061_init_arm < nb_input_streams; pl061_init_arm++)

                if (input_streams[pl061_init_arm]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    new_subtitle_stream(o, oc, pl061_init_arm);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (pl061_init_arm = 0; pl061_init_arm < o->nb_stream_maps; pl061_init_arm++) {

            StreamMap *map = &o->stream_maps[pl061_init_arm];



            if (map->disabled)

                continue;



            if (map->linklabel) {

                FilterGraph *fg;

                OutputFilter *ofilter = NULL;

                int j, k;



                for (j = 0; j < nb_filtergraphs; j++) {

                    fg = filtergraphs[j];

                    for (k = 0; k < fg->nb_outputs; k++) {

                        AVFilterInOut *out = fg->outputs[k]->out_tmp;

                        if (out && !strcmp(out->name, map->linklabel)) {

                            ofilter = fg->outputs[k];

                            goto loop_end;

                        }

                    }

                }

loop_end:

                if (!ofilter) {

                    av_log(NULL, AV_LOG_FATAL, ""Output with label '%s' does not exist ""

                           ""in any defined filter graph, or was already used elsewhere.
"", map->linklabel);

                    exit_program(1);

                }

                init_output_filter(ofilter, o, oc);

            } else {

                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;



                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];

                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)

                    continue;

                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)

                    continue;

                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

                    continue;

                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)

                    continue;



                switch (ist->st->codec->codec_type) {

                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;

                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;

                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;

                default:

                    av_log(NULL, AV_LOG_FATAL, ""Cannot map stream #%d:%d - unsupported type.
"",

                           map->file_index, map->stream_index);

                    exit_program(1);

                }

            }

        }

    }



    /* handle attached files */

    for (pl061_init_arm = 0; pl061_init_arm < o->nb_attachments; pl061_init_arm++) {

        AVIOContext *pb;

        uint8_t *attachment;

        const char *p;

        int64_t len;



        if ((err = avio_open2(&pb, o->attachments[pl061_init_arm], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not open attachment file %s.
"",

                   o->attachments[pl061_init_arm]);

            exit_program(1);

        }

        if ((len = avio_size(pb)) <= 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not get size of the attachment %s.
"",

                   o->attachments[pl061_init_arm]);

            exit_program(1);

        }

        if (!(attachment = av_malloc(len))) {

            av_log(NULL, AV_LOG_FATAL, ""Attachment %s too large to fit into memory.
"",

                   o->attachments[pl061_init_arm]);

            exit_program(1);

        }

        avio_read(pb, attachment, len);



        ost = new_attachment_stream(o, oc, -1);

        ost->stream_copy               = 0;

        ost->attachment_filename       = o->attachments[pl061_init_arm];

        ost->finished                  = 1;

        ost->st->codec->extradata      = attachment;

        ost->st->codec->extradata_size = len;



        p = strrchr(o->attachments[pl061_init_arm], '/');

        av_dict_set(&ost->st->metadata, ""filename"", (p && *p) ? p + 1 : o->attachments[pl061_init_arm], AV_DICT_DONT_OVERWRITE);

        avio_close(pb);

    }



    for (pl061_init_arm = nb_output_streams - oc->nb_streams; pl061_init_arm < nb_output_streams; pl061_init_arm++) { //for all streams of this output file

        AVDictionaryEntry *e;

        ost = output_streams[pl061_init_arm];



        if ((ost->stream_copy || ost->attachment_filename)

            && (e = av_dict_get(o->g->codec_opts, ""flags"", NULL, AV_DICT_IGNORE_SUFFIX))

            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))

            if (av_opt_set(ost->st->codec, ""flags"", e->value, 0) < 0)

                exit_program(1);

    }



    /* check if all codec options have been used */

    unused_opts = strip_specifiers(o->g->codec_opts);

    for (pl061_init_arm = of->ost_index; pl061_init_arm < nb_output_streams; pl061_init_arm++) {

        e = NULL;

        while ((e = av_dict_get(output_streams[pl061_init_arm]->opts, """", e,

                                AV_DICT_IGNORE_SUFFIX)))

            av_dict_set(&unused_opts, e->key, NULL, 0);

    }



    e = NULL;

    while ((e = av_dict_get(unused_opts, """", e, AV_DICT_IGNORE_SUFFIX))) {

        const AVClass *class = avcodec_get_class();

        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,

                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);

        if (!option)

            continue;

        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {

            av_log(NULL, AV_LOG_ERROR, ""Codec AVOption %s (%s) specified for ""

                   ""output file #%d (%s) is not an encoding option.
"", e->key,

                   option->help ? option->help : """", nb_output_files - 1,

                   filename);

            exit_program(1);

        }



        // gop_timecode is injected by generic code but not always used

        if (!strcmp(e->key, ""gop_timecode""))

            continue;



        av_log(NULL, AV_LOG_WARNING, ""Codec AVOption %s (%s) specified for ""

               ""output file #%d (%s) has not been used for any stream. The most ""

               ""likely reason is either wrong type (e.g. a video option with ""

               ""no video streams) or that it is a private option of some encoder ""

               ""which was not actually used for any stream.
"", e->key,

               option->help ? option->help : """", nb_output_files - 1, filename);

    }

    av_dict_free(&unused_opts);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid losing precious files */

        assert_file_overwrite(filename);



        /* open the file */

        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,

                              &oc->interrupt_callback,

                              &of->opts)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (strcmp(oc->oformat->name, ""image2"")==0 && !av_filename_number_test(filename))

        assert_file_overwrite(filename);



    if (o->mux_preload) {

        uint8_t buf[64];

        snprintf(buf, sizeof(buf), ""%d"", (int)(o->mux_preload*AV_TIME_BASE));

        av_dict_set(&of->opts, ""preload"", buf, 0);

    }

    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);



    /* copy metadata */

    for (pl061_init_arm = 0; pl061_init_arm < o->nb_metadata_map; pl061_init_arm++) {

        char *p;

        int in_file_index = strtol(o->metadata_map[pl061_init_arm].u.str, &p, 0);



        if (in_file_index >= nb_input_files) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d while processing metadata maps
"", in_file_index);

            exit_program(1);

        }

        copy_metadata(o->metadata_map[pl061_init_arm].specifier, *p ? p + 1 : p, oc,

                      in_file_index >= 0 ?

                      input_files[in_file_index]->ctx : NULL, o);

    }



    /* copy chapters */

    if (o->chapters_input_file >= nb_input_files) {

        if (o->chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            o->chapters_input_file = -1;

            for (pl061_init_arm = 0; pl061_init_arm < nb_input_files; pl061_init_arm++)

                if (input_files[pl061_init_arm]->ctx->nb_chapters) {

                    o->chapters_input_file = pl061_init_arm;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d in chapter mapping.
"",

                   o->chapters_input_file);

            exit_program(1);

        }

    }

    if (o->chapters_input_file >= 0)

        copy_chapters(input_files[o->chapters_input_file], of,

                      !o->metadata_chapters_manual);



    /* copy global metadata by default */

    if (!o->metadata_global_manual && nb_input_files){

        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

        if(o->recording_time != INT64_MAX)

            av_dict_set(&oc->metadata, ""duration"", NULL, 0);

        av_dict_set(&oc->metadata, ""creation_time"", NULL, 0);

    }

    if (!o->metadata_streams_manual)

        for (pl061_init_arm = of->ost_index; pl061_init_arm < nb_output_streams; pl061_init_arm++) {

            InputStream *ist;

            if (output_streams[pl061_init_arm]->source_index < 0)         /* this is true e.g. for attached files */

                continue;

            ist = input_streams[output_streams[pl061_init_arm]->source_index];

            av_dict_copy(&output_streams[pl061_init_arm]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    /* process manually set metadata */

    for (pl061_init_arm = 0; pl061_init_arm < o->nb_metadata; pl061_init_arm++) {

        AVDictionary **m;

        char type, *val;

        const char *stream_spec;

        int index = 0, j, ret = 0;



        val = strchr(o->metadata[pl061_init_arm].u.str, '=');

        if (!val) {

            av_log(NULL, AV_LOG_FATAL, ""No '=' character in metadata string %s.
"",

                   o->metadata[pl061_init_arm].u.str);

            exit_program(1);

        }

        *val++ = 0;



        parse_meta_type(o->metadata[pl061_init_arm].specifier, &type, &index, &stream_spec);

        if (type == 's') {

            for (j = 0; j < oc->nb_streams; j++) {

                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {

                    av_dict_set(&oc->streams[j]->metadata, o->metadata[pl061_init_arm].u.str, *val ? val : NULL, 0);

                } else if (ret < 0)

                    exit_program(1);

            }

        }

        else {

            switch (type) {

            case 'g':

                m = &oc->metadata;

                break;

            case 'c':

                if (index < 0 || index >= oc->nb_chapters) {

                    av_log(NULL, AV_LOG_FATAL, ""Invalid chapter index %d in metadata specifier.
"", index);

                    exit_program(1);

                }

                m = &oc->chapters[index]->metadata;

                break;

            default:

                av_log(NULL, AV_LOG_FATAL, ""Invalid metadata specifier %s.
"", o->metadata[pl061_init_arm].specifier);

                exit_program(1);

            }

            av_dict_set(m, o->metadata[pl061_init_arm].u.str, *val ? val : NULL, 0);

        }

    }



    return 0;

}
",0,0,1,1,i,0.1713310182094574,1,72,{'i': 'pl061_init_arm'},MHM-Origin,22,0.017448325951894123
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,

                                   unsigned int imms, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int len;



    assert(immn < 2 && imms < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>

     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>

     * Notice that immn = 0, imms = 11111x is the only combination

     * not covered by one of the above options; this is reserved.

     * Further, <length of run - 1> all-ones is a reserved pattern.

     *

     * In all cases the rotation is by immr % e (and immr is 6 bits).

     */



    /* First determine the element size */

    len = 31 - clz32((immn << 6) | (~imms & 0x3f));

    if (len < 1) {

        /* This is the immn == 0, imms == 0x11111x case */

        return false;

    }

    e = 1 << len;



    levels = e - 1;

    s = imms & levels;

    r = immr & levels;



    if (s == levels) {

        /* <length of run - 1> mustn't be all-ones. */

        return false;

    }



    /* Create the value of one element: s+1 set bits rotated

     * by r within the element (which is e bits wide)...

     */

    mask = bitmask64(s + 1);

    mask = (mask >> r) | (mask << (e - r));

    /* ...then replicate the element over the whole 64 bit value */

    mask = bitfield_replicate(mask, e);

    *result = mask;

    return true;

}
",162,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int resync_mb_x,

                                   unsigned int imms, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int len;



    assert(resync_mb_x < 2 && imms < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>

     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>

     * Notice that immn = 0, imms = 11111x is the only combination

     * not covered by one of the above options; this is reserved.

     * Further, <length of run - 1> all-ones is a reserved pattern.

     *

     * In all cases the rotation is by immr % e (and immr is 6 bits).

     */



    /* First determine the element size */

    len = 31 - clz32((resync_mb_x << 6) | (~imms & 0x3f));

    if (len < 1) {

        /* This is the immn == 0, imms == 0x11111x case */

        return false;

    }

    e = 1 << len;



    levels = e - 1;

    s = imms & levels;

    r = immr & levels;



    if (s == levels) {

        /* <length of run - 1> mustn't be all-ones. */

        return false;

    }



    /* Create the value of one element: s+1 set bits rotated

     * by r within the element (which is e bits wide)...

     */

    mask = bitmask64(s + 1);

    mask = (mask >> r) | (mask << (e - r));

    /* ...then replicate the element over the whole 64 bit value */

    mask = bitfield_replicate(mask, e);

    *result = mask;

    return true;

}
",1,1,0,1,immn,-0.47483794391155243,1,3,{'immn': 'resync_mb_x'},MHM-Origin,22,0.0058310588200887045
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,

                                         src - (stride * 2) +

                                         sizeof(uint8_t), stride, dst, stride);

}
",43,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *inverse, const uint8_t *gen_op_movl_seg_T0_vm,

                                ptrdiff_t refcount_table_clusters)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(gen_op_movl_seg_T0_vm - 2,

                                         gen_op_movl_seg_T0_vm - (refcount_table_clusters * 2) +

                                         sizeof(uint8_t), refcount_table_clusters, inverse, refcount_table_clusters);

}
",0,0,0,-1,src,0.00032414356246590614,3,9,"{'dst': 'inverse', 'src': 'gen_op_movl_seg_T0_vm', 'stride': 'refcount_table_clusters'}",MHM-Origin,412,0.09758957227071126
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",80,"static int flv_probe(AVProbeData *QEMU_GNUC_PREREQ)

{

    const uint8_t *mpeg_enc_ctx;



    if (QEMU_GNUC_PREREQ->buf_size < 6)

        return 0;

    mpeg_enc_ctx = QEMU_GNUC_PREREQ->buf;

    if (mpeg_enc_ctx[0] == 'F' && mpeg_enc_ctx[1] == 'L' && mpeg_enc_ctx[2] == 'V' && mpeg_enc_ctx[3] < 5 && mpeg_enc_ctx[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",0,0,0,-1,d,-0.002242392860352993,2,10,"{'p': 'QEMU_GNUC_PREREQ', 'd': 'mpeg_enc_ctx'}",MHM-Origin,412,0.09963214794794718
232,"static void opt_output_file(void *optctx, const char *filename)

{

    OptionsContext *o = optctx;

    AVFormatContext *oc;

    int i, err;

    AVOutputFormat *file_oformat;

    OutputStream *ost;

    InputStream  *ist;



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    oc = avformat_alloc_context();

    if (!oc) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }



    if (last_asked_format) {

        file_oformat = av_guess_format(last_asked_format, NULL, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Requested output format '%s' is not a suitable output format\n"", last_asked_format);

            exit_program(1);

        }

        last_asked_format = NULL;

    } else {

        file_oformat = av_guess_format(NULL, filename, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Unable to find a suitable output format for '%s'\n"",

                    filename);

            exit_program(1);

        }

    }



    oc->oformat = file_oformat;

    av_strlcpy(oc->filename, filename, sizeof(oc->filename));



    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        /* special case for files sent to avserver: we get the stream

           parameters from avserver */

        int err = read_avserver_streams(oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (!o->nb_stream_maps) {

        /* pick the ""best"" stream of each type */

#define NEW_STREAM(type, index)\

        if (index >= 0) {\

            ost = new_ ## type ## _stream(oc);\

            ost->source_index = index;\

            ost->sync_ist     = &input_streams[index];\

            input_streams[index].discard = 0;\

        }



        /* video: highest resolution */

        if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) {

            int area = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = &input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    ist->st->codec->width * ist->st->codec->height > area) {

                    area = ist->st->codec->width * ist->st->codec->height;

                    idx = i;

                }

            }

            NEW_STREAM(video, idx);

        }



        /* audio: most channels */

        if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = &input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            NEW_STREAM(audio, idx);

        }



        /* subtitles: pick first */

        if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    NEW_STREAM(subtitle, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < o->nb_stream_maps; i++) {

            StreamMap *map = &o->stream_maps[i];



            if (map->disabled)

                continue;



            ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index];

            switch (ist->st->codec->codec_type) {

            case AVMEDIA_TYPE_VIDEO:    ost = new_video_stream(oc);    break;

            case AVMEDIA_TYPE_AUDIO:    ost = new_audio_stream(oc);    break;

            case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break;

            case AVMEDIA_TYPE_DATA:     ost = new_data_stream(oc);     break;

            default:

                av_log(NULL, AV_LOG_ERROR, ""Cannot map stream #%d.%d - unsupported type.\n"",

                       map->file_index, map->stream_index);

                exit_program(1);

            }



            ost->source_index = input_files[map->file_index].ist_index + map->stream_index;

            ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index +

                                           map->sync_stream_index];

            ist->discard = 0;

        }

    }



    av_dict_copy(&oc->metadata, metadata, 0);

    av_dict_free(&metadata);





    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);

    output_files[nb_output_files - 1].ctx       = oc;

    output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams;

    output_files[nb_output_files - 1].recording_time = o->recording_time;

    output_files[nb_output_files - 1].start_time     = o->start_time;

    output_files[nb_output_files - 1].limit_filesize = limit_filesize;

    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid loosing precious files */

        if (!file_overwrite &&

            (strchr(filename, ':') == NULL ||

             filename[1] == ':' ||

             av_strstart(filename, ""file:"", NULL))) {

            if (avio_check(filename, 0) == 0) {

                if (!using_stdin) {

                    fprintf(stderr,""File '%s' already exists. Overwrite ? [y/N] "", filename);

                    fflush(stderr);

                    if (!read_yesno()) {

                        fprintf(stderr, ""Not overwriting - exiting\n"");

                        exit_program(1);

                    }

                }

                else {

                    fprintf(stderr,""File '%s' already exists. Exiting.\n"", filename);

                    exit_program(1);

                }

            }

        }



        /* open the file */

        if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    oc->preload= (int)(mux_preload*AV_TIME_BASE);

    oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE);

    oc->flags |= AVFMT_FLAG_NONBLOCK;



    /* copy chapters */

    if (chapters_input_file >= nb_input_files) {

        if (chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i].ctx->nb_chapters) {

                    chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_ERROR, ""Invalid input file index %d in chapter mapping.\n"",

                   chapters_input_file);

            exit_program(1);

        }

    }

    if (chapters_input_file >= 0)

        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);



    /* copy metadata */

    for (i = 0; i < nb_meta_data_maps; i++) {

        AVFormatContext *files[2];

        AVDictionary    **meta[2];

        int j;



#define METADATA_CHECK_INDEX(index, nb_elems, desc)\

        if ((index) < 0 || (index) >= (nb_elems)) {\

            av_log(NULL, AV_LOG_ERROR, ""Invalid %s index %d while processing metadata maps\n"",\

                     (desc), (index));\

            exit_program(1);\

        }



        int in_file_index = meta_data_maps[i][1].file;

        if (in_file_index < 0)

            continue;

        METADATA_CHECK_INDEX(in_file_index, nb_input_files, ""input file"")



        files[0] = oc;

        files[1] = input_files[in_file_index].ctx;



        for (j = 0; j < 2; j++) {

            MetadataMap *map = &meta_data_maps[i][j];



            switch (map->type) {

            case 'g':

                meta[j] = &files[j]->metadata;

                break;

            case 's':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, ""stream"")

                meta[j] = &files[j]->streams[map->index]->metadata;

                break;

            case 'c':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, ""chapter"")

                meta[j] = &files[j]->chapters[map->index]->metadata;

                break;

            case 'p':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, ""program"")

                meta[j] = &files[j]->programs[map->index]->metadata;

                break;

            }

        }



        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);

    }



    /* copy global metadata by default */

    if (metadata_global_autocopy && nb_input_files)

        av_dict_copy(&oc->metadata, input_files[0].ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

    if (metadata_streams_autocopy)

        for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) {

            InputStream *ist = &input_streams[output_streams[i].source_index];

            av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    frame_rate    = (AVRational){0, 0};

    frame_width   = 0;

    frame_height  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    chapters_input_file = INT_MAX;

    limit_filesize = UINT64_MAX;



    av_freep(&meta_data_maps);

    nb_meta_data_maps = 0;

    metadata_global_autocopy   = 1;

    metadata_streams_autocopy  = 1;

    metadata_chapters_autocopy = 1;

    av_freep(&streamid_map);

    nb_streamid_map = 0;



    av_dict_free(&codec_names);



    av_freep(&forced_key_frames);

    reset_options(o);

}
",1619,"static void opt_output_file(void *optctx, const char *filename)

{

    OptionsContext *q_scale_type = optctx;

    AVFormatContext *oc;

    int gen_set_hflag, kernel_cmdline;

    AVOutputFormat *codes;

    OutputStream *esi;

    InputStream  *ist;



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    oc = avformat_alloc_context();

    if (!oc) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }



    if (last_asked_format) {

        codes = av_guess_format(last_asked_format, NULL, NULL);

        if (!codes) {

            fprintf(stderr, ""Requested output format '%s' is not a suitable output format
"", last_asked_format);

            exit_program(1);

        }

        last_asked_format = NULL;

    } else {

        codes = av_guess_format(NULL, filename, NULL);

        if (!codes) {

            fprintf(stderr, ""Unable to find a suitable output format for '%s'
"",

                    filename);

            exit_program(1);

        }

    }



    oc->oformat = codes;

    av_strlcpy(oc->filename, filename, sizeof(oc->filename));



    if (!strcmp(codes->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        /* special case for files sent to avserver: we get the stream

           parameters from avserver */

        int kernel_cmdline = read_avserver_streams(oc, filename);

        if (kernel_cmdline < 0) {

            print_error(filename, kernel_cmdline);

            exit_program(1);

        }

    } else if (!q_scale_type->nb_stream_maps) {

        /* pick the ""best"" stream of each type */

#define NEW_STREAM(type, index)\

        if (index >= 0) {\

            esi = new_ ## type ## _stream(oc);\

            esi->source_index = index;\

            esi->sync_ist     = &input_streams[index];\

            input_streams[index].discard = 0;\

        }



        /* video: highest resolution */

        if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) {

            int area = 0, idx = -1;

            for (gen_set_hflag = 0; gen_set_hflag < nb_input_streams; gen_set_hflag++) {

                ist = &input_streams[gen_set_hflag];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    ist->st->codec->width * ist->st->codec->height > area) {

                    area = ist->st->codec->width * ist->st->codec->height;

                    idx = gen_set_hflag;

                }

            }

            NEW_STREAM(video, idx);

        }



        /* audio: most channels */

        if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (gen_set_hflag = 0; gen_set_hflag < nb_input_streams; gen_set_hflag++) {

                ist = &input_streams[gen_set_hflag];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = gen_set_hflag;

                }

            }

            NEW_STREAM(audio, idx);

        }



        /* subtitles: pick first */

        if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) {

            for (gen_set_hflag = 0; gen_set_hflag < nb_input_streams; gen_set_hflag++)

                if (input_streams[gen_set_hflag].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    NEW_STREAM(subtitle, gen_set_hflag);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (gen_set_hflag = 0; gen_set_hflag < q_scale_type->nb_stream_maps; gen_set_hflag++) {

            StreamMap *memidx = &q_scale_type->stream_maps[gen_set_hflag];



            if (memidx->disabled)

                continue;



            ist = &input_streams[input_files[memidx->file_index].ist_index + memidx->stream_index];

            switch (ist->st->codec->codec_type) {

            case AVMEDIA_TYPE_VIDEO:    esi = new_video_stream(oc);    break;

            case AVMEDIA_TYPE_AUDIO:    esi = new_audio_stream(oc);    break;

            case AVMEDIA_TYPE_SUBTITLE: esi = new_subtitle_stream(oc); break;

            case AVMEDIA_TYPE_DATA:     esi = new_data_stream(oc);     break;

            default:

                av_log(NULL, codes, ""Cannot map stream #%d.%d - unsupported type.
"",

                       memidx->file_index, memidx->stream_index);

                exit_program(1);

            }



            esi->source_index = input_files[memidx->file_index].ist_index + memidx->stream_index;

            esi->sync_ist = &input_streams[input_files[memidx->sync_file_index].ist_index +

                                           memidx->sync_stream_index];

            ist->discard = 0;

        }

    }



    av_dict_copy(&oc->metadata, metadata, 0);

    av_dict_free(&metadata);





    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);

    output_files[nb_output_files - 1].ctx       = oc;

    output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams;

    output_files[nb_output_files - 1].recording_time = q_scale_type->recording_time;

    output_files[nb_output_files - 1].start_time     = q_scale_type->start_time;

    output_files[nb_output_files - 1].limit_filesize = limit_filesize;

    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid loosing precious files */

        if (!file_overwrite &&

            (strchr(filename, ':') == NULL ||

             filename[1] == ':' ||

             av_strstart(filename, ""file:"", NULL))) {

            if (avio_check(filename, 0) == 0) {

                if (!using_stdin) {

                    fprintf(stderr,""File '%s' already exists. Overwrite ? [y/N] "", filename);

                    fflush(stderr);

                    if (!read_yesno()) {

                        fprintf(stderr, ""Not overwriting - exiting
"");

                        exit_program(1);

                    }

                }

                else {

                    fprintf(stderr,""File '%s' already exists. Exiting.
"", filename);

                    exit_program(1);

                }

            }

        }



        /* open the file */

        if ((kernel_cmdline = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {

            print_error(filename, kernel_cmdline);

            exit_program(1);

        }

    }



    oc->preload= (int)(mux_preload*AV_TIME_BASE);

    oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE);

    oc->flags |= AVFMT_FLAG_NONBLOCK;



    /* copy chapters */

    if (chapters_input_file >= nb_input_files) {

        if (chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            chapters_input_file = -1;

            for (gen_set_hflag = 0; gen_set_hflag < nb_input_files; gen_set_hflag++)

                if (input_files[gen_set_hflag].ctx->nb_chapters) {

                    chapters_input_file = gen_set_hflag;

                    break;

                }

        } else {

            av_log(NULL, codes, ""Invalid input file index %d in chapter mapping.
"",

                   chapters_input_file);

            exit_program(1);

        }

    }

    if (chapters_input_file >= 0)

        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);



    /* copy metadata */

    for (gen_set_hflag = 0; gen_set_hflag < nb_meta_data_maps; gen_set_hflag++) {

        AVFormatContext *files[2];

        AVDictionary    **meta[2];

        int nb_output_streams;



#define METADATA_CHECK_INDEX(index, nb_elems, desc)\

        if ((index) < 0 || (index) >= (nb_elems)) {\

            av_log(NULL, codes, ""Invalid %s index %d while processing metadata maps
"",\

                     (desc), (index));\

            exit_program(1);\

        }



        int in_file_index = meta_data_maps[gen_set_hflag][1].file;

        if (in_file_index < 0)

            continue;

        METADATA_CHECK_INDEX(in_file_index, nb_input_files, ""input file"")



        files[0] = oc;

        files[1] = input_files[in_file_index].ctx;



        for (nb_output_streams = 0; nb_output_streams < 2; nb_output_streams++) {

            MetadataMap *memidx = &meta_data_maps[gen_set_hflag][nb_output_streams];



            switch (memidx->type) {

            case 'g':

                meta[nb_output_streams] = &files[nb_output_streams]->metadata;

                break;

            case 's':

                METADATA_CHECK_INDEX(memidx->index, files[nb_output_streams]->nb_streams, ""stream"")

                meta[nb_output_streams] = &files[nb_output_streams]->streams[memidx->index]->metadata;

                break;

            case 'c':

                METADATA_CHECK_INDEX(memidx->index, files[nb_output_streams]->nb_chapters, ""chapter"")

                meta[nb_output_streams] = &files[nb_output_streams]->chapters[memidx->index]->metadata;

                break;

            case 'p':

                METADATA_CHECK_INDEX(memidx->index, files[nb_output_streams]->nb_programs, ""program"")

                meta[nb_output_streams] = &files[nb_output_streams]->programs[memidx->index]->metadata;

                break;

            }

        }



        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);

    }



    /* copy global metadata by default */

    if (metadata_global_autocopy && nb_input_files)

        av_dict_copy(&oc->metadata, input_files[0].ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

    if (metadata_streams_autocopy)

        for (gen_set_hflag = output_files[nb_output_files - 1].ost_index; gen_set_hflag < nb_output_streams; gen_set_hflag++) {

            InputStream *ist = &input_streams[output_streams[gen_set_hflag].source_index];

            av_dict_copy(&output_streams[gen_set_hflag].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    frame_rate    = (AVRational){0, 0};

    frame_width   = 0;

    frame_height  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    chapters_input_file = INT_MAX;

    limit_filesize = UINT64_MAX;



    av_freep(&meta_data_maps);

    nb_meta_data_maps = 0;

    metadata_global_autocopy   = 1;

    metadata_streams_autocopy  = 1;

    metadata_chapters_autocopy = 1;

    av_freep(&streamid_map);

    nb_streamid_map = 0;



    av_dict_free(&codec_names);



    av_freep(&forced_key_frames);

    reset_options(q_scale_type);

}
",0,0,1,1,i,0.14622294902801514,7,97,"{'err': 'kernel_cmdline', 'ost': 'esi', 'file_oformat': 'codes', 'j': 'nb_output_streams', 'o': 'q_scale_type', 'map': 'memidx', 'i': 'gen_set_hflag'}",MHM-Origin,271,0.12829440434773762
235,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
",14,"bool machine_iommu(MachineState *gen_helper_write_eflags)

{

    return gen_helper_write_eflags->iommu;

}
",0,0,1,1,machine,0.6776441689580679,1,2,{'machine': 'gen_helper_write_eflags'},MHM-Origin,44,0.00923162301381429
237,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
",37,"static CharDriverState *vc_init(const char *id, ChardevBackend *RV34DecContext,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(RV34DecContext->u.vc, errp);

}
",0,0,1,1,backend,0.3966592848300934,1,2,{'backend': 'RV34DecContext'},MHM-Origin,22,0.004602086544036865
239,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)

{

    CPU_DoubleU farg;

    float32 f32;



    farg.ll = arg;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

    }

    f32 = float64_to_float32(farg.d, &env->fp_status);

    farg.d = float32_to_float64(f32, &env->fp_status);



    return farg.ll;

}
",78,"uint64_t helper_frsp(CPUPPCState *FW_CFG_KERNEL_ADDR, uint64_t qemu_cpu_self)

{

    CPU_DoubleU saddr;

    float32 MKTAG;



    saddr.ll = qemu_cpu_self;



    if (unlikely(float64_is_signaling_nan(saddr.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(FW_CFG_KERNEL_ADDR, POWERPC_EXCP_FP_VXSNAN);

    }

    MKTAG = float64_to_float32(saddr.d, &FW_CFG_KERNEL_ADDR->fp_status);

    saddr.d = float32_to_float64(MKTAG, &FW_CFG_KERNEL_ADDR->fp_status);



    return saddr.ll;

}
",0,0,0,-1,env,2.931291237473488e-05,4,15,"{'arg': 'qemu_cpu_self', 'env': 'FW_CFG_KERNEL_ADDR', 'farg': 'saddr', 'f32': 'MKTAG'}",MHM-Origin,412,0.09792594114939372
240,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
",67,"int gen_new_label(void)

{

    TCGContext *mb_type_b_tab = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (mb_type_b_tab->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = mb_type_b_tab->nb_labels++;

    l = &mb_type_b_tab->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
",0,0,1,1,s,0.44449499249458313,1,4,{'s': 'mb_type_b_tab'},MHM-Origin,20,0.005071874459584554
243,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",117,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *src_plane = bs->opaque;
    BlkdebugRule *fft_level_exp = NULL;
    QSIMPLEQ_FOREACH(fft_level_exp, &src_plane->active_rules, active_next) {
        uint64_t inject_offset = fft_level_exp->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (fft_level_exp && fft_level_exp->options.inject.error) {
        return inject_error(bs, fft_level_exp);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",1,1,1,-1,s,0.002084076404571533,2,8,"{'s': 'src_plane', 'rule': 'fft_level_exp'}",MHM-Origin,406,0.10253655910491943
244,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
",74,"static int idreg_init1(SysBusDevice *vert_out1)

{

    IDRegState *next_eip = MACIO_ID_REGISTER(vert_out1);



    memory_region_init_ram(&next_eip->mem, OBJECT(next_eip),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&next_eip->mem);

    memory_region_set_readonly(&next_eip->mem, true);

    sysbus_init_mmio(vert_out1, &next_eip->mem);

    return 0;

}
",1,1,1,-1,s,0.2521158456802368,2,9,"{'dev': 'vert_out1', 's': 'ERROR'}",MHM-Origin,414,0.0997936487197876
245,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,

                                  tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);

    if (arg != (arg & 0xfff))

        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |

              INSN_IMM13(arg & 0x3ff));

#else

    tcg_out_ld_raw(s, ret, arg);

#endif

}
",121,"static inline void tcg_out_ld_ptr(TCGContext *temps, int HV_X64_MSR_SIMP,

                                  tcg_target_long PCI_BRIDGE_CTL_VGA_16BIT)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (PCI_BRIDGE_CTL_VGA_16BIT != (PCI_BRIDGE_CTL_VGA_16BIT & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld
"", __func__, PCI_BRIDGE_CTL_VGA_16BIT);

    if (PCI_BRIDGE_CTL_VGA_16BIT != (PCI_BRIDGE_CTL_VGA_16BIT & 0xfff))

        tcg_out32(temps, SETHI | INSN_RD(HV_X64_MSR_SIMP) | (((uint32_t)PCI_BRIDGE_CTL_VGA_16BIT & 0xfffffc00) >> 10));

    tcg_out32(temps, LDX | INSN_RD(HV_X64_MSR_SIMP) | INSN_RS1(HV_X64_MSR_SIMP) |

              INSN_IMM13(PCI_BRIDGE_CTL_VGA_16BIT & 0x3ff));

#else

    tcg_out_ld_raw(temps, HV_X64_MSR_SIMP, PCI_BRIDGE_CTL_VGA_16BIT);

#endif

}
",0,0,1,1,s,0.2012714147567749,3,18,"{'arg': 'PCI_BRIDGE_CTL_VGA_16BIT', 's': 'temps', 'ret': 'HV_X64_MSR_SIMP'}",MHM-Origin,367,0.08975557486216228
246,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
",221,"int xen_config_dev_blk(DriveInfo *cpuid_ext3_features)

{

    char tcg_gen_qemu_st_i64[256], SETUP_STATE_ACK[256];

    int vdev = 202 * 256 + 16 * cpuid_ext3_features->unit;

    int cdrom = cpuid_ext3_features->bdrv->type == BDRV_TYPE_CDROM;

    const char *params = cdrom ? ""cdrom"" : ""disk"";

    const char *boot_order    = cdrom ? ""r""     : ""w"";



    snprintf(cpuid_ext3_features->bdrv->device_name, sizeof(cpuid_ext3_features->bdrv->device_name),

	     ""xvd%c"", 'a' + cpuid_ext3_features->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s
"",

                  cpuid_ext3_features->unit, cpuid_ext3_features->bdrv->device_name, cpuid_ext3_features->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, tcg_gen_qemu_st_i64, SETUP_STATE_ACK, sizeof(tcg_gen_qemu_st_i64));



    /* frontend */

    xenstore_write_int(tcg_gen_qemu_st_i64, ""virtual-device"",  vdev);

    xenstore_write_str(tcg_gen_qemu_st_i64, ""device-type"",     params);



    /* backend */

    xenstore_write_str(SETUP_STATE_ACK, ""dev"",             cpuid_ext3_features->bdrv->device_name);

    xenstore_write_str(SETUP_STATE_ACK, ""type"",            ""file"");

    xenstore_write_str(SETUP_STATE_ACK, ""params"",          cpuid_ext3_features->bdrv->filename);

    xenstore_write_str(SETUP_STATE_ACK, ""mode"",            boot_order);



    /* common stuff */

    return xen_config_dev_all(tcg_gen_qemu_st_i64, SETUP_STATE_ACK);

}
",0,0,0,-1,devtype,-0.2869475185871124,5,28,"{'mode': 'boot_order', 'be': 'MATROSKA_ID_DURATION', 'fe': 'tcg_gen_qemu_st_i64', 'devtype': 'params', 'disk': 'cpuid_ext3_features'}",MHM-Origin,402,0.10518486499786377
248,"static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)

{

    IVShmemState *s = IVSHMEM(dev);

    Error *err = NULL;

    uint8_t *pci_conf;

    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |

        PCI_BASE_ADDRESS_MEM_PREFETCH;



    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {

        error_setg(errp,

                   ""You must specify either 'shm', 'chardev' or 'x-memdev'"");

        return;

    }



    if (s->hostmem) {

        MemoryRegion *mr;



        if (s->sizearg) {

            g_warning(""size argument ignored with hostmem"");

        }



        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);

        s->ivshmem_size = memory_region_size(mr);

    } else if (s->sizearg == NULL) {

        s->ivshmem_size = 4 << 20; /* 4 MB default */

    } else {

        char *end;

        int64_t size = qemu_strtosz(s->sizearg, &end);

        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {

            error_setg(errp, ""Invalid size %s"", s->sizearg);

            return;

        }

        s->ivshmem_size = size;

    }



    /* IRQFD requires MSI */

    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&

        !ivshmem_has_feature(s, IVSHMEM_MSI)) {

        error_setg(errp, ""ioeventfd/irqfd requires MSI"");

        return;

    }



    /* check that role is reasonable */

    if (s->role) {

        if (strncmp(s->role, ""peer"", 5) == 0) {

            s->role_val = IVSHMEM_PEER;

        } else if (strncmp(s->role, ""master"", 7) == 0) {

            s->role_val = IVSHMEM_MASTER;

        } else {

            error_setg(errp, ""'role' must be 'peer' or 'master'"");

            return;

        }

    } else {

        s->role_val = IVSHMEM_MASTER; /* default */

    }



    pci_conf = dev->config;

    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;



    /*

     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a

     * bald-faced lie then.  But it's a backwards compatible lie.

     */

    pci_config_set_interrupt_pin(pci_conf, 1);



    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,

                          ""ivshmem-mmio"", IVSHMEM_REG_BAR_SIZE);



    /* region for registers*/

    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,

                     &s->ivshmem_mmio);



    memory_region_init(&s->bar, OBJECT(s), ""ivshmem-bar2-container"", s->ivshmem_size);

    if (s->ivshmem_64bit) {

        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;

    }



    if (s->hostmem != NULL) {

        MemoryRegion *mr;



        IVSHMEM_DPRINTF(""using hostmem\n"");



        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),

                                            &error_abort);

        vmstate_register_ram(mr, DEVICE(s));

        memory_region_add_subregion(&s->bar, 0, mr);

        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);

    } else if (s->server_chr != NULL) {

        /* FIXME do not rely on what chr drivers put into filename */

        if (strncmp(s->server_chr->filename, ""unix:"", 5)) {

            error_setg(errp, ""chardev is not a unix client socket"");

            return;

        }



        /* if we get a UNIX socket as the parameter we will talk

         * to the ivshmem server to receive the memory region */



        IVSHMEM_DPRINTF(""using shared memory server (socket = %s)\n"",

                        s->server_chr->filename);



        if (ivshmem_setup_interrupts(s) < 0) {

            error_setg(errp, ""failed to initialize interrupts"");

            return;

        }



        /* we allocate enough space for 16 peers and grow as needed */

        resize_peers(s, 16);

        s->vm_id = -1;



        pci_register_bar(dev, 2, attr, &s->bar);



        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,

                              ivshmem_check_version, NULL, s);

    } else {

        /* just map the file immediately, we're not using a server */

        int fd;



        IVSHMEM_DPRINTF(""using shm_open (shm object = %s)\n"", s->shmobj);



        /* try opening with O_EXCL and if it succeeds zero the memory

         * by truncating to 0 */

        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,

                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {

           /* truncate file to length PCI device's memory */

            if (ftruncate(fd, s->ivshmem_size) != 0) {

                error_report(""could not truncate shared file"");

            }



        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,

                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {

            error_setg(errp, ""could not open shared file"");

            return;

        }



        if (check_shm_size(s, fd, errp) == -1) {

            return;

        }



        create_shared_memory_BAR(s, fd, attr, &err);

        if (err) {

            error_propagate(errp, err);

            return;

        }

    }



    fifo8_create(&s->incoming_fifo, sizeof(int64_t));



    if (s->role_val == IVSHMEM_PEER) {

        error_setg(&s->migration_blocker,

                   ""Migration is disabled when using feature 'peer mode' in device 'ivshmem'"");

        migrate_add_blocker(s->migration_blocker);

    }

}
",778,"static void pci_ivshmem_realize(PCIDevice *dev, Error **nb_refs)

{

    IVShmemState *drive_get_max_bus = IVSHMEM(dev);

    Error *err = NULL;

    uint8_t *pci_conf;

    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |

        PCI_BASE_ADDRESS_MEM_PREFETCH;



    if (!!drive_get_max_bus->server_chr + !!drive_get_max_bus->shmobj + !!drive_get_max_bus->hostmem != 1) {

        error_setg(nb_refs,

                   ""You must specify either 'shm', 'chardev' or 'x-memdev'"");

        return;

    }



    if (drive_get_max_bus->hostmem) {

        MemoryRegion *mr;



        if (drive_get_max_bus->sizearg) {

            g_warning(""size argument ignored with hostmem"");

        }



        mr = host_memory_backend_get_memory(drive_get_max_bus->hostmem, &error_abort);

        drive_get_max_bus->ivshmem_size = memory_region_size(mr);

    } else if (drive_get_max_bus->sizearg == NULL) {

        drive_get_max_bus->ivshmem_size = 4 << 20; /* 4 MB default */

    } else {

        char *end;

        int64_t size = qemu_strtosz(drive_get_max_bus->sizearg, &end);

        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {

            error_setg(nb_refs, ""Invalid size %s"", drive_get_max_bus->sizearg);

            return;

        }

        drive_get_max_bus->ivshmem_size = size;

    }



    /* IRQFD requires MSI */

    if (ivshmem_has_feature(drive_get_max_bus, IVSHMEM_IOEVENTFD) &&

        !ivshmem_has_feature(drive_get_max_bus, IVSHMEM_MSI)) {

        error_setg(nb_refs, ""ioeventfd/irqfd requires MSI"");

        return;

    }



    /* check that role is reasonable */

    if (drive_get_max_bus->role) {

        if (strncmp(drive_get_max_bus->role, ""peer"", 5) == 0) {

            drive_get_max_bus->role_val = IVSHMEM_PEER;

        } else if (strncmp(drive_get_max_bus->role, ""master"", 7) == 0) {

            drive_get_max_bus->role_val = IVSHMEM_MASTER;

        } else {

            error_setg(nb_refs, ""'role' must be 'peer' or 'master'"");

            return;

        }

    } else {

        drive_get_max_bus->role_val = IVSHMEM_MASTER; /* default */

    }



    pci_conf = dev->config;

    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;



    /*

     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a

     * bald-faced lie then.  But it's a backwards compatible lie.

     */

    pci_config_set_interrupt_pin(pci_conf, 1);



    memory_region_init_io(&drive_get_max_bus->ivshmem_mmio, OBJECT(drive_get_max_bus), &ivshmem_mmio_ops, drive_get_max_bus,

                          ""ivshmem-mmio"", IVSHMEM_REG_BAR_SIZE);



    /* region for registers*/

    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,

                     &drive_get_max_bus->ivshmem_mmio);



    memory_region_init(&drive_get_max_bus->bar, OBJECT(drive_get_max_bus), ""ivshmem-bar2-container"", drive_get_max_bus->ivshmem_size);

    if (drive_get_max_bus->ivshmem_64bit) {

        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;

    }



    if (drive_get_max_bus->hostmem != NULL) {

        MemoryRegion *mr;



        IVSHMEM_DPRINTF(""using hostmem
"");



        mr = host_memory_backend_get_memory(MEMORY_BACKEND(drive_get_max_bus->hostmem),

                                            &error_abort);

        vmstate_register_ram(mr, DEVICE(drive_get_max_bus));

        memory_region_add_subregion(&drive_get_max_bus->bar, 0, mr);

        pci_register_bar(PCI_DEVICE(drive_get_max_bus), 2, attr, &drive_get_max_bus->bar);

    } else if (drive_get_max_bus->server_chr != NULL) {

        /* FIXME do not rely on what chr drivers put into filename */

        if (strncmp(drive_get_max_bus->server_chr->filename, ""unix:"", 5)) {

            error_setg(nb_refs, ""chardev is not a unix client socket"");

            return;

        }



        /* if we get a UNIX socket as the parameter we will talk

         * to the ivshmem server to receive the memory region */



        IVSHMEM_DPRINTF(""using shared memory server (socket = %s)
"",

                        drive_get_max_bus->server_chr->filename);



        if (ivshmem_setup_interrupts(drive_get_max_bus) < 0) {

            error_setg(nb_refs, ""failed to initialize interrupts"");

            return;

        }



        /* we allocate enough space for 16 peers and grow as needed */

        resize_peers(drive_get_max_bus, 16);

        drive_get_max_bus->vm_id = -1;



        pci_register_bar(dev, 2, attr, &drive_get_max_bus->bar);



        qemu_chr_add_handlers(drive_get_max_bus->server_chr, ivshmem_can_receive,

                              ivshmem_check_version, NULL, drive_get_max_bus);

    } else {

        /* just map the file immediately, we're not using a server */

        int drc_index;



        IVSHMEM_DPRINTF(""using shm_open (shm object = %s)
"", drive_get_max_bus->shmobj);



        /* try opening with O_EXCL and if it succeeds zero the memory

         * by truncating to 0 */

        if ((drc_index = shm_open(drive_get_max_bus->shmobj, O_CREAT|O_RDWR|O_EXCL,

                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {

           /* truncate file to length PCI device's memory */

            if (ftruncate(drc_index, drive_get_max_bus->ivshmem_size) != 0) {

                error_report(""could not truncate shared file"");

            }



        } else if ((drc_index = shm_open(drive_get_max_bus->shmobj, O_CREAT|O_RDWR,

                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {

            error_setg(nb_refs, ""could not open shared file"");

            return;

        }



        if (check_shm_size(drive_get_max_bus, drc_index, nb_refs) == -1) {

            return;

        }



        create_shared_memory_BAR(drive_get_max_bus, drc_index, attr, &err);

        if (err) {

            error_propagate(nb_refs, err);

            return;

        }

    }



    fifo8_create(&drive_get_max_bus->incoming_fifo, sizeof(int64_t));



    if (drive_get_max_bus->role_val == IVSHMEM_PEER) {

        error_setg(&drive_get_max_bus->migration_blocker,

                   ""Migration is disabled when using feature 'peer mode' in device 'ivshmem'"");

        migrate_add_blocker(drive_get_max_bus->migration_blocker);

    }

}
",1,1,0,1,s,-0.2726365625858307,3,70,"{'errp': 'nb_refs', 'fd': 'drc_index', 's': 'drive_get_max_bus'}",MHM-Origin,84,0.030646085739135742
252,"static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int i;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""pxor %%mm2, %%mm2		\n\t"" // 2*xalpha

			""movd %5, %%mm6			\n\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""movq %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	\n\t""

			""movd %4, %%mm6			\n\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""xorl %%eax, %%eax		\n\t"" // i

			""movl %0, %%esi			\n\t"" // src

			""movl %1, %%edi			\n\t"" // buf1

			""movl %3, %%edx			\n\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		\n\t""

			""xorl %%ebx, %%ebx		\n\t""

			""movw %4, %%bx			\n\t"" // (xInc*4)&0xFFFF



#define FUNNY_Y_CODE \

			PREFETCH"" 1024(%%esi)		\n\t""\

			PREFETCH"" 1056(%%esi)		\n\t""\

			PREFETCH"" 1088(%%esi)		\n\t""\

			""call ""MANGLE(funnyYCode)""	\n\t""\

			""movq ""MANGLE(temp0)"", %%mm2	\n\t""\

			""xorl %%ecx, %%ecx		\n\t""



FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE



			:: ""m"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" ((xInc*4)>>16),

			""m"" ((xInc*4)&0xFFFF), ""m"" (xInc&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		\n\t"" // i

		""xorl %%ebx, %%ebx		\n\t"" // xx

		""xorl %%ecx, %%ecx		\n\t"" // 2*xalpha

		"".balign 16			\n\t""

		""1:				\n\t""

		""movzbl  (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, (%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, 2(%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			\n\t""

		""cmpl %2, %%eax			\n\t""

		"" jb 1b				\n\t""





		:: ""r"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" (xInc>>16), ""m"" (xInc&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int i;

	unsigned int xpos=0;

	for(i=0;i<dstWidth;i++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

		xpos+=xInc;

	}

#endif

    }

}
",573,"static inline void RENAME(hyscale)(uint16_t *rlow, int dstWidth, uint8_t *tcg_gen_extu_tl_i64, int rtp_handle, int xInc)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(rlow, dstWidth, tcg_gen_extu_tl_i64, rtp_handle, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int i;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		
\t""

			""pxor %%mm2, %%mm2		
\t"" // 2*xalpha

			""movd %5, %%mm6			
\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		
\t""

			""punpcklwd %%mm6, %%mm6		
\t""

			""movq %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t""

			""paddw %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t""

			""paddw %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	
\t""

			""movd %4, %%mm6			
\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		
\t""

			""punpcklwd %%mm6, %%mm6		
\t""

			""xorl %%eax, %%eax		
\t"" // i

			""movl %0, %%esi			
\t"" // src

			""movl %1, %%edi			
\t"" // buf1

			""movl %3, %%edx			
\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		
\t""

			""xorl %%ebx, %%ebx		
\t""

			""movw %4, %%bx			
\t"" // (xInc*4)&0xFFFF



#define FUNNY_Y_CODE \

			PREFETCH"" 1024(%%esi)		
\t""\

			PREFETCH"" 1056(%%esi)		
\t""\

			PREFETCH"" 1088(%%esi)		
\t""\

			""call ""MANGLE(funnyYCode)""	
\t""\

			""movq ""MANGLE(temp0)"", %%mm2	
\t""\

			""xorl %%ecx, %%ecx		
\t""



FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE



			:: ""m"" (tcg_gen_extu_tl_i64), ""m"" (rlow), ""m"" (dstWidth), ""m"" ((xInc*4)>>16),

			""m"" ((xInc*4)&0xFFFF), ""m"" (xInc&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(i=dstWidth-1; (i*xInc)>>16 >=rtp_handle-1; i--) rlow[i] = tcg_gen_extu_tl_i64[rtp_handle-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		
\t"" // i

		""xorl %%ebx, %%ebx		
\t"" // xx

		""xorl %%ecx, %%ecx		
\t"" // 2*xalpha

		"".balign 16			
\t""

		""1:				
\t""

		""movzbl  (%0, %%ebx), %%edi	
\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	
\t"" //src[xx+1]

		""subl %%edi, %%esi		
\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		
\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		
\t""

		""addl %%edi, %%esi		
\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			
\t""

		""shrl $9, %%esi			
\t""

		""movw %%si, (%%edi, %%eax, 2)	
\t""

		""addw %4, %%cx			
\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			
\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	
\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	
\t"" //src[xx+1]

		""subl %%edi, %%esi		
\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		
\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		
\t""

		""addl %%edi, %%esi		
\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			
\t""

		""shrl $9, %%esi			
\t""

		""movw %%si, 2(%%edi, %%eax, 2)	
\t""

		""addw %4, %%cx			
\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			
\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			
\t""

		""cmpl %2, %%eax			
\t""

		"" jb 1b				
\t""





		:: ""r"" (tcg_gen_extu_tl_i64), ""m"" (rlow), ""m"" (dstWidth), ""m"" (xInc>>16), ""m"" (xInc&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int i;

	unsigned int xpos=0;

	for(i=0;i<dstWidth;i++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		rlow[i]= (tcg_gen_extu_tl_i64[xx]<<7) + (tcg_gen_extu_tl_i64[xx+1] - tcg_gen_extu_tl_i64[xx])*xalpha;

		xpos+=xInc;

	}

#endif

    }

}
",1,1,0,1,srcW,-0.43524229526519775,3,18,"{'src': 'tcg_gen_extu_tl_i64', 'dst': 'rlow', 'srcW': 'rtp_handle'}",MHM-Origin,65,0.020712268352508546
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",50,"static int get_uint16_equal(QEMUFile *prom_addr, void *kernel_filename, size_t size)

{

    uint16_t *gen_exts = kernel_filename;

    uint16_t v2;

    qemu_get_be16s(prom_addr, &v2);



    if (*gen_exts == v2) {

        return 0;

    }

    return -EINVAL;

}
",1,1,0,1,pv,-0.6705701351165771,3,6,"{'v': 'gen_exts', 'f': 'prom_addr', 'pv': 'kernel_filename'}",MHM-Origin,61,0.014657247066497802
254,"static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,

                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,

                              const uint8_t *buf, int len, uint16_t seq,

                              int flags)

{

    uint8_t nal;

    uint8_t type;

    int result = 0;



    if (!len) {

        av_log(ctx, AV_LOG_ERROR, ""Empty H264 RTP packet\n"");

        return AVERROR_INVALIDDATA;

    }

    nal  = buf[0];

    type = nal & 0x1f;



    assert(data);

    assert(buf);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (type >= 1 && type <= 23)

        type = 1;

    switch (type) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(pkt, len + sizeof(start_sequence));

        memcpy(pkt->data, start_sequence, sizeof(start_sequence));

        memcpy(pkt->data + sizeof(start_sequence), buf, len);

        COUNT_NAL_TYPE(data, nal);

        break;



    case 24:                   // STAP-A (one packet, multiple nals)

        // consume the STAP-A NAL

        buf++;

        len--;

        // first we are going to figure out the total size

        {

            int pass         = 0;

            int total_length = 0;

            uint8_t *dst     = NULL;



            for (pass = 0; pass < 2; pass++) {

                const uint8_t *src = buf;

                int src_len        = len;



                while (src_len > 2) {

                    uint16_t nal_size = AV_RB16(src);



                    // consume the length of the aggregate

                    src     += 2;

                    src_len -= 2;



                    if (nal_size <= src_len) {

                        if (pass == 0) {

                            // counting

                            total_length += sizeof(start_sequence) + nal_size;

                        } else {

                            // copying

                            assert(dst);

                            memcpy(dst, start_sequence, sizeof(start_sequence));

                            dst += sizeof(start_sequence);

                            memcpy(dst, src, nal_size);

                            COUNT_NAL_TYPE(data, *src);

                            dst += nal_size;

                        }

                    } else {

                        av_log(ctx, AV_LOG_ERROR,

                               ""nal size exceeds length: %d %d\n"", nal_size, src_len);

                    }



                    // eat what we handled

                    src     += nal_size;

                    src_len -= nal_size;



                    if (src_len < 0)

                        av_log(ctx, AV_LOG_ERROR,

                               ""Consumed more bytes than we got! (%d)\n"", src_len);

                }



                if (pass == 0) {

                    /* now we know the total size of the packet (with the

                     * start sequences added) */

                    av_new_packet(pkt, total_length);

                    dst = pkt->data;

                } else {

                    assert(dst - pkt->data == total_length);

                }

            }

        }

        break;



    case 25:                   // STAP-B

    case 26:                   // MTAP-16

    case 27:                   // MTAP-24

    case 29:                   // FU-B

        av_log(ctx, AV_LOG_ERROR,

               ""Unhandled type (%d) (See RFC for implementation details\n"",

               type);

        result = AVERROR(ENOSYS);

        break;



    case 28:                   // FU-A (fragmented nal)

        buf++;

        len--;                 // skip the fu_indicator

        if (len > 1) {

            // these are the same as above, we just redo them here for clarity

            uint8_t fu_indicator      = nal;

            uint8_t fu_header         = *buf;

            uint8_t start_bit         = fu_header >> 7;

            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;

            uint8_t nal_type          = fu_header & 0x1f;

            uint8_t reconstructed_nal;



            // Reconstruct this packet's true nal; only the data follows.

            /* The original nal forbidden bit and NRI are stored in this

             * packet's nal. */

            reconstructed_nal  = fu_indicator & 0xe0;

            reconstructed_nal |= nal_type;



            // skip the fu_header

            buf++;

            len--;



            if (start_bit)

                COUNT_NAL_TYPE(data, nal_type);

            if (start_bit) {

                /* copy in the start sequence, and the reconstructed nal */

                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);

                memcpy(pkt->data, start_sequence, sizeof(start_sequence));

                pkt->data[sizeof(start_sequence)] = reconstructed_nal;

                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);

            } else {

                av_new_packet(pkt, len);

                memcpy(pkt->data, buf, len);

            }

        } else {

            av_log(ctx, AV_LOG_ERROR, ""Too short data for FU-A H264 RTP packet\n"");

            result = AVERROR_INVALIDDATA;

        }

        break;



    case 30:                   // undefined

    case 31:                   // undefined

    default:

        av_log(ctx, AV_LOG_ERROR, ""Undefined type (%d)\n"", type);

        result = AVERROR_INVALIDDATA;

        break;

    }



    pkt->stream_index = st->index;



    return result;

}
",666,"static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *server_chr,

                              AVStream *vert_out0, AVPacket *tcg_regset_set_reg, uint32_t *timestamp,

                              const uint8_t *buf, int len, uint16_t seq,

                              int flags)

{

    uint8_t nal;

    uint8_t type;

    int result = 0;



    if (!len) {

        av_log(ctx, AV_LOG_ERROR, ""Empty H264 RTP packet
"");

        return AVERROR_INVALIDDATA;

    }

    nal  = buf[0];

    type = nal & 0x1f;



    assert(server_chr);

    assert(buf);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (type >= 1 && type <= 23)

        type = 1;

    switch (type) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(tcg_regset_set_reg, len + sizeof(start_sequence));

        memcpy(tcg_regset_set_reg->server_chr, start_sequence, sizeof(start_sequence));

        memcpy(tcg_regset_set_reg->server_chr + sizeof(start_sequence), buf, len);

        COUNT_NAL_TYPE(server_chr, nal);

        break;



    case 24:                   // STAP-A (one packet, multiple nals)

        // consume the STAP-A NAL

        buf++;

        len--;

        // first we are going to figure out the total size

        {

            int pass         = 0;

            int total_length = 0;

            uint8_t *dst     = NULL;



            for (pass = 0; pass < 2; pass++) {

                const uint8_t *qemu_co_mutex_unlock = buf;

                int src_len        = len;



                while (src_len > 2) {

                    uint16_t nal_size = AV_RB16(qemu_co_mutex_unlock);



                    // consume the length of the aggregate

                    qemu_co_mutex_unlock     += 2;

                    src_len -= 2;



                    if (nal_size <= src_len) {

                        if (pass == 0) {

                            // counting

                            total_length += sizeof(start_sequence) + nal_size;

                        } else {

                            // copying

                            assert(dst);

                            memcpy(dst, start_sequence, sizeof(start_sequence));

                            dst += sizeof(start_sequence);

                            memcpy(dst, qemu_co_mutex_unlock, nal_size);

                            COUNT_NAL_TYPE(server_chr, *qemu_co_mutex_unlock);

                            dst += nal_size;

                        }

                    } else {

                        av_log(ctx, AV_LOG_ERROR,

                               ""nal size exceeds length: %d %d
"", nal_size, src_len);

                    }



                    // eat what we handled

                    qemu_co_mutex_unlock     += nal_size;

                    src_len -= nal_size;



                    if (src_len < 0)

                        av_log(ctx, AV_LOG_ERROR,

                               ""Consumed more bytes than we got! (%d)
"", src_len);

                }



                if (pass == 0) {

                    /* now we know the total size of the packet (with the

                     * start sequences added) */

                    av_new_packet(tcg_regset_set_reg, total_length);

                    dst = tcg_regset_set_reg->server_chr;

                } else {

                    assert(dst - tcg_regset_set_reg->server_chr == total_length);

                }

            }

        }

        break;



    case 25:                   // STAP-B

    case 26:                   // MTAP-16

    case 27:                   // MTAP-24

    case 29:                   // FU-B

        av_log(ctx, AV_LOG_ERROR,

               ""Unhandled type (%d) (See RFC for implementation details
"",

               type);

        result = AVERROR(ENOSYS);

        break;



    case 28:                   // FU-A (fragmented nal)

        buf++;

        len--;                 // skip the fu_indicator

        if (len > 1) {

            // these are the same as above, we just redo them here for clarity

            uint8_t fu_indicator      = nal;

            uint8_t fu_header         = *buf;

            uint8_t start_bit         = fu_header >> 7;

            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;

            uint8_t nal_type          = fu_header & 0x1f;

            uint8_t reconstructed_nal;



            // Reconstruct this packet's true nal; only the data follows.

            /* The original nal forbidden bit and NRI are stored in this

             * packet's nal. */

            reconstructed_nal  = fu_indicator & 0xe0;

            reconstructed_nal |= nal_type;



            // skip the fu_header

            buf++;

            len--;



            if (start_bit)

                COUNT_NAL_TYPE(server_chr, nal_type);

            if (start_bit) {

                /* copy in the start sequence, and the reconstructed nal */

                av_new_packet(tcg_regset_set_reg, sizeof(start_sequence) + sizeof(nal) + len);

                memcpy(tcg_regset_set_reg->server_chr, start_sequence, sizeof(start_sequence));

                tcg_regset_set_reg->server_chr[sizeof(start_sequence)] = reconstructed_nal;

                memcpy(tcg_regset_set_reg->server_chr + sizeof(start_sequence) + sizeof(nal), buf, len);

            } else {

                av_new_packet(tcg_regset_set_reg, len);

                memcpy(tcg_regset_set_reg->server_chr, buf, len);

            }

        } else {

            av_log(ctx, AV_LOG_ERROR, ""Too short data for FU-A H264 RTP packet
"");

            result = AVERROR_INVALIDDATA;

        }

        break;



    case 30:                   // undefined

    case 31:                   // undefined

    default:

        av_log(ctx, AV_LOG_ERROR, ""Undefined type (%d)
"", type);

        result = AVERROR_INVALIDDATA;

        break;

    }



    tcg_regset_set_reg->stream_index = vert_out0->index;



    return result;

}
",1,1,0,1,pkt,-0.10385176539421082,4,35,"{'data': 'server_chr', 'st': 'vert_out0', 'src': 'qemu_co_mutex_unlock', 'pkt': 'tcg_regset_set_reg'}",MHM-Origin,82,0.027141229311625163
255,"void bdrv_refresh_filename(BlockDriverState *bs)

{

    BlockDriver *drv = bs->drv;

    QDict *opts;



    if (!drv) {

        return;

    }



    /* This BDS's file name will most probably depend on its file's name, so

     * refresh that first */

    if (bs->file) {

        bdrv_refresh_filename(bs->file->bs);

    }



    if (drv->bdrv_refresh_filename) {

        /* Obsolete information is of no use here, so drop the old file name

         * information before refreshing it */

        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        drv->bdrv_refresh_filename(bs);

    } else if (bs->file) {

        /* Try to reconstruct valid information from the underlying file */

        bool has_open_options;



        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        opts = qdict_new();

        has_open_options = append_open_options(opts, bs);



        /* If no specific options have been given for this BDS, the filename of

         * the underlying file should suffice for this one as well */

        if (bs->file->bs->exact_filename[0] && !has_open_options) {

            strcpy(bs->exact_filename, bs->file->bs->exact_filename);

        }

        /* Reconstructing the full options QDict is simple for most format block

         * drivers, as long as the full options are known for the underlying

         * file BDS. The full options QDict of that file BDS should somehow

         * contain a representation of the filename, therefore the following

         * suffices without querying the (exact_)filename of this BDS. */

        if (bs->file->bs->full_open_options) {

            qdict_put_obj(opts, ""driver"",

                          QOBJECT(qstring_from_str(drv->format_name)));

            QINCREF(bs->file->bs->full_open_options);

            qdict_put_obj(opts, ""file"",

                          QOBJECT(bs->file->bs->full_open_options));



            bs->full_open_options = opts;

        } else {

            QDECREF(opts);

        }

    } else if (!bs->full_open_options && qdict_size(bs->options)) {

        /* There is no underlying file BDS (at least referenced by BDS.file),

         * so the full options QDict should be equal to the options given

         * specifically for this block device when it was opened (plus the

         * driver specification).

         * Because those options don't change, there is no need to update

         * full_open_options when it's already set. */



        opts = qdict_new();

        append_open_options(opts, bs);

        qdict_put_obj(opts, ""driver"",

                      QOBJECT(qstring_from_str(drv->format_name)));



        if (bs->exact_filename[0]) {

            /* This may not work for all block protocol drivers (some may

             * require this filename to be parsed), but we have to find some

             * default solution here, so just include it. If some block driver

             * does not support pure options without any filename at all or

             * needs some special format of the options QDict, it needs to

             * implement the driver-specific bdrv_refresh_filename() function.

             */

            qdict_put_obj(opts, ""filename"",

                          QOBJECT(qstring_from_str(bs->exact_filename)));

        }



        bs->full_open_options = opts;

    }



    if (bs->exact_filename[0]) {

        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);

    } else if (bs->full_open_options) {

        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));

        snprintf(bs->filename, sizeof(bs->filename), ""json:%s"",

                 qstring_get_str(json));

        QDECREF(json);

    }

}
",422,"void bdrv_refresh_filename(BlockDriverState *SETUP_STATE_ACK)

{

    BlockDriver *drv = SETUP_STATE_ACK->drv;

    QDict *opts;



    if (!drv) {

        return;

    }



    /* This BDS's file name will most probably depend on its file's name, so

     * refresh that first */

    if (SETUP_STATE_ACK->file) {

        bdrv_refresh_filename(SETUP_STATE_ACK->file->SETUP_STATE_ACK);

    }



    if (drv->bdrv_refresh_filename) {

        /* Obsolete information is of no use here, so drop the old file name

         * information before refreshing it */

        SETUP_STATE_ACK->exact_filename[0] = '\0';

        if (SETUP_STATE_ACK->full_open_options) {

            QDECREF(SETUP_STATE_ACK->full_open_options);

            SETUP_STATE_ACK->full_open_options = NULL;

        }



        drv->bdrv_refresh_filename(SETUP_STATE_ACK);

    } else if (SETUP_STATE_ACK->file) {

        /* Try to reconstruct valid information from the underlying file */

        bool has_open_options;



        SETUP_STATE_ACK->exact_filename[0] = '\0';

        if (SETUP_STATE_ACK->full_open_options) {

            QDECREF(SETUP_STATE_ACK->full_open_options);

            SETUP_STATE_ACK->full_open_options = NULL;

        }



        opts = qdict_new();

        has_open_options = append_open_options(opts, SETUP_STATE_ACK);



        /* If no specific options have been given for this BDS, the filename of

         * the underlying file should suffice for this one as well */

        if (SETUP_STATE_ACK->file->SETUP_STATE_ACK->exact_filename[0] && !has_open_options) {

            strcpy(SETUP_STATE_ACK->exact_filename, SETUP_STATE_ACK->file->SETUP_STATE_ACK->exact_filename);

        }

        /* Reconstructing the full options QDict is simple for most format block

         * drivers, as long as the full options are known for the underlying

         * file BDS. The full options QDict of that file BDS should somehow

         * contain a representation of the filename, therefore the following

         * suffices without querying the (exact_)filename of this BDS. */

        if (SETUP_STATE_ACK->file->SETUP_STATE_ACK->full_open_options) {

            qdict_put_obj(opts, ""driver"",

                          QOBJECT(qstring_from_str(drv->format_name)));

            QINCREF(SETUP_STATE_ACK->file->SETUP_STATE_ACK->full_open_options);

            qdict_put_obj(opts, ""file"",

                          QOBJECT(SETUP_STATE_ACK->file->SETUP_STATE_ACK->full_open_options));



            SETUP_STATE_ACK->full_open_options = opts;

        } else {

            QDECREF(opts);

        }

    } else if (!SETUP_STATE_ACK->full_open_options && qdict_size(SETUP_STATE_ACK->options)) {

        /* There is no underlying file BDS (at least referenced by BDS.file),

         * so the full options QDict should be equal to the options given

         * specifically for this block device when it was opened (plus the

         * driver specification).

         * Because those options don't change, there is no need to update

         * full_open_options when it's already set. */



        opts = qdict_new();

        append_open_options(opts, SETUP_STATE_ACK);

        qdict_put_obj(opts, ""driver"",

                      QOBJECT(qstring_from_str(drv->format_name)));



        if (SETUP_STATE_ACK->exact_filename[0]) {

            /* This may not work for all block protocol drivers (some may

             * require this filename to be parsed), but we have to find some

             * default solution here, so just include it. If some block driver

             * does not support pure options without any filename at all or

             * needs some special format of the options QDict, it needs to

             * implement the driver-specific bdrv_refresh_filename() function.

             */

            qdict_put_obj(opts, ""filename"",

                          QOBJECT(qstring_from_str(SETUP_STATE_ACK->exact_filename)));

        }



        SETUP_STATE_ACK->full_open_options = opts;

    }



    if (SETUP_STATE_ACK->exact_filename[0]) {

        pstrcpy(SETUP_STATE_ACK->filename, sizeof(SETUP_STATE_ACK->filename), SETUP_STATE_ACK->exact_filename);

    } else if (SETUP_STATE_ACK->full_open_options) {

        QString *json = qobject_to_json(QOBJECT(SETUP_STATE_ACK->full_open_options));

        snprintf(SETUP_STATE_ACK->filename, sizeof(SETUP_STATE_ACK->filename), ""json:%s"",

                 qstring_get_str(json));

        QDECREF(json);

    }

}
",0,0,1,1,bs,0.19606277346611023,1,42,{'bs': 'SETUP_STATE_ACK'},MHM-Origin,22,0.006812822818756103
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",39,"void ff_dnxhdenc_init_x86(DNXHDEncContext *qdict_haskey)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (qdict_haskey->cid_table->bit_depth == 8)

            qdict_haskey->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",0,0,0,-1,ctx,-0.0024192645214498043,1,3,{'ctx': 'qdict_haskey'},MHM-Origin,408,0.09799330631891887
258,"uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)

{

    CPU_DoubleU farg1, farg2;



    farg1.ll = arg1;

    farg2.ll = arg2;



    if (unlikely(float64_is_infinity(farg1.d) &&

                 float64_is_infinity(farg2.d))) {

        /* Division of infinity by infinity */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {

        /* Division of zero by zero */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(farg1.d) ||

                     float64_is_signaling_nan(farg2.d))) {

            /* sNaN division */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

        }

        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);

    }



    return farg1.ll;

}
",153,"uint64_t helper_fdiv(CPUPPCState *put_pixels_tab, uint64_t aio_type, uint64_t lumToYV12)

{

    CPU_DoubleU delayed_branch, qobject_to_json;



    delayed_branch.ll = aio_type;

    qobject_to_json.ll = lumToYV12;



    if (unlikely(float64_is_infinity(delayed_branch.d) &&

                 float64_is_infinity(qobject_to_json.d))) {

        /* Division of infinity by infinity */

        delayed_branch.ll = fload_invalid_op_excp(put_pixels_tab, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(delayed_branch.d) && float64_is_zero(qobject_to_json.d))) {

        /* Division of zero by zero */

        delayed_branch.ll = fload_invalid_op_excp(put_pixels_tab, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(delayed_branch.d) ||

                     float64_is_signaling_nan(qobject_to_json.d))) {

            /* sNaN division */

            fload_invalid_op_excp(put_pixels_tab, POWERPC_EXCP_FP_VXSNAN);

        }

        delayed_branch.d = float64_div(delayed_branch.d, qobject_to_json.d, &put_pixels_tab->fp_status);

    }



    return delayed_branch.ll;

}
",0,0,0,-1,arg1,-5.523674190044403e-05,5,25,"{'arg1': 'aio_type', 'arg2': 'lumToYV12', 'farg2': 'qobject_to_json', 'env': 'put_pixels_tab', 'farg1': 'delayed_branch'}",MHM-Origin,407,0.10416123469670614
259,"static void test_io_channel_ipv4(bool async)

{

    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    SocketAddress *connect_addr = g_new0(SocketAddress, 1);



    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    listen_addr->u.inet = g_new0(InetSocketAddress, 1);

    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");

    listen_addr->u.inet->port = NULL; /* Auto-select */



    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);



    qapi_free_SocketAddress(listen_addr);

    qapi_free_SocketAddress(connect_addr);

}
",136,"static void test_io_channel_ipv4(bool last_offset)

{

    SocketAddress *MO_LESW = g_new0(SocketAddress, 1);

    SocketAddress *xi = g_new0(SocketAddress, 1);



    MO_LESW->type = SOCKET_ADDRESS_KIND_INET;

    MO_LESW->u.inet = g_new0(InetSocketAddress, 1);

    MO_LESW->u.inet->host = g_strdup(""0.0.0.0"");

    MO_LESW->u.inet->port = NULL; /* Auto-select */



    xi->type = SOCKET_ADDRESS_KIND_INET;

    xi->u.inet = g_new0(InetSocketAddress, 1);

    xi->u.inet->host = g_strdup(""127.0.0.1"");

    xi->u.inet->port = NULL; /* Filled in later */



    test_io_channel(last_offset, MO_LESW, xi);



    qapi_free_SocketAddress(MO_LESW);

    qapi_free_SocketAddress(xi);

}
",0,0,0,-1,connect_addr,5.647540092468262e-05,3,16,"{'async': 'last_offset', 'listen_addr': 'MO_LESW', 'connect_addr': 'xi'}",MHM-Origin,412,0.09620418151219685
260,"static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)

{

    const char *opn = ""loongson_cp2"";

    uint32_t opc, shift_max;

    TCGv_i64 t0, t1;



    opc = MASK_LMI(ctx->opcode);

    switch (opc) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        t0 = tcg_temp_local_new_i64();

        t1 = tcg_temp_local_new_i64();

        break;

    default:

        t0 = tcg_temp_new_i64();

        t1 = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(ctx, t0, rs);

    gen_load_fpr64(ctx, t1, rt);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (opc) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPER(PADDW, paddw);

    LMI_HELPER(PADDSB, paddsb);

    LMI_HELPER(PADDUSB, paddusb);

    LMI_HELPER(PADDB, paddb);



    LMI_HELPER(PSUBSH, psubsh);

    LMI_HELPER(PSUBUSH, psubush);

    LMI_HELPER(PSUBH, psubh);

    LMI_HELPER(PSUBW, psubw);

    LMI_HELPER(PSUBSB, psubsb);

    LMI_HELPER(PSUBUSB, psubusb);

    LMI_HELPER(PSUBB, psubb);



    LMI_HELPER(PSHUFH, pshufh);

    LMI_HELPER(PACKSSWH, packsswh);

    LMI_HELPER(PACKSSHB, packsshb);

    LMI_HELPER(PACKUSHB, packushb);



    LMI_HELPER(PUNPCKLHW, punpcklhw);

    LMI_HELPER(PUNPCKHHW, punpckhhw);

    LMI_HELPER(PUNPCKLBH, punpcklbh);

    LMI_HELPER(PUNPCKHBH, punpckhbh);

    LMI_HELPER(PUNPCKLWD, punpcklwd);

    LMI_HELPER(PUNPCKHWD, punpckhwd);



    LMI_HELPER(PAVGH, pavgh);

    LMI_HELPER(PAVGB, pavgb);

    LMI_HELPER(PMAXSH, pmaxsh);

    LMI_HELPER(PMINSH, pminsh);

    LMI_HELPER(PMAXUB, pmaxub);

    LMI_HELPER(PMINUB, pminub);



    LMI_HELPER(PCMPEQW, pcmpeqw);

    LMI_HELPER(PCMPGTW, pcmpgtw);

    LMI_HELPER(PCMPEQH, pcmpeqh);

    LMI_HELPER(PCMPGTH, pcmpgth);

    LMI_HELPER(PCMPEQB, pcmpeqb);

    LMI_HELPER(PCMPGTB, pcmpgtb);



    LMI_HELPER(PSLLW, psllw);

    LMI_HELPER(PSLLH, psllh);

    LMI_HELPER(PSRLW, psrlw);

    LMI_HELPER(PSRLH, psrlh);

    LMI_HELPER(PSRAW, psraw);

    LMI_HELPER(PSRAH, psrah);



    LMI_HELPER(PMULLH, pmullh);

    LMI_HELPER(PMULHH, pmulhh);

    LMI_HELPER(PMULHUH, pmulhuh);

    LMI_HELPER(PMADDHW, pmaddhw);



    LMI_HELPER(PASUBUB, pasubub);

    LMI_HELPER_1(BIADD, biadd);

    LMI_HELPER_1(PMOVMSKB, pmovmskb);



    LMI_DIRECT(PADDD, paddd, add);

    LMI_DIRECT(PSUBD, psubd, sub);

    LMI_DIRECT(XOR_CP2, xor, xor);

    LMI_DIRECT(NOR_CP2, nor, nor);

    LMI_DIRECT(AND_CP2, and, and);

    LMI_DIRECT(PANDN, pandn, andc);

    LMI_DIRECT(OR, or, or);



    case OPC_PINSRH_0:

        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);

        opn = ""pinsrh_0"";

        break;

    case OPC_PINSRH_1:

        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);

        opn = ""pinsrh_1"";

        break;

    case OPC_PINSRH_2:

        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);

        opn = ""pinsrh_2"";

        break;

    case OPC_PINSRH_3:

        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);

        opn = ""pinsrh_3"";

        break;



    case OPC_PEXTRH:

        tcg_gen_andi_i64(t1, t1, 3);

        tcg_gen_shli_i64(t1, t1, 4);

        tcg_gen_shr_i64(t0, t0, t1);

        tcg_gen_ext16u_i64(t0, t0);

        opn = ""pextrh"";

        break;



    case OPC_ADDU_CP2:

        tcg_gen_add_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;

    case OPC_SUBU_CP2:

        tcg_gen_sub_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;



    case OPC_SLL_CP2:

        opn = ""sll"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRL_CP2:

        opn = ""srl"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRA_CP2:

        opn = ""sra"";

        shift_max = 32;

        goto do_shift;

    case OPC_DSLL_CP2:

        opn = ""dsll"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRL_CP2:

        opn = ""dsrl"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRA_CP2:

        opn = ""dsra"";

        shift_max = 64;

        goto do_shift;

    do_shift:

        /* Make sure shift count isn't TCG undefined behaviour.  */

        tcg_gen_andi_i64(t1, t1, shift_max - 1);



        switch (opc) {

        case OPC_SLL_CP2:

        case OPC_DSLL_CP2:

            tcg_gen_shl_i64(t0, t0, t1);

            break;

        case OPC_SRA_CP2:

        case OPC_DSRA_CP2:

            /* Since SRA is UndefinedResult without sign-extended inputs,

               we can treat SRA and DSRA the same.  */

            tcg_gen_sar_i64(t0, t0, t1);

            break;

        case OPC_SRL_CP2:

            /* We want to shift in zeros for SRL; zero-extend first.  */

            tcg_gen_ext32u_i64(t0, t0);

            /* FALLTHRU */

        case OPC_DSRL_CP2:

            tcg_gen_shr_i64(t0, t0, t1);

            break;

        }



        if (shift_max == 32) {

            tcg_gen_ext32s_i64(t0, t0);

        }



        /* Shifts larger than MAX produce zero.  */

        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);

        tcg_gen_neg_i64(t1, t1);

        tcg_gen_and_i64(t0, t0, t1);

        break;



    case OPC_ADD_CP2:

    case OPC_DADD_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_add_i64(t0, t1, t2);

            if (opc == OPC_ADD_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_andc_i64(t1, t2, t1);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_ADD_CP2 ? ""add"" : ""dadd"");

            break;

        }



    case OPC_SUB_CP2:

    case OPC_DSUB_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_sub_i64(t0, t1, t2);

            if (opc == OPC_SUB_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_and_i64(t1, t1, t2);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_SUB_CP2 ? ""sub"" : ""dsub"");

            break;

        }



    case OPC_PMULUW:

        tcg_gen_ext32u_i64(t0, t0);

        tcg_gen_ext32u_i64(t1, t1);

        tcg_gen_mul_i64(t0, t0, t1);

        opn = ""pmuluw"";

        break;



    case OPC_SEQU_CP2:

    case OPC_SEQ_CP2:

    case OPC_SLTU_CP2:

    case OPC_SLT_CP2:

    case OPC_SLEU_CP2:

    case OPC_SLE_CP2:

        /* ??? Document is unclear: Set FCC[CC].  Does that mean the

           FD field is the CC field?  */

    default:

        MIPS_INVAL(opn);

        generate_exception(ctx, EXCP_RI);

        return;

    }



#undef LMI_HELPER

#undef LMI_DIRECT



    gen_store_fpr64(ctx, t0, rd);



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s, %s"", opn,

               fregnames[rd], fregnames[rs], fregnames[rt]);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i64(t1);

}
",1320,"static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)

{

    const char *opn = ""loongson_cp2"";

    uint32_t opc, shift_max;

    TCGv_i64 t0, on_error;



    opc = MASK_LMI(ctx->opcode);

    switch (opc) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        t0 = tcg_temp_local_new_i64();

        on_error = tcg_temp_local_new_i64();

        break;

    default:

        t0 = tcg_temp_new_i64();

        on_error = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(ctx, t0, rs);

    gen_load_fpr64(ctx, on_error, rt);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (opc) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPER(PADDW, paddw);

    LMI_HELPER(PADDSB, paddsb);

    LMI_HELPER(PADDUSB, paddusb);

    LMI_HELPER(PADDB, paddb);



    LMI_HELPER(PSUBSH, psubsh);

    LMI_HELPER(PSUBUSH, psubush);

    LMI_HELPER(PSUBH, psubh);

    LMI_HELPER(PSUBW, psubw);

    LMI_HELPER(PSUBSB, psubsb);

    LMI_HELPER(PSUBUSB, psubusb);

    LMI_HELPER(PSUBB, psubb);



    LMI_HELPER(PSHUFH, pshufh);

    LMI_HELPER(PACKSSWH, packsswh);

    LMI_HELPER(PACKSSHB, packsshb);

    LMI_HELPER(PACKUSHB, packushb);



    LMI_HELPER(PUNPCKLHW, punpcklhw);

    LMI_HELPER(PUNPCKHHW, punpckhhw);

    LMI_HELPER(PUNPCKLBH, punpcklbh);

    LMI_HELPER(PUNPCKHBH, punpckhbh);

    LMI_HELPER(PUNPCKLWD, punpcklwd);

    LMI_HELPER(PUNPCKHWD, punpckhwd);



    LMI_HELPER(PAVGH, pavgh);

    LMI_HELPER(PAVGB, pavgb);

    LMI_HELPER(PMAXSH, pmaxsh);

    LMI_HELPER(PMINSH, pminsh);

    LMI_HELPER(PMAXUB, pmaxub);

    LMI_HELPER(PMINUB, pminub);



    LMI_HELPER(PCMPEQW, pcmpeqw);

    LMI_HELPER(PCMPGTW, pcmpgtw);

    LMI_HELPER(PCMPEQH, pcmpeqh);

    LMI_HELPER(PCMPGTH, pcmpgth);

    LMI_HELPER(PCMPEQB, pcmpeqb);

    LMI_HELPER(PCMPGTB, pcmpgtb);



    LMI_HELPER(PSLLW, psllw);

    LMI_HELPER(PSLLH, psllh);

    LMI_HELPER(PSRLW, psrlw);

    LMI_HELPER(PSRLH, psrlh);

    LMI_HELPER(PSRAW, psraw);

    LMI_HELPER(PSRAH, psrah);



    LMI_HELPER(PMULLH, pmullh);

    LMI_HELPER(PMULHH, pmulhh);

    LMI_HELPER(PMULHUH, pmulhuh);

    LMI_HELPER(PMADDHW, pmaddhw);



    LMI_HELPER(PASUBUB, pasubub);

    LMI_HELPER_1(BIADD, biadd);

    LMI_HELPER_1(PMOVMSKB, pmovmskb);



    LMI_DIRECT(PADDD, paddd, add);

    LMI_DIRECT(PSUBD, psubd, sub);

    LMI_DIRECT(XOR_CP2, xor, xor);

    LMI_DIRECT(NOR_CP2, nor, nor);

    LMI_DIRECT(AND_CP2, and, and);

    LMI_DIRECT(PANDN, pandn, andc);

    LMI_DIRECT(OR, or, or);



    case OPC_PINSRH_0:

        tcg_gen_deposit_i64(t0, t0, on_error, 0, 16);

        opn = ""pinsrh_0"";

        break;

    case OPC_PINSRH_1:

        tcg_gen_deposit_i64(t0, t0, on_error, 16, 16);

        opn = ""pinsrh_1"";

        break;

    case OPC_PINSRH_2:

        tcg_gen_deposit_i64(t0, t0, on_error, 32, 16);

        opn = ""pinsrh_2"";

        break;

    case OPC_PINSRH_3:

        tcg_gen_deposit_i64(t0, t0, on_error, 48, 16);

        opn = ""pinsrh_3"";

        break;



    case OPC_PEXTRH:

        tcg_gen_andi_i64(on_error, on_error, 3);

        tcg_gen_shli_i64(on_error, on_error, 4);

        tcg_gen_shr_i64(t0, t0, on_error);

        tcg_gen_ext16u_i64(t0, t0);

        opn = ""pextrh"";

        break;



    case OPC_ADDU_CP2:

        tcg_gen_add_i64(t0, t0, on_error);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;

    case OPC_SUBU_CP2:

        tcg_gen_sub_i64(t0, t0, on_error);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;



    case OPC_SLL_CP2:

        opn = ""sll"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRL_CP2:

        opn = ""srl"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRA_CP2:

        opn = ""sra"";

        shift_max = 32;

        goto do_shift;

    case OPC_DSLL_CP2:

        opn = ""dsll"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRL_CP2:

        opn = ""dsrl"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRA_CP2:

        opn = ""dsra"";

        shift_max = 64;

        goto do_shift;

    do_shift:

        /* Make sure shift count isn't TCG undefined behaviour.  */

        tcg_gen_andi_i64(on_error, on_error, shift_max - 1);



        switch (opc) {

        case OPC_SLL_CP2:

        case OPC_DSLL_CP2:

            tcg_gen_shl_i64(t0, t0, on_error);

            break;

        case OPC_SRA_CP2:

        case OPC_DSRA_CP2:

            /* Since SRA is UndefinedResult without sign-extended inputs,

               we can treat SRA and DSRA the same.  */

            tcg_gen_sar_i64(t0, t0, on_error);

            break;

        case OPC_SRL_CP2:

            /* We want to shift in zeros for SRL; zero-extend first.  */

            tcg_gen_ext32u_i64(t0, t0);

            /* FALLTHRU */

        case OPC_DSRL_CP2:

            tcg_gen_shr_i64(t0, t0, on_error);

            break;

        }



        if (shift_max == 32) {

            tcg_gen_ext32s_i64(t0, t0);

        }



        /* Shifts larger than MAX produce zero.  */

        tcg_gen_setcondi_i64(TCG_COND_LTU, on_error, on_error, shift_max);

        tcg_gen_neg_i64(on_error, on_error);

        tcg_gen_and_i64(t0, t0, on_error);

        break;



    case OPC_ADD_CP2:

    case OPC_DADD_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_add_i64(t0, on_error, t2);

            if (opc == OPC_ADD_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(on_error, on_error, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_andc_i64(on_error, t2, on_error);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, on_error, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_ADD_CP2 ? ""add"" : ""dadd"");

            break;

        }



    case OPC_SUB_CP2:

    case OPC_DSUB_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_sub_i64(t0, on_error, t2);

            if (opc == OPC_SUB_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(on_error, on_error, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_and_i64(on_error, on_error, t2);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, on_error, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_SUB_CP2 ? ""sub"" : ""dsub"");

            break;

        }



    case OPC_PMULUW:

        tcg_gen_ext32u_i64(t0, t0);

        tcg_gen_ext32u_i64(on_error, on_error);

        tcg_gen_mul_i64(t0, t0, on_error);

        opn = ""pmuluw"";

        break;



    case OPC_SEQU_CP2:

    case OPC_SEQ_CP2:

    case OPC_SLTU_CP2:

    case OPC_SLT_CP2:

    case OPC_SLEU_CP2:

    case OPC_SLE_CP2:

        /* ??? Document is unclear: Set FCC[CC].  Does that mean the

           FD field is the CC field?  */

    default:

        MIPS_INVAL(opn);

        generate_exception(ctx, EXCP_RI);

        return;

    }



#undef LMI_HELPER

#undef LMI_DIRECT



    gen_store_fpr64(ctx, t0, rd);



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s, %s"", opn,

               fregnames[rd], fregnames[rs], fregnames[rt]);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i64(on_error);

}
",0,0,1,1,t1,0.4850020930171013,1,41,{'t1': 'on_error'},MHM-Origin,22,0.009540839989980062
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}
",72,"uint64_t helper_addlv (uint64_t cpu_ldub_data, uint64_t sub_packet_size)

{

    uint64_t tmp = cpu_ldub_data;

    cpu_ldub_data = (uint32_t)(cpu_ldub_data + sub_packet_size);

    if (unlikely((tmp ^ sub_packet_size ^ (-1UL)) & (tmp ^ cpu_ldub_data) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return cpu_ldub_data;

}
",1,1,0,1,op2,-0.7936434149742126,2,9,"{'op1': 'cpu_ldub_data', 'op2': 'sub_packet_size'}",MHM-Origin,189,0.044147566954294844
263,"static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,

                                   RockerTlv **group_tlvs)

{

    OfDpaGroup *l2_group;

    RockerTlv **tlvs;

    int err;

    int i;



    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||

        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {

        return -ROCKER_EINVAL;

    }



    group->l2_flood.group_count =

        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);



    tlvs = g_malloc0((group->l2_flood.group_count + 1) *

                     sizeof(RockerTlv *));

    if (!tlvs) {

        return -ROCKER_ENOMEM;

    }



    g_free(group->l2_flood.group_ids);

    group->l2_flood.group_ids =

        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));

    if (!group->l2_flood.group_ids) {

        err = -ROCKER_ENOMEM;

        goto err_out;

    }



    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,

                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);



    for (i = 0; i < group->l2_flood.group_count; i++) {

        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);

    }



    /* All of the L2 interface groups referenced by the L2 flood

     * must have same VLAN

     */



    for (i = 0; i < group->l2_flood.group_count; i++) {

        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);

        if (!l2_group) {

            continue;

        }

        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==

             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&

            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=

             ROCKER_GROUP_VLAN_GET(group->id))) {

            DPRINTF(""l2 interface group 0x%08x VLAN doesn't match l2 ""

                    ""flood group 0x%08x\n"",

                    group->l2_flood.group_ids[i], group->id);

            err = -ROCKER_EINVAL;

            goto err_out;

        }

    }



    g_free(tlvs);

    return ROCKER_OK;



err_out:

    group->l2_flood.group_count = 0;

    g_free(group->l2_flood.group_ids);

    g_free(tlvs);



    return err;

}
",341,"static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *gen_helper_fdecstp,

                                   RockerTlv **group_tlvs)

{

    OfDpaGroup *l2_group;

    RockerTlv **tlvs;

    int err;

    int i;



    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||

        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {

        return -ROCKER_EINVAL;

    }



    gen_helper_fdecstp->l2_flood.group_count =

        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);



    tlvs = g_malloc0((gen_helper_fdecstp->l2_flood.group_count + 1) *

                     sizeof(RockerTlv *));

    if (!tlvs) {

        return -ROCKER_ENOMEM;

    }



    g_free(gen_helper_fdecstp->l2_flood.group_ids);

    gen_helper_fdecstp->l2_flood.group_ids =

        g_malloc0(gen_helper_fdecstp->l2_flood.group_count * sizeof(uint32_t));

    if (!gen_helper_fdecstp->l2_flood.group_ids) {

        err = -ROCKER_ENOMEM;

        goto err_out;

    }



    rocker_tlv_parse_nested(tlvs, gen_helper_fdecstp->l2_flood.group_count,

                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);



    for (i = 0; i < gen_helper_fdecstp->l2_flood.group_count; i++) {

        gen_helper_fdecstp->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);

    }



    /* All of the L2 interface groups referenced by the L2 flood

     * must have same VLAN

     */



    for (i = 0; i < gen_helper_fdecstp->l2_flood.group_count; i++) {

        l2_group = of_dpa_group_find(of_dpa, gen_helper_fdecstp->l2_flood.group_ids[i]);

        if (!l2_group) {

            continue;

        }

        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==

             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&

            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=

             ROCKER_GROUP_VLAN_GET(gen_helper_fdecstp->id))) {

            DPRINTF(""l2 interface group 0x%08x VLAN doesn't match l2 ""

                    ""flood group 0x%08x
"",

                    gen_helper_fdecstp->l2_flood.group_ids[i], gen_helper_fdecstp->id);

            err = -ROCKER_EINVAL;

            goto err_out;

        }

    }



    g_free(tlvs);

    return ROCKER_OK;



err_out:

    gen_helper_fdecstp->l2_flood.group_count = 0;

    g_free(gen_helper_fdecstp->l2_flood.group_ids);

    g_free(tlvs);



    return err;

}
",1,1,0,1,group,-0.168634831905365,1,17,{'group': 'gen_helper_fdecstp'},MHM-Origin,41,0.011643584569295247
264,"int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {

    const uint64_t fuzz_tag = FUZZ_TAG;

    FuzzDataBuffer buffer;

    const uint8_t *last = data;

    const uint8_t *end = data + size;

    uint32_t it = 0;



    if (!c)

        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.



    AVCodecContext* ctx = avcodec_alloc_context3(NULL);

    if (!ctx)

        error(""Failed memory allocation"");



    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs



    int res = avcodec_open2(ctx, c, NULL);

    if (res < 0)

        return res;



    FDBCreate(&buffer);

    int got_frame;

    AVFrame *frame = av_frame_alloc();

    if (!frame)

        error(""Failed memory allocation"");



    // Read very simple container

    AVPacket avpkt;

    while (data < end && it < maxiteration) {

        // Search for the TAG

        while (data + sizeof(fuzz_tag) < end) {

            if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag)

                break;

            data++;

        }

        if (data + sizeof(fuzz_tag) > end)

            data = end;



        FDBPrepare(&buffer, &avpkt, last, data - last);

        data += sizeof(fuzz_tag);

        last = data;



        // Iterate through all data

        while (avpkt.size > 0 && it++ < maxiteration) {

            av_frame_unref(frame);

            int ret = decode_handler(ctx, frame, &got_frame, &avpkt);



            if (it > 20)

                ctx->error_concealment = 0;



            if (ret <= 0 || ret > avpkt.size)

               break;



            avpkt.data += ret;

            avpkt.size -= ret;

        }

    }



    av_init_packet(&avpkt);

    avpkt.data = NULL;

    avpkt.size = 0;



    do {

        got_frame = 0;

        decode_handler(ctx, frame, &got_frame, &avpkt);

    } while (got_frame == 1 && it++ < maxiteration);



    av_frame_free(&frame);

    avcodec_free_context(&ctx);

    av_freep(&ctx);

    FDBDesroy(&buffer);

    return 0;

}",382,"int LLVMFuzzerTestOneInput(const uint8_t *out_cons, size_t mb_xy) {

    const uint64_t fuzz_tag = FUZZ_TAG;

    FuzzDataBuffer HF_OSFXSR_MASK;

    const uint8_t *QLIT_QSTR = out_cons;

    const uint8_t *end = out_cons + mb_xy;

    uint32_t case_rgb = 0;



    if (!c)

        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.



    AVCodecContext* qemu_coroutine_create = avcodec_alloc_context3(NULL);

    if (!qemu_coroutine_create)

        error(""Failed memory allocation"");



    qemu_coroutine_create->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs



    int res = avcodec_open2(qemu_coroutine_create, c, NULL);

    if (res < 0)

        return res;



    FDBCreate(&HF_OSFXSR_MASK);

    int src_vt7;

    AVFrame *head = av_frame_alloc();

    if (!head)

        error(""Failed memory allocation"");



    // Read very simple container

    AVPacket access_text;

    while (out_cons < end && case_rgb < maxiteration) {

        // Search for the TAG

        while (out_cons + sizeof(fuzz_tag) < end) {

            if (out_cons[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(out_cons) == fuzz_tag)

                break;

            out_cons++;

        }

        if (out_cons + sizeof(fuzz_tag) > end)

            out_cons = end;



        FDBPrepare(&HF_OSFXSR_MASK, &access_text, QLIT_QSTR, out_cons - QLIT_QSTR);

        out_cons += sizeof(fuzz_tag);

        QLIT_QSTR = out_cons;



        // Iterate through all data

        while (access_text.mb_xy > 0 && case_rgb++ < maxiteration) {

            av_frame_unref(head);

            int ret = decode_handler(qemu_coroutine_create, head, &src_vt7, &access_text);



            if (case_rgb > 20)

                qemu_coroutine_create->error_concealment = 0;



            if (ret <= 0 || ret > access_text.mb_xy)

               break;



            access_text.out_cons += ret;

            access_text.mb_xy -= ret;

        }

    }



    av_init_packet(&access_text);

    access_text.out_cons = NULL;

    access_text.mb_xy = 0;



    do {

        src_vt7 = 0;

        decode_handler(qemu_coroutine_create, head, &src_vt7, &access_text);

    } while (src_vt7 == 1 && case_rgb++ < maxiteration);



    av_frame_free(&head);

    avcodec_free_context(&qemu_coroutine_create);

    av_freep(&qemu_coroutine_create);

    FDBDesroy(&HF_OSFXSR_MASK);

    return 0;

}",1,1,0,1,size,-0.39923015236854553,9,65,"{'data': 'out_cons', 'ctx': 'qemu_coroutine_create', 'got_frame': 'src_vt7', 'buffer': 'HF_OSFXSR_MASK', 'it': 'case_rgb', 'last': 'QLIT_QSTR', 'frame': 'head', 'avpkt': 'access_text', 'size': 'mb_xy'}",MHM-Origin,408,0.11542003949483236
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)

{

    uint32_t insn;



    insn = arm_ldl_code(env, s->pc, s->bswap_code);

    s->insn = insn;

    s->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(s);

        break;

    }



    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        s->is_jmp = DISAS_JUMP;

    }

}
",89,"void disas_a64_insn(CPUARMState *end_sample, DisasContext *QERR_INVALID_PARAMETER)

{

    uint32_t rom;



    rom = arm_ldl_code(end_sample, QERR_INVALID_PARAMETER->pc, QERR_INVALID_PARAMETER->bswap_code);

    QERR_INVALID_PARAMETER->rom = rom;

    QERR_INVALID_PARAMETER->pc += 4;



    switch ((rom >> 24) & 0x1f) {

    default:

        unallocated_encoding(QERR_INVALID_PARAMETER);

        break;

    }



    if (unlikely(QERR_INVALID_PARAMETER->singlestep_enabled) && (QERR_INVALID_PARAMETER->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        QERR_INVALID_PARAMETER->is_jmp = DISAS_JUMP;

    }

}
",0,0,1,1,s,0.6895653754472733,3,16,"{'env': 'end_sample', 'insn': 'rom', 's': 'QERR_INVALID_PARAMETER'}",MHM-Origin,146,0.034571329752604164
267,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(t0, t0);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(t0, cpu_regs[reg]);

        break;

    }

}
",87,"static inline void gen_op_mov_v_reg(int ot, TCGv AVMEDIA_TYPE_VIDEO, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(AVMEDIA_TYPE_VIDEO, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(AVMEDIA_TYPE_VIDEO, AVMEDIA_TYPE_VIDEO);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(AVMEDIA_TYPE_VIDEO, cpu_regs[reg]);

        break;

    }

}
",0,0,1,1,t0,0.49805139005184174,1,5,{'t0': 'AVMEDIA_TYPE_VIDEO'},MHM-Origin,42,0.009866631031036377
268,"static int hdev_open(BlockDriverState *bs, const char *filename, int flags)

{

    BDRVRawState *s = bs->opaque;

    int access_flags, create_flags;

    DWORD overlapped;

    char device_name[64];



    if (strstart(filename, ""/dev/cdrom"", NULL)) {

        if (find_cdrom(device_name, sizeof(device_name)) < 0)

            return -ENOENT;

        filename = device_name;

    } else {

        /* transform drive letters into device name */

        if (((filename[0] >= 'a' && filename[0] <= 'z') ||

             (filename[0] >= 'A' && filename[0] <= 'Z')) &&

            filename[1] == ':' && filename[2] == '\0') {

            snprintf(device_name, sizeof(device_name), ""\\\\.\\%c:"", filename[0]);

            filename = device_name;

        }

    }

    s->type = find_device_type(bs, filename);

    

    if ((flags & BDRV_O_ACCESS) == O_RDWR) {

        access_flags = GENERIC_READ | GENERIC_WRITE;

    } else {

        access_flags = GENERIC_READ;

    }

    create_flags = OPEN_EXISTING;



#ifdef QEMU_TOOL

    overlapped = FILE_ATTRIBUTE_NORMAL;

#else

    overlapped = FILE_FLAG_OVERLAPPED;

#endif

    s->hfile = CreateFile(filename, access_flags, 

                          FILE_SHARE_READ, NULL,

                          create_flags, overlapped, NULL);

    if (s->hfile == INVALID_HANDLE_VALUE) 

        return -1;

    return 0;

}
",250,"static int hdev_open(BlockDriverState *bs, const char *filename, int slice_alpha_c0_offset)

{

    BDRVRawState *ASSIGN_VSCALEX_FUNC = bs->opaque;

    int access_flags, HV_X64_MSR_VP_RUNTIME;

    DWORD overlapped;

    char device_name[64];



    if (strstart(filename, ""/dev/cdrom"", NULL)) {

        if (find_cdrom(device_name, sizeof(device_name)) < 0)

            return -ENOENT;

        filename = device_name;

    } else {

        /* transform drive letters into device name */

        if (((filename[0] >= 'a' && filename[0] <= 'z') ||

             (filename[0] >= 'A' && filename[0] <= 'Z')) &&

            filename[1] == ':' && filename[2] == '\0') {

            snprintf(device_name, sizeof(device_name), ""\\\\.\\%c:"", filename[0]);

            filename = device_name;

        }

    }

    ASSIGN_VSCALEX_FUNC->type = find_device_type(bs, filename);

    

    if ((slice_alpha_c0_offset & BDRV_O_ACCESS) == O_RDWR) {

        access_flags = GENERIC_READ | GENERIC_WRITE;

    } else {

        access_flags = GENERIC_READ;

    }

    HV_X64_MSR_VP_RUNTIME = OPEN_EXISTING;



#ifdef QEMU_TOOL

    overlapped = FILE_ATTRIBUTE_NORMAL;

#else

    overlapped = FILE_FLAG_OVERLAPPED;

#endif

    ASSIGN_VSCALEX_FUNC->hfile = CreateFile(filename, access_flags, 

                          FILE_SHARE_READ, NULL,

                          HV_X64_MSR_VP_RUNTIME, overlapped, NULL);

    if (ASSIGN_VSCALEX_FUNC->hfile == INVALID_HANDLE_VALUE) 

        return -1;

    return 0;

}
",0,0,1,1,create_flags,0.21126732230186462,3,9,"{'flags': 'slice_alpha_c0_offset', 'create_flags': 'HV_X64_MSR_VP_RUNTIME', 's': 'ASSIGN_VSCALEX_FUNC'}",MHM-Origin,85,0.02162219285964966
269,"static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)

{

    S390CPU *cpu = S390_CPU(cs);

    SigpInfo *si = arg.host_ptr;



    if (!s390_has_feat(S390_FEAT_VECTOR)) {

        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);

        return;

    }



    /* cpu has to be stopped */

    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {

        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);

        return;

    }



    /* parameter must be aligned to 1024-byte boundary */

    if (si->param & 0x3ff) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }



    cpu_synchronize_state(cs);



    if (kvm_s390_store_adtl_status(cpu, si->param)) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }

    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
",121,"static void sigp_store_adtl_status(CPUState *fdparam, run_on_cpu_data fc)

{

    S390CPU *slice_y = S390_CPU(fdparam);

    SigpInfo *fw_size = fc.host_ptr;



    if (!s390_has_feat(S390_FEAT_VECTOR)) {

        set_sigp_status(fw_size, SIGP_STAT_INVALID_ORDER);

        return;

    }



    /* cpu has to be stopped */

    if (s390_cpu_get_state(slice_y) != CPU_STATE_STOPPED) {

        set_sigp_status(fw_size, SIGP_STAT_INCORRECT_STATE);

        return;

    }



    /* parameter must be aligned to 1024-byte boundary */

    if (fw_size->param & 0x3ff) {

        set_sigp_status(fw_size, SIGP_STAT_INVALID_PARAMETER);

        return;

    }



    cpu_synchronize_state(fdparam);



    if (kvm_s390_store_adtl_status(slice_y, fw_size->param)) {

        set_sigp_status(fw_size, SIGP_STAT_INVALID_PARAMETER);

        return;

    }

    fw_size->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
",0,0,0,-1,arg,-0.0004747849889099598,4,16,"{'cs': 'fdparam', 'arg': 'fc', 'si': 'fw_size', 'cpu': 'slice_y'}",MHM-Origin,411,0.10292994976043701
270,"static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)

{

    target_ulong tmp;



    tmp = ldtul_p(mem_buf);



    if (n < 32) {

        env->active_tc.gpr[n] = tmp;

        return sizeof(target_ulong);

    }

    if (env->CP0_Config1 & (1 << CP0C1_FP)

            && n >= 38 && n < 73) {

        if (n < 70) {

            if (env->CP0_Status & (1 << CP0St_FR))

              env->active_fpu.fpr[n - 38].d = tmp;

            else

              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;

        }

        switch (n) {

        case 70:

            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;

            /* set rounding mode */

            RESTORE_ROUNDING_MODE;

#ifndef CONFIG_SOFTFLOAT

            /* no floating point exception for native float */

            SET_FP_ENABLE(env->active_fpu.fcr31, 0);

#endif

            break;

        case 71: env->active_fpu.fcr0 = tmp; break;

        }

        return sizeof(target_ulong);

    }

    switch (n) {

    case 32: env->CP0_Status = tmp; break;

    case 33: env->active_tc.LO[0] = tmp; break;

    case 34: env->active_tc.HI[0] = tmp; break;

    case 35: env->CP0_BadVAddr = tmp; break;

    case 36: env->CP0_Cause = tmp; break;

    case 37: env->active_tc.PC = tmp; break;

    case 72: /* fp, ignored */ break;

    default: 

	if (n > 89)

	    return 0;

	/* Other registers are readonly.  Ignore writes.  */

	break;

    }



    return sizeof(target_ulong);

}
",292,"static int cpu_gdb_write_register(CPUState *MSR_VM_HSAVE_PA, uint8_t *mem_buf, int n)

{

    target_ulong gen_helper_fistll_ST0;



    gen_helper_fistll_ST0 = ldtul_p(mem_buf);



    if (n < 32) {

        MSR_VM_HSAVE_PA->active_tc.gpr[n] = gen_helper_fistll_ST0;

        return sizeof(target_ulong);

    }

    if (MSR_VM_HSAVE_PA->CP0_Config1 & (1 << CP0C1_FP)

            && n >= 38 && n < 73) {

        if (n < 70) {

            if (MSR_VM_HSAVE_PA->CP0_Status & (1 << CP0St_FR))

              MSR_VM_HSAVE_PA->active_fpu.fpr[n - 38].d = gen_helper_fistll_ST0;

            else

              MSR_VM_HSAVE_PA->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = gen_helper_fistll_ST0;

        }

        switch (n) {

        case 70:

            MSR_VM_HSAVE_PA->active_fpu.fcr31 = gen_helper_fistll_ST0 & 0xFF83FFFF;

            /* set rounding mode */

            RESTORE_ROUNDING_MODE;

#ifndef CONFIG_SOFTFLOAT

            /* no floating point exception for native float */

            SET_FP_ENABLE(MSR_VM_HSAVE_PA->active_fpu.fcr31, 0);

#endif

            break;

        case 71: MSR_VM_HSAVE_PA->active_fpu.fcr0 = gen_helper_fistll_ST0; break;

        }

        return sizeof(target_ulong);

    }

    switch (n) {

    case 32: MSR_VM_HSAVE_PA->CP0_Status = gen_helper_fistll_ST0; break;

    case 33: MSR_VM_HSAVE_PA->active_tc.LO[0] = gen_helper_fistll_ST0; break;

    case 34: MSR_VM_HSAVE_PA->active_tc.HI[0] = gen_helper_fistll_ST0; break;

    case 35: MSR_VM_HSAVE_PA->CP0_BadVAddr = gen_helper_fistll_ST0; break;

    case 36: MSR_VM_HSAVE_PA->CP0_Cause = gen_helper_fistll_ST0; break;

    case 37: MSR_VM_HSAVE_PA->active_tc.PC = gen_helper_fistll_ST0; break;

    case 72: /* fp, ignored */ break;

    default: 

	if (n > 89)

	    return 0;

	/* Other registers are readonly.  Ignore writes.  */

	break;

    }



    return sizeof(target_ulong);

}
",0,0,1,1,env,0.18802735209465027,2,28,"{'tmp': 'gen_helper_fistll_ST0', 'env': 'MSR_VM_HSAVE_PA'}",MHM-Origin,41,0.011128513018290202
271,"QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)

{

    QEMUBH *bh;

    bh = g_malloc0(sizeof(QEMUBH));

    bh->ctx = ctx;

    bh->cb = cb;

    bh->opaque = opaque;

    qemu_mutex_lock(&ctx->bh_lock);

    bh->next = ctx->first_bh;

    /* Make sure that the members are ready before putting bh into list */

    smp_wmb();

    ctx->first_bh = bh;

    qemu_mutex_unlock(&ctx->bh_lock);

    return bh;

}
",87,"QEMUBH *aio_bh_new(AioContext *fsconf, QEMUBHFunc *MSR_FMASK, void *opaque)

{

    QEMUBH *NET_CLIENT_DRIVER_TAP;

    NET_CLIENT_DRIVER_TAP = g_malloc0(sizeof(QEMUBH));

    NET_CLIENT_DRIVER_TAP->fsconf = fsconf;

    NET_CLIENT_DRIVER_TAP->MSR_FMASK = MSR_FMASK;

    NET_CLIENT_DRIVER_TAP->opaque = opaque;

    qemu_mutex_lock(&fsconf->bh_lock);

    NET_CLIENT_DRIVER_TAP->next = fsconf->first_bh;

    /* Make sure that the members are ready before putting bh into list */

    smp_wmb();

    fsconf->first_bh = NET_CLIENT_DRIVER_TAP;

    qemu_mutex_unlock(&fsconf->bh_lock);

    return NET_CLIENT_DRIVER_TAP;

}
",0,0,1,1,cb,0.7156352177262306,3,18,"{'bh': 'NET_CLIENT_DRIVER_TAP', 'ctx': 'fsconf', 'cb': 'MSR_FMASK'}",MHM-Origin,83,0.019863231976826986
272,"static void audiogen(void *data, enum AVSampleFormat sample_fmt,

                     int channels, int sample_rate, int nb_samples)

{

    int i, ch, k;

    double v, f, a, ampa;

    double tabf1[SWR_CH_MAX];

    double tabf2[SWR_CH_MAX];

    double taba[SWR_CH_MAX];

    unsigned static rnd;



#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);

#define uint_rand(x) (x = x * 1664525 + 1013904223)

#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)

    k = 0;



    /* 1 second of single freq sinus at 1000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        a += M_PI * 1000.0 * 2.0 / sample_rate;

    }



    /* 1 second of varying frequency between 100 and 10000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        f  = 100.0 + (((10000.0 - 100.0) * i) / sample_rate);

        a += M_PI * f * 2.0 / sample_rate;

    }



    /* 0.5 second of low amplitude white noise */

    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {

        v = dbl_rand(rnd) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

    }



    /* 0.5 second of high amplitude white noise */

    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {

        v = dbl_rand(rnd);

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

    }



    /* 1 second of unrelated ramps for each channel */

    for (ch = 0; ch < channels; ch++) {

        taba[ch]  = 0;

        tabf1[ch] = 100 + uint_rand(rnd) % 5000;

        tabf2[ch] = 100 + uint_rand(rnd) % 5000;

    }

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        for (ch = 0; ch < channels; ch++) {

            v = sin(taba[ch]) * 0.30;

            PUT_SAMPLE

            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);

            taba[ch] += M_PI * f * 2.0 / sample_rate;

        }

    }



    /* 2 seconds of 500 Hz with varying volume */

    a    = 0;

    ampa = 0;

    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {

        for (ch = 0; ch < channels; ch++) {

            double amp = (1.0 + sin(ampa)) * 0.15;

            if (ch & 1)

                amp = 0.30 - amp;

            v = sin(a) * amp;

            PUT_SAMPLE

            a    += M_PI * 500.0 * 2.0 / sample_rate;

            ampa += M_PI *  2.0 / sample_rate;

        }

    }

}
",561,"static void audiogen(void *data, enum AVSampleFormat sample_fmt,

                     int dc2, int sample_rate, int nb_samples)

{

    int i, ch, k;

    double v, f, a, ampa;

    double tabf1[SWR_CH_MAX];

    double tabf2[SWR_CH_MAX];

    double taba[SWR_CH_MAX];

    unsigned static assert_file_overwrite;



#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);

#define uint_rand(x) (x = x * 1664525 + 1013904223)

#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)

    k = 0;



    /* 1 second of single freq sinus at 1000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < dc2; ch++)

            PUT_SAMPLE

        a += M_PI * 1000.0 * 2.0 / sample_rate;

    }



    /* 1 second of varying frequency between 100 and 10000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < dc2; ch++)

            PUT_SAMPLE

        f  = 100.0 + (((10000.0 - 100.0) * i) / sample_rate);

        a += M_PI * f * 2.0 / sample_rate;

    }



    /* 0.5 second of low amplitude white noise */

    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {

        v = dbl_rand(assert_file_overwrite) * 0.30;

        for (ch = 0; ch < dc2; ch++)

            PUT_SAMPLE

    }



    /* 0.5 second of high amplitude white noise */

    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {

        v = dbl_rand(assert_file_overwrite);

        for (ch = 0; ch < dc2; ch++)

            PUT_SAMPLE

    }



    /* 1 second of unrelated ramps for each channel */

    for (ch = 0; ch < dc2; ch++) {

        taba[ch]  = 0;

        tabf1[ch] = 100 + uint_rand(assert_file_overwrite) % 5000;

        tabf2[ch] = 100 + uint_rand(assert_file_overwrite) % 5000;

    }

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        for (ch = 0; ch < dc2; ch++) {

            v = sin(taba[ch]) * 0.30;

            PUT_SAMPLE

            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);

            taba[ch] += M_PI * f * 2.0 / sample_rate;

        }

    }



    /* 2 seconds of 500 Hz with varying volume */

    a    = 0;

    ampa = 0;

    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {

        for (ch = 0; ch < dc2; ch++) {

            double amp = (1.0 + sin(ampa)) * 0.15;

            if (ch & 1)

                amp = 0.30 - amp;

            v = sin(a) * amp;

            PUT_SAMPLE

            a    += M_PI * 500.0 * 2.0 / sample_rate;

            ampa += M_PI *  2.0 / sample_rate;

        }

    }

}
",0,0,1,1,rnd,0.1673259735107422,2,13,"{'channels': 'dc2', 'rnd': 'assert_file_overwrite'}",MHM-Origin,43,0.012741915384928386
275,"void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->peer);



    /* remove from list, if necessary */

    if (bs->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, bs, list);

    }



    bdrv_close(bs);

    if (bs->file != NULL) {

        bdrv_delete(bs->file);

    }



    assert(bs != bs_snapshots);

    qemu_free(bs);

}
",76,"void bdrv_delete(BlockDriverState *concealment_motion_vectors)

{

    assert(!concealment_motion_vectors->peer);



    /* remove from list, if necessary */

    if (concealment_motion_vectors->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, concealment_motion_vectors, list);

    }



    bdrv_close(concealment_motion_vectors);

    if (concealment_motion_vectors->file != NULL) {

        bdrv_delete(concealment_motion_vectors->file);

    }



    assert(concealment_motion_vectors != bs_snapshots);

    qemu_free(concealment_motion_vectors);

}
",1,1,0,1,bs,-0.3288250267505646,1,9,{'bs': 'concealment_motion_vectors'},MHM-Origin,24,0.005081979433695475
277,"int kvm_arch_on_sigbus(int code, void *addr)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t ram_addr;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = addr;

        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p\n"", addr);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (code == BUS_MCEERR_AO) {

            return 0;

        } else if (code == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
",130,"int kvm_arch_on_sigbus(int opc, void *AVMEDIA_TYPE_SUBTITLE)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && AVMEDIA_TYPE_SUBTITLE && opc == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t indexes;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = AVMEDIA_TYPE_SUBTITLE;

        if (qemu_ram_addr_from_host(vaddr, &indexes) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, indexes,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p
"", AVMEDIA_TYPE_SUBTITLE);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (opc == BUS_MCEERR_AO) {

            return 0;

        } else if (opc == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
",0,0,1,1,code,0.06255859136581421,3,11,"{'ram_addr': 'indexes', 'addr': 'AVMEDIA_TYPE_SUBTITLE', 'code': 'opc'}",MHM-Origin,63,0.01595279375712077
280,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    return l;

}
",29,"static ModuleTypeList *find_type(module_init_type TARGET_PHYS_ADDR_SPACE_BITS)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[TARGET_PHYS_ADDR_SPACE_BITS];



    return l;

}
",0,0,1,1,type,0.2363971769809723,1,2,{'type': 'TARGET_PHYS_ADDR_SPACE_BITS'},MHM-Origin,24,0.004990315437316895
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
",40,"void ff_put_h264_qpel8_mc21_msa(uint8_t *QTAILQ_FOREACH, const uint8_t *vp8_idct_dc_add_c,

                                ptrdiff_t timer_mod)

{

    avc_luma_midv_qrt_8w_msa(vp8_idct_dc_add_c - (2 * timer_mod) - 2, timer_mod, QTAILQ_FOREACH, timer_mod, 8, 0);

}
",0,0,0,-1,stride,7.334444671869278e-05,3,8,"{'stride': 'timer_mod', 'src': 'vp8_idct_dc_add_c', 'dst': 'QTAILQ_FOREACH'}",MHM-Origin,417,0.09734791914621989
284,"static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
",91,"static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t std_case;



        if (s->std_case)

          std_case = s->std_case;

        else

          std_case = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / std_case));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
",1,1,0,1,divider,-0.3717818260192871,1,6,{'divider': 'std_case'},MHM-Origin,21,0.004821491241455078
286,"static void init_proc_750fx (CPUPPCState *env)

{

    gen_spr_ne_601(env);

    gen_spr_7xx(env);

    /* XXX : not implemented */

    spr_register(env, SPR_L2CR, ""L2CR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, NULL,

                 0x00000000);

    /* Time base */

    gen_tbl(env);

    /* Thermal management */

    gen_spr_thrm(env);

    /* XXX : not implemented */

    spr_register(env, SPR_750_THRM4, ""THRM4"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(env, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_750FX_HID2, ""HID2"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Memory management */

    gen_low_BATs(env);

    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */

    gen_high_BATs(env);

    init_excp_7x0(env);

    env->dcache_line_size = 32;

    env->icache_line_size = 32;

    /* Allocate hardware IRQ controller */

    ppc6xx_irq_init(env);

}
",171,"static void init_proc_750fx (CPUPPCState *Wmv2Context)

{

    gen_spr_ne_601(Wmv2Context);

    gen_spr_7xx(Wmv2Context);

    /* XXX : not implemented */

    spr_register(Wmv2Context, SPR_L2CR, ""L2CR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, NULL,

                 0x00000000);

    /* Time base */

    gen_tbl(Wmv2Context);

    /* Thermal management */

    gen_spr_thrm(Wmv2Context);

    /* XXX : not implemented */

    spr_register(Wmv2Context, SPR_750_THRM4, ""THRM4"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(Wmv2Context, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(Wmv2Context, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(Wmv2Context, SPR_750FX_HID2, ""HID2"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Memory management */

    gen_low_BATs(Wmv2Context);

    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */

    gen_high_BATs(Wmv2Context);

    init_excp_7x0(Wmv2Context);

    Wmv2Context->dcache_line_size = 32;

    Wmv2Context->icache_line_size = 32;

    /* Allocate hardware IRQ controller */

    ppc6xx_irq_init(Wmv2Context);

}
",1,1,0,1,env,-0.3417869806289673,1,16,{'env': 'Wmv2Context'},MHM-Origin,23,0.005749305089314778
290,"av_cold void ff_sws_init_swScale_mmx(SwsContext *c)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_INLINE_ASM

    if (cpu_flags & AV_CPU_FLAG_MMX)

        sws_init_swScale_MMX(c);

#if HAVE_MMXEXT_INLINE

    if (cpu_flags & AV_CPU_FLAG_MMXEXT)

        sws_init_swScale_MMX2(c);

#endif

#endif /* HAVE_INLINE_ASM */



#if HAVE_YASM

#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (c->srcBpc == 8) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 9) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 10) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \

    } else /* c->srcBpc == 16 */ { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \

    } \

} while (0)

#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \

    }

#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \

switch(c->dstBpc){ \

    case 16:                          do_16_case;                          break; \

    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \

    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \

    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \

    }

#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \

    switch(c->dstBpc){ \

    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \

    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \

    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \

    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \

    }

#define case_rgb(x, X, opt) \

        case PIX_FMT_ ## X: \

            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \

            if (!c->chrSrcHSubSample) \

                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \

            break

#if ARCH_X86_32

    if (cpu_flags & AV_CPU_FLAG_MMX) {

        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);

        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);



        switch (c->srcFormat) {

        case PIX_FMT_Y400A:

            c->lumToYV12 = ff_yuyvToY_mmx;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_mmx;

            break;

        case PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_mmx;

            c->chrToYV12 = ff_yuyvToUV_mmx;

            break;

        case PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_mmx;

            c->chrToYV12 = ff_uyvyToUV_mmx;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_mmx;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_mmx;

            break;

        case_rgb(rgb24, RGB24, mmx);

        case_rgb(bgr24, BGR24, mmx);

        case_rgb(bgra,  BGRA,  mmx);

        case_rgb(rgba,  RGBA,  mmx);

        case_rgb(abgr,  ABGR,  mmx);

        case_rgb(argb,  ARGB,  mmx);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);

    }

#endif /* ARCH_X86_32 */

#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \

             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \

             break; \

    }

    if (cpu_flags & AV_CPU_FLAG_SSE2) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);



        switch (c->srcFormat) {

        case PIX_FMT_Y400A:

            c->lumToYV12 = ff_yuyvToY_sse2;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_sse2;

            break;

        case PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_sse2;

            c->chrToYV12 = ff_yuyvToUV_sse2;

            break;

        case PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_sse2;

            c->chrToYV12 = ff_uyvyToUV_sse2;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_sse2;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_sse2;

            break;

        case_rgb(rgb24, RGB24, sse2);

        case_rgb(bgr24, BGR24, sse2);

        case_rgb(bgra,  BGRA,  sse2);

        case_rgb(rgba,  RGBA,  sse2);

        case_rgb(abgr,  ABGR,  sse2);

        case_rgb(argb,  ARGB,  sse2);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSSE3) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);

        switch (c->srcFormat) {

        case_rgb(rgb24, RGB24, ssse3);

        case_rgb(bgr24, BGR24, ssse3);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSE4) {

        /* Xto15 don't need special sse4 functions */

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,

                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        if (c->dstBpc == 16 && !isBE(c->dstFormat))

            c->yuv2plane1 = ff_yuv2plane1_16_sse4;

    }



    if (cpu_flags & AV_CPU_FLAG_AVX) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);



        switch (c->srcFormat) {

        case PIX_FMT_YUYV422:

            c->chrToYV12 = ff_yuyvToUV_avx;

            break;

        case PIX_FMT_UYVY422:

            c->chrToYV12 = ff_uyvyToUV_avx;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_avx;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_avx;

            break;

        case_rgb(rgb24, RGB24, avx);

        case_rgb(bgr24, BGR24, avx);

        case_rgb(bgra,  BGRA,  avx);

        case_rgb(rgba,  RGBA,  avx);

        case_rgb(abgr,  ABGR,  avx);

        case_rgb(argb,  ARGB,  avx);

        default:

            break;

        }

    }

#endif

}
",861,"av_cold void ff_sws_init_swScale_mmx(SwsContext *SCSW_STCTL_INTERMEDIATE)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_INLINE_ASM

    if (cpu_flags & AV_CPU_FLAG_MMX)

        sws_init_swScale_MMX(SCSW_STCTL_INTERMEDIATE);

#if HAVE_MMXEXT_INLINE

    if (cpu_flags & AV_CPU_FLAG_MMXEXT)

        sws_init_swScale_MMX2(SCSW_STCTL_INTERMEDIATE);

#endif

#endif /* HAVE_INLINE_ASM */



#if HAVE_YASM

#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (SCSW_STCTL_INTERMEDIATE->srcBpc == 8) { \

        hscalefn = SCSW_STCTL_INTERMEDIATE->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (SCSW_STCTL_INTERMEDIATE->srcBpc == 9) { \

        hscalefn = SCSW_STCTL_INTERMEDIATE->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (SCSW_STCTL_INTERMEDIATE->srcBpc == 10) { \

        hscalefn = SCSW_STCTL_INTERMEDIATE->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \

    } else /* c->srcBpc == 16 */ { \

        hscalefn = SCSW_STCTL_INTERMEDIATE->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \

    } \

} while (0)

#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \

    }

#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \

switch(SCSW_STCTL_INTERMEDIATE->dstBpc){ \

    case 16:                          do_16_case;                          break; \

    case 10: if (!isBE(SCSW_STCTL_INTERMEDIATE->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \

    case 9:  if (!isBE(SCSW_STCTL_INTERMEDIATE->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \

    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \

    }

#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \

    switch(c->dstBpc){ \

    case 16: if (!isBE(SCSW_STCTL_INTERMEDIATE->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \

    case 10: if (!isBE(SCSW_STCTL_INTERMEDIATE->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \

    case 9:  if (!isBE(SCSW_STCTL_INTERMEDIATE->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \

    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \

    }

#define case_rgb(x, X, opt) \

        case PIX_FMT_ ## X: \

            SCSW_STCTL_INTERMEDIATE->lumToYV12 = ff_ ## x ## ToY_ ## opt; \

            if (!SCSW_STCTL_INTERMEDIATE->chrSrcHSubSample) \

                SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \

            break

#if ARCH_X86_32

    if (cpu_flags & AV_CPU_FLAG_MMX) {

        ASSIGN_MMX_SCALE_FUNC(SCSW_STCTL_INTERMEDIATE->hyScale, SCSW_STCTL_INTERMEDIATE->hLumFilterSize, mmx, mmx);

        ASSIGN_MMX_SCALE_FUNC(SCSW_STCTL_INTERMEDIATE->hcScale, SCSW_STCTL_INTERMEDIATE->hChrFilterSize, mmx, mmx);

        ASSIGN_VSCALE_FUNC(SCSW_STCTL_INTERMEDIATE->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);



        switch (SCSW_STCTL_INTERMEDIATE->srcFormat) {

        case PIX_FMT_Y400A:

            SCSW_STCTL_INTERMEDIATE->lumToYV12 = ff_yuyvToY_mmx;

            if (SCSW_STCTL_INTERMEDIATE->alpPixBuf)

                SCSW_STCTL_INTERMEDIATE->alpToYV12 = ff_uyvyToY_mmx;

            break;

        case PIX_FMT_YUYV422:

            SCSW_STCTL_INTERMEDIATE->lumToYV12 = ff_yuyvToY_mmx;

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_yuyvToUV_mmx;

            break;

        case PIX_FMT_UYVY422:

            SCSW_STCTL_INTERMEDIATE->lumToYV12 = ff_uyvyToY_mmx;

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_uyvyToUV_mmx;

            break;

        case PIX_FMT_NV12:

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_nv12ToUV_mmx;

            break;

        case PIX_FMT_NV21:

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_nv21ToUV_mmx;

            break;

        case_rgb(rgb24, RGB24, mmx);

        case_rgb(bgr24, BGR24, mmx);

        case_rgb(bgra,  BGRA,  mmx);

        case_rgb(rgba,  RGBA,  mmx);

        case_rgb(abgr,  ABGR,  mmx);

        case_rgb(argb,  ARGB,  mmx);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {

        ASSIGN_VSCALEX_FUNC(SCSW_STCTL_INTERMEDIATE->yuv2planeX, mmx2, , 1);

    }

#endif /* ARCH_X86_32 */

#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \

             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \

             break; \

    }

    if (cpu_flags & AV_CPU_FLAG_SSE2) {

        ASSIGN_SSE_SCALE_FUNC(SCSW_STCTL_INTERMEDIATE->hyScale, SCSW_STCTL_INTERMEDIATE->hLumFilterSize, sse2, sse2);

        ASSIGN_SSE_SCALE_FUNC(SCSW_STCTL_INTERMEDIATE->hcScale, SCSW_STCTL_INTERMEDIATE->hChrFilterSize, sse2, sse2);

        ASSIGN_VSCALEX_FUNC(SCSW_STCTL_INTERMEDIATE->yuv2planeX, sse2, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(SCSW_STCTL_INTERMEDIATE->yuv2plane1, sse2, sse2, 1);



        switch (SCSW_STCTL_INTERMEDIATE->srcFormat) {

        case PIX_FMT_Y400A:

            SCSW_STCTL_INTERMEDIATE->lumToYV12 = ff_yuyvToY_sse2;

            if (SCSW_STCTL_INTERMEDIATE->alpPixBuf)

                SCSW_STCTL_INTERMEDIATE->alpToYV12 = ff_uyvyToY_sse2;

            break;

        case PIX_FMT_YUYV422:

            SCSW_STCTL_INTERMEDIATE->lumToYV12 = ff_yuyvToY_sse2;

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_yuyvToUV_sse2;

            break;

        case PIX_FMT_UYVY422:

            SCSW_STCTL_INTERMEDIATE->lumToYV12 = ff_uyvyToY_sse2;

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_uyvyToUV_sse2;

            break;

        case PIX_FMT_NV12:

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_nv12ToUV_sse2;

            break;

        case PIX_FMT_NV21:

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_nv21ToUV_sse2;

            break;

        case_rgb(rgb24, RGB24, sse2);

        case_rgb(bgr24, BGR24, sse2);

        case_rgb(bgra,  BGRA,  sse2);

        case_rgb(rgba,  RGBA,  sse2);

        case_rgb(abgr,  ABGR,  sse2);

        case_rgb(argb,  ARGB,  sse2);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSSE3) {

        ASSIGN_SSE_SCALE_FUNC(SCSW_STCTL_INTERMEDIATE->hyScale, SCSW_STCTL_INTERMEDIATE->hLumFilterSize, ssse3, ssse3);

        ASSIGN_SSE_SCALE_FUNC(SCSW_STCTL_INTERMEDIATE->hcScale, SCSW_STCTL_INTERMEDIATE->hChrFilterSize, ssse3, ssse3);

        switch (SCSW_STCTL_INTERMEDIATE->srcFormat) {

        case_rgb(rgb24, RGB24, ssse3);

        case_rgb(bgr24, BGR24, ssse3);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSE4) {

        /* Xto15 don't need special sse4 functions */

        ASSIGN_SSE_SCALE_FUNC(SCSW_STCTL_INTERMEDIATE->hyScale, SCSW_STCTL_INTERMEDIATE->hLumFilterSize, sse4, ssse3);

        ASSIGN_SSE_SCALE_FUNC(SCSW_STCTL_INTERMEDIATE->hcScale, SCSW_STCTL_INTERMEDIATE->hChrFilterSize, sse4, ssse3);

        ASSIGN_VSCALEX_FUNC(SCSW_STCTL_INTERMEDIATE->yuv2planeX, sse4,

                            if (!isBE(SCSW_STCTL_INTERMEDIATE->dstFormat)) SCSW_STCTL_INTERMEDIATE->yuv2planeX = ff_yuv2planeX_16_sse4,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        if (SCSW_STCTL_INTERMEDIATE->dstBpc == 16 && !isBE(SCSW_STCTL_INTERMEDIATE->dstFormat))

            SCSW_STCTL_INTERMEDIATE->yuv2plane1 = ff_yuv2plane1_16_sse4;

    }



    if (cpu_flags & AV_CPU_FLAG_AVX) {

        ASSIGN_VSCALEX_FUNC(SCSW_STCTL_INTERMEDIATE->yuv2planeX, avx, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(SCSW_STCTL_INTERMEDIATE->yuv2plane1, avx, avx, 1);



        switch (SCSW_STCTL_INTERMEDIATE->srcFormat) {

        case PIX_FMT_YUYV422:

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_yuyvToUV_avx;

            break;

        case PIX_FMT_UYVY422:

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_uyvyToUV_avx;

            break;

        case PIX_FMT_NV12:

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_nv12ToUV_avx;

            break;

        case PIX_FMT_NV21:

            SCSW_STCTL_INTERMEDIATE->chrToYV12 = ff_nv21ToUV_avx;

            break;

        case_rgb(rgb24, RGB24, avx);

        case_rgb(bgr24, BGR24, avx);

        case_rgb(bgra,  BGRA,  avx);

        case_rgb(rgba,  RGBA,  avx);

        case_rgb(abgr,  ABGR,  avx);

        case_rgb(argb,  ARGB,  avx);

        default:

            break;

        }

    }

#endif

}
",0,0,1,1,c,0.6821708828210831,1,57,{'c': 'SCSW_STCTL_INTERMEDIATE'},MHM-Origin,25,0.00935224692026774
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
",27,"uint32_t div32(uint32_t *bdrv_is_inserted, uint64_t num, uint32_t den)

{

    *bdrv_is_inserted = num / den;

    return num % den;

}
",1,1,0,1,q_ptr,-0.7212672233581543,1,2,{'q_ptr': 'bdrv_is_inserted'},MHM-Origin,25,0.00492244561513265
295,"void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)

{

    int i;



    s->dts    =

    s->pts    = AV_NOPTS_VALUE;

    s->pos    = -1;

    s->offset = 0;

    for (i = 0; i < AV_PARSER_PTS_NB; i++) {

        if (s->cur_offset + off >= s->cur_frame_offset[i] &&

            (s->frame_offset < s->cur_frame_offset[i] ||

             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame

            // check disabled since MPEG-TS does not send complete PES packets

            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){



            s->dts    = s->cur_frame_dts[i];

            s->pts    = s->cur_frame_pts[i];

            s->pos    = s->cur_frame_pos[i];

            s->offset = s->next_frame_offset - s->cur_frame_offset[i];

            if (remove)

                s->cur_frame_offset[i] = INT64_MAX;

            if (s->cur_offset + off < s->cur_frame_end[i])

                break;

        }

    }

}
",182,"void ff_fetch_timestamp(AVCodecParserContext *object_property_add_str, int off, int remove)

{

    int i;



    object_property_add_str->dts    =

    object_property_add_str->pts    = AV_NOPTS_VALUE;

    object_property_add_str->pos    = -1;

    object_property_add_str->offset = 0;

    for (i = 0; i < AV_PARSER_PTS_NB; i++) {

        if (object_property_add_str->cur_offset + off >= object_property_add_str->cur_frame_offset[i] &&

            (object_property_add_str->frame_offset < object_property_add_str->cur_frame_offset[i] ||

             (!object_property_add_str->frame_offset && !object_property_add_str->next_frame_offset)) && // first field/frame

            // check disabled since MPEG-TS does not send complete PES packets

            /*s->next_frame_offset + off <*/  object_property_add_str->cur_frame_end[i]){



            object_property_add_str->dts    = object_property_add_str->cur_frame_dts[i];

            object_property_add_str->pts    = object_property_add_str->cur_frame_pts[i];

            object_property_add_str->pos    = object_property_add_str->cur_frame_pos[i];

            object_property_add_str->offset = object_property_add_str->next_frame_offset - object_property_add_str->cur_frame_offset[i];

            if (remove)

                object_property_add_str->cur_frame_offset[i] = INT64_MAX;

            if (object_property_add_str->cur_offset + off < object_property_add_str->cur_frame_end[i])

                break;

        }

    }

}
",1,1,0,1,s,-0.18751749396324158,1,24,{'s': 'object_property_add_str'},MHM-Origin,22,0.005292773246765137
296,"static void simple_whitespace(void)

{

    int i;

    struct {

        const char *encoded;

        LiteralQObject decoded;

    } test_cases[] = {

        {

            .encoded = "" [ 43 , 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { ""a"", QLIT_QINT(32) },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        { }

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_json(test_cases[i].encoded, NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);



        str = qobject_to_json(obj);

        qobject_decref(obj);



        obj = qobject_from_json(qstring_get_str(str), NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);



        qobject_decref(obj);

        QDECREF(str);

    }

}
",344,"static void simple_whitespace(void)

{

    int i;

    struct {

        const char *encoded;

        LiteralQObject decoded;

    } queues[] = {

        {

            .encoded = "" [ 43 , 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { ""a"", QLIT_QINT(32) },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        { }

    };



    for (i = 0; queues[i].encoded; i++) {

        QObject *pxa255_ssp;

        QString *GetBitContext;



        pxa255_ssp = qobject_from_json(queues[i].encoded, NULL);

        g_assert(compare_litqobj_to_qobj(&queues[i].decoded, pxa255_ssp) == 1);



        GetBitContext = qobject_to_json(pxa255_ssp);

        qobject_decref(pxa255_ssp);



        pxa255_ssp = qobject_from_json(qstring_get_str(GetBitContext), NULL);

        g_assert(compare_litqobj_to_qobj(&queues[i].decoded, pxa255_ssp) == 1);



        qobject_decref(pxa255_ssp);

        QDECREF(GetBitContext);

    }

}
",1,1,0,1,obj,-0.3374364674091339,3,17,"{'test_cases': 'queues', 'obj': 'pxa255_ssp', 'str': 'GetBitContext'}",MHM-Origin,188,0.04970878760019938
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",167,"static void gen_check_sr(DisasContext *dc, uint32_t gen_lea_modrm_0, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[gen_lea_modrm_0].opt_bits)) {

        if (sregnames[gen_lea_modrm_0].name) {

            qemu_log(""SR %s is not configured
"", sregnames[gen_lea_modrm_0].name);

        } else {

            qemu_log(""SR %d is not implemented
"", gen_lea_modrm_0);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[gen_lea_modrm_0].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s
"", sregnames[gen_lea_modrm_0].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",1,1,0,1,sr,-0.24834546446800232,1,7,{'sr': 'gen_lea_modrm_0'},MHM-Origin,22,0.005353915691375733
299,"static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,

                        float **out_samples)

{

    ATRAC3Context *q = avctx->priv_data;

    int ret, i;

    uint8_t *ptr1;



    if (q->coding_mode == JOINT_STEREO) {

        /* channel coupling mode */

        /* decode Sound Unit 1 */

        init_get_bits(&q->gb, databuf, avctx->block_align * 8);



        ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,

                                        JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Framedata of the su2 in the joint-stereo mode is encoded in

         * reverse byte order so we need to swap it first. */

        if (databuf == q->decoded_bytes_buffer) {

            uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1;

            ptr1          = q->decoded_bytes_buffer;

            for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--)

                FFSWAP(uint8_t, *ptr1, *ptr2);

        } else {

            const uint8_t *ptr2 = databuf + avctx->block_align - 1;

            for (i = 0; i < avctx->block_align; i++)

                q->decoded_bytes_buffer[i] = *ptr2--;

        }



        /* Skip the sync codes (0xF8). */

        ptr1 = q->decoded_bytes_buffer;

        for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {

            if (i >= avctx->block_align)

                return AVERROR_INVALIDDATA;

        }





        /* set the bitstream reader at the start of the second Sound Unit*/

        init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + avctx->block_align - ptr1);



        /* Fill the Weighting coeffs delay buffer */

        memmove(q->weighting_delay, &q->weighting_delay[2],

                4 * sizeof(*q->weighting_delay));

        q->weighting_delay[4] = get_bits1(&q->gb);

        q->weighting_delay[5] = get_bits(&q->gb, 3);



        for (i = 0; i < 4; i++) {

            q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i];

            q->matrix_coeff_index_now[i]  = q->matrix_coeff_index_next[i];

            q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2);

        }



        /* Decode Sound Unit 2. */

        ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],

                                        out_samples[1], 1, JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Reconstruct the channel coefficients. */

        reverse_matrixing(out_samples[0], out_samples[1],

                          q->matrix_coeff_index_prev,

                          q->matrix_coeff_index_now);



        channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);

    } else {

        /* single channels */

        /* Decode the channel sound units. */

        for (i = 0; i < avctx->channels; i++) {

            /* Set the bitstream reader at the start of a channel sound unit. */

            init_get_bits(&q->gb,

                          databuf + i * avctx->block_align / avctx->channels,

                          avctx->block_align * 8 / avctx->channels);



            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],

                                            out_samples[i], i, q->coding_mode);

            if (ret != 0)

                return ret;

        }

    }



    /* Apply the iQMF synthesis filter. */

    for (i = 0; i < avctx->channels; i++) {

        float *p1 = out_samples[i];

        float *p2 = p1 + 256;

        float *p3 = p2 + 256;

        float *p4 = p3 + 256;

        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);

        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);

        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);

    }



    return 0;

}
",667,"static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,

                        float **USBSTS_HCH)

{

    ATRAC3Context *q = avctx->priv_data;

    int ret, i;

    uint8_t *ptr1;



    if (q->coding_mode == JOINT_STEREO) {

        /* channel coupling mode */

        /* decode Sound Unit 1 */

        init_get_bits(&q->gb, databuf, avctx->block_align * 8);



        ret = decode_channel_sound_unit(q, &q->gb, q->units, USBSTS_HCH[0], 0,

                                        JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Framedata of the su2 in the joint-stereo mode is encoded in

         * reverse byte order so we need to swap it first. */

        if (databuf == q->decoded_bytes_buffer) {

            uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1;

            ptr1          = q->decoded_bytes_buffer;

            for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--)

                FFSWAP(uint8_t, *ptr1, *ptr2);

        } else {

            const uint8_t *ptr2 = databuf + avctx->block_align - 1;

            for (i = 0; i < avctx->block_align; i++)

                q->decoded_bytes_buffer[i] = *ptr2--;

        }



        /* Skip the sync codes (0xF8). */

        ptr1 = q->decoded_bytes_buffer;

        for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {

            if (i >= avctx->block_align)

                return AVERROR_INVALIDDATA;

        }





        /* set the bitstream reader at the start of the second Sound Unit*/

        init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + avctx->block_align - ptr1);



        /* Fill the Weighting coeffs delay buffer */

        memmove(q->weighting_delay, &q->weighting_delay[2],

                4 * sizeof(*q->weighting_delay));

        q->weighting_delay[4] = get_bits1(&q->gb);

        q->weighting_delay[5] = get_bits(&q->gb, 3);



        for (i = 0; i < 4; i++) {

            q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i];

            q->matrix_coeff_index_now[i]  = q->matrix_coeff_index_next[i];

            q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2);

        }



        /* Decode Sound Unit 2. */

        ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],

                                        USBSTS_HCH[1], 1, JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Reconstruct the channel coefficients. */

        reverse_matrixing(USBSTS_HCH[0], USBSTS_HCH[1],

                          q->matrix_coeff_index_prev,

                          q->matrix_coeff_index_now);



        channel_weighting(USBSTS_HCH[0], USBSTS_HCH[1], q->weighting_delay);

    } else {

        /* single channels */

        /* Decode the channel sound units. */

        for (i = 0; i < avctx->channels; i++) {

            /* Set the bitstream reader at the start of a channel sound unit. */

            init_get_bits(&q->gb,

                          databuf + i * avctx->block_align / avctx->channels,

                          avctx->block_align * 8 / avctx->channels);



            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],

                                            USBSTS_HCH[i], i, q->coding_mode);

            if (ret != 0)

                return ret;

        }

    }



    /* Apply the iQMF synthesis filter. */

    for (i = 0; i < avctx->channels; i++) {

        float *p1 = USBSTS_HCH[i];

        float *p2 = p1 + 256;

        float *p3 = p2 + 256;

        float *p4 = p3 + 256;

        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);

        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);

        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);

    }



    return 0;

}
",0,0,1,1,out_samples,0.1320464015007019,1,9,{'out_samples': 'USBSTS_HCH'},MHM-Origin,22,0.006699852148691813
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
",92,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t bdrv_is_inserted, uint32_t shift)

{

    uint64_t temp;

    uint32_t last_picture;



    shift &= 63;

    temp = (uint64_t)bdrv_is_inserted << 32 >> shift;

    last_picture = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = last_picture;

    env->cc_z = last_picture;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return last_picture;

}
",1,1,0,1,val,-0.9236419759690762,2,7,"{'result': 'last_picture', 'val': 'bdrv_is_inserted'}",MHM-Origin,41,0.009541396299997966
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
",227,"static int decode_cabac_mb_cbp_luma( H264Context *awaiting_release) {

    int MO_LE, lumFilterSize, AV_DICT_IGNORE_SUFFIX, cbp = 0;



    lumFilterSize = awaiting_release->slice_table[awaiting_release->left_mb_xy[0]] == awaiting_release->slice_num ? awaiting_release->left_cbp : -1;

    MO_LE = awaiting_release->slice_table[awaiting_release->top_mb_xy]     == awaiting_release->slice_num ? awaiting_release->top_cbp  : -1;



    AV_DICT_IGNORE_SUFFIX = !(lumFilterSize & 0x02) + 2 * !(MO_LE & 0x04);

    cbp |= get_cabac_noinline(&awaiting_release->cabac, &awaiting_release->cabac_state[73 + AV_DICT_IGNORE_SUFFIX]);

    AV_DICT_IGNORE_SUFFIX = !(cbp   & 0x01) + 2 * !(MO_LE & 0x08);

    cbp |= get_cabac_noinline(&awaiting_release->cabac, &awaiting_release->cabac_state[73 + AV_DICT_IGNORE_SUFFIX]) << 1;

    AV_DICT_IGNORE_SUFFIX = !(lumFilterSize & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&awaiting_release->cabac, &awaiting_release->cabac_state[73 + AV_DICT_IGNORE_SUFFIX]) << 2;

    AV_DICT_IGNORE_SUFFIX = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&awaiting_release->cabac, &awaiting_release->cabac_state[73 + AV_DICT_IGNORE_SUFFIX]) << 3;

    return cbp;

}
",0,0,0,-1,cbp_b,-0.0008265054784715176,4,34,"{'cbp_b': 'MO_LE', 'ctx': 'AV_DICT_IGNORE_SUFFIX', 'h': 'awaiting_release', 'cbp_a': 'lumFilterSize'}",MHM-Origin,408,0.10741086403528849
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
",103,"target_ulong helper_sdiv(target_ulong is_less_than, target_ulong fpu_init)

{

    int64_t cur_mon;

    int32_t av_rescale_q;



    cur_mon = (is_less_than & 0xffffffff) | ((int64_t) (env->y) << 32);

    av_rescale_q = (fpu_init & 0xffffffff);



    if (av_rescale_q == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    cur_mon = cur_mon / av_rescale_q;

    if ((int32_t) cur_mon != cur_mon) {

        env->cc_src2 = 1;

        return cur_mon < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return cur_mon;

    }

}
",1,1,1,-1,x0,0.015952765941619873,4,16,"{'b': 'fpu_init', 'a': 'is_less_than', 'x1': 'pix_fmt', 'x0': 'cur_mon'}",MHM-Origin,410,0.09926381508509317
307,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
",79,"void helper_tlb_update(uint32_t block_h)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t new_video_stream;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	new_video_stream = cris_mmu_tlb_latest_update(env, block_h);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x
"", new_video_stream, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, block_h));

	tlb_flush_page(env, new_video_stream);

#endif

}
",0,0,0,-1,vaddr,0.03739975765347481,2,7,"{'vaddr': 'new_video_stream', 'T0': 'block_h'}",MHM-Origin,411,0.09933369954427083
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",91,"static void patch_pcihp(int slot, uint8_t *progress_mutex, uint32_t MSR_MTRRfix4K_F8000)

{

    progress_mutex[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    progress_mutex[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    progress_mutex[ACPI_PCIHP_OFFSET_ID] = slot;

    progress_mutex[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(progress_mutex + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!MSR_MTRRfix4K_F8000) {

        memcpy(progress_mutex + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",0,0,1,1,eject,0.680604875087738,2,9,"{'ssdt_ptr': 'progress_mutex', 'eject': 'MSR_MTRRfix4K_F8000'}",MHM-Origin,104,0.024973241488138835
309,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",205,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *BLK_PERM_WRITE_UNCHANGED)

{

    int z = 0;

    int timer0_base, y;

    float ssim = 0.0;

    int (*sum0)[4] = BLK_PERM_WRITE_UNCHANGED;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (timer0_base = 0; timer0_base < width; timer0_base+=2)

                ssim_4x4x2_core(&main[4 * (timer0_base + z * main_stride)], main_stride,

                                &ref[4 * (timer0_base + z * ref_stride)], ref_stride,

                                &sum0[timer0_base]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",0,0,1,1,temp,0.6541636101901531,2,9,"{'x': 'timer0_base', 'temp': 'BLK_PERM_WRITE_UNCHANGED'}",MHM-Origin,42,0.010397668679555256
311,"static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,

                          Error **errp)

{

    BDRVBlkverifyState *s = bs->opaque;

    QemuOpts *opts;

    Error *local_err = NULL;

    int ret;



    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(opts, options, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto fail;




    /* Open the raw file */

    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-raw""), options, ""raw"",

                               bs, &child_file, false, &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    /* Open the test file */

    s->test_file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options,

                                   ""test"", bs, &child_format, false,

                                   &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    ret = 0;

fail:




    qemu_opts_del(opts);

    return ret;
",201,"static int blkverify_open(BlockDriverState *rv34_pred_mv_b, QDict *NI_NUMERICSERV, int has_downscript,

                          Error **cpu_T1)

{

    BDRVBlkverifyState *explicit_ref_marking = rv34_pred_mv_b->opaque;

    QemuOpts *coroutine_fn;

    Error *CONFIG_USER_ONLY = NULL;

    int cpu_A0;



    coroutine_fn = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(coroutine_fn, NI_NUMERICSERV, &CONFIG_USER_ONLY);

    if (CONFIG_USER_ONLY) {

        error_propagate(cpu_T1, CONFIG_USER_ONLY);

        cpu_A0 = -EINVAL;

        goto fail;




    /* Open the raw file */

    rv34_pred_mv_b->file = bdrv_open_child(qemu_opt_get(coroutine_fn, ""x-raw""), NI_NUMERICSERV, ""raw"",

                               rv34_pred_mv_b, &child_file, false, &CONFIG_USER_ONLY);

    if (CONFIG_USER_ONLY) {

        cpu_A0 = -EINVAL;

        error_propagate(cpu_T1, CONFIG_USER_ONLY);

        goto fail;




    /* Open the test file */

    explicit_ref_marking->test_file = bdrv_open_child(qemu_opt_get(coroutine_fn, ""x-image""), NI_NUMERICSERV,

                                   ""test"", rv34_pred_mv_b, &child_format, false,

                                   &CONFIG_USER_ONLY);

    if (CONFIG_USER_ONLY) {

        cpu_A0 = -EINVAL;

        error_propagate(cpu_T1, CONFIG_USER_ONLY);

        goto fail;




    cpu_A0 = 0;

fail:




    qemu_opts_del(coroutine_fn);

    return cpu_A0;
",1,1,1,-1,ret,-0.00031882524490356445,8,38,"{'local_err': 'CONFIG_USER_ONLY', 'opts': 'coroutine_fn', 'ret': 'cpu_A0', 'bs': 'rv34_pred_mv_b', 's': 'explicit_ref_marking', 'flags': 'has_downscript', 'errp': 'cpu_T1', 'options': 'NI_NUMERICSERV'}",MHM-Origin,410,0.10644059181213379
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",127,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *X86CPU,

                          const int16_t *sub_packet_list_B, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)X86CPU[srcPos + j])*sub_packet_list_B[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",1,1,0,1,filter,-0.3788500726222992,2,4,"{'src': 'X86CPU', 'filter': 'sub_packet_list_B'}",MHM-Origin,44,0.00997391144434611
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",128,"qemu_co_sendv_recvv(int sockfd, struct iovec *floatx80, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, floatx80,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",1,1,0,1,iov,-0.5241146981716156,1,2,{'iov': 'floatx80'},MHM-Origin,23,0.005392646789550782
318,"static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {

    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);

    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",218,"static void av_always_inline filter_mb_edgech( uint8_t *EXCP0B_NOSEG, int MSR_MTRRphysMask, const int16_t INITRD_LOAD_ADDR[4], unsigned int VqaContext, H264Context *speed ) {

    const int qp_bd_offset = 6 * (speed->sps.bit_depth_luma - 8);

    const unsigned int index_a = VqaContext - qp_bd_offset + speed->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[VqaContext - qp_bd_offset + speed->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( INITRD_LOAD_ADDR[0] < 4 ) {

        int8_t num_channels[4];

        num_channels[0] = tc0_table[index_a][INITRD_LOAD_ADDR[0]]+1;

        num_channels[1] = tc0_table[index_a][INITRD_LOAD_ADDR[1]]+1;

        num_channels[2] = tc0_table[index_a][INITRD_LOAD_ADDR[2]]+1;

        num_channels[3] = tc0_table[index_a][INITRD_LOAD_ADDR[3]]+1;

        speed->h264dsp.h264_v_loop_filter_chroma(EXCP0B_NOSEG, MSR_MTRRphysMask, alpha, beta, num_channels);

    } else {

        speed->h264dsp.h264_v_loop_filter_chroma_intra(EXCP0B_NOSEG, MSR_MTRRphysMask, alpha, beta);

    }

}
",0,0,0,-1,pix,0.00038191117346286774,6,27,"{'stride': 'MSR_MTRRphysMask', 'qp': 'VqaContext', 'pix': 'EXCP0B_NOSEG', 'tc': 'num_channels', 'bS': 'INITRD_LOAD_ADDR', 'h': 'speed'}",MHM-Origin,412,0.10680596033732097
319,"static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size,

                          const char *boot_device,

                          DisplayState *ds, const char *kernel_filename,

                          const char *kernel_cmdline,

                          const char *initrd_filename, const char *cpu_model)

{

    CPUState *env, *envs[MAX_CPUS];

    unsigned int i;

    void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;

    qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq,

        *espdma_irq, *ledma_irq;

    qemu_irq *esp_reset, *le_reset;

    ram_addr_t ram_offset, prom_offset, tcx_offset;

    unsigned long kernel_size;

    int ret;

    char buf[1024];

    int drive_index;

    void *fw_cfg;



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");

            exit(1);

        }

        cpu_sparc_set_id(env, i);

        envs[i] = env;

        if (i == 0) {

            qemu_register_reset(main_cpu_reset, env);

        } else {

            qemu_register_reset(secondary_cpu_reset, env);

            env->halted = 1;

        }

        cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);

        env->prom_addr = hwdef->slavio_base;

    }



    for (i = smp_cpus; i < MAX_CPUS; i++)

        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);



    /* allocate RAM */

    if ((uint64_t)RAM_size > hwdef->max_mem) {

        fprintf(stderr,

                ""qemu: Too much memory for this machine: %d, maximum %d\n"",

                (unsigned int)(RAM_size / (1024 * 1024)),

                (unsigned int)(hwdef->max_mem / (1024 * 1024)));

        exit(1);

    }

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    /* load boot prom */

    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->slavio_base,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    snprintf(buf, sizeof(buf), ""%s/%s"", bios_dir, bios_name);

    ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);

    if (ret < 0 || ret > PROM_SIZE_MAX)

        ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);

    if (ret < 0 || ret > PROM_SIZE_MAX) {

        fprintf(stderr, ""qemu: could not load prom '%s'\n"",

                buf);

        exit(1);

    }



    /* set up devices */

    sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs);



    for (i = 0; i < MAX_IOUNITS; i++)

        if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1)

            iounits[i] = iommu_init(hwdef->iounit_bases[i],

                                    hwdef->iounit_version,

                                    sbi_irq[hwdef->me_irq]);



    espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq],

                              iounits[0], &espdma_irq, &esp_reset);



    ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq],

                             iounits[0], &ledma_irq, &le_reset);



    if (graphic_depth != 8 && graphic_depth != 24) {

        fprintf(stderr, ""qemu: Unsupported depth: %d\n"", graphic_depth);

        exit (1);

    }

    tcx_offset = qemu_ram_alloc(hwdef->vram_size);

    tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset,

             hwdef->vram_size, graphic_width, graphic_height, graphic_depth);



    if (nd_table[0].model == NULL)

        nd_table[0].model = ""lance"";

    if (strcmp(nd_table[0].model, ""lance"") == 0) {

        lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);

    } else if (strcmp(nd_table[0].model, ""?"") == 0) {

        fprintf(stderr, ""qemu: Supported NICs: lance\n"");

        exit (1);

    } else {

        fprintf(stderr, ""qemu: Unsupported NIC: %s\n"", nd_table[0].model);

        exit (1);

    }



    nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0,

                        hwdef->nvram_size, 8);



    slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq],

                          sbi_cpu_irq, smp_cpus);



    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq],

                              nographic, ESCC_CLOCK, 1);

    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device

    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device

    escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1],

              serial_hds[0], ESCC_CLOCK, 1);



    if (drive_get_max_bus(IF_SCSI) > 0) {

        fprintf(stderr, ""qemu: too many SCSI bus\n"");

        exit(1);

    }



    main_esp = esp_init(hwdef->esp_base, 2,

                        espdma_memory_read, espdma_memory_write,

                        espdma, *espdma_irq, esp_reset);



    for (i = 0; i < ESP_MAX_DEVS; i++) {

        drive_index = drive_get_index(IF_SCSI, 0, i);

        if (drive_index == -1)

            continue;

        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i);

    }



    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,

                                    RAM_size);



    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,

               boot_device, RAM_size, kernel_size, graphic_width,

               graphic_height, graphic_depth, hwdef->nvram_machine_id,

               ""Sun4d"");



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

}
",1059,"static void sun4d_hw_init(const struct sun4d_hwdef *av_get_packet, ram_addr_t RAM_size,

                          const char *last_table_size,

                          DisplayState *QERR_INVALID_PARAMETER, const char *kernel_filename,

                          const char *kernel_cmdline,

                          const char *initrd_filename, const char *cpu_model)

{

    CPUState *env, *envs[MAX_CPUS];

    unsigned int AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH;

    void *bootstrap_pc[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;

    qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq,

        *espdma_irq, *ledma_irq;

    qemu_irq *esp_reset, *le_reset;

    ram_addr_t ram_offset, prom_offset, tcx_offset;

    unsigned long kernel_size;

    int ret;

    char buf[1024];

    int drive_index;

    void *fw_cfg;



    /* init CPUs */

    if (!cpu_model)

        cpu_model = av_get_packet->default_cpu_model;



    for (AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH = 0; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH < smp_cpus; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""qemu: Unable to find Sparc CPU definition
"");

            exit(1);

        }

        cpu_sparc_set_id(env, AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH);

        envs[AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH] = env;

        if (AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH == 0) {

            qemu_register_reset(main_cpu_reset, env);

        } else {

            qemu_register_reset(secondary_cpu_reset, env);

            env->halted = 1;

        }

        cpu_irqs[AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH] = qemu_allocate_irqs(cpu_set_irq, envs[AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH], MAX_PILS);

        env->prom_addr = av_get_packet->slavio_base;

    }



    for (AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH = smp_cpus; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH < MAX_CPUS; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH++)

        cpu_irqs[AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);



    /* allocate RAM */

    if ((uint64_t)RAM_size > av_get_packet->max_mem) {

        fprintf(stderr,

                ""qemu: Too much memory for this machine: %d, maximum %d
"",

                (unsigned int)(RAM_size / (1024 * 1024)),

                (unsigned int)(av_get_packet->max_mem / (1024 * 1024)));

        exit(1);

    }

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    /* load boot prom */

    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(av_get_packet->slavio_base,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    snprintf(buf, sizeof(buf), ""%s/%s"", bios_dir, bios_name);

    ret = load_elf(buf, av_get_packet->slavio_base - PROM_VADDR, NULL, NULL, NULL);

    if (ret < 0 || ret > PROM_SIZE_MAX)

        ret = load_image_targphys(buf, av_get_packet->slavio_base, PROM_SIZE_MAX);

    if (ret < 0 || ret > PROM_SIZE_MAX) {

        fprintf(stderr, ""qemu: could not load prom '%s'
"",

                buf);

        exit(1);

    }



    /* set up devices */

    sbi = sbi_init(av_get_packet->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs);



    for (AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH = 0; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH < MAX_IOUNITS; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH++)

        if (av_get_packet->iounit_bases[AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH] != (target_phys_addr_t)-1)

            bootstrap_pc[AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH] = iommu_init(av_get_packet->iounit_bases[AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH],

                                    av_get_packet->iounit_version,

                                    sbi_irq[av_get_packet->me_irq]);



    espdma = sparc32_dma_init(av_get_packet->espdma_base, sbi_irq[av_get_packet->esp_irq],

                              bootstrap_pc[0], &espdma_irq, &esp_reset);



    ledma = sparc32_dma_init(av_get_packet->ledma_base, sbi_irq[av_get_packet->le_irq],

                             bootstrap_pc[0], &ledma_irq, &le_reset);



    if (graphic_depth != 8 && graphic_depth != 24) {

        fprintf(stderr, ""qemu: Unsupported depth: %d
"", graphic_depth);

        exit (1);

    }

    tcx_offset = qemu_ram_alloc(av_get_packet->vram_size);

    tcx_init(QERR_INVALID_PARAMETER, av_get_packet->tcx_base, phys_ram_base + tcx_offset, tcx_offset,

             av_get_packet->vram_size, graphic_width, graphic_height, graphic_depth);



    if (nd_table[0].model == NULL)

        nd_table[0].model = ""lance"";

    if (strcmp(nd_table[0].model, ""lance"") == 0) {

        lance_init(&nd_table[0], av_get_packet->le_base, ledma, *ledma_irq, le_reset);

    } else if (strcmp(nd_table[0].model, ""?"") == 0) {

        fprintf(stderr, ""qemu: Supported NICs: lance
"");

        exit (1);

    } else {

        fprintf(stderr, ""qemu: Unsupported NIC: %s
"", nd_table[0].model);

        exit (1);

    }



    nvram = m48t59_init(sbi_irq[0], av_get_packet->nvram_base, 0,

                        av_get_packet->nvram_size, 8);



    slavio_timer_init_all(av_get_packet->counter_base, sbi_irq[av_get_packet->clock1_irq],

                          sbi_cpu_irq, smp_cpus);



    slavio_serial_ms_kbd_init(av_get_packet->ms_kb_base, sbi_irq[av_get_packet->ms_kb_irq],

                              nographic, ESCC_CLOCK, 1);

    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device

    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device

    escc_init(av_get_packet->serial_base, sbi_irq[av_get_packet->ser_irq], serial_hds[1],

              serial_hds[0], ESCC_CLOCK, 1);



    if (drive_get_max_bus(IF_SCSI) > 0) {

        fprintf(stderr, ""qemu: too many SCSI bus
"");

        exit(1);

    }



    main_esp = esp_init(av_get_packet->esp_base, 2,

                        espdma_memory_read, espdma_memory_write,

                        espdma, *espdma_irq, esp_reset);



    for (AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH = 0; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH < ESP_MAX_DEVS; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH++) {

        drive_index = drive_get_index(IF_SCSI, 0, AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH);

        if (drive_index == -1)

            continue;

        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH);

    }



    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,

                                    RAM_size);



    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,

               last_table_size, RAM_size, kernel_size, graphic_width,

               graphic_height, graphic_depth, av_get_packet->nvram_machine_id,

               ""Sun4d"");



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, av_get_packet->machine_id);

}
",0,0,1,1,ds,0.16634312272071838,5,64,"{'ds': 'QERR_INVALID_PARAMETER', 'hwdef': 'av_get_packet', 'iounits': 'bootstrap_pc', 'i': 'AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH', 'boot_device': 'last_table_size'}",MHM-Origin,145,0.05769198338190715
321,"static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t *)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    __asm__ volatile(""pxor    %%mm7,%%mm7    \n\t"":::""memory"");

    __asm__ volatile(""pcmpeqd %%mm6,%%mm6    \n\t"":::""memory"");

    mm_end = end - 3;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            PACK_RGB32

            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r)

            :""memory"");

        d += 16;

        s += 4;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

        *d++ = 255;

    }

}
",274,"static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *qbus_find, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = qbus_find;

    const uint16_t *s = (const uint16_t *)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    __asm__ volatile(""pxor    %%mm7,%%mm7    
\t"":::""memory"");

    __asm__ volatile(""pcmpeqd %%mm6,%%mm6    
\t"":::""memory"");

    mm_end = end - 3;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movq          %1, %%mm0    
\t""

            ""movq          %1, %%mm1    
\t""

            ""movq          %1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            PACK_RGB32

            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r)

            :""memory"");

        d += 16;

        s += 4;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

        *d++ = 255;

    }

}
",1,1,0,1,dst,-0.6172426640987396,1,2,{'dst': 'qbus_find'},MHM-Origin,22,0.0053762316703796385
328,"static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x,

                                                 const uint8_t *src_y,

                                                 int32_t src_stride,

                                                 uint8_t *dst,

                                                 int32_t dst_stride)

{

    v16i8 src_hz0, src_hz1, src_hz2, src_hz3;

    v16u8 dst0, dst1, dst2, dst3;

    v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4;

    v16i8 src_vt5, src_vt6, src_vt7, src_vt8;

    v16i8 mask0, mask1, mask2;

    v8i16 hz_out0, hz_out1, vert_out0, vert_out1;

    v8i16 res0, res1;

    v16u8 res;



    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);

    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);

    src_y += (5 * src_stride);



    src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1);

    src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2);

    src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3);

    src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4);



    XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3);

    LD_SB4(src_x, src_stride, src_hz0, src_hz1, src_hz2, src_hz3);

    LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);

    XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3);

    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1,

                                                          mask0, mask1, mask2);

    hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3,

                                                          mask0, mask1, mask2);

    SRARI_H2_SH(hz_out0, hz_out1, 5);

    SAT_SH2_SH(hz_out0, hz_out1, 7);

    LD_SB4(src_y, src_stride, src_vt5, src_vt6, src_vt7, src_vt8);



    src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5);

    src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6);

    src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7);

    src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8);



    XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7);



    /* filter calc */

    vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2,

                                                  src_vt3, src_vt4, src_vt5);

    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4,

                                                  src_vt5, src_vt6, src_vt7);

    SRARI_H2_SH(vert_out0, vert_out1, 5);

    SAT_SH2_SH(vert_out0, vert_out1, 7);



    res1 = __msa_srari_h((hz_out1 + vert_out1), 1);

    res0 = __msa_srari_h((hz_out0 + vert_out0), 1);



    SAT_SH2_SH(res0, res1, 7);

    res = PCKEV_XORI128_UB(res0, res1);



    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);

    dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3);

    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);

    dst0 = __msa_aver_u_b(res, dst0);



    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride);

}
",600,"static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x,

                                                 const uint8_t *src_y,

                                                 int32_t src_stride,

                                                 uint8_t *dst,

                                                 int32_t dst_stride)

{

    v16i8 src_hz0, src_hz1, quantization, src_hz3;

    v16u8 dst0, dst1, dst2, bw;

    v16i8 src_vt0, JOINT_STEREO, gen_helper_cmpxchg16b, channel_arrangement, out2;

    v16i8 src_vt5, bytestream2_peek_be32, src_vt7, cpu_generic_init;

    v16i8 bytes_per_pixel, mask1, nvme_get_bootindex;

    v8i16 j, hz_out1, vert_out0, vert_out1;

    v8i16 res0, FW_CFG_INITRD_SIZE;

    v16u8 error_report;



    LD_SB3(&luma_mask_arr[48], 16, bytes_per_pixel, mask1, nvme_get_bootindex);

    LD_SB5(src_y, src_stride, src_vt0, JOINT_STEREO, gen_helper_cmpxchg16b, channel_arrangement, out2);

    src_y += (5 * src_stride);



    src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) JOINT_STEREO);

    JOINT_STEREO = (v16i8) __msa_insve_w((v4i32) JOINT_STEREO, 1, (v4i32) gen_helper_cmpxchg16b);

    gen_helper_cmpxchg16b = (v16i8) __msa_insve_w((v4i32) gen_helper_cmpxchg16b, 1, (v4i32) channel_arrangement);

    channel_arrangement = (v16i8) __msa_insve_w((v4i32) channel_arrangement, 1, (v4i32) out2);



    XORI_B4_128_SB(src_vt0, JOINT_STEREO, gen_helper_cmpxchg16b, channel_arrangement);

    LD_SB4(src_x, src_stride, src_hz0, src_hz1, quantization, src_hz3);

    LD_UB4(dst, dst_stride, dst0, dst1, dst2, bw);

    XORI_B4_128_SB(src_hz0, src_hz1, quantization, src_hz3);

    j = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1,

                                                          bytes_per_pixel, mask1, nvme_get_bootindex);

    hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(quantization, src_hz3,

                                                          bytes_per_pixel, mask1, nvme_get_bootindex);

    SRARI_H2_SH(j, hz_out1, 5);

    SAT_SH2_SH(j, hz_out1, 7);

    LD_SB4(src_y, src_stride, src_vt5, bytestream2_peek_be32, src_vt7, cpu_generic_init);



    out2 = (v16i8) __msa_insve_w((v4i32) out2, 1, (v4i32) src_vt5);

    src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) bytestream2_peek_be32);

    bytestream2_peek_be32 = (v16i8) __msa_insve_w((v4i32) bytestream2_peek_be32, 1, (v4i32) src_vt7);

    src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) cpu_generic_init);



    XORI_B4_128_SB(out2, src_vt5, bytestream2_peek_be32, src_vt7);



    /* filter calc */

    vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, JOINT_STEREO, gen_helper_cmpxchg16b,

                                                  channel_arrangement, out2, src_vt5);

    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(gen_helper_cmpxchg16b, channel_arrangement, out2,

                                                  src_vt5, bytestream2_peek_be32, src_vt7);

    SRARI_H2_SH(vert_out0, vert_out1, 5);

    SAT_SH2_SH(vert_out0, vert_out1, 7);



    FW_CFG_INITRD_SIZE = __msa_srari_h((hz_out1 + vert_out1), 1);

    res0 = __msa_srari_h((j + vert_out0), 1);



    SAT_SH2_SH(res0, FW_CFG_INITRD_SIZE, 7);

    error_report = PCKEV_XORI128_UB(res0, FW_CFG_INITRD_SIZE);



    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);

    dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) bw);

    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);

    dst0 = __msa_aver_u_b(error_report, dst0);



    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride);

}
",0,0,0,-1,hz_out0,1.8518883734941483e-05,13,68,"{'src_vt2': 'gen_helper_cmpxchg16b', 'mask0': 'bytes_per_pixel', 'res': 'error_report', 'src_vt6': 'bytestream2_peek_be32', 'res1': 'FW_CFG_INITRD_SIZE', 'src_vt3': 'channel_arrangement', 'mask2': 'nvme_get_bootindex', 'src_vt4': 'out2', 'src_vt8': 'cpu_generic_init', 'src_vt1': 'JOINT_STEREO', 'dst3': 'bw', 'hz_out0': 'j', 'src_hz2': 'quantization'}",MHM-Origin,417,0.12733939091364543
329,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

                         BlockDriverCompletionFunc *cb, void *opaque)

{

    BDRVRawState *s = bs->opaque;

    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,

                       cb, opaque, QEMU_AIO_READ);

}
",59,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t num_codes_sum, QEMUIOVector *qiov, int CC_OP_MULW,

                         BlockDriverCompletionFunc *cb, void *opaque)

{

    BDRVRawState *s = bs->opaque;

    return paio_submit(bs, s->hfile, num_codes_sum, qiov, CC_OP_MULW,

                       cb, opaque, QEMU_AIO_READ);

}
",0,0,1,1,nb_sectors,0.4734128937125206,2,4,"{'sector_num': 'num_codes_sum', 'nb_sectors': 'CC_OP_MULW'}",MHM-Origin,64,0.014597555001576742
330,"static void tcx_blit_writel(void *opaque, hwaddr addr,

                            uint64_t val, unsigned size)

{

    TCXState *s = opaque;

    uint32_t adsr, len;

    int i;



    if (!(addr & 4)) {

        s->tmpblit = val;

    } else {

        addr = (addr >> 3) & 0xfffff;

        adsr = val & 0xffffff;

        len = ((val >> 24) & 0x1f) + 1;

        if (adsr == 0xffffff) {

            memset(&s->vram[addr], s->tmpblit, len);

            if (s->depth == 24) {

                val = s->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (i = 0; i < len; i++) {

                    s->vram24[addr + i] = val;

                }

            }

        } else {

            memcpy(&s->vram[addr], &s->vram[adsr], len);

            if (s->depth == 24) {

                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);

            }

        }

        memory_region_set_dirty(&s->vram_mem, addr, len);

    }

}
",228,"static void tcx_blit_writel(void *opaque, hwaddr VQA_HEADER_SIZE,

                            uint64_t val, unsigned size)

{

    TCXState *s = opaque;

    uint32_t gen_helper_fldz_FT0, len;

    int ff_celt_window2;



    if (!(VQA_HEADER_SIZE & 4)) {

        s->tmpblit = val;

    } else {

        VQA_HEADER_SIZE = (VQA_HEADER_SIZE >> 3) & 0xfffff;

        gen_helper_fldz_FT0 = val & 0xffffff;

        len = ((val >> 24) & 0x1f) + 1;

        if (gen_helper_fldz_FT0 == 0xffffff) {

            memset(&s->vram[VQA_HEADER_SIZE], s->tmpblit, len);

            if (s->depth == 24) {

                val = s->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (ff_celt_window2 = 0; ff_celt_window2 < len; ff_celt_window2++) {

                    s->vram24[VQA_HEADER_SIZE + ff_celt_window2] = val;

                }

            }

        } else {

            memcpy(&s->vram[VQA_HEADER_SIZE], &s->vram[gen_helper_fldz_FT0], len);

            if (s->depth == 24) {

                memcpy(&s->vram24[VQA_HEADER_SIZE], &s->vram24[gen_helper_fldz_FT0], len * 4);

            }

        }

        memory_region_set_dirty(&s->vram_mem, VQA_HEADER_SIZE, len);

    }

}
",0,0,1,1,addr,0.5419721491634846,3,19,"{'adsr': 'gen_helper_fldz_FT0', 'i': 'ff_celt_window2', 'addr': 'VQA_HEADER_SIZE'}",MHM-Origin,84,0.02101131280263265
331,"static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,

                                                       uint8_t alpha_in,

                                                       uint8_t beta_in,

                                                       uint32_t img_width)

{

    uint16_t out0, out1, out2, out3;

    v8i16 tmp1;

    v16u8 alpha, beta, is_less_than;

    v8i16 p0_or_q0, q0_or_p0;

    v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org;

    v16i8 zero = { 0 };

    v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0;

    v16u8 is_less_than_alpha, is_less_than_beta;

    v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r;



    {

        v16u8 row0, row1, row2, row3, row4, row5, row6, row7;



        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,

                      row0, row1, row2, row3, row4, row5, row6, row7);



        TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7,

                          p1_or_q1_org, p0_or_q0_org,

                          q0_or_p0_org, q1_or_p1_org);

    }



    alpha = (v16u8) __msa_fill_b(alpha_in);

    beta = (v16u8) __msa_fill_b(beta_in);



    p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org);

    p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org);

    q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org);



    is_less_than_alpha = (p0_asub_q0 < alpha);

    is_less_than_beta = (p1_asub_p0 < beta);

    is_less_than = is_less_than_beta & is_less_than_alpha;

    is_less_than_beta = (q1_asub_q0 < beta);

    is_less_than = is_less_than_beta & is_less_than;



    is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than);



    if (!__msa_test_bz_v(is_less_than)) {

        p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org);

        p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org);

        q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org);

        q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org);



        AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, p0_or_q0);

        AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0);



        /* convert 16 bit output into 8 bit output */

        p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0);

        q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0);



        p0_or_q0_org =

            __msa_bmnz_v(p0_or_q0_org, (v16u8) p0_or_q0, is_less_than);

        q0_or_p0_org =

            __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than);



        tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org);



        data_cb_or_cr -= 1;



        out0 = __msa_copy_u_h(tmp1, 0);

        out1 = __msa_copy_u_h(tmp1, 1);

        out2 = __msa_copy_u_h(tmp1, 2);

        out3 = __msa_copy_u_h(tmp1, 3);



        STORE_HWORD(data_cb_or_cr, out0);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out1);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out3);

        data_cb_or_cr += img_width;



        out0 = __msa_copy_u_h(tmp1, 4);

        out1 = __msa_copy_u_h(tmp1, 5);

        out2 = __msa_copy_u_h(tmp1, 6);

        out3 = __msa_copy_u_h(tmp1, 7);



        STORE_HWORD(data_cb_or_cr, out0);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out1);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out3);

    }

}
",582,"static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,

                                                       uint8_t alpha_in,

                                                       uint8_t PayloadContext,

                                                       uint32_t img_width)

{

    uint16_t mix_2_1_f, Y2, out2, out3;

    v8i16 cur_offset;

    v16u8 alpha, pin, gen_op_testl_T0_T1_cc;

    v8i16 qdm2_decode_sub_packet_header, q0_or_p0;

    v16u8 p1_or_q1_org, p0_or_q0_org, endptr, q1_or_p1_org;

    v16i8 zero = { 0 };

    v16u8 ram_offset, p1_asub_p0, q1_asub_q0;

    v16u8 is_less_than_alpha, best;

    v8i16 p1_org_r, p0_org_r, PIX_FMT_Y400A, peers_ptr;



    {

        v16u8 row0, FD_ISSET, row2, FW_CFG_KERNEL_ADDR, header, row5, row6, n;



        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,

                      row0, FD_ISSET, row2, FW_CFG_KERNEL_ADDR, header, row5, row6, n);



        TRANSPOSE8x4_B_UB(row0, FD_ISSET, row2, FW_CFG_KERNEL_ADDR, header, row5, row6, n,

                          p1_or_q1_org, p0_or_q0_org,

                          endptr, q1_or_p1_org);

    }



    alpha = (v16u8) __msa_fill_b(alpha_in);

    pin = (v16u8) __msa_fill_b(PayloadContext);



    ram_offset = __msa_asub_u_b(p0_or_q0_org, endptr);

    p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org);

    q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, endptr);



    is_less_than_alpha = (ram_offset < alpha);

    best = (p1_asub_p0 < pin);

    gen_op_testl_T0_T1_cc = best & is_less_than_alpha;

    best = (q1_asub_q0 < pin);

    gen_op_testl_T0_T1_cc = best & gen_op_testl_T0_T1_cc;



    gen_op_testl_T0_T1_cc = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) gen_op_testl_T0_T1_cc);



    if (!__msa_test_bz_v(gen_op_testl_T0_T1_cc)) {

        p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org);

        p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org);

        PIX_FMT_Y400A = (v8i16) __msa_ilvr_b(zero, (v16i8) endptr);

        peers_ptr = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org);



        AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, peers_ptr, p1_org_r, qdm2_decode_sub_packet_header);

        AVC_LOOP_FILTER_P0_OR_Q0(PIX_FMT_Y400A, p1_org_r, peers_ptr, q0_or_p0);



        /* convert 16 bit output into 8 bit output */

        qdm2_decode_sub_packet_header = (v8i16) __msa_pckev_b(zero, (v16i8) qdm2_decode_sub_packet_header);

        q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0);



        p0_or_q0_org =

            __msa_bmnz_v(p0_or_q0_org, (v16u8) qdm2_decode_sub_packet_header, gen_op_testl_T0_T1_cc);

        endptr =

            __msa_bmnz_v(endptr, (v16u8) q0_or_p0, gen_op_testl_T0_T1_cc);



        cur_offset = (v8i16) __msa_ilvr_b((v16i8) endptr, (v16i8) p0_or_q0_org);



        data_cb_or_cr -= 1;



        mix_2_1_f = __msa_copy_u_h(cur_offset, 0);

        Y2 = __msa_copy_u_h(cur_offset, 1);

        out2 = __msa_copy_u_h(cur_offset, 2);

        out3 = __msa_copy_u_h(cur_offset, 3);



        STORE_HWORD(data_cb_or_cr, mix_2_1_f);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, Y2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out3);

        data_cb_or_cr += img_width;



        mix_2_1_f = __msa_copy_u_h(cur_offset, 4);

        Y2 = __msa_copy_u_h(cur_offset, 5);

        out2 = __msa_copy_u_h(cur_offset, 6);

        out3 = __msa_copy_u_h(cur_offset, 7);



        STORE_HWORD(data_cb_or_cr, mix_2_1_f);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, Y2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out3);

    }

}
",0,0,0,-1,row4,-6.759259849786758e-05,16,75,"{'p0_asub_q0': 'ram_offset', 'row3': 'FW_CFG_KERNEL_ADDR', 'q0_org_r': 'PIX_FMT_Y400A', 'beta_in': 'PayloadContext', 'is_less_than': 'gen_op_testl_T0_T1_cc', 'out1': 'Y2', 'tmp1': 'cur_offset', 'p0_or_q0': 'qdm2_decode_sub_packet_header', 'beta': 'pin', 'q0_or_p0_org': 'endptr', 'is_less_than_beta': 'best', 'row7': 'n', 'out0': 'mix_2_1_f', 'q1_org_r': 'peers_ptr', 'row1': 'FD_ISSET', 'row4': 'header'}",MHM-Origin,409,0.13403288125991822
333,"static int vdpau_mpeg_start_frame(AVCodecContext *avctx,

                                  const uint8_t *buffer, uint32_t size)

{

    MpegEncContext * const s = avctx->priv_data;

    Picture *pic             = s->current_picture_ptr;

    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;

    VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;

    VdpVideoSurface ref;

    int i;



    /* fill VdpPictureInfoMPEG1Or2 struct */

    info->forward_reference  = VDP_INVALID_HANDLE;

    info->backward_reference = VDP_INVALID_HANDLE;



    switch (s->pict_type) {

    case AV_PICTURE_TYPE_B:

        ref = ff_vdpau_get_surface_id(&s->next_picture.f);

        assert(ref != VDP_INVALID_HANDLE);

        info->backward_reference = ref;

        /* fall through to forward prediction */

    case AV_PICTURE_TYPE_P:

        ref = ff_vdpau_get_surface_id(&s->last_picture.f);

        info->forward_reference  = ref;

    }



    info->slice_count                = 0;

    info->picture_structure          = s->picture_structure;

    info->picture_coding_type        = s->pict_type;

    info->intra_dc_precision         = s->intra_dc_precision;

    info->frame_pred_frame_dct       = s->frame_pred_frame_dct;

    info->concealment_motion_vectors = s->concealment_motion_vectors;

    info->intra_vlc_format           = s->intra_vlc_format;

    info->alternate_scan             = s->alternate_scan;

    info->q_scale_type               = s->q_scale_type;

    info->top_field_first            = s->top_field_first;

    // Both for MPEG-1 only, zero for MPEG-2:

    info->full_pel_forward_vector    = s->full_pel[0];

    info->full_pel_backward_vector   = s->full_pel[1];

    // For MPEG-1 fill both horizontal & vertical:

    info->f_code[0][0]               = s->mpeg_f_code[0][0];

    info->f_code[0][1]               = s->mpeg_f_code[0][1];

    info->f_code[1][0]               = s->mpeg_f_code[1][0];

    info->f_code[1][1]               = s->mpeg_f_code[1][1];

    for (i = 0; i < 64; ++i) {

        info->intra_quantizer_matrix[i]     = s->intra_matrix[i];

        info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];

    }



    return ff_vdpau_common_start_frame(pic_ctx, buffer, size);

}
",363,"static int vdpau_mpeg_start_frame(AVCodecContext *tcg_gen_clzi_tl,

                                  const uint8_t *buffer, uint32_t size)

{

    MpegEncContext * const s = tcg_gen_clzi_tl->priv_data;

    Picture *pic             = s->current_picture_ptr;

    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;

    VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;

    VdpVideoSurface ref;

    int i;



    /* fill VdpPictureInfoMPEG1Or2 struct */

    info->forward_reference  = VDP_INVALID_HANDLE;

    info->backward_reference = VDP_INVALID_HANDLE;



    switch (s->pict_type) {

    case AV_PICTURE_TYPE_B:

        ref = ff_vdpau_get_surface_id(&s->next_picture.f);

        assert(ref != VDP_INVALID_HANDLE);

        info->backward_reference = ref;

        /* fall through to forward prediction */

    case AV_PICTURE_TYPE_P:

        ref = ff_vdpau_get_surface_id(&s->last_picture.f);

        info->forward_reference  = ref;

    }



    info->slice_count                = 0;

    info->picture_structure          = s->picture_structure;

    info->picture_coding_type        = s->pict_type;

    info->intra_dc_precision         = s->intra_dc_precision;

    info->frame_pred_frame_dct       = s->frame_pred_frame_dct;

    info->concealment_motion_vectors = s->concealment_motion_vectors;

    info->intra_vlc_format           = s->intra_vlc_format;

    info->alternate_scan             = s->alternate_scan;

    info->q_scale_type               = s->q_scale_type;

    info->top_field_first            = s->top_field_first;

    // Both for MPEG-1 only, zero for MPEG-2:

    info->full_pel_forward_vector    = s->full_pel[0];

    info->full_pel_backward_vector   = s->full_pel[1];

    // For MPEG-1 fill both horizontal & vertical:

    info->f_code[0][0]               = s->mpeg_f_code[0][0];

    info->f_code[0][1]               = s->mpeg_f_code[0][1];

    info->f_code[1][0]               = s->mpeg_f_code[1][0];

    info->f_code[1][1]               = s->mpeg_f_code[1][1];

    for (i = 0; i < 64; ++i) {

        info->intra_quantizer_matrix[i]     = s->intra_matrix[i];

        info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];

    }



    return ff_vdpau_common_start_frame(pic_ctx, buffer, size);

}
",1,1,0,1,avctx,-0.1773822009563446,1,2,{'avctx': 'tcg_gen_clzi_tl'},MHM-Origin,22,0.0057839075724283855
334,"void h263_decode_init_vlc(MpegEncContext *s)

{

    static int done = 0;



    if (!done) {

        done = 1;



        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, 

                 intra_MCBPC_bits, 1, 1,

                 intra_MCBPC_code, 1, 1);

        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, 

                 inter_MCBPC_bits, 1, 1,

                 inter_MCBPC_code, 1, 1);

        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,

                 &cbpy_tab[0][1], 2, 1,

                 &cbpy_tab[0][0], 2, 1);

        init_vlc(&mv_vlc, MV_VLC_BITS, 33,

                 &mvtab[0][1], 2, 1,

                 &mvtab[0][0], 2, 1);

        init_rl(&rl_inter);

        init_rl(&rl_intra);

        init_rl(&rvlc_rl_inter);

        init_rl(&rvlc_rl_intra);

        init_rl(&rl_intra_aic);

        init_vlc_rl(&rl_inter);

        init_vlc_rl(&rl_intra);

        init_vlc_rl(&rvlc_rl_inter);

        init_vlc_rl(&rvlc_rl_intra);

        init_vlc_rl(&rl_intra_aic);

        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_lum[0][1], 2, 1,

                 &DCtab_lum[0][0], 2, 1);

        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_chrom[0][1], 2, 1,

                 &DCtab_chrom[0][0], 2, 1);

        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,

                 &sprite_trajectory_tab[0][1], 4, 2,

                 &sprite_trajectory_tab[0][0], 4, 2);

        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,

                 &mb_type_b_tab[0][1], 2, 1,

                 &mb_type_b_tab[0][0], 2, 1);

        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,

                 &h263_mbtype_b_tab[0][1], 2, 1,

                 &h263_mbtype_b_tab[0][0], 2, 1);

        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,

                 &cbpc_b_tab[0][1], 2, 1,

                 &cbpc_b_tab[0][0], 2, 1);

    }

}
",418,"void h263_decode_init_vlc(MpegEncContext *t2)

{

    static int done = 0;



    if (!done) {

        done = 1;



        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, 

                 intra_MCBPC_bits, 1, 1,

                 intra_MCBPC_code, 1, 1);

        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, 

                 inter_MCBPC_bits, 1, 1,

                 inter_MCBPC_code, 1, 1);

        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,

                 &cbpy_tab[0][1], 2, 1,

                 &cbpy_tab[0][0], 2, 1);

        init_vlc(&mv_vlc, MV_VLC_BITS, 33,

                 &mvtab[0][1], 2, 1,

                 &mvtab[0][0], 2, 1);

        init_rl(&rl_inter);

        init_rl(&rl_intra);

        init_rl(&rvlc_rl_inter);

        init_rl(&rvlc_rl_intra);

        init_rl(&rl_intra_aic);

        init_vlc_rl(&rl_inter);

        init_vlc_rl(&rl_intra);

        init_vlc_rl(&rvlc_rl_inter);

        init_vlc_rl(&rvlc_rl_intra);

        init_vlc_rl(&rl_intra_aic);

        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_lum[0][1], 2, 1,

                 &DCtab_lum[0][0], 2, 1);

        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_chrom[0][1], 2, 1,

                 &DCtab_chrom[0][0], 2, 1);

        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,

                 &sprite_trajectory_tab[0][1], 4, 2,

                 &sprite_trajectory_tab[0][0], 4, 2);

        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,

                 &mb_type_b_tab[0][1], 2, 1,

                 &mb_type_b_tab[0][0], 2, 1);

        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,

                 &h263_mbtype_b_tab[0][1], 2, 1,

                 &h263_mbtype_b_tab[0][0], 2, 1);

        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,

                 &cbpc_b_tab[0][1], 2, 1,

                 &cbpc_b_tab[0][0], 2, 1);

    }

}
",1,1,1,-1,s,-0.0005969405174255371,1,1,{'s': 't2'},MHM-Origin,412,0.11170899470647176
337,"void ff_rfps_calculate(AVFormatContext *ic)
{
    int i, j;
    for (i = 0; i<ic->nb_streams; i++) {
        AVStream *st = ic->streams[i];
        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)
        // the check for tb_unreliable() is not completely correct, since this is not about handling
        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
        // ipmovie.c produces.
        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)
            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);
        if (st->info->duration_count>1 && !st->r_frame_rate.num
            && tb_unreliable(st->codec)) {
            int num = 0;
            double best_error= 0.01;
            for (j=0; j<MAX_STD_TIMEBASES; j++) {
                int k;
                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))
                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))
                for(k=0; k<2; k++){
                    int n= st->info->duration_count;
                    double a= st->info->duration_error[k][0][j] / n;
                    double error= st->info->duration_error[k][1][j]/n - a*a;
                    if(error < best_error && best_error> 0.000000001){
                        best_error= error;
                        num = get_std_framerate(j);
                    }
                    if(error < 0.02)
                        av_log(NULL, AV_LOG_DEBUG, ""rfps: %f %f\n"", get_std_framerate(j) / 12.0/1001, error);
                }
            }
            // do not increase frame rate by more than 1 % in order to match a standard rate.
            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))
                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);
        }
        av_freep(&st->info->duration_error);
        st->info->last_dts = AV_NOPTS_VALUE;
        st->info->duration_count = 0;
        st->info->rfps_duration_sum = 0;
    }
}",458,"void ff_rfps_calculate(AVFormatContext *ic)
{
    int nal_type, j;
    for (nal_type = 0; nal_type<ic->nb_streams; nal_type++) {
        AVStream *st = ic->streams[nal_type];
        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)
        // the check for tb_unreliable() is not completely correct, since this is not about handling
        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
        // ipmovie.c produces.
        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)
            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);
        if (st->info->duration_count>1 && !st->r_frame_rate.num
            && tb_unreliable(st->codec)) {
            int num = 0;
            double best_error= 0.01;
            for (j=0; j<MAX_STD_TIMEBASES; j++) {
                int k;
                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))
                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))
                for(k=0; k<2; k++){
                    int n= st->info->duration_count;
                    double a= st->info->duration_error[k][0][j] / n;
                    double error= st->info->duration_error[k][1][j]/n - a*a;
                    if(error < best_error && best_error> 0.000000001){
                        best_error= error;
                        num = get_std_framerate(j);
                    }
                    if(error < 0.02)
                        av_log(NULL, AV_LOG_DEBUG, ""rfps: %f %f
"", get_std_framerate(j) / 12.0/1001, error);
                }
            }
            // do not increase frame rate by more than 1 % in order to match a standard rate.
            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))
                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);
        }
        av_freep(&st->info->duration_error);
        st->info->last_dts = AV_NOPTS_VALUE;
        st->info->duration_count = 0;
        st->info->rfps_duration_sum = 0;
    }
}",1,1,0,1,i,-0.21566268801689148,1,5,{'i': 'nal_type'},MHM-Origin,24,0.006266562143961588
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
",36,"static void gen_compute_eflags_o(DisasContext *QObject, TCGv tmp_args)

{

    gen_compute_eflags(QObject);

    tcg_gen_shri_tl(tmp_args, cpu_cc_src, 11);

    tcg_gen_andi_tl(tmp_args, tmp_args, 1);

}
",0,0,1,1,reg,0.5265853554010391,2,6,"{'s': 'QObject', 'reg': 'tmp_args'}",MHM-Origin,41,0.009058125813802083
339,"static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,

                                       int *mb_type)

{

    int b8_stride = 2;

    int b4_stride = h->b_stride;

    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;

    int mb_type_col[2];

    const int16_t (*l1mv0)[2], (*l1mv1)[2];

    const int8_t *l1ref0, *l1ref1;

    const int is_b8x8 = IS_8X8(*mb_type);

    unsigned int sub_mb_type = MB_TYPE_L0L1;

    int i8, i4;

    int ref[2];

    int mv[2];

    int list;



    assert(sl->ref_list[1][0].reference & 3);



    await_reference_mb_row(h, sl->ref_list[1][0].parent,

                           sl->mb_y + !!IS_INTERLACED(*mb_type));



#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \

                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)



    /* ref = min(neighbors) */

    for (list = 0; list < 2; list++) {

        int left_ref     = sl->ref_cache[list][scan8[0] - 1];

        int top_ref      = sl->ref_cache[list][scan8[0] - 8];

        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];

        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];

        if (refc == PART_NOT_AVAILABLE) {

            refc = sl->ref_cache[list][scan8[0] - 8 - 1];

            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];

        }

        ref[list] = FFMIN3((unsigned)left_ref,

                           (unsigned)top_ref,

                           (unsigned)refc);

        if (ref[list] >= 0) {

            /* This is just pred_motion() but with the cases removed that

             * cannot happen for direct blocks. */

            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];

            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];



            int match_count = (left_ref == ref[list]) +

                              (top_ref  == ref[list]) +

                              (refc     == ref[list]);



            if (match_count > 1) { // most common

                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),

                                      mid_pred(A[1], B[1], C[1]));

            } else {

                assert(match_count == 1);

                if (left_ref == ref[list])

                    mv[list] = AV_RN32A(A);

                else if (top_ref == ref[list])

                    mv[list] = AV_RN32A(B);

                else

                    mv[list] = AV_RN32A(C);

            }

        } else {

            int mask = ~(MB_TYPE_L0 << (2 * list));

            mv[list]  = 0;

            ref[list] = -1;

            if (!is_b8x8)

                *mb_type &= mask;

            sub_mb_type &= mask;

        }

    }

    if (ref[0] < 0 && ref[1] < 0) {

        ref[0] = ref[1] = 0;

        if (!is_b8x8)

            *mb_type |= MB_TYPE_L0L1;

        sub_mb_type |= MB_TYPE_L0L1;

    }



    if (!(is_b8x8 | mv[0] | mv[1])) {

        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);

        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;

        return;

    }



    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL

        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL

            mb_y  = (sl->mb_y & ~1) + sl->col_parity;

            mb_xy = sl->mb_x +

                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;

            b8_stride = 0;

        } else {

            mb_y  += sl->col_fieldoff;

            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity

        }

        goto single_col;

    } else {                                             // AFL/AFR/FR/FL -> AFR/FR

        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR

            mb_y           =  sl->mb_y & ~1;

            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;

            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];

            b8_stride      = 2 + 4 * h->mb_stride;

            b4_stride     *= 6;

            if (IS_INTERLACED(mb_type_col[0]) !=

                IS_INTERLACED(mb_type_col[1])) {

                mb_type_col[0] &= ~MB_TYPE_INTERLACED;

                mb_type_col[1] &= ~MB_TYPE_INTERLACED;

            }



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&

                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&

                !is_b8x8) {

                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */

            } else {

                *mb_type |= MB_TYPE_8x8;

            }

        } else {                                         //     AFR/FR    -> AFR/FR

single_col:

            mb_type_col[0] =

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {

                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */

            } else if (!is_b8x8 &&

                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {

                *mb_type |= MB_TYPE_DIRECT2 |

                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));

            } else {

                if (!h->sps.direct_8x8_inference_flag) {

                    /* FIXME: Save sub mb types from previous frames (or derive

                     * from MVs) so we know exactly what block size to use. */

                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */

                }

                *mb_type |= MB_TYPE_8x8;

            }

        }

    }



    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);



    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];

    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];

    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];

    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];

    if (!b8_stride) {

        if (sl->mb_y & 1) {

            l1ref0 += 2;

            l1ref1 += 2;

            l1mv0  += 2 * b4_stride;

            l1mv1  += 2 * b4_stride;

        }

    }



    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            int x8  = i8 & 1;

            int y8  = i8 >> 1;

            int xy8 = x8     + y8 * b8_stride;

            int xy4 = x8 * 3 + y8 * b4_stride;

            int a, b;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);

            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&

                ((l1ref0[xy8] == 0 &&

                  FFABS(l1mv0[xy4][0]) <= 1 &&

                  FFABS(l1mv0[xy4][1]) <= 1) ||

                 (l1ref0[xy8] < 0 &&

                  l1ref1[xy8] == 0 &&

                  FFABS(l1mv1[xy4][0]) <= 1 &&

                  FFABS(l1mv1[xy4][1]) <= 1))) {

                a =

                b = 0;

                if (ref[0] > 0)

                    a = mv[0];

                if (ref[1] > 0)

                    b = mv[1];

                n++;

            } else {

                a = mv[0];

                b = mv[1];

            }

            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);

        }

        if (!is_b8x8 && !(n & 3))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    } else if (IS_16X16(*mb_type)) {

        int a, b;



        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

            ((l1ref0[0] == 0 &&

              FFABS(l1mv0[0][0]) <= 1 &&

              FFABS(l1mv0[0][1]) <= 1) ||

             (l1ref0[0] < 0 && !l1ref1[0] &&

              FFABS(l1mv1[0][0]) <= 1 &&

              FFABS(l1mv1[0][1]) <= 1 &&

              h->x264_build > 33U))) {

            a = b = 0;

            if (ref[0] > 0)

                a = mv[0];

            if (ref[1] > 0)

                b = mv[1];

        } else {

            a = mv[0];

            b = mv[1];

        }

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);

    } else {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            const int x8 = i8 & 1;

            const int y8 = i8 >> 1;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);

            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);



            assert(b8_stride == 2);

            /* col_zero_flag */

            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

                (l1ref0[i8] == 0 ||

                 (l1ref0[i8] < 0 &&

                  l1ref1[i8] == 0 &&

                  h->x264_build > 33U))) {

                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;

                if (IS_SUB_8X8(sub_mb_type)) {

                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];

                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                        if (ref[0] == 0)

                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        if (ref[1] == 0)

                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        n += 4;

                    }

                } else {

                    int m = 0;

                    for (i4 = 0; i4 < 4; i4++) {

                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +

                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];

                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                            if (ref[0] == 0)

                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);

                            if (ref[1] == 0)

                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);

                            m++;

                        }

                    }

                    if (!(m & 3))

                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;

                    n += m;

                }

            }

        }

        if (!is_b8x8 && !(n & 15))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    }

}
",2704,"static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,

                                       int *mb_type)

{

    int b8_stride = 2;

    int b4_stride = h->b_stride;

    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;

    int mb_type_col[2];

    const int16_t (*l1mv0)[2], (*l1mv1)[2];

    const int8_t *l1ref0, *l1ref1;

    const int is_b8x8 = IS_8X8(*mb_type);

    unsigned int sub_mb_type = MB_TYPE_L0L1;

    int i8, qemu_input_event_send_key_delay;

    int ref[2];

    int mv[2];

    int list;



    assert(sl->ref_list[1][0].reference & 3);



    await_reference_mb_row(h, sl->ref_list[1][0].parent,

                           sl->mb_y + !!IS_INTERLACED(*mb_type));



#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \

                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)



    /* ref = min(neighbors) */

    for (list = 0; list < 2; list++) {

        int left_ref     = sl->ref_cache[list][scan8[0] - 1];

        int top_ref      = sl->ref_cache[list][scan8[0] - 8];

        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];

        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];

        if (refc == PART_NOT_AVAILABLE) {

            refc = sl->ref_cache[list][scan8[0] - 8 - 1];

            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];

        }

        ref[list] = FFMIN3((unsigned)left_ref,

                           (unsigned)top_ref,

                           (unsigned)refc);

        if (ref[list] >= 0) {

            /* This is just pred_motion() but with the cases removed that

             * cannot happen for direct blocks. */

            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];

            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];



            int match_count = (left_ref == ref[list]) +

                              (top_ref  == ref[list]) +

                              (refc     == ref[list]);



            if (match_count > 1) { // most common

                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),

                                      mid_pred(A[1], B[1], C[1]));

            } else {

                assert(match_count == 1);

                if (left_ref == ref[list])

                    mv[list] = AV_RN32A(A);

                else if (top_ref == ref[list])

                    mv[list] = AV_RN32A(B);

                else

                    mv[list] = AV_RN32A(C);

            }

        } else {

            int mask = ~(MB_TYPE_L0 << (2 * list));

            mv[list]  = 0;

            ref[list] = -1;

            if (!is_b8x8)

                *mb_type &= mask;

            sub_mb_type &= mask;

        }

    }

    if (ref[0] < 0 && ref[1] < 0) {

        ref[0] = ref[1] = 0;

        if (!is_b8x8)

            *mb_type |= MB_TYPE_L0L1;

        sub_mb_type |= MB_TYPE_L0L1;

    }



    if (!(is_b8x8 | mv[0] | mv[1])) {

        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);

        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;

        return;

    }



    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL

        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL

            mb_y  = (sl->mb_y & ~1) + sl->col_parity;

            mb_xy = sl->mb_x +

                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;

            b8_stride = 0;

        } else {

            mb_y  += sl->col_fieldoff;

            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity

        }

        goto single_col;

    } else {                                             // AFL/AFR/FR/FL -> AFR/FR

        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR

            mb_y           =  sl->mb_y & ~1;

            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;

            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];

            b8_stride      = 2 + 4 * h->mb_stride;

            b4_stride     *= 6;

            if (IS_INTERLACED(mb_type_col[0]) !=

                IS_INTERLACED(mb_type_col[1])) {

                mb_type_col[0] &= ~MB_TYPE_INTERLACED;

                mb_type_col[1] &= ~MB_TYPE_INTERLACED;

            }



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&

                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&

                !is_b8x8) {

                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */

            } else {

                *mb_type |= MB_TYPE_8x8;

            }

        } else {                                         //     AFR/FR    -> AFR/FR

single_col:

            mb_type_col[0] =

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {

                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */

            } else if (!is_b8x8 &&

                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {

                *mb_type |= MB_TYPE_DIRECT2 |

                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));

            } else {

                if (!h->sps.direct_8x8_inference_flag) {

                    /* FIXME: Save sub mb types from previous frames (or derive

                     * from MVs) so we know exactly what block size to use. */

                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */

                }

                *mb_type |= MB_TYPE_8x8;

            }

        }

    }



    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);



    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];

    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];

    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];

    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];

    if (!b8_stride) {

        if (sl->mb_y & 1) {

            l1ref0 += 2;

            l1ref1 += 2;

            l1mv0  += 2 * b4_stride;

            l1mv1  += 2 * b4_stride;

        }

    }



    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            int x8  = i8 & 1;

            int y8  = i8 >> 1;

            int xy8 = x8     + y8 * b8_stride;

            int xy4 = x8 * 3 + y8 * b4_stride;

            int a, b;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);

            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&

                ((l1ref0[xy8] == 0 &&

                  FFABS(l1mv0[xy4][0]) <= 1 &&

                  FFABS(l1mv0[xy4][1]) <= 1) ||

                 (l1ref0[xy8] < 0 &&

                  l1ref1[xy8] == 0 &&

                  FFABS(l1mv1[xy4][0]) <= 1 &&

                  FFABS(l1mv1[xy4][1]) <= 1))) {

                a =

                b = 0;

                if (ref[0] > 0)

                    a = mv[0];

                if (ref[1] > 0)

                    b = mv[1];

                n++;

            } else {

                a = mv[0];

                b = mv[1];

            }

            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);

        }

        if (!is_b8x8 && !(n & 3))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    } else if (IS_16X16(*mb_type)) {

        int a, b;



        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

            ((l1ref0[0] == 0 &&

              FFABS(l1mv0[0][0]) <= 1 &&

              FFABS(l1mv0[0][1]) <= 1) ||

             (l1ref0[0] < 0 && !l1ref1[0] &&

              FFABS(l1mv1[0][0]) <= 1 &&

              FFABS(l1mv1[0][1]) <= 1 &&

              h->x264_build > 33U))) {

            a = b = 0;

            if (ref[0] > 0)

                a = mv[0];

            if (ref[1] > 0)

                b = mv[1];

        } else {

            a = mv[0];

            b = mv[1];

        }

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);

    } else {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            const int x8 = i8 & 1;

            const int y8 = i8 >> 1;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);

            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);



            assert(b8_stride == 2);

            /* col_zero_flag */

            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

                (l1ref0[i8] == 0 ||

                 (l1ref0[i8] < 0 &&

                  l1ref1[i8] == 0 &&

                  h->x264_build > 33U))) {

                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;

                if (IS_SUB_8X8(sub_mb_type)) {

                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];

                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                        if (ref[0] == 0)

                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        if (ref[1] == 0)

                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        n += 4;

                    }

                } else {

                    int m = 0;

                    for (qemu_input_event_send_key_delay = 0; qemu_input_event_send_key_delay < 4; qemu_input_event_send_key_delay++) {

                        const int16_t *mv_col = l1mv[x8 * 2 + (qemu_input_event_send_key_delay & 1) +

                                                     (y8 * 2 + (qemu_input_event_send_key_delay >> 1)) * b4_stride];

                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                            if (ref[0] == 0)

                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + qemu_input_event_send_key_delay]]);

                            if (ref[1] == 0)

                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + qemu_input_event_send_key_delay]]);

                            m++;

                        }

                    }

                    if (!(m & 3))

                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;

                    n += m;

                }

            }

        }

        if (!is_b8x8 && !(n & 15))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    }

}
",0,0,1,1,i4,0.24944138526916504,1,8,{'i4': 'qemu_input_event_send_key_delay'},MHM-Origin,22,0.014645413557688395
340,"static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,

        unsigned size)

{

    GemState *s = (GemState *)opaque;

    uint32_t readonly;



    DB_PRINT(""offset: 0x%04x write: 0x%08x "", offset, (unsigned)val);

    offset >>= 2;



    /* Squash bits which are read only in write value */

    val &= ~(s->regs_ro[offset]);

    /* Preserve (only) bits which are read only in register */

    readonly = s->regs[offset];

    readonly &= s->regs_ro[offset];



    /* Squash bits which are write 1 to clear */

    val &= ~(s->regs_w1c[offset] & val);



    /* Copy register write to backing store */

    s->regs[offset] = val | readonly;



    /* Handle register write side effects */

    switch (offset) {

    case GEM_NWCTRL:

        if (val & GEM_NWCTRL_TXSTART) {

            gem_transmit(s);

        }

        if (!(val & GEM_NWCTRL_TXENA)) {

            /* Reset to start of Q when transmit disabled. */

            s->tx_desc_addr = s->regs[GEM_TXQBASE];

        }

        if (!(val & GEM_NWCTRL_RXENA)) {

            /* Reset to start of Q when receive disabled. */

            s->rx_desc_addr = s->regs[GEM_RXQBASE];

        }

        break;



    case GEM_TXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_RXQBASE:

        s->rx_desc_addr = val;

        break;

    case GEM_TXQBASE:

        s->tx_desc_addr = val;

        break;

    case GEM_RXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_IER:

        s->regs[GEM_IMR] &= ~val;

        gem_update_int_status(s);

        break;

    case GEM_IDR:

        s->regs[GEM_IMR] |= val;

        gem_update_int_status(s);

        break;

    case GEM_PHYMNTNC:

        if (val & GEM_PHYMNTNC_OP_W) {

            uint32_t phy_addr, reg_num;



            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;

            if (phy_addr == BOARD_PHY_ADDRESS) {

                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;

                gem_phy_write(s, reg_num, val);

            }

        }

        break;

    }



    DB_PRINT(""newval: 0x%08x\n"", s->regs[offset]);

}
",321,"static void gem_write(void *do_show_frames, target_phys_addr_t offset, uint64_t input,

        unsigned size)

{

    GemState *s = (GemState *)do_show_frames;

    uint32_t readonly;



    DB_PRINT(""offset: 0x%04x write: 0x%08x "", offset, (unsigned)input);

    offset >>= 2;



    /* Squash bits which are read only in write value */

    input &= ~(s->regs_ro[offset]);

    /* Preserve (only) bits which are read only in register */

    readonly = s->regs[offset];

    readonly &= s->regs_ro[offset];



    /* Squash bits which are write 1 to clear */

    input &= ~(s->regs_w1c[offset] & input);



    /* Copy register write to backing store */

    s->regs[offset] = input | readonly;



    /* Handle register write side effects */

    switch (offset) {

    case GEM_NWCTRL:

        if (input & GEM_NWCTRL_TXSTART) {

            gem_transmit(s);

        }

        if (!(input & GEM_NWCTRL_TXENA)) {

            /* Reset to start of Q when transmit disabled. */

            s->tx_desc_addr = s->regs[GEM_TXQBASE];

        }

        if (!(input & GEM_NWCTRL_RXENA)) {

            /* Reset to start of Q when receive disabled. */

            s->rx_desc_addr = s->regs[GEM_RXQBASE];

        }

        break;



    case GEM_TXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_RXQBASE:

        s->rx_desc_addr = input;

        break;

    case GEM_TXQBASE:

        s->tx_desc_addr = input;

        break;

    case GEM_RXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_IER:

        s->regs[GEM_IMR] &= ~input;

        gem_update_int_status(s);

        break;

    case GEM_IDR:

        s->regs[GEM_IMR] |= input;

        gem_update_int_status(s);

        break;

    case GEM_PHYMNTNC:

        if (input & GEM_PHYMNTNC_OP_W) {

            uint32_t phy_addr, reg_num;



            phy_addr = (input & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;

            if (phy_addr == BOARD_PHY_ADDRESS) {

                reg_num = (input & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;

                gem_phy_write(s, reg_num, input);

            }

        }

        break;

    }



    DB_PRINT(""newval: 0x%08x
"", s->regs[offset]);

}
",0,0,1,1,opaque,0.61335214599967,2,19,"{'val': 'input', 'opaque': 'do_show_frames'}",MHM-Origin,40,0.01123503843943278
341,"void cpu_loop(CPUMIPSState *env)

{

    target_siginfo_t info;

    int trapnr, ret;

    unsigned int syscall_num;



    for(;;) {

        trapnr = cpu_mips_exec(env);

        switch(trapnr) {

        case EXCP_SYSCALL:

            syscall_num = env->active_tc.gpr[2] - 4000;

            env->active_tc.PC += 4;

            if (syscall_num >= sizeof(mips_syscall_args)) {

                ret = -ENOSYS;

            } else {

                int nb_args;

                abi_ulong sp_reg;

                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;



                nb_args = mips_syscall_args[syscall_num];

                sp_reg = env->active_tc.gpr[29];

                switch (nb_args) {

                /* these arguments are taken from the stack */

                /* FIXME - what to do if get_user() fails? */

                case 8: get_user_ual(arg8, sp_reg + 28);

                case 7: get_user_ual(arg7, sp_reg + 24);

                case 6: get_user_ual(arg6, sp_reg + 20);

                case 5: get_user_ual(arg5, sp_reg + 16);

                default:



                ret = do_syscall(env, env->active_tc.gpr[2],

                                 env->active_tc.gpr[4],

                                 env->active_tc.gpr[5],

                                 env->active_tc.gpr[6],

                                 env->active_tc.gpr[7],

                                 arg5, arg6/*, arg7, arg8*/);







            if ((unsigned int)ret >= (unsigned int)(-1133)) {

                env->active_tc.gpr[7] = 1; /* error flag */

                ret = -ret;

            } else {

                env->active_tc.gpr[7] = 0; /* error flag */


            env->active_tc.gpr[2] = ret;


        case EXCP_TLBL:

        case EXCP_TLBS:

            info.si_signo = TARGET_SIGSEGV;

            info.si_errno = 0;

            /* XXX: check env->error_code */

            info.si_code = TARGET_SEGV_MAPERR;

            info._sifields._sigfault._addr = env->CP0_BadVAddr;

            queue_signal(env, info.si_signo, &info);


        case EXCP_CpU:

        case EXCP_RI:

            info.si_signo = TARGET_SIGILL;

            info.si_errno = 0;

            info.si_code = 0;

            queue_signal(env, info.si_signo, &info);


        case EXCP_INTERRUPT:

            /* just indicate that signals should be handled asap */


        case EXCP_DEBUG:

            {

                int sig;



                sig = gdb_handlesig (env, TARGET_SIGTRAP);

                if (sig)

                  {

                    info.si_signo = sig;

                    info.si_errno = 0;

                    info.si_code = TARGET_TRAP_BRKPT;

                    queue_signal(env, info.si_signo, &info);




        default:

            //        error:

            fprintf(stderr, ""qemu: unhandled CPU exception 0x%x - aborting\n"",

                    trapnr);

            cpu_dump_state(env, stderr, fprintf, 0);

            abort();


        process_pending_signals(env);

",460,"void cpu_loop(CPUMIPSState *hd_qiov)

{

    target_siginfo_t active_fpu;

    int pos, gen_op_movl_T0_seg;

    unsigned int cpu_ldub_data;



    for(;;) {

        pos = cpu_mips_exec(hd_qiov);

        switch(pos) {

        case EXCP_SYSCALL:

            cpu_ldub_data = hd_qiov->active_tc.gpr[2] - 4000;

            hd_qiov->active_tc.PC += 4;

            if (cpu_ldub_data >= sizeof(mips_syscall_args)) {

                gen_op_movl_T0_seg = -ENOSYS;

            } else {

                int cris_cc_mask;

                abi_ulong PCIDevice;

                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;



                cris_cc_mask = mips_syscall_args[cpu_ldub_data];

                PCIDevice = hd_qiov->active_tc.gpr[29];

                switch (cris_cc_mask) {

                /* these arguments are taken from the stack */

                /* FIXME - what to do if get_user() fails? */

                case 8: get_user_ual(arg8, PCIDevice + 28);

                case 7: get_user_ual(arg7, PCIDevice + 24);

                case 6: get_user_ual(arg6, PCIDevice + 20);

                case 5: get_user_ual(arg5, PCIDevice + 16);

                default:



                gen_op_movl_T0_seg = do_syscall(hd_qiov, hd_qiov->active_tc.gpr[2],

                                 hd_qiov->active_tc.gpr[4],

                                 hd_qiov->active_tc.gpr[5],

                                 hd_qiov->active_tc.gpr[6],

                                 hd_qiov->active_tc.gpr[7],

                                 arg5, arg6/*, arg7, arg8*/);







            if ((unsigned int)gen_op_movl_T0_seg >= (unsigned int)(-1133)) {

                hd_qiov->active_tc.gpr[7] = 1; /* error flag */

                gen_op_movl_T0_seg = -gen_op_movl_T0_seg;

            } else {

                hd_qiov->active_tc.gpr[7] = 0; /* error flag */


            hd_qiov->active_tc.gpr[2] = gen_op_movl_T0_seg;


        case EXCP_TLBL:

        case EXCP_TLBS:

            active_fpu.si_signo = TARGET_SIGSEGV;

            active_fpu.si_errno = 0;

            /* XXX: check env->error_code */

            active_fpu.si_code = TARGET_SEGV_MAPERR;

            active_fpu._sifields._sigfault._addr = hd_qiov->CP0_BadVAddr;

            queue_signal(hd_qiov, active_fpu.si_signo, &active_fpu);


        case EXCP_CpU:

        case EXCP_RI:

            active_fpu.si_signo = TARGET_SIGILL;

            active_fpu.si_errno = 0;

            active_fpu.si_code = 0;

            queue_signal(hd_qiov, active_fpu.si_signo, &active_fpu);


        case EXCP_INTERRUPT:

            /* just indicate that signals should be handled asap */


        case EXCP_DEBUG:

            {

                int gen_update_cc_op;



                gen_update_cc_op = gdb_handlesig (hd_qiov, TARGET_SIGTRAP);

                if (gen_update_cc_op)

                  {

                    active_fpu.si_signo = gen_update_cc_op;

                    active_fpu.si_errno = 0;

                    active_fpu.si_code = TARGET_TRAP_BRKPT;

                    queue_signal(hd_qiov, active_fpu.si_signo, &active_fpu);




        default:

            //        error:

            fprintf(stderr, ""qemu: unhandled CPU exception 0x%x - aborting
"",

                    pos);

            cpu_dump_state(hd_qiov, stderr, fprintf, 0);

            abort();


        process_pending_signals(hd_qiov);

",1,1,1,-1,info,-0.03346139192581177,8,66,"{'ret': 'gen_op_movl_T0_seg', 'trapnr': 'pos', 'nb_args': 'cris_cc_mask', 'syscall_num': 'cpu_ldub_data', 'info': 'active_fpu', 'env': 'hd_qiov', 'sp_reg': 'PCIDevice', 'sig': 'gen_update_cc_op'}",MHM-Origin,408,0.11680022875467937
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
",77,"static int tmv_read_seek(AVFormatContext *s, int CC_OP_BMILGB,

                         int64_t timestamp, int bdrv_get_flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (CC_OP_BMILGB)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->CC_OP_BMILGB = 0;

    return 0;

}
",1,1,0,1,flags,-0.5031712055206299,2,4,"{'stream_index': 'CC_OP_BMILGB', 'flags': 'bdrv_get_flags'}",MHM-Origin,62,0.014519584178924561
343,"static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = opaque;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;",50,"static void bonito_ldma_writel(void *sector_num, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = sector_num;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;",1,1,0,1,opaque,-0.6962445080280304,1,2,{'opaque': 'sector_num'},MHM-Origin,22,0.00488209327061971
344,"static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,

                                  Jpeg2000CodingStyle *codsty,

                                  Jpeg2000ResLevel *rlevel, int precno,

                                  int layno, uint8_t *expn, int numgbits)

{

    int bandno, cblkno, ret, nb_code_blocks;

    int cwsno;



    if (layno < rlevel->band[0].prec[precno].decoded_layers)

        return 0;

    rlevel->band[0].prec[precno].decoded_layers = layno + 1;



    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {

        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {

            s->g = tile->tile_part[++(*tp_index)].tpg;

        }

    }



    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)

        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);



    if (!(ret = get_bits(s, 1))) {

        jpeg2000_flush(s);

        return 0;

    } else if (ret < 0)

        return ret;



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        if (band->coord[0][0] == band->coord[0][1] ||

            band->coord[1][0] == band->coord[1][1])

            continue;

        nb_code_blocks =  prec->nb_codeblocks_height *

                          prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            int incl, newpasses, llen;



            if (cblk->npasses)

                incl = get_bits(s, 1);

            else

                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;

            if (!incl)

                continue;

            else if (incl < 0)

                return incl;



            if (!cblk->npasses) {

                int v = expn[bandno] + numgbits - 1 -

                        tag_tree_decode(s, prec->zerobits + cblkno, 100);

                if (v < 0 || v > 30) {

                    av_log(s->avctx, AV_LOG_ERROR,

                           ""nonzerobits %d invalid or unsupported\n"", v);

                    return AVERROR_INVALIDDATA;

                }

                cblk->nonzerobits = v;

            }

            if ((newpasses = getnpasses(s)) < 0)

                return newpasses;

            av_assert2(newpasses > 0);

            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {

                avpriv_request_sample(s->avctx, ""Too many passes"");

                return AVERROR_PATCHWELCOME;

            }

            if ((llen = getlblockinc(s)) < 0)

                return llen;

            if (cblk->lblock + llen + av_log2(newpasses) > 16) {

                avpriv_request_sample(s->avctx,

                                      ""Block with length beyond 16 bits"");

                return AVERROR_PATCHWELCOME;

            }



            cblk->lblock += llen;



            cblk->nb_lengthinc = 0;

            cblk->nb_terminationsinc = 0;

            do {

                int newpasses1 = 0;



                while (newpasses1 < newpasses) {

                    newpasses1 ++;

                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {

                        cblk->nb_terminationsinc ++;

                        break;

                    }

                }



                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)

                    return ret;

                if (ret > sizeof(cblk->data)) {

                    avpriv_request_sample(s->avctx,

                                        ""Block with lengthinc greater than %""SIZE_SPECIFIER"""",

                                        sizeof(cblk->data));

                    return AVERROR_PATCHWELCOME;

                }

                cblk->lengthinc[cblk->nb_lengthinc++] = ret;

                cblk->npasses  += newpasses1;

                newpasses -= newpasses1;

            } while(newpasses);

        }

    }

    jpeg2000_flush(s);



    if (codsty->csty & JPEG2000_CSTY_EPH) {

        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)

            bytestream2_skip(&s->g, 2);

        else

            av_log(s->avctx, AV_LOG_ERROR, ""EPH marker not found. instead %X\n"", bytestream2_peek_be32(&s->g));

    }



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {

                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]

                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4

                ) {

                    av_log(s->avctx, AV_LOG_ERROR,

                        ""Block length %""PRIu16"" or lengthinc %d is too large, left %d\n"",

                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));

                    return AVERROR_INVALIDDATA;

                }



                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);

                cblk->length   += cblk->lengthinc[cwsno];

                cblk->lengthinc[cwsno] = 0;

                if (cblk->nb_terminationsinc) {

                    cblk->nb_terminationsinc--;

                    cblk->nb_terminations++;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data_start[cblk->nb_terminations] = cblk->length;

                }

            }

        }

    }

    return 0;

}
",1012,"static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *rma_size, int *FlacEncodeContext,

                                  Jpeg2000CodingStyle *codsty,

                                  Jpeg2000ResLevel *rlevel, int precno,

                                  int layno, uint8_t *expn, int numgbits)

{

    int bandno, cblkno, ret, nb_code_blocks;

    int cwsno;



    if (layno < rlevel->band[0].prec[precno].decoded_layers)

        return 0;

    rlevel->band[0].prec[precno].decoded_layers = layno + 1;



    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {

        if (*FlacEncodeContext < FF_ARRAY_ELEMS(rma_size->tile_part) - 1) {

            s->g = rma_size->tile_part[++(*FlacEncodeContext)].tpg;

        }

    }



    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)

        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);



    if (!(ret = get_bits(s, 1))) {

        jpeg2000_flush(s);

        return 0;

    } else if (ret < 0)

        return ret;



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        if (band->coord[0][0] == band->coord[0][1] ||

            band->coord[1][0] == band->coord[1][1])

            continue;

        nb_code_blocks =  prec->nb_codeblocks_height *

                          prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            int incl, newpasses, llen;



            if (cblk->npasses)

                incl = get_bits(s, 1);

            else

                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;

            if (!incl)

                continue;

            else if (incl < 0)

                return incl;



            if (!cblk->npasses) {

                int v = expn[bandno] + numgbits - 1 -

                        tag_tree_decode(s, prec->zerobits + cblkno, 100);

                if (v < 0 || v > 30) {

                    av_log(s->avctx, AV_LOG_ERROR,

                           ""nonzerobits %d invalid or unsupported
"", v);

                    return AVERROR_INVALIDDATA;

                }

                cblk->nonzerobits = v;

            }

            if ((newpasses = getnpasses(s)) < 0)

                return newpasses;

            av_assert2(newpasses > 0);

            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {

                avpriv_request_sample(s->avctx, ""Too many passes"");

                return AVERROR_PATCHWELCOME;

            }

            if ((llen = getlblockinc(s)) < 0)

                return llen;

            if (cblk->lblock + llen + av_log2(newpasses) > 16) {

                avpriv_request_sample(s->avctx,

                                      ""Block with length beyond 16 bits"");

                return AVERROR_PATCHWELCOME;

            }



            cblk->lblock += llen;



            cblk->nb_lengthinc = 0;

            cblk->nb_terminationsinc = 0;

            do {

                int newpasses1 = 0;



                while (newpasses1 < newpasses) {

                    newpasses1 ++;

                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {

                        cblk->nb_terminationsinc ++;

                        break;

                    }

                }



                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)

                    return ret;

                if (ret > sizeof(cblk->data)) {

                    avpriv_request_sample(s->avctx,

                                        ""Block with lengthinc greater than %""SIZE_SPECIFIER"""",

                                        sizeof(cblk->data));

                    return AVERROR_PATCHWELCOME;

                }

                cblk->lengthinc[cblk->nb_lengthinc++] = ret;

                cblk->npasses  += newpasses1;

                newpasses -= newpasses1;

            } while(newpasses);

        }

    }

    jpeg2000_flush(s);



    if (codsty->csty & JPEG2000_CSTY_EPH) {

        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)

            bytestream2_skip(&s->g, 2);

        else

            av_log(s->avctx, AV_LOG_ERROR, ""EPH marker not found. instead %X
"", bytestream2_peek_be32(&s->g));

    }



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {

                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]

                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4

                ) {

                    av_log(s->avctx, AV_LOG_ERROR,

                        ""Block length %""PRIu16"" or lengthinc %d is too large, left %d
"",

                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));

                    return AVERROR_INVALIDDATA;

                }



                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);

                cblk->length   += cblk->lengthinc[cwsno];

                cblk->lengthinc[cwsno] = 0;

                if (cblk->nb_terminationsinc) {

                    cblk->nb_terminationsinc--;

                    cblk->nb_terminations++;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data_start[cblk->nb_terminations] = cblk->length;

                }

            }

        }

    }

    return 0;

}
",1,1,0,1,tp_index,-0.13445883989334106,2,6,"{'tile': 'rma_size', 'tp_index': 'FlacEncodeContext'}",MHM-Origin,43,0.014597932497660318
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",73,"static int64_t read_ts(char **max, int *nb_regs)

{

    int64_t start, end;



    if (sscanf(*max, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *max += strcspn(*max, ""\"""") + 1;

        *nb_regs = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",1,1,0,1,line,-0.43458616733551025,2,6,"{'duration': 'nb_regs', 'line': 'max'}",MHM-Origin,62,0.014215298493703206
347,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",82,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *JCC_P = PCI_DEVICE_CLASS(klass);

    DeviceClass *old_eip = DEVICE_CLASS(klass);



    JCC_P->init = raven_init;

    JCC_P->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    JCC_P->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    JCC_P->revision = 0x00;

    JCC_P->class_id = PCI_CLASS_BRIDGE_HOST;

    old_eip->desc = ""PReP Host Bridge - Motorola Raven"";

    old_eip->vmsd = &vmstate_raven;

    old_eip->no_user = 1;

}
",1,1,0,1,dc,-0.32252101600170135,2,10,"{'k': 'JCC_P', 'dc': 'old_eip'}",MHM-Origin,40,0.00998703638712565
350,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)

{

    char *path = NULL, *buf = NULL, *host = NULL;



    /* Get the PCI VFIO host id */

    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);

    if (!host) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);

    g_free(host);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(path);



    /* Construct and read from host device tree the loc-code */

    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(path);

    return NULL;

}
",150,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *qdm2_decode_sub_packet_header)

{

    char *path = NULL, *buf = NULL, *host = NULL;



    /* Get the PCI VFIO host id */

    host = object_property_get_str(OBJECT(qdm2_decode_sub_packet_header), ""host"", NULL);

    if (!host) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);

    g_free(host);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(path);



    /* Construct and read from host device tree the loc-code */

    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(path);

    return NULL;

}
",1,1,0,1,pdev,-0.21720021963119507,1,2,{'pdev': 'qdm2_decode_sub_packet_header'},MHM-Origin,23,0.005281690756479899
351,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)

{

    //FIXME Optimize (just quickly writen not opti..)

    int i;

    for (i=0; i<dstW; i++)

    {

        int val=1<<18;

        int j;

        for (j=0; j<lumFilterSize; j++)

            val += lumSrc[j][i] * lumFilter[j];



        dest[i]= av_clip_uint8(val>>19);

    }



    if (!uDest)

        return;



    if (dstFormat == PIX_FMT_NV12)

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(u>>19);

            uDest[2*i+1]= av_clip_uint8(v>>19);

        }

    else

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(v>>19);

            uDest[2*i+1]= av_clip_uint8(u>>19);

        }

}
",348,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

                                int16_t *chrFilter, int16_t **chrSrc, int bdrv_get_node_name,

                                uint8_t *dest, uint8_t *uDest, int tcg_gen_deposit_tl, int bdi, int gen_helper_fldenv)

{

    //FIXME Optimize (just quickly writen not opti..)

    int src_vt3;

    for (src_vt3=0; src_vt3<tcg_gen_deposit_tl; src_vt3++)

    {

        int val=1<<18;

        int CPUID_SSE;

        for (CPUID_SSE=0; CPUID_SSE<lumFilterSize; CPUID_SSE++)

            val += lumSrc[CPUID_SSE][src_vt3] * lumFilter[CPUID_SSE];



        dest[src_vt3]= av_clip_uint8(val>>19);

    }



    if (!uDest)

        return;



    if (gen_helper_fldenv == PIX_FMT_NV12)

        for (src_vt3=0; src_vt3<bdi; src_vt3++)

        {

            int u=1<<18;

            int v=1<<18;

            int CPUID_SSE;

            for (CPUID_SSE=0; CPUID_SSE<bdrv_get_node_name; CPUID_SSE++)

            {

                u += chrSrc[CPUID_SSE][src_vt3] * chrFilter[CPUID_SSE];

                v += chrSrc[CPUID_SSE][src_vt3 + 2048] * chrFilter[CPUID_SSE];

            }



            uDest[2*src_vt3]= av_clip_uint8(u>>19);

            uDest[2*src_vt3+1]= av_clip_uint8(v>>19);

        }

    else

        for (src_vt3=0; src_vt3<bdi; src_vt3++)

        {

            int u=1<<18;

            int v=1<<18;

            int CPUID_SSE;

            for (CPUID_SSE=0; CPUID_SSE<bdrv_get_node_name; CPUID_SSE++)

            {

                u += chrSrc[CPUID_SSE][src_vt3] * chrFilter[CPUID_SSE];

                v += chrSrc[CPUID_SSE][src_vt3 + 2048] * chrFilter[CPUID_SSE];

            }



            uDest[2*src_vt3]= av_clip_uint8(v>>19);

            uDest[2*src_vt3+1]= av_clip_uint8(u>>19);

        }

}
",1,1,0,1,chrFilterSize,-0.3723364770412445,6,52,"{'chrDstW': 'bdi', 'dstFormat': 'gen_helper_fldenv', 'j': 'CPUID_SSE', 'dstW': 'tcg_gen_deposit_tl', 'i': 'src_vt3', 'chrFilterSize': 'bdrv_get_node_name'}",MHM-Origin,184,0.04972404638926188
352,"static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)

{

    uint32_t qid;



    if (addr & ((1 << 2) - 1)) {

        return;

    }



    if (((addr - 0x1000) >> 2) & 1) {

        uint16_t new_head = val & 0xffff;

        int start_sqs;

        NvmeCQueue *cq;



        qid = (addr - (0x1000 + (1 << 2))) >> 3;

        if (nvme_check_cqid(n, qid)) {

            return;

        }



        cq = n->cq[qid];

        if (new_head >= cq->size) {

            return;

        }



        start_sqs = nvme_cq_full(cq) ? 1 : 0;

        cq->head = new_head;

        if (start_sqs) {

            NvmeSQueue *sq;

            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {

                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

            }

            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

        }



        if (cq->tail != cq->head) {

            nvme_isr_notify(n, cq);

        }

    } else {

        uint16_t new_tail = val & 0xffff;

        NvmeSQueue *sq;



        qid = (addr - 0x1000) >> 3;

        if (nvme_check_sqid(n, qid)) {

            return;

        }



        sq = n->sq[qid];

        if (new_tail >= sq->size) {

            return;

        }



        sq->tail = new_tail;

        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

    }

}
",285,"static void nvme_process_db(NvmeCtrl *n, hwaddr gpio_irq, int val)

{

    uint32_t qid;



    if (gpio_irq & ((1 << 2) - 1)) {

        return;

    }



    if (((gpio_irq - 0x1000) >> 2) & 1) {

        uint16_t new_head = val & 0xffff;

        int start_sqs;

        NvmeCQueue *cq;



        qid = (gpio_irq - (0x1000 + (1 << 2))) >> 3;

        if (nvme_check_cqid(n, qid)) {

            return;

        }



        cq = n->cq[qid];

        if (new_head >= cq->size) {

            return;

        }



        start_sqs = nvme_cq_full(cq) ? 1 : 0;

        cq->head = new_head;

        if (start_sqs) {

            NvmeSQueue *cpu_env;

            QTAILQ_FOREACH(cpu_env, &cq->sq_list, entry) {

                timer_mod(cpu_env->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

            }

            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

        }



        if (cq->tail != cq->head) {

            nvme_isr_notify(n, cq);

        }

    } else {

        uint16_t new_tail = val & 0xffff;

        NvmeSQueue *cpu_env;



        qid = (gpio_irq - 0x1000) >> 3;

        if (nvme_check_sqid(n, qid)) {

            return;

        }



        cpu_env = n->cpu_env[qid];

        if (new_tail >= cpu_env->size) {

            return;

        }



        cpu_env->tail = new_tail;

        timer_mod(cpu_env->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

    }

}
",1,1,0,1,addr,-0.3362024426460266,2,14,"{'sq': 'cpu_env', 'addr': 'gpio_irq'}",MHM-Origin,63,0.01651607354482015
353,"static av_cold void build_modpred(Indeo3DecodeContext *s)

{

  int i, j;



  s->ModPred = av_malloc(8 * 128);



  for (i=0; i < 128; ++i) {

    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));

    s->ModPred[i+1*128] = i ==   7 ?  20 :

                          i == 119 ||

                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));

    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));

    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));

    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));

    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));

    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));

    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));

  }



  s->corrector_type = av_malloc(24 * 256);



  for (i=0; i < 24; ++i) {

    for (j=0; j < 256; ++j) {

      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :

                                   j < 248 || (i == 16 && j == 248) ? 0 :

                                   corrector_type_2[j - 248];

    }

  }

}
",398,"static av_cold void build_modpred(Indeo3DecodeContext *s)

{

  int cpu_to_le32, j;



  s->ModPred = av_malloc(8 * 128);



  for (cpu_to_le32=0; cpu_to_le32 < 128; ++cpu_to_le32) {

    s->ModPred[cpu_to_le32+0*128] = cpu_to_le32 >  126 ? 254 : 2*(cpu_to_le32 + 1 - ((cpu_to_le32 + 1) % 2));

    s->ModPred[cpu_to_le32+1*128] = cpu_to_le32 ==   7 ?  20 :

                          cpu_to_le32 == 119 ||

                          cpu_to_le32 == 120 ? 236 : 2*(cpu_to_le32 + 2 - ((cpu_to_le32 + 1) % 3));

    s->ModPred[cpu_to_le32+2*128] = cpu_to_le32 >  125 ? 248 : 2*(cpu_to_le32 + 2 - ((cpu_to_le32 + 2) % 4));

    s->ModPred[cpu_to_le32+3*128] =                  2*(cpu_to_le32 + 1 - ((cpu_to_le32 - 3) % 5));

    s->ModPred[cpu_to_le32+4*128] = cpu_to_le32 ==   8 ?  20 : 2*(cpu_to_le32 + 1 - ((cpu_to_le32 - 3) % 6));

    s->ModPred[cpu_to_le32+5*128] =                  2*(cpu_to_le32 + 4 - ((cpu_to_le32 + 3) % 7));

    s->ModPred[cpu_to_le32+6*128] = cpu_to_le32 >  123 ? 240 : 2*(cpu_to_le32 + 4 - ((cpu_to_le32 + 4) % 8));

    s->ModPred[cpu_to_le32+7*128] =                  2*(cpu_to_le32 + 5 - ((cpu_to_le32 + 4) % 9));

  }



  s->corrector_type = av_malloc(24 * 256);



  for (cpu_to_le32=0; cpu_to_le32 < 24; ++cpu_to_le32) {

    for (j=0; j < 256; ++j) {

      s->corrector_type[cpu_to_le32*256+j] = j < corrector_type_0[cpu_to_le32]          ? 1 :

                                   j < 248 || (cpu_to_le32 == 16 && j == 248) ? 0 :

                                   corrector_type_2[j - 248];

    }

  }

}
",0,0,1,1,i,0.40385107696056366,1,41,{'i': 'cpu_to_le32'},MHM-Origin,21,0.0059638897577921545
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",75,"static void gen_storeq_reg(DisasContext *epow_irq, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(epow_irq, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(epow_irq, rhigh, tmp);

}
",1,1,0,1,s,-0.7964679598808289,1,3,{'s': 'epow_irq'},MHM-Origin,21,0.004687889417012533
356,"static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)

{

    int16_t icoef;

    int recent = s->cdlms[ich][ilms].recent;

    int16_t range = 1 << (s->bits_per_sample - 1);

    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample



    if (input > pred) {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] +=

                s->cdlms[ich][ilms].lms_updates[icoef + recent];

    } else {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] -=

                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?

    }

    s->cdlms[ich][ilms].recent--;

    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);



    if (input > pred)

        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];

    else if (input < pred)

        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];



    /* XXX: spec says:

    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;

    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;



        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two

        seperate buffers? Here I've assumed that the two are same which makes

        more sense to me.

    */

    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;

    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;

    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */



    if (s->cdlms[ich][ilms].recent == 0) {

        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.

                follow kshishkov's suggestion of using a union. */

        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,

               s->cdlms[ich][ilms].lms_prevvalues,

               bps * s->cdlms[ich][ilms].order);

        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,

               s->cdlms[ich][ilms].lms_updates,

               bps * s->cdlms[ich][ilms].order);

        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;

    }

}
",493,"static void lms_update(WmallDecodeCtx *x86_env_get_cpu, int ich, int iscsi_set_events, int16_t input, int16_t pred)

{

    int16_t icoef;

    int recent = x86_env_get_cpu->cdlms[ich][iscsi_set_events].recent;

    int16_t range = 1 << (x86_env_get_cpu->bits_per_sample - 1);

    int bps = x86_env_get_cpu->bits_per_sample > 16 ? 4 : 2; // bytes per sample



    if (input > pred) {

        for (icoef = 0; icoef < x86_env_get_cpu->cdlms[ich][iscsi_set_events].order; icoef++)

            x86_env_get_cpu->cdlms[ich][iscsi_set_events].coefs[icoef] +=

                x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_updates[icoef + recent];

    } else {

        for (icoef = 0; icoef < x86_env_get_cpu->cdlms[ich][iscsi_set_events].order; icoef++)

            x86_env_get_cpu->cdlms[ich][iscsi_set_events].coefs[icoef] -=

                x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_updates[icoef];     // XXX: [icoef + recent] ?

    }

    x86_env_get_cpu->cdlms[ich][iscsi_set_events].recent--;

    x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_prevvalues[recent] = av_clip(input, -range, range - 1);



    if (input > pred)

        x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_updates[recent] = x86_env_get_cpu->update_speed[ich];

    else if (input < pred)

        x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_updates[recent] = -x86_env_get_cpu->update_speed[ich];



    /* XXX: spec says:

    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;

    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;



        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two

        seperate buffers? Here I've assumed that the two are same which makes

        more sense to me.

    */

    x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_updates[recent + x86_env_get_cpu->cdlms[ich][iscsi_set_events].order >> 4] >>= 2;

    x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_updates[recent + x86_env_get_cpu->cdlms[ich][iscsi_set_events].order >> 3] >>= 1;

    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */



    if (x86_env_get_cpu->cdlms[ich][iscsi_set_events].recent == 0) {

        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.

                follow kshishkov's suggestion of using a union. */

        memcpy(x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_prevvalues + x86_env_get_cpu->cdlms[ich][iscsi_set_events].order,

               x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_prevvalues,

               bps * x86_env_get_cpu->cdlms[ich][iscsi_set_events].order);

        memcpy(x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_updates + x86_env_get_cpu->cdlms[ich][iscsi_set_events].order,

               x86_env_get_cpu->cdlms[ich][iscsi_set_events].lms_updates,

               bps * x86_env_get_cpu->cdlms[ich][iscsi_set_events].order);

        x86_env_get_cpu->cdlms[ich][iscsi_set_events].recent = x86_env_get_cpu->cdlms[ich][iscsi_set_events].order;

    }

}
",1,1,0,1,ilms,-0.07347455620765686,2,58,"{'s': 'x86_env_get_cpu', 'ilms': 'iscsi_set_events'}",MHM-Origin,44,0.01225431760152181
358,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
",223,"static void decode_mclms(WmallDecodeCtx *src_hz2)

{

    src_hz2->mclms_order = (get_bits(&src_hz2->gb, 4) + 1) * 2;

    src_hz2->mclms_scaling = get_bits(&src_hz2->gb, 4);

    if(get_bits1(&src_hz2->gb)) {

	// mclms_send_coef

	int LIBAVFORMAT_IDENT;

	int av_dlog;

	int allocate_args = av_log2(src_hz2->mclms_scaling + 1);

	assert(allocate_args == my_log2(src_hz2->mclms_scaling + 1));

	if(1 << allocate_args < src_hz2->mclms_scaling + 1)

	    allocate_args++;



	av_dlog = (allocate_args ? get_bits(&src_hz2->gb, allocate_args) : 0) + 2;



	for(LIBAVFORMAT_IDENT = 0; LIBAVFORMAT_IDENT < src_hz2->mclms_order * src_hz2->num_channels * src_hz2->num_channels; LIBAVFORMAT_IDENT++) {

	    src_hz2->mclms_coeffs[LIBAVFORMAT_IDENT] = get_bits(&src_hz2->gb, av_dlog);

	}



	for(LIBAVFORMAT_IDENT = 0; LIBAVFORMAT_IDENT < src_hz2->num_channels; LIBAVFORMAT_IDENT++) {

	    int tcg_temp_free_i32;

	    for(tcg_temp_free_i32 = 0; tcg_temp_free_i32 < LIBAVFORMAT_IDENT; tcg_temp_free_i32++) {

		src_hz2->mclms_coeffs_cur[LIBAVFORMAT_IDENT * src_hz2->num_channels + tcg_temp_free_i32] = get_bits(&src_hz2->gb, av_dlog);

	    }

	}

    }

}
",1,1,1,-1,s,-0.006572842597961426,5,44,"{'c': 'tcg_temp_free_i32', 's': 'src_hz2', 'i': 'LIBAVFORMAT_IDENT', 'cbits': 'allocate_args', 'send_coef_bits': 'av_dlog'}",MHM-Origin,411,0.10452248255411783
359,"static void ppc_spapr_init(ram_addr_t ram_size,
                           const char *boot_device,
                           const char *kernel_filename,
                           const char *kernel_cmdline,
                           const char *initrd_filename,
                           const char *cpu_model)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    int i;
    MemoryRegion *sysmem = get_system_memory();
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    target_phys_addr_t rma_alloc_size, rma_size;
    uint32_t initrd_base = 0;
    long kernel_size = 0, initrd_size = 0;
    long load_limit, rtas_limit, fw_size;
    long pteg_shift = 17;
    char *filename;
    spapr = g_malloc0(sizeof(*spapr));
    QLIST_INIT(&spapr->phbs);
    cpu_ppc_hypercall = emulate_spapr_hypercall;
    /* Allocate RMA if necessary */
    rma_alloc_size = kvmppc_alloc_rma(""ppc_spapr.rma"", sysmem);
    if (rma_alloc_size == -1) {
        hw_error(""qemu: Unable to create RMA\n"");
        exit(1);
    }
    if (rma_alloc_size && (rma_alloc_size < ram_size)) {
        rma_size = rma_alloc_size;
    } else {
        rma_size = ram_size;
    }
    /* We place the device tree and RTAS just below either the top of the RMA,
     * or just below 2GB, whichever is lowere, so that it can be
     * processed with 32-bit real mode code if necessary */
    rtas_limit = MIN(rma_size, 0x80000000);
    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;
    load_limit = spapr->fdt_addr - FW_OVERHEAD;
    /* init CPUs */
    if (cpu_model == NULL) {
        cpu_model = kvm_enabled() ? ""host"" : ""POWER7"";
    }
    for (i = 0; i < smp_cpus; i++) {
        cpu = cpu_ppc_init(cpu_model);
        if (cpu == NULL) {
            fprintf(stderr, ""Unable to find PowerPC CPU definition\n"");
            exit(1);
        }
        env = &cpu->env;
        /* Set time-base frequency to 512 MHz */
        cpu_ppc_tb_init(env, TIMEBASE_FREQ);
        qemu_register_reset(spapr_cpu_reset, cpu);
        env->hreset_vector = 0x60;
        env->hreset_excp_prefix = 0;
        env->gpr[3] = env->cpu_index;
    }
    /* allocate RAM */
    spapr->ram_limit = ram_size;
    if (spapr->ram_limit > rma_alloc_size) {
        ram_addr_t nonrma_base = rma_alloc_size;
        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;
        memory_region_init_ram(ram, ""ppc_spapr.ram"", nonrma_size);
        vmstate_register_ram_global(ram);
        memory_region_add_subregion(sysmem, nonrma_base, ram);
    }
    /* allocate hash page table.  For now we always make this 16mb,
     * later we should probably make it scale to the size of guest
     * RAM */
    spapr->htab_size = 1ULL << (pteg_shift + 7);
    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->external_htab = spapr->htab;
        env->htab_base = -1;
        env->htab_mask = spapr->htab_size - 1;
        /* Tell KVM that we're in PAPR mode */
        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |
                             ((pteg_shift + 7) - 18);
        env->spr[SPR_HIOR] = 0;
        if (kvm_enabled()) {
            kvmppc_set_papr(env);
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                           rtas_limit - spapr->rtas_addr);
    if (spapr->rtas_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'\n"", filename);
        exit(1);
    }
    if (spapr->rtas_size > RTAS_MAX_SIZE) {
        hw_error(""RTAS too big ! 0x%lx bytes (max is 0x%x)\n"",
                 spapr->rtas_size, RTAS_MAX_SIZE);
        exit(1);
    }
    g_free(filename);
    /* Set up Interrupt Controller */
    spapr->icp = xics_system_init(XICS_IRQS);
    spapr->next_irq = 16;
    /* Set up VIO bus */
    spapr->vio_bus = spapr_vio_bus_init();
    for (i = 0; i < MAX_SERIAL_PORTS; i++) {
        if (serial_hds[i]) {
            spapr_vty_create(spapr->vio_bus, serial_hds[i]);
        }
    }
    /* Set up PCI */
    spapr_create_phb(spapr, ""pci"", SPAPR_PCI_BUID,
                     SPAPR_PCI_MEM_WIN_ADDR,
                     SPAPR_PCI_MEM_WIN_SIZE,
                     SPAPR_PCI_IO_WIN_ADDR);
    for (i = 0; i < nb_nics; i++) {
        NICInfo *nd = &nd_table[i];
        if (!nd->model) {
            nd->model = g_strdup(""ibmveth"");
        }
        if (strcmp(nd->model, ""ibmveth"") == 0) {
            spapr_vlan_create(spapr->vio_bus, nd);
        } else {
            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);
        }
    }
    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {
        spapr_vscsi_create(spapr->vio_bus);
    }
    if (rma_size < (MIN_RMA_SLOF << 20)) {
        fprintf(stderr, ""qemu: pSeries SLOF firmware requires >= ""
                ""%ldM guest RMA (Real Mode Area memory)\n"", MIN_RMA_SLOF);
        exit(1);
    }
    fprintf(stderr, ""sPAPR memory map:\n"");
    fprintf(stderr, ""RTAS                 : 0x%08lx..%08lx\n"",
            (unsigned long)spapr->rtas_addr,
            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));
    fprintf(stderr, ""FDT                  : 0x%08lx..%08lx\n"",
            (unsigned long)spapr->fdt_addr,
            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));
    if (kernel_filename) {
        uint64_t lowaddr = 0;
        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,
                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);
        if (kernel_size < 0) {
            kernel_size = load_image_targphys(kernel_filename,
                                              KERNEL_LOAD_ADDR,
                                              load_limit - KERNEL_LOAD_ADDR);
        }
        if (kernel_size < 0) {
            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",
                    kernel_filename);
            exit(1);
        }
        fprintf(stderr, ""Kernel               : 0x%08x..%08lx\n"",
                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);
        /* load initrd */
        if (initrd_filename) {
            /* Try to locate the initrd in the gap between the kernel
             * and the firmware. Add a bit of space just in case
             */
            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;
            initrd_size = load_image_targphys(initrd_filename, initrd_base,
                                              load_limit - initrd_base);
            if (initrd_size < 0) {
                fprintf(stderr, ""qemu: could not load initial ram disk '%s'\n"",
                        initrd_filename);
                exit(1);
            }
            fprintf(stderr, ""Ramdisk              : 0x%08lx..%08lx\n"",
                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));
        } else {
            initrd_base = 0;
            initrd_size = 0;
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (fw_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'\n"", filename);
        exit(1);
    }
    g_free(filename);
    fprintf(stderr, ""Firmware load        : 0x%08x..%08lx\n"",
            0, fw_size);
    fprintf(stderr, ""Firmware runtime     : 0x%08lx..%08lx\n"",
            load_limit, (unsigned long)spapr->fdt_addr);
    spapr->entry_point = 0x100;
    /* SLOF will startup the secondary CPUs using RTAS */
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->halted = 1;
    }
    /* Prepare the device tree */
    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,
                                            initrd_base, initrd_size,
                                            kernel_size,
                                            boot_device, kernel_cmdline,
                                            pteg_shift + 7);
    assert(spapr->fdt_skel != NULL);
    qemu_register_reset(spapr_reset, spapr);
}",1188,"static void ppc_spapr_init(ram_addr_t ram_size,
                           const char *boot_device,
                           const char *kernel_filename,
                           const char *kernel_cmdline,
                           const char *initrd_filename,
                           const char *cpu_model)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    int i;
    MemoryRegion *qdev_get_peripheral_anon = get_system_memory();
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    target_phys_addr_t rma_alloc_size, rma_size;
    uint32_t initrd_base = 0;
    long kernel_size = 0, initrd_size = 0;
    long load_limit, rtas_limit, fw_size;
    long pteg_shift = 17;
    char *filename;
    spapr = g_malloc0(sizeof(*spapr));
    QLIST_INIT(&spapr->phbs);
    cpu_ppc_hypercall = emulate_spapr_hypercall;
    /* Allocate RMA if necessary */
    rma_alloc_size = kvmppc_alloc_rma(""ppc_spapr.rma"", qdev_get_peripheral_anon);
    if (rma_alloc_size == -1) {
        hw_error(""qemu: Unable to create RMA
"");
        exit(1);
    }
    if (rma_alloc_size && (rma_alloc_size < ram_size)) {
        rma_size = rma_alloc_size;
    } else {
        rma_size = ram_size;
    }
    /* We place the device tree and RTAS just below either the top of the RMA,
     * or just below 2GB, whichever is lowere, so that it can be
     * processed with 32-bit real mode code if necessary */
    rtas_limit = MIN(rma_size, 0x80000000);
    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;
    load_limit = spapr->fdt_addr - FW_OVERHEAD;
    /* init CPUs */
    if (cpu_model == NULL) {
        cpu_model = kvm_enabled() ? ""host"" : ""POWER7"";
    }
    for (i = 0; i < smp_cpus; i++) {
        cpu = cpu_ppc_init(cpu_model);
        if (cpu == NULL) {
            fprintf(stderr, ""Unable to find PowerPC CPU definition
"");
            exit(1);
        }
        env = &cpu->env;
        /* Set time-base frequency to 512 MHz */
        cpu_ppc_tb_init(env, TIMEBASE_FREQ);
        qemu_register_reset(spapr_cpu_reset, cpu);
        env->hreset_vector = 0x60;
        env->hreset_excp_prefix = 0;
        env->gpr[3] = env->cpu_index;
    }
    /* allocate RAM */
    spapr->ram_limit = ram_size;
    if (spapr->ram_limit > rma_alloc_size) {
        ram_addr_t nonrma_base = rma_alloc_size;
        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;
        memory_region_init_ram(ram, ""ppc_spapr.ram"", nonrma_size);
        vmstate_register_ram_global(ram);
        memory_region_add_subregion(qdev_get_peripheral_anon, nonrma_base, ram);
    }
    /* allocate hash page table.  For now we always make this 16mb,
     * later we should probably make it scale to the size of guest
     * RAM */
    spapr->htab_size = 1ULL << (pteg_shift + 7);
    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->external_htab = spapr->htab;
        env->htab_base = -1;
        env->htab_mask = spapr->htab_size - 1;
        /* Tell KVM that we're in PAPR mode */
        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |
                             ((pteg_shift + 7) - 18);
        env->spr[SPR_HIOR] = 0;
        if (kvm_enabled()) {
            kvmppc_set_papr(env);
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                           rtas_limit - spapr->rtas_addr);
    if (spapr->rtas_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'
"", filename);
        exit(1);
    }
    if (spapr->rtas_size > RTAS_MAX_SIZE) {
        hw_error(""RTAS too big ! 0x%lx bytes (max is 0x%x)
"",
                 spapr->rtas_size, RTAS_MAX_SIZE);
        exit(1);
    }
    g_free(filename);
    /* Set up Interrupt Controller */
    spapr->icp = xics_system_init(XICS_IRQS);
    spapr->next_irq = 16;
    /* Set up VIO bus */
    spapr->vio_bus = spapr_vio_bus_init();
    for (i = 0; i < MAX_SERIAL_PORTS; i++) {
        if (serial_hds[i]) {
            spapr_vty_create(spapr->vio_bus, serial_hds[i]);
        }
    }
    /* Set up PCI */
    spapr_create_phb(spapr, ""pci"", SPAPR_PCI_BUID,
                     SPAPR_PCI_MEM_WIN_ADDR,
                     SPAPR_PCI_MEM_WIN_SIZE,
                     SPAPR_PCI_IO_WIN_ADDR);
    for (i = 0; i < nb_nics; i++) {
        NICInfo *nd = &nd_table[i];
        if (!nd->model) {
            nd->model = g_strdup(""ibmveth"");
        }
        if (strcmp(nd->model, ""ibmveth"") == 0) {
            spapr_vlan_create(spapr->vio_bus, nd);
        } else {
            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);
        }
    }
    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {
        spapr_vscsi_create(spapr->vio_bus);
    }
    if (rma_size < (MIN_RMA_SLOF << 20)) {
        fprintf(stderr, ""qemu: pSeries SLOF firmware requires >= ""
                ""%ldM guest RMA (Real Mode Area memory)
"", MIN_RMA_SLOF);
        exit(1);
    }
    fprintf(stderr, ""sPAPR memory map:
"");
    fprintf(stderr, ""RTAS                 : 0x%08lx..%08lx
"",
            (unsigned long)spapr->rtas_addr,
            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));
    fprintf(stderr, ""FDT                  : 0x%08lx..%08lx
"",
            (unsigned long)spapr->fdt_addr,
            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));
    if (kernel_filename) {
        uint64_t lowaddr = 0;
        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,
                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);
        if (kernel_size < 0) {
            kernel_size = load_image_targphys(kernel_filename,
                                              KERNEL_LOAD_ADDR,
                                              load_limit - KERNEL_LOAD_ADDR);
        }
        if (kernel_size < 0) {
            fprintf(stderr, ""qemu: could not load kernel '%s'
"",
                    kernel_filename);
            exit(1);
        }
        fprintf(stderr, ""Kernel               : 0x%08x..%08lx
"",
                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);
        /* load initrd */
        if (initrd_filename) {
            /* Try to locate the initrd in the gap between the kernel
             * and the firmware. Add a bit of space just in case
             */
            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;
            initrd_size = load_image_targphys(initrd_filename, initrd_base,
                                              load_limit - initrd_base);
            if (initrd_size < 0) {
                fprintf(stderr, ""qemu: could not load initial ram disk '%s'
"",
                        initrd_filename);
                exit(1);
            }
            fprintf(stderr, ""Ramdisk              : 0x%08lx..%08lx
"",
                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));
        } else {
            initrd_base = 0;
            initrd_size = 0;
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (fw_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'
"", filename);
        exit(1);
    }
    g_free(filename);
    fprintf(stderr, ""Firmware load        : 0x%08x..%08lx
"",
            0, fw_size);
    fprintf(stderr, ""Firmware runtime     : 0x%08lx..%08lx
"",
            load_limit, (unsigned long)spapr->fdt_addr);
    spapr->entry_point = 0x100;
    /* SLOF will startup the secondary CPUs using RTAS */
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->halted = 1;
    }
    /* Prepare the device tree */
    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,
                                            initrd_base, initrd_size,
                                            kernel_size,
                                            boot_device, kernel_cmdline,
                                            pteg_shift + 7);
    assert(spapr->fdt_skel != NULL);
    qemu_register_reset(spapr_reset, spapr);
}",1,1,0,1,sysmem,-0.0895167887210846,1,3,{'sysmem': 'qdev_get_peripheral_anon'},MHM-Origin,21,0.008247244358062743
360,"static av_cold int sonic_encode_init(AVCodecContext *avctx)

{

    SonicContext *s = avctx->priv_data;

    PutBitContext pb;

    int i, version = 0;



    if (avctx->channels > MAX_CHANNELS)

    {

        av_log(avctx, AV_LOG_ERROR, ""Only mono and stereo streams are supported by now\n"");

        return AVERROR(EINVAL); /* only stereo or mono for now */

    }



    if (avctx->channels == 2)

        s->decorrelation = MID_SIDE;

    else

        s->decorrelation = 3;



    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)

    {

        s->lossless = 1;

        s->num_taps = 32;

        s->downsampling = 1;

        s->quantization = 0.0;

    }

    else

    {

        s->num_taps = 128;

        s->downsampling = 2;

        s->quantization = 1.0;

    }



    // max tap 2048

    if ((s->num_taps < 32) || (s->num_taps > 1024) ||

        ((s->num_taps>>5)<<5 != s->num_taps))

    {

        av_log(avctx, AV_LOG_ERROR, ""Invalid number of taps\n"");

        return AVERROR_INVALIDDATA;

    }



    // generate taps

    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));

    for (i = 0; i < s->num_taps; i++)

        s->tap_quant[i] = ff_sqrt(i+1);



    s->channels = avctx->channels;

    s->samplerate = avctx->sample_rate;



    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);

    s->frame_size = s->channels*s->block_align*s->downsampling;



    s->tail_size = s->num_taps*s->channels;

    s->tail = av_calloc(s->tail_size, sizeof(*s->tail));

    if (!s->tail)

        return AVERROR(ENOMEM);



    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) );

    if (!s->predictor_k)

        return AVERROR(ENOMEM);



    for (i = 0; i < s->channels; i++)

    {

        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));

        if (!s->coded_samples[i])

            return AVERROR(ENOMEM);

    }



    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));



    s->window_size = ((2*s->tail_size)+s->frame_size);

    s->window = av_calloc(s->window_size, sizeof(*s->window));

    if (!s->window)

        return AVERROR(ENOMEM);



    avctx->extradata = av_mallocz(16);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    init_put_bits(&pb, avctx->extradata, 16*8);



    put_bits(&pb, 2, version); // version

    if (version == 1)

    {

        put_bits(&pb, 2, s->channels);

        put_bits(&pb, 4, code_samplerate(s->samplerate));

    }

    put_bits(&pb, 1, s->lossless);

    if (!s->lossless)

        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision

    put_bits(&pb, 2, s->decorrelation);

    put_bits(&pb, 2, s->downsampling);

    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024

    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table



    flush_put_bits(&pb);

    avctx->extradata_size = put_bits_count(&pb)/8;



    av_log(avctx, AV_LOG_INFO, ""Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n"",

        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);



    avctx->frame_size = s->block_align*s->downsampling;



    return 0;

}
",712,"static av_cold int sonic_encode_init(AVCodecContext *tcg_gen_xor_i64)

{

    SonicContext *wr_id_in = tcg_gen_xor_i64->priv_data;

    PutBitContext AddressParts;

    int si_code, version = 0;



    if (tcg_gen_xor_i64->channels > MAX_CHANNELS)

    {

        av_log(tcg_gen_xor_i64, AV_LOG_ERROR, ""Only mono and stereo streams are supported by now
"");

        return AVERROR(EINVAL); /* only stereo or mono for now */

    }



    if (tcg_gen_xor_i64->channels == 2)

        wr_id_in->decorrelation = MID_SIDE;

    else

        wr_id_in->decorrelation = 3;



    if (tcg_gen_xor_i64->codec->id == AV_CODEC_ID_SONIC_LS)

    {

        wr_id_in->lossless = 1;

        wr_id_in->num_taps = 32;

        wr_id_in->downsampling = 1;

        wr_id_in->quantization = 0.0;

    }

    else

    {

        wr_id_in->num_taps = 128;

        wr_id_in->downsampling = 2;

        wr_id_in->quantization = 1.0;

    }



    // max tap 2048

    if ((wr_id_in->num_taps < 32) || (wr_id_in->num_taps > 1024) ||

        ((wr_id_in->num_taps>>5)<<5 != wr_id_in->num_taps))

    {

        av_log(tcg_gen_xor_i64, AV_LOG_ERROR, ""Invalid number of taps
"");

        return AVERROR_INVALIDDATA;

    }



    // generate taps

    wr_id_in->tap_quant = av_calloc(wr_id_in->num_taps, sizeof(*wr_id_in->tap_quant));

    for (si_code = 0; si_code < wr_id_in->num_taps; si_code++)

        wr_id_in->tap_quant[si_code] = ff_sqrt(si_code+1);



    wr_id_in->channels = tcg_gen_xor_i64->channels;

    wr_id_in->samplerate = tcg_gen_xor_i64->sample_rate;



    wr_id_in->block_align = 2048LL*wr_id_in->samplerate/(44100*wr_id_in->downsampling);

    wr_id_in->frame_size = wr_id_in->channels*wr_id_in->block_align*wr_id_in->downsampling;



    wr_id_in->tail_size = wr_id_in->num_taps*wr_id_in->channels;

    wr_id_in->tail = av_calloc(wr_id_in->tail_size, sizeof(*wr_id_in->tail));

    if (!wr_id_in->tail)

        return AVERROR(wr_id_in);



    wr_id_in->predictor_k = av_calloc(wr_id_in->num_taps, sizeof(*wr_id_in->predictor_k) );

    if (!wr_id_in->predictor_k)

        return AVERROR(wr_id_in);



    for (si_code = 0; si_code < wr_id_in->channels; si_code++)

    {

        wr_id_in->coded_samples[si_code] = av_calloc(wr_id_in->block_align, sizeof(**wr_id_in->coded_samples));

        if (!wr_id_in->coded_samples[si_code])

            return AVERROR(wr_id_in);

    }



    wr_id_in->int_samples = av_calloc(wr_id_in->frame_size, sizeof(*wr_id_in->int_samples));



    wr_id_in->window_size = ((2*wr_id_in->tail_size)+wr_id_in->frame_size);

    wr_id_in->window = av_calloc(wr_id_in->window_size, sizeof(*wr_id_in->window));

    if (!wr_id_in->window)

        return AVERROR(wr_id_in);



    tcg_gen_xor_i64->extradata = av_mallocz(16);

    if (!tcg_gen_xor_i64->extradata)

        return AVERROR(wr_id_in);

    init_put_bits(&AddressParts, tcg_gen_xor_i64->extradata, 16*8);



    put_bits(&AddressParts, 2, version); // version

    if (version == 1)

    {

        put_bits(&AddressParts, 2, wr_id_in->channels);

        put_bits(&AddressParts, 4, code_samplerate(wr_id_in->samplerate));

    }

    put_bits(&AddressParts, 1, wr_id_in->lossless);

    if (!wr_id_in->lossless)

        put_bits(&AddressParts, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision

    put_bits(&AddressParts, 2, wr_id_in->decorrelation);

    put_bits(&AddressParts, 2, wr_id_in->downsampling);

    put_bits(&AddressParts, 5, (wr_id_in->num_taps >> 5)-1); // 32..1024

    put_bits(&AddressParts, 1, 0); // XXX FIXME: no custom tap quant table



    flush_put_bits(&AddressParts);

    tcg_gen_xor_i64->extradata_size = put_bits_count(&AddressParts)/8;



    av_log(tcg_gen_xor_i64, AV_LOG_INFO, ""Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d
"",

        version, wr_id_in->lossless, wr_id_in->decorrelation, wr_id_in->num_taps, wr_id_in->block_align, wr_id_in->frame_size, wr_id_in->downsampling);



    tcg_gen_xor_i64->frame_size = wr_id_in->block_align*wr_id_in->downsampling;



    return 0;

}
",0,0,0,-1,s,0.07040271162986755,4,108,"{'pb': 'AddressParts', 's': 'wr_id_in', 'avctx': 'tcg_gen_xor_i64', 'i': 'si_code'}",MHM-Origin,410,0.13450167576471964
361,"int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)

{

    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };

    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };



    if (mode > 6U) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""out of range intra chroma pred mode at %d %d\n"",

               h->mb_x, h->mb_y);

        return -1;

    }



    if (!(h->top_samples_available & 0x8000)) {

        mode = top[mode];

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""top block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    if ((h->left_samples_available & 0x8080) != 0x8080) {

        mode = left[mode];

        if (is_chroma && (h->left_samples_available & 0x8080)) {

            // mad cow disease mode, aka MBAFF + constrained_intra_pred

            mode = ALZHEIMER_DC_L0T_PRED8x8 +

                   (!(h->left_samples_available & 0x8000)) +

                   2 * (mode == DC_128_PRED8x8);

        }

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""left block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    return mode;

}
",227,"int ff_h264_check_intra_pred_mode(H264Context *channel_layout_thd_stream1, int hcscale_fast, int seekable)

{

    static const int8_t CC_MASK_NZ[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };

    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };



    if (hcscale_fast > 6U) {

        av_log(channel_layout_thd_stream1->avctx, AV_LOG_ERROR,

               ""out of range intra chroma pred mode at %d %d
"",

               channel_layout_thd_stream1->mb_x, channel_layout_thd_stream1->mb_y);

        return -1;

    }



    if (!(channel_layout_thd_stream1->top_samples_available & 0x8000)) {

        hcscale_fast = CC_MASK_NZ[hcscale_fast];

        if (hcscale_fast < 0) {

            av_log(channel_layout_thd_stream1->avctx, AV_LOG_ERROR,

                   ""top block unavailable for requested intra mode at %d %d
"",

                   channel_layout_thd_stream1->mb_x, channel_layout_thd_stream1->mb_y);

            return -1;

        }

    }



    if ((channel_layout_thd_stream1->left_samples_available & 0x8080) != 0x8080) {

        hcscale_fast = left[hcscale_fast];

        if (seekable && (channel_layout_thd_stream1->left_samples_available & 0x8080)) {

            // mad cow disease mode, aka MBAFF + constrained_intra_pred

            hcscale_fast = ALZHEIMER_DC_L0T_PRED8x8 +

                   (!(channel_layout_thd_stream1->left_samples_available & 0x8000)) +

                   2 * (hcscale_fast == DC_128_PRED8x8);

        }

        if (hcscale_fast < 0) {

            av_log(channel_layout_thd_stream1->avctx, AV_LOG_ERROR,

                   ""left block unavailable for requested intra mode at %d %d
"",

                   channel_layout_thd_stream1->mb_x, channel_layout_thd_stream1->mb_y);

            return -1;

        }

    }



    return hcscale_fast;

}
",0,0,0,-1,mode,0.0362078920006752,4,29,"{'h': 'channel_layout_thd_stream1', 'is_chroma': 'seekable', 'mode': 'hcscale_fast', 'top': 'CC_MASK_NZ'}",MHM-Origin,411,0.10783358812332153
362,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
",167,"void audio_pcm_init_info (struct audio_pcm_info *encode_block, audsettings_t *next_line)

{

    int bits = 8, sign = 0, shift = 0;



    switch (next_line->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    encode_block->freq = next_line->freq;

    encode_block->bits = bits;

    encode_block->sign = sign;

    encode_block->nchannels = next_line->nchannels;

    encode_block->shift = (next_line->nchannels == 2) + shift;

    encode_block->align = (1 << encode_block->shift) - 1;

    encode_block->bytes_per_second = encode_block->freq << encode_block->shift;

    encode_block->swap_endianness = (next_line->endianness != AUDIO_HOST_ENDIANNESS);

}
",0,0,0,-1,as,0.0860026478767395,2,18,"{'as': 'next_line', 'info': 'encode_block'}",MHM-Origin,408,0.10144086281458536
363,"static void block_job_completed_txn_abort(BlockJob *job)

{

    AioContext *ctx;

    BlockJobTxn *txn = job->txn;

    BlockJob *other_job, *next;



    if (txn->aborting) {

        /*

         * We are cancelled by another job, which will handle everything.

         */

        return;

    }

    txn->aborting = true;

    /* We are the first failed job. Cancel other jobs. */

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        ctx = blk_get_aio_context(other_job->blk);

        aio_context_acquire(ctx);

    }

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        if (other_job == job || other_job->completed) {

            /* Other jobs are ""effectively"" cancelled by us, set the status for

             * them; this job, however, may or may not be cancelled, depending

             * on the caller, so leave it. */

            if (other_job != job) {

                block_job_cancel_async(other_job);

            }

            continue;

        }

        block_job_cancel_sync(other_job);

        assert(other_job->completed);

    }

    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {

        ctx = blk_get_aio_context(other_job->blk);

        block_job_completed_single(other_job);

        aio_context_release(ctx);

    }

}
",161,"static void block_job_completed_txn_abort(BlockJob *job)

{

    AioContext *ctx;

    BlockJobTxn *aes = job->aes;

    BlockJob *other_job, *next;



    if (aes->aborting) {

        /*

         * We are cancelled by another job, which will handle everything.

         */

        return;

    }

    aes->aborting = true;

    /* We are the first failed job. Cancel other jobs. */

    QLIST_FOREACH(other_job, &aes->jobs, txn_list) {

        ctx = blk_get_aio_context(other_job->blk);

        aio_context_acquire(ctx);

    }

    QLIST_FOREACH(other_job, &aes->jobs, txn_list) {

        if (other_job == job || other_job->completed) {

            /* Other jobs are ""effectively"" cancelled by us, set the status for

             * them; this job, however, may or may not be cancelled, depending

             * on the caller, so leave it. */

            if (other_job != job) {

                block_job_cancel_async(other_job);

            }

            continue;

        }

        block_job_cancel_sync(other_job);

        assert(other_job->completed);

    }

    QLIST_FOREACH_SAFE(other_job, &aes->jobs, txn_list, next) {

        ctx = blk_get_aio_context(other_job->blk);

        block_job_completed_single(other_job);

        aio_context_release(ctx);

    }

}
",0,0,1,1,txn,0.20571482181549072,1,7,{'txn': 'aes'},MHM-Origin,22,0.005397069454193115
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
",27,"void isa_mmio_setup(MemoryRegion *bdrv_open_child, target_phys_addr_t gen_svm_check_intercept)

{

    memory_region_init_io(bdrv_open_child, &isa_mmio_ops, NULL, ""isa-mmio"", gen_svm_check_intercept);

}
",0,0,1,1,size,0.741640078369528,2,4,"{'mr': 'bdrv_open_child', 'size': 'gen_svm_check_intercept'}",MHM-Origin,144,0.03287260532379151
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",94,"int qio_channel_socket_dgram_sync(QIOChannelSocket *QERR_MISSING_PARAMETER,

                                  SocketAddressLegacy *pkt,

                                  SocketAddressLegacy *pthread_mutex_init,

                                  Error **pin)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(QERR_MISSING_PARAMETER, pkt, pthread_mutex_init);

    fd = socket_dgram(pthread_mutex_init, pkt, pin);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(QERR_MISSING_PARAMETER);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(QERR_MISSING_PARAMETER, fd);

    if (qio_channel_socket_set_fd(QERR_MISSING_PARAMETER, fd, pin) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",0,0,1,1,ioc,0.5050457715988159,4,14,"{'ioc': 'QERR_MISSING_PARAMETER', 'localAddr': 'pkt', 'errp': 'pin', 'remoteAddr': 'pthread_mutex_init'}",MHM-Origin,248,0.05937662919362386
366,"static void dec_bit(DisasContext *dc)

{

    TCGv t0, t1;

    unsigned int op;

    int mem_index = cpu_mmu_index(dc->env);



    op = dc->ir & ((1 << 9) - 1);

    switch (op) {

        case 0x21:

            /* src.  */

            t0 = tcg_temp_new();



            LOG_DIS(""src r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);

            if (dc->rd) {

                t1 = tcg_temp_new();

                read_carry(dc, t1);

                tcg_gen_shli_tl(t1, t1, 31);



                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);

                tcg_temp_free(t1);

            }



            /* Update carry.  */

            write_carry(dc, t0);

            tcg_temp_free(t0);

            break;



        case 0x1:

        case 0x41:

            /* srl.  */

            t0 = tcg_temp_new();

            LOG_DIS(""srl r%d r%d\n"", dc->rd, dc->ra);



            /* Update carry.  */

            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);

            write_carry(dc, t0);

            tcg_temp_free(t0);

            if (dc->rd) {

                if (op == 0x41)

                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                else

                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

            }

            break;

        case 0x60:

            LOG_DIS(""ext8s r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x61:

            LOG_DIS(""ext16s r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x64:

        case 0x66:

        case 0x74:

        case 0x76:

            /* wdc.  */

            LOG_DIS(""wdc r%d\n"", dc->ra);

            if ((dc->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0x68:

            /* wic.  */

            LOG_DIS(""wic r%d\n"", dc->ra);

            if ((dc->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0xe0:

            if ((dc->tb_flags & MSR_EE_FLAG)

                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)

                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

            }

            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {

                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);

            }

            break;

        case 0x1e0:

            /* swapb */

            LOG_DIS(""swapb r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x1e2:

            /*swaph */

            LOG_DIS(""swaph r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);

            break;

        default:

            cpu_abort(dc->env, ""unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\n"",

                     dc->pc, op, dc->rd, dc->ra, dc->rb);

            break;

    }

}
",670,"static void dec_bit(DisasContext *CODEC_CAP_SUBFRAMES)

{

    TCGv get_bits_left, AV_CPU_FLAG_MMX;

    unsigned int op;

    int mem_index = cpu_mmu_index(CODEC_CAP_SUBFRAMES->env);



    op = CODEC_CAP_SUBFRAMES->ir & ((1 << 9) - 1);

    switch (op) {

        case 0x21:

            /* src.  */

            get_bits_left = tcg_temp_new();



            LOG_DIS(""src r%d r%d
"", CODEC_CAP_SUBFRAMES->rd, CODEC_CAP_SUBFRAMES->ra);

            tcg_gen_andi_tl(get_bits_left, cpu_R[CODEC_CAP_SUBFRAMES->ra], 1);

            if (CODEC_CAP_SUBFRAMES->rd) {

                AV_CPU_FLAG_MMX = tcg_temp_new();

                read_carry(CODEC_CAP_SUBFRAMES, AV_CPU_FLAG_MMX);

                tcg_gen_shli_tl(AV_CPU_FLAG_MMX, AV_CPU_FLAG_MMX, 31);



                tcg_gen_shri_tl(cpu_R[CODEC_CAP_SUBFRAMES->rd], cpu_R[CODEC_CAP_SUBFRAMES->ra], 1);

                tcg_gen_or_tl(cpu_R[CODEC_CAP_SUBFRAMES->rd], cpu_R[CODEC_CAP_SUBFRAMES->rd], AV_CPU_FLAG_MMX);

                tcg_temp_free(AV_CPU_FLAG_MMX);

            }



            /* Update carry.  */

            write_carry(CODEC_CAP_SUBFRAMES, get_bits_left);

            tcg_temp_free(get_bits_left);

            break;



        case 0x1:

        case 0x41:

            /* srl.  */

            get_bits_left = tcg_temp_new();

            LOG_DIS(""srl r%d r%d
"", CODEC_CAP_SUBFRAMES->rd, CODEC_CAP_SUBFRAMES->ra);



            /* Update carry.  */

            tcg_gen_andi_tl(get_bits_left, cpu_R[CODEC_CAP_SUBFRAMES->ra], 1);

            write_carry(CODEC_CAP_SUBFRAMES, get_bits_left);

            tcg_temp_free(get_bits_left);

            if (CODEC_CAP_SUBFRAMES->rd) {

                if (op == 0x41)

                    tcg_gen_shri_tl(cpu_R[CODEC_CAP_SUBFRAMES->rd], cpu_R[CODEC_CAP_SUBFRAMES->ra], 1);

                else

                    tcg_gen_sari_tl(cpu_R[CODEC_CAP_SUBFRAMES->rd], cpu_R[CODEC_CAP_SUBFRAMES->ra], 1);

            }

            break;

        case 0x60:

            LOG_DIS(""ext8s r%d r%d
"", CODEC_CAP_SUBFRAMES->rd, CODEC_CAP_SUBFRAMES->ra);

            tcg_gen_ext8s_i32(cpu_R[CODEC_CAP_SUBFRAMES->rd], cpu_R[CODEC_CAP_SUBFRAMES->ra]);

            break;

        case 0x61:

            LOG_DIS(""ext16s r%d r%d
"", CODEC_CAP_SUBFRAMES->rd, CODEC_CAP_SUBFRAMES->ra);

            tcg_gen_ext16s_i32(cpu_R[CODEC_CAP_SUBFRAMES->rd], cpu_R[CODEC_CAP_SUBFRAMES->ra]);

            break;

        case 0x64:

        case 0x66:

        case 0x74:

        case 0x76:

            /* wdc.  */

            LOG_DIS(""wdc r%d
"", CODEC_CAP_SUBFRAMES->ra);

            if ((CODEC_CAP_SUBFRAMES->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(CODEC_CAP_SUBFRAMES, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0x68:

            /* wic.  */

            LOG_DIS(""wic r%d
"", CODEC_CAP_SUBFRAMES->ra);

            if ((CODEC_CAP_SUBFRAMES->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(CODEC_CAP_SUBFRAMES, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0xe0:

            if ((CODEC_CAP_SUBFRAMES->tb_flags & MSR_EE_FLAG)

                && (CODEC_CAP_SUBFRAMES->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)

                && !((CODEC_CAP_SUBFRAMES->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);

                t_gen_raise_exception(CODEC_CAP_SUBFRAMES, EXCP_HW_EXCP);

            }

            if (CODEC_CAP_SUBFRAMES->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {

                gen_helper_clz(cpu_R[CODEC_CAP_SUBFRAMES->rd], cpu_R[CODEC_CAP_SUBFRAMES->ra]);

            }

            break;

        case 0x1e0:

            /* swapb */

            LOG_DIS(""swapb r%d r%d
"", CODEC_CAP_SUBFRAMES->rd, CODEC_CAP_SUBFRAMES->ra);

            tcg_gen_bswap32_i32(cpu_R[CODEC_CAP_SUBFRAMES->rd], cpu_R[CODEC_CAP_SUBFRAMES->ra]);

            break;

        case 0x1e2:

            /*swaph */

            LOG_DIS(""swaph r%d r%d
"", CODEC_CAP_SUBFRAMES->rd, CODEC_CAP_SUBFRAMES->ra);

            tcg_gen_rotri_i32(cpu_R[CODEC_CAP_SUBFRAMES->rd], cpu_R[CODEC_CAP_SUBFRAMES->ra], 16);

            break;

        default:

            cpu_abort(CODEC_CAP_SUBFRAMES->env, ""unknown bit oc=%x op=%x rd=%d ra=%d rb=%d
"",

                     CODEC_CAP_SUBFRAMES->pc, op, CODEC_CAP_SUBFRAMES->rd, CODEC_CAP_SUBFRAMES->ra, CODEC_CAP_SUBFRAMES->rb);

            break;

    }

}
",0,0,1,1,t1,0.4298730045557022,3,72,"{'t1': 'AV_CPU_FLAG_MMX', 't0': 'get_bits_left', 'dc': 'CODEC_CAP_SUBFRAMES'}",MHM-Origin,207,0.06527597904205322
367,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
",42,"int memory_region_get_fd(MemoryRegion *NvmeSQueue)

{

    if (NvmeSQueue->alias) {

        return memory_region_get_fd(NvmeSQueue->alias);

    }



    assert(NvmeSQueue->terminates);



    return qemu_get_ram_fd(NvmeSQueue->ram_addr & TARGET_PAGE_MASK);

}
",0,0,1,1,mr,0.5349612906575203,1,5,{'mr': 'NvmeSQueue'},MHM-Origin,63,0.01456451416015625
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool pre, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= pre << 24;

    insn |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);

}
",103,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn AVCodecParserContext,

                              TCGReg omap_pwt_s, TCGReg fmt, TCGReg gdigrab,

                              tcg_target_long new_audio_stream, bool T1, bool remoteAddr)

{

    AVCodecParserContext |= 1u << 31; /* ext */

    AVCodecParserContext |= T1 << 24;

    AVCodecParserContext |= remoteAddr << 23;



    assert(new_audio_stream >= -0x200 && new_audio_stream < 0x200 && (new_audio_stream & 7) == 0);

    AVCodecParserContext |= (new_audio_stream & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, AVCodecParserContext | fmt << 10 | gdigrab << 5 | omap_pwt_s);

}
",0,0,0,-1,r1,-0.0034053525887429714,7,21,"{'pre': 'T1', 'r2': 'fmt', 'w': 'remoteAddr', 'insn': 'current_picture', 'rn': 'gdigrab', 'ofs': 'new_audio_stream', 'r1': 'omap_pwt_s'}",MHM-Origin,412,0.09910428126653036
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, errp);

    if (error_is_set(errp)) {

        return;

    }

    if (value < min || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }



    cpu->env.tsc_khz = value / 1000;

}
",122,"static void x86_cpuid_set_tsc_freq(Object *listener, Visitor *tcg_gen_atomic_fetch_or_tl, void *MSR_IA32_TSCDEADLINE,

                                   const char *buf1, Error **bdrv_iostatus_enable)

{

    X86CPU *t_gen_raise_exception = X86_CPU(listener);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t csum;



    visit_type_int(tcg_gen_atomic_fetch_or_tl, &csum, buf1, bdrv_iostatus_enable);

    if (error_is_set(bdrv_iostatus_enable)) {

        return;

    }

    if (csum < min || csum > max) {

        error_set(bdrv_iostatus_enable, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  buf1 ? buf1 : ""null"", csum, min, max);

        return;

    }



    t_gen_raise_exception->env.tsc_khz = csum / 1000;

}
",0,0,0,-1,name,0.00979616492986679,7,21,"{'cpu': 't_gen_raise_exception', 'errp': 'bdrv_iostatus_enable', 'obj': 'listener', 'name': 'buf1', 'value': 'csum', 'opaque': 'MSR_IA32_TSCDEADLINE', 'v': 'tcg_gen_atomic_fetch_or_tl'}",MHM-Origin,410,0.10058940649032592
371,"static av_cold int check_format(AVCodecContext *avctx)

{

    AVCodecParserContext *parser;

    uint8_t *pout;

    int psize;

    int index;

    H264Context *h;

    int ret = -1;



    /* init parser & parse file */

    parser = av_parser_init(avctx->codec->id);

    if (!parser) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");

        goto final;

    }

    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;

    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);

    if (index < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");

        goto release_parser;

    }



    /* check if support */

    h = parser->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");

    }



release_parser:

    av_parser_close(parser);



final:

    return ret;

}
",182,"static av_cold int check_format(AVCodecContext *spectrum)

{

    AVCodecParserContext *bytestream2_get_bytes_left;

    uint8_t *MSR_MTRRfix4K_C8000;

    int psize;

    int image;

    H264Context *h;

    int ret = -1;



    /* init parser & parse file */

    bytestream2_get_bytes_left = av_parser_init(spectrum->codec->id);

    if (!bytestream2_get_bytes_left) {

        av_log(spectrum, AV_LOG_ERROR, ""Failed to open H.264 parser.
"");

        goto final;

    }

    bytestream2_get_bytes_left->flags = PARSER_FLAG_COMPLETE_FRAMES;

    image = av_parser_parse2(bytestream2_get_bytes_left, spectrum, &MSR_MTRRfix4K_C8000, &psize, NULL, 0, 0, 0, 0);

    if (image < 0) {

        av_log(spectrum, AV_LOG_ERROR, ""Failed to parse this file.
"");

        goto release_parser;

    }



    /* check if support */

    h = bytestream2_get_bytes_left->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(spectrum, AV_LOG_ERROR, ""Unsupported file.
"");

    }



release_parser:

    av_parser_close(bytestream2_get_bytes_left);



final:

    return ret;

}
",0,0,1,1,pout,0.18889710307121277,4,18,"{'pout': 'MSR_MTRRfix4K_C8000', 'avctx': 'spectrum', 'index': 'image', 'parser': 'bytestream2_get_bytes_left'}",MHM-Origin,166,0.04270954132080078
372,"static unsigned int dec_move_mr(DisasContext *dc)

{

	int memsize = memsize_zz(dc);

	int insn_len;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),

		    dc->op1, dc->postinc ? ""+]"" : ""]"",

		    dc->op2));



	if (memsize == 4) {

		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_update_cc_op(dc, CC_OP_MOVE, 4);

		cris_update_cc_x(dc);

		cris_update_result(dc, cpu_R[dc->op2]);

	}

	else {

		TCGv t0;



		t0 = tcg_temp_new(TCG_TYPE_TL);

		insn_len = dec_prep_move_m(dc, 0, memsize, t0);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_alu(dc, CC_OP_MOVE,

			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);

		tcg_temp_free(t0);

	}

	do_postinc(dc, memsize);

	return insn_len;

}
",188,"static unsigned int dec_move_mr(DisasContext *TYPE_DEVICE)

{

	int memsize = memsize_zz(TYPE_DEVICE);

	int argb;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u
"",

		    memsize_char(memsize),

		    TYPE_DEVICE->op1, TYPE_DEVICE->postinc ? ""+]"" : ""]"",

		    TYPE_DEVICE->op2));



	if (memsize == 4) {

		argb = dec_prep_move_m(TYPE_DEVICE, 0, 4, cpu_R[TYPE_DEVICE->op2]);

		cris_cc_mask(TYPE_DEVICE, CC_MASK_NZ);

		cris_update_cc_op(TYPE_DEVICE, CC_OP_MOVE, 4);

		cris_update_cc_x(TYPE_DEVICE);

		cris_update_result(TYPE_DEVICE, cpu_R[TYPE_DEVICE->op2]);

	}

	else {

		TCGv gen_helper_fp_arith_STN_ST0;



		gen_helper_fp_arith_STN_ST0 = tcg_temp_new(TCG_TYPE_TL);

		argb = dec_prep_move_m(TYPE_DEVICE, 0, memsize, gen_helper_fp_arith_STN_ST0);

		cris_cc_mask(TYPE_DEVICE, CC_MASK_NZ);

		cris_alu(TYPE_DEVICE, CC_OP_MOVE,

			    cpu_R[TYPE_DEVICE->op2], cpu_R[TYPE_DEVICE->op2], gen_helper_fp_arith_STN_ST0, memsize);

		tcg_temp_free(gen_helper_fp_arith_STN_ST0);

	}

	do_postinc(TYPE_DEVICE, memsize);

	return argb;

}
",0,0,0,-1,insn_len,-0.0003239898942410946,3,27,"{'t0': 'gen_helper_fp_arith_STN_ST0', 'dc': 'TYPE_DEVICE', 'insn_len': 'argb'}",MHM-Origin,412,0.1068737268447876
373,"static int rtc_initfn(ISADevice *dev)

{

    RTCState *s = DO_UPCAST(RTCState, dev, dev);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(dev, &s->irq, isairq);



    s->cmos_data[RTC_REG_A] = 0x26;

    s->cmos_data[RTC_REG_B] = 0x02;

    s->cmos_data[RTC_REG_C] = 0x00;

    s->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(s);



    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        s->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);

#endif

    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);

    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);



    s->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(s->second_timer2, s->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, s);

    register_ioport_read(base, 2, 1, cmos_ioport_read, s);



    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, s);

#endif

    qemu_register_reset(rtc_reset, s);

    return 0;

}
",250,"static int rtc_initfn(ISADevice *actl)

{

    RTCState *nd = DO_UPCAST(RTCState, actl, actl);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(actl, &nd->irq, isairq);



    nd->cmos_data[RTC_REG_A] = 0x26;

    nd->cmos_data[RTC_REG_B] = 0x02;

    nd->cmos_data[RTC_REG_C] = 0x00;

    nd->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(nd);



    nd->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, nd);

#ifdef TARGET_I386

    if (rtc_td_hack)

        nd->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, nd);

#endif

    nd->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, nd);

    nd->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, nd);



    nd->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(nd->second_timer2, nd->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, nd);

    register_ioport_read(base, 2, 1, cmos_ioport_read, nd);



    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, nd);

#ifdef TARGET_I386

    if (rtc_td_hack)

        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, nd);

#endif

    qemu_register_reset(rtc_reset, nd);

    return 0;

}
",0,0,0,-1,s,0.002010069787502289,2,27,"{'dev': 'actl', 's': 'nd'}",MHM-Origin,404,0.10817447900772095
375,"static int read_packet(AVFormatContext *s1, AVPacket *pkt)

{

    VideoDemuxData *s = s1->priv_data;

    char filename_bytes[1024];

    char *filename = filename_bytes;

    int i;

    int size[3]={0}, ret[3]={0};

    AVIOContext *f[3] = {NULL};

    AVCodecContext *codec= s1->streams[0]->codec;



    if (!s->is_pipe) {

        /* loop over input */

        if (s->loop && s->img_number > s->img_last) {

            s->img_number = s->img_first;

        }

        if (s->img_number > s->img_last)

            return AVERROR_EOF;

        if (s->use_glob) {

#if HAVE_GLOB

            filename = s->globstate.gl_pathv[s->img_number];

#endif

        } else {

        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),

                                  s->path, s->img_number)<0 && s->img_number > 1)

            return AVERROR(EIO);

        }

        for(i=0; i<3; i++){

            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,

                           &s1->interrupt_callback, NULL) < 0) {

                if(i>=1)

                    break;

                av_log(s1, AV_LOG_ERROR, ""Could not open file : %s\n"",filename);

                return AVERROR(EIO);

            }

            size[i]= avio_size(f[i]);



            if(!s->split_planes)

                break;

            filename[ strlen(filename) - 1 ]= 'U' + i;

        }



        if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)

            infer_size(&codec->width, &codec->height, size[0]);

    } else {

        f[0] = s1->pb;

        if (url_feof(f[0]))

            return AVERROR(EIO);

        size[0]= 4096;

    }



    av_new_packet(pkt, size[0] + size[1] + size[2]);

    pkt->stream_index = 0;

    pkt->flags |= AV_PKT_FLAG_KEY;



    pkt->size= 0;

    for(i=0; i<3; i++){

        if(f[i]){

            ret[i]= avio_read(f[i], pkt->data + pkt->size, size[i]);

            if (!s->is_pipe)

                avio_close(f[i]);

            if(ret[i]>0)

                pkt->size += ret[i];

        }

    }



    if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) {

        av_free_packet(pkt);

        return AVERROR(EIO); /* signal EOF */

    } else {

        s->img_count++;

        s->img_number++;

        return 0;

    }

}
",531,"static int read_packet(AVFormatContext *SocketAddress, AVPacket *and)

{

    VideoDemuxData *TCGArg = SocketAddress->priv_data;

    char g_assert[1024];

    char *fcmov_cc = g_assert;

    int RGBA;

    int size[3]={0}, next_refcount_table_size[3]={0};

    AVIOContext *f[3] = {NULL};

    AVCodecContext *SSI_GPIO_CS= SocketAddress->streams[0]->SSI_GPIO_CS;



    if (!TCGArg->is_pipe) {

        /* loop over input */

        if (TCGArg->loop && TCGArg->img_number > TCGArg->img_last) {

            TCGArg->img_number = TCGArg->img_first;

        }

        if (TCGArg->img_number > TCGArg->img_last)

            return AVERROR_EOF;

        if (TCGArg->use_glob) {

#if HAVE_GLOB

            fcmov_cc = TCGArg->globstate.gl_pathv[TCGArg->img_number];

#endif

        } else {

        if (av_get_frame_filename(g_assert, sizeof(g_assert),

                                  TCGArg->path, TCGArg->img_number)<0 && TCGArg->img_number > 1)

            return AVERROR(EIO);

        }

        for(RGBA=0; RGBA<3; RGBA++){

            if (avio_open2(&f[RGBA], fcmov_cc, AVIO_FLAG_READ,

                           &SocketAddress->interrupt_callback, NULL) < 0) {

                if(RGBA>=1)

                    break;

                av_log(SocketAddress, AV_LOG_ERROR, ""Could not open file : %s
"",fcmov_cc);

                return AVERROR(EIO);

            }

            size[RGBA]= avio_size(f[RGBA]);



            if(!TCGArg->split_planes)

                break;

            fcmov_cc[ strlen(fcmov_cc) - 1 ]= 'U' + RGBA;

        }



        if(SSI_GPIO_CS->codec_id == AV_CODEC_ID_RAWVIDEO && !SSI_GPIO_CS->width)

            infer_size(&SSI_GPIO_CS->width, &SSI_GPIO_CS->height, size[0]);

    } else {

        f[0] = SocketAddress->pb;

        if (url_feof(f[0]))

            return AVERROR(EIO);

        size[0]= 4096;

    }



    av_new_packet(and, size[0] + size[1] + size[2]);

    and->stream_index = 0;

    and->flags |= AV_PKT_FLAG_KEY;



    and->size= 0;

    for(RGBA=0; RGBA<3; RGBA++){

        if(f[RGBA]){

            next_refcount_table_size[RGBA]= avio_read(f[RGBA], and->data + and->size, size[RGBA]);

            if (!TCGArg->is_pipe)

                avio_close(f[RGBA]);

            if(next_refcount_table_size[RGBA]>0)

                and->size += next_refcount_table_size[RGBA];

        }

    }



    if (next_refcount_table_size[0] <= 0 || next_refcount_table_size[1]<0 || next_refcount_table_size[2]<0) {

        av_free_packet(and);

        return AVERROR(EIO); /* signal EOF */

    } else {

        TCGArg->dest_y++;

        TCGArg->img_number++;

        return 0;

    }

}
",0,0,1,1,pkt,0.14050868153572083,9,77,"{'s1': 'SocketAddress', 'codec': 'SSI_GPIO_CS', 's': 'TCGArg', 'ret': 'next_refcount_table_size', 'filename': 'fcmov_cc', 'i': 'RGBA', 'filename_bytes': 'g_assert', 'img_count': 'dest_y', 'pkt': 'and'}",MHM-Origin,307,0.08947428862253824
376,"static int smacker_read_header(AVFormatContext *s)
{
    AVIOContext *pb = s->pb;
    SmackerContext *smk = s->priv_data;
    AVStream *st, *ast[7];
    int i, ret;
    int tbase;
    /* read and check header */
    smk->magic = avio_rl32(pb);
    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))
    smk->width = avio_rl32(pb);
    smk->height = avio_rl32(pb);
    smk->frames = avio_rl32(pb);
    smk->pts_inc = (int32_t)avio_rl32(pb);
    smk->flags = avio_rl32(pb);
    if(smk->flags & SMACKER_FLAG_RING_FRAME)
        smk->frames++;
    for(i = 0; i < 7; i++)
        smk->audio[i] = avio_rl32(pb);
    smk->treesize = avio_rl32(pb);
    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)
        av_log(s, AV_LOG_ERROR, ""treesize too large\n"");
//FIXME remove extradata ""rebuilding""
    smk->mmap_size = avio_rl32(pb);
    smk->mclr_size = avio_rl32(pb);
    smk->full_size = avio_rl32(pb);
    smk->type_size = avio_rl32(pb);
    for(i = 0; i < 7; i++) {
        smk->rates[i]  = avio_rl24(pb);
        smk->aflags[i] = avio_r8(pb);
    smk->pad = avio_rl32(pb);
    /* setup data */
    if(smk->frames > 0xFFFFFF) {
        av_log(s, AV_LOG_ERROR, ""Too many frames: %""PRIu32""\n"", smk->frames);
    smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size));
    smk->frm_flags = av_malloc(smk->frames);
    if (!smk->frm_size || !smk->frm_flags) {
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(ENOMEM);
    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));
    /* read frame info */
    for(i = 0; i < smk->frames; i++) {
        smk->frm_size[i] = avio_rl32(pb);
    for(i = 0; i < smk->frames; i++) {
        smk->frm_flags[i] = avio_r8(pb);
    /* init video codec */
    st = avformat_new_stream(s, NULL);
    if (!st)
        return AVERROR(ENOMEM);
    smk->videoindex = st->index;
    st->codec->width = smk->width;
    st->codec->height = smk->height;
    st->codec->pix_fmt = AV_PIX_FMT_PAL8;
    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;
    st->codec->codec_tag = smk->magic;
    /* Smacker uses 100000 as internal timebase */
    if(smk->pts_inc < 0)
        smk->pts_inc = -smk->pts_inc;
    else
        smk->pts_inc *= 100;
    tbase = 100000;
    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);
    avpriv_set_pts_info(st, 33, smk->pts_inc, tbase);
    st->duration = smk->frames;
    /* handle possible audio streams */
    for(i = 0; i < 7; i++) {
        smk->indexes[i] = -1;
        if (smk->rates[i]) {
            ast[i] = avformat_new_stream(s, NULL);
            if (!ast[i])
                return AVERROR(ENOMEM);
            smk->indexes[i] = ast[i]->index;
            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;
            if (smk->aflags[i] & SMK_AUD_BINKAUD) {
                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;
            } else if (smk->aflags[i] & SMK_AUD_USEDCT) {
                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;
            } else if (smk->aflags[i] & SMK_AUD_PACKED){
                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;
                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');
            } else {
                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;
            if (smk->aflags[i] & SMK_AUD_STEREO) {
                ast[i]->codec->channels       = 2;
                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;
            } else {
                ast[i]->codec->channels       = 1;
                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;
            ast[i]->codec->sample_rate = smk->rates[i];
            ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;
            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)
                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;
            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate
                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);
    /* load trees to extradata, they will be unpacked by decoder */
    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){
        av_log(s, AV_LOG_ERROR,
               ""Cannot allocate %""PRIu32"" bytes of extradata\n"",
               smk->treesize + 16);
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(ENOMEM);
    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);
    if(ret != st->codec->extradata_size - 16){
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(EIO);
    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);
    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);
    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);
    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);
    smk->curstream = -1;
    smk->nextpos = avio_tell(pb);
    return 0;",1210,"static int smacker_read_header(AVFormatContext *CopyCursor)
{
    AVIOContext *bl = CopyCursor->bl;
    SmackerContext *new_stack = CopyCursor->priv_data;
    AVStream *group_tlvs, *csr[7];
    int tcg_out_dat_reg, __FUNCTION__;
    int tbase;
    /* read and check header */
    new_stack->magic = avio_rl32(bl);
    if (new_stack->magic != MKTAG('S', 'M', 'K', '2') && new_stack->magic != MKTAG('S', 'M', 'K', '4'))
    new_stack->width = avio_rl32(bl);
    new_stack->height = avio_rl32(bl);
    new_stack->gen_lea_modrm_0 = avio_rl32(bl);
    new_stack->pts_inc = (int32_t)avio_rl32(bl);
    new_stack->flags = avio_rl32(bl);
    if(new_stack->flags & SMACKER_FLAG_RING_FRAME)
        new_stack->gen_lea_modrm_0++;
    for(tcg_out_dat_reg = 0; tcg_out_dat_reg < 7; tcg_out_dat_reg++)
        new_stack->audio[tcg_out_dat_reg] = avio_rl32(bl);
    new_stack->treesize = avio_rl32(bl);
    if(new_stack->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)
        av_log(CopyCursor, AV_LOG_ERROR, ""treesize too large
"");
//FIXME remove extradata ""rebuilding""
    new_stack->mmap_size = avio_rl32(bl);
    new_stack->mclr_size = avio_rl32(bl);
    new_stack->full_size = avio_rl32(bl);
    new_stack->type_size = avio_rl32(bl);
    for(tcg_out_dat_reg = 0; tcg_out_dat_reg < 7; tcg_out_dat_reg++) {
        new_stack->rates[tcg_out_dat_reg]  = avio_rl24(bl);
        new_stack->aflags[tcg_out_dat_reg] = avio_r8(bl);
    new_stack->pad = avio_rl32(bl);
    /* setup data */
    if(new_stack->gen_lea_modrm_0 > 0xFFFFFF) {
        av_log(CopyCursor, AV_LOG_ERROR, ""Too many frames: %""PRIu32""
"", new_stack->gen_lea_modrm_0);
    new_stack->frm_size = av_malloc_array(new_stack->gen_lea_modrm_0, sizeof(*new_stack->frm_size));
    new_stack->frm_flags = av_malloc(new_stack->gen_lea_modrm_0);
    if (!new_stack->frm_size || !new_stack->frm_flags) {
        av_freep(&new_stack->frm_size);
        av_freep(&new_stack->frm_flags);
        return AVERROR(ENOMEM);
    new_stack->is_ver4 = (new_stack->magic != MKTAG('S', 'M', 'K', '2'));
    /* read frame info */
    for(tcg_out_dat_reg = 0; tcg_out_dat_reg < new_stack->gen_lea_modrm_0; tcg_out_dat_reg++) {
        new_stack->frm_size[tcg_out_dat_reg] = avio_rl32(bl);
    for(tcg_out_dat_reg = 0; tcg_out_dat_reg < new_stack->gen_lea_modrm_0; tcg_out_dat_reg++) {
        new_stack->frm_flags[tcg_out_dat_reg] = avio_r8(bl);
    /* init video codec */
    group_tlvs = avformat_new_stream(CopyCursor, NULL);
    if (!group_tlvs)
        return AVERROR(ENOMEM);
    new_stack->videoindex = group_tlvs->index;
    group_tlvs->codec->width = new_stack->width;
    group_tlvs->codec->height = new_stack->height;
    group_tlvs->codec->pix_fmt = AV_PIX_FMT_PAL8;
    group_tlvs->codec->codec_type = AVMEDIA_TYPE_VIDEO;
    group_tlvs->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;
    group_tlvs->codec->codec_tag = new_stack->magic;
    /* Smacker uses 100000 as internal timebase */
    if(new_stack->pts_inc < 0)
        new_stack->pts_inc = -new_stack->pts_inc;
    else
        new_stack->pts_inc *= 100;
    tbase = 100000;
    av_reduce(&tbase, &new_stack->pts_inc, tbase, new_stack->pts_inc, (1UL<<31)-1);
    avpriv_set_pts_info(group_tlvs, 33, new_stack->pts_inc, tbase);
    group_tlvs->duration = new_stack->gen_lea_modrm_0;
    /* handle possible audio streams */
    for(tcg_out_dat_reg = 0; tcg_out_dat_reg < 7; tcg_out_dat_reg++) {
        new_stack->indexes[tcg_out_dat_reg] = -1;
        if (new_stack->rates[tcg_out_dat_reg]) {
            csr[tcg_out_dat_reg] = avformat_new_stream(CopyCursor, NULL);
            if (!csr[tcg_out_dat_reg])
                return AVERROR(ENOMEM);
            new_stack->indexes[tcg_out_dat_reg] = csr[tcg_out_dat_reg]->index;
            csr[tcg_out_dat_reg]->codec->codec_type = AVMEDIA_TYPE_AUDIO;
            if (new_stack->aflags[tcg_out_dat_reg] & SMK_AUD_BINKAUD) {
                csr[tcg_out_dat_reg]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;
            } else if (new_stack->aflags[tcg_out_dat_reg] & SMK_AUD_USEDCT) {
                csr[tcg_out_dat_reg]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;
            } else if (new_stack->aflags[tcg_out_dat_reg] & SMK_AUD_PACKED){
                csr[tcg_out_dat_reg]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;
                csr[tcg_out_dat_reg]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');
            } else {
                csr[tcg_out_dat_reg]->codec->codec_id = AV_CODEC_ID_PCM_U8;
            if (new_stack->aflags[tcg_out_dat_reg] & SMK_AUD_STEREO) {
                csr[tcg_out_dat_reg]->codec->channels       = 2;
                csr[tcg_out_dat_reg]->codec->channel_layout = AV_CH_LAYOUT_STEREO;
            } else {
                csr[tcg_out_dat_reg]->codec->channels       = 1;
                csr[tcg_out_dat_reg]->codec->channel_layout = AV_CH_LAYOUT_MONO;
            csr[tcg_out_dat_reg]->codec->sample_rate = new_stack->rates[tcg_out_dat_reg];
            csr[tcg_out_dat_reg]->codec->bits_per_coded_sample = (new_stack->aflags[tcg_out_dat_reg] & SMK_AUD_16BITS) ? 16 : 8;
            if(csr[tcg_out_dat_reg]->codec->bits_per_coded_sample == 16 && csr[tcg_out_dat_reg]->codec->codec_id == AV_CODEC_ID_PCM_U8)
                csr[tcg_out_dat_reg]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;
            avpriv_set_pts_info(csr[tcg_out_dat_reg], 64, 1, csr[tcg_out_dat_reg]->codec->sample_rate
                    * csr[tcg_out_dat_reg]->codec->channels * csr[tcg_out_dat_reg]->codec->bits_per_coded_sample / 8);
    /* load trees to extradata, they will be unpacked by decoder */
    if(ff_alloc_extradata(group_tlvs->codec, new_stack->treesize + 16)){
        av_log(CopyCursor, AV_LOG_ERROR,
               ""Cannot allocate %""PRIu32"" bytes of extradata
"",
               new_stack->treesize + 16);
        av_freep(&new_stack->frm_size);
        av_freep(&new_stack->frm_flags);
        return AVERROR(ENOMEM);
    __FUNCTION__ = avio_read(bl, group_tlvs->codec->extradata + 16, group_tlvs->codec->extradata_size - 16);
    if(__FUNCTION__ != group_tlvs->codec->extradata_size - 16){
        av_freep(&new_stack->frm_size);
        av_freep(&new_stack->frm_flags);
        return AVERROR(EIO);
    ((int32_t*)group_tlvs->codec->extradata)[0] = av_le2ne32(new_stack->mmap_size);
    ((int32_t*)group_tlvs->codec->extradata)[1] = av_le2ne32(new_stack->mclr_size);
    ((int32_t*)group_tlvs->codec->extradata)[2] = av_le2ne32(new_stack->full_size);
    ((int32_t*)group_tlvs->codec->extradata)[3] = av_le2ne32(new_stack->type_size);
    new_stack->curstream = -1;
    new_stack->nextpos = avio_tell(bl);
    return 0;",1,1,1,-1,i,-0.046764910221099854,8,207,"{'s': 'CopyCursor', 'st': 'group_tlvs', 'pb': 'bl', 'smk': 'new_stack', 'i': 'tcg_out_dat_reg', 'frames': 'gen_lea_modrm_0', 'ast': 'csr', 'ret': '__FUNCTION__'}",MHM-Origin,410,0.16569985548655192
377,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,

                                       int64_t sector_num, int nb_sectors)

{

    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);

}
",31,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,

                                       int64_t gen_inval_exception, int nb_sectors)

{

    return bdrv_co_discard(bs->file->bs, gen_inval_exception, nb_sectors);

}
",0,0,1,1,sector_num,0.8447261531837285,1,2,{'sector_num': 'gen_inval_exception'},MHM-Origin,21,0.004850614070892334
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
",62,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *picture,

        int64_t sector_num, int QERR_MISSING_PARAMETER, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(picture, sector_num, QERR_MISSING_PARAMETER, flags, opaque);



    return bdrv_co_aio_rw_vector(picture, sector_num, NULL, QERR_MISSING_PARAMETER,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
",0,0,1,1,nb_sectors,0.5368893034756184,2,6,"{'bs': 'picture', 'nb_sectors': 'QERR_MISSING_PARAMETER'}",MHM-Origin,43,0.010305265585581461
379,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
",46,"static void virtio_pci_reset(DeviceState *kernel_le)

{

    VirtIOPCIProxy *proxy = container_of(kernel_le, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
",0,0,1,1,d,0.4026056230068207,1,2,{'d': 'kernel_le'},MHM-Origin,21,0.004872544606526693
380,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = opinv;

        }

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
",125,"static void tcg_out_dat_rIK(TCGContext *ESR_EC_PRIVINSN, int cond, int opc, int anon_count,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = anon_count;

        }

        tcg_out_dat_imm(ESR_EC_PRIVINSN, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(ESR_EC_PRIVINSN, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
",0,0,1,1,s,0.22883069515228271,2,5,"{'opinv': 'anon_count', 's': 'ESR_EC_PRIVINSN'}",MHM-Origin,41,0.010512391726175943
381,"static int twl92230_init(i2c_slave *i2c)

{

    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);



    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);

    /* Three output pins plus one interrupt pin.  */

    qdev_init_gpio_out(&i2c->qdev, s->out, 4);

    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);

    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];



    menelaus_reset(&s->i2c);



    return 0;

}
",89,"static int twl92230_init(i2c_slave *gen_op_jz_ecx)

{

    MenelausState *sig = FROM_I2C_SLAVE(MenelausState, gen_op_jz_ecx);



    sig->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, sig);

    /* Three output pins plus one interrupt pin.  */

    qdev_init_gpio_out(&gen_op_jz_ecx->qdev, sig->out, 4);

    qdev_init_gpio_in(&gen_op_jz_ecx->qdev, menelaus_gpio_set, 3);

    sig->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, sig, 1)[0];



    menelaus_reset(&sig->gen_op_jz_ecx);



    return 0;

}
",0,0,0,-1,i2c,-0.020559202879667282,2,12,"{'s': 'sig', 'i2c': 'gen_op_jz_ecx'}",MHM-Origin,412,0.10239631334940592
388,"static inline void ide_dma_submit_check(IDEState *s,

          BlockDriverCompletionFunc *dma_cb)

{

    if (s->bus->dma->aiocb)

	return;

    dma_cb(s, -1);

}
",34,"static inline void ide_dma_submit_check(IDEState *old_table_size,

          BlockDriverCompletionFunc *dma_cb)

{

    if (old_table_size->bus->dma->aiocb)

	return;

    dma_cb(old_table_size, -1);

}
",1,1,0,1,s,-0.38172927498817444,1,3,{'s': 'old_table_size'},MHM-Origin,25,0.004555590947469075
390,"static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,

                                    const uint8_t *src, const uint8_t *src_end,

                                    int width, int esc_count)

{

    int i = 0;

    int count;

    uint8_t zero_run = 0;

    const uint8_t *src_start = src;

    uint8_t mask1 = -(esc_count < 2);

    uint8_t mask2 = -(esc_count < 3);

    uint8_t *end = dst + (width - 2);



    avpriv_request_sample(l->avctx, ""zero_run_line"");

    return AVERROR_PATCHWELCOME;



output_zeros:

    if (l->zeros_rem) {

        count = FFMIN(l->zeros_rem, width - i);

        if (end - dst < count) {

            av_log(l->avctx, AV_LOG_ERROR, ""Too many zeros remaining.\n"");

            return AVERROR_INVALIDDATA;

        }



        memset(dst, 0, count);

        l->zeros_rem -= count;

        dst += count;

    }



    while (dst < end) {

        i = 0;

        while (!zero_run && dst + i < end) {

            i++;

            if (i+2 >= src_end - src)

                return AVERROR_INVALIDDATA;

            zero_run =

                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));

        }

        if (zero_run) {

            zero_run = 0;

            i += esc_count;

            memcpy(dst, src, i);

            dst += i;

            l->zeros_rem = lag_calc_zero_run(src[i]);



            src += i + 1;

            goto output_zeros;

        } else {

            memcpy(dst, src, i);

            src += i;

            dst += i;

        }

    }

    return  src - src_start;

}
",308,"static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *v9fs_string_sprintf,

                                    const uint8_t *src, const uint8_t *src_end,

                                    int width, int esc_count)

{

    int i = 0;

    int count;

    uint8_t zero_run = 0;

    const uint8_t *src_start = src;

    uint8_t mask1 = -(esc_count < 2);

    uint8_t mask2 = -(esc_count < 3);

    uint8_t *do_read_packets = v9fs_string_sprintf + (width - 2);



    avpriv_request_sample(l->avctx, ""zero_run_line"");

    return AVERROR_PATCHWELCOME;



output_zeros:

    if (l->zeros_rem) {

        count = FFMIN(l->zeros_rem, width - i);

        if (do_read_packets - v9fs_string_sprintf < count) {

            av_log(l->avctx, AV_LOG_ERROR, ""Too many zeros remaining.
"");

            return AVERROR_INVALIDDATA;

        }



        memset(v9fs_string_sprintf, 0, count);

        l->zeros_rem -= count;

        v9fs_string_sprintf += count;

    }



    while (v9fs_string_sprintf < do_read_packets) {

        i = 0;

        while (!zero_run && v9fs_string_sprintf + i < do_read_packets) {

            i++;

            if (i+2 >= src_end - src)

                return AVERROR_INVALIDDATA;

            zero_run =

                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));

        }

        if (zero_run) {

            zero_run = 0;

            i += esc_count;

            memcpy(v9fs_string_sprintf, src, i);

            v9fs_string_sprintf += i;

            l->zeros_rem = lag_calc_zero_run(src[i]);



            src += i + 1;

            goto output_zeros;

        } else {

            memcpy(v9fs_string_sprintf, src, i);

            src += i;

            v9fs_string_sprintf += i;

        }

    }

    return  src - src_start;

}
",1,1,0,1,end,-0.22446021437644958,2,15,"{'dst': 'v9fs_string_sprintf', 'end': 'do_read_packets'}",MHM-Origin,42,0.011436565717061361
391,"static int ram_init_all(RAMState **rsp)

{

    Error *local_err = NULL;



    if (ram_state_init(rsp)) {

        return -1;

    }



    if (migrate_use_xbzrle()) {

        XBZRLE_cache_lock();

        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);

        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),

                                  TARGET_PAGE_SIZE, &local_err);

        if (!XBZRLE.cache) {

            XBZRLE_cache_unlock();

            error_report_err(local_err);

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

        XBZRLE_cache_unlock();



        /* We prefer not to abort if there is no memory */

        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);

        if (!XBZRLE.encoded_buf) {

            error_report(""Error allocating encoded_buf"");

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }



        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);

        if (!XBZRLE.current_buf) {

            error_report(""Error allocating current_buf"");

            g_free(XBZRLE.encoded_buf);

            XBZRLE.encoded_buf = NULL;

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

    }



    /* For memory_global_dirty_log_start below.  */

    qemu_mutex_lock_iothread();



    qemu_mutex_lock_ramlist();

    rcu_read_lock();



    /* Skip setting bitmap if there is no RAM */

    if (ram_bytes_total()) {

        RAMBlock *block;



        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {

            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;



            block->bmap = bitmap_new(pages);

            bitmap_set(block->bmap, 0, pages);

            if (migrate_postcopy_ram()) {

                block->unsentmap = bitmap_new(pages);

                bitmap_set(block->unsentmap, 0, pages);

            }

        }

    }



    memory_global_dirty_log_start();

    migration_bitmap_sync(*rsp);

    qemu_mutex_unlock_ramlist();

    qemu_mutex_unlock_iothread();

    rcu_read_unlock();



    return 0;

}
",312,"static int ram_init_all(RAMState **rsp)

{

    Error *v9fs_string_free = NULL;



    if (ram_state_init(rsp)) {

        return -1;

    }



    if (migrate_use_xbzrle()) {

        XBZRLE_cache_lock();

        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);

        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),

                                  TARGET_PAGE_SIZE, &v9fs_string_free);

        if (!XBZRLE.cache) {

            XBZRLE_cache_unlock();

            error_report_err(v9fs_string_free);

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

        XBZRLE_cache_unlock();



        /* We prefer not to abort if there is no memory */

        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);

        if (!XBZRLE.encoded_buf) {

            error_report(""Error allocating encoded_buf"");

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }



        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);

        if (!XBZRLE.current_buf) {

            error_report(""Error allocating current_buf"");

            g_free(XBZRLE.encoded_buf);

            XBZRLE.encoded_buf = NULL;

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

    }



    /* For memory_global_dirty_log_start below.  */

    qemu_mutex_lock_iothread();



    qemu_mutex_lock_ramlist();

    rcu_read_lock();



    /* Skip setting bitmap if there is no RAM */

    if (ram_bytes_total()) {

        RAMBlock *block;



        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {

            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;



            block->bmap = bitmap_new(pages);

            bitmap_set(block->bmap, 0, pages);

            if (migrate_postcopy_ram()) {

                block->unsentmap = bitmap_new(pages);

                bitmap_set(block->unsentmap, 0, pages);

            }

        }

    }



    memory_global_dirty_log_start();

    migration_bitmap_sync(*rsp);

    qemu_mutex_unlock_ramlist();

    qemu_mutex_unlock_iothread();

    rcu_read_unlock();



    return 0;

}
",1,1,0,1,local_err,-0.37507763504981995,1,3,{'local_err': 'v9fs_string_free'},MHM-Origin,43,0.011723554134368897
392,"static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",197,"static void av_always_inline filter_mb_edgecv( uint8_t *priv_data, int block_type, int16_t MSR_MTRRphysBase[4], unsigned int g_assert, H264Context *in_file_index ) {

    const unsigned int index_a = g_assert + in_file_index->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[g_assert + in_file_index->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( MSR_MTRRphysBase[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][MSR_MTRRphysBase[0]]+1;

        tc[1] = tc0_table[index_a][MSR_MTRRphysBase[1]]+1;

        tc[2] = tc0_table[index_a][MSR_MTRRphysBase[2]]+1;

        tc[3] = tc0_table[index_a][MSR_MTRRphysBase[3]]+1;

        in_file_index->h264dsp.h264_h_loop_filter_chroma(priv_data, block_type, alpha, beta, tc);

    } else {

        in_file_index->h264dsp.h264_h_loop_filter_chroma_intra(priv_data, block_type, alpha, beta);

    }

}
",0,0,0,-1,bS,0.00038469117134809494,5,20,"{'qp': 'g_assert', 'stride': 'block_type', 'bS': 'MSR_MTRRphysBase', 'h': 'in_file_index', 'pix': 'priv_data'}",MHM-Origin,407,0.10585703055063883
393,"static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,

                                      int w, int h)

{

    ImageContext *img;

    HuffReader *hg;

    int i, j, ret, x, y, width;



    img       = &s->image[role];

    img->role = role;



    if (!img->frame) {

        img->frame = av_frame_alloc();

        if (!img->frame)

            return AVERROR(ENOMEM);

    }



    img->frame->format = AV_PIX_FMT_ARGB;

    img->frame->width  = w;

    img->frame->height = h;



    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {

        ThreadFrame pt = { .f = img->frame };

        ret = ff_thread_get_buffer(s->avctx, &pt, 0);

    } else

        ret = av_frame_get_buffer(img->frame, 1);

    if (ret < 0)

        return ret;



    if (get_bits1(&s->gb)) {

        img->color_cache_bits = get_bits(&s->gb, 4);

        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {

            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d\n"",

                   img->color_cache_bits);

            return AVERROR_INVALIDDATA;

        }

        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,

                                            sizeof(*img->color_cache));

        if (!img->color_cache)

            return AVERROR(ENOMEM);

    } else {

        img->color_cache_bits = 0;

    }



    img->nb_huffman_groups = 1;

    if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {

        ret = decode_entropy_image(s);

        if (ret < 0)

            return ret;

        img->nb_huffman_groups = s->nb_huffman_groups;

    }

    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *

                                           HUFFMAN_CODES_PER_META_CODE,

                                           sizeof(*img->huffman_groups));

    if (!img->huffman_groups)

        return AVERROR(ENOMEM);



    for (i = 0; i < img->nb_huffman_groups; i++) {

        hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];

        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {

            int alphabet_size = alphabet_sizes[j];

            if (!j && img->color_cache_bits > 0)

                alphabet_size += 1 << img->color_cache_bits;



            if (get_bits1(&s->gb)) {

                read_huffman_code_simple(s, &hg[j]);

            } else {

                ret = read_huffman_code_normal(s, &hg[j], alphabet_size);

                if (ret < 0)

                    return ret;

            }

        }

    }



    width = img->frame->width;

    if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0)

        width = s->reduced_width;



    x = 0; y = 0;

    while (y < img->frame->height) {

        int v;



        hg = get_huffman_group(s, img, x, y);

        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb);

        if (v < NUM_LITERAL_CODES) {

            /* literal pixel values */

            uint8_t *p = GET_PIXEL(img->frame, x, y);

            p[2] = v;

            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &s->gb);

            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &s->gb);

            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb);

            if (img->color_cache_bits)

                color_cache_put(img, AV_RB32(p));

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {

            /* LZ77 backwards mapping */

            int prefix_code, length, distance, ref_x, ref_y;



            /* parse length and distance */

            prefix_code = v - NUM_LITERAL_CODES;

            if (prefix_code < 4) {

                length = prefix_code + 1;

            } else {

                int extra_bits = (prefix_code - 2) >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                length = offset + get_bits(&s->gb, extra_bits) + 1;

            }

            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb);

            if (prefix_code > 39) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""distance prefix code too large: %d\n"", prefix_code);

                return AVERROR_INVALIDDATA;

            }

            if (prefix_code < 4) {

                distance = prefix_code + 1;

            } else {

                int extra_bits = prefix_code - 2 >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                distance = offset + get_bits(&s->gb, extra_bits) + 1;

            }



            /* find reference location */

            if (distance <= NUM_SHORT_DISTANCES) {

                int xi = lz77_distance_offsets[distance - 1][0];

                int yi = lz77_distance_offsets[distance - 1][1];

                distance = FFMAX(1, xi + yi * width);

            } else {

                distance -= NUM_SHORT_DISTANCES;

            }

            ref_x = x;

            ref_y = y;

            if (distance <= x) {

                ref_x -= distance;

                distance = 0;

            } else {

                ref_x = 0;

                distance -= x;

            }

            while (distance >= width) {

                ref_y--;

                distance -= width;

            }

            if (distance > 0) {

                ref_x = width - distance;

                ref_y--;

            }

            ref_x = FFMAX(0, ref_x);

            ref_y = FFMAX(0, ref_y);



            /* copy pixels

             * source and dest regions can overlap and wrap lines, so just

             * copy per-pixel */

            for (i = 0; i < length; i++) {

                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);

                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);



                AV_COPY32(p, p_ref);

                if (img->color_cache_bits)

                    color_cache_put(img, AV_RB32(p));

                x++;

                ref_x++;

                if (x == width) {

                    x = 0;

                    y++;

                }

                if (ref_x == width) {

                    ref_x = 0;

                    ref_y++;

                }

                if (y == img->frame->height || ref_y == img->frame->height)

                    break;

            }

        } else {

            /* read from color cache */

            uint8_t *p = GET_PIXEL(img->frame, x, y);

            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);



            if (!img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR, ""color cache not found\n"");

                return AVERROR_INVALIDDATA;

            }

            if (cache_idx >= 1 << img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""color cache index out-of-bounds\n"");

                return AVERROR_INVALIDDATA;

            }

            AV_WB32(p, img->color_cache[cache_idx]);

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        }

    }



    return 0;

}
",1232,"static int decode_entropy_coded_image(WebPContext *heads, enum ImageRole aio_type,

                                      int w, int h)

{

    ImageContext *REX_B;

    HuffReader *saddr;

    int AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH, j, xics_system_init, SOCK_DGRAM, T1, width;



    REX_B       = &heads->heads[aio_type];

    REX_B->aio_type = aio_type;



    if (!REX_B->frame) {

        REX_B->frame = av_frame_alloc();

        if (!REX_B->frame)

            return AVERROR(ENOMEM);

    }



    REX_B->frame->format = AV_PIX_FMT_ARGB;

    REX_B->frame->width  = w;

    REX_B->frame->height = h;



    if (aio_type == IMAGE_ROLE_ARGB && !REX_B->is_alpha_primary) {

        ThreadFrame pt = { .f = REX_B->frame };

        xics_system_init = ff_thread_get_buffer(heads->avctx, &pt, 0);

    } else

        xics_system_init = av_frame_get_buffer(REX_B->frame, 1);

    if (xics_system_init < 0)

        return xics_system_init;



    if (get_bits1(&heads->gb)) {

        REX_B->color_cache_bits = get_bits(&heads->gb, 4);

        if (REX_B->color_cache_bits < 1 || REX_B->color_cache_bits > 11) {

            av_log(heads->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d
"",

                   REX_B->color_cache_bits);

            return AVERROR_INVALIDDATA;

        }

        REX_B->color_cache = av_mallocz_array(1 << REX_B->color_cache_bits,

                                            sizeof(*REX_B->color_cache));

        if (!REX_B->color_cache)

            return AVERROR(ENOMEM);

    } else {

        REX_B->color_cache_bits = 0;

    }



    REX_B->nb_huffman_groups = 1;

    if (aio_type == IMAGE_ROLE_ARGB && get_bits1(&heads->gb)) {

        xics_system_init = decode_entropy_image(heads);

        if (xics_system_init < 0)

            return xics_system_init;

        REX_B->nb_huffman_groups = heads->nb_huffman_groups;

    }

    REX_B->huffman_groups = av_mallocz_array(REX_B->nb_huffman_groups *

                                           HUFFMAN_CODES_PER_META_CODE,

                                           sizeof(*REX_B->huffman_groups));

    if (!REX_B->huffman_groups)

        return AVERROR(ENOMEM);



    for (AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH = 0; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH < REX_B->nb_huffman_groups; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH++) {

        saddr = &REX_B->huffman_groups[AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH * HUFFMAN_CODES_PER_META_CODE];

        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {

            int alphabet_size = alphabet_sizes[j];

            if (!j && REX_B->color_cache_bits > 0)

                alphabet_size += 1 << REX_B->color_cache_bits;



            if (get_bits1(&heads->gb)) {

                read_huffman_code_simple(heads, &saddr[j]);

            } else {

                xics_system_init = read_huffman_code_normal(heads, &saddr[j], alphabet_size);

                if (xics_system_init < 0)

                    return xics_system_init;

            }

        }

    }



    width = REX_B->frame->width;

    if (aio_type == IMAGE_ROLE_ARGB && heads->reduced_width > 0)

        width = heads->reduced_width;



    SOCK_DGRAM = 0; T1 = 0;

    while (T1 < REX_B->frame->height) {

        int v;



        saddr = get_huffman_group(heads, REX_B, SOCK_DGRAM, T1);

        v = huff_reader_get_symbol(&saddr[HUFF_IDX_GREEN], &heads->gb);

        if (v < NUM_LITERAL_CODES) {

            /* literal pixel values */

            uint8_t *cpu_index = GET_PIXEL(REX_B->frame, SOCK_DGRAM, T1);

            cpu_index[2] = v;

            cpu_index[1] = huff_reader_get_symbol(&saddr[HUFF_IDX_RED],   &heads->gb);

            cpu_index[3] = huff_reader_get_symbol(&saddr[HUFF_IDX_BLUE],  &heads->gb);

            cpu_index[0] = huff_reader_get_symbol(&saddr[HUFF_IDX_ALPHA], &heads->gb);

            if (REX_B->color_cache_bits)

                color_cache_put(REX_B, AV_RB32(cpu_index));

            SOCK_DGRAM++;

            if (SOCK_DGRAM == width) {

                SOCK_DGRAM = 0;

                T1++;

            }

        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {

            /* LZ77 backwards mapping */

            int prefix_code, gen_helper_fprem, distance, ref_x, ref_y;



            /* parse length and distance */

            prefix_code = v - NUM_LITERAL_CODES;

            if (prefix_code < 4) {

                gen_helper_fprem = prefix_code + 1;

            } else {

                int extra_bits = (prefix_code - 2) >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                gen_helper_fprem = offset + get_bits(&heads->gb, extra_bits) + 1;

            }

            prefix_code = huff_reader_get_symbol(&saddr[HUFF_IDX_DIST], &heads->gb);

            if (prefix_code > 39) {

                av_log(heads->avctx, AV_LOG_ERROR,

                       ""distance prefix code too large: %d
"", prefix_code);

                return AVERROR_INVALIDDATA;

            }

            if (prefix_code < 4) {

                distance = prefix_code + 1;

            } else {

                int extra_bits = prefix_code - 2 >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                distance = offset + get_bits(&heads->gb, extra_bits) + 1;

            }



            /* find reference location */

            if (distance <= NUM_SHORT_DISTANCES) {

                int xi = lz77_distance_offsets[distance - 1][0];

                int yi = lz77_distance_offsets[distance - 1][1];

                distance = FFMAX(1, xi + yi * width);

            } else {

                distance -= NUM_SHORT_DISTANCES;

            }

            ref_x = SOCK_DGRAM;

            ref_y = T1;

            if (distance <= SOCK_DGRAM) {

                ref_x -= distance;

                distance = 0;

            } else {

                ref_x = 0;

                distance -= SOCK_DGRAM;

            }

            while (distance >= width) {

                ref_y--;

                distance -= width;

            }

            if (distance > 0) {

                ref_x = width - distance;

                ref_y--;

            }

            ref_x = FFMAX(0, ref_x);

            ref_y = FFMAX(0, ref_y);



            /* copy pixels

             * source and dest regions can overlap and wrap lines, so just

             * copy per-pixel */

            for (AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH = 0; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH < gen_helper_fprem; AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH++) {

                uint8_t *USBDevice = GET_PIXEL(REX_B->frame, ref_x, ref_y);

                uint8_t *cpu_index     = GET_PIXEL(REX_B->frame,     SOCK_DGRAM,     T1);



                AV_COPY32(cpu_index, USBDevice);

                if (REX_B->color_cache_bits)

                    color_cache_put(REX_B, AV_RB32(cpu_index));

                SOCK_DGRAM++;

                ref_x++;

                if (SOCK_DGRAM == width) {

                    SOCK_DGRAM = 0;

                    T1++;

                }

                if (ref_x == width) {

                    ref_x = 0;

                    ref_y++;

                }

                if (T1 == REX_B->frame->height || ref_y == REX_B->frame->height)

                    break;

            }

        } else {

            /* read from color cache */

            uint8_t *cpu_index = GET_PIXEL(REX_B->frame, SOCK_DGRAM, T1);

            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);



            if (!REX_B->color_cache_bits) {

                av_log(heads->avctx, AV_LOG_ERROR, ""color cache not found
"");

                return AVERROR_INVALIDDATA;

            }

            if (cache_idx >= 1 << REX_B->color_cache_bits) {

                av_log(heads->avctx, AV_LOG_ERROR,

                       ""color cache index out-of-bounds
"");

                return AVERROR_INVALIDDATA;

            }

            AV_WB32(cpu_index, REX_B->color_cache[cache_idx]);

            SOCK_DGRAM++;

            if (SOCK_DGRAM == width) {

                SOCK_DGRAM = 0;

                T1++;

            }

        }

    }



    return 0;

}
",1,1,1,-1,length,0.0,11,155,"{'s': 'heads', 'ret': 'xics_system_init', 'x': 'SOCK_DGRAM', 'p_ref': 'USBDevice', 'hg': 'saddr', 'img': 'REX_B', 'y': 'T1', 'role': 'aio_type', 'i': 'AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH', 'p': 'cpu_index', 'length': 'gen_helper_fprem'}",MHM-Origin,411,0.1601405382156372
394,"void ff_mspel_motion(MpegEncContext *s,

                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,

                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],

                               int motion_x, int motion_y, int h)

{

    Wmv2Context * const w= (Wmv2Context*)s;

    uint8_t *ptr;

    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;

    int emu=0;



    dxy = ((motion_y & 1) << 1) | (motion_x & 1);

    dxy = 2*dxy + w->hshift;

    src_x = s->mb_x * 16 + (motion_x >> 1);

    src_y = s->mb_y * 16 + (motion_y >> 1);



    /* WARNING: do no forget half pels */

    v_edge_pos = s->v_edge_pos;

    src_x = av_clip(src_x, -16, s->width);

    src_y = av_clip(src_y, -16, s->height);



    if(src_x<=-16 || src_x >= s->width)

        dxy &= ~3;

    if(src_y<=-16 || src_y >= s->height)

        dxy &= ~4;



    linesize   = s->linesize;

    uvlinesize = s->uvlinesize;

    ptr = ref_picture[0] + (src_y * linesize) + src_x;



        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos

                              || src_y + h+1 >= v_edge_pos){

            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,

                             src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos);

            ptr= s->edge_emu_buffer + 1 + s->linesize;

            emu=1;

        }



    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);



    if(s->flags&CODEC_FLAG_GRAY) return;



    if (s->out_format == FMT_H263) {

        dxy = 0;

        if ((motion_x & 3) != 0)

            dxy |= 1;

        if ((motion_y & 3) != 0)

            dxy |= 2;

        mx = motion_x >> 2;

        my = motion_y >> 2;

    } else {

        mx = motion_x / 2;

        my = motion_y / 2;

        dxy = ((my & 1) << 1) | (mx & 1);

        mx >>= 1;

        my >>= 1;

    }



    src_x = s->mb_x * 8 + mx;

    src_y = s->mb_y * 8 + my;

    src_x = av_clip(src_x, -8, s->width >> 1);

    if (src_x == (s->width >> 1))

        dxy &= ~1;

    src_y = av_clip(src_y, -8, s->height >> 1);

    if (src_y == (s->height >> 1))

        dxy &= ~2;

    offset = (src_y * uvlinesize) + src_x;

    ptr = ref_picture[1] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);

        ptr= s->edge_emu_buffer;

    }

    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);



    ptr = ref_picture[2] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);

        ptr= s->edge_emu_buffer;

    }

    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);

}
",760,"void ff_mspel_motion(MpegEncContext *s,

                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,

                               uint8_t **cc_src2, op_pixels_func (*pix_op)[4],

                               int motion_x, int motion_y, int h)

{

    Wmv2Context * const w= (Wmv2Context*)s;

    uint8_t *ptr;

    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;

    int emu=0;



    dxy = ((motion_y & 1) << 1) | (motion_x & 1);

    dxy = 2*dxy + w->hshift;

    src_x = s->mb_x * 16 + (motion_x >> 1);

    src_y = s->mb_y * 16 + (motion_y >> 1);



    /* WARNING: do no forget half pels */

    v_edge_pos = s->v_edge_pos;

    src_x = av_clip(src_x, -16, s->width);

    src_y = av_clip(src_y, -16, s->height);



    if(src_x<=-16 || src_x >= s->width)

        dxy &= ~3;

    if(src_y<=-16 || src_y >= s->height)

        dxy &= ~4;



    linesize   = s->linesize;

    uvlinesize = s->uvlinesize;

    ptr = cc_src2[0] + (src_y * linesize) + src_x;



        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos

                              || src_y + h+1 >= v_edge_pos){

            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,

                             src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos);

            ptr= s->edge_emu_buffer + 1 + s->linesize;

            emu=1;

        }



    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);



    if(s->flags&CODEC_FLAG_GRAY) return;



    if (s->out_format == FMT_H263) {

        dxy = 0;

        if ((motion_x & 3) != 0)

            dxy |= 1;

        if ((motion_y & 3) != 0)

            dxy |= 2;

        mx = motion_x >> 2;

        my = motion_y >> 2;

    } else {

        mx = motion_x / 2;

        my = motion_y / 2;

        dxy = ((my & 1) << 1) | (mx & 1);

        mx >>= 1;

        my >>= 1;

    }



    src_x = s->mb_x * 8 + mx;

    src_y = s->mb_y * 8 + my;

    src_x = av_clip(src_x, -8, s->width >> 1);

    if (src_x == (s->width >> 1))

        dxy &= ~1;

    src_y = av_clip(src_y, -8, s->height >> 1);

    if (src_y == (s->height >> 1))

        dxy &= ~2;

    offset = (src_y * uvlinesize) + src_x;

    ptr = cc_src2[1] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);

        ptr= s->edge_emu_buffer;

    }

    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);



    ptr = cc_src2[2] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);

        ptr= s->edge_emu_buffer;

    }

    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);

}
",1,1,0,1,ref_picture,-0.16879460215568542,1,4,{'ref_picture': 'cc_src2'},MHM-Origin,22,0.006796610355377197
395,"static int svq1_encode_plane(SVQ1Context *s, int plane,

                             unsigned char *src_plane,

                             unsigned char *ref_plane,

                             unsigned char *decoded_plane,

                             int width, int height, int src_stride, int stride)

{

    const AVFrame *f = s->avctx->coded_frame;

    int x, y;

    int i;

    int block_width, block_height;

    int level;

    int threshold[6];

    uint8_t *src     = s->scratchbuf + stride * 16;

    const int lambda = (f->quality * f->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    threshold[5] = QUALITY_THRESHOLD;

    for (level = 4; level >= 0; level--)

        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    block_height = (height + 15) / 16;



    if (f->pict_type == AV_PICTURE_TYPE_P) {

        s->m.avctx                         = s->avctx;

        s->m.current_picture_ptr           = &s->m.current_picture;

        s->m.last_picture_ptr              = &s->m.last_picture;

        s->m.last_picture.f.data[0]        = ref_plane;

        s->m.linesize                      =

        s->m.last_picture.f.linesize[0]    =

        s->m.new_picture.f.linesize[0]     =

        s->m.current_picture.f.linesize[0] = stride;

        s->m.width                         = width;

        s->m.height                        = height;

        s->m.mb_width                      = block_width;

        s->m.mb_height                     = block_height;

        s->m.mb_stride                     = s->m.mb_width + 1;

        s->m.b8_stride                     = 2 * s->m.mb_width + 1;

        s->m.f_code                        = 1;

        s->m.pict_type                     = f->pict_type;

        s->m.me_method                     = s->avctx->me_method;

        s->m.me.scene_change_score         = 0;

        s->m.flags                         = s->avctx->flags;

        // s->m.out_format                    = FMT_H263;

        // s->m.unrestricted_mv               = 1;

        s->m.lambda                        = f->quality;

        s->m.qscale                        = s->m.lambda * 139 +

                                             FF_LAMBDA_SCALE * 64 >>

                                             FF_LAMBDA_SHIFT + 7;

        s->m.lambda2                       = s->m.lambda * s->m.lambda +

                                             FF_LAMBDA_SCALE / 2 >>

                                             FF_LAMBDA_SHIFT;



        if (!s->motion_val8[plane]) {

            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *

                                                 block_height * 2 + 2) *

                                                2 * sizeof(int16_t));

            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *

                                                 (block_height + 2) + 1) *

                                                2 * sizeof(int16_t));

        }



        s->m.mb_type = s->mb_type;



        // dummies, to avoid segfaults

        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;

        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;

        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;

        s->m.current_picture.mb_type = s->dummy;



        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;

        s->m.p_mv_table                      = s->motion_val16[plane] +

                                               s->m.mb_stride + 1;

        s->m.dsp                             = s->dsp; // move

        ff_init_me(&s->m);



        s->m.me.dia_size      = s->avctx->dia_size;

        s->m.first_slice_line = 1;

        for (y = 0; y < block_height; y++) {

            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly

            s->m.mb_y                  = y;



            for (i = 0; i < 16 && i + 16 * y < height; i++) {

                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                       width);

                for (x = width; x < 16 * block_width; x++)

                    src[i * stride + x] = src[i * stride + x - 1];

            }

            for (; i < 16 && i + 16 * y < 16 * block_height; i++)

                memcpy(&src[i * stride], &src[(i - 1) * stride],

                       16 * block_width);



            for (x = 0; x < block_width; x++) {

                s->m.mb_x = x;

                ff_init_block_index(&s->m);

                ff_update_block_index(&s->m);



                ff_estimate_p_frame_motion(&s->m, x, y);

            }

            s->m.first_slice_line = 0;

        }



        ff_fix_long_p_mvs(&s->m);

        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,

                        CANDIDATE_MB_TYPE_INTER, 0);

    }



    s->m.first_slice_line = 1;

    for (y = 0; y < block_height; y++) {

        for (i = 0; i < 16 && i + 16 * y < height; i++) {

            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                   width);

            for (x = width; x < 16 * block_width; x++)

                src[i * stride + x] = src[i * stride + x - 1];

        }

        for (; i < 16 && i + 16 * y < 16 * block_height; i++)

            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);



        s->m.mb_y = y;

        for (x = 0; x < block_width; x++) {

            uint8_t reorder_buffer[3][6][7 * 32];

            int count[3][6];

            int offset       = y * 16 * stride + x * 16;

            uint8_t *decoded = decoded_plane + offset;

            uint8_t *ref     = ref_plane + offset;

            int score[4]     = { 0, 0, 0, 0 }, best;

            uint8_t *temp    = s->scratchbuf;



            if (s->pb.buf_end - s->pb.buf -

                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size

                av_log(s->avctx, AV_LOG_ERROR, ""encoded frame too large\n"");

                return -1;

            }



            s->m.mb_x = x;

            ff_init_block_index(&s->m);

            ff_update_block_index(&s->m);



            if (f->pict_type == AV_PICTURE_TYPE_I ||

                (s->m.mb_type[x + y * s->m.mb_stride] &

                 CANDIDATE_MB_TYPE_INTRA)) {

                for (i = 0; i < 6; i++)

                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],

                                  7 * 32);

                if (f->pict_type == AV_PICTURE_TYPE_P) {

                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);

                    score[0] = vlc[1] * lambda;

                }

                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,

                                         5, 64, lambda, 1);

                for (i = 0; i < 6; i++) {

                    count[0][i] = put_bits_count(&s->reorder_pb[i]);

                    flush_put_bits(&s->reorder_pb[i]);

                }

            } else

                score[0] = INT_MAX;



            best = 0;



            if (f->pict_type == AV_PICTURE_TYPE_P) {

                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, my, pred_x, pred_y, dxy;

                int16_t *motion_ptr;



                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);

                if (s->m.mb_type[x + y * s->m.mb_stride] &

                    CANDIDATE_MB_TYPE_INTER) {

                    for (i = 0; i < 6; i++)

                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],

                                      7 * 32);



                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);



                    s->m.pb = s->reorder_pb[5];

                    mx      = motion_ptr[0];

                    my      = motion_ptr[1];

                    assert(mx     >= -32 && mx     <= 31);

                    assert(my     >= -32 && my     <= 31);

                    assert(pred_x >= -32 && pred_x <= 31);

                    assert(pred_y >= -32 && pred_y <= 31);

                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);

                    ff_h263_encode_motion(&s->m, my - pred_y, 1);

                    s->reorder_pb[5] = s->m.pb;

                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);



                    dxy = (mx & 1) + 2 * (my & 1);



                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,

                                                   ref + (mx >> 1) +

                                                   stride * (my >> 1),

                                                   stride, 16);



                    score[1] += encode_block(s, src + 16 * x, temp + 16,

                                             decoded, stride, 5, 64, lambda, 0);

                    best      = score[1] <= score[0];



                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,

                                              stride, 16);

                    score[2] += vlc[1] * lambda;

                    if (score[2] < score[best] && mx == 0 && my == 0) {

                        best = 2;

                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);

                        for (i = 0; i < 6; i++)

                            count[2][i] = 0;

                        put_bits(&s->pb, vlc[1], vlc[0]);

                    }

                }



                if (best == 1) {

                    for (i = 0; i < 6; i++) {

                        count[1][i] = put_bits_count(&s->reorder_pb[i]);

                        flush_put_bits(&s->reorder_pb[i]);

                    }

                } else {

                    motion_ptr[0]                      =

                    motion_ptr[1]                      =

                    motion_ptr[2]                      =

                    motion_ptr[3]                      =

                    motion_ptr[0 + 2 * s->m.b8_stride] =

                    motion_ptr[1 + 2 * s->m.b8_stride] =

                    motion_ptr[2 + 2 * s->m.b8_stride] =

                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;

                }

            }



            s->rd_total += score[best];



            for (i = 5; i >= 0; i--)

                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],

                                 count[best][i]);

            if (best == 0)

                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);

        }

        s->m.first_slice_line = 0;

    }

    return 0;

}
",2179,"static int svq1_encode_plane(SVQ1Context *s, int plane,

                             unsigned char *src_plane,

                             unsigned char *ref_plane,

                             unsigned char *decoded_plane,

                             int width, int height, int TARGET_MIPS64, int stride)

{

    const AVFrame *output_files = s->avctx->coded_frame;

    int CPUID_7_0_EBX_SMAP, y;

    int i;

    int block_width, block_height;

    int vex_l;

    int ai_socktype[6];

    uint8_t *src     = s->scratchbuf + stride * 16;

    const int lambda = (output_files->quality * output_files->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    ai_socktype[5] = QUALITY_THRESHOLD;

    for (vex_l = 4; vex_l >= 0; vex_l--)

        ai_socktype[vex_l] = ai_socktype[vex_l + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    block_height = (height + 15) / 16;



    if (output_files->pict_type == AV_PICTURE_TYPE_P) {

        s->m.avctx                         = s->avctx;

        s->m.current_picture_ptr           = &s->m.current_picture;

        s->m.last_picture_ptr              = &s->m.last_picture;

        s->m.last_picture.output_files.data[0]        = ref_plane;

        s->m.linesize                      =

        s->m.last_picture.output_files.linesize[0]    =

        s->m.new_picture.output_files.linesize[0]     =

        s->m.current_picture.output_files.linesize[0] = stride;

        s->m.width                         = width;

        s->m.height                        = height;

        s->m.mb_width                      = block_width;

        s->m.mb_height                     = block_height;

        s->m.mb_stride                     = s->m.mb_width + 1;

        s->m.b8_stride                     = 2 * s->m.mb_width + 1;

        s->m.f_code                        = 1;

        s->m.pict_type                     = output_files->pict_type;

        s->m.me_method                     = s->avctx->me_method;

        s->m.me.scene_change_score         = 0;

        s->m.flags                         = s->avctx->flags;

        // s->m.out_format                    = FMT_H263;

        // s->m.unrestricted_mv               = 1;

        s->m.lambda                        = output_files->quality;

        s->m.qscale                        = s->m.lambda * 139 +

                                             FF_LAMBDA_SCALE * 64 >>

                                             FF_LAMBDA_SHIFT + 7;

        s->m.lambda2                       = s->m.lambda * s->m.lambda +

                                             FF_LAMBDA_SCALE / 2 >>

                                             FF_LAMBDA_SHIFT;



        if (!s->motion_val8[plane]) {

            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *

                                                 block_height * 2 + 2) *

                                                2 * sizeof(int16_t));

            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *

                                                 (block_height + 2) + 1) *

                                                2 * sizeof(int16_t));

        }



        s->m.mb_type = s->mb_type;



        // dummies, to avoid segfaults

        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;

        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;

        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;

        s->m.current_picture.mb_type = s->dummy;



        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;

        s->m.p_mv_table                      = s->motion_val16[plane] +

                                               s->m.mb_stride + 1;

        s->m.dsp                             = s->dsp; // move

        ff_init_me(&s->m);



        s->m.me.dia_size      = s->avctx->dia_size;

        s->m.first_slice_line = 1;

        for (y = 0; y < block_height; y++) {

            s->m.new_picture.output_files.data[0] = src - y * 16 * stride; // ugly

            s->m.mb_y                  = y;



            for (i = 0; i < 16 && i + 16 * y < height; i++) {

                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * TARGET_MIPS64],

                       width);

                for (CPUID_7_0_EBX_SMAP = width; CPUID_7_0_EBX_SMAP < 16 * block_width; CPUID_7_0_EBX_SMAP++)

                    src[i * stride + CPUID_7_0_EBX_SMAP] = src[i * stride + CPUID_7_0_EBX_SMAP - 1];

            }

            for (; i < 16 && i + 16 * y < 16 * block_height; i++)

                memcpy(&src[i * stride], &src[(i - 1) * stride],

                       16 * block_width);



            for (CPUID_7_0_EBX_SMAP = 0; CPUID_7_0_EBX_SMAP < block_width; CPUID_7_0_EBX_SMAP++) {

                s->m.mb_x = CPUID_7_0_EBX_SMAP;

                ff_init_block_index(&s->m);

                ff_update_block_index(&s->m);



                ff_estimate_p_frame_motion(&s->m, CPUID_7_0_EBX_SMAP, y);

            }

            s->m.first_slice_line = 0;

        }



        ff_fix_long_p_mvs(&s->m);

        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,

                        CANDIDATE_MB_TYPE_INTER, 0);

    }



    s->m.first_slice_line = 1;

    for (y = 0; y < block_height; y++) {

        for (i = 0; i < 16 && i + 16 * y < height; i++) {

            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * TARGET_MIPS64],

                   width);

            for (CPUID_7_0_EBX_SMAP = width; CPUID_7_0_EBX_SMAP < 16 * block_width; CPUID_7_0_EBX_SMAP++)

                src[i * stride + CPUID_7_0_EBX_SMAP] = src[i * stride + CPUID_7_0_EBX_SMAP - 1];

        }

        for (; i < 16 && i + 16 * y < 16 * block_height; i++)

            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);



        s->m.mb_y = y;

        for (CPUID_7_0_EBX_SMAP = 0; CPUID_7_0_EBX_SMAP < block_width; CPUID_7_0_EBX_SMAP++) {

            uint8_t avio_close[3][6][7 * 32];

            int count[3][6];

            int offset       = y * 16 * stride + CPUID_7_0_EBX_SMAP * 16;

            uint8_t *decoded = decoded_plane + offset;

            uint8_t *O_RDONLY     = ref_plane + offset;

            int cur_time[4]     = { 0, 0, 0, 0 }, q1_org_r;

            uint8_t *tb_lock_reset    = s->scratchbuf;



            if (s->pb.buf_end - s->pb.buf -

                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size

                av_log(s->avctx, AV_LOG_ERROR, ""encoded frame too large
"");

                return -1;

            }



            s->m.mb_x = CPUID_7_0_EBX_SMAP;

            ff_init_block_index(&s->m);

            ff_update_block_index(&s->m);



            if (output_files->pict_type == AV_PICTURE_TYPE_I ||

                (s->m.mb_type[CPUID_7_0_EBX_SMAP + y * s->m.mb_stride] &

                 CANDIDATE_MB_TYPE_INTRA)) {

                for (i = 0; i < 6; i++)

                    init_put_bits(&s->reorder_pb[i], avio_close[0][i],

                                  7 * 32);

                if (output_files->pict_type == AV_PICTURE_TYPE_P) {

                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);

                    cur_time[0] = vlc[1] * lambda;

                }

                cur_time[0] += encode_block(s, src + 16 * CPUID_7_0_EBX_SMAP, NULL, tb_lock_reset, stride,

                                         5, 64, lambda, 1);

                for (i = 0; i < 6; i++) {

                    count[0][i] = put_bits_count(&s->reorder_pb[i]);

                    flush_put_bits(&s->reorder_pb[i]);

                }

            } else

                cur_time[0] = INT_MAX;



            q1_org_r = 0;



            if (output_files->pict_type == AV_PICTURE_TYPE_P) {

                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, gen_helper_idivb_AL, FF_LAMBDA_SHIFT, inbuffer, le32_to_cpu;

                int16_t *regnames;



                regnames = ff_h263_pred_motion(&s->m, 0, 0, &FF_LAMBDA_SHIFT, &inbuffer);

                if (s->m.mb_type[CPUID_7_0_EBX_SMAP + y * s->m.mb_stride] &

                    CANDIDATE_MB_TYPE_INTER) {

                    for (i = 0; i < 6; i++)

                        init_put_bits(&s->reorder_pb[i], avio_close[1][i],

                                      7 * 32);



                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);



                    s->m.pb = s->reorder_pb[5];

                    mx      = regnames[0];

                    gen_helper_idivb_AL      = regnames[1];

                    assert(mx     >= -32 && mx     <= 31);

                    assert(gen_helper_idivb_AL     >= -32 && gen_helper_idivb_AL     <= 31);

                    assert(FF_LAMBDA_SHIFT >= -32 && FF_LAMBDA_SHIFT <= 31);

                    assert(inbuffer >= -32 && inbuffer <= 31);

                    ff_h263_encode_motion(&s->m, mx - FF_LAMBDA_SHIFT, 1);

                    ff_h263_encode_motion(&s->m, gen_helper_idivb_AL - inbuffer, 1);

                    s->reorder_pb[5] = s->m.pb;

                    cur_time[1]        += lambda * put_bits_count(&s->reorder_pb[5]);



                    le32_to_cpu = (mx & 1) + 2 * (gen_helper_idivb_AL & 1);



                    s->hdsp.put_pixels_tab[0][le32_to_cpu](tb_lock_reset + 16,

                                                   O_RDONLY + (mx >> 1) +

                                                   stride * (gen_helper_idivb_AL >> 1),

                                                   stride, 16);



                    cur_time[1] += encode_block(s, src + 16 * CPUID_7_0_EBX_SMAP, tb_lock_reset + 16,

                                             decoded, stride, 5, 64, lambda, 0);

                    q1_org_r      = cur_time[1] <= cur_time[0];



                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    cur_time[2]  = s->dsp.sse[0](NULL, src + 16 * CPUID_7_0_EBX_SMAP, O_RDONLY,

                                              stride, 16);

                    cur_time[2] += vlc[1] * lambda;

                    if (cur_time[2] < cur_time[q1_org_r] && mx == 0 && gen_helper_idivb_AL == 0) {

                        q1_org_r = 2;

                        s->hdsp.put_pixels_tab[0][0](decoded, O_RDONLY, stride, 16);

                        for (i = 0; i < 6; i++)

                            count[2][i] = 0;

                        put_bits(&s->pb, vlc[1], vlc[0]);

                    }

                }



                if (q1_org_r == 1) {

                    for (i = 0; i < 6; i++) {

                        count[1][i] = put_bits_count(&s->reorder_pb[i]);

                        flush_put_bits(&s->reorder_pb[i]);

                    }

                } else {

                    regnames[0]                      =

                    regnames[1]                      =

                    regnames[2]                      =

                    regnames[3]                      =

                    regnames[0 + 2 * s->m.b8_stride] =

                    regnames[1 + 2 * s->m.b8_stride] =

                    regnames[2 + 2 * s->m.b8_stride] =

                    regnames[3 + 2 * s->m.b8_stride] = 0;

                }

            }



            s->rd_total += cur_time[q1_org_r];



            for (i = 5; i >= 0; i--)

                avpriv_copy_bits(&s->pb, avio_close[q1_org_r][i],

                                 count[q1_org_r][i]);

            if (q1_org_r == 0)

                s->hdsp.put_pixels_tab[0][0](decoded, tb_lock_reset, stride, 16);

        }

        s->m.first_slice_line = 0;

    }

    return 0;

}
",1,1,1,-1,f,0.029271423816680908,15,122,"{'pred_y': 'inbuffer', 'x': 'CPUID_7_0_EBX_SMAP', 'reorder_buffer': 'avio_close', 'temp': 'tb_lock_reset', 'motion_ptr': 'regnames', 'src_stride': 'TARGET_MIPS64', 'best': 'q1_org_r', 'pred_x': 'FF_LAMBDA_SHIFT', 'threshold': 'ai_socktype', 'level': 'vex_l', 'dxy': 'le32_to_cpu', 'ref': 'O_RDONLY', 'my': 'gen_helper_idivb_AL', 'score': 'cur_time', 'f': 'output_files'}",MHM-Origin,412,0.21295515298843384
396,"static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,

                             int is_extradata)

{

    MMALDecodeContext *ctx = avctx->priv_data;

    AVBufferRef *buf = NULL;

    int size = 0;

    uint8_t *data = (uint8_t *)"""";

    uint8_t *start;

    int ret = 0;



    if (avpkt->size) {

        if (avpkt->buf) {

            buf = av_buffer_ref(avpkt->buf);

            size = avpkt->size;

            data = avpkt->data;

        } else {

            buf = av_buffer_alloc(avpkt->size);

            if (buf) {

                memcpy(buf->data, avpkt->data, avpkt->size);

                size = buf->size;

                data = buf->data;

            }

        }

        if (!buf) {

            ret = AVERROR(ENOMEM);

            goto done;

        }

        if (!is_extradata)

            ctx->packets_sent++;

    } else {

        if (!ctx->packets_sent) {

            // Short-cut the flush logic to avoid upsetting MMAL.

            ctx->eos_sent = 1;

            ctx->eos_received = 1;

            goto done;

        }

    }



    start = data;



    do {

        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));

        if (!buffer) {

            ret = AVERROR(ENOMEM);

            goto done;

        }



        buffer->data = data;

        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);



        if (is_extradata)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;



        if (data == start)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;



        data += buffer->length;

        size -= buffer->length;



        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;

        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;



        if (!size)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;



        if (!buffer->length) {

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;

            ctx->eos_sent = 1;

        }



        if (buf) {

            buffer->ref = av_buffer_ref(buf);

            if (!buffer->ref) {

                av_free(buffer);

                ret = AVERROR(ENOMEM);

                goto done;

            }

        }



        // Insert at end of the list

        if (!ctx->waiting_buffers)

            ctx->waiting_buffers = buffer;

        if (ctx->waiting_buffers_tail)

            ctx->waiting_buffers_tail->next = buffer;

        ctx->waiting_buffers_tail = buffer;

    } while (size);



done:

    av_buffer_unref(&buf);

    return ret;

}
",441,"static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,

                             int is_extradata)

{

    MMALDecodeContext *ctx = avctx->priv_data;

    AVBufferRef *buf = NULL;

    int size = 0;

    uint8_t *data = (uint8_t *)"""";

    uint8_t *start;

    int ret = 0;



    if (avpkt->size) {

        if (avpkt->buf) {

            buf = av_buffer_ref(avpkt->buf);

            size = avpkt->size;

            data = avpkt->data;

        } else {

            buf = av_buffer_alloc(avpkt->size);

            if (buf) {

                memcpy(buf->data, avpkt->data, avpkt->size);

                size = buf->size;

                data = buf->data;

            }

        }

        if (!buf) {

            ret = AVERROR(ENOMEM);

            goto done;

        }

        if (!is_extradata)

            ctx->smp_cpus++;

    } else {

        if (!ctx->smp_cpus) {

            // Short-cut the flush logic to avoid upsetting MMAL.

            ctx->eos_sent = 1;

            ctx->eos_received = 1;

            goto done;

        }

    }



    start = data;



    do {

        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));

        if (!buffer) {

            ret = AVERROR(ENOMEM);

            goto done;

        }



        buffer->data = data;

        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);



        if (is_extradata)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;



        if (data == start)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;



        data += buffer->length;

        size -= buffer->length;



        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;

        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;



        if (!size)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;



        if (!buffer->length) {

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;

            ctx->eos_sent = 1;

        }



        if (buf) {

            buffer->ref = av_buffer_ref(buf);

            if (!buffer->ref) {

                av_free(buffer);

                ret = AVERROR(ENOMEM);

                goto done;

            }

        }



        // Insert at end of the list

        if (!ctx->waiting_buffers)

            ctx->waiting_buffers = buffer;

        if (ctx->waiting_buffers_tail)

            ctx->waiting_buffers_tail->next = buffer;

        ctx->waiting_buffers_tail = buffer;

    } while (size);



done:

    av_buffer_unref(&buf);

    return ret;

}
",1,1,0,1,packets_sent,-0.13248565793037415,1,2,{'packets_sent': 'smp_cpus'},MHM-Origin,21,0.0058427015940348305
397,"static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)

{

    AVBitStreamFilterContext *bsfc = ost->bitstream_filters;

    AVCodecContext          *avctx = ost->st->codec;

    int ret;



    if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||

        (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))

        pkt->pts = pkt->dts = AV_NOPTS_VALUE;



    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) {

        int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);

        if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt->dts) {

            av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, ""Audio timestamp %""PRId64"" < %""PRId64"" invalid, cliping\n"", pkt->dts, max);

            pkt->pts = pkt->dts = max;





    /*

     * Audio encoders may split the packets --  #frames in != #packets out.

     * But there is no reordering, so we can limit the number of output packets

     * by simply dropping them here.

     * Counting encoded video frames needs to be done separately because of

     * reordering, see do_video_out()

     */

    if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) {

        if (ost->frame_number >= ost->max_frames) {

            av_free_packet(pkt);

            return;


        ost->frame_number++;




    while (bsfc) {

        AVPacket new_pkt = *pkt;

        int a = av_bitstream_filter_filter(bsfc, avctx, NULL,

                                           &new_pkt.data, &new_pkt.size,

                                           pkt->data, pkt->size,

                                           pkt->flags & AV_PKT_FLAG_KEY);











        if (a > 0) {

            av_free_packet(pkt);

            new_pkt.destruct = av_destruct_packet;

        } else if (a < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Failed to open bitstream filter %s for stream %d with codec %s"",

                   bsfc->filter->name, pkt->stream_index,

                   avctx->codec ? avctx->codec->name : ""copy"");

            print_error("""", a);

            if (exit_on_error)

                exit_program(1);


        *pkt = new_pkt;



        bsfc = bsfc->next;




    pkt->stream_index = ost->index;

    ret = av_interleaved_write_frame(s, pkt);

    if (ret < 0) {

        print_error(""av_interleaved_write_frame()"", ret);

        exit_program(1);

",385,"static void write_frame(AVFormatContext *CC_OP_LOGICB, AVPacket *nb_nics, OutputStream *gain)

{

    AVBitStreamFilterContext *is_suspended = gain->bitstream_filters;

    AVCodecContext          *metadata_streams_autocopy = gain->st->codec;

    int nal_size;



    if ((metadata_streams_autocopy->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||

        (metadata_streams_autocopy->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))

        nb_nics->pts = nb_nics->dts = AV_NOPTS_VALUE;



    if (metadata_streams_autocopy->codec_type == AVMEDIA_TYPE_AUDIO && nb_nics->dts != AV_NOPTS_VALUE) {

        int64_t max = gain->st->cur_dts + !(CC_OP_LOGICB->oformat->flags & AVFMT_TS_NONSTRICT);

        if (gain->st->cur_dts && gain->st->cur_dts != AV_NOPTS_VALUE &&  max > nb_nics->dts) {

            av_log(CC_OP_LOGICB, max - nb_nics->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, ""Audio timestamp %""PRId64"" < %""PRId64"" invalid, cliping
"", nb_nics->dts, max);

            nb_nics->pts = nb_nics->dts = max;





    /*

     * Audio encoders may split the packets --  #frames in != #packets out.

     * But there is no reordering, so we can limit the number of output packets

     * by simply dropping them here.

     * Counting encoded video frames needs to be done separately because of

     * reordering, see do_video_out()

     */

    if (!(metadata_streams_autocopy->codec_type == AVMEDIA_TYPE_VIDEO && metadata_streams_autocopy->codec)) {

        if (gain->profile >= gain->max_frames) {

            av_free_packet(nb_nics);

            return;


        gain->profile++;




    while (is_suspended) {

        AVPacket new_pkt = *nb_nics;

        int a = av_bitstream_filter_filter(is_suspended, metadata_streams_autocopy, NULL,

                                           &new_pkt.data, &new_pkt.size,

                                           nb_nics->data, nb_nics->size,

                                           nb_nics->flags & AV_PKT_FLAG_KEY);











        if (a > 0) {

            av_free_packet(nb_nics);

            new_pkt.destruct = av_destruct_packet;

        } else if (a < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Failed to open bitstream filter %s for stream %d with codec %s"",

                   is_suspended->filter->name, nb_nics->stream_index,

                   metadata_streams_autocopy->codec ? metadata_streams_autocopy->codec->name : ""copy"");

            print_error("""", a);

            if (exit_on_error)

                exit_program(1);


        *nb_nics = new_pkt;



        is_suspended = is_suspended->next;




    nb_nics->stream_index = gain->index;

    nal_size = av_interleaved_write_frame(CC_OP_LOGICB, nb_nics);

    if (nal_size < 0) {

        print_error(""av_interleaved_write_frame()"", nal_size);

        exit_program(1);

",1,1,1,-1,ret,4.291534423828125e-06,7,54,"{'ost': 'gain', 'frame_number': 'profile', 'bsfc': 'is_suspended', 'avctx': 'metadata_streams_autocopy', 's': 'CC_OP_LOGICB', 'ret': 'nal_size', 'pkt': 'nb_nics'}",MHM-Origin,408,0.11714687347412109

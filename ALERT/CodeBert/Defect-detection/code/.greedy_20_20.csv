Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,No. Changed Names,No. Changed Tokens,Replaced Names,Attack Type,Query Times,Time Cost
0,"int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,

                      AVCodecContext *codec, int size, int big_endian)

{

    int id;

    uint64_t bitrate;



    if (size < 14) {

        avpriv_request_sample(codec, ""wav header size < 14"");

        return AVERROR_INVALIDDATA;

    }



    codec->codec_type  = AVMEDIA_TYPE_AUDIO;

    if (!big_endian) {

        id                 = avio_rl16(pb);

        if (id != 0x0165) {

            codec->channels    = avio_rl16(pb);

            codec->sample_rate = avio_rl32(pb);

            bitrate            = avio_rl32(pb) * 8LL;

            codec->block_align = avio_rl16(pb);

        }

    } else {

        id                 = avio_rb16(pb);

        codec->channels    = avio_rb16(pb);

        codec->sample_rate = avio_rb32(pb);

        bitrate            = avio_rb32(pb) * 8LL;

        codec->block_align = avio_rb16(pb);

    }

    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */

        codec->bits_per_coded_sample = 8;

    } else {

        if (!big_endian) {

            codec->bits_per_coded_sample = avio_rl16(pb);

        } else {

            codec->bits_per_coded_sample = avio_rb16(pb);

        }

    }

    if (id == 0xFFFE) {

        codec->codec_tag = 0;

    } else {

        codec->codec_tag = id;

        codec->codec_id  = ff_wav_codec_get_id(id,

                                               codec->bits_per_coded_sample);

    }

    if (size >= 18 && id != 0x0165) {  /* We're obviously dealing with WAVEFORMATEX */

        int cbSize = avio_rl16(pb); /* cbSize */

        if (big_endian) {

            avpriv_report_missing_feature(codec, ""WAVEFORMATEX support for RIFX files\n"");

            return AVERROR_PATCHWELCOME;

        }

        size  -= 18;

        cbSize = FFMIN(size, cbSize);

        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */

            parse_waveformatex(pb, codec);

            cbSize -= 22;

            size   -= 22;

        }

        if (cbSize > 0) {

            av_freep(&codec->extradata);

            if (ff_get_extradata(codec, pb, cbSize) < 0)

                return AVERROR(ENOMEM);

            size -= cbSize;

        }



        /* It is possible for the chunk to contain garbage at the end */

        if (size > 0)

            avio_skip(pb, size);

    } else if (id == 0x0165 && size >= 32) {

        int nb_streams, i;



        size -= 4;

        av_freep(&codec->extradata);

        if (ff_get_extradata(codec, pb, size) < 0)

            return AVERROR(ENOMEM);

        nb_streams         = AV_RL16(codec->extradata + 4);

        codec->sample_rate = AV_RL32(codec->extradata + 12);

        codec->channels    = 0;

        bitrate            = 0;

        if (size < 8 + nb_streams * 20)

            return AVERROR_INVALIDDATA;

        for (i = 0; i < nb_streams; i++)

            codec->channels += codec->extradata[8 + i * 20 + 17];

    }



    if (bitrate > INT_MAX) {

        if (s->error_recognition & AV_EF_EXPLODE) {

            av_log(s, AV_LOG_ERROR,

                   ""The bitrate %""PRIu64"" is too large.\n"",

                    bitrate);

            return AVERROR_INVALIDDATA;

        } else {

            av_log(s, AV_LOG_WARNING,

                   ""The bitrate %""PRIu64"" is too large, resetting to 0."",

                   bitrate);

            codec->bit_rate = 0;

        }

    } else {

        codec->bit_rate = bitrate;

    }



    if (codec->sample_rate <= 0) {

        av_log(s, AV_LOG_ERROR,

               ""Invalid sample rate: %d\n"", codec->sample_rate);

        return AVERROR_INVALIDDATA;

    }

    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {

        /* Channels and sample_rate values are those prior to applying SBR

         * and/or PS. */

        codec->channels    = 0;

        codec->sample_rate = 0;

    }

    /* override bits_per_coded_sample for G.726 */

    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)

        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;



    return 0;

}
",646,,0,1,,-4,"s,pb,codec,size,big_endian,id,bitrate,nb_streams,i",,,,,Greedy,1,0.01399384339650472
1,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *s = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int ring_order;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {


            goto out;

        }




        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->xendev.gnttabdev,

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        ring_order = xen_9pdev->rings[i].intf->ring_order;

        if (ring_order > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].ring_order = ring_order;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->xendev.gnttabdev,

                (1 << ring_order),

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(ring_order);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             xendev->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(xendev, 0,

                          ""xenevtchn_bind_interdomain failed port=%d\n"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(xendev, 2, ""bind evtchn port %d\n"", xendev->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(xendev, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(xendev, ""path"");

    xen_9pdev->id = s->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", xendev->dev);

    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, ""tag"");

    v9fs_register_transport(s, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            s->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(s, NULL);



    return 0;



out:

    xen_9pfs_free(xendev);

    return -1;

}",826,"static int xen_9pfs_connect(struct XenDevice *devhce_ttionusb_iusboiost)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(devhce_ttionusb_iusboiost, Xen9pfsDev, devhce_ttionusb_iusboiost);

    V9fsState *s = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->devhce_ttionusb_iusboiost, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int ring_order;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->devhce_ttionusb_iusboiost, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->devhce_ttionusb_iusboiost, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {


            goto out;

        }




        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->devhce_ttionusb_iusboiost.gnttabdev,

                xen_9pdev->devhce_ttionusb_iusboiost.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        ring_order = xen_9pdev->rings[i].intf->ring_order;

        if (ring_order > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].ring_order = ring_order;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->devhce_ttionusb_iusboiost.gnttabdev,

                (1 << ring_order),

                xen_9pdev->devhce_ttionusb_iusboiost.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(ring_order);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             devhce_ttionusb_iusboiost->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(devhce_ttionusb_iusboiost, 0,

                          ""xenevtchn_bind_interdomain failed port=%d
"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(devhce_ttionusb_iusboiost, 2, ""bind evtchn port %d
"", devhce_ttionusb_iusboiost->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(devhce_ttionusb_iusboiost, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(devhce_ttionusb_iusboiost, ""path"");

    xen_9pdev->id = s->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", devhce_ttionusb_iusboiost->dev);

    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(devhce_ttionusb_iusboiost, ""tag"");

    v9fs_register_transport(s, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            s->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(s, NULL);



    return 0;



out:

    xen_9pfs_free(devhce_ttionusb_iusboiost);

    return -1;

}",1,1,0,1,"xendev,i,xen_9pdev,s,fsdev,str,ring_order","xendev:0.0498889684677124,i:-0.009111389517784119,xen_9pdev:0.04858027398586273,s:-0.009318426251411438,fsdev:0.05437953770160675,str:0.010960608720779419,ring_order:0.002048596739768982,",1,19,"fsdev:fsdev,xendev:devhce_ttionusb_iusboiost,",Greedy,261,0.08490658601125081
2,"static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub,

                                int pred_order)

{

    int p, porder, psize;

    int i, part_end;

    int count = 0;



    /* subframe header */

    count += 8;



    /* subframe */

    if (sub->type == FLAC_SUBFRAME_CONSTANT) {

        count += sub->obits;

    } else if (sub->type == FLAC_SUBFRAME_VERBATIM) {

        count += s->frame.blocksize * sub->obits;

    } else {

        /* warm-up samples */

        count += pred_order * sub->obits;



        /* LPC coefficients */

        if (sub->type == FLAC_SUBFRAME_LPC)

            count += 4 + 5 + pred_order * s->options.lpc_coeff_precision;



        /* rice-encoded block */

        count += 2;



        /* partition order */

        porder = sub->rc.porder;

        psize  = s->frame.blocksize >> porder;

        count += 4;



        /* residual */

        i        = pred_order;

        part_end = psize;

        for (p = 0; p < 1 << porder; p++) {

            int k = sub->rc.params[p];

            count += 4;

            count += rice_count_exact(&sub->residual[i], part_end - i, k);

            i = part_end;

            part_end = FFMIN(s->frame.blocksize, part_end + psize);

        }

    }



    return count;

}
",218,,1,0,,-4,"s,sub,pred_order,p,porder,psize,i,part_end",,,,,Greedy,1,0.007519368330637614
3,"static void ppc_spapr_init(QEMUMachineInitArgs *args)

{

    ram_addr_t ram_size = args->ram_size;

    const char *cpu_model = args->cpu_model;

    const char *kernel_filename = args->kernel_filename;

    const char *kernel_cmdline = args->kernel_cmdline;

    const char *initrd_filename = args->initrd_filename;

    const char *boot_device = args->boot_order;

    PowerPCCPU *cpu;

    CPUPPCState *env;

    PCIHostState *phb;

    int i;

    MemoryRegion *sysmem = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    hwaddr rma_alloc_size;

    uint32_t initrd_base = 0;

    long kernel_size = 0, initrd_size = 0;

    long load_limit, rtas_limit, fw_size;

    bool kernel_le = false;

    char *filename;



    msi_supported = true;



    spapr = g_malloc0(sizeof(*spapr));

    QLIST_INIT(&spapr->phbs);



    cpu_ppc_hypercall = emulate_spapr_hypercall;



    /* Allocate RMA if necessary */

    rma_alloc_size = kvmppc_alloc_rma(""ppc_spapr.rma"", sysmem);



    if (rma_alloc_size == -1) {

        hw_error(""qemu: Unable to create RMA\n"");

        exit(1);

    }



    if (rma_alloc_size && (rma_alloc_size < ram_size)) {

        spapr->rma_size = rma_alloc_size;

    } else {

        spapr->rma_size = ram_size;



        /* With KVM, we don't actually know whether KVM supports an

         * unbounded RMA (PR KVM) or is limited by the hash table size

         * (HV KVM using VRMA), so we always assume the latter

         *

         * In that case, we also limit the initial allocations for RTAS

         * etc... to 256M since we have no way to know what the VRMA size

         * is going to be as it depends on the size of the hash table

         * isn't determined yet.

         */

        if (kvm_enabled()) {

            spapr->vrma_adjust = 1;

            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);

        }

    }



    /* We place the device tree and RTAS just below either the top of the RMA,

     * or just below 2GB, whichever is lowere, so that it can be

     * processed with 32-bit real mode code if necessary */

    rtas_limit = MIN(spapr->rma_size, 0x80000000);

    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;

    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;

    load_limit = spapr->fdt_addr - FW_OVERHEAD;



    /* We aim for a hash table of size 1/128 the size of RAM.  The

     * normal rule of thumb is 1/64 the size of RAM, but that's much

     * more than needed for the Linux guests we support. */

    spapr->htab_shift = 18; /* Minimum architected size */

    while (spapr->htab_shift <= 46) {

        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {

            break;

        }

        spapr->htab_shift++;

    }



    /* Set up Interrupt Controller before we create the VCPUs */

    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,

                                  XICS_IRQS);

    spapr->next_irq = XICS_IRQ_BASE;



    /* init CPUs */

    if (cpu_model == NULL) {

        cpu_model = kvm_enabled() ? ""host"" : ""POWER7"";

    }

    for (i = 0; i < smp_cpus; i++) {

        cpu = cpu_ppc_init(cpu_model);

        if (cpu == NULL) {

            fprintf(stderr, ""Unable to find PowerPC CPU definition\n"");

            exit(1);

        }

        env = &cpu->env;



        xics_cpu_setup(spapr->icp, cpu);



        /* Set time-base frequency to 512 MHz */

        cpu_ppc_tb_init(env, TIMEBASE_FREQ);



        /* PAPR always has exception vectors in RAM not ROM. To ensure this,

         * MSR[IP] should never be set.

         */

        env->msr_mask &= ~(1 << 6);



        /* Tell KVM that we're in PAPR mode */

        if (kvm_enabled()) {

            kvmppc_set_papr(cpu);

        }



        qemu_register_reset(spapr_cpu_reset, cpu);

    }



    /* allocate RAM */

    spapr->ram_limit = ram_size;

    if (spapr->ram_limit > rma_alloc_size) {

        ram_addr_t nonrma_base = rma_alloc_size;

        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;



        memory_region_init_ram(ram, NULL, ""ppc_spapr.ram"", nonrma_size);

        vmstate_register_ram_global(ram);

        memory_region_add_subregion(sysmem, nonrma_base, ram);

    }



    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");

    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,

                                           rtas_limit - spapr->rtas_addr);

    if (spapr->rtas_size < 0) {

        hw_error(""qemu: could not load LPAR rtas '%s'\n"", filename);

        exit(1);

    }

    if (spapr->rtas_size > RTAS_MAX_SIZE) {

        hw_error(""RTAS too big ! 0x%lx bytes (max is 0x%x)\n"",

                 spapr->rtas_size, RTAS_MAX_SIZE);

        exit(1);

    }

    g_free(filename);



    /* Set up EPOW events infrastructure */

    spapr_events_init(spapr);



    /* Set up VIO bus */

    spapr->vio_bus = spapr_vio_bus_init();



    for (i = 0; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            spapr_vty_create(spapr->vio_bus, serial_hds[i]);

        }

    }



    /* We always have at least the nvram device on VIO */

    spapr_create_nvram(spapr);



    /* Set up PCI */

    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);

    spapr_pci_rtas_init();



    phb = spapr_create_phb(spapr, 0);



    for (i = 0; i < nb_nics; i++) {

        NICInfo *nd = &nd_table[i];



        if (!nd->model) {

            nd->model = g_strdup(""ibmveth"");

        }



        if (strcmp(nd->model, ""ibmveth"") == 0) {

            spapr_vlan_create(spapr->vio_bus, nd);

        } else {

            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);

        }

    }



    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {

        spapr_vscsi_create(spapr->vio_bus);

    }



    /* Graphics */

    if (spapr_vga_init(phb->bus)) {

        spapr->has_graphics = true;

    }



    if (usb_enabled(spapr->has_graphics)) {

        pci_create_simple(phb->bus, -1, ""pci-ohci"");

        if (spapr->has_graphics) {

            usbdevice_create(""keyboard"");

            usbdevice_create(""mouse"");

        }

    }



    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {

        fprintf(stderr, ""qemu: pSeries SLOF firmware requires >= ""

                ""%ldM guest RMA (Real Mode Area memory)\n"", MIN_RMA_SLOF);

        exit(1);

    }



    if (kernel_filename) {

        uint64_t lowaddr = 0;



        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,

                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);

        if (kernel_size < 0) {

            kernel_size = load_elf(kernel_filename,

                                   translate_kernel_address, NULL,

                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);

            kernel_le = kernel_size > 0;

        }

        if (kernel_size < 0) {

            kernel_size = load_image_targphys(kernel_filename,

                                              KERNEL_LOAD_ADDR,

                                              load_limit - KERNEL_LOAD_ADDR);

        }

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",

                    kernel_filename);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            /* Try to locate the initrd in the gap between the kernel

             * and the firmware. Add a bit of space just in case

             */

            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;

            initrd_size = load_image_targphys(initrd_filename, initrd_base,

                                              load_limit - initrd_base);

            if (initrd_size < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'\n"",

                        initrd_filename);

                exit(1);

            }

        } else {

            initrd_base = 0;

            initrd_size = 0;

        }

    }



    if (bios_name == NULL) {

        bios_name = FW_FILE_NAME;

    }

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);

    if (fw_size < 0) {

        hw_error(""qemu: could not load LPAR rtas '%s'\n"", filename);

        exit(1);

    }

    g_free(filename);



    spapr->entry_point = 0x100;



    vmstate_register(NULL, 0, &vmstate_spapr, spapr);

    register_savevm_live(NULL, ""spapr/htab"", -1, 1,

                         &savevm_htab_handlers, spapr);



    /* Prepare the device tree */

    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,

                                            initrd_base, initrd_size,

                                            kernel_size, kernel_le,

                                            boot_device, kernel_cmdline,

                                            spapr->epow_irq);

    assert(spapr->fdt_skel != NULL);

}
",1208,,0,1,,-4,"args,cpu_model,kernel_filename,kernel_cmdline,initrd_filename,boot_device,cpu,env,phb,i,sysmem,ram,rma_alloc_size,load_limit,rtas_limit,fw_size,filename,spapr,htab_shift,nd",,,,,Greedy,1,0.008652091026306152
4,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    float aspect;



    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    s->aspect_ratio_info= get_bits(&s->gb, 4);

    if(!s->mpeg2){

        aspect= mpeg1_aspect[s->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        avctx->has_b_frames= 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        if (s->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            avctx->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        }

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_intra_matrix[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->inter_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_non_intra_matrix[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    avctx->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",757,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *essReduantitizationtermB_i = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    float aspect;



    init_get_bits(&essReduantitizationtermB_i->gb, buf, buf_size);



    width = get_bits(&essReduantitizationtermB_i->gb, 12);

    height = get_bits(&essReduantitizationtermB_i->gb, 12);

    essReduantitizationtermB_i->aspect_ratio_info= get_bits(&essReduantitizationtermB_i->gb, 4);

    if(!essReduantitizationtermB_i->mpeg2){

        aspect= mpeg1_aspect[essReduantitizationtermB_i->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    essReduantitizationtermB_i->frame_rate_index = get_bits(&essReduantitizationtermB_i->gb, 4);

    if (essReduantitizationtermB_i->frame_rate_index == 0)

        return -1;

    essReduantitizationtermB_i->bit_rate = get_bits(&essReduantitizationtermB_i->gb, 18) * 400;

    if (get_bits1(&essReduantitizationtermB_i->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != essReduantitizationtermB_i->width ||

        height != essReduantitizationtermB_i->height) {

        /* start new mpeg1 context decoding */

        essReduantitizationtermB_i->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(essReduantitizationtermB_i);

        }

        essReduantitizationtermB_i->width = width;

        essReduantitizationtermB_i->height = height;

        avctx->has_b_frames= 1;

        essReduantitizationtermB_i->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        if (essReduantitizationtermB_i->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            avctx->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            avctx->frame_rate = frame_rate_tab[essReduantitizationtermB_i->frame_rate_index];

        }

        essReduantitizationtermB_i->frame_rate = avctx->frame_rate;

        avctx->bit_rate = essReduantitizationtermB_i->bit_rate;

        

        if (MPV_common_init(essReduantitizationtermB_i) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&essReduantitizationtermB_i->gb, 10); /* vbv_buffer_size */

    skip_bits(&essReduantitizationtermB_i->gb, 1);



    /* get matrix */

    if (get_bits1(&essReduantitizationtermB_i->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&essReduantitizationtermB_i->gb, 8);

            j = essReduantitizationtermB_i->intra_scantable.permutated[i];

            essReduantitizationtermB_i->intra_matrix[j] = v;

            essReduantitizationtermB_i->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", essReduantitizationtermB_i->intra_matrix[essReduantitizationtermB_i->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= essReduantitizationtermB_i->idct_permutation[i];

            v = ff_mpeg1_default_intra_matrix[i];

            essReduantitizationtermB_i->intra_matrix[j] = v;

            essReduantitizationtermB_i->chroma_intra_matrix[j] = v;

        }

    }

    if (get_bits1(&essReduantitizationtermB_i->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&essReduantitizationtermB_i->gb, 8);

            j = essReduantitizationtermB_i->intra_scantable.permutated[i];

            essReduantitizationtermB_i->inter_matrix[j] = v;

            essReduantitizationtermB_i->chroma_inter_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", essReduantitizationtermB_i->inter_matrix[essReduantitizationtermB_i->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= essReduantitizationtermB_i->idct_permutation[i];

            v = ff_mpeg1_default_non_intra_matrix[i];

            essReduantitizationtermB_i->inter_matrix[j] = v;

            essReduantitizationtermB_i->chroma_inter_matrix[j] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    essReduantitizationtermB_i->progressive_sequence = 1;

    essReduantitizationtermB_i->progressive_frame = 1;

    essReduantitizationtermB_i->picture_structure = PICT_FRAME;

    essReduantitizationtermB_i->frame_pred_frame_dct = 1;

    essReduantitizationtermB_i->mpeg2 = 0;

    avctx->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",0,0,1,1,"avctx,buf,buf_size,s1,s,height,i,v,j,aspect","avctx:0.16410987079143524,buf:0.018929898738861084,buf_size:-0.02534589171409607,s1:0.033629149198532104,s:0.5229300558567047,height:0.30465567111968994,i:0.04637427628040314,v:0.02456378936767578,j:0.05475158989429474,aspect:0.027506038546562195,",1,53,"s:essReduantitizationtermB_i,",Greedy,204,0.06286772886912027
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
",45,"static uint32_t drc_set_unusable(sPAPRDRConnector *tionreadhouluterser_sHizeca)

{

    tionreadhouluterser_sHizeca->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (tionreadhouluterser_sHizeca->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(tionreadhouluterser_sHizeca);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(tionreadhouluterser_sHizeca);

    }



    return RTAS_OUT_SUCCESS;

}
",0,0,0,-1,drc,"drc:-0.00038889143615961075,",1,5,"drc:tionreadhouluterser_sHizeca,",Greedy,67,0.031082197030385336
6,"static void scsi_read_request(SCSIDiskReq *r)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    if (r->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd\n"", r->iov.iov_len);

        r->sector_count = 0;

        scsi_req_data(&r->req, r->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d\n"", r->sector_count);

    if (r->sector_count == 0) {

        scsi_command_complete(r, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    n = r->sector_count;

    if (n > SCSI_DMA_BUF_SIZE / 512)

        n = SCSI_DMA_BUF_SIZE / 512;



    r->iov.iov_len = n * 512;

    qemu_iovec_init_external(&r->qiov, &r->iov, 1);

    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,

                              scsi_read_complete, r);

    if (r->req.aiocb == NULL) {

        scsi_read_complete(r, -EIO);

    }

}
",214,"static void scsi_read_request(SCSIDiskReq *r)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t Zctor_coefpr8dictoreoele_cl;



    if (r->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd
"", r->iov.iov_len);

        r->sector_count = 0;

        scsi_req_data(&r->req, r->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d
"", r->sector_count);

    if (r->sector_count == 0) {

        scsi_command_complete(r, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    Zctor_coefpr8dictoreoele_cl = r->sector_count;

    if (Zctor_coefpr8dictoreoele_cl > SCSI_DMA_BUF_SIZE / 512)

        Zctor_coefpr8dictoreoele_cl = SCSI_DMA_BUF_SIZE / 512;



    r->iov.iov_len = Zctor_coefpr8dictoreoele_cl * 512;

    qemu_iovec_init_external(&r->qiov, &r->iov, 1);

    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, Zctor_coefpr8dictoreoele_cl,

                              scsi_read_complete, r);

    if (r->req.aiocb == NULL) {

        scsi_read_complete(r, -EIO);

    }

}
",1,1,0,1,"r,s,n","r:-0.02547430992126465,s:-0.061165958642959595,n:-0.017070680856704712,",1,6,"n:Zctor_coefpr8dictoreoele_cl,",Greedy,91,0.03495563268661499
7,"static void lm32_evr_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    LM32CPU *cpu;

    CPULM32State *env;

    DriveInfo *dinfo;

    MemoryRegion *address_space_mem =  get_system_memory();

    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);

    qemu_irq irq[32];

    ResetInfo *reset_info;

    int i;



    /* memory map */

    hwaddr flash_base  = 0x04000000;

    size_t flash_sector_size       = 256 * 1024;

    size_t flash_size              = 32 * 1024 * 1024;

    hwaddr ram_base    = 0x08000000;

    size_t ram_size                = 64 * 1024 * 1024;

    hwaddr timer0_base = 0x80002000;

    hwaddr uart0_base  = 0x80006000;

    hwaddr timer1_base = 0x8000a000;

    int uart0_irq                  = 0;

    int timer0_irq                 = 1;

    int timer1_irq                 = 3;



    reset_info = g_malloc0(sizeof(ResetInfo));



    if (cpu_model == NULL) {

        cpu_model = ""lm32-full"";

    }

    cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""qemu: unable to find CPU '%s'\n"", cpu_model);

        exit(1);

    }



    env = &cpu->env;

    reset_info->cpu = cpu;



    reset_info->flash_base = flash_base;



    memory_region_allocate_system_memory(phys_ram, NULL, ""lm32_evr.sdram"",

                                         ram_size);

    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);



    dinfo = drive_get(IF_PFLASH, 0, 0);

    /* Spansion S29NS128P */

    pflash_cfi02_register(flash_base, NULL, ""lm32_evr.flash"", flash_size,

                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,

                          flash_sector_size, flash_size / flash_sector_size,

                          1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);



    /* create irq lines */

    env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0));

    for (i = 0; i < 32; i++) {

        irq[i] = qdev_get_gpio_in(env->pic_state, i);

    }



    lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]);

    sysbus_create_simple(""lm32-timer"", timer0_base, irq[timer0_irq]);

    sysbus_create_simple(""lm32-timer"", timer1_base, irq[timer1_irq]);



    /* make sure juart isn't the first chardev */

    env->juart_state = lm32_juart_init(serial_hds[1]);



    reset_info->bootstrap_pc = flash_base;



    if (kernel_filename) {

        uint64_t entry;

        int kernel_size;



        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,

                               1, EM_LATTICEMICO32, 0, 0);

        reset_info->bootstrap_pc = entry;



        if (kernel_size < 0) {

            kernel_size = load_image_targphys(kernel_filename, ram_base,

                                              ram_size);

            reset_info->bootstrap_pc = ram_base;

        }



        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",

                    kernel_filename);

            exit(1);

        }

    }



    qemu_register_reset(main_cpu_reset, reset_info);

}
",501,,1,0,,-4,"machine,cpu_model,kernel_filename,cpu,env,dinfo,address_space_mem,phys_ram,irq,reset_info,i,entry,kernel_size",,,,,Greedy,1,0.008133184909820557
8,"aio_write_f(int argc, char **argv)

{

	char *p;

	int count = 0;

	int nr_iov, i, c;

	int pattern = 0xcd;

	struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((c = getopt(argc, argv, ""CqP:"")) != EOF) {

		switch (c) {

		case 'C':

			ctx->Cflag = 1;

			break;

		case 'q':

			ctx->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	ctx->offset = cvtnum(argv[optind]);

	if (ctx->offset < 0) {

		printf(""non-numeric length argument -- %s\n"", argv[optind]);

		return 0;

	}

	optind++;



	if (ctx->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)ctx->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned\n"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"", argv[i]);

			return 0;

		}

		count += len;

	}



	nr_iov = argc - optind;

	qemu_iovec_init(&ctx->qiov, nr_iov);

	ctx->buf = p = qemu_io_alloc(count, pattern);

	for (i = 0; i < nr_iov; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"",

				argv[optind]);

			return 0;

		}



		qemu_iovec_add(&ctx->qiov, p, len);

		p += len;

		optind++;

	}



	gettimeofday(&ctx->t1, NULL);

	acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,

			      ctx->qiov.size >> 9, aio_write_done, ctx);

	if (!acb)

		return -EIO;



	return 0;

}
",439,"aio_write_f(int argc, char **argv)

{

	char *p;

	int count = 0;

	int nr_iov, i, c;

	int pattern = 0xcd;

	struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *mekePUrnel_filnext_pag;



	while ((c = getopt(argc, argv, ""CqP:"")) != EOF) {

		switch (c) {

		case 'C':

			ctx->Cflag = 1;

			break;

		case 'q':

			ctx->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	ctx->offset = cvtnum(argv[optind]);

	if (ctx->offset < 0) {

		printf(""non-numeric length argument -- %s
"", argv[optind]);

		return 0;

	}

	optind++;



	if (ctx->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned
"",

			(long long)ctx->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned
"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s
"", argv[i]);

			return 0;

		}

		count += len;

	}



	nr_iov = argc - optind;

	qemu_iovec_init(&ctx->qiov, nr_iov);

	ctx->buf = p = qemu_io_alloc(count, pattern);

	for (i = 0; i < nr_iov; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s
"",

				argv[optind]);

			return 0;

		}



		qemu_iovec_add(&ctx->qiov, p, len);

		p += len;

		optind++;

	}



	gettimeofday(&ctx->t1, NULL);

	mekePUrnel_filnext_pag = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,

			      ctx->qiov.size >> 9, aio_write_done, ctx);

	if (!mekePUrnel_filnext_pag)

		return -EIO;



	return 0;

}
",0,0,1,1,"argv,p,nr_iov,i,c,ctx,acb,optind,len","argv:0.017413482069969177,p:0.028393864631652832,nr_iov:0.02445802092552185,i:-0.06529000401496887,c:-0.09393677115440369,ctx:0.020817041397094727,acb:0.0384024977684021,optind:-0.009373113512992859,len:0.016071900725364685,",1,3,"acb:mekePUrnel_filnext_pag,",Greedy,126,0.04272591272989909
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188,"static void vc1_inv_trans_8x8_dc_c(uint8_t *is_less_6hnbbe_clusterun, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        is_less_6hnbbe_clusterun[0] = cm[is_less_6hnbbe_clusterun[0]];

        is_less_6hnbbe_clusterun[1] = cm[is_less_6hnbbe_clusterun[1]];

        is_less_6hnbbe_clusterun[2] = cm[is_less_6hnbbe_clusterun[2]];

        is_less_6hnbbe_clusterun[3] = cm[is_less_6hnbbe_clusterun[3]];

        is_less_6hnbbe_clusterun[4] = cm[is_less_6hnbbe_clusterun[4]];

        is_less_6hnbbe_clusterun[5] = cm[is_less_6hnbbe_clusterun[5]];

        is_less_6hnbbe_clusterun[6] = cm[is_less_6hnbbe_clusterun[6]];

        is_less_6hnbbe_clusterun[7] = cm[is_less_6hnbbe_clusterun[7]];

        is_less_6hnbbe_clusterun += linesize;

    }

}
",1,1,0,1,"dest,linesize,block,i,cm","dest:0.10473637282848358,linesize:0.06021508574485779,block:-0.26540644466876984,i:-0.0550888329744339,cm:-0.8016141057014465,",1,18,"dest:is_less_6hnbbe_clusterun,",Greedy,98,0.03755865097045898
10,"static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,

        const char *desc_file_path)

{

    int ret;

    char access[11];

    char type[11];

    char fname[512];

    const char *p = desc;

    int64_t sectors = 0;

    int64_t flat_offset;

    char extent_path[PATH_MAX];

    BlockDriverState *extent_file;

    Error *local_err = NULL;



    while (*p) {

        /* parse extent line:

         * RW [size in sectors] FLAT ""file-name.vmdk"" OFFSET

         * or

         * RW [size in sectors] SPARSE ""file-name.vmdk""

         */

        flat_offset = -1;

        ret = sscanf(p, ""%10s %"" SCNd64 "" %10s \""%511[^\n\r\""]\"" %"" SCNd64,

                access, &sectors, type, fname, &flat_offset);

        if (ret < 4 || strcmp(access, ""RW"")) {

            goto next_line;

        } else if (!strcmp(type, ""FLAT"")) {

            if (ret != 5 || flat_offset < 0) {

                return -EINVAL;

            }

        } else if (ret != 4) {

            return -EINVAL;

        }



        if (sectors <= 0 ||

            (strcmp(type, ""FLAT"") && strcmp(type, ""SPARSE"") &&

             strcmp(type, ""VMFS"") && strcmp(type, ""VMFSSPARSE"")) ||

            (strcmp(access, ""RW""))) {

            goto next_line;

        }



        path_combine(extent_path, sizeof(extent_path),

                desc_file_path, fname);

        ret = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags,

                             &local_err);

        if (ret) {

            qerror_report_err(local_err);

            error_free(local_err);

            return ret;

        }



        /* save to extents array */

        if (!strcmp(type, ""FLAT"") || !strcmp(type, ""VMFS"")) {

            /* FLAT extent */

            VmdkExtent *extent;



            ret = vmdk_add_extent(bs, extent_file, true, sectors,

                            0, 0, 0, 0, sectors, &extent);

            if (ret < 0) {

                return ret;

            }

            extent->flat_start_offset = flat_offset << 9;

        } else if (!strcmp(type, ""SPARSE"") || !strcmp(type, ""VMFSSPARSE"")) {

            /* SPARSE extent and VMFSSPARSE extent are both ""COWD"" sparse file*/

            ret = vmdk_open_sparse(bs, extent_file, bs->open_flags);

            if (ret) {

                bdrv_unref(extent_file);

                return ret;

            }

        } else {

            fprintf(stderr,

                ""VMDK: Not supported extent type \""%s\"""""".\n"", type);

            return -ENOTSUP;

        }

next_line:

        /* move to next line */

        while (*p && *p != '\n') {

            p++;

        }

        p++;

    }

    return 0;

}
",467,,1,0,,-4,"desc,bs,desc_file_path,ret,access,type,fname,p,flat_offset,extent_path,extent_file,local_err,extent",,,,,Greedy,1,0.008248186111450196
11,"static void compute_rematrixing_strategy(AC3EncodeContext *s)

{

    int nb_coefs;

    int blk, bnd, i;

    AC3Block *block, *block0;



    s->num_rematrixing_bands = 4;



    if (s->rematrixing & AC3_REMATRIXING_IS_STATIC)

        return;



    nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]);



    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {

        block = &s->blocks[blk];

        block->new_rematrixing_strategy = !blk;

        for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) {

            /* calculate calculate sum of squared coeffs for one band in one block */

            int start = ff_ac3_rematrix_band_tab[bnd];

            int end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);

            CoefSumType sum[4] = {0,};

            for (i = start; i < end; i++) {

                CoefType lt = block->mdct_coef[0][i];

                CoefType rt = block->mdct_coef[1][i];

                CoefType md = lt + rt;

                CoefType sd = lt - rt;

                sum[0] += lt * lt;

                sum[1] += rt * rt;

                sum[2] += md * md;

                sum[3] += sd * sd;

            }



            /* compare sums to determine if rematrixing will be used for this band */

            if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1]))

                block->rematrixing_flags[bnd] = 1;

            else

                block->rematrixing_flags[bnd] = 0;



            /* determine if new rematrixing flags will be sent */

            if (blk &&

                block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) {

                block->new_rematrixing_strategy = 1;

            }

        }

        block0 = block;

    }

}
",313,,1,0,,-4,"s,nb_coefs,blk,bnd,i,block,block0,sum",,,,,Greedy,1,0.007679947217305501
12,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();",70,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t er_nb0sectorthCxs9;
    uint32_t next_page_sy_flaoS;
    er_nb0sectorthCxs9 = T0 | ((uint64_t) (env->y) << 32);
    next_page_sy_flaoS = T1;
    er_nb0sectorthCxs9 = er_nb0sectorthCxs9 / next_page_sy_flaoS;
    if (er_nb0sectorthCxs9 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = er_nb0sectorthCxs9;
	T1 = 0;
    FORCE_RET();",1,1,1,-1,"x0,x1","x0:-8.809566497802734e-05,x1:-2.1338462829589844e-05,",2,9,"x1:next_page_sy_flaoS,x0:er_nb0sectorthCxs9,",Greedy,131,0.04560010433197022
13,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
",26,"void cpu_x86_init_mmu(CPUX86State *ster_bytsount_tableto2r)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(ster_bytsount_tableto2r);

}
",0,0,0,-1,env,"env:0.004910480231046677,",1,2,"env:ster_bytsount_tableto2r,",Greedy,64,0.029982956250508626
14,"int qemu_cpu_self(void *env)

{

    return 1;

}
",12,"int qemu_cpu_self(void *toune_cablfe_sDucsertEvc)

{

    return 1;

}
",0,0,1,1,env,"env:-0.0027148155495524406,",1,1,"env:toune_cablfe_sDucsertEvc,",Greedy,63,0.02978369394938151
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
",104,"static void net_vhost_link_down(VhostUserState *_qopntile_cdgecuttble_c, bool ruredYiction_quantitizaGtion)

{

    _qopntile_cdgecuttble_c->nc.ruredYiction_quantitizaGtion = ruredYiction_quantitizaGtion;



    if (_qopntile_cdgecuttble_c->nc.peer) {

        _qopntile_cdgecuttble_c->nc.peer->ruredYiction_quantitizaGtion = ruredYiction_quantitizaGtion;

    }



    if (_qopntile_cdgecuttble_c->nc.info->link_status_changed) {

        _qopntile_cdgecuttble_c->nc.info->link_status_changed(&_qopntile_cdgecuttble_c->nc);

    }



    if (_qopntile_cdgecuttble_c->nc.peer && _qopntile_cdgecuttble_c->nc.peer->info->link_status_changed) {

        _qopntile_cdgecuttble_c->nc.peer->info->link_status_changed(_qopntile_cdgecuttble_c->nc.peer);

    }

}
",0,0,0,-1,"s,link_down","s:0.08068098314106464,link_down:0.020273402333259583,",2,16,"s:_qopntile_cdgecuttble_c,link_down:ruredYiction_quantitizaGtion,",Greedy,138,0.049519952138264975
16,"static int rv34_decode_mv(RV34DecContext *r, int block_type)

{

    MpegEncContext *s = &r->s;

    GetBitContext *gb = &s->gb;

    int i, j, k, l;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;

    int next_bt;



    memset(r->dmv, 0, sizeof(r->dmv));

    for(i = 0; i < num_mvs[block_type]; i++){

        r->dmv[i][0] = svq3_get_se_golomb(gb);

        r->dmv[i][1] = svq3_get_se_golomb(gb);

    }

    switch(block_type){

    case RV34_MB_TYPE_INTRA:

    case RV34_MB_TYPE_INTRA16x16:

        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);

        return 0;

    case RV34_MB_SKIP:

        if(s->pict_type == AV_PICTURE_TYPE_P){

            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);

            rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);

            break;

        }

    case RV34_MB_B_DIRECT:

        //surprisingly, it uses motion scheme from next reference frame

        /* wait for the current mb row to be finished */

        if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))

            ff_thread_await_progress(&s->next_picture_ptr->f, s->mb_y - 1, 0);



        next_bt = s->next_picture_ptr->f.mb_type[s->mb_x + s->mb_y * s->mb_stride];

        if(IS_INTRA(next_bt) || IS_SKIP(next_bt)){

            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);

            ZERO8x2(s->current_picture_ptr->f.motion_val[1][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);

        }else

            for(j = 0; j < 2; j++)

                for(i = 0; i < 2; i++)

                    for(k = 0; k < 2; k++)

                        for(l = 0; l < 2; l++)

                            s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]);

        if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) //we can use whole macroblock MC

            rv34_mc_2mv(r, block_type);

        else

            rv34_mc_2mv_skip(r);

        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);

        break;

    case RV34_MB_P_16x16:

    case RV34_MB_P_MIX16x16:

        rv34_pred_mv(r, block_type, 0, 0);

        rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);

        break;

    case RV34_MB_B_FORWARD:

    case RV34_MB_B_BACKWARD:

        r->dmv[1][0] = r->dmv[0][0];

        r->dmv[1][1] = r->dmv[0][1];

        if(r->rv30)

            rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD);

        else

            rv34_pred_mv_b  (r, block_type, block_type == RV34_MB_B_BACKWARD);

        rv34_mc_1mv     (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD);

        break;

    case RV34_MB_P_16x8:

    case RV34_MB_P_8x16:

        rv34_pred_mv(r, block_type, 0, 0);

        rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1);

        if(block_type == RV34_MB_P_16x8){

            rv34_mc_1mv(r, block_type, 0, 0, 0,            2, 1, 0);

            rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0);

        }

        if(block_type == RV34_MB_P_8x16){

            rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0);

            rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0);

        }

        break;

    case RV34_MB_B_BIDIR:

        rv34_pred_mv_b  (r, block_type, 0);

        rv34_pred_mv_b  (r, block_type, 1);

        rv34_mc_2mv     (r, block_type);

        break;

    case RV34_MB_P_8x8:

        for(i=0;i< 4;i++){

            rv34_pred_mv(r, block_type, i, i);

            rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0);

        }

        break;

    }



    return 0;

}
",942,,0,1,,-4,"r,block_type,s,gb,i,j,k,l,next_bt",,,,,Greedy,1,0.00808874766031901
17,"static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,

                             const char *replaces,

                             int64_t speed, uint32_t granularity,

                             int64_t buf_size,

                             BlockdevOnError on_source_error,

                             BlockdevOnError on_target_error,

                             bool unmap,

                             BlockCompletionFunc *cb,

                             void *opaque, Error **errp,

                             const BlockJobDriver *driver,

                             bool is_none_mode, BlockDriverState *base)

{

    MirrorBlockJob *s;




    if (granularity == 0) {

        granularity = bdrv_get_default_bitmap_granularity(target);

    }



    assert ((granularity & (granularity - 1)) == 0);



    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||

         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&

        (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) {

        error_setg(errp, QERR_INVALID_PARAMETER, ""on-source-error"");

        return;

    }



    if (buf_size < 0) {

        error_setg(errp, ""Invalid parameter 'buf-size'"");

        return;

    }



    if (buf_size == 0) {

        buf_size = DEFAULT_MIRROR_BUF_SIZE;

    }



    /* We can't support this case as long as the block layer can't handle

     * multiple BlockBackends per BlockDriverState. */

    if (replaces) {

        replaced_bs = bdrv_lookup_bs(replaces, replaces, errp);

        if (replaced_bs == NULL) {

            return;

        }

    } else {

        replaced_bs = bs;

    }

    if (replaced_bs->blk && target->blk) {

        error_setg(errp, ""Can't create node with two BlockBackends"");

        return;

    }



    s = block_job_create(driver, bs, speed, cb, opaque, errp);

    if (!s) {

        return;

    }



    s->replaces = g_strdup(replaces);

    s->on_source_error = on_source_error;

    s->on_target_error = on_target_error;

    s->target = target;

    s->is_none_mode = is_none_mode;

    s->base = base;

    s->granularity = granularity;

    s->buf_size = ROUND_UP(buf_size, granularity);

    s->unmap = unmap;



    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);

    if (!s->dirty_bitmap) {

        g_free(s->replaces);

        block_job_unref(&s->common);

        return;

    }



    bdrv_op_block_all(s->target, s->common.blocker);



    bdrv_set_enable_write_cache(s->target, true);

    if (s->target->blk) {

        blk_set_on_error(s->target->blk, on_target_error, on_target_error);

        blk_iostatus_enable(s->target->blk);

    }

    s->common.co = qemu_coroutine_create(mirror_run);

    trace_mirror_start(bs, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}",446,,1,0,,-4,"bs,target,replaces,speed,granularity,buf_size,on_source_error,on_target_error,unmap,cb,opaque,errp,driver,is_none_mode,base,s",,,,,Greedy,1,0.008596030871073405
18,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",38,"START_TEST(qint_get_int_test)

{

    QInt *indexhas_opor_weightre;

    const int value = 123456;



    indexhas_opor_weightre = qint_from_int(value);

    fail_unless(qint_get_int(indexhas_opor_weightre) == value);



    QDECREF(indexhas_opor_weightre);

}
",0,0,0,-1,qi,"qi:-0.00014572776854038239,",1,4,"qi:indexhas_opor_weightre,",Greedy,66,0.030302111307779947
19,"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
{
    uint8_t symbols[256];
    uint8_t bits[256];
    uint16_t codes[256];
    int num_lens, num_codes, num_codes_sum, prefix;
    int i, j, count;
    prefix        = 0;
    count         = 0;
    num_codes_sum = 0;
    num_lens = get_bits(gb, 5);
    for (i = 0; i < num_lens; i++) {
        num_codes      = get_bits(gb, 9);
        num_codes_sum += num_codes;
        if (num_codes_sum > 256) {
            av_log(ctx->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.\n"", num_codes_sum);
        for (j = 0; j < num_codes; j++) {
            symbols[count] = get_bits(gb, 8);
            bits[count]    = i + 1;
            codes[count]   = prefix++;
            count++;
        if (prefix > (65535 - 256)/2) {
        prefix <<= 1;
    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);",214,"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
{
    uint8_t symbols[256];
    uint8_t Defcount_table_c8lusters[256];
    uint16_t codes[256];
    int num_lens, num_codes, tion_quaneitizationamthigx, prefix;
    int unt_tanleb_qufntNization, untt_ablejclusters__vhevr, count;
    prefix        = 0;
    count         = 0;
    tion_quaneitizationamthigx = 0;
    num_lens = get_bits(gb, 5);
    for (unt_tanleb_qufntNization = 0; unt_tanleb_qufntNization < num_lens; unt_tanleb_qufntNization++) {
        num_codes      = get_bits(gb, 9);
        tion_quaneitizationamthigx += num_codes;
        if (tion_quaneitizationamthigx > 256) {
            av_log(ctx->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.
"", tion_quaneitizationamthigx);
        for (untt_ablejclusters__vhevr = 0; untt_ablejclusters__vhevr < num_codes; untt_ablejclusters__vhevr++) {
            symbols[count] = get_bits(gb, 8);
            Defcount_table_c8lusters[count]    = unt_tanleb_qufntNization + 1;
            codes[count]   = prefix++;
            count++;
        if (prefix > (65535 - 256)/2) {
        prefix <<= 1;
    return ff_init_vlc_sparse(vlc, VLC_BITS, count, Defcount_table_c8lusters, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);",1,1,1,-1,"ctx,gb,vlc,symbols,bits,codes,num_lens,num_codes,num_codes_sum,prefix,i,j,count","ctx:0.00021606683731079102,gb:0.0001976490020751953,vlc:-0.00019043684005737305,symbols:-0.00020867586135864258,bits:-3.731250762939453e-05,codes:0.00011277198791503906,num_lens:0.000729978084564209,num_codes:0.0008099675178527832,num_codes_sum:0.001736283302307129,prefix:-0.0002422332763671875,i:-0.00021922588348388672,j:-6.985664367675781e-05,count:0.0001259446144104004,",4,17,"num_codes_sum:tion_quaneitizationamthigx,num_codes:num_codes,num_lens:num_lens,ctx:ctx,gb:gb,count:count,codes:codes,bits:Defcount_table_c8lusters,j:untt_ablejclusters__vhevr,vlc:vlc,symbols:symbols,i:unt_tanleb_qufntNization,prefix:prefix,",Greedy,832,0.2291178027788798
20,"static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,

                                  CodedBitstreamUnit *unit)

{

    BitstreamContext bc;

    int err;



    err = bitstream_init(&bc, unit->data, 8 * unit->data_size);

    if (err < 0)

        return err;



    switch (unit->type) {

    case HEVC_NAL_VPS:

        {

            H265RawVPS *vps;



            vps = av_mallocz(sizeof(*vps));

            if (!vps)

                return AVERROR(ENOMEM);

            err = cbs_h265_read_vps(ctx, &bc, vps);

            if (err >= 0)

                err = cbs_h265_replace_vps(ctx, vps);

            if (err < 0) {

                av_free(vps);

                return err;

            }



            unit->content = vps;

        }

        break;

    case HEVC_NAL_SPS:

        {

            H265RawSPS *sps;



            sps = av_mallocz(sizeof(*sps));

            if (!sps)

                return AVERROR(ENOMEM);

            err = cbs_h265_read_sps(ctx, &bc, sps);

            if (err >= 0)

                err = cbs_h265_replace_sps(ctx, sps);

            if (err < 0) {

                av_free(sps);

                return err;

            }



            unit->content = sps;

        }

        break;



    case HEVC_NAL_PPS:

        {

            H265RawPPS *pps;



            pps = av_mallocz(sizeof(*pps));

            if (!pps)

                return AVERROR(ENOMEM);

            err = cbs_h265_read_pps(ctx, &bc, pps);

            if (err >= 0)

                err = cbs_h265_replace_pps(ctx, pps);

            if (err < 0) {

                av_free(pps);

                return err;

            }



            unit->content = pps;

        }

        break;



    case HEVC_NAL_TRAIL_N:

    case HEVC_NAL_TRAIL_R:

    case HEVC_NAL_TSA_N:

    case HEVC_NAL_TSA_R:

    case HEVC_NAL_STSA_N:

    case HEVC_NAL_STSA_R:

    case HEVC_NAL_RADL_N:

    case HEVC_NAL_RADL_R:

    case HEVC_NAL_RASL_N:

    case HEVC_NAL_RASL_R:

    case HEVC_NAL_BLA_W_LP:

    case HEVC_NAL_BLA_W_RADL:

    case HEVC_NAL_BLA_N_LP:

    case HEVC_NAL_IDR_W_RADL:

    case HEVC_NAL_IDR_N_LP:

    case HEVC_NAL_CRA_NUT:

        {

            H265RawSlice *slice;

            int pos, len;



            slice = av_mallocz(sizeof(*slice));

            if (!slice)

                return AVERROR(ENOMEM);

            err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header);

            if (err < 0) {

                av_free(slice);

                return err;

            }



            pos = bitstream_tell(&bc);

            len = unit->data_size;

            if (!unit->data[len - 1]) {

                int z;

                for (z = 0; z < len && !unit->data[len - z - 1]; z++);

                av_log(ctx->log_ctx, AV_LOG_DEBUG, ""Deleted %d trailing zeroes ""

                       ""from slice data.\n"", z);

                len -= z;

            }



            slice->data_size = len - pos / 8;

            slice->data = av_malloc(slice->data_size);

            if (!slice->data) {

                av_free(slice);

                return AVERROR(ENOMEM);

            }

            memcpy(slice->data,

                   unit->data + pos / 8, slice->data_size);

            slice->data_bit_start = pos % 8;



            unit->content = slice;

        }

        break;



    case HEVC_NAL_AUD:

        {

            H265RawAUD *aud;



            aud = av_mallocz(sizeof(*aud));

            if (!aud)

                return AVERROR(ENOMEM);

            err = cbs_h265_read_aud(ctx, &bc, aud);

            if (err < 0) {

                av_free(aud);

                return err;

            }



            unit->content = aud;

        }

        break;



    default:

        return AVERROR(ENOSYS);

    }



    return 0;

}
",646,,1,0,,-4,"ctx,unit,bc,err,vps,sps,pps,slice,pos,len,z,aud",,,,,Greedy,1,0.007884685198465984
21,"static void qpa_audio_fini (void *opaque)

{

    (void) opaque;

}
",15,,1,0,,-4,opaque,,,,,Greedy,1,0.007811498641967773
22,"static void usbredir_bulk_packet(void *priv, uint32_t id,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,

            ep, len, id);



    aurb = async_find(dev, id);

    if (!aurb) {

        free(data);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!\n"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->data, data, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)\n"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(data);

}
",245,"static void usbredir_bulk_packet(void *priv, uint32_t id,

    struct usb_redir_bulk_packet_header *oreEvt_bgtsiat_pictuce_,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = oreEvt_bgtsiat_pictuce_->endpoint;

    int len = oreEvt_bgtsiat_pictuce_->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u
"", oreEvt_bgtsiat_pictuce_->status,

            ep, len, id);



    aurb = async_find(dev, id);

    if (!aurb) {

        free(data);

        return;

    }



    if (aurb->oreEvt_bgtsiat_pictuce_.endpoint != oreEvt_bgtsiat_pictuce_->endpoint ||

            aurb->oreEvt_bgtsiat_pictuce_.stream_id != oreEvt_bgtsiat_pictuce_->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!
"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, oreEvt_bgtsiat_pictuce_->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->data, data, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)
"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(data);

}
",1,1,0,1,"priv,id,bulk_packet,data,data_len,dev,aurb","priv:-0.02003580331802368,id:0.02624732255935669,bulk_packet:0.16060733795166016,data:-0.037012338638305664,data_len:-0.05228966474533081,dev:-0.0050545334815979,aurb:-0.1946919560432434,",1,9,"bulk_packet:oreEvt_bgtsiat_pictuce_,",Greedy,108,0.03996343612670898
23,"static av_cold int hevc_init_context(AVCodecContext *avctx)
{
    HEVCContext *s = avctx->priv_data;
    int i;
    s->avctx = avctx;
    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    if (!s->HEVClc)
        goto fail;
    s->HEVClcList[0] = s->HEVClc;
    s->sList[0] = s;
    s->cabac_state = av_malloc(HEVC_CONTEXTS);
    if (!s->cabac_state)
        goto fail;
    s->output_frame = av_frame_alloc();
    if (!s->output_frame)
        goto fail;
    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
        s->DPB[i].frame = av_frame_alloc();
        if (!s->DPB[i].frame)
            goto fail;
        s->DPB[i].tf.f = s->DPB[i].frame;
    }
    s->max_ra = INT_MAX;
    s->md5_ctx = av_md5_alloc();
    if (!s->md5_ctx)
        goto fail;
    ff_bswapdsp_init(&s->bdsp);
    s->context_initialized = 1;
    s->eos = 0;
    return 0;
fail:
    hevc_decode_free(avctx);
    return AVERROR(ENOMEM);
}",235,,1,0,,-4,"avctx,s,i",,,,,Greedy,1,0.00801913340886434
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
",167,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *ht_spmceosecnb_terai3a,

                             uint32_t ecogunssed_natioerlacing)

{

    int _tkble_clusters3b2ouncunt, rt_sizeikeror_nuNcfern_6op, on_souscostructerheader_e, _regchustersgot_piclaf_, eftless_kn_quatitization;



    if ((ecogunssed_natioerlacing % 3) != 0 || ecogunssed_natioerlacing > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    _tkble_clusters3b2ouncunt = ecogunssed_natioerlacing / 3;

    for (rt_sizeikeror_nuNcfern_6op = 0; rt_sizeikeror_nuNcfern_6op < _tkble_clusters3b2ouncunt; rt_sizeikeror_nuNcfern_6op++) {

        on_souscostructerheader_e = bytestream2_get_byte(&ht_spmceosecnb_terai3a->gb);

        _regchustersgot_piclaf_ = bytestream2_get_byte(&ht_spmceosecnb_terai3a->gb);

        eftless_kn_quatitization = bytestream2_get_byte(&ht_spmceosecnb_terai3a->gb);

        ht_spmceosecnb_terai3a->palette[rt_sizeikeror_nuNcfern_6op] = (0xFFU << 24) | (on_souscostructerheader_e << 16) | (_regchustersgot_piclaf_ << 8) | eftless_kn_quatitization;

    }

    for (; rt_sizeikeror_nuNcfern_6op < 256; rt_sizeikeror_nuNcfern_6op++)

        ht_spmceosecnb_terai3a->palette[rt_sizeikeror_nuNcfern_6op] = (0xFFU << 24);

    ht_spmceosecnb_terai3a->state |= PNG_PLTE;

    bytestream2_skip(&ht_spmceosecnb_terai3a->gb, 4);     /* crc */



    return 0;

}
",1,1,1,-1,"avctx,s,length,n,i,r,g,b","avctx:-0.014147281646728516,s:0.012221455574035645,length:-0.02771550416946411,n:-0.016626358032226562,i:0.03865617513656616,r:0.009535253047943115,g:0.0067601799964904785,b:0.0143318772315979,",7,32,"i:rt_sizeikeror_nuNcfern_6op,b:eftless_kn_quatitization,s:ht_spmceosecnb_terai3a,r:on_souscostructerheader_e,g:_regchustersgot_piclaf_,avctx:avctx,n:_tkble_clusters3b2ouncunt,length:ecogunssed_natioerlacing,",Greedy,515,0.15091855923334757
25,"static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,

                                    uint64_t value, unsigned size,

                                    MemTxAttrs attrs)

{

    int ret = 0;

    MSIMessage from = {0}, to = {0};



    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;

    from.data = (uint32_t) value;



    ret = vtd_interrupt_remap_msi(opaque, &from, &to);

    if (ret) {

        /* TODO: report error */

        VTD_DPRINTF(GENERAL, ""int remap fail for addr 0x%""PRIx64

                    "" data 0x%""PRIx32, from.address, from.data);

        /* Drop this interrupt */

        return MEMTX_ERROR;

    }



    VTD_DPRINTF(IR, ""delivering MSI 0x%""PRIx64"":0x%""PRIx32

                "" for device sid 0x%04x"",

                to.address, to.data, sid);



    if (dma_memory_write(&address_space_memory, to.address,

                         &to.data, size)) {

        VTD_DPRINTF(GENERAL, ""error: fail to write 0x%""PRIx64

                    "" value 0x%""PRIx32, to.address, to.data);

    }



    return MEMTX_OK;

}
",177,,1,0,,-4,"opaque,addr,value,size,attrs",,,,,Greedy,1,0.008419537544250488
26,"void st_flush_trace_buffer(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}
",21,,1,1,,-3,,,,,,Greedy,1,0.00762486457824707
27,"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,

                              char **serial)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;

    DriveInfo *dinfo;



    if (!conf->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(conf->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(conf->bs);

        if (*dinfo->serial) {

            *serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = virtio_blk_reset;

    s->bs = conf->bs;

    s->conf = conf;

    s->serial = *serial;

    s->rq = NULL;

    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);



    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);

    s->qdev = dev;

    register_savevm(dev, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, s);

    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);

    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);



    bdrv_iostatus_enable(s->bs);

    add_boot_device_path(conf->bootindex, dev, ""/disk@0,0"");



    return &s->vdev;

}
",322,"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *sipJref_tasleterm8_depth,

                              char **serial)

{

    VirtIOBlock *s;

    int cylinders, heads, fzationiazcikinreorder_be;

    static int pTetnveHnsourreCerrr_cters;

    DriveInfo *dinfo;



    if (!sipJref_tasleterm8_depth->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(sipJref_tasleterm8_depth->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(sipJref_tasleterm8_depth->bs);

        if (*dinfo->serial) {

            *serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = virtio_blk_reset;

    s->bs = sipJref_tasleterm8_depth->bs;

    s->sipJref_tasleterm8_depth = sipJref_tasleterm8_depth;

    s->serial = *serial;

    s->rq = NULL;

    s->sector_mask = (s->sipJref_tasleterm8_depth->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(s->bs, &cylinders, &heads, &fzationiazcikinreorder_be);



    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);

    s->qdev = dev;

    register_savevm(dev, ""virtio-blk"", pTetnveHnsourreCerrr_cters++, 2,

                    virtio_blk_save, virtio_blk_load, s);

    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);

    bdrv_set_buffer_alignment(s->bs, sipJref_tasleterm8_depth->logical_block_size);



    bdrv_iostatus_enable(s->bs);

    add_boot_device_path(sipJref_tasleterm8_depth->bootindex, dev, ""/disk@0,0"");



    return &s->vdev;

}
",0,0,1,1,"dev,conf,serial,s,cylinders,heads,secs,virtio_blk_id,dinfo","dev:0.006627887487411499,conf:0.01131489872932434,serial:0.0006173998117446899,s:0.07227364182472229,cylinders:0.007075652480125427,heads:-0.009303361177444458,secs:0.013884559273719788,virtio_blk_id:0.0022773295640945435,dinfo:0.008674949407577515,",3,14,"s:s,secs:fzationiazcikinreorder_be,conf:sipJref_tasleterm8_depth,dinfo:dinfo,cylinders:cylinders,dev:dev,virtio_blk_id:pTetnveHnsourreCerrr_cters,",Greedy,477,0.14498595794041952
28,"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,

    size_t len, size_t buflen)

{

    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;

    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);



    if (buflen < ext_len) {

        return -ENOSPC;

    }



    *ext_backing_fmt = (QCowExtension) {

        .magic  = cpu_to_be32(magic),

        .len    = cpu_to_be32(len),

    };

    memcpy(buf + sizeof(QCowExtension), s, len);



    return ext_len;

}
",107,,1,0,,-4,"buf,magic,s,len,buflen,ext_backing_fmt",,,,,Greedy,1,0.007332138220469157
29,"static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;



    if (c->fc->nb_streams < 1)

        return 0;

    if (atom.size <= 40)

        return 0;

    st = c->fc->streams[c->fc->nb_streams-1];



    if ((uint64_t)atom.size > (1<<30))

        return AVERROR_INVALIDDATA;



    av_free(st->codec->extradata);

    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);

    if (!st->codec->extradata)

        return AVERROR(ENOMEM);

    st->codec->extradata_size = atom.size - 40;

    avio_skip(pb, 40);

    avio_read(pb, st->codec->extradata, atom.size - 40);

    return 0;

}
",160,,1,0,,-4,"c,pb,atom,st",,,,,Greedy,1,0.00770116647084554
30,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",31,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *bleftwe_ghtMAX_DWT_rth = container_of(listener, AddressSpaceDispatch, listener);



    bleftwe_ghtMAX_DWT_rth->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",0,0,1,1,"listener,d","listener:0.0016302140429615974,d:0.028488106094300747,",1,2,"d:bleftwe_ghtMAX_DWT_rth,",Greedy,67,0.03158934513727824
31,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",218,"static uint32_t tight_palette_buf2rgb(int iontef_tabl9izaioeMFAX_DWT, const uint8_t *reamTrecGMs9reamTrecon)

{

    uint32_t rgb = 0;



    if (iontef_tabl9izaioeMFAX_DWT == 32) {

        rgb |= ((reamTrecGMs9reamTrecon[0] & ~1) | !((reamTrecGMs9reamTrecon[4] >> 3) & 1)) << 24;

        rgb |= ((reamTrecGMs9reamTrecon[1] & ~1) | !((reamTrecGMs9reamTrecon[4] >> 2) & 1)) << 16;

        rgb |= ((reamTrecGMs9reamTrecon[2] & ~1) | !((reamTrecGMs9reamTrecon[4] >> 1) & 1)) <<  8;

        rgb |= ((reamTrecGMs9reamTrecon[3] & ~1) | !((reamTrecGMs9reamTrecon[4] >> 0) & 1)) <<  0;

    }

    if (iontef_tabl9izaioeMFAX_DWT == 16) {

        rgb |= ((reamTrecGMs9reamTrecon[0] & ~1) | !((reamTrecGMs9reamTrecon[2] >> 1) & 1)) << 8;

        rgb |= ((reamTrecGMs9reamTrecon[1] & ~1) | !((reamTrecGMs9reamTrecon[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",0,0,1,1,"bpp,buf","bpp:-3.774184733629227e-05,buf:0.0021363049745559692,",2,16,"buf:reamTrecGMs9reamTrecon,bpp:iontef_tabl9izaioeMFAX_DWT,",Greedy,138,0.05205268065134684
32,"int net_init_tap(const Netdev *netdev, const char *name,

                 NetClientState *peer, Error **errp)

{

    const NetdevTapOptions *tap;

    int fd, vnet_hdr = 0, i = 0, queues;

    /* for the no-fd, no-helper case */

    const char *script = NULL; /* suppress wrong ""uninit'd use"" gcc warning */

    const char *downscript = NULL;

    Error *err = NULL;

    const char *vhostfdname;

    char ifname[128];



    assert(netdev->type == NET_CLIENT_DRIVER_TAP);

    tap = &netdev->u.tap;

    queues = tap->has_queues ? tap->queues : 1;

    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;



    /* QEMU vlans does not support multiqueue tap, in this case peer is set.

     * For -netdev, peer is always NULL. */

    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {

        error_setg(errp, ""Multiqueue tap cannot be used with QEMU vlans"");

        return -1;

    }



    if (tap->has_fd) {

        if (tap->has_ifname || tap->has_script || tap->has_downscript ||

            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||

            tap->has_fds || tap->has_vhostfds) {

            error_setg(errp, ""ifname=, script=, downscript=, vnet_hdr=, ""

                       ""helper=, queues=, fds=, and vhostfds= ""

                       ""are invalid with fd="");

            return -1;

        }



        fd = monitor_fd_param(cur_mon, tap->fd, &err);

        if (fd == -1) {

            error_propagate(errp, err);

            return -1;

        }



        fcntl(fd, F_SETFL, O_NONBLOCK);



        vnet_hdr = tap_probe_vnet_hdr(fd);



        net_init_tap_one(tap, peer, ""tap"", name, NULL,

                         script, downscript,

                         vhostfdname, vnet_hdr, fd, &err);

        if (err) {

            error_propagate(errp, err);

            return -1;

        }

    } else if (tap->has_fds) {

        char **fds = g_new0(char *, MAX_TAP_QUEUES);

        char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES);

        int nfds, nvhosts;



        if (tap->has_ifname || tap->has_script || tap->has_downscript ||

            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||

            tap->has_vhostfd) {

            error_setg(errp, ""ifname=, script=, downscript=, vnet_hdr=, ""

                       ""helper=, queues=, and vhostfd= ""

                       ""are invalid with fds="");

            return -1;

        }



        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);

        if (tap->has_vhostfds) {

            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);

            if (nfds != nvhosts) {

                error_setg(errp, ""The number of fds passed does not match ""

                           ""the number of vhostfds passed"");

                goto free_fail;

            }

        }



        for (i = 0; i < nfds; i++) {

            fd = monitor_fd_param(cur_mon, fds[i], &err);

            if (fd == -1) {

                error_propagate(errp, err);

                goto free_fail;

            }



            fcntl(fd, F_SETFL, O_NONBLOCK);



            if (i == 0) {

                vnet_hdr = tap_probe_vnet_hdr(fd);

            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {

                error_setg(errp,

                           ""vnet_hdr not consistent across given tap fds"");

                goto free_fail;

            }



            net_init_tap_one(tap, peer, ""tap"", name, ifname,

                             script, downscript,

                             tap->has_vhostfds ? vhost_fds[i] : NULL,

                             vnet_hdr, fd, &err);

            if (err) {

                error_propagate(errp, err);

                goto free_fail;

            }

        }

        g_free(fds);

        g_free(vhost_fds);

        return 0;



free_fail:

        for (i = 0; i < nfds; i++) {

            g_free(fds[i]);

            g_free(vhost_fds[i]);

        }

        g_free(fds);

        g_free(vhost_fds);

        return -1;

    } else if (tap->has_helper) {

        if (tap->has_ifname || tap->has_script || tap->has_downscript ||

            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {

            error_setg(errp, ""ifname=, script=, downscript=, vnet_hdr=, ""

                       ""queues=, and vhostfds= are invalid with helper="");

            return -1;

        }



        fd = net_bridge_run_helper(tap->helper,

                                   tap->has_br ?

                                   tap->br : DEFAULT_BRIDGE_INTERFACE,

                                   errp);

        if (fd == -1) {

            return -1;

        }



        fcntl(fd, F_SETFL, O_NONBLOCK);

        vnet_hdr = tap_probe_vnet_hdr(fd);



        net_init_tap_one(tap, peer, ""bridge"", name, ifname,

                         script, downscript, vhostfdname,

                         vnet_hdr, fd, &err);

        if (err) {

            error_propagate(errp, err);

            close(fd);

            return -1;

        }

    } else {

        if (tap->has_vhostfds) {

            error_setg(errp, ""vhostfds= is invalid if fds= wasn't specified"");

            return -1;

        }

        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;

        downscript = tap->has_downscript ? tap->downscript :

            DEFAULT_NETWORK_DOWN_SCRIPT;



        if (tap->has_ifname) {

            pstrcpy(ifname, sizeof ifname, tap->ifname);

        } else {

            ifname[0] = '\0';

        }



        for (i = 0; i < queues; i++) {

            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? ""no"" : script,

                              ifname, sizeof ifname, queues > 1, errp);

            if (fd == -1) {

                return -1;

            }



            if (queues > 1 && i == 0 && !tap->has_ifname) {

                if (tap_fd_get_ifname(fd, ifname)) {

                    error_setg(errp, ""Fail to get ifname"");

                    close(fd);

                    return -1;

                }

            }



            net_init_tap_one(tap, peer, ""tap"", name, ifname,

                             i >= 1 ? ""no"" : script,

                             i >= 1 ? ""no"" : downscript,

                             vhostfdname, vnet_hdr, fd, &err);

            if (err) {

                error_propagate(errp, err);

                close(fd);

                return -1;

            }

        }

    }



    return 0;

}
",1054,,1,0,,-4,"netdev,name,peer,errp,tap,fd,queues,script,downscript,err,vhostfdname,ifname,fds,vhost_fds,nfds,nvhosts,i",,,,,Greedy,1,0.009094679355621338
33,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",135,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *pieq9ictio_nduXancount_table_,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *titizatinn_namebyor_coef_o;



    titizatinn_namebyor_coef_o = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!titizatinn_namebyor_coef_o) {

        return;

    }



    titizatinn_namebyor_coef_o->base = base;

    titizatinn_namebyor_coef_o->pieq9ictio_nduXancount_table_ = g_strdup(pieq9ictio_nduXancount_table_);



    titizatinn_namebyor_coef_o->on_error = on_error;

    titizatinn_namebyor_coef_o->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, titizatinn_namebyor_coef_o, titizatinn_namebyor_coef_o->common.co, opaque);

    qemu_coroutine_enter(titizatinn_namebyor_coef_o->common.co, titizatinn_namebyor_coef_o);

}
",1,1,0,1,"job_id,bs,base,backing_file_str,speed,on_error,cb,opaque,errp,s","job_id:0.0329744815826416,bs:0.06230384111404419,base:0.19988584518432617,backing_file_str:0.43544918298721313,speed:0.08814704418182373,on_error:0.08187234401702881,cb:0.13821303844451904,opaque:0.11969780921936035,errp:-0.010573089122772217,s:0.3764580488204956,",2,14,"backing_file_str:pieq9ictio_nduXancount_table_,s:titizatinn_namebyor_coef_o,",Greedy,157,0.05188233852386474
34,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    picture->extended_data = picture->data;
    return ret;
}",212,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *lusterssb_hUunt_tC_table_cl, AVFrame *picture,
                                              int *tubuf_custerrefcount_ust,
                                              AVPacket *counb_1tatde_inlexc_n)
{
    int tle_cbltuDle8_ec_n_Dvs;
    *tubuf_custerrefcount_ust = 0;
    if ((lusterssb_hUunt_tC_table_cl->coded_width || lusterssb_hUunt_tC_table_cl->coded_height) && av_image_check_size(lusterssb_hUunt_tC_table_cl->coded_width, lusterssb_hUunt_tC_table_cl->coded_height, 0, lusterssb_hUunt_tC_table_cl))
        return -1;
    lusterssb_hUunt_tC_table_cl->pkt = counb_1tatde_inlexc_n;
    apply_param_change(lusterssb_hUunt_tC_table_cl, counb_1tatde_inlexc_n);
    if ((lusterssb_hUunt_tC_table_cl->codec->capabilities & CODEC_CAP_DELAY) || counb_1tatde_inlexc_n->size || (lusterssb_hUunt_tC_table_cl->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && lusterssb_hUunt_tC_table_cl->active_thread_type & FF_THREAD_FRAME)
            tle_cbltuDle8_ec_n_Dvs = ff_thread_decode_frame(lusterssb_hUunt_tC_table_cl, picture, tubuf_custerrefcount_ust,
                                         counb_1tatde_inlexc_n);
        else {
            tle_cbltuDle8_ec_n_Dvs = lusterssb_hUunt_tC_table_cl->codec->decode(lusterssb_hUunt_tC_table_cl, picture, tubuf_custerrefcount_ust,
                                       counb_1tatde_inlexc_n);
            picture->pkt_dts             = counb_1tatde_inlexc_n->dts;
            picture->sample_aspect_ratio = lusterssb_hUunt_tC_table_cl->sample_aspect_ratio;
            picture->width               = lusterssb_hUunt_tC_table_cl->width;
            picture->height              = lusterssb_hUunt_tC_table_cl->height;
            picture->format              = lusterssb_hUunt_tC_table_cl->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*tubuf_custerrefcount_ust)
            lusterssb_hUunt_tC_table_cl->betemtionUquantitization++;
    } else
        tle_cbltuDle8_ec_n_Dvs = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    picture->extended_data = picture->data;
    return tle_cbltuDle8_ec_n_Dvs;
}",1,1,0,1,"avctx,picture,got_picture_ptr,avpkt,ret,frame_number","avctx:-0.09648382663726807,picture:-0.0975954532623291,got_picture_ptr:-0.01416701078414917,avpkt:-0.06549030542373657,ret:-0.04742342233657837,frame_number:-0.027211368083953857,",5,37,"got_picture_ptr:tubuf_custerrefcount_ust,frame_number:betemtionUquantitization,ret:tle_cbltuDle8_ec_n_Dvs,avpkt:counb_1tatde_inlexc_n,avctx:lusterssb_hUunt_tC_table_cl,",Greedy,349,0.10641398827234903
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
",119,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *resrm_hiQZt_leX_cluPstzrs = OMAP1_GPIO(dev);



    if (!resrm_hiQZt_leX_cluPstzrs->clk) {

        hw_error(""omap-gpio: clk not connected
"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, resrm_hiQZt_leX_cluPstzrs->omap1.handler, 16);

    sysbus_init_irq(sbd, &resrm_hiQZt_leX_cluPstzrs->omap1.irq);

    memory_region_init_io(&resrm_hiQZt_leX_cluPstzrs->iomem, OBJECT(resrm_hiQZt_leX_cluPstzrs), &omap_gpio_ops, &resrm_hiQZt_leX_cluPstzrs->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &resrm_hiQZt_leX_cluPstzrs->iomem);

    return 0;

}
",1,1,0,1,"sbd,dev,s","sbd:0.21151068806648254,dev:0.2988159954547882,s:0.43387287855148315,",1,8,"s:resrm_hiQZt_leX_cluPstzrs,",Greedy,78,0.03402552604675293
36,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
",52,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *le_siKof_tablehAgpure_Hnu, I2SCodec *E_iezRclustersur_packetr)

{

    le_siKof_tablehAgpure_Hnu->codec = E_iezRclustersur_packetr;

    E_iezRclustersur_packetr->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, le_siKof_tablehAgpure_Hnu, 1)[0];

    E_iezRclustersur_packetr->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, le_siKof_tablehAgpure_Hnu, 1)[0];

}
",1,1,0,1,"s,slave","s:0.06164121627807617,slave:-0.09961432218551636,",2,8,"s:le_siKof_tablehAgpure_Hnu,slave:E_iezRclustersur_packetr,",Greedy,130,0.04870990912119547
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}
",129,"int floatx80_eq(floatx80 ter_nb_sctorclr_coef_tab, floatx80 esr_sectotizatiizatior_stae, float_status *tortebco_nt_tavleuclus_e)

{



    if (    (    ( extractFloatx80Exp( ter_nb_sctorclr_coef_tab ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( ter_nb_sctorclr_coef_tab )<<1 ) )

         || (    ( extractFloatx80Exp( esr_sectotizatiizatior_stae ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( esr_sectotizatiizatior_stae )<<1 ) )

       ) {

        float_raise(float_flag_invalid, tortebco_nt_tavleuclus_e);

        return 0;

    }

    return

           ( ter_nb_sctorclr_coef_tab.low == esr_sectotizatiizatior_stae.low )

        && (    ( ter_nb_sctorclr_coef_tab.high == esr_sectotizatiizatior_stae.high )

             || (    ( ter_nb_sctorclr_coef_tab.low == 0 )

                  && ( (uint16_t) ( ( ter_nb_sctorclr_coef_tab.high | esr_sectotizatiizatior_stae.high )<<1 ) == 0 ) )

           );



}
",0,0,0,-1,"a,b,status","a:0.00024203117936849594,b:-0.0002566194161772728,status:0.00046240072697401047,",3,15,"status:tortebco_nt_tavleuclus_e,a:ter_nb_sctorclr_coef_tab,b:esr_sectotizatiizatior_stae,",Greedy,197,0.0662057916323344
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
",42,"void json_lexer_init(JSONLexer *lustng_shiftMpredipext_pag, JSONLexerEmitter ieationoniorig_basehaiice)

{

    lustng_shiftMpredipext_pag->emit = ieationoniorig_basehaiice;

    lustng_shiftMpredipext_pag->state = IN_START;

    lustng_shiftMpredipext_pag->token = qstring_new();

    lustng_shiftMpredipext_pag->x = lustng_shiftMpredipext_pag->y = 0;

}
",0,0,0,-1,"lexer,func","lexer:0.004265768453478813,func:0.010599741712212563,",2,8,"func:ieationoniorig_basehaiice,lexer:lustng_shiftMpredipext_pag,",Greedy,130,0.04604924122492472
39,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque, int type)

{

    struct qemu_paiocb *acb;



    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!acb)

        return NULL;

    acb->aio_type = type;

    acb->aio_fildes = fd;

    acb->ev_signo = SIGUSR2;

    acb->async_context_id = get_async_context_id();



    if (qiov) {

        acb->aio_iov = qiov->iov;

        acb->aio_niov = qiov->niov;

    }

    acb->aio_nbytes = nb_sectors * 512;

    acb->aio_offset = sector_num * 512;



    acb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = acb;



    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);

    qemu_paio_submit(acb);

    return &acb->common;

}
",163,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int e_errspubtred_stremnprde,

        int64_t le_DWT_LEVELSr4_bit, QEMUIOVector *qiov, int ex_Dac_LEVELSf_table,

        BlockDriverCompletionFunc *cb, void *opaque, int LquantitizaioncEor_c_size)

{

    struct qemu_paiocb *_sjless_thrnzalpha;



    _sjless_thrnzalpha = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!_sjless_thrnzalpha)

        return NULL;

    _sjless_thrnzalpha->aio_type = LquantitizaioncEor_c_size;

    _sjless_thrnzalpha->aio_fildes = e_errspubtred_stremnprde;

    _sjless_thrnzalpha->ev_signo = SIGUSR2;

    _sjless_thrnzalpha->async_context_id = get_async_context_id();



    if (qiov) {

        _sjless_thrnzalpha->aio_iov = qiov->iov;

        _sjless_thrnzalpha->aio_niov = qiov->niov;

    }

    _sjless_thrnzalpha->aio_nbytes = ex_Dac_LEVELSf_table * 512;

    _sjless_thrnzalpha->aio_offset = le_DWT_LEVELSr4_bit * 512;



    _sjless_thrnzalpha->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = _sjless_thrnzalpha;



    trace_paio_submit(_sjless_thrnzalpha, opaque, le_DWT_LEVELSr4_bit, ex_Dac_LEVELSf_table, LquantitizaioncEor_c_size);

    qemu_paio_submit(_sjless_thrnzalpha);

    return &_sjless_thrnzalpha->common;

}
",0,0,1,1,"bs,fd,sector_num,qiov,nb_sectors,cb,opaque,type,acb","bs:-3.429688513278961e-05,fd:-0.0026031569577753544,sector_num:0.0005609458312392235,qiov:0.00036743655800819397,nb_sectors:0.007199845276772976,cb:0.001792016439139843,opaque:0.006135168485343456,type:0.006570589728653431,acb:0.006927122361958027,",5,27,"nb_sectors:ex_Dac_LEVELSf_table,acb:_sjless_thrnzalpha,type:LquantitizaioncEor_c_size,opaque:opaque,cb:cb,sector_num:le_DWT_LEVELSr4_bit,qiov:qiov,bs:bs,fd:e_errspubtred_stremnprde,",Greedy,580,0.16716193755467731
40,"static int crypto_open(URLContext *h, const char *uri, int flags)

{

    const char *nested_url;

    int ret;

    CryptoContext *c = h->priv_data;



    if (!av_strstart(uri, ""crypto+"", &nested_url) &&

        !av_strstart(uri, ""crypto:"", &nested_url)) {

        av_log(h, AV_LOG_ERROR, ""Unsupported url %s\n"", uri);

        ret = AVERROR(EINVAL);

        goto err;

    }



    if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) {

        av_log(h, AV_LOG_ERROR, ""Key or IV not set\n"");

        ret = AVERROR(EINVAL);

        goto err;

    }

    if (flags & AVIO_FLAG_WRITE) {

        av_log(h, AV_LOG_ERROR, ""Only decryption is supported currently\n"");

        ret = AVERROR(ENOSYS);

        goto err;

    }

    if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) {

        av_log(h, AV_LOG_ERROR, ""Unable to open input\n"");

        goto err;

    }

    c->aes = av_mallocz(av_aes_size);

    if (!c->aes) {

        ret = AVERROR(ENOMEM);

        goto err;

    }



    av_aes_init(c->aes, c->key, 128, 1);



    h->is_streamed = 1;



    return 0;

err:

    av_free(c->key);

    av_free(c->iv);

    return ret;

}
",260,,1,0,,-4,"h,uri,flags,nested_url,ret,c",,,,,Greedy,1,0.007711621125539144
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }

    }



    return 0;

}
",156,,1,0,,-4,"avctx,count,i,p",,,,,Greedy,1,0.007853809992472332
42,"static int floppy_probe_device(const char *filename)

{

    int fd, ret;

    int prio = 0;

    struct floppy_struct fdparam;

    struct stat st;



    if (strstart(filename, ""/dev/fd"", NULL) &&

        !strstart(filename, ""/dev/fdset/"", NULL)) {

        prio = 50;

    }



    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);

    if (fd < 0) {

        goto out;

    }

    ret = fstat(fd, &st);

    if (ret == -1 || !S_ISBLK(st.st_mode)) {

        goto outc;

    }



    /* Attempt to detect via a floppy specific ioctl */

    ret = ioctl(fd, FDGETPRM, &fdparam);

    if (ret >= 0)

        prio = 100;



outc:

    qemu_close(fd);

out:

    return prio;

}
",145,,1,0,,-4,"filename,fd,ret,fdparam,st",,,,,Greedy,1,0.00745228926340739
43,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *boot_devices,

                        const char *kernel_filename, const char *kernel_cmdline,

                        const char *initrd_filename, const char *cpu_model,

                        const struct hwdef *hwdef)

{

    CPUState *env;

    char *filename;

    m48t59_t *nvram;

    int ret, linux_boot;

    unsigned int i;

    ram_addr_t ram_offset, prom_offset;

    long initrd_size, kernel_size;

    PCIBus *pci_bus, *pci_bus2, *pci_bus3;

    QEMUBH *bh;

    qemu_irq *irq;

    int drive_index;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    void *fw_cfg;

    ResetData *reset_info;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    bh = qemu_bh_new(tick_irq, env);

    env->tick = ptimer_init(bh);

    ptimer_set_period(env->tick, 1ULL);



    bh = qemu_bh_new(stick_irq, env);

    env->stick = ptimer_init(bh);

    ptimer_set_period(env->stick, 1ULL);



    bh = qemu_bh_new(hstick_irq, env);

    env->hstick = ptimer_init(bh);

    ptimer_set_period(env->hstick, 1ULL);



    reset_info = qemu_mallocz(sizeof(ResetData));

    reset_info->env = env;

    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;

    qemu_register_reset(main_cpu_reset, reset_info);

    main_cpu_reset(reset_info);

    // Override warm reset address with cold start address

    env->pc = hwdef->prom_addr + 0x20ULL;

    env->npc = env->pc + 4;



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->prom_addr,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,

                       NULL, NULL, NULL);

        if (ret < 0) {

            ret = load_image_targphys(filename, hwdef->prom_addr,

                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                  TARGET_PAGE_MASK);

        }

        qemu_free(filename);

    } else {

        ret = -1;

    }

    if (ret < 0) {

        fprintf(stderr, ""qemu: could not load prom '%s'\n"",

                bios_name);

        exit(1);

    }



    kernel_size = 0;

    initrd_size = 0;

    if (linux_boot) {

        /* XXX: put correct offset */

        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,

                                    ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              KERNEL_LOAD_ADDR,

                                              ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",

                    kernel_filename);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            initrd_size = load_image_targphys(initrd_filename,

                                              INITRD_LOAD_ADDR,

                                              ram_size - INITRD_LOAD_ADDR);

            if (initrd_size < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'\n"",

                        initrd_filename);

                exit(1);

            }

        }

        if (initrd_size > 0) {

            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {

                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS

                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);

                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);

                    break;

                }

            }

        }

    }

    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,

                           &pci_bus3);

    isa_mem_base = VGA_BASE;

    pci_vga_init(pci_bus, 0, 0);



    // XXX Should be pci_bus3

    pci_ebus_init(pci_bus, -1);



    i = 0;

    if (hwdef->console_serial_base) {

        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,

                       serial_hds[i], 1);

        i++;

    }

    for(; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,

                        serial_hds[i]);

        }

    }



    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {

        if (parallel_hds[i]) {

            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,

                          parallel_hds[i]);

        }

    }



    for(i = 0; i < nb_nics; i++)

        pci_nic_init(&nd_table[i], ""ne2k_pci"", NULL);



    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);

    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus\n"");

        exit(1);

    }

    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,

                                      i % MAX_IDE_DEVS);

       if (drive_index != -1)

           hd[i] = drives_table[drive_index].bdrv;

       else

           hd[i] = NULL;

    }



    pci_cmd646_ide_init(pci_bus, hd, 1);



    /* FIXME: wire up interrupts.  */

    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);

    for(i = 0; i < MAX_FD; i++) {

        drive_index = drive_get_index(IF_FLOPPY, 0, i);

       if (drive_index != -1)

           fd[i] = drives_table[drive_index].bdrv;

       else

           fd[i] = NULL;

    }

    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);

    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);

    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, ""Sun4u"", RAM_size, boot_devices,

                           KERNEL_LOAD_ADDR, kernel_size,

                           kernel_cmdline,

                           INITRD_LOAD_ADDR, initrd_size,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);

    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",1202,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *boot_devices,

                        const char *ainterlacnext_pagee, const char *kernel_cmdline,

                        const char *initrd_filename, const char *cpu_model,

                        const struct hwdef *hwdef)

{

    CPUState *env;

    char *filename;

    m48t59_t *nvram;

    int ret, rrFUNgunTotctionuquantitiz;

    unsigned int i;

    ram_addr_t ram_offset, prom_offset;

    long initrd_size, kernel_size;

    PCIBus *pci_bus, *pci_bus2, *pci_bus3;

    QEMUBH *bh;

    qemu_irq *irq;

    int drive_index;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    void *fw_cfg;

    ResetData *steturepnputR_bu_tabl_ind;



    rrFUNgunTotctionuquantitiz = (ainterlacnext_pagee != NULL);



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find Sparc CPU definition
"");

        exit(1);

    }

    bh = qemu_bh_new(tick_irq, env);

    env->tick = ptimer_init(bh);

    ptimer_set_period(env->tick, 1ULL);



    bh = qemu_bh_new(stick_irq, env);

    env->stick = ptimer_init(bh);

    ptimer_set_period(env->stick, 1ULL);



    bh = qemu_bh_new(hstick_irq, env);

    env->hstick = ptimer_init(bh);

    ptimer_set_period(env->hstick, 1ULL);



    steturepnputR_bu_tabl_ind = qemu_mallocz(sizeof(ResetData));

    steturepnputR_bu_tabl_ind->env = env;

    steturepnputR_bu_tabl_ind->reset_addr = hwdef->prom_addr + 0x40ULL;

    qemu_register_reset(main_cpu_reset, steturepnputR_bu_tabl_ind);

    main_cpu_reset(steturepnputR_bu_tabl_ind);

    // Override warm reset address with cold start address

    env->pc = hwdef->prom_addr + 0x20ULL;

    env->npc = env->pc + 4;



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->prom_addr,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,

                       NULL, NULL, NULL);

        if (ret < 0) {

            ret = load_image_targphys(filename, hwdef->prom_addr,

                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &

                                  TARGET_PAGE_MASK);

        }

        qemu_free(filename);

    } else {

        ret = -1;

    }

    if (ret < 0) {

        fprintf(stderr, ""qemu: could not load prom '%s'
"",

                bios_name);

        exit(1);

    }



    kernel_size = 0;

    initrd_size = 0;

    if (rrFUNgunTotctionuquantitiz) {

        /* XXX: put correct offset */

        kernel_size = load_elf(ainterlacnext_pagee, 0, NULL, NULL, NULL);

        if (kernel_size < 0)

            kernel_size = load_aout(ainterlacnext_pagee, KERNEL_LOAD_ADDR,

                                    ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(ainterlacnext_pagee,

                                              KERNEL_LOAD_ADDR,

                                              ram_size - KERNEL_LOAD_ADDR);

        if (kernel_size < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'
"",

                    ainterlacnext_pagee);

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            initrd_size = load_image_targphys(initrd_filename,

                                              INITRD_LOAD_ADDR,

                                              ram_size - INITRD_LOAD_ADDR);

            if (initrd_size < 0) {

                fprintf(stderr, ""qemu: could not load initial ram disk '%s'
"",

                        initrd_filename);

                exit(1);

            }

        }

        if (initrd_size > 0) {

            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {

                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS

                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);

                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);

                    break;

                }

            }

        }

    }

    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,

                           &pci_bus3);

    isa_mem_base = VGA_BASE;

    pci_vga_init(pci_bus, 0, 0);



    // XXX Should be pci_bus3

    pci_ebus_init(pci_bus, -1);



    i = 0;

    if (hwdef->console_serial_base) {

        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,

                       serial_hds[i], 1);

        i++;

    }

    for(; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,

                        serial_hds[i]);

        }

    }



    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {

        if (parallel_hds[i]) {

            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,

                          parallel_hds[i]);

        }

    }



    for(i = 0; i < nb_nics; i++)

        pci_nic_init(&nd_table[i], ""ne2k_pci"", NULL);



    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);

    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus
"");

        exit(1);

    }

    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,

                                      i % MAX_IDE_DEVS);

       if (drive_index != -1)

           hd[i] = drives_table[drive_index].bdrv;

       else

           hd[i] = NULL;

    }



    pci_cmd646_ide_init(pci_bus, hd, 1);



    /* FIXME: wire up interrupts.  */

    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);

    for(i = 0; i < MAX_FD; i++) {

        drive_index = drive_get_index(IF_FLOPPY, 0, i);

       if (drive_index != -1)

           fd[i] = drives_table[drive_index].bdrv;

       else

           fd[i] = NULL;

    }

    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);

    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);

    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, ""Sun4u"", RAM_size, boot_devices,

                           KERNEL_LOAD_ADDR, kernel_size,

                           kernel_cmdline,

                           INITRD_LOAD_ADDR, initrd_size,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);

    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",0,0,1,1,"RAM_size,boot_devices,kernel_filename,kernel_cmdline,initrd_filename,cpu_model,hwdef,env,filename,nvram,ret,linux_boot,i,ram_offset,prom_offset,initrd_size,kernel_size,pci_bus,pci_bus2,pci_bus3,bh,irq,drive_index,hd,MAX_IDE_BUS,MAX_IDE_DEVS,fd,MAX_FD,fw_cfg,reset_info","RAM_size:0.010051354765892029,boot_devices:0.025734156370162964,kernel_filename:0.0986441969871521,kernel_cmdline:0.007794633507728577,initrd_filename:0.0030824095010757446,cpu_model:0.07544998824596405,hwdef:0.07337823510169983,env:0.21322014927864075,filename:0.04387027025222778,nvram:0.04695478081703186,ret:0.027050629258155823,linux_boot:0.13712948560714722,i:0.027537018060684204,ram_offset:0.0414748340845108,prom_offset:0.05021461844444275,initrd_size:0.011332288384437561,kernel_size:0.06880934536457062,pci_bus:-0.002402171492576599,pci_bus2:0.002076864242553711,pci_bus3:0.01398390531539917,bh:0.031292036175727844,irq:0.016055181622505188,drive_index:0.026534482836723328,hd:-0.002748638391494751,MAX_IDE_BUS:0.009529605507850647,MAX_IDE_DEVS:0.018031224608421326,fd:-0.007286101579666138,MAX_FD:0.0025263428688049316,fw_cfg:0.0489250123500824,reset_info:0.14648906886577606,",3,15,"env:env,reset_info:steturepnputR_bu_tabl_ind,linux_boot:rrFUNgunTotctionuquantitiz,kernel_filename:ainterlacnext_pagee,",Greedy,437,0.16432677110036215
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",116,"static void fpu_init (CPUMIPSState *lele_clustersinterat2tab, const mips_def_t *onsubtit_ocksess_than_beNt)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        lele_clustersinterat2tab->fpus[i].fcr0 = onsubtit_ocksess_than_beNt->CP1_fcr0;



    memcpy(&lele_clustersinterat2tab->active_fpu, &lele_clustersinterat2tab->fpus[0], sizeof(lele_clustersinterat2tab->active_fpu));

    if (lele_clustersinterat2tab->user_mode_only) {

        if (lele_clustersinterat2tab->CP0_Config1 & (1 << CP0C1_FP))

            lele_clustersinterat2tab->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (lele_clustersinterat2tab->active_fpu.fcr0 & (1 << FCR0_F64))

            lele_clustersinterat2tab->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",0,0,1,1,"env,def,i","env:0.0645474623888731,def:0.017907055094838142,i:-0.006753280758857727,",2,12,"env:lele_clustersinterat2tab,def:onsubtit_ocksess_than_beNt,",Greedy,139,0.048636889457702635
45,"static int bfi_decode_frame(AVCodecContext *avctx, void *data,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *bfi = avctx->priv_data;

    uint8_t *dst = bfi->dst;

    uint8_t *src, *dst_offset, colour1, colour2;

    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;

    uint32_t *pal;

    int i, j, height = avctx->height;



    if (bfi->frame.data[0])

        avctx->release_buffer(avctx, &bfi->frame);



    bfi->frame.reference = 1;



    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        bfi->frame.pict_type = AV_PICTURE_TYPE_I;

        bfi->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.\n"");

            return -1;

        }

        pal = (uint32_t *)bfi->frame.data[1];

        for (i = 0; i < avctx->extradata_size / 3; i++) {

            int shift = 16;

            *pal = 0;

            for (j = 0; j < 3; j++, shift -= 8)

                *pal +=

                    ((avctx->extradata[i * 3 + j] << 2) |

                    (avctx->extradata[i * 3 + j] >> 4)) << shift;

            pal++;

        }

        bfi->frame.palette_has_changed = 1;

    } else {

        bfi->frame.pict_type = AV_PICTURE_TYPE_P;

        bfi->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (dst != frame_end) {

        static const uint8_t lentab[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.\n"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (dst + (length << lentab[code]) > frame_end)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(avctx, AV_LOG_ERROR, ""Frame larger than buffer.\n"");

                return -1;

            }

            bytestream_get_buffer(&buf, dst, length);

            dst += length;

            break;



        case 1:                //Back Chain

            dst_offset = dst - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < bfi->dst)

                break;

            while (length--)

                *dst++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            dst += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *dst++ = colour1;

                *dst++ = colour2;

            }

            break;



        }

    }



    src = bfi->dst;

    dst = bfi->frame.data[0];

    while (height--) {

        memcpy(dst, src, avctx->width);

        src += avctx->width;

        dst += bfi->frame.linesize[0];

    }

    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = bfi->frame;

    return buf_size;

}
",728,"static int bfi_decode_frame(AVCodecContext *sInChunkble_cEluzutionfi, void *une_table_clusttrststers,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->une_table_clusttrststers, *buf_end = avpkt->une_table_clusttrststers + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *bfi = sInChunkble_cEluzutionfi->priv_data;

    uint8_t *dst = bfi->dst;

    uint8_t *tive_bitable_tersef_toef_, *dst_offset, colour1, colour2;

    uint8_t *frame_end = bfi->dst + sInChunkble_cEluzutionfi->width * sInChunkble_cEluzutionfi->fcGunt_tazeoneftweighzEeact;

    uint32_t *antitizationflagspicturey_;

    int i, nHtitiLanionorP_coef_ta_lef, fcGunt_tazeoneftweighzEeact = sInChunkble_cEluzutionfi->fcGunt_tazeoneftweighzEeact;



    if (bfi->frame.une_table_clusttrststers[0])

        sInChunkble_cEluzutionfi->release_buffer(sInChunkble_cEluzutionfi, &bfi->frame);



    bfi->frame.reference = 1;



    if (sInChunkble_cEluzutionfi->get_buffer(sInChunkble_cEluzutionfi, &bfi->frame) < 0) {

        av_log(sInChunkble_cEluzutionfi, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!sInChunkble_cEluzutionfi->frame_number) {

        bfi->frame.pict_type = AV_PICTURE_TYPE_I;

        bfi->frame.key_frame = 1;

        /* Setting the palette */

        if (sInChunkble_cEluzutionfi->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.
"");

            return -1;

        }

        antitizationflagspicturey_ = (uint32_t *)bfi->frame.une_table_clusttrststers[1];

        for (i = 0; i < sInChunkble_cEluzutionfi->extradata_size / 3; i++) {

            int shift = 16;

            *antitizationflagspicturey_ = 0;

            for (nHtitiLanionorP_coef_ta_lef = 0; nHtitiLanionorP_coef_ta_lef < 3; nHtitiLanionorP_coef_ta_lef++, shift -= 8)

                *antitizationflagspicturey_ +=

                    ((sInChunkble_cEluzutionfi->extradata[i * 3 + nHtitiLanionorP_coef_ta_lef] << 2) |

                    (sInChunkble_cEluzutionfi->extradata[i * 3 + nHtitiLanionorP_coef_ta_lef] >> 4)) << shift;

            antitizationflagspicturey_++;

        }

        bfi->frame.palette_has_changed = 1;

    } else {

        bfi->frame.pict_type = AV_PICTURE_TYPE_P;

        bfi->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (dst != frame_end) {

        static const uint8_t lentab[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(sInChunkble_cEluzutionfi, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.
"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (dst + (length << lentab[code]) > frame_end)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(sInChunkble_cEluzutionfi, AV_LOG_ERROR, ""Frame larger than buffer.
"");

                return -1;

            }

            bytestream_get_buffer(&buf, dst, length);

            dst += length;

            break;



        case 1:                //Back Chain

            dst_offset = dst - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < bfi->dst)

                break;

            while (length--)

                *dst++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            dst += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *dst++ = colour1;

                *dst++ = colour2;

            }

            break;



        }

    }



    tive_bitable_tersef_toef_ = bfi->dst;

    dst = bfi->frame.une_table_clusttrststers[0];

    while (fcGunt_tazeoneftweighzEeact--) {

        memcpy(dst, tive_bitable_tersef_toef_, sInChunkble_cEluzutionfi->width);

        tive_bitable_tersef_toef_ += sInChunkble_cEluzutionfi->width;

        dst += bfi->frame.linesize[0];

    }

    *data_size = sizeof(AVFrame);

    *(AVFrame *)une_table_clusttrststers = bfi->frame;

    return buf_size;

}
",1,1,0,1,"avctx,data,data_size,avpkt,buf,buf_end,bfi,dst,src,dst_offset,colour1,colour2,frame_end,pal,i,j,lentab,length,height","avctx:0.03711855411529541,data:0.010042726993560791,data_size:0.00032401084899902344,avpkt:-0.0014443397521972656,buf:-0.02189558744430542,buf_end:-0.023045718669891357,bfi:-0.0017865300178527832,dst:-0.03284269571304321,src:0.004078805446624756,dst_offset:-0.005950808525085449,colour1:-0.018758118152618408,colour2:-0.036805033683776855,frame_end:-0.012770593166351318,pal:0.014542460441589355,i:0.021511554718017578,j:0.01833641529083252,lentab:0.0,length:0.0,height:0.0018579363822937012,",6,45,"avctx:sInChunkble_cEluzutionfi,i:i,j:nHtitiLanionorP_coef_ta_lef,pal:antitizationflagspicturey_,data:une_table_clusttrststers,src:tive_bitable_tersef_toef_,height:fcGunt_tazeoneftweighzEeact,",Greedy,558,0.18413676023483277
46,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !bus->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",563,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *lastltcluBttble_cZlusTaers = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""lastltcluBttble_cZlusTaers"");

    if (path != NULL) {

        lastltcluBttble_cZlusTaers = qbus_find(path);

        if (!lastltcluBttble_cZlusTaers) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(lastltcluBttble_cZlusTaers), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(lastltcluBttble_cZlusTaers)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        lastltcluBttble_cZlusTaers = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!lastltcluBttble_cZlusTaers) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && lastltcluBttble_cZlusTaers && !lastltcluBttble_cZlusTaers->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, lastltcluBttble_cZlusTaers->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (lastltcluBttble_cZlusTaers) {

        qdev_set_parent_bus(dev, lastltcluBttble_cZlusTaers);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",1,1,0,1,"opts,oc,dc,driver,path,id,dev,bus,err,typename,anon_count,name","opts:0.0032326877117156982,oc:0.0568523108959198,dc:0.0746431052684784,driver:0.07892441749572754,path:0.06631720066070557,id:0.03193691372871399,dev:0.03559383749961853,bus:0.08267128467559814,err:0.02933049201965332,typename:0.0006356239318847656,anon_count:0.0,name:-0.01014062762260437,",1,13,"bus:lastltcluBttble_cZlusTaers,",Greedy,156,0.05041437149047852
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
",24,"void thread_pool_submit(ThreadPoolFunc *rhChrFtConser_nb___nb__c, void *nl_mess_sizetactevguesse)

{

    thread_pool_submit_aio(rhChrFtConser_nb___nb__c, nl_mess_sizetactevguesse, NULL, NULL);

}
",0,0,1,1,"func,arg","func:0.00031316420063376427,arg:0.0005880864337086678,",2,4,"arg:nl_mess_sizetactevguesse,func:rhChrFtConser_nb___nb__c,",Greedy,126,0.04536276658376058
48,"static void pl061_register_devices(void)

{

    sysbus_register_dev(""pl061"", sizeof(pl061_state),

                        pl061_init_arm);

    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),

                        pl061_init_luminary);

}
",36,,0,1,,-4,,,,,,Greedy,1,0.007999165852864584
49,"int cpu_exec(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    cc->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        cc = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(cc == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, cpu);

        }

    }



    cc->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",232,"int cpu_exec(CPUState *izeMAX_DWTtrrsizeMA__DW)

{

    CPUClass *cc = CPU_GET_CLASS(izeMAX_DWTtrrsizeMA__DW);

    int tnext_page_stariredpct;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = izeMAX_DWTtrrsizeMA__DW;



    if (cpu_handle_halt(izeMAX_DWTtrrsizeMA__DW)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    cc->cpu_exec_enter(izeMAX_DWTtrrsizeMA__DW);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, izeMAX_DWTtrrsizeMA__DW);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(izeMAX_DWTtrrsizeMA__DW->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        izeMAX_DWTtrrsizeMA__DW = current_cpu;

        cc = CPU_GET_CLASS(izeMAX_DWTtrrsizeMA__DW);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(izeMAX_DWTtrrsizeMA__DW == current_cpu);

        g_assert(cc == CPU_GET_CLASS(izeMAX_DWTtrrsizeMA__DW));

#endif /* buggy compiler */

        izeMAX_DWTtrrsizeMA__DW->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(izeMAX_DWTtrrsizeMA__DW, &tnext_page_stariredpct)) {

        TranslationBlock *iredusftwonrIecouzt_tablfZ = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(izeMAX_DWTtrrsizeMA__DW, &iredusftwonrIecouzt_tablfZ)) {

            TranslationBlock *titizationlepredictector_ = tb_find(izeMAX_DWTtrrsizeMA__DW, iredusftwonrIecouzt_tablfZ, tb_exit);

            cpu_loop_exec_tb(izeMAX_DWTtrrsizeMA__DW, titizationlepredictector_, &iredusftwonrIecouzt_tablfZ, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, izeMAX_DWTtrrsizeMA__DW);

        }

    }



    cc->cpu_exec_exit(izeMAX_DWTtrrsizeMA__DW);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return tnext_page_stariredpct;

}
",1,1,0,1,"cpu,cc,ret,sc,last_tb,tb","cpu:-0.17953819036483765,cc:-0.19520121812820435,ret:-0.05136847496032715,sc:-0.06853985786437988,last_tb:-0.06120014190673828,tb:-0.0493507981300354,",4,27,"tb:titizationlepredictector_,ret:tnext_page_stariredpct,last_tb:iredusftwonrIecouzt_tablfZ,sc:sc,cpu:izeMAX_DWTtrrsizeMA__DW,",Greedy,338,0.10871296326319377
50,"static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)

{

    int i;

    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&dest->scsw, &src->scsw);



    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {

        dest->esw[i] = cpu_to_be32(src->esw[i]);

    }

    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {

        dest->ecw[i] = cpu_to_be32(src->ecw[i]);

    }

    /* extended measurements enabled? */

    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||

        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {

            dest->emw[i] = cpu_to_be32(src->emw[i]);

        }

    }

}
",245,"static void copy_irb_to_guest(IRB *dest, const IRB *_bizeUext_sackDQT_age_sear_, PMCW *pmcw)

{

    int edictor_ctoDef_tPanbleon;

    uint16_t stctl = _bizeUext_sackDQT_age_sear_->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = _bizeUext_sackDQT_age_sear_->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&dest->scsw, &_bizeUext_sackDQT_age_sear_->scsw);



    for (edictor_ctoDef_tPanbleon = 0; edictor_ctoDef_tPanbleon < ARRAY_SIZE(dest->esw); edictor_ctoDef_tPanbleon++) {

        dest->esw[edictor_ctoDef_tPanbleon] = cpu_to_be32(_bizeUext_sackDQT_age_sear_->esw[edictor_ctoDef_tPanbleon]);

    }

    for (edictor_ctoDef_tPanbleon = 0; edictor_ctoDef_tPanbleon < ARRAY_SIZE(dest->ecw); edictor_ctoDef_tPanbleon++) {

        dest->ecw[edictor_ctoDef_tPanbleon] = cpu_to_be32(_bizeUext_sackDQT_age_sear_->ecw[edictor_ctoDef_tPanbleon]);

    }

    /* extended measurements enabled? */

    if ((_bizeUext_sackDQT_age_sear_->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||

        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (edictor_ctoDef_tPanbleon = 0; edictor_ctoDef_tPanbleon < ARRAY_SIZE(dest->emw); edictor_ctoDef_tPanbleon++) {

            dest->emw[edictor_ctoDef_tPanbleon] = cpu_to_be32(_bizeUext_sackDQT_age_sear_->emw[edictor_ctoDef_tPanbleon]);

        }

    }

}
",0,0,1,1,"dest,src,pmcw,i","dest:0.01182820089161396,src:0.03435900993645191,pmcw:0.018933990970253944,i:0.02246721275150776,",2,24,"src:_bizeUext_sackDQT_age_sear_,i:edictor_ctoDef_tPanbleon,",Greedy,157,0.05427440404891968
51,"static int process_input_packet(InputStream *ist, const AVPacket *pkt)

{

    int i;

    int got_output;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &got_output);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (pkt) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",600,"static int process_input_packet(InputStream *xzation_sizauzd_tcable_alu, const AVPacket *pkt)

{

    int i;

    int got_output;

    AVPacket avpkt;



    if (xzation_sizauzd_tcable_alu->next_dts == AV_NOPTS_VALUE)

        xzation_sizauzd_tcable_alu->next_dts = xzation_sizauzd_tcable_alu->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        xzation_sizauzd_tcable_alu->next_dts = xzation_sizauzd_tcable_alu->last_dts = av_rescale_q(pkt->dts, xzation_sizauzd_tcable_alu->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (xzation_sizauzd_tcable_alu->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int ret = 0;

    handle_eof:



        xzation_sizauzd_tcable_alu->last_dts = xzation_sizauzd_tcable_alu->next_dts;



        if (avpkt.size && avpkt.size != pkt->size &&

            !(xzation_sizauzd_tcable_alu->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, xzation_sizauzd_tcable_alu->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d
"", pkt->stream_index);

            xzation_sizauzd_tcable_alu->showed_multi_packet_warning = 1;

        }



        switch (xzation_sizauzd_tcable_alu->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (xzation_sizauzd_tcable_alu, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (xzation_sizauzd_tcable_alu, &avpkt, &got_output);

            if (avpkt.duration)

                xzation_sizauzd_tcable_alu->next_dts += av_rescale_q(avpkt.duration, xzation_sizauzd_tcable_alu->st->time_base, AV_TIME_BASE_Q);

            else if (xzation_sizauzd_tcable_alu->st->avg_frame_rate.num)

                xzation_sizauzd_tcable_alu->next_dts += av_rescale_q(1, av_inv_q(xzation_sizauzd_tcable_alu->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (xzation_sizauzd_tcable_alu->dec_ctx->time_base.num != 0) {

                int ticks      = xzation_sizauzd_tcable_alu->st->parser ? xzation_sizauzd_tcable_alu->st->parser->repeat_pict + 1 :

                                                   xzation_sizauzd_tcable_alu->dec_ctx->ticks_per_frame;

                xzation_sizauzd_tcable_alu->next_dts += av_rescale_q(ticks, xzation_sizauzd_tcable_alu->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(xzation_sizauzd_tcable_alu, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (pkt) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!xzation_sizauzd_tcable_alu->decoding_needed) {

        xzation_sizauzd_tcable_alu->last_dts = xzation_sizauzd_tcable_alu->next_dts;

        switch (xzation_sizauzd_tcable_alu->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            xzation_sizauzd_tcable_alu->next_dts += ((int64_t)AV_TIME_BASE * xzation_sizauzd_tcable_alu->dec_ctx->frame_size) /

                             xzation_sizauzd_tcable_alu->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (xzation_sizauzd_tcable_alu->dec_ctx->time_base.num != 0) {

                int ticks = xzation_sizauzd_tcable_alu->st->parser ? xzation_sizauzd_tcable_alu->st->parser->repeat_pict + 1 : xzation_sizauzd_tcable_alu->dec_ctx->ticks_per_frame;

                xzation_sizauzd_tcable_alu->next_dts += ((int64_t)AV_TIME_BASE *

                                  xzation_sizauzd_tcable_alu->dec_ctx->time_base.num * ticks) /

                                  xzation_sizauzd_tcable_alu->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(xzation_sizauzd_tcable_alu, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(xzation_sizauzd_tcable_alu, ost, pkt);

    }



    return 0;

}
",0,0,1,1,"ist,pkt,i,got_output,avpkt,ost","ist:0.10047516226768494,pkt:0.09204027056694031,i:0.053153425455093384,got_output:-0.00317952036857605,avpkt:-0.12518170475959778,ost:-1.1920928955078125e-07,",1,44,"ist:xzation_sizauzd_tcable_alu,",Greedy,147,0.049379018942515056
52,"static target_ulong disas_insn(DisasContext *s, CPUState *cpu)

{

    CPUX86State *env = cpu->env_ptr;

    int b, prefixes;

    int shift;

    TCGMemOp ot, aflag, dflag;

    int modrm, reg, rm, mod, op, opreg, val;

    target_ulong next_eip, tval;

    int rex_w, rex_r;

    target_ulong pc_start = s->base.pc_next;



    s->pc_start = s->pc = pc_start;

    prefixes = 0;

    s->override = -1;

    rex_w = -1;

    rex_r = 0;

#ifdef TARGET_X86_64

    s->rex_x = 0;

    s->rex_b = 0;

    x86_64_hregs = 0;

#endif

    s->rip_offset = 0; /* for relative ip address */

    s->vex_l = 0;

    s->vex_v = 0;

    if (sigsetjmp(s->jmpbuf, 0) != 0) {

        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        return s->pc;

    }



 next_byte:

    b = x86_ldub_code(env, s);

    /* Collect prefixes.  */

    switch (b) {

    case 0xf3:

        prefixes |= PREFIX_REPZ;

        goto next_byte;

    case 0xf2:

        prefixes |= PREFIX_REPNZ;

        goto next_byte;

    case 0xf0:

        prefixes |= PREFIX_LOCK;

        goto next_byte;

    case 0x2e:

        s->override = R_CS;

        goto next_byte;

    case 0x36:

        s->override = R_SS;

        goto next_byte;

    case 0x3e:

        s->override = R_DS;

        goto next_byte;

    case 0x26:

        s->override = R_ES;

        goto next_byte;

    case 0x64:

        s->override = R_FS;

        goto next_byte;

    case 0x65:

        s->override = R_GS;

        goto next_byte;

    case 0x66:

        prefixes |= PREFIX_DATA;

        goto next_byte;

    case 0x67:

        prefixes |= PREFIX_ADR;

        goto next_byte;

#ifdef TARGET_X86_64

    case 0x40 ... 0x4f:

        if (CODE64(s)) {

            /* REX prefix */

            rex_w = (b >> 3) & 1;

            rex_r = (b & 0x4) << 1;

            s->rex_x = (b & 0x2) << 2;

            REX_B(s) = (b & 0x1) << 3;

            x86_64_hregs = 1; /* select uniform byte register addressing */

            goto next_byte;

        }

        break;

#endif

    case 0xc5: /* 2-byte VEX */

    case 0xc4: /* 3-byte VEX */

        /* VEX prefixes cannot be used except in 32-bit mode.

           Otherwise the instruction is LES or LDS.  */

        if (s->code32 && !s->vm86) {

            static const int pp_prefix[4] = {

                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ

            };

            int vex3, vex2 = x86_ldub_code(env, s);



            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {

                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,

                   otherwise the instruction is LES or LDS.  */

                break;

            }

            s->pc++;



            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */

            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ

                            | PREFIX_LOCK | PREFIX_DATA)) {

                goto illegal_op;

            }

#ifdef TARGET_X86_64

            if (x86_64_hregs) {

                goto illegal_op;

            }

#endif

            rex_r = (~vex2 >> 4) & 8;

            if (b == 0xc5) {

                vex3 = vex2;

                b = x86_ldub_code(env, s);

            } else {

#ifdef TARGET_X86_64

                s->rex_x = (~vex2 >> 3) & 8;

                s->rex_b = (~vex2 >> 2) & 8;

#endif

                vex3 = x86_ldub_code(env, s);

                rex_w = (vex3 >> 7) & 1;

                switch (vex2 & 0x1f) {

                case 0x01: /* Implied 0f leading opcode bytes.  */

                    b = x86_ldub_code(env, s) | 0x100;

                    break;

                case 0x02: /* Implied 0f 38 leading opcode bytes.  */

                    b = 0x138;

                    break;

                case 0x03: /* Implied 0f 3a leading opcode bytes.  */

                    b = 0x13a;

                    break;

                default:   /* Reserved for future use.  */

                    goto unknown_op;

                }

            }

            s->vex_v = (~vex3 >> 3) & 0xf;

            s->vex_l = (vex3 >> 2) & 1;

            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;

        }

        break;

    }



    /* Post-process prefixes.  */

    if (CODE64(s)) {

        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit

           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence

           over 0x66 if both are present.  */

        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);

        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */

        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);

    } else {

        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */

        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {

            dflag = MO_32;

        } else {

            dflag = MO_16;

        }

        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */

        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {

            aflag = MO_32;

        }  else {

            aflag = MO_16;

        }

    }



    s->prefix = prefixes;

    s->aflag = aflag;

    s->dflag = dflag;



    /* now check op code */

 reswitch:

    switch(b) {

    case 0x0f:

        /**************************/

        /* extended op code */

        b = x86_ldub_code(env, s) | 0x100;

        goto reswitch;



        /**************************/

        /* arith & logic */

    case 0x00 ... 0x05:

    case 0x08 ... 0x0d:

    case 0x10 ... 0x15:

    case 0x18 ... 0x1d:

    case 0x20 ... 0x25:

    case 0x28 ... 0x2d:

    case 0x30 ... 0x35:

    case 0x38 ... 0x3d:

        {

            int op, f, val;

            op = (b >> 3) & 7;

            f = (b >> 1) & 3;



            ot = mo_b_d(b, dflag);



            switch(f) {

            case 0: /* OP Ev, Gv */

                modrm = x86_ldub_code(env, s);

                reg = ((modrm >> 3) & 7) | rex_r;

                mod = (modrm >> 6) & 3;

                rm = (modrm & 7) | REX_B(s);

                if (mod != 3) {

                    gen_lea_modrm(env, s, modrm);

                    opreg = OR_TMP0;

                } else if (op == OP_XORL && rm == reg) {

                xor_zero:

                    /* xor reg, reg optimisation */

                    set_cc_op(s, CC_OP_CLR);

                    tcg_gen_movi_tl(cpu_T0, 0);

                    gen_op_mov_reg_v(ot, reg, cpu_T0);

                    break;

                } else {

                    opreg = rm;

                }

                gen_op_mov_v_reg(ot, cpu_T1, reg);

                gen_op(s, op, ot, opreg);

                break;

            case 1: /* OP Gv, Ev */

                modrm = x86_ldub_code(env, s);

                mod = (modrm >> 6) & 3;

                reg = ((modrm >> 3) & 7) | rex_r;

                rm = (modrm & 7) | REX_B(s);

                if (mod != 3) {

                    gen_lea_modrm(env, s, modrm);

                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);

                } else if (op == OP_XORL && rm == reg) {

                    goto xor_zero;

                } else {

                    gen_op_mov_v_reg(ot, cpu_T1, rm);

                }

                gen_op(s, op, ot, reg);

                break;

            case 2: /* OP A, Iv */

                val = insn_get(env, s, ot);

                tcg_gen_movi_tl(cpu_T1, val);

                gen_op(s, op, ot, OR_EAX);

                break;

            }

        }

        break;



    case 0x82:

        if (CODE64(s))

            goto illegal_op;

    case 0x80: /* GRP1 */

    case 0x81:

    case 0x83:

        {

            int val;



            ot = mo_b_d(b, dflag);



            modrm = x86_ldub_code(env, s);

            mod = (modrm >> 6) & 3;

            rm = (modrm & 7) | REX_B(s);

            op = (modrm >> 3) & 7;



            if (mod != 3) {

                if (b == 0x83)

                    s->rip_offset = 1;

                else

                    s->rip_offset = insn_const_size(ot);

                gen_lea_modrm(env, s, modrm);

                opreg = OR_TMP0;

            } else {

                opreg = rm;

            }



            switch(b) {

            default:

            case 0x80:

            case 0x81:

            case 0x82:

                val = insn_get(env, s, ot);

                break;

            case 0x83:

                val = (int8_t)insn_get(env, s, MO_8);

                break;

            }

            tcg_gen_movi_tl(cpu_T1, val);

            gen_op(s, op, ot, opreg);

        }

        break;



        /**************************/

        /* inc, dec, and other misc arith */

    case 0x40 ... 0x47: /* inc Gv */

        ot = dflag;

        gen_inc(s, ot, OR_EAX + (b & 7), 1);

        break;

    case 0x48 ... 0x4f: /* dec Gv */

        ot = dflag;

        gen_inc(s, ot, OR_EAX + (b & 7), -1);

        break;

    case 0xf6: /* GRP3 */

    case 0xf7:

        ot = mo_b_d(b, dflag);



        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        rm = (modrm & 7) | REX_B(s);

        op = (modrm >> 3) & 7;

        if (mod != 3) {

            if (op == 0) {

                s->rip_offset = insn_const_size(ot);

            }

            gen_lea_modrm(env, s, modrm);

            /* For those below that handle locked memory, don't load here.  */

            if (!(s->prefix & PREFIX_LOCK)

                || op != 2) {

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

            }

        } else {

            gen_op_mov_v_reg(ot, cpu_T0, rm);

        }



        switch(op) {

        case 0: /* test */

            val = insn_get(env, s, ot);

            tcg_gen_movi_tl(cpu_T1, val);

            gen_op_testl_T0_T1_cc();

            set_cc_op(s, CC_OP_LOGICB + ot);

            break;

        case 2: /* not */

            if (s->prefix & PREFIX_LOCK) {

                if (mod == 3) {

                    goto illegal_op;

                }

                tcg_gen_movi_tl(cpu_T0, ~0);

                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,

                                            s->mem_index, ot | MO_LE);

            } else {

                tcg_gen_not_tl(cpu_T0, cpu_T0);

                if (mod != 3) {

                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);

                } else {

                    gen_op_mov_reg_v(ot, rm, cpu_T0);

                }

            }

            break;

        case 3: /* neg */

            if (s->prefix & PREFIX_LOCK) {

                TCGLabel *label1;

                TCGv a0, t0, t1, t2;



                if (mod == 3) {

                    goto illegal_op;

                }

                a0 = tcg_temp_local_new();

                t0 = tcg_temp_local_new();

                label1 = gen_new_label();



                tcg_gen_mov_tl(a0, cpu_A0);

                tcg_gen_mov_tl(t0, cpu_T0);



                gen_set_label(label1);

                t1 = tcg_temp_new();

                t2 = tcg_temp_new();

                tcg_gen_mov_tl(t2, t0);

                tcg_gen_neg_tl(t1, t0);

                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,

                                          s->mem_index, ot | MO_LE);

                tcg_temp_free(t1);

                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);



                tcg_temp_free(t2);

                tcg_temp_free(a0);

                tcg_gen_mov_tl(cpu_T0, t0);

                tcg_temp_free(t0);

            } else {

                tcg_gen_neg_tl(cpu_T0, cpu_T0);

                if (mod != 3) {

                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);

                } else {

                    gen_op_mov_reg_v(ot, rm, cpu_T0);

                }

            }

            gen_op_update_neg_cc();

            set_cc_op(s, CC_OP_SUBB + ot);

            break;

        case 4: /* mul */

            switch(ot) {

            case MO_8:

                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);

                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);

                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);

                /* XXX: use 32 bit mul which could be faster */

                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);

                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);

                set_cc_op(s, CC_OP_MULB);

                break;

            case MO_16:

                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);

                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);

                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);

                /* XXX: use 32 bit mul which could be faster */

                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);

                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);

                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);

                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);

                set_cc_op(s, CC_OP_MULW);

                break;

            default:

            case MO_32:

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);

                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,

                                  cpu_tmp2_i32, cpu_tmp3_i32);

                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);

                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);

                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);

                set_cc_op(s, CC_OP_MULL);

                break;

#ifdef TARGET_X86_64

            case MO_64:

                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],

                                  cpu_T0, cpu_regs[R_EAX]);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);

                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);

                set_cc_op(s, CC_OP_MULQ);

                break;

#endif

            }

            break;

        case 5: /* imul */

            switch(ot) {

            case MO_8:

                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);

                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);

                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);

                /* XXX: use 32 bit mul which could be faster */

                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);

                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);

                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);

                set_cc_op(s, CC_OP_MULB);

                break;

            case MO_16:

                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);

                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);

                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);

                /* XXX: use 32 bit mul which could be faster */

                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);

                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);

                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);

                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);

                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);

                set_cc_op(s, CC_OP_MULW);

                break;

            default:

            case MO_32:

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);

                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,

                                  cpu_tmp2_i32, cpu_tmp3_i32);

                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);

                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);

                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);

                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);

                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);

                set_cc_op(s, CC_OP_MULL);

                break;

#ifdef TARGET_X86_64

            case MO_64:

                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],

                                  cpu_T0, cpu_regs[R_EAX]);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);

                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);

                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);

                set_cc_op(s, CC_OP_MULQ);

                break;

#endif

            }

            break;

        case 6: /* div */

            switch(ot) {

            case MO_8:

                gen_helper_divb_AL(cpu_env, cpu_T0);

                break;

            case MO_16:

                gen_helper_divw_AX(cpu_env, cpu_T0);

                break;

            default:

            case MO_32:

                gen_helper_divl_EAX(cpu_env, cpu_T0);

                break;

#ifdef TARGET_X86_64

            case MO_64:

                gen_helper_divq_EAX(cpu_env, cpu_T0);

                break;

#endif

            }

            break;

        case 7: /* idiv */

            switch(ot) {

            case MO_8:

                gen_helper_idivb_AL(cpu_env, cpu_T0);

                break;

            case MO_16:

                gen_helper_idivw_AX(cpu_env, cpu_T0);

                break;

            default:

            case MO_32:

                gen_helper_idivl_EAX(cpu_env, cpu_T0);

                break;

#ifdef TARGET_X86_64

            case MO_64:

                gen_helper_idivq_EAX(cpu_env, cpu_T0);

                break;

#endif

            }

            break;

        default:

            goto unknown_op;

        }

        break;



    case 0xfe: /* GRP4 */

    case 0xff: /* GRP5 */

        ot = mo_b_d(b, dflag);



        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        rm = (modrm & 7) | REX_B(s);

        op = (modrm >> 3) & 7;

        if (op >= 2 && b == 0xfe) {

            goto unknown_op;

        }

        if (CODE64(s)) {

            if (op == 2 || op == 4) {

                /* operand size for jumps is 64 bit */

                ot = MO_64;

            } else if (op == 3 || op == 5) {

                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;

            } else if (op == 6) {

                /* default push size is 64 bit */

                ot = mo_pushpop(s, dflag);

            }

        }

        if (mod != 3) {

            gen_lea_modrm(env, s, modrm);

            if (op >= 2 && op != 3 && op != 5)

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

        } else {

            gen_op_mov_v_reg(ot, cpu_T0, rm);

        }



        switch(op) {

        case 0: /* inc Ev */

            if (mod != 3)

                opreg = OR_TMP0;

            else

                opreg = rm;

            gen_inc(s, ot, opreg, 1);

            break;

        case 1: /* dec Ev */

            if (mod != 3)

                opreg = OR_TMP0;

            else

                opreg = rm;

            gen_inc(s, ot, opreg, -1);

            break;

        case 2: /* call Ev */

            /* XXX: optimize if memory (no 'and' is necessary) */

            if (dflag == MO_16) {

                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);

            }

            next_eip = s->pc - s->cs_base;

            tcg_gen_movi_tl(cpu_T1, next_eip);

            gen_push_v(s, cpu_T1);

            gen_op_jmp_v(cpu_T0);

            gen_bnd_jmp(s);

            gen_jr(s, cpu_T0);

            break;

        case 3: /* lcall Ev */

            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);

            gen_add_A0_im(s, 1 << ot);

            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);

        do_lcall:

            if (s->pe && !s->vm86) {

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,

                                           tcg_const_i32(dflag - 1),

                                           tcg_const_tl(s->pc - s->cs_base));

            } else {

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,

                                      tcg_const_i32(dflag - 1),

                                      tcg_const_i32(s->pc - s->cs_base));

            }

            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));

            gen_jr(s, cpu_tmp4);

            break;

        case 4: /* jmp Ev */

            if (dflag == MO_16) {

                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);

            }

            gen_op_jmp_v(cpu_T0);

            gen_bnd_jmp(s);

            gen_jr(s, cpu_T0);

            break;

        case 5: /* ljmp Ev */

            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);

            gen_add_A0_im(s, 1 << ot);

            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);

        do_ljmp:

            if (s->pe && !s->vm86) {

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,

                                          tcg_const_tl(s->pc - s->cs_base));

            } else {

                gen_op_movl_seg_T0_vm(R_CS);

                gen_op_jmp_v(cpu_T1);

            }

            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));

            gen_jr(s, cpu_tmp4);

            break;

        case 6: /* push Ev */

            gen_push_v(s, cpu_T0);

            break;

        default:

            goto unknown_op;

        }

        break;



    case 0x84: /* test Ev, Gv */

    case 0x85:

        ot = mo_b_d(b, dflag);



        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;



        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);

        gen_op_mov_v_reg(ot, cpu_T1, reg);

        gen_op_testl_T0_T1_cc();

        set_cc_op(s, CC_OP_LOGICB + ot);

        break;



    case 0xa8: /* test eAX, Iv */

    case 0xa9:

        ot = mo_b_d(b, dflag);

        val = insn_get(env, s, ot);



        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);

        tcg_gen_movi_tl(cpu_T1, val);

        gen_op_testl_T0_T1_cc();

        set_cc_op(s, CC_OP_LOGICB + ot);

        break;



    case 0x98: /* CWDE/CBW */

        switch (dflag) {

#ifdef TARGET_X86_64

        case MO_64:

            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);

            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);

            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);

            break;

#endif

        case MO_32:

            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);

            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);

            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);

            break;

        case MO_16:

            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);

            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);

            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

            break;

        default:

            tcg_abort();

        }

        break;

    case 0x99: /* CDQ/CWD */

        switch (dflag) {

#ifdef TARGET_X86_64

        case MO_64:

            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);

            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);

            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);

            break;

#endif

        case MO_32:

            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);

            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);

            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);

            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);

            break;

        case MO_16:

            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);

            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);

            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);

            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);

            break;

        default:

            tcg_abort();

        }

        break;

    case 0x1af: /* imul Gv, Ev */

    case 0x69: /* imul Gv, Ev, I */

    case 0x6b:

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        if (b == 0x69)

            s->rip_offset = insn_const_size(ot);

        else if (b == 0x6b)

            s->rip_offset = 1;

        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);

        if (b == 0x69) {

            val = insn_get(env, s, ot);

            tcg_gen_movi_tl(cpu_T1, val);

        } else if (b == 0x6b) {

            val = (int8_t)insn_get(env, s, MO_8);

            tcg_gen_movi_tl(cpu_T1, val);

        } else {

            gen_op_mov_v_reg(ot, cpu_T1, reg);

        }

        switch (ot) {

#ifdef TARGET_X86_64

        case MO_64:

            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);

            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);

            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);

            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);

            break;

#endif

        case MO_32:

            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);

            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,

                              cpu_tmp2_i32, cpu_tmp3_i32);

            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);

            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);

            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);

            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);

            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);

            break;

        default:

            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);

            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);

            /* XXX: use 32 bit mul which could be faster */

            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);

            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);

            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);

            gen_op_mov_reg_v(ot, reg, cpu_T0);

            break;

        }

        set_cc_op(s, CC_OP_MULB + ot);

        break;

    case 0x1c0:

    case 0x1c1: /* xadd Ev, Gv */

        ot = mo_b_d(b, dflag);

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        mod = (modrm >> 6) & 3;

        gen_op_mov_v_reg(ot, cpu_T0, reg);

        if (mod == 3) {

            rm = (modrm & 7) | REX_B(s);

            gen_op_mov_v_reg(ot, cpu_T1, rm);

            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);

            gen_op_mov_reg_v(ot, reg, cpu_T1);

            gen_op_mov_reg_v(ot, rm, cpu_T0);

        } else {

            gen_lea_modrm(env, s, modrm);

            if (s->prefix & PREFIX_LOCK) {

                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,

                                            s->mem_index, ot | MO_LE);

                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);

            } else {

                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);

                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);

                gen_op_st_v(s, ot, cpu_T0, cpu_A0);

            }

            gen_op_mov_reg_v(ot, reg, cpu_T1);

        }

        gen_op_update2_cc();

        set_cc_op(s, CC_OP_ADDB + ot);

        break;

    case 0x1b0:

    case 0x1b1: /* cmpxchg Ev, Gv */

        {

            TCGv oldv, newv, cmpv;



            ot = mo_b_d(b, dflag);

            modrm = x86_ldub_code(env, s);

            reg = ((modrm >> 3) & 7) | rex_r;

            mod = (modrm >> 6) & 3;

            oldv = tcg_temp_new();

            newv = tcg_temp_new();

            cmpv = tcg_temp_new();

            gen_op_mov_v_reg(ot, newv, reg);

            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);



            if (s->prefix & PREFIX_LOCK) {

                if (mod == 3) {

                    goto illegal_op;

                }

                gen_lea_modrm(env, s, modrm);

                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,

                                          s->mem_index, ot | MO_LE);

                gen_op_mov_reg_v(ot, R_EAX, oldv);

            } else {

                if (mod == 3) {

                    rm = (modrm & 7) | REX_B(s);

                    gen_op_mov_v_reg(ot, oldv, rm);

                } else {

                    gen_lea_modrm(env, s, modrm);

                    gen_op_ld_v(s, ot, oldv, cpu_A0);

                    rm = 0; /* avoid warning */

                }

                gen_extu(ot, oldv);

                gen_extu(ot, cmpv);

                /* store value = (old == cmp ? new : old);  */

                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);

                if (mod == 3) {

                    gen_op_mov_reg_v(ot, R_EAX, oldv);

                    gen_op_mov_reg_v(ot, rm, newv);

                } else {

                    /* Perform an unconditional store cycle like physical cpu;

                       must be before changing accumulator to ensure

                       idempotency if the store faults and the instruction

                       is restarted */

                    gen_op_st_v(s, ot, newv, cpu_A0);

                    gen_op_mov_reg_v(ot, R_EAX, oldv);

                }

            }

            tcg_gen_mov_tl(cpu_cc_src, oldv);

            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);

            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);

            set_cc_op(s, CC_OP_SUBB + ot);

            tcg_temp_free(oldv);

            tcg_temp_free(newv);

            tcg_temp_free(cmpv);

        }

        break;

    case 0x1c7: /* cmpxchg8b */

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        if ((mod == 3) || ((modrm & 0x38) != 0x8))

            goto illegal_op;

#ifdef TARGET_X86_64

        if (dflag == MO_64) {

            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))

                goto illegal_op;

            gen_lea_modrm(env, s, modrm);

            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {

                gen_helper_cmpxchg16b(cpu_env, cpu_A0);

            } else {

                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);

            }

        } else

#endif        

        {

            if (!(s->cpuid_features & CPUID_CX8))

                goto illegal_op;

            gen_lea_modrm(env, s, modrm);

            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {

                gen_helper_cmpxchg8b(cpu_env, cpu_A0);

            } else {

                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);

            }

        }

        set_cc_op(s, CC_OP_EFLAGS);

        break;



        /**************************/

        /* push/pop */

    case 0x50 ... 0x57: /* push */

        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));

        gen_push_v(s, cpu_T0);

        break;

    case 0x58 ... 0x5f: /* pop */

        ot = gen_pop_T0(s);

        /* NOTE: order is important for pop %sp */

        gen_pop_update(s, ot);

        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);

        break;

    case 0x60: /* pusha */

        if (CODE64(s))

            goto illegal_op;

        gen_pusha(s);

        break;

    case 0x61: /* popa */

        if (CODE64(s))

            goto illegal_op;

        gen_popa(s);

        break;

    case 0x68: /* push Iv */

    case 0x6a:

        ot = mo_pushpop(s, dflag);

        if (b == 0x68)

            val = insn_get(env, s, ot);

        else

            val = (int8_t)insn_get(env, s, MO_8);

        tcg_gen_movi_tl(cpu_T0, val);

        gen_push_v(s, cpu_T0);

        break;

    case 0x8f: /* pop Ev */

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        ot = gen_pop_T0(s);

        if (mod == 3) {

            /* NOTE: order is important for pop %sp */

            gen_pop_update(s, ot);

            rm = (modrm & 7) | REX_B(s);

            gen_op_mov_reg_v(ot, rm, cpu_T0);

        } else {

            /* NOTE: order is important too for MMU exceptions */

            s->popl_esp_hack = 1 << ot;

            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);

            s->popl_esp_hack = 0;

            gen_pop_update(s, ot);

        }

        break;

    case 0xc8: /* enter */

        {

            int level;

            val = x86_lduw_code(env, s);

            level = x86_ldub_code(env, s);

            gen_enter(s, val, level);

        }

        break;

    case 0xc9: /* leave */

        gen_leave(s);

        break;

    case 0x06: /* push es */

    case 0x0e: /* push cs */

    case 0x16: /* push ss */

    case 0x1e: /* push ds */

        if (CODE64(s))

            goto illegal_op;

        gen_op_movl_T0_seg(b >> 3);

        gen_push_v(s, cpu_T0);

        break;

    case 0x1a0: /* push fs */

    case 0x1a8: /* push gs */

        gen_op_movl_T0_seg((b >> 3) & 7);

        gen_push_v(s, cpu_T0);

        break;

    case 0x07: /* pop es */

    case 0x17: /* pop ss */

    case 0x1f: /* pop ds */

        if (CODE64(s))

            goto illegal_op;

        reg = b >> 3;

        ot = gen_pop_T0(s);

        gen_movl_seg_T0(s, reg);

        gen_pop_update(s, ot);

        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */

        if (s->base.is_jmp) {

            gen_jmp_im(s->pc - s->cs_base);

            if (reg == R_SS) {

                s->tf = 0;

                gen_eob_inhibit_irq(s, true);

            } else {

                gen_eob(s);

            }

        }

        break;

    case 0x1a1: /* pop fs */

    case 0x1a9: /* pop gs */

        ot = gen_pop_T0(s);

        gen_movl_seg_T0(s, (b >> 3) & 7);

        gen_pop_update(s, ot);

        if (s->base.is_jmp) {

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

        }

        break;



        /**************************/

        /* mov */

    case 0x88:

    case 0x89: /* mov Gv, Ev */

        ot = mo_b_d(b, dflag);

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;



        /* generate a generic store */

        gen_ldst_modrm(env, s, modrm, ot, reg, 1);

        break;

    case 0xc6:

    case 0xc7: /* mov Ev, Iv */

        ot = mo_b_d(b, dflag);

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        if (mod != 3) {

            s->rip_offset = insn_const_size(ot);

            gen_lea_modrm(env, s, modrm);

        }

        val = insn_get(env, s, ot);

        tcg_gen_movi_tl(cpu_T0, val);

        if (mod != 3) {

            gen_op_st_v(s, ot, cpu_T0, cpu_A0);

        } else {

            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);

        }

        break;

    case 0x8a:

    case 0x8b: /* mov Ev, Gv */

        ot = mo_b_d(b, dflag);

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;



        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);

        gen_op_mov_reg_v(ot, reg, cpu_T0);

        break;

    case 0x8e: /* mov seg, Gv */

        modrm = x86_ldub_code(env, s);

        reg = (modrm >> 3) & 7;

        if (reg >= 6 || reg == R_CS)

            goto illegal_op;

        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

        gen_movl_seg_T0(s, reg);

        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */

        if (s->base.is_jmp) {

            gen_jmp_im(s->pc - s->cs_base);

            if (reg == R_SS) {

                s->tf = 0;

                gen_eob_inhibit_irq(s, true);

            } else {

                gen_eob(s);

            }

        }

        break;

    case 0x8c: /* mov Gv, seg */

        modrm = x86_ldub_code(env, s);

        reg = (modrm >> 3) & 7;

        mod = (modrm >> 6) & 3;

        if (reg >= 6)

            goto illegal_op;

        gen_op_movl_T0_seg(reg);

        ot = mod == 3 ? dflag : MO_16;

        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);

        break;



    case 0x1b6: /* movzbS Gv, Eb */

    case 0x1b7: /* movzwS Gv, Eb */

    case 0x1be: /* movsbS Gv, Eb */

    case 0x1bf: /* movswS Gv, Eb */

        {

            TCGMemOp d_ot;

            TCGMemOp s_ot;



            /* d_ot is the size of destination */

            d_ot = dflag;

            /* ot is the size of source */

            ot = (b & 1) + MO_8;

            /* s_ot is the sign+size of source */

            s_ot = b & 8 ? MO_SIGN | ot : ot;



            modrm = x86_ldub_code(env, s);

            reg = ((modrm >> 3) & 7) | rex_r;

            mod = (modrm >> 6) & 3;

            rm = (modrm & 7) | REX_B(s);



            if (mod == 3) {

                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {

                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);

                } else {

                    gen_op_mov_v_reg(ot, cpu_T0, rm);

                    switch (s_ot) {

                    case MO_UB:

                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);

                        break;

                    case MO_SB:

                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);

                        break;

                    case MO_UW:

                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);

                        break;

                    default:

                    case MO_SW:

                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);

                        break;

                    }

                }

                gen_op_mov_reg_v(d_ot, reg, cpu_T0);

            } else {

                gen_lea_modrm(env, s, modrm);

                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);

                gen_op_mov_reg_v(d_ot, reg, cpu_T0);

            }

        }

        break;



    case 0x8d: /* lea */

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        if (mod == 3)

            goto illegal_op;

        reg = ((modrm >> 3) & 7) | rex_r;

        {

            AddressParts a = gen_lea_modrm_0(env, s, modrm);

            TCGv ea = gen_lea_modrm_1(a);

            gen_lea_v_seg(s, s->aflag, ea, -1, -1);

            gen_op_mov_reg_v(dflag, reg, cpu_A0);

        }

        break;



    case 0xa0: /* mov EAX, Ov */

    case 0xa1:

    case 0xa2: /* mov Ov, EAX */

    case 0xa3:

        {

            target_ulong offset_addr;



            ot = mo_b_d(b, dflag);

            switch (s->aflag) {

#ifdef TARGET_X86_64

            case MO_64:

                offset_addr = x86_ldq_code(env, s);

                break;

#endif

            default:

                offset_addr = insn_get(env, s, s->aflag);

                break;

            }

            tcg_gen_movi_tl(cpu_A0, offset_addr);

            gen_add_A0_ds_seg(s);

            if ((b & 2) == 0) {

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);

            } else {

                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);

                gen_op_st_v(s, ot, cpu_T0, cpu_A0);

            }

        }

        break;

    case 0xd7: /* xlat */

        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);

        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);

        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);

        gen_extu(s->aflag, cpu_A0);

        gen_add_A0_ds_seg(s);

        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);

        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);

        break;

    case 0xb0 ... 0xb7: /* mov R, Ib */

        val = insn_get(env, s, MO_8);

        tcg_gen_movi_tl(cpu_T0, val);

        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);

        break;

    case 0xb8 ... 0xbf: /* mov R, Iv */

#ifdef TARGET_X86_64

        if (dflag == MO_64) {

            uint64_t tmp;

            /* 64 bit case */

            tmp = x86_ldq_code(env, s);

            reg = (b & 7) | REX_B(s);

            tcg_gen_movi_tl(cpu_T0, tmp);

            gen_op_mov_reg_v(MO_64, reg, cpu_T0);

        } else

#endif

        {

            ot = dflag;

            val = insn_get(env, s, ot);

            reg = (b & 7) | REX_B(s);

            tcg_gen_movi_tl(cpu_T0, val);

            gen_op_mov_reg_v(ot, reg, cpu_T0);

        }

        break;



    case 0x91 ... 0x97: /* xchg R, EAX */

    do_xchg_reg_eax:

        ot = dflag;

        reg = (b & 7) | REX_B(s);

        rm = R_EAX;

        goto do_xchg_reg;

    case 0x86:

    case 0x87: /* xchg Ev, Gv */

        ot = mo_b_d(b, dflag);

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        mod = (modrm >> 6) & 3;

        if (mod == 3) {

            rm = (modrm & 7) | REX_B(s);

        do_xchg_reg:

            gen_op_mov_v_reg(ot, cpu_T0, reg);

            gen_op_mov_v_reg(ot, cpu_T1, rm);

            gen_op_mov_reg_v(ot, rm, cpu_T0);

            gen_op_mov_reg_v(ot, reg, cpu_T1);

        } else {

            gen_lea_modrm(env, s, modrm);

            gen_op_mov_v_reg(ot, cpu_T0, reg);

            /* for xchg, lock is implicit */

            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,

                                   s->mem_index, ot | MO_LE);

            gen_op_mov_reg_v(ot, reg, cpu_T1);

        }

        break;

    case 0xc4: /* les Gv */

        /* In CODE64 this is VEX3; see above.  */

        op = R_ES;

        goto do_lxx;

    case 0xc5: /* lds Gv */

        /* In CODE64 this is VEX2; see above.  */

        op = R_DS;

        goto do_lxx;

    case 0x1b2: /* lss Gv */

        op = R_SS;

        goto do_lxx;

    case 0x1b4: /* lfs Gv */

        op = R_FS;

        goto do_lxx;

    case 0x1b5: /* lgs Gv */

        op = R_GS;

    do_lxx:

        ot = dflag != MO_16 ? MO_32 : MO_16;

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        mod = (modrm >> 6) & 3;

        if (mod == 3)

            goto illegal_op;

        gen_lea_modrm(env, s, modrm);

        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);

        gen_add_A0_im(s, 1 << ot);

        /* load the segment first to handle exceptions properly */

        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);

        gen_movl_seg_T0(s, op);

        /* then put the data */

        gen_op_mov_reg_v(ot, reg, cpu_T1);

        if (s->base.is_jmp) {

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

        }

        break;



        /************************/

        /* shifts */

    case 0xc0:

    case 0xc1:

        /* shift Ev,Ib */

        shift = 2;

    grp2:

        {

            ot = mo_b_d(b, dflag);

            modrm = x86_ldub_code(env, s);

            mod = (modrm >> 6) & 3;

            op = (modrm >> 3) & 7;



            if (mod != 3) {

                if (shift == 2) {

                    s->rip_offset = 1;

                }

                gen_lea_modrm(env, s, modrm);

                opreg = OR_TMP0;

            } else {

                opreg = (modrm & 7) | REX_B(s);

            }



            /* simpler op */

            if (shift == 0) {

                gen_shift(s, op, ot, opreg, OR_ECX);

            } else {

                if (shift == 2) {

                    shift = x86_ldub_code(env, s);

                }

                gen_shifti(s, op, ot, opreg, shift);

            }

        }

        break;

    case 0xd0:

    case 0xd1:

        /* shift Ev,1 */

        shift = 1;

        goto grp2;

    case 0xd2:

    case 0xd3:

        /* shift Ev,cl */

        shift = 0;

        goto grp2;



    case 0x1a4: /* shld imm */

        op = 0;

        shift = 1;

        goto do_shiftd;

    case 0x1a5: /* shld cl */

        op = 0;

        shift = 0;

        goto do_shiftd;

    case 0x1ac: /* shrd imm */

        op = 1;

        shift = 1;

        goto do_shiftd;

    case 0x1ad: /* shrd cl */

        op = 1;

        shift = 0;

    do_shiftd:

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        rm = (modrm & 7) | REX_B(s);

        reg = ((modrm >> 3) & 7) | rex_r;

        if (mod != 3) {

            gen_lea_modrm(env, s, modrm);

            opreg = OR_TMP0;

        } else {

            opreg = rm;

        }

        gen_op_mov_v_reg(ot, cpu_T1, reg);



        if (shift) {

            TCGv imm = tcg_const_tl(x86_ldub_code(env, s));

            gen_shiftd_rm_T1(s, ot, opreg, op, imm);

            tcg_temp_free(imm);

        } else {

            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);

        }

        break;



        /************************/

        /* floats */

    case 0xd8 ... 0xdf:

        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {

            /* if CR0.EM or CR0.TS are set, generate an FPU exception */

            /* XXX: what to do if illegal op ? */

            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

            break;

        }

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        rm = modrm & 7;

        op = ((b & 7) << 3) | ((modrm >> 3) & 7);

        if (mod != 3) {

            /* memory op */

            gen_lea_modrm(env, s, modrm);

            switch(op) {

            case 0x00 ... 0x07: /* fxxxs */

            case 0x10 ... 0x17: /* fixxxl */

            case 0x20 ... 0x27: /* fxxxl */

            case 0x30 ... 0x37: /* fixxx */

                {

                    int op1;

                    op1 = op & 7;



                    switch(op >> 4) {

                    case 0:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);

                        break;

                    case 1:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);

                        break;

                    case 2:

                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,

                                            s->mem_index, MO_LEQ);

                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);

                        break;

                    case 3:

                    default:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LESW);

                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);

                        break;

                    }



                    gen_helper_fp_arith_ST0_FT0(op1);

                    if (op1 == 3) {

                        /* fcomp needs pop */

                        gen_helper_fpop(cpu_env);

                    }

                }

                break;

            case 0x08: /* flds */

            case 0x0a: /* fsts */

            case 0x0b: /* fstps */

            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */

            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */

            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */

                switch(op & 7) {

                case 0:

                    switch(op >> 4) {

                    case 0:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);

                        break;

                    case 1:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);

                        break;

                    case 2:

                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,

                                            s->mem_index, MO_LEQ);

                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);

                        break;

                    case 3:

                    default:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LESW);

                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);

                        break;

                    }

                    break;

                case 1:

                    /* XXX: the corresponding CPUID bit must be tested ! */

                    switch(op >> 4) {

                    case 1:

                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);

                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        break;

                    case 2:

                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);

                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,

                                            s->mem_index, MO_LEQ);

                        break;

                    case 3:

                    default:

                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);

                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUW);

                        break;

                    }

                    gen_helper_fpop(cpu_env);

                    break;

                default:

                    switch(op >> 4) {

                    case 0:

                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);

                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        break;

                    case 1:

                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);

                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        break;

                    case 2:

                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);

                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,

                                            s->mem_index, MO_LEQ);

                        break;

                    case 3:

                    default:

                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);

                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUW);

                        break;

                    }

                    if ((op & 7) == 3)

                        gen_helper_fpop(cpu_env);

                    break;

                }

                break;

            case 0x0c: /* fldenv mem */

                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));

                break;

            case 0x0d: /* fldcw mem */

                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                    s->mem_index, MO_LEUW);

                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);

                break;

            case 0x0e: /* fnstenv mem */

                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));

                break;

            case 0x0f: /* fnstcw mem */

                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);

                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                    s->mem_index, MO_LEUW);

                break;

            case 0x1d: /* fldt mem */

                gen_helper_fldt_ST0(cpu_env, cpu_A0);

                break;

            case 0x1f: /* fstpt mem */

                gen_helper_fstt_ST0(cpu_env, cpu_A0);

                gen_helper_fpop(cpu_env);

                break;

            case 0x2c: /* frstor mem */

                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));

                break;

            case 0x2e: /* fnsave mem */

                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));

                break;

            case 0x2f: /* fnstsw mem */

                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);

                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                    s->mem_index, MO_LEUW);

                break;

            case 0x3c: /* fbld */

                gen_helper_fbld_ST0(cpu_env, cpu_A0);

                break;

            case 0x3e: /* fbstp */

                gen_helper_fbst_ST0(cpu_env, cpu_A0);

                gen_helper_fpop(cpu_env);

                break;

            case 0x3d: /* fildll */

                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);

                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);

                break;

            case 0x3f: /* fistpll */

                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);

                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);

                gen_helper_fpop(cpu_env);

                break;

            default:

                goto unknown_op;

            }

        } else {

            /* register float ops */

            opreg = rm;



            switch(op) {

            case 0x08: /* fld sti */

                gen_helper_fpush(cpu_env);

                gen_helper_fmov_ST0_STN(cpu_env,

                                        tcg_const_i32((opreg + 1) & 7));

                break;

            case 0x09: /* fxchg sti */

            case 0x29: /* fxchg4 sti, undocumented op */

            case 0x39: /* fxchg7 sti, undocumented op */

                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));

                break;

            case 0x0a: /* grp d9/2 */

                switch(rm) {

                case 0: /* fnop */

                    /* check exceptions (FreeBSD FPU probe) */

                    gen_helper_fwait(cpu_env);

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x0c: /* grp d9/4 */

                switch(rm) {

                case 0: /* fchs */

                    gen_helper_fchs_ST0(cpu_env);

                    break;

                case 1: /* fabs */

                    gen_helper_fabs_ST0(cpu_env);

                    break;

                case 4: /* ftst */

                    gen_helper_fldz_FT0(cpu_env);

                    gen_helper_fcom_ST0_FT0(cpu_env);

                    break;

                case 5: /* fxam */

                    gen_helper_fxam_ST0(cpu_env);

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x0d: /* grp d9/5 */

                {

                    switch(rm) {

                    case 0:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fld1_ST0(cpu_env);

                        break;

                    case 1:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldl2t_ST0(cpu_env);

                        break;

                    case 2:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldl2e_ST0(cpu_env);

                        break;

                    case 3:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldpi_ST0(cpu_env);

                        break;

                    case 4:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldlg2_ST0(cpu_env);

                        break;

                    case 5:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldln2_ST0(cpu_env);

                        break;

                    case 6:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldz_ST0(cpu_env);

                        break;

                    default:

                        goto unknown_op;

                    }

                }

                break;

            case 0x0e: /* grp d9/6 */

                switch(rm) {

                case 0: /* f2xm1 */

                    gen_helper_f2xm1(cpu_env);

                    break;

                case 1: /* fyl2x */

                    gen_helper_fyl2x(cpu_env);

                    break;

                case 2: /* fptan */

                    gen_helper_fptan(cpu_env);

                    break;

                case 3: /* fpatan */

                    gen_helper_fpatan(cpu_env);

                    break;

                case 4: /* fxtract */

                    gen_helper_fxtract(cpu_env);

                    break;

                case 5: /* fprem1 */

                    gen_helper_fprem1(cpu_env);

                    break;

                case 6: /* fdecstp */

                    gen_helper_fdecstp(cpu_env);

                    break;

                default:

                case 7: /* fincstp */

                    gen_helper_fincstp(cpu_env);

                    break;

                }

                break;

            case 0x0f: /* grp d9/7 */

                switch(rm) {

                case 0: /* fprem */

                    gen_helper_fprem(cpu_env);

                    break;

                case 1: /* fyl2xp1 */

                    gen_helper_fyl2xp1(cpu_env);

                    break;

                case 2: /* fsqrt */

                    gen_helper_fsqrt(cpu_env);

                    break;

                case 3: /* fsincos */

                    gen_helper_fsincos(cpu_env);

                    break;

                case 5: /* fscale */

                    gen_helper_fscale(cpu_env);

                    break;

                case 4: /* frndint */

                    gen_helper_frndint(cpu_env);

                    break;

                case 6: /* fsin */

                    gen_helper_fsin(cpu_env);

                    break;

                default:

                case 7: /* fcos */

                    gen_helper_fcos(cpu_env);

                    break;

                }

                break;

            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */

            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */

            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */

                {

                    int op1;



                    op1 = op & 7;

                    if (op >= 0x20) {

                        gen_helper_fp_arith_STN_ST0(op1, opreg);

                        if (op >= 0x30)

                            gen_helper_fpop(cpu_env);

                    } else {

                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                        gen_helper_fp_arith_ST0_FT0(op1);

                    }

                }

                break;

            case 0x02: /* fcom */

            case 0x22: /* fcom2, undocumented op */

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fcom_ST0_FT0(cpu_env);

                break;

            case 0x03: /* fcomp */

            case 0x23: /* fcomp3, undocumented op */

            case 0x32: /* fcomp5, undocumented op */

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fcom_ST0_FT0(cpu_env);

                gen_helper_fpop(cpu_env);

                break;

            case 0x15: /* da/5 */

                switch(rm) {

                case 1: /* fucompp */

                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));

                    gen_helper_fucom_ST0_FT0(cpu_env);

                    gen_helper_fpop(cpu_env);

                    gen_helper_fpop(cpu_env);

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x1c:

                switch(rm) {

                case 0: /* feni (287 only, just do nop here) */

                    break;

                case 1: /* fdisi (287 only, just do nop here) */

                    break;

                case 2: /* fclex */

                    gen_helper_fclex(cpu_env);

                    break;

                case 3: /* fninit */

                    gen_helper_fninit(cpu_env);

                    break;

                case 4: /* fsetpm (287 only, just do nop here) */

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x1d: /* fucomi */

                if (!(s->cpuid_features & CPUID_CMOV)) {

                    goto illegal_op;

                }

                gen_update_cc_op(s);

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fucomi_ST0_FT0(cpu_env);

                set_cc_op(s, CC_OP_EFLAGS);

                break;

            case 0x1e: /* fcomi */

                if (!(s->cpuid_features & CPUID_CMOV)) {

                    goto illegal_op;

                }

                gen_update_cc_op(s);

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fcomi_ST0_FT0(cpu_env);

                set_cc_op(s, CC_OP_EFLAGS);

                break;

            case 0x28: /* ffree sti */

                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));

                break;

            case 0x2a: /* fst sti */

                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));

                break;

            case 0x2b: /* fstp sti */

            case 0x0b: /* fstp1 sti, undocumented op */

            case 0x3a: /* fstp8 sti, undocumented op */

            case 0x3b: /* fstp9 sti, undocumented op */

                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));

                gen_helper_fpop(cpu_env);

                break;

            case 0x2c: /* fucom st(i) */

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fucom_ST0_FT0(cpu_env);

                break;

            case 0x2d: /* fucomp st(i) */

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fucom_ST0_FT0(cpu_env);

                gen_helper_fpop(cpu_env);

                break;

            case 0x33: /* de/3 */

                switch(rm) {

                case 1: /* fcompp */

                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));

                    gen_helper_fcom_ST0_FT0(cpu_env);

                    gen_helper_fpop(cpu_env);

                    gen_helper_fpop(cpu_env);

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x38: /* ffreep sti, undocumented op */

                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fpop(cpu_env);

                break;

            case 0x3c: /* df/4 */

                switch(rm) {

                case 0:

                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);

                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);

                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x3d: /* fucomip */

                if (!(s->cpuid_features & CPUID_CMOV)) {

                    goto illegal_op;

                }

                gen_update_cc_op(s);

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fucomi_ST0_FT0(cpu_env);

                gen_helper_fpop(cpu_env);

                set_cc_op(s, CC_OP_EFLAGS);

                break;

            case 0x3e: /* fcomip */

                if (!(s->cpuid_features & CPUID_CMOV)) {

                    goto illegal_op;

                }

                gen_update_cc_op(s);

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fcomi_ST0_FT0(cpu_env);

                gen_helper_fpop(cpu_env);

                set_cc_op(s, CC_OP_EFLAGS);

                break;

            case 0x10 ... 0x13: /* fcmovxx */

            case 0x18 ... 0x1b:

                {

                    int op1;

                    TCGLabel *l1;

                    static const uint8_t fcmov_cc[8] = {

                        (JCC_B << 1),

                        (JCC_Z << 1),

                        (JCC_BE << 1),

                        (JCC_P << 1),

                    };



                    if (!(s->cpuid_features & CPUID_CMOV)) {

                        goto illegal_op;

                    }

                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);

                    l1 = gen_new_label();

                    gen_jcc1_noeob(s, op1, l1);

                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));

                    gen_set_label(l1);

                }

                break;

            default:

                goto unknown_op;

            }

        }

        break;

        /************************/

        /* string ops */



    case 0xa4: /* movsS */

    case 0xa5:

        ot = mo_b_d(b, dflag);

        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {

            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);

        } else {

            gen_movs(s, ot);

        }

        break;



    case 0xaa: /* stosS */

    case 0xab:

        ot = mo_b_d(b, dflag);

        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {

            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);

        } else {

            gen_stos(s, ot);

        }

        break;

    case 0xac: /* lodsS */

    case 0xad:

        ot = mo_b_d(b, dflag);

        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {

            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);

        } else {

            gen_lods(s, ot);

        }

        break;

    case 0xae: /* scasS */

    case 0xaf:

        ot = mo_b_d(b, dflag);

        if (prefixes & PREFIX_REPNZ) {

            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);

        } else if (prefixes & PREFIX_REPZ) {

            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);

        } else {

            gen_scas(s, ot);

        }

        break;



    case 0xa6: /* cmpsS */

    case 0xa7:

        ot = mo_b_d(b, dflag);

        if (prefixes & PREFIX_REPNZ) {

            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);

        } else if (prefixes & PREFIX_REPZ) {

            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);

        } else {

            gen_cmps(s, ot);

        }

        break;

    case 0x6c: /* insS */

    case 0x6d:

        ot = mo_b_d32(b, dflag);

        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);

        gen_check_io(s, ot, pc_start - s->cs_base, 

                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);

        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {

            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);

        } else {

            gen_ins(s, ot);

            if (s->base.tb->cflags & CF_USE_ICOUNT) {

                gen_jmp(s, s->pc - s->cs_base);

            }

        }

        break;

    case 0x6e: /* outsS */

    case 0x6f:

        ot = mo_b_d32(b, dflag);

        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);

        gen_check_io(s, ot, pc_start - s->cs_base,

                     svm_is_rep(prefixes) | 4);

        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {

            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);

        } else {

            gen_outs(s, ot);

            if (s->base.tb->cflags & CF_USE_ICOUNT) {

                gen_jmp(s, s->pc - s->cs_base);

            }

        }

        break;



        /************************/

        /* port I/O */



    case 0xe4:

    case 0xe5:

        ot = mo_b_d32(b, dflag);

        val = x86_ldub_code(env, s);

        tcg_gen_movi_tl(cpu_T0, val);

        gen_check_io(s, ot, pc_start - s->cs_base,

                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));

        if (s->base.tb->cflags & CF_USE_ICOUNT) {

            gen_io_start();

	}

        tcg_gen_movi_i32(cpu_tmp2_i32, val);

        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);

        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);

        gen_bpt_io(s, cpu_tmp2_i32, ot);

        if (s->base.tb->cflags & CF_USE_ICOUNT) {

            gen_io_end();

            gen_jmp(s, s->pc - s->cs_base);

        }

        break;

    case 0xe6:

    case 0xe7:

        ot = mo_b_d32(b, dflag);

        val = x86_ldub_code(env, s);

        tcg_gen_movi_tl(cpu_T0, val);

        gen_check_io(s, ot, pc_start - s->cs_base,

                     svm_is_rep(prefixes));

        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);



        if (s->base.tb->cflags & CF_USE_ICOUNT) {

            gen_io_start();

	}

        tcg_gen_movi_i32(cpu_tmp2_i32, val);

        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);

        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);

        gen_bpt_io(s, cpu_tmp2_i32, ot);

        if (s->base.tb->cflags & CF_USE_ICOUNT) {

            gen_io_end();

            gen_jmp(s, s->pc - s->cs_base);

        }

        break;

    case 0xec:

    case 0xed:

        ot = mo_b_d32(b, dflag);

        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);

        gen_check_io(s, ot, pc_start - s->cs_base,

                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));

        if (s->base.tb->cflags & CF_USE_ICOUNT) {

            gen_io_start();

	}

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);

        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);

        gen_bpt_io(s, cpu_tmp2_i32, ot);

        if (s->base.tb->cflags & CF_USE_ICOUNT) {

            gen_io_end();

            gen_jmp(s, s->pc - s->cs_base);

        }

        break;

    case 0xee:

    case 0xef:

        ot = mo_b_d32(b, dflag);

        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);

        gen_check_io(s, ot, pc_start - s->cs_base,

                     svm_is_rep(prefixes));

        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);



        if (s->base.tb->cflags & CF_USE_ICOUNT) {

            gen_io_start();

	}

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);

        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);

        gen_bpt_io(s, cpu_tmp2_i32, ot);

        if (s->base.tb->cflags & CF_USE_ICOUNT) {

            gen_io_end();

            gen_jmp(s, s->pc - s->cs_base);

        }

        break;



        /************************/

        /* control */

    case 0xc2: /* ret im */

        val = x86_ldsw_code(env, s);

        ot = gen_pop_T0(s);

        gen_stack_update(s, val + (1 << ot));

        /* Note that gen_pop_T0 uses a zero-extending load.  */

        gen_op_jmp_v(cpu_T0);

        gen_bnd_jmp(s);

        gen_jr(s, cpu_T0);

        break;

    case 0xc3: /* ret */

        ot = gen_pop_T0(s);

        gen_pop_update(s, ot);

        /* Note that gen_pop_T0 uses a zero-extending load.  */

        gen_op_jmp_v(cpu_T0);

        gen_bnd_jmp(s);

        gen_jr(s, cpu_T0);

        break;

    case 0xca: /* lret im */

        val = x86_ldsw_code(env, s);

    do_lret:

        if (s->pe && !s->vm86) {

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),

                                      tcg_const_i32(val));

        } else {

            gen_stack_A0(s);

            /* pop offset */

            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);

            /* NOTE: keeping EIP updated is not a problem in case of

               exception */

            gen_op_jmp_v(cpu_T0);

            /* pop selector */

            gen_add_A0_im(s, 1 << dflag);

            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);

            gen_op_movl_seg_T0_vm(R_CS);

            /* add stack offset */

            gen_stack_update(s, val + (2 << dflag));

        }

        gen_eob(s);

        break;

    case 0xcb: /* lret */

        val = 0;

        goto do_lret;

    case 0xcf: /* iret */

        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);

        if (!s->pe) {

            /* real mode */

            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));

            set_cc_op(s, CC_OP_EFLAGS);

        } else if (s->vm86) {

            if (s->iopl != 3) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

            } else {

                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));

                set_cc_op(s, CC_OP_EFLAGS);

            }

        } else {

            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),

                                      tcg_const_i32(s->pc - s->cs_base));

            set_cc_op(s, CC_OP_EFLAGS);

        }

        gen_eob(s);

        break;

    case 0xe8: /* call im */

        {

            if (dflag != MO_16) {

                tval = (int32_t)insn_get(env, s, MO_32);

            } else {

                tval = (int16_t)insn_get(env, s, MO_16);

            }

            next_eip = s->pc - s->cs_base;

            tval += next_eip;

            if (dflag == MO_16) {

                tval &= 0xffff;

            } else if (!CODE64(s)) {

                tval &= 0xffffffff;

            }

            tcg_gen_movi_tl(cpu_T0, next_eip);

            gen_push_v(s, cpu_T0);

            gen_bnd_jmp(s);

            gen_jmp(s, tval);

        }

        break;

    case 0x9a: /* lcall im */

        {

            unsigned int selector, offset;



            if (CODE64(s))

                goto illegal_op;

            ot = dflag;

            offset = insn_get(env, s, ot);

            selector = insn_get(env, s, MO_16);



            tcg_gen_movi_tl(cpu_T0, selector);

            tcg_gen_movi_tl(cpu_T1, offset);

        }

        goto do_lcall;

    case 0xe9: /* jmp im */

        if (dflag != MO_16) {

            tval = (int32_t)insn_get(env, s, MO_32);

        } else {

            tval = (int16_t)insn_get(env, s, MO_16);

        }

        tval += s->pc - s->cs_base;

        if (dflag == MO_16) {

            tval &= 0xffff;

        } else if (!CODE64(s)) {

            tval &= 0xffffffff;

        }

        gen_bnd_jmp(s);

        gen_jmp(s, tval);

        break;

    case 0xea: /* ljmp im */

        {

            unsigned int selector, offset;



            if (CODE64(s))

                goto illegal_op;

            ot = dflag;

            offset = insn_get(env, s, ot);

            selector = insn_get(env, s, MO_16);



            tcg_gen_movi_tl(cpu_T0, selector);

            tcg_gen_movi_tl(cpu_T1, offset);

        }

        goto do_ljmp;

    case 0xeb: /* jmp Jb */

        tval = (int8_t)insn_get(env, s, MO_8);

        tval += s->pc - s->cs_base;

        if (dflag == MO_16) {

            tval &= 0xffff;

        }

        gen_jmp(s, tval);

        break;

    case 0x70 ... 0x7f: /* jcc Jb */

        tval = (int8_t)insn_get(env, s, MO_8);

        goto do_jcc;

    case 0x180 ... 0x18f: /* jcc Jv */

        if (dflag != MO_16) {

            tval = (int32_t)insn_get(env, s, MO_32);

        } else {

            tval = (int16_t)insn_get(env, s, MO_16);

        }

    do_jcc:

        next_eip = s->pc - s->cs_base;

        tval += next_eip;

        if (dflag == MO_16) {

            tval &= 0xffff;

        }

        gen_bnd_jmp(s);

        gen_jcc(s, b, tval, next_eip);

        break;



    case 0x190 ... 0x19f: /* setcc Gv */

        modrm = x86_ldub_code(env, s);

        gen_setcc1(s, b, cpu_T0);

        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);

        break;

    case 0x140 ... 0x14f: /* cmov Gv, Ev */

        if (!(s->cpuid_features & CPUID_CMOV)) {

            goto illegal_op;

        }

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        gen_cmovcc1(env, s, ot, b, modrm, reg);

        break;



        /************************/

        /* flags */

    case 0x9c: /* pushf */

        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);

        if (s->vm86 && s->iopl != 3) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_update_cc_op(s);

            gen_helper_read_eflags(cpu_T0, cpu_env);

            gen_push_v(s, cpu_T0);

        }

        break;

    case 0x9d: /* popf */

        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);

        if (s->vm86 && s->iopl != 3) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            ot = gen_pop_T0(s);

            if (s->cpl == 0) {

                if (dflag != MO_16) {

                    gen_helper_write_eflags(cpu_env, cpu_T0,

                                            tcg_const_i32((TF_MASK | AC_MASK |

                                                           ID_MASK | NT_MASK |

                                                           IF_MASK |

                                                           IOPL_MASK)));

                } else {

                    gen_helper_write_eflags(cpu_env, cpu_T0,

                                            tcg_const_i32((TF_MASK | AC_MASK |

                                                           ID_MASK | NT_MASK |

                                                           IF_MASK | IOPL_MASK)

                                                          & 0xffff));

                }

            } else {

                if (s->cpl <= s->iopl) {

                    if (dflag != MO_16) {

                        gen_helper_write_eflags(cpu_env, cpu_T0,

                                                tcg_const_i32((TF_MASK |

                                                               AC_MASK |

                                                               ID_MASK |

                                                               NT_MASK |

                                                               IF_MASK)));

                    } else {

                        gen_helper_write_eflags(cpu_env, cpu_T0,

                                                tcg_const_i32((TF_MASK |

                                                               AC_MASK |

                                                               ID_MASK |

                                                               NT_MASK |

                                                               IF_MASK)

                                                              & 0xffff));

                    }

                } else {

                    if (dflag != MO_16) {

                        gen_helper_write_eflags(cpu_env, cpu_T0,

                                           tcg_const_i32((TF_MASK | AC_MASK |

                                                          ID_MASK | NT_MASK)));

                    } else {

                        gen_helper_write_eflags(cpu_env, cpu_T0,

                                           tcg_const_i32((TF_MASK | AC_MASK |

                                                          ID_MASK | NT_MASK)

                                                         & 0xffff));

                    }

                }

            }

            gen_pop_update(s, ot);

            set_cc_op(s, CC_OP_EFLAGS);

            /* abort translation because TF/AC flag may change */

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

        }

        break;

    case 0x9e: /* sahf */

        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))

            goto illegal_op;

        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);

        gen_compute_eflags(s);

        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);

        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);

        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);

        break;

    case 0x9f: /* lahf */

        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))

            goto illegal_op;

        gen_compute_eflags(s);

        /* Note: gen_compute_eflags() only gives the condition codes */

        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);

        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);

        break;

    case 0xf5: /* cmc */

        gen_compute_eflags(s);

        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);

        break;

    case 0xf8: /* clc */

        gen_compute_eflags(s);

        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);

        break;

    case 0xf9: /* stc */

        gen_compute_eflags(s);

        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);

        break;

    case 0xfc: /* cld */

        tcg_gen_movi_i32(cpu_tmp2_i32, 1);

        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));

        break;

    case 0xfd: /* std */

        tcg_gen_movi_i32(cpu_tmp2_i32, -1);

        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));

        break;



        /************************/

        /* bit operations */

    case 0x1ba: /* bt/bts/btr/btc Gv, im */

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        op = (modrm >> 3) & 7;

        mod = (modrm >> 6) & 3;

        rm = (modrm & 7) | REX_B(s);

        if (mod != 3) {

            s->rip_offset = 1;

            gen_lea_modrm(env, s, modrm);

            if (!(s->prefix & PREFIX_LOCK)) {

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

            }

        } else {

            gen_op_mov_v_reg(ot, cpu_T0, rm);

        }

        /* load shift */

        val = x86_ldub_code(env, s);

        tcg_gen_movi_tl(cpu_T1, val);

        if (op < 4)

            goto unknown_op;

        op -= 4;

        goto bt_op;

    case 0x1a3: /* bt Gv, Ev */

        op = 0;

        goto do_btx;

    case 0x1ab: /* bts */

        op = 1;

        goto do_btx;

    case 0x1b3: /* btr */

        op = 2;

        goto do_btx;

    case 0x1bb: /* btc */

        op = 3;

    do_btx:

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        mod = (modrm >> 6) & 3;

        rm = (modrm & 7) | REX_B(s);

        gen_op_mov_v_reg(MO_32, cpu_T1, reg);

        if (mod != 3) {

            AddressParts a = gen_lea_modrm_0(env, s, modrm);

            /* specific case: we need to add a displacement */

            gen_exts(ot, cpu_T1);

            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);

            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);

            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);

            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);

            if (!(s->prefix & PREFIX_LOCK)) {

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

            }

        } else {

            gen_op_mov_v_reg(ot, cpu_T0, rm);

        }

    bt_op:

        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);

        tcg_gen_movi_tl(cpu_tmp0, 1);

        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);

        if (s->prefix & PREFIX_LOCK) {

            switch (op) {

            case 0: /* bt */

                /* Needs no atomic ops; we surpressed the normal

                   memory load for LOCK above so do it now.  */

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

                break;

            case 1: /* bts */

                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,

                                           s->mem_index, ot | MO_LE);

                break;

            case 2: /* btr */

                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);

                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,

                                            s->mem_index, ot | MO_LE);

                break;

            default:

            case 3: /* btc */

                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,

                                            s->mem_index, ot | MO_LE);

                break;

            }

            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);

        } else {

            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);

            switch (op) {

            case 0: /* bt */

                /* Data already loaded; nothing to do.  */

                break;

            case 1: /* bts */

                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);

                break;

            case 2: /* btr */

                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);

                break;

            default:

            case 3: /* btc */

                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);

                break;

            }

            if (op != 0) {

                if (mod != 3) {

                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);

                } else {

                    gen_op_mov_reg_v(ot, rm, cpu_T0);

                }

            }

        }



        /* Delay all CC updates until after the store above.  Note that

           C is the result of the test, Z is unchanged, and the others

           are all undefined.  */

        switch (s->cc_op) {

        case CC_OP_MULB ... CC_OP_MULQ:

        case CC_OP_ADDB ... CC_OP_ADDQ:

        case CC_OP_ADCB ... CC_OP_ADCQ:

        case CC_OP_SUBB ... CC_OP_SUBQ:

        case CC_OP_SBBB ... CC_OP_SBBQ:

        case CC_OP_LOGICB ... CC_OP_LOGICQ:

        case CC_OP_INCB ... CC_OP_INCQ:

        case CC_OP_DECB ... CC_OP_DECQ:

        case CC_OP_SHLB ... CC_OP_SHLQ:

        case CC_OP_SARB ... CC_OP_SARQ:

        case CC_OP_BMILGB ... CC_OP_BMILGQ:

            /* Z was going to be computed from the non-zero status of CC_DST.

               We can get that same Z value (and the new C value) by leaving

               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the

               same width.  */

            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);

            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);

            break;

        default:

            /* Otherwise, generate EFLAGS and replace the C bit.  */

            gen_compute_eflags(s);

            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,

                               ctz32(CC_C), 1);

            break;

        }

        break;

    case 0x1bc: /* bsf / tzcnt */

    case 0x1bd: /* bsr / lzcnt */

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);

        gen_extu(ot, cpu_T0);



        /* Note that lzcnt and tzcnt are in different extensions.  */

        if ((prefixes & PREFIX_REPZ)

            && (b & 1

                ? s->cpuid_ext3_features & CPUID_EXT3_ABM

                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {

            int size = 8 << ot;

            /* For lzcnt/tzcnt, C bit is defined related to the input. */

            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);

            if (b & 1) {

                /* For lzcnt, reduce the target_ulong result by the

                   number of zeros that we expect to find at the top.  */

                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);

                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);

            } else {

                /* For tzcnt, a zero input must return the operand size.  */

                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);

            }

            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */

            gen_op_update1_cc();

            set_cc_op(s, CC_OP_BMILGB + ot);

        } else {

            /* For bsr/bsf, only the Z bit is defined and it is related

               to the input and not the result.  */

            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

            set_cc_op(s, CC_OP_LOGICB + ot);



            /* ??? The manual says that the output is undefined when the

               input is zero, but real hardware leaves it unchanged, and

               real programs appear to depend on that.  Accomplish this

               by passing the output as the value to return upon zero.  */

            if (b & 1) {

                /* For bsr, return the bit index of the first 1 bit,

                   not the count of leading zeros.  */

                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);

                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);

                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);

            } else {

                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);

            }

        }

        gen_op_mov_reg_v(ot, reg, cpu_T0);

        break;

        /************************/

        /* bcd */

    case 0x27: /* daa */

        if (CODE64(s))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_helper_daa(cpu_env);

        set_cc_op(s, CC_OP_EFLAGS);

        break;

    case 0x2f: /* das */

        if (CODE64(s))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_helper_das(cpu_env);

        set_cc_op(s, CC_OP_EFLAGS);

        break;

    case 0x37: /* aaa */

        if (CODE64(s))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_helper_aaa(cpu_env);

        set_cc_op(s, CC_OP_EFLAGS);

        break;

    case 0x3f: /* aas */

        if (CODE64(s))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_helper_aas(cpu_env);

        set_cc_op(s, CC_OP_EFLAGS);

        break;

    case 0xd4: /* aam */

        if (CODE64(s))

            goto illegal_op;

        val = x86_ldub_code(env, s);

        if (val == 0) {

            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);

        } else {

            gen_helper_aam(cpu_env, tcg_const_i32(val));

            set_cc_op(s, CC_OP_LOGICB);

        }

        break;

    case 0xd5: /* aad */

        if (CODE64(s))

            goto illegal_op;

        val = x86_ldub_code(env, s);

        gen_helper_aad(cpu_env, tcg_const_i32(val));

        set_cc_op(s, CC_OP_LOGICB);

        break;

        /************************/

        /* misc */

    case 0x90: /* nop */

        /* XXX: correct lock test for all insn */

        if (prefixes & PREFIX_LOCK) {

            goto illegal_op;

        }

        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */

        if (REX_B(s)) {

            goto do_xchg_reg_eax;

        }

        if (prefixes & PREFIX_REPZ) {

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));

            s->base.is_jmp = DISAS_NORETURN;

        }

        break;

    case 0x9b: /* fwait */

        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==

            (HF_MP_MASK | HF_TS_MASK)) {

            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

        } else {

            gen_helper_fwait(cpu_env);

        }

        break;

    case 0xcc: /* int3 */

        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);

        break;

    case 0xcd: /* int N */

        val = x86_ldub_code(env, s);

        if (s->vm86 && s->iopl != 3) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);

        }

        break;

    case 0xce: /* into */

        if (CODE64(s))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_jmp_im(pc_start - s->cs_base);

        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));

        break;

#ifdef WANT_ICEBP

    case 0xf1: /* icebp (undocumented, exits to external debugger) */

        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);

#if 1

        gen_debug(s, pc_start - s->cs_base);

#else

        /* start debug */

        tb_flush(CPU(x86_env_get_cpu(env)));

        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);

#endif

        break;

#endif

    case 0xfa: /* cli */

        if (!s->vm86) {

            if (s->cpl <= s->iopl) {

                gen_helper_cli(cpu_env);

            } else {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

            }

        } else {

            if (s->iopl == 3) {

                gen_helper_cli(cpu_env);

            } else {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

            }

        }

        break;

    case 0xfb: /* sti */

        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {

            gen_helper_sti(cpu_env);

            /* interruptions are enabled only the first insn after sti */

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob_inhibit_irq(s, true);

        } else {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        }

        break;

    case 0x62: /* bound */

        if (CODE64(s))

            goto illegal_op;

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        reg = (modrm >> 3) & 7;

        mod = (modrm >> 6) & 3;

        if (mod == 3)

            goto illegal_op;

        gen_op_mov_v_reg(ot, cpu_T0, reg);

        gen_lea_modrm(env, s, modrm);

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        if (ot == MO_16) {

            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);

        } else {

            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);

        }

        break;

    case 0x1c8 ... 0x1cf: /* bswap reg */

        reg = (b & 7) | REX_B(s);

#ifdef TARGET_X86_64

        if (dflag == MO_64) {

            gen_op_mov_v_reg(MO_64, cpu_T0, reg);

            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);

            gen_op_mov_reg_v(MO_64, reg, cpu_T0);

        } else

#endif

        {

            gen_op_mov_v_reg(MO_32, cpu_T0, reg);

            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);

            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);

            gen_op_mov_reg_v(MO_32, reg, cpu_T0);

        }

        break;

    case 0xd6: /* salc */

        if (CODE64(s))

            goto illegal_op;

        gen_compute_eflags_c(s, cpu_T0);

        tcg_gen_neg_tl(cpu_T0, cpu_T0);

        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);

        break;

    case 0xe0: /* loopnz */

    case 0xe1: /* loopz */

    case 0xe2: /* loop */

    case 0xe3: /* jecxz */

        {

            TCGLabel *l1, *l2, *l3;



            tval = (int8_t)insn_get(env, s, MO_8);

            next_eip = s->pc - s->cs_base;

            tval += next_eip;

            if (dflag == MO_16) {

                tval &= 0xffff;

            }



            l1 = gen_new_label();

            l2 = gen_new_label();

            l3 = gen_new_label();

            b &= 3;

            switch(b) {

            case 0: /* loopnz */

            case 1: /* loopz */

                gen_op_add_reg_im(s->aflag, R_ECX, -1);

                gen_op_jz_ecx(s->aflag, l3);

                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);

                break;

            case 2: /* loop */

                gen_op_add_reg_im(s->aflag, R_ECX, -1);

                gen_op_jnz_ecx(s->aflag, l1);

                break;

            default:

            case 3: /* jcxz */

                gen_op_jz_ecx(s->aflag, l1);

                break;

            }



            gen_set_label(l3);

            gen_jmp_im(next_eip);

            tcg_gen_br(l2);



            gen_set_label(l1);

            gen_jmp_im(tval);

            gen_set_label(l2);

            gen_eob(s);

        }

        break;

    case 0x130: /* wrmsr */

    case 0x132: /* rdmsr */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            if (b & 2) {

                gen_helper_rdmsr(cpu_env);

            } else {

                gen_helper_wrmsr(cpu_env);

            }

        }

        break;

    case 0x131: /* rdtsc */

        gen_update_cc_op(s);

        gen_jmp_im(pc_start - s->cs_base);

        if (s->base.tb->cflags & CF_USE_ICOUNT) {

            gen_io_start();

	}

        gen_helper_rdtsc(cpu_env);

        if (s->base.tb->cflags & CF_USE_ICOUNT) {

            gen_io_end();

            gen_jmp(s, s->pc - s->cs_base);

        }

        break;

    case 0x133: /* rdpmc */

        gen_update_cc_op(s);

        gen_jmp_im(pc_start - s->cs_base);

        gen_helper_rdpmc(cpu_env);

        break;

    case 0x134: /* sysenter */

        /* For Intel SYSENTER is valid on 64-bit */

        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)

            goto illegal_op;

        if (!s->pe) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_helper_sysenter(cpu_env);

            gen_eob(s);

        }

        break;

    case 0x135: /* sysexit */

        /* For Intel SYSEXIT is valid on 64-bit */

        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)

            goto illegal_op;

        if (!s->pe) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));

            gen_eob(s);

        }

        break;

#ifdef TARGET_X86_64

    case 0x105: /* syscall */

        /* XXX: is it usable in real mode ? */

        gen_update_cc_op(s);

        gen_jmp_im(pc_start - s->cs_base);

        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));

        /* TF handling for the syscall insn is different. The TF bit is  checked

           after the syscall insn completes. This allows #DB to not be

           generated after one has entered CPL0 if TF is set in FMASK.  */

        gen_eob_worker(s, false, true);

        break;

    case 0x107: /* sysret */

        if (!s->pe) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));

            /* condition codes are modified only in long mode */

            if (s->lma) {

                set_cc_op(s, CC_OP_EFLAGS);

            }

            /* TF handling for the sysret insn is different. The TF bit is

               checked after the sysret insn completes. This allows #DB to be

               generated ""as if"" the syscall insn in userspace has just

               completed.  */

            gen_eob_worker(s, false, true);

        }

        break;

#endif

    case 0x1a2: /* cpuid */

        gen_update_cc_op(s);

        gen_jmp_im(pc_start - s->cs_base);

        gen_helper_cpuid(cpu_env);

        break;

    case 0xf4: /* hlt */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));

            s->base.is_jmp = DISAS_NORETURN;

        }

        break;

    case 0x100:

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        op = (modrm >> 3) & 7;

        switch(op) {

        case 0: /* sldt */

            if (!s->pe || s->vm86)

                goto illegal_op;

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);

            tcg_gen_ld32u_tl(cpu_T0, cpu_env,

                             offsetof(CPUX86State, ldt.selector));

            ot = mod == 3 ? dflag : MO_16;

            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);

            break;

        case 2: /* lldt */

            if (!s->pe || s->vm86)

                goto illegal_op;

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

            } else {

                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);

                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                gen_helper_lldt(cpu_env, cpu_tmp2_i32);

            }

            break;

        case 1: /* str */

            if (!s->pe || s->vm86)

                goto illegal_op;

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);

            tcg_gen_ld32u_tl(cpu_T0, cpu_env,

                             offsetof(CPUX86State, tr.selector));

            ot = mod == 3 ? dflag : MO_16;

            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);

            break;

        case 3: /* ltr */

            if (!s->pe || s->vm86)

                goto illegal_op;

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

            } else {

                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);

                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                gen_helper_ltr(cpu_env, cpu_tmp2_i32);

            }

            break;

        case 4: /* verr */

        case 5: /* verw */

            if (!s->pe || s->vm86)

                goto illegal_op;

            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

            gen_update_cc_op(s);

            if (op == 4) {

                gen_helper_verr(cpu_env, cpu_T0);

            } else {

                gen_helper_verw(cpu_env, cpu_T0);

            }

            set_cc_op(s, CC_OP_EFLAGS);

            break;

        default:

            goto unknown_op;

        }

        break;



    case 0x101:

        modrm = x86_ldub_code(env, s);

        switch (modrm) {

        CASE_MODRM_MEM_OP(0): /* sgdt */

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);

            gen_lea_modrm(env, s, modrm);

            tcg_gen_ld32u_tl(cpu_T0,

                             cpu_env, offsetof(CPUX86State, gdt.limit));

            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);

            gen_add_A0_im(s, 2);

            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));

            if (dflag == MO_16) {

                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);

            }

            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);

            break;



        case 0xc8: /* monitor */

            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {

                goto illegal_op;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);

            gen_extu(s->aflag, cpu_A0);

            gen_add_A0_ds_seg(s);

            gen_helper_monitor(cpu_env, cpu_A0);

            break;



        case 0xc9: /* mwait */

            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {

                goto illegal_op;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));

            gen_eob(s);

            break;



        case 0xca: /* clac */

            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)

                || s->cpl != 0) {

                goto illegal_op;

            }

            gen_helper_clac(cpu_env);

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        case 0xcb: /* stac */

            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)

                || s->cpl != 0) {

                goto illegal_op;

            }

            gen_helper_stac(cpu_env);

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        CASE_MODRM_MEM_OP(1): /* sidt */

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);

            gen_lea_modrm(env, s, modrm);

            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));

            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);

            gen_add_A0_im(s, 2);

            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));

            if (dflag == MO_16) {

                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);

            }

            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);

            break;



        case 0xd0: /* xgetbv */

            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0

                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA

                                 | PREFIX_REPZ | PREFIX_REPNZ))) {

                goto illegal_op;

            }

            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);

            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);

            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);

            break;



        case 0xd1: /* xsetbv */

            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0

                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA

                                 | PREFIX_REPZ | PREFIX_REPNZ))) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],

                                  cpu_regs[R_EDX]);

            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);

            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);

            /* End TB because translation flags may change.  */

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        case 0xd8: /* VMRUN */

            if (!(s->flags & HF_SVME_MASK) || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),

                             tcg_const_i32(s->pc - pc_start));

            tcg_gen_exit_tb(0);

            s->base.is_jmp = DISAS_NORETURN;

            break;



        case 0xd9: /* VMMCALL */

            if (!(s->flags & HF_SVME_MASK)) {

                goto illegal_op;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_vmmcall(cpu_env);

            break;



        case 0xda: /* VMLOAD */

            if (!(s->flags & HF_SVME_MASK) || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));

            break;



        case 0xdb: /* VMSAVE */

            if (!(s->flags & HF_SVME_MASK) || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));

            break;



        case 0xdc: /* STGI */

            if ((!(s->flags & HF_SVME_MASK)

                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))

                || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_stgi(cpu_env);

            break;



        case 0xdd: /* CLGI */

            if (!(s->flags & HF_SVME_MASK) || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_clgi(cpu_env);

            break;



        case 0xde: /* SKINIT */

            if ((!(s->flags & HF_SVME_MASK)

                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))

                || !s->pe) {

                goto illegal_op;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_skinit(cpu_env);

            break;



        case 0xdf: /* INVLPGA */

            if (!(s->flags & HF_SVME_MASK) || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));

            break;



        CASE_MODRM_MEM_OP(2): /* lgdt */

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);

            gen_lea_modrm(env, s, modrm);

            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);

            gen_add_A0_im(s, 2);

            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);

            if (dflag == MO_16) {

                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);

            }

            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));

            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));

            break;



        CASE_MODRM_MEM_OP(3): /* lidt */

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);

            gen_lea_modrm(env, s, modrm);

            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);

            gen_add_A0_im(s, 2);

            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);

            if (dflag == MO_16) {

                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);

            }

            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));

            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));

            break;



        CASE_MODRM_OP(4): /* smsw */

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);

            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));

            if (CODE64(s)) {

                mod = (modrm >> 6) & 3;

                ot = (mod != 3 ? MO_16 : s->dflag);

            } else {

                ot = MO_16;

            }

            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);

            break;

        case 0xee: /* rdpkru */

            if (prefixes & PREFIX_LOCK) {

                goto illegal_op;

            }

            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);

            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);

            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);

            break;

        case 0xef: /* wrpkru */

            if (prefixes & PREFIX_LOCK) {

                goto illegal_op;

            }

            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],

                                  cpu_regs[R_EDX]);

            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);

            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);

            break;

        CASE_MODRM_OP(6): /* lmsw */

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);

            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

            gen_helper_lmsw(cpu_env, cpu_T0);

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        CASE_MODRM_MEM_OP(7): /* invlpg */

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_lea_modrm(env, s, modrm);

            gen_helper_invlpg(cpu_env, cpu_A0);

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        case 0xf8: /* swapgs */

#ifdef TARGET_X86_64

            if (CODE64(s)) {

                if (s->cpl != 0) {

                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                } else {

                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);

                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,

                                  offsetof(CPUX86State, kernelgsbase));

                    tcg_gen_st_tl(cpu_T0, cpu_env,

                                  offsetof(CPUX86State, kernelgsbase));

                }

                break;

            }

#endif

            goto illegal_op;



        case 0xf9: /* rdtscp */

            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {

                goto illegal_op;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            if (s->base.tb->cflags & CF_USE_ICOUNT) {

                gen_io_start();

            }

            gen_helper_rdtscp(cpu_env);

            if (s->base.tb->cflags & CF_USE_ICOUNT) {

                gen_io_end();

                gen_jmp(s, s->pc - s->cs_base);

            }

            break;



        default:

            goto unknown_op;

        }

        break;



    case 0x108: /* invd */

    case 0x109: /* wbinvd */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);

            /* nothing to do */

        }

        break;

    case 0x63: /* arpl or movslS (x86_64) */

#ifdef TARGET_X86_64

        if (CODE64(s)) {

            int d_ot;

            /* d_ot is the size of destination */

            d_ot = dflag;



            modrm = x86_ldub_code(env, s);

            reg = ((modrm >> 3) & 7) | rex_r;

            mod = (modrm >> 6) & 3;

            rm = (modrm & 7) | REX_B(s);



            if (mod == 3) {

                gen_op_mov_v_reg(MO_32, cpu_T0, rm);

                /* sign extend */

                if (d_ot == MO_64) {

                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);

                }

                gen_op_mov_reg_v(d_ot, reg, cpu_T0);

            } else {

                gen_lea_modrm(env, s, modrm);

                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);

                gen_op_mov_reg_v(d_ot, reg, cpu_T0);

            }

        } else

#endif

        {

            TCGLabel *label1;

            TCGv t0, t1, t2, a0;



            if (!s->pe || s->vm86)

                goto illegal_op;

            t0 = tcg_temp_local_new();

            t1 = tcg_temp_local_new();

            t2 = tcg_temp_local_new();

            ot = MO_16;

            modrm = x86_ldub_code(env, s);

            reg = (modrm >> 3) & 7;

            mod = (modrm >> 6) & 3;

            rm = modrm & 7;

            if (mod != 3) {

                gen_lea_modrm(env, s, modrm);

                gen_op_ld_v(s, ot, t0, cpu_A0);

                a0 = tcg_temp_local_new();

                tcg_gen_mov_tl(a0, cpu_A0);

            } else {

                gen_op_mov_v_reg(ot, t0, rm);

                TCGV_UNUSED(a0);

            }

            gen_op_mov_v_reg(ot, t1, reg);

            tcg_gen_andi_tl(cpu_tmp0, t0, 3);

            tcg_gen_andi_tl(t1, t1, 3);

            tcg_gen_movi_tl(t2, 0);

            label1 = gen_new_label();

            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);

            tcg_gen_andi_tl(t0, t0, ~3);

            tcg_gen_or_tl(t0, t0, t1);

            tcg_gen_movi_tl(t2, CC_Z);

            gen_set_label(label1);

            if (mod != 3) {

                gen_op_st_v(s, ot, t0, a0);

                tcg_temp_free(a0);

           } else {

                gen_op_mov_reg_v(ot, rm, t0);

            }

            gen_compute_eflags(s);

            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);

            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);

            tcg_temp_free(t0);

            tcg_temp_free(t1);

            tcg_temp_free(t2);

        }

        break;

    case 0x102: /* lar */

    case 0x103: /* lsl */

        {

            TCGLabel *label1;

            TCGv t0;

            if (!s->pe || s->vm86)

                goto illegal_op;

            ot = dflag != MO_16 ? MO_32 : MO_16;

            modrm = x86_ldub_code(env, s);

            reg = ((modrm >> 3) & 7) | rex_r;

            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

            t0 = tcg_temp_local_new();

            gen_update_cc_op(s);

            if (b == 0x102) {

                gen_helper_lar(t0, cpu_env, cpu_T0);

            } else {

                gen_helper_lsl(t0, cpu_env, cpu_T0);

            }

            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);

            label1 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);

            gen_op_mov_reg_v(ot, reg, t0);

            gen_set_label(label1);

            set_cc_op(s, CC_OP_EFLAGS);

            tcg_temp_free(t0);

        }

        break;

    case 0x118:

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        op = (modrm >> 3) & 7;

        switch(op) {

        case 0: /* prefetchnta */

        case 1: /* prefetchnt0 */

        case 2: /* prefetchnt0 */

        case 3: /* prefetchnt0 */

            if (mod == 3)

                goto illegal_op;

            gen_nop_modrm(env, s, modrm);

            /* nothing more to do */

            break;

        default: /* nop (multi byte) */

            gen_nop_modrm(env, s, modrm);

            break;

        }

        break;

    case 0x11a:

        modrm = x86_ldub_code(env, s);

        if (s->flags & HF_MPX_EN_MASK) {

            mod = (modrm >> 6) & 3;

            reg = ((modrm >> 3) & 7) | rex_r;

            if (prefixes & PREFIX_REPZ) {

                /* bndcl */

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16) {

                    goto illegal_op;

                }

                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);

            } else if (prefixes & PREFIX_REPNZ) {

                /* bndcu */

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16) {

                    goto illegal_op;

                }

                TCGv_i64 notu = tcg_temp_new_i64();

                tcg_gen_not_i64(notu, cpu_bndu[reg]);

                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);

                tcg_temp_free_i64(notu);

            } else if (prefixes & PREFIX_DATA) {

                /* bndmov -- from reg/mem */

                if (reg >= 4 || s->aflag == MO_16) {

                    goto illegal_op;

                }

                if (mod == 3) {

                    int reg2 = (modrm & 7) | REX_B(s);

                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {

                        goto illegal_op;

                    }

                    if (s->flags & HF_MPX_IU_MASK) {

                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);

                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);

                    }

                } else {

                    gen_lea_modrm(env, s, modrm);

                    if (CODE64(s)) {

                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,

                                            s->mem_index, MO_LEQ);

                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);

                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,

                                            s->mem_index, MO_LEQ);

                    } else {

                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,

                                            s->mem_index, MO_LEUL);

                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);

                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,

                                            s->mem_index, MO_LEUL);

                    }

                    /* bnd registers are now in-use */

                    gen_set_hflag(s, HF_MPX_IU_MASK);

                }

            } else if (mod != 3) {

                /* bndldx */

                AddressParts a = gen_lea_modrm_0(env, s, modrm);

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16

                    || a.base < -1) {

                    goto illegal_op;

                }

                if (a.base >= 0) {

                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);

                } else {

                    tcg_gen_movi_tl(cpu_A0, 0);

                }

                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);

                if (a.index >= 0) {

                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);

                } else {

                    tcg_gen_movi_tl(cpu_T0, 0);

                }

                if (CODE64(s)) {

                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);

                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,

                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));

                } else {

                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);

                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);

                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);

                }

                gen_set_hflag(s, HF_MPX_IU_MASK);

            }

        }

        gen_nop_modrm(env, s, modrm);

        break;

    case 0x11b:

        modrm = x86_ldub_code(env, s);

        if (s->flags & HF_MPX_EN_MASK) {

            mod = (modrm >> 6) & 3;

            reg = ((modrm >> 3) & 7) | rex_r;

            if (mod != 3 && (prefixes & PREFIX_REPZ)) {

                /* bndmk */

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16) {

                    goto illegal_op;

                }

                AddressParts a = gen_lea_modrm_0(env, s, modrm);

                if (a.base >= 0) {

                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);

                    if (!CODE64(s)) {

                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);

                    }

                } else if (a.base == -1) {

                    /* no base register has lower bound of 0 */

                    tcg_gen_movi_i64(cpu_bndl[reg], 0);

                } else {

                    /* rip-relative generates #ud */

                    goto illegal_op;

                }

                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));

                if (!CODE64(s)) {

                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);

                }

                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);

                /* bnd registers are now in-use */

                gen_set_hflag(s, HF_MPX_IU_MASK);

                break;

            } else if (prefixes & PREFIX_REPNZ) {

                /* bndcn */

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16) {

                    goto illegal_op;

                }

                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);

            } else if (prefixes & PREFIX_DATA) {

                /* bndmov -- to reg/mem */

                if (reg >= 4 || s->aflag == MO_16) {

                    goto illegal_op;

                }

                if (mod == 3) {

                    int reg2 = (modrm & 7) | REX_B(s);

                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {

                        goto illegal_op;

                    }

                    if (s->flags & HF_MPX_IU_MASK) {

                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);

                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);

                    }

                } else {

                    gen_lea_modrm(env, s, modrm);

                    if (CODE64(s)) {

                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,

                                            s->mem_index, MO_LEQ);

                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);

                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,

                                            s->mem_index, MO_LEQ);

                    } else {

                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,

                                            s->mem_index, MO_LEUL);

                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);

                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,

                                            s->mem_index, MO_LEUL);

                    }

                }

            } else if (mod != 3) {

                /* bndstx */

                AddressParts a = gen_lea_modrm_0(env, s, modrm);

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16

                    || a.base < -1) {

                    goto illegal_op;

                }

                if (a.base >= 0) {

                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);

                } else {

                    tcg_gen_movi_tl(cpu_A0, 0);

                }

                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);

                if (a.index >= 0) {

                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);

                } else {

                    tcg_gen_movi_tl(cpu_T0, 0);

                }

                if (CODE64(s)) {

                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,

                                        cpu_bndl[reg], cpu_bndu[reg]);

                } else {

                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,

                                        cpu_bndl[reg], cpu_bndu[reg]);

                }

            }

        }

        gen_nop_modrm(env, s, modrm);

        break;

    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */

        modrm = x86_ldub_code(env, s);

        gen_nop_modrm(env, s, modrm);

        break;

    case 0x120: /* mov reg, crN */

    case 0x122: /* mov crN, reg */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            modrm = x86_ldub_code(env, s);

            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).

             * AMD documentation (24594.pdf) and testing of

             * intel 386 and 486 processors all show that the mod bits

             * are assumed to be 1's, regardless of actual values.

             */

            rm = (modrm & 7) | REX_B(s);

            reg = ((modrm >> 3) & 7) | rex_r;

            if (CODE64(s))

                ot = MO_64;

            else

                ot = MO_32;

            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&

                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {

                reg = 8;

            }

            switch(reg) {

            case 0:

            case 2:

            case 3:

            case 4:

            case 8:

                gen_update_cc_op(s);

                gen_jmp_im(pc_start - s->cs_base);

                if (b & 2) {

                    if (s->base.tb->cflags & CF_USE_ICOUNT) {

                        gen_io_start();

                    }

                    gen_op_mov_v_reg(ot, cpu_T0, rm);

                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),

                                         cpu_T0);

                    if (s->base.tb->cflags & CF_USE_ICOUNT) {

                        gen_io_end();

                    }

                    gen_jmp_im(s->pc - s->cs_base);

                    gen_eob(s);

                } else {

                    if (s->base.tb->cflags & CF_USE_ICOUNT) {

                        gen_io_start();

                    }

                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));

                    gen_op_mov_reg_v(ot, rm, cpu_T0);

                    if (s->base.tb->cflags & CF_USE_ICOUNT) {

                        gen_io_end();

                    }

                }

                break;

            default:

                goto unknown_op;

            }

        }

        break;

    case 0x121: /* mov reg, drN */

    case 0x123: /* mov drN, reg */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            modrm = x86_ldub_code(env, s);

            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).

             * AMD documentation (24594.pdf) and testing of

             * intel 386 and 486 processors all show that the mod bits

             * are assumed to be 1's, regardless of actual values.

             */

            rm = (modrm & 7) | REX_B(s);

            reg = ((modrm >> 3) & 7) | rex_r;

            if (CODE64(s))

                ot = MO_64;

            else

                ot = MO_32;

            if (reg >= 8) {

                goto illegal_op;

            }

            if (b & 2) {

                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);

                gen_op_mov_v_reg(ot, cpu_T0, rm);

                tcg_gen_movi_i32(cpu_tmp2_i32, reg);

                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);

                gen_jmp_im(s->pc - s->cs_base);

                gen_eob(s);

            } else {

                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);

                tcg_gen_movi_i32(cpu_tmp2_i32, reg);

                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);

                gen_op_mov_reg_v(ot, rm, cpu_T0);

            }

        }

        break;

    case 0x106: /* clts */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);

            gen_helper_clts(cpu_env);

            /* abort block because static cpu state changed */

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

        }

        break;

    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */

    case 0x1c3: /* MOVNTI reg, mem */

        if (!(s->cpuid_features & CPUID_SSE2))

            goto illegal_op;

        ot = mo_64_32(dflag);

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        if (mod == 3)

            goto illegal_op;

        reg = ((modrm >> 3) & 7) | rex_r;

        /* generate a generic store */

        gen_ldst_modrm(env, s, modrm, ot, reg, 1);

        break;

    case 0x1ae:

        modrm = x86_ldub_code(env, s);

        switch (modrm) {

        CASE_MODRM_MEM_OP(0): /* fxsave */

            if (!(s->cpuid_features & CPUID_FXSR)

                || (prefixes & PREFIX_LOCK)) {

                goto illegal_op;

            }

            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {

                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

                break;

            }

            gen_lea_modrm(env, s, modrm);

            gen_helper_fxsave(cpu_env, cpu_A0);

            break;



        CASE_MODRM_MEM_OP(1): /* fxrstor */

            if (!(s->cpuid_features & CPUID_FXSR)

                || (prefixes & PREFIX_LOCK)) {

                goto illegal_op;

            }

            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {

                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

                break;

            }

            gen_lea_modrm(env, s, modrm);

            gen_helper_fxrstor(cpu_env, cpu_A0);

            break;



        CASE_MODRM_MEM_OP(2): /* ldmxcsr */

            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {

                goto illegal_op;

            }

            if (s->flags & HF_TS_MASK) {

                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

                break;

            }

            gen_lea_modrm(env, s, modrm);

            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);

            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);

            break;



        CASE_MODRM_MEM_OP(3): /* stmxcsr */

            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {

                goto illegal_op;

            }

            if (s->flags & HF_TS_MASK) {

                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

                break;

            }

            gen_lea_modrm(env, s, modrm);

            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));

            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);

            break;



        CASE_MODRM_MEM_OP(4): /* xsave */

            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0

                || (prefixes & (PREFIX_LOCK | PREFIX_DATA

                                | PREFIX_REPZ | PREFIX_REPNZ))) {

                goto illegal_op;

            }

            gen_lea_modrm(env, s, modrm);

            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],

                                  cpu_regs[R_EDX]);

            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);

            break;



        CASE_MODRM_MEM_OP(5): /* xrstor */

            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0

                || (prefixes & (PREFIX_LOCK | PREFIX_DATA

                                | PREFIX_REPZ | PREFIX_REPNZ))) {

                goto illegal_op;

            }

            gen_lea_modrm(env, s, modrm);

            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],

                                  cpu_regs[R_EDX]);

            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);

            /* XRSTOR is how MPX is enabled, which changes how

               we translate.  Thus we need to end the TB.  */

            gen_update_cc_op(s);

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */

            if (prefixes & PREFIX_LOCK) {

                goto illegal_op;

            }

            if (prefixes & PREFIX_DATA) {

                /* clwb */

                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {

                    goto illegal_op;

                }

                gen_nop_modrm(env, s, modrm);

            } else {

                /* xsaveopt */

                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0

                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0

                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {

                    goto illegal_op;

                }

                gen_lea_modrm(env, s, modrm);

                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],

                                      cpu_regs[R_EDX]);

                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);

            }

            break;



        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */

            if (prefixes & PREFIX_LOCK) {

                goto illegal_op;

            }

            if (prefixes & PREFIX_DATA) {

                /* clflushopt */

                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {

                    goto illegal_op;

                }

            } else {

                /* clflush */

                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))

                    || !(s->cpuid_features & CPUID_CLFLUSH)) {

                    goto illegal_op;

                }

            }

            gen_nop_modrm(env, s, modrm);

            break;



        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */

        case 0xc8 ... 0xcf: /* rdgsbase (f3 0f ae /1) */

        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */

        case 0xd8 ... 0xdf: /* wrgsbase (f3 0f ae /3) */

            if (CODE64(s)

                && (prefixes & PREFIX_REPZ)

                && !(prefixes & PREFIX_LOCK)

                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {

                TCGv base, treg, src, dst;



                /* Preserve hflags bits by testing CR4 at runtime.  */

                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);

                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);



                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];

                treg = cpu_regs[(modrm & 7) | REX_B(s)];



                if (modrm & 0x10) {

                    /* wr*base */

                    dst = base, src = treg;

                } else {

                    /* rd*base */

                    dst = treg, src = base;

                }



                if (s->dflag == MO_32) {

                    tcg_gen_ext32u_tl(dst, src);

                } else {

                    tcg_gen_mov_tl(dst, src);

                }

                break;

            }

            goto unknown_op;



        case 0xf8: /* sfence / pcommit */

            if (prefixes & PREFIX_DATA) {

                /* pcommit */

                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)

                    || (prefixes & PREFIX_LOCK)) {

                    goto illegal_op;

                }

                break;

            }

            /* fallthru */

        case 0xf9 ... 0xff: /* sfence */

            if (!(s->cpuid_features & CPUID_SSE)

                || (prefixes & PREFIX_LOCK)) {

                goto illegal_op;

            }

            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);

            break;

        case 0xe8 ... 0xef: /* lfence */

            if (!(s->cpuid_features & CPUID_SSE)

                || (prefixes & PREFIX_LOCK)) {

                goto illegal_op;

            }

            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);

            break;

        case 0xf0 ... 0xf7: /* mfence */

            if (!(s->cpuid_features & CPUID_SSE2)

                || (prefixes & PREFIX_LOCK)) {

                goto illegal_op;

            }

            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);

            break;



        default:

            goto unknown_op;

        }

        break;



    case 0x10d: /* 3DNow! prefetch(w) */

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        if (mod == 3)

            goto illegal_op;

        gen_nop_modrm(env, s, modrm);

        break;

    case 0x1aa: /* rsm */

        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);

        if (!(s->flags & HF_SMM_MASK))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_jmp_im(s->pc - s->cs_base);

        gen_helper_rsm(cpu_env);

        gen_eob(s);

        break;

    case 0x1b8: /* SSE4.2 popcnt */

        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=

             PREFIX_REPZ)

            goto illegal_op;

        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))

            goto illegal_op;



        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;



        if (s->prefix & PREFIX_DATA) {

            ot = MO_16;

        } else {

            ot = mo_64_32(dflag);

        }



        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);

        gen_extu(ot, cpu_T0);

        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);

        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);

        gen_op_mov_reg_v(ot, reg, cpu_T0);



        set_cc_op(s, CC_OP_POPCNT);

        break;

    case 0x10e ... 0x10f:

        /* 3DNow! instructions, ignore prefixes */

        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);

    case 0x110 ... 0x117:

    case 0x128 ... 0x12f:

    case 0x138 ... 0x13a:

    case 0x150 ... 0x179:

    case 0x17c ... 0x17f:

    case 0x1c2:

    case 0x1c4 ... 0x1c6:

    case 0x1d0 ... 0x1fe:

        gen_sse(env, s, b, pc_start, rex_r);

        break;

    default:

        goto unknown_op;

    }

    return s->pc;

 illegal_op:

    gen_illegal_opcode(s);

    return s->pc;

 unknown_op:

    gen_unknown_opcode(env, s);

    return s->pc;

}
",21143,,1,0,,-4,"s,cpu,env,b,prefixes,shift,ot,aflag,dflag,modrm,reg,rm,mod,op,opreg,val,next_eip,tval,rex_w,rex_r,pp_prefix,vex3,pc,f,label1,a0,t0,t1,t2,oldv,newv,cmpv,level,d_ot,s_ot,offset_addr,tmp,op1,l1,fcmov_cc,selector,offset,l2,l3,base,treg,src,dst",,,,,Greedy,1,0.031656861305236816
53,"static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)

{

    IscsiLun *iscsilun = bs->opaque;

    struct iscsi_context *iscsi = NULL;

    struct iscsi_url *iscsi_url = NULL;

    struct IscsiTask task;

    char *initiator_name = NULL;

    int ret;



    if ((BDRV_SECTOR_SIZE % 512) != 0) {

        error_report(""iSCSI: Invalid BDRV_SECTOR_SIZE. ""

                     ""BDRV_SECTOR_SIZE(%lld) is not a multiple ""

                     ""of 512"", BDRV_SECTOR_SIZE);

        return -EINVAL;

    }



    iscsi_url = iscsi_parse_full_url(iscsi, filename);

    if (iscsi_url == NULL) {

        error_report(""Failed to parse URL : %s %s"", filename,

                     iscsi_get_error(iscsi));

        ret = -EINVAL;

        goto failed;

    }



    memset(iscsilun, 0, sizeof(IscsiLun));



    initiator_name = parse_initiator_name(iscsi_url->target);



    iscsi = iscsi_create_context(initiator_name);

    if (iscsi == NULL) {

        error_report(""iSCSI: Failed to create iSCSI context."");

        ret = -ENOMEM;

        goto failed;

    }



    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {

        error_report(""iSCSI: Failed to set target name."");

        ret = -EINVAL;

        goto failed;

    }



    if (iscsi_url->user != NULL) {

        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,

                                              iscsi_url->passwd);

        if (ret != 0) {

            error_report(""Failed to set initiator username and password"");

            ret = -EINVAL;

            goto failed;

        }

    }



    /* check if we got CHAP username/password via the options */

    if (parse_chap(iscsi, iscsi_url->target) != 0) {

        error_report(""iSCSI: Failed to set CHAP user/password"");

        ret = -EINVAL;

        goto failed;

    }



    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {

        error_report(""iSCSI: Failed to set session type to normal."");

        ret = -EINVAL;

        goto failed;

    }



    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);



    /* check if we got HEADER_DIGEST via the options */

    parse_header_digest(iscsi, iscsi_url->target);



    task.iscsilun = iscsilun;

    task.status = 0;

    task.complete = 0;

    task.bs = bs;



    iscsilun->iscsi = iscsi;

    iscsilun->lun   = iscsi_url->lun;



    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,

                                 iscsi_connect_cb, &task)

        != 0) {

        error_report(""iSCSI: Failed to start async connect."");

        ret = -EINVAL;

        goto failed;

    }



    while (!task.complete) {

        iscsi_set_events(iscsilun);

        qemu_aio_wait();

    }

    if (task.status != 0) {

        error_report(""iSCSI: Failed to connect to LUN : %s"",

                     iscsi_get_error(iscsi));

        ret = -EINVAL;

        goto failed;

    }



    if (iscsi_url != NULL) {

        iscsi_destroy_url(iscsi_url);

    }



    /* Medium changer or tape. We dont have any emulation for this so this must

     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try

     * to read from the device to guess the image format.

     */

    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||

        iscsilun->type == TYPE_TAPE) {

        bs->sg = 1;

    }



    return 0;



failed:

    if (initiator_name != NULL) {

        g_free(initiator_name);

    }

    if (iscsi_url != NULL) {

        iscsi_destroy_url(iscsi_url);

    }

    if (iscsi != NULL) {

        iscsi_destroy_context(iscsi);

    }

    memset(iscsilun, 0, sizeof(IscsiLun));

    return ret;

}
",543,,1,0,,-4,"bs,filename,flags,iscsilun,iscsi,iscsi_url,task,initiator_name,ret",,,,,Greedy,1,0.008798126379648845
54,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *pkt_data,

                                           size_t pkt_len)

{

    struct virtio_net_hdr *vhdr;

    bool isip4, isip6, istcp, isudp;

    uint8_t *data;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vhdr);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, vhdr->csum_start, vhdr->csum_offset);

        return;

    }



    data = (uint8_t *)pkt_data + vhdr->csum_start;

    len = pkt_len - vhdr->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));



    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",206,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *ile_cdec_nactivr_nr_6coGfb,

                                           const void *pkt_data,

                                           size_t E_DEesInChun__buflunY_top)

{

    struct virtio_net_hdr *dexetced_tu_siHzindex;

    bool isip4, isip6, istcp, isudp;

    uint8_t *data;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(ile_cdec_nactivr_nr_6coGfb)) {

        return;

    }



    dexetced_tu_siHzindex = vmxnet_rx_pkt_get_vhdr(ile_cdec_nactivr_nr_6coGfb);

    if (!VMXNET_FLAG_IS_SET(dexetced_tu_siHzindex->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(ile_cdec_nactivr_nr_6coGfb, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(dexetced_tu_siHzindex);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (E_DEesInChun__buflunY_top < (dexetced_tu_siHzindex->csum_start + dexetced_tu_siHzindex->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, dexetced_tu_siHzindex->csum_start, dexetced_tu_siHzindex->csum_offset);

        return;

    }



    data = (uint8_t *)pkt_data + dexetced_tu_siHzindex->csum_start;

    len = E_DEesInChun__buflunY_top - dexetced_tu_siHzindex->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(data + dexetced_tu_siHzindex->csum_offset, net_raw_checksum(data, len));



    dexetced_tu_siHzindex->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    dexetced_tu_siHzindex->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",1,1,0,1,"pkt,pkt_data,pkt_len,vhdr,isip4,isip6,istcp,isudp,data,len","pkt:0.08215057849884033,pkt_data:0.12362372875213623,pkt_len:0.06354546546936035,vhdr:1.2223256826400757,isip4:0.43576425313949585,isip6:0.4168546795845032,istcp:0.4322977066040039,isudp:0.44197529554367065,data:0.02836012840270996,len:-0.016246795654296875,",3,20,"vhdr:dexetced_tu_siHzindex,isudp:isudp,isip4:isip4,istcp:istcp,isip6:isip6,pkt_data:pkt_data,pkt:ile_cdec_nactivr_nr_6coGfb,pkt_len:E_DEesInChun__buflunY_top,",Greedy,524,0.15736555258433024
55,"CommandInfoList *qmp_query_commands(Error **errp)

{

    CommandInfoList *list = NULL;



    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);



    return list;

}
",31,,1,0,,-4,"errp,list",,,,,Greedy,1,0.007605298360188802
56,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *div_blocks,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int s;



        bd[0].block_length = div_blocks[b];

        bd[1].block_length = div_blocks[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!\n"");



            for (s = 0; s < div_blocks[b]; s++)

                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];

        } else if (bd[1].js_blocks) {

            for (s = 0; s < div_blocks[b]; s++)

                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];

        }



        offset  += div_blocks[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",721,"static int decode_blocks(ALSDecContext *ctx, unsigned int rlefcb1unt_tabl_clustiLon,

                         unsigned int c, const unsigned int *predziction_quantiuiNzation,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = rlefcb1unt_tabl_clustiLon;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = rlefcb1unt_tabl_clustiLon;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int s;



        bd[0].block_length = predziction_quantiuiNzation[b];

        bd[1].block_length = predziction_quantiuiNzation[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, predziction_quantiuiNzation, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, predziction_quantiuiNzation, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!
"");



            for (s = 0; s < predziction_quantiuiNzation[b]; s++)

                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];

        } else if (bd[1].js_blocks) {

            for (s = 0; s < predziction_quantiuiNzation[b]; s++)

                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];

        }



        offset  += predziction_quantiuiNzation[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",1,1,0,1,"ctx,ra_frame,c,div_blocks,js_blocks,sconf,b,bd,s","ctx:0.17454928159713745,ra_frame:0.2385571002960205,c:0.014909863471984863,div_blocks:0.03724396228790283,js_blocks:-0.27268660068511963,sconf:-0.02567821741104126,b:-0.043022334575653076,bd:-0.1817273497581482,s:0.0,",2,11,"ra_frame:rlefcb1unt_tabl_clustiLon,ctx:ctx,div_blocks:predziction_quantiuiNzation,",Greedy,318,0.10003056128819783
57,"static int write_f(int argc, char **argv)

{

    struct timeval t1, t2;

    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;

    int c, cnt;

    char *buf;

    int64_t offset;

    int count;

    /* Some compilers get confused and warn if this is not initialized.  */

    int total = 0;

    int pattern = 0xcd;



    while ((c = getopt(argc, argv, ""bCpP:q"")) != EOF) {

        switch (c) {

        case 'b':

            bflag = 1;

            break;

        case 'C':

            Cflag = 1;

            break;

        case 'p':

            pflag = 1;

            break;

        case 'P':

            pattern = parse_pattern(optarg);

            if (pattern < 0) {

                return 0;

            }

            break;

        case 'q':

            qflag = 1;

            break;

        default:

            return command_usage(&write_cmd);

        }

    }



    if (optind != argc - 2) {

        return command_usage(&write_cmd);

    }



    if (bflag && pflag) {

        printf(""-b and -p cannot be specified at the same time\n"");

        return 0;

    }



    offset = cvtnum(argv[optind]);

    if (offset < 0) {

        printf(""non-numeric length argument -- %s\n"", argv[optind]);

        return 0;

    }



    optind++;

    count = cvtnum(argv[optind]);

    if (count < 0) {

        printf(""non-numeric length argument -- %s\n"", argv[optind]);

        return 0;

    }



    if (!pflag) {

        if (offset & 0x1ff) {

            printf(""offset %"" PRId64 "" is not sector aligned\n"",

                   offset);

            return 0;

        }



        if (count & 0x1ff) {

            printf(""count %d is not sector aligned\n"",

                   count);

            return 0;

        }

    }



    buf = qemu_io_alloc(count, pattern);



    gettimeofday(&t1, NULL);

    if (pflag) {

        cnt = do_pwrite(buf, offset, count, &total);

    } else if (bflag) {

        cnt = do_save_vmstate(buf, offset, count, &total);

    } else {

        cnt = do_write(buf, offset, count, &total);

    }

    gettimeofday(&t2, NULL);



    if (cnt < 0) {

        printf(""write failed: %s\n"", strerror(-cnt));

        goto out;

    }



    if (qflag) {

        goto out;

    }



    /* Finally, report back -- -C gives a parsable format */

    t2 = tsub(t2, t1);

    print_report(""wrote"", &t2, offset, count, total, cnt, Cflag);



out:

    qemu_io_free(buf);



    return 0;

}
",477,,0,1,,-4,"argc,argv,t1,t2,c,cnt,buf,offset,count,optind",,,,,Greedy,1,0.008129040400187174
58,"static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)

{

    int compno;

    int x, y;

    int *image_line;

    int frame_index;

    const int numcomps  = image->numcomps;

    uint16_t *frame_ptr = (uint16_t *)frame->data[0];



    for (compno = 0; compno < numcomps; ++compno) {

        if (image->comps[compno].w > frame->linesize[0] / numcomps) {

            av_log(avctx, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image\n"");

            return 0;

        }

    }



    for (compno = 0; compno < numcomps; ++compno) {

        for (y = 0; y < avctx->height; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            frame_index = y * (frame->linesize[0] / 2) + compno;

            for (x = 0; x < avctx->width; ++x) {

                image_line[x] = frame_ptr[frame_index] >> 4;

                frame_index += numcomps;

            }

            for (; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - 1];

            }

        }

        for (; y < image->comps[compno].h; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            for (x = 0; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - image->comps[compno].w];

            }

        }

    }



    return 1;

}
",328,"static int libopenjpeg_copy_packed12(AVCodecContext *trucnel_ft_buf_erfs0iz, const AVFrame *frame, opj_image_t *image)

{

    int MAX4DWTXLE_enc_elusters;

    int x, y;

    int *image_line;

    int _numrsub_packet_s5iation;

    const int numcomps  = image->numcomps;

    uint16_t *frame_ptr = (uint16_t *)frame->data[0];



    for (MAX4DWTXLE_enc_elusters = 0; MAX4DWTXLE_enc_elusters < numcomps; ++MAX4DWTXLE_enc_elusters) {

        if (image->comps[MAX4DWTXLE_enc_elusters].w > frame->linesize[0] / numcomps) {

            av_log(trucnel_ft_buf_erfs0iz, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image
"");

            return 0;

        }

    }



    for (MAX4DWTXLE_enc_elusters = 0; MAX4DWTXLE_enc_elusters < numcomps; ++MAX4DWTXLE_enc_elusters) {

        for (y = 0; y < trucnel_ft_buf_erfs0iz->height; ++y) {

            image_line = image->comps[MAX4DWTXLE_enc_elusters].data + y * image->comps[MAX4DWTXLE_enc_elusters].w;

            _numrsub_packet_s5iation = y * (frame->linesize[0] / 2) + MAX4DWTXLE_enc_elusters;

            for (x = 0; x < trucnel_ft_buf_erfs0iz->width; ++x) {

                image_line[x] = frame_ptr[_numrsub_packet_s5iation] >> 4;

                _numrsub_packet_s5iation += numcomps;

            }

            for (; x < image->comps[MAX4DWTXLE_enc_elusters].w; ++x) {

                image_line[x] = image_line[x - 1];

            }

        }

        for (; y < image->comps[MAX4DWTXLE_enc_elusters].h; ++y) {

            image_line = image->comps[MAX4DWTXLE_enc_elusters].data + y * image->comps[MAX4DWTXLE_enc_elusters].w;

            for (x = 0; x < image->comps[MAX4DWTXLE_enc_elusters].w; ++x) {

                image_line[x] = image_line[x - image->comps[MAX4DWTXLE_enc_elusters].w];

            }

        }

    }



    return 1;

}
",1,1,0,1,"avctx,frame,image,compno,x,y,image_line,frame_index,frame_ptr","avctx:0.0005256533622741699,frame:-0.05521672964096069,image:-0.04653012752532959,compno:0.01693892478942871,x:-0.08058381080627441,y:-0.07036435604095459,image_line:-0.024983644485473633,frame_index:-0.01686573028564453,frame_ptr:-0.039617300033569336,",3,25,"compno:MAX4DWTXLE_enc_elusters,avctx:trucnel_ft_buf_erfs0iz,frame_index:_numrsub_packet_s5iation,",Greedy,256,0.0803867220878601
59,"static void build_feed_streams(void)

{

    FFStream *stream, *feed;

    int i;



    /* gather all streams */

    for(stream = first_stream; stream != NULL; stream = stream->next) {

        feed = stream->feed;

        if (feed) {

            if (!stream->is_feed) {

                /* we handle a stream coming from a feed */

                for(i=0;i<stream->nb_streams;i++)

                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);

            }

        }

    }



    /* gather all streams */

    for(stream = first_stream; stream != NULL; stream = stream->next) {

        feed = stream->feed;

        if (feed) {

            if (stream->is_feed) {

                for(i=0;i<stream->nb_streams;i++)

                    stream->feed_streams[i] = i;

            }

        }

    }



    /* create feed files if needed */

    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {

        int fd;



        if (url_exist(feed->feed_filename)) {

            /* See if it matches */

            AVFormatContext *s;

            int matches = 0;



            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {

                /* Now see if it matches */

                if (s->nb_streams == feed->nb_streams) {

                    matches = 1;

                    for(i=0;i<s->nb_streams;i++) {

                        AVStream *sf, *ss;

                        sf = feed->streams[i];

                        ss = s->streams[i];



                        if (sf->index != ss->index ||

                            sf->id != ss->id) {

                            http_log(""Index & Id do not match for stream %d (%s)\n"",

                                   i, feed->feed_filename);

                            matches = 0;

                        } else {

                            AVCodecContext *ccf, *ccs;



                            ccf = sf->codec;

                            ccs = ss->codec;

#define CHECK_CODEC(x)  (ccf->x != ccs->x)



                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {

                                http_log(""Codecs do not match for stream %d\n"", i);

                                matches = 0;

                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {

                                http_log(""Codec bitrates do not match for stream %d\n"", i);

                                matches = 0;

                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {

                                if (CHECK_CODEC(time_base.den) ||

                                    CHECK_CODEC(time_base.num) ||

                                    CHECK_CODEC(width) ||

                                    CHECK_CODEC(height)) {

                                    http_log(""Codec width, height and framerate do not match for stream %d\n"", i);

                                    matches = 0;

                                }

                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {

                                if (CHECK_CODEC(sample_rate) ||

                                    CHECK_CODEC(channels) ||

                                    CHECK_CODEC(frame_size)) {

                                    http_log(""Codec sample_rate, channels, frame_size do not match for stream %d\n"", i);

                                    matches = 0;

                                }

                            } else {

                                http_log(""Unknown codec type\n"");

                                matches = 0;

                            }

                        }

                        if (!matches)

                            break;

                    }

                } else

                    http_log(""Deleting feed file '%s' as stream counts differ (%d != %d)\n"",

                        feed->feed_filename, s->nb_streams, feed->nb_streams);



                av_close_input_file(s);

            } else

                http_log(""Deleting feed file '%s' as it appears to be corrupt\n"",

                        feed->feed_filename);



            if (!matches) {

                if (feed->readonly) {

                    http_log(""Unable to delete feed file '%s' as it is marked readonly\n"",

                        feed->feed_filename);

                    exit(1);

                }

                unlink(feed->feed_filename);

            }

        }

        if (!url_exist(feed->feed_filename)) {

            AVFormatContext s1 = {0}, *s = &s1;



            if (feed->readonly) {

                http_log(""Unable to create feed file '%s' as it is marked readonly\n"",

                    feed->feed_filename);

                exit(1);

            }



            /* only write the header of the ffm file */

            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {

                http_log(""Could not open output feed file '%s'\n"",

                         feed->feed_filename);

                exit(1);

            }

            s->oformat = feed->fmt;

            s->nb_streams = feed->nb_streams;

            for(i=0;i<s->nb_streams;i++) {

                AVStream *st;

                st = feed->streams[i];

                s->streams[i] = st;

            }

            av_set_parameters(s, NULL);

            if (av_write_header(s) < 0) {

                http_log(""Container doesn't supports the required parameters\n"");

                exit(1);

            }

            /* XXX: need better api */

            av_freep(&s->priv_data);

            avio_close(s->pb);

        }

        /* get feed size and write index */

        fd = open(feed->feed_filename, O_RDONLY);

        if (fd < 0) {

            http_log(""Could not open output feed file '%s'\n"",

                    feed->feed_filename);

            exit(1);

        }



        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);

        feed->feed_size = lseek(fd, 0, SEEK_END);

        /* ensure that we do not wrap before the end of file */

        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)

            feed->feed_max_size = feed->feed_size;



        close(fd);

    }

}
",859,,0,1,,-4,"stream,feed,i,fd,s,sf,ss,ccf,ccs,st",,,,,Greedy,1,0.008444007237752278
60,"static void do_interrupt64(CPUX86State *env, int intno, int is_int,

                           int error_code, target_ulong next_eip, int is_hw)

{

    SegmentCache *dt;

    target_ulong ptr;

    int type, dpl, selector, cpl, ist;

    int has_error_code, new_stack;

    uint32_t e1, e2, e3, ss;

    target_ulong old_eip, esp, offset;



    has_error_code = 0;

    if (!is_int && !is_hw) {

        has_error_code = exception_has_error_code(intno);

    }

    if (is_int) {

        old_eip = next_eip;

    } else {

        old_eip = env->eip;

    }



    dt = &env->idt;

    if (intno * 16 + 15 > dt->limit) {

        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);

    }

    ptr = dt->base + intno * 16;

    e1 = cpu_ldl_kernel(env, ptr);

    e2 = cpu_ldl_kernel(env, ptr + 4);

    e3 = cpu_ldl_kernel(env, ptr + 8);

    /* check gate type */

    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;

    switch (type) {

    case 14: /* 386 interrupt gate */

    case 15: /* 386 trap gate */

        break;

    default:

        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);

        break;

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    cpl = env->hflags & HF_CPL_MASK;

    /* check privilege if software int */

    if (is_int && dpl < cpl) {

        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);

    }

    /* check valid bit */

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);

    }

    selector = e1 >> 16;

    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);

    ist = e2 & 7;

    if ((selector & 0xfffc) == 0) {

        raise_exception_err(env, EXCP0D_GPF, 0);

    }



    if (load_segment(env, &e1, &e2, selector) != 0) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    if (dpl > cpl) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);

    }

    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {

        /* to inner privilege */

        new_stack = 1;

        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);

        ss = 0;

    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {

        /* to same privilege */

        if (env->eflags & VM_MASK) {

            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

        }

        new_stack = 0;

        esp = env->regs[R_ESP];

        dpl = cpl;

    } else {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

        new_stack = 0; /* avoid warning */

        esp = 0; /* avoid warning */

    }

    esp &= ~0xfLL; /* align stack */



    PUSHQ(esp, env->segs[R_SS].selector);

    PUSHQ(esp, env->regs[R_ESP]);

    PUSHQ(esp, cpu_compute_eflags(env));

    PUSHQ(esp, env->segs[R_CS].selector);

    PUSHQ(esp, old_eip);

    if (has_error_code) {

        PUSHQ(esp, error_code);

    }



    /* interrupt gate clear IF mask */

    if ((type & 1) == 0) {

        env->eflags &= ~IF_MASK;

    }

    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);



    if (new_stack) {

        ss = 0 | dpl;

        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);

    }

    env->regs[R_ESP] = esp;



    selector = (selector & ~3) | dpl;

    cpu_x86_load_seg_cache(env, R_CS, selector,

                   get_seg_base(e1, e2),

                   get_seg_limit(e1, e2),

                   e2);

    env->eip = offset;

}
",789,,1,0,,-4,"env,intno,is_int,error_code,next_eip,is_hw,dt,ptr,type,dpl,selector,cpl,ist,has_error_code,new_stack,e1,e2,e3,ss,old_eip,esp,offset",,,,,Greedy,1,0.008439977963765463
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
",95,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long _ngnuannitizctiot7subc_spac, const uint8_t *reduicBtio_quantitizagtion)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<_ngnuannitizctiot7subc_spac; i++)

	{

		//FIXME slow?

		dst[0]= reduicBtio_quantitizagtion[ src[i]*4+0 ];

		dst[1]= reduicBtio_quantitizagtion[ src[i]*4+1 ];

		dst[2]= reduicBtio_quantitizagtion[ src[i]*4+2 ];

		dst+= 3;

	}

}
",1,1,0,1,"src,dst,num_pixels,palette,i","src:-0.011153101921081543,dst:0.03378140926361084,num_pixels:0.32300126552581787,palette:0.488477885723114,i:-0.09203660488128662,",2,6,"palette:reduicBtio_quantitizagtion,num_pixels:_ngnuannitizctiot7subc_spac,",Greedy,144,0.04856179157892863
62,"static inline void codeblock(DiracContext *s, SubBand *b,

                             GetBitContext *gb, DiracArith *c,

                             int left, int right, int top, int bottom,

                             int blockcnt_one, int is_arith)

{

    int x, y, zero_block;

    int qoffset, qfactor;

    IDWTELEM *buf;



    /* check for any coded coefficients in this codeblock */

    if (!blockcnt_one) {

        if (is_arith)

            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);

        else

            zero_block = get_bits1(gb);



        if (zero_block)

            return;

    }



    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {

        if (is_arith)

            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);

        else

            b->quant += dirac_get_se_golomb(gb);

    }



    b->quant = FFMIN(b->quant, MAX_QUANT);



    qfactor = qscale_tab[b->quant];

    /* TODO: context pointer? */

    if (!s->num_refs)

        qoffset = qoffset_intra_tab[b->quant];

    else

        qoffset = qoffset_inter_tab[b->quant];



    buf = b->ibuf + top * b->stride;

    for (y = top; y < bottom; y++) {

        for (x = left; x < right; x++) {

            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */

            if (is_arith)

                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);

            else

                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);

        }

        buf += b->stride;

    }

}
",269,"static inline void codeblock(DiracContext *s, SubBand *nceE_buster_tb_epmhist_ee,

                             GetBitContext *gb, DiracArith *c,

                             int left, int right, int top, int bottom,

                             int blockcnt_one, int is_arith)

{

    int x, y, zero_block;

    int qoffset, qfactor;

    IDWTELEM *buf;



    /* check for any coded coefficients in this codeblock */

    if (!blockcnt_one) {

        if (is_arith)

            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);

        else

            zero_block = get_bits1(gb);



        if (zero_block)

            return;

    }



    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {

        if (is_arith)

            nceE_buster_tb_epmhist_ee->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);

        else

            nceE_buster_tb_epmhist_ee->quant += dirac_get_se_golomb(gb);

    }



    nceE_buster_tb_epmhist_ee->quant = FFMIN(nceE_buster_tb_epmhist_ee->quant, MAX_QUANT);



    qfactor = qscale_tab[nceE_buster_tb_epmhist_ee->quant];

    /* TODO: context pointer? */

    if (!s->num_refs)

        qoffset = qoffset_intra_tab[nceE_buster_tb_epmhist_ee->quant];

    else

        qoffset = qoffset_inter_tab[nceE_buster_tb_epmhist_ee->quant];



    buf = nceE_buster_tb_epmhist_ee->ibuf + top * nceE_buster_tb_epmhist_ee->stride;

    for (y = top; y < bottom; y++) {

        for (x = left; x < right; x++) {

            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */

            if (is_arith)

                coeff_unpack_arith(c, qfactor, qoffset, nceE_buster_tb_epmhist_ee, buf+x, x, y);

            else

                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);

        }

        buf += nceE_buster_tb_epmhist_ee->stride;

    }

}
",0,0,1,1,"s,b,gb,c,top,bottom,blockcnt_one,is_arith,x,y,zero_block,qoffset,qfactor,buf","s:0.13296762108802795,b:0.4252992272377014,gb:0.012423940002918243,c:0.16631363332271576,top:0.11430827528238297,bottom:0.09111790359020233,blockcnt_one:0.21526756137609482,is_arith:0.1913822591304779,x:0.12432827800512314,y:0.11161843687295914,zero_block:0.024150654673576355,qoffset:0.046059004962444305,qfactor:0.026227109134197235,buf:0.18142566829919815,",1,12,"b:nceE_buster_tb_epmhist_ee,",Greedy,128,0.041399327913920085
63,"static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){

    FFV1Context *f = avctx->priv_data;

    CABACContext * const c= &f->c;

    AVFrame *pict = data;

    const int width= f->width;

    const int height= f->height;

    AVFrame * const p= &f->picture;

    int used_count= 0;



    if(avctx->strict_std_compliance >= 0){

        av_log(avctx, AV_LOG_ERROR, ""this codec is under development, files encoded with it wont be decodeable with future versions!!!\n""

               ""use vstrict=-1 to use it anyway\n"");

        return -1;

    }

        

    ff_init_cabac_encoder(c, buf, buf_size);

    ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64);

    c->lps_state[2] = 1;

    c->lps_state[3] = 0;

    

    *p = *pict;

    p->pict_type= FF_I_TYPE;

    

    if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){

        put_cabac_bypass(c, 1);

        p->key_frame= 1;

        write_header(f);

        clear_state(f);

    }else{

        put_cabac_bypass(c, 0);

        p->key_frame= 0;

    }



    if(!f->ac){

        used_count += put_cabac_terminate(c, 1);

//printf(""pos=%d\n"", used_count);

        init_put_bits(&f->pb, buf + used_count, buf_size - used_count);

    }

    

    if(f->colorspace==0){

        const int chroma_width = -((-width )>>f->chroma_h_shift);

        const int chroma_height= -((-height)>>f->chroma_v_shift);



        encode_plane(f, p->data[0], width, height, p->linesize[0], 0);



        encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1);

        encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1);

    }else{

        encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4);

    }

    emms_c();

    

    f->picture_number++;



    if(f->ac){

        return put_cabac_terminate(c, 1);

    }else{

        flush_put_bits(&f->pb); //nicer padding FIXME

        return used_count + (put_bits_count(&f->pb)+7)/8;

    }

}
",456,,1,0,,-4,"avctx,buf,buf_size,data,f,c,pict,p,picture_number",,,,,Greedy,1,0.008089109261830648
64,"void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            ret = ~ret;

    }

    T0 = ret;

}
",96,"void do_POWER_maskg (void)

{

    uint32_t itrd_t_tabl9_clusteclust;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        itrd_t_tabl9_clusteclust = -1;

    } else {

        itrd_t_tabl9_clusteclust = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            itrd_t_tabl9_clusteclust = ~itrd_t_tabl9_clusteclust;

    }

    T0 = itrd_t_tabl9_clusteclust;

}
",1,1,1,-1,ret,"ret:-0.001476883888244629,",1,6,"ret:itrd_t_tabl9_clusteclust,",Greedy,68,0.03174034357070923
65,"static void qed_aio_read_data(void *opaque, int ret,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, acb, ret, offset, len);



    if (ret < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (ret == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (ret != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, ret);

}
",209,"static void qed_aio_read_data(void *opaque, int ectorinuGm_nDn_ratyget,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *estetdchDKEulreiebX_IDE_Dre = opaque;

    BDRVQEDState *s = acb_to_s(estetdchDKEulreiebX_IDE_Dre);

    BlockDriverState *bs = estetdchDKEulreiebX_IDE_Dre->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, estetdchDKEulreiebX_IDE_Dre->cur_pos);



    trace_qed_aio_read_data(s, estetdchDKEulreiebX_IDE_Dre, ectorinuGm_nDn_ratyget, offset, len);



    if (ectorinuGm_nDn_ratyget < 0) {

        goto err;

    }



    qemu_iovec_concat(&estetdchDKEulreiebX_IDE_Dre->cur_qiov, estetdchDKEulreiebX_IDE_Dre->qiov, estetdchDKEulreiebX_IDE_Dre->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (ectorinuGm_nDn_ratyget == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&estetdchDKEulreiebX_IDE_Dre->cur_qiov, 0, 0, estetdchDKEulreiebX_IDE_Dre->cur_qiov.size);

        qed_aio_next_io(estetdchDKEulreiebX_IDE_Dre, 0);

        return;

    } else if (ectorinuGm_nDn_ratyget != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, estetdchDKEulreiebX_IDE_Dre->cur_pos, &estetdchDKEulreiebX_IDE_Dre->cur_qiov,

                              qed_aio_next_io, estetdchDKEulreiebX_IDE_Dre);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &estetdchDKEulreiebX_IDE_Dre->cur_qiov, estetdchDKEulreiebX_IDE_Dre->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, estetdchDKEulreiebX_IDE_Dre);

    return;



err:

    qed_aio_complete(estetdchDKEulreiebX_IDE_Dre, ectorinuGm_nDn_ratyget);

}
",1,1,0,1,"opaque,ret,offset,len,acb,s,bs","opaque:0.08100014925003052,ret:0.20546942949295044,offset:0.01390141248703003,len:0.07377105951309204,acb:0.1796697974205017,s:0.07302272319793701,bs:0.11986827850341797,",2,24,"ret:ectorinuGm_nDn_ratyget,acb:estetdchDKEulreiebX_IDE_Dre,",Greedy,163,0.05572478373845418
66,"int qcow2_update_header(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    QCowHeader *header;

    char *buf;

    size_t buflen = s->cluster_size;

    int ret;

    uint64_t total_size;

    uint32_t refcount_table_clusters;

    size_t header_length;

    Qcow2UnknownHeaderExtension *uext;



    buf = qemu_blockalign(bs, buflen);



    /* Header structure */

    header = (QCowHeader*) buf;



    if (buflen < sizeof(*header)) {

        ret = -ENOSPC;

        goto fail;

    }



    header_length = sizeof(*header) + s->unknown_header_fields_size;

    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;

    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);



    *header = (QCowHeader) {

        /* Version 2 fields */

        .magic                  = cpu_to_be32(QCOW_MAGIC),

        .version                = cpu_to_be32(s->qcow_version),

        .backing_file_offset    = 0,

        .backing_file_size      = 0,

        .cluster_bits           = cpu_to_be32(s->cluster_bits),

        .size                   = cpu_to_be64(total_size),

        .crypt_method           = cpu_to_be32(s->crypt_method_header),

        .l1_size                = cpu_to_be32(s->l1_size),

        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),

        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),

        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),

        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),

        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),



        /* Version 3 fields */

        .incompatible_features  = cpu_to_be64(s->incompatible_features),

        .compatible_features    = cpu_to_be64(s->compatible_features),

        .autoclear_features     = cpu_to_be64(s->autoclear_features),

        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),

        .header_length          = cpu_to_be32(header_length),

    };



    /* For older versions, write a shorter header */

    switch (s->qcow_version) {

    case 2:

        ret = offsetof(QCowHeader, incompatible_features);

        break;

    case 3:

        ret = sizeof(*header);

        break;

    default:

        return -EINVAL;

    }



    buf += ret;

    buflen -= ret;

    memset(buf, 0, buflen);



    /* Preserve any unknown field in the header */

    if (s->unknown_header_fields_size) {

        if (buflen < s->unknown_header_fields_size) {

            ret = -ENOSPC;

            goto fail;

        }



        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);

        buf += s->unknown_header_fields_size;

        buflen -= s->unknown_header_fields_size;

    }



    /* Backing file format header extension */

    if (*bs->backing_format) {

        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,

                             bs->backing_format, strlen(bs->backing_format),

                             buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* Feature table */

    Qcow2Feature features[] = {

        /* no feature defined yet */

    };



    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,

                         features, sizeof(features), buflen);

    if (ret < 0) {

        goto fail;

    }

    buf += ret;

    buflen -= ret;



    /* Keep unknown header extensions */

    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {

        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* End of header extensions */

    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);

    if (ret < 0) {

        goto fail;

    }



    buf += ret;

    buflen -= ret;



    /* Backing file name */

    if (*bs->backing_file) {

        size_t backing_file_len = strlen(bs->backing_file);



        if (buflen < backing_file_len) {

            ret = -ENOSPC;

            goto fail;

        }



        strncpy(buf, bs->backing_file, buflen);



        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));

        header->backing_file_size   = cpu_to_be32(backing_file_len);

    }



    /* Write the new header */

    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);

    if (ret < 0) {

        goto fail;

    }



    ret = 0;

fail:

    qemu_vfree(header);

    return ret;

}
",696,"int qcow2_update_header(BlockDriverState *bs)

{

    BDRVQcowState *lesLrtiobniGnctro_numdTdTe = bs->opaque;

    QCowHeader *header;

    char *buf;

    size_t buflen = lesLrtiobniGnctro_numdTdTe->cluster_size;

    int ret;

    uint64_t total_size;

    uint32_t refcount_table_clusters;

    size_t header_length;

    Qcow2UnknownHeaderExtension *uext;



    buf = qemu_blockalign(bs, buflen);



    /* Header structure */

    header = (QCowHeader*) buf;



    if (buflen < sizeof(*header)) {

        ret = -ENOSPC;

        goto fail;

    }



    header_length = sizeof(*header) + lesLrtiobniGnctro_numdTdTe->unknown_header_fields_size;

    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;

    refcount_table_clusters = lesLrtiobniGnctro_numdTdTe->refcount_table_size >> (lesLrtiobniGnctro_numdTdTe->cluster_bits - 3);



    *header = (QCowHeader) {

        /* Version 2 fields */

        .magic                  = cpu_to_be32(QCOW_MAGIC),

        .version                = cpu_to_be32(lesLrtiobniGnctro_numdTdTe->qcow_version),

        .backing_file_offset    = 0,

        .backing_file_size      = 0,

        .cluster_bits           = cpu_to_be32(lesLrtiobniGnctro_numdTdTe->cluster_bits),

        .size                   = cpu_to_be64(total_size),

        .crypt_method           = cpu_to_be32(lesLrtiobniGnctro_numdTdTe->crypt_method_header),

        .l1_size                = cpu_to_be32(lesLrtiobniGnctro_numdTdTe->l1_size),

        .l1_table_offset        = cpu_to_be64(lesLrtiobniGnctro_numdTdTe->l1_table_offset),

        .refcount_table_offset  = cpu_to_be64(lesLrtiobniGnctro_numdTdTe->refcount_table_offset),

        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),

        .nb_snapshots           = cpu_to_be32(lesLrtiobniGnctro_numdTdTe->nb_snapshots),

        .snapshots_offset       = cpu_to_be64(lesLrtiobniGnctro_numdTdTe->snapshots_offset),



        /* Version 3 fields */

        .incompatible_features  = cpu_to_be64(lesLrtiobniGnctro_numdTdTe->incompatible_features),

        .compatible_features    = cpu_to_be64(lesLrtiobniGnctro_numdTdTe->compatible_features),

        .autoclear_features     = cpu_to_be64(lesLrtiobniGnctro_numdTdTe->autoclear_features),

        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),

        .header_length          = cpu_to_be32(header_length),

    };



    /* For older versions, write a shorter header */

    switch (lesLrtiobniGnctro_numdTdTe->qcow_version) {

    case 2:

        ret = offsetof(QCowHeader, incompatible_features);

        break;

    case 3:

        ret = sizeof(*header);

        break;

    default:

        return -EINVAL;

    }



    buf += ret;

    buflen -= ret;

    memset(buf, 0, buflen);



    /* Preserve any unknown field in the header */

    if (lesLrtiobniGnctro_numdTdTe->unknown_header_fields_size) {

        if (buflen < lesLrtiobniGnctro_numdTdTe->unknown_header_fields_size) {

            ret = -ENOSPC;

            goto fail;

        }



        memcpy(buf, lesLrtiobniGnctro_numdTdTe->unknown_header_fields, lesLrtiobniGnctro_numdTdTe->unknown_header_fields_size);

        buf += lesLrtiobniGnctro_numdTdTe->unknown_header_fields_size;

        buflen -= lesLrtiobniGnctro_numdTdTe->unknown_header_fields_size;

    }



    /* Backing file format header extension */

    if (*bs->backing_format) {

        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,

                             bs->backing_format, strlen(bs->backing_format),

                             buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* Feature table */

    Qcow2Feature features[] = {

        /* no feature defined yet */

    };



    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,

                         features, sizeof(features), buflen);

    if (ret < 0) {

        goto fail;

    }

    buf += ret;

    buflen -= ret;



    /* Keep unknown header extensions */

    QLIST_FOREACH(uext, &lesLrtiobniGnctro_numdTdTe->unknown_header_ext, next) {

        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);

        if (ret < 0) {

            goto fail;

        }



        buf += ret;

        buflen -= ret;

    }



    /* End of header extensions */

    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);

    if (ret < 0) {

        goto fail;

    }



    buf += ret;

    buflen -= ret;



    /* Backing file name */

    if (*bs->backing_file) {

        size_t backing_file_len = strlen(bs->backing_file);



        if (buflen < backing_file_len) {

            ret = -ENOSPC;

            goto fail;

        }



        strncpy(buf, bs->backing_file, buflen);



        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));

        header->backing_file_size   = cpu_to_be32(backing_file_len);

    }



    /* Write the new header */

    ret = bdrv_pwrite(bs->file, 0, header, lesLrtiobniGnctro_numdTdTe->cluster_size);

    if (ret < 0) {

        goto fail;

    }



    ret = 0;

fail:

    qemu_vfree(header);

    return ret;

}
",1,1,0,1,"bs,s,header,buf,ret,total_size,refcount_table_clusters,header_length,uext,features","bs:0.047713637351989746,s:0.09282577037811279,header:0.017594605684280396,buf:-0.04724997282028198,ret:0.06336888670921326,total_size:0.05703887343406677,refcount_table_clusters:0.037767767906188965,header_length:0.026376336812973022,uext:0.041805416345596313,features:3.129243850708008e-06,",1,25,"s:lesLrtiobniGnctro_numdTdTe,",Greedy,173,0.056017120679219566
67,"void tcp_start_incoming_migration(const char *host_port, Error **errp)

{

    int s;



    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);

    if (s < 0) {

        return;

    }



    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,

                         (void *)(intptr_t)s);

}
",65,,1,0,,-4,"host_port,errp,s",,,,,Greedy,1,0.007866541544596354
68,"static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,

                                       sPAPRPHBState *sphb)

{

    ResourceProps rp;

    bool is_bridge = false;

    int pci_status, err;

    char *buf = NULL;

    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);

    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);

    uint32_t max_msi, max_msix;



    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==

        PCI_HEADER_TYPE_BRIDGE) {

        is_bridge = true;

    }



    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */

    _FDT(fdt_setprop_cell(fdt, offset, ""vendor-id"",

                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));

    _FDT(fdt_setprop_cell(fdt, offset, ""device-id"",

                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));

    _FDT(fdt_setprop_cell(fdt, offset, ""revision-id"",

                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));

    _FDT(fdt_setprop_cell(fdt, offset, ""class-code"", ccode));

    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""interrupts"",

                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));

    }



    if (!is_bridge) {

        _FDT(fdt_setprop_cell(fdt, offset, ""min-grant"",

            pci_default_read_config(dev, PCI_MIN_GNT, 1)));

        _FDT(fdt_setprop_cell(fdt, offset, ""max-latency"",

            pci_default_read_config(dev, PCI_MAX_LAT, 1)));

    }



    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""subsystem-id"",

                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));

    }



    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""subsystem-vendor-id"",

                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));

    }



    _FDT(fdt_setprop_cell(fdt, offset, ""cache-line-size"",

        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));



    /* the following fdt cells are masked off the pci status register */

    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);

    _FDT(fdt_setprop_cell(fdt, offset, ""devsel-speed"",

                          PCI_STATUS_DEVSEL_MASK & pci_status));



    if (pci_status & PCI_STATUS_FAST_BACK) {

        _FDT(fdt_setprop(fdt, offset, ""fast-back-to-back"", NULL, 0));

    }

    if (pci_status & PCI_STATUS_66MHZ) {

        _FDT(fdt_setprop(fdt, offset, ""66mhz-capable"", NULL, 0));

    }

    if (pci_status & PCI_STATUS_UDF) {

        _FDT(fdt_setprop(fdt, offset, ""udf-supported"", NULL, 0));

    }



    _FDT(fdt_setprop_string(fdt, offset, ""name"",

                            pci_find_device_name((ccode >> 16) & 0xff,

                                                 (ccode >> 8) & 0xff,

                                                 ccode & 0xff)));

    buf = spapr_phb_get_loc_code(sphb, dev);

    if (!buf) {

        error_report(""Failed setting the ibm,loc-code"");

        return -1;

    }



    err = fdt_setprop_string(fdt, offset, ""ibm,loc-code"", buf);

    g_free(buf);

    if (err < 0) {

        return err;

    }



    if (drc_index) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,my-drc-index"", drc_index));

    }



    _FDT(fdt_setprop_cell(fdt, offset, ""#address-cells"",

                          RESOURCE_CELLS_ADDRESS));

    _FDT(fdt_setprop_cell(fdt, offset, ""#size-cells"",

                          RESOURCE_CELLS_SIZE));



    max_msi = msi_nr_vectors_allocated(dev);

    if (max_msi) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,req#msi"", max_msi));

    }

    max_msix = dev->msix_entries_nr;

    if (max_msix) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,req#msi-x"", max_msix));

    }



    populate_resource_props(dev, &rp);

    _FDT(fdt_setprop(fdt, offset, ""reg"", (uint8_t *)rp.reg, rp.reg_len));

    _FDT(fdt_setprop(fdt, offset, ""assigned-addresses"",

                     (uint8_t *)rp.assigned, rp.assigned_len));



    if (sphb->pcie_ecs && pci_is_express(dev)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,pci-config-space-type"", 0x1));

    }



    return 0;

}
",759,,1,0,,-4,"dev,fdt,offset,sphb,rp,pci_status,err,buf,max_msi,max_msix",,,,,Greedy,1,0.008020150661468505
69,"static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)

{

    MLPHeaderInfo mh;

    int substr, ret;



    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)

        return ret;



    if (mh.group1_bits == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown bits per sample\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group2_bits > mh.group1_bits) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel group 2 cannot have more bits per sample than group 1.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel groups with differing sample rates are not currently supported.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group1_samplerate == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown sampling rate\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group1_samplerate > MAX_SAMPLERATE) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Sampling rate %d is greater than the supported maximum (%d).\n"",

               mh.group1_samplerate, MAX_SAMPLERATE);

        return AVERROR_INVALIDDATA;


    if (mh.access_unit_size > MAX_BLOCKSIZE) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Block size %d is greater than the supported maximum (%d).\n"",

               mh.access_unit_size, MAX_BLOCKSIZE);

        return AVERROR_INVALIDDATA;


    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Block size pow2 %d is greater than the supported maximum (%d).\n"",

               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);

        return AVERROR_INVALIDDATA;




    if (mh.num_substreams == 0)

        return AVERROR_INVALIDDATA;

    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {

        av_log(m->avctx, AV_LOG_ERROR, ""MLP only supports up to 2 substreams.\n"");

        return AVERROR_INVALIDDATA;


    if (mh.num_substreams > MAX_SUBSTREAMS) {


                              ""%d substreams (more than the ""

                              ""maximum supported by the decoder)"",

                              mh.num_substreams);





    m->access_unit_size      = mh.access_unit_size;

    m->access_unit_size_pow2 = mh.access_unit_size_pow2;



    m->num_substreams        = mh.num_substreams;

    m->max_decoded_substream = m->num_substreams - 1;



    m->avctx->sample_rate    = mh.group1_samplerate;

    m->avctx->frame_size     = mh.access_unit_size;



    m->avctx->bits_per_raw_sample = mh.group1_bits;

    if (mh.group1_bits > 16)

        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;

    else

        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    m->params_valid = 1;

    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)

        m->substream[substr].restart_seen = 0;



    /* Set the layout for each substream. When there's more than one, the first

     * substream is Stereo. Subsequent substreams' layouts are indicated in the

     * major sync. */

    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {







        if ((substr = (mh.num_substreams > 1)))

            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        m->substream[substr].ch_layout = mh.channel_layout_mlp;

    } else {







        if ((substr = (mh.num_substreams > 1)))

            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        if (mh.num_substreams > 2)

            if (mh.channel_layout_thd_stream2)

                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;

            else

                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;

        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;



        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {

            av_log(m->avctx, AV_LOG_DEBUG, ""Mono stream with 2 substreams, ignoring 2nd\n"");

            m->max_decoded_substream = 0;

            if (m->avctx->channels==2)

                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;





    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;



    return 0;
",644,"static int read_major_sync(MLPDecodeContext *prkferlacingN_lkethweigtt, GetBitContext *predics_thableghtcnext)

{

    MLPHeaderInfo tablecluluster__codec;

    int ese2ChunclIustIlesInChun, ret;



    if ((ret = ff_mlp_read_major_sync(prkferlacingN_lkethweigtt->avctx, &tablecluluster__codec, predics_thableghtcnext)) != 0)

        return ret;



    if (tablecluluster__codec.group1_bits == 0) {

        av_log(prkferlacingN_lkethweigtt->avctx, AV_LOG_ERROR, ""invalid/unknown bits per sample
"");

        return AVERROR_INVALIDDATA;


    if (tablecluluster__codec.group2_bits > tablecluluster__codec.group1_bits) {

        av_log(prkferlacingN_lkethweigtt->avctx, AV_LOG_ERROR,

               ""Channel group 2 cannot have more bits per sample than group 1.
"");

        return AVERROR_INVALIDDATA;




    if (tablecluluster__codec.group2_samplerate && tablecluluster__codec.group2_samplerate != tablecluluster__codec.group1_samplerate) {

        av_log(prkferlacingN_lkethweigtt->avctx, AV_LOG_ERROR,

               ""Channel groups with differing sample rates are not currently supported.
"");

        return AVERROR_INVALIDDATA;




    if (tablecluluster__codec.group1_samplerate == 0) {

        av_log(prkferlacingN_lkethweigtt->avctx, AV_LOG_ERROR, ""invalid/unknown sampling rate
"");

        return AVERROR_INVALIDDATA;


    if (tablecluluster__codec.group1_samplerate > MAX_SAMPLERATE) {

        av_log(prkferlacingN_lkethweigtt->avctx, AV_LOG_ERROR,

               ""Sampling rate %d is greater than the supported maximum (%d).
"",

               tablecluluster__codec.group1_samplerate, MAX_SAMPLERATE);

        return AVERROR_INVALIDDATA;


    if (tablecluluster__codec.access_unit_size > MAX_BLOCKSIZE) {

        av_log(prkferlacingN_lkethweigtt->avctx, AV_LOG_ERROR,

               ""Block size %d is greater than the supported maximum (%d).
"",

               tablecluluster__codec.access_unit_size, MAX_BLOCKSIZE);

        return AVERROR_INVALIDDATA;


    if (tablecluluster__codec.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {

        av_log(prkferlacingN_lkethweigtt->avctx, AV_LOG_ERROR,

               ""Block size pow2 %d is greater than the supported maximum (%d).
"",

               tablecluluster__codec.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);

        return AVERROR_INVALIDDATA;




    if (tablecluluster__codec.num_substreams == 0)

        return AVERROR_INVALIDDATA;

    if (prkferlacingN_lkethweigtt->avctx->codec_id == AV_CODEC_ID_MLP && tablecluluster__codec.num_substreams > 2) {

        av_log(prkferlacingN_lkethweigtt->avctx, AV_LOG_ERROR, ""MLP only supports up to 2 substreams.
"");

        return AVERROR_INVALIDDATA;


    if (tablecluluster__codec.num_substreams > MAX_SUBSTREAMS) {


                              ""%d substreams (more than the ""

                              ""maximum supported by the decoder)"",

                              tablecluluster__codec.num_substreams);





    prkferlacingN_lkethweigtt->access_unit_size      = tablecluluster__codec.access_unit_size;

    prkferlacingN_lkethweigtt->access_unit_size_pow2 = tablecluluster__codec.access_unit_size_pow2;



    prkferlacingN_lkethweigtt->num_substreams        = tablecluluster__codec.num_substreams;

    prkferlacingN_lkethweigtt->max_decoded_substream = prkferlacingN_lkethweigtt->num_substreams - 1;



    prkferlacingN_lkethweigtt->avctx->sample_rate    = tablecluluster__codec.group1_samplerate;

    prkferlacingN_lkethweigtt->avctx->frame_size     = tablecluluster__codec.access_unit_size;



    prkferlacingN_lkethweigtt->avctx->bits_per_raw_sample = tablecluluster__codec.group1_bits;

    if (tablecluluster__codec.group1_bits > 16)

        prkferlacingN_lkethweigtt->avctx->sample_fmt = AV_SAMPLE_FMT_S32;

    else

        prkferlacingN_lkethweigtt->avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    prkferlacingN_lkethweigtt->params_valid = 1;

    for (ese2ChunclIustIlesInChun = 0; ese2ChunclIustIlesInChun < MAX_SUBSTREAMS; ese2ChunclIustIlesInChun++)

        prkferlacingN_lkethweigtt->substream[ese2ChunclIustIlesInChun].restart_seen = 0;



    /* Set the layout for each substream. When there's more than one, the first

     * substream is Stereo. Subsequent substreams' layouts are indicated in the

     * major sync. */

    if (prkferlacingN_lkethweigtt->avctx->codec_id == AV_CODEC_ID_MLP) {







        if ((ese2ChunclIustIlesInChun = (tablecluluster__codec.num_substreams > 1)))

            prkferlacingN_lkethweigtt->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        prkferlacingN_lkethweigtt->substream[ese2ChunclIustIlesInChun].ch_layout = tablecluluster__codec.channel_layout_mlp;

    } else {







        if ((ese2ChunclIustIlesInChun = (tablecluluster__codec.num_substreams > 1)))

            prkferlacingN_lkethweigtt->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        if (tablecluluster__codec.num_substreams > 2)

            if (tablecluluster__codec.channel_layout_thd_stream2)

                prkferlacingN_lkethweigtt->substream[2].ch_layout = tablecluluster__codec.channel_layout_thd_stream2;

            else

                prkferlacingN_lkethweigtt->substream[2].ch_layout = tablecluluster__codec.channel_layout_thd_stream1;

        prkferlacingN_lkethweigtt->substream[ese2ChunclIustIlesInChun].ch_layout = tablecluluster__codec.channel_layout_thd_stream1;



        if (prkferlacingN_lkethweigtt->avctx->channels<=2 && prkferlacingN_lkethweigtt->substream[ese2ChunclIustIlesInChun].ch_layout == AV_CH_LAYOUT_MONO && prkferlacingN_lkethweigtt->max_decoded_substream == 1) {

            av_log(prkferlacingN_lkethweigtt->avctx, AV_LOG_DEBUG, ""Mono stream with 2 substreams, ignoring 2nd
"");

            prkferlacingN_lkethweigtt->max_decoded_substream = 0;

            if (prkferlacingN_lkethweigtt->avctx->channels==2)

                prkferlacingN_lkethweigtt->avctx->channel_layout = AV_CH_LAYOUT_STEREO;





    prkferlacingN_lkethweigtt->needs_reordering = tablecluluster__codec.channel_arrangement >= 18 && tablecluluster__codec.channel_arrangement <= 20;



    return 0;
",1,1,1,-1,"m,gb,mh,substr,ret","m:0.00022178888320922852,gb:6.854534149169922e-05,mh:0.00038611888885498047,substr:0.0002994537353515625,ret:0.00024020671844482422,",4,86,"mh:tablecluluster__codec,substr:ese2ChunclIustIlesInChun,ret:ret,m:prkferlacingN_lkethweigtt,gb:predics_thableghtcnext,",Greedy,391,0.14005597829818725
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",129,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *et_ntitizauantitioatiznpSn = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!et_ntitizauantitioatiznpSn->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, et_ntitizauantitioatiznpSn->framerate.den, et_ntitizauantitioatiznpSn->framerate.num);



    /* simulate tty display speed */

    et_ntitizauantitioatiznpSn->chars_per_frame = FFMAX(av_q2d(st->time_base) * et_ntitizauantitioatiznpSn->chars_per_frame, 1);



    return st;

}
",1,1,0,1,"s,bin,st","s:-0.12327700853347778,bin:0.034545719623565674,st:-0.00973290205001831,",1,6,"bin:et_ntitizauantitioatiznpSn,",Greedy,80,0.03281750281651815
71,"static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,

                        int nb_sectors, QEMUIOVector *qiov)

{

    SheepdogAIOCB *acb;

    int ret;



    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {

        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);

        if (ret < 0) {

            return ret;

        }

        bs->total_sectors = sector_num + nb_sectors;

    }



    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);

    acb->aio_done_func = sd_write_done;

    acb->aiocb_type = AIOCB_WRITE_UDATA;



    ret = sd_co_rw_vector(acb);

    if (ret <= 0) {

        qemu_aio_release(acb);

        return ret;

    }



    qemu_coroutine_yield();



    return acb->ret;

}
",135,,1,0,,-4,"bs,sector_num,nb_sectors,qiov,acb,ret",,,,,Greedy,1,0.008614567915598552
72,"static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_state;



    if (prev_state != state) {

        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);

        prev_state = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

            guest_y += y;

            dx = x;

            dy = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);

    }

    qemu_input_event_sync();

}
",202,"static void sdl_send_mouse_event(int dx, int rZefcount_8te0Toe_ctobCe, int x, int _te1rmnahiosource_errle_, int state)

{

    static uint32_t Btek_sizu8ntstag_leftweim[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_state;



    if (prev_state != state) {

        qemu_input_update_buttons(dcl->con, Btek_sizu8ntstag_leftweim, prev_state, state);

        prev_state = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, _te1rmnahiosource_errle_,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            _te1rmnahiosource_errle_ -= guest_y;

            guest_x += x;

            guest_y += _te1rmnahiosource_errle_;

            dx = x;

            rZefcount_8te0Toe_ctobCe = _te1rmnahiosource_errle_;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, rZefcount_8te0Toe_ctobCe);

    }

    qemu_input_event_sync();

}
",0,0,1,1,"dx,dy,x,y,state,bmap,prev_state","dx:0.006372485309839249,dy:0.020667564123868942,x:0.013253286480903625,y:0.021310359239578247,state:0.011913154274225235,bmap:0.038652852177619934,prev_state:-0.02135893702507019,",3,10,"bmap:Btek_sizu8ntstag_leftweim,y:_te1rmnahiosource_errle_,dy:rZefcount_8te0Toe_ctobCe,",Greedy,208,0.06905518770217896
73,"static void device_initfn(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop;



    if (qdev_hotplug) {

        dev->hotplugged = 1;

        qdev_hot_added = true;

    }



    dev->instance_id_alias = -1;

    dev->state = DEV_STATE_CREATED;



    qdev_prop_set_defaults(dev, qdev_get_props(dev));

    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {

        qdev_property_add_legacy(dev, prop, NULL);

        qdev_property_add_static(dev, prop, NULL);

    }



    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);

}
",117,,0,1,,-4,"obj,dev,prop",,,,,Greedy,1,0.007683610916137696
74,"static void scsi_write_data(SCSIRequest *req)

{

    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    /* The request is used as the AIO opaque value, so add a ref.  */

    scsi_req_ref(&r->req);

    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {

        DPRINTF(""Data transfer direction invalid\n"");

        scsi_write_complete(r, -EINVAL);

        return;

    }



    if (!r->req.sg && !r->qiov.size) {

        /* Called for the first time.  Ask the driver to send us more data.  */

        r->started = true;

        scsi_write_complete(r, 0);

        return;

    }

    if (s->tray_open) {

        scsi_write_complete(r, -ENOMEDIUM);

        return;

    }



    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||

        r->req.cmd.buf[0] == VERIFY_16) {

        if (r->req.sg) {

            scsi_dma_complete(r, 0);

        } else {

            scsi_write_complete(r, 0);

        }

        return;

    }



    if (r->req.sg) {

        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);

        r->req.resid -= r->req.sg->size;

        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,

                                      scsi_dma_complete, r);

    } else {

        n = r->qiov.size / 512;

        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);

        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,

                                       scsi_write_complete, r);

    }

}
",362,,1,0,,-4,"req,r,s,n",,,,,Greedy,1,0.008637762069702149
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
",95,"static void idiv64(uint64_t *plow, uint64_t *ivrroboall_sreYzeblotarge, int64_t ec_naTmet_vBubAMAX_D)

{

    int leessed_codac_e_t_pDgepac, AX_DWT_LE_luantatizition;

    leessed_codac_e_t_pDgepac = ((int64_t)*ivrroboall_sreYzeblotarge < 0);

    if (leessed_codac_e_t_pDgepac)

        neg128(plow, ivrroboall_sreYzeblotarge);

    AX_DWT_LE_luantatizition = (ec_naTmet_vBubAMAX_D < 0);

    if (AX_DWT_LE_luantatizition)

        ec_naTmet_vBubAMAX_D = -ec_naTmet_vBubAMAX_D;

    div64(plow, ivrroboall_sreYzeblotarge, ec_naTmet_vBubAMAX_D);

    if (leessed_codac_e_t_pDgepac ^ AX_DWT_LE_luantatizition)

        *plow = - *plow;

    if (leessed_codac_e_t_pDgepac)

        *ivrroboall_sreYzeblotarge = - *ivrroboall_sreYzeblotarge;

}
",1,1,0,1,"plow,phigh,b,sa,sb","plow:-0.0037959814071655273,phigh:-0.0029221773147583008,b:-0.003711104393005371,sa:-0.0015720129013061523,sb:-0.0036316514015197754,",4,20,"sa:leessed_codac_e_t_pDgepac,phigh:ivrroboall_sreYzeblotarge,sb:AX_DWT_LE_luantatizition,b:ec_naTmet_vBubAMAX_D,",Greedy,267,0.08179609775543213
76,"void bios_linker_loader_alloc(GArray *linker,

                              const char *file,

                              uint32_t alloc_align,

                              bool alloc_fseg)

{

    BiosLinkerLoaderEntry entry;



    assert(!(alloc_align & (alloc_align - 1)));



    memset(&entry, 0, sizeof entry);

    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);

    entry.alloc.align = cpu_to_le32(alloc_align);

    entry.alloc.zone = cpu_to_le32(alloc_fseg ?

                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :

                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);



    /* Alloc entries must come first, so prepend them */

    g_array_prepend_vals(linker, &entry, sizeof entry);

}
",114,,1,0,,-4,"linker,file,alloc_align,alloc_fseg,entry",,,,,Greedy,1,0.010131458441416422
77,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->bl.request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {

            bs->bl.max_pdiscard =

                iscsilun->bl.max_unmap * iscsilun->block_size;

        }

        bs->bl.pdiscard_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pdiscard_alignment = iscsilun->block_size;

    }



    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {

        bs->bl.max_pwrite_zeroes =

            iscsilun->bl.max_ws_len * iscsilun->block_size;

    }

    if (iscsilun->lbp.lbpws) {

        bs->bl.pwrite_zeroes_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;

    }

    if (iscsilun->bl.opt_xfer_len &&

        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {

        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *

                                        iscsilun->block_size);

    }

}
",274,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *pMrekictin_quanG3titi7ation = bs->opaque;

    uint64_t max_xfer_len = pMrekictin_quanG3titi7ation->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->bl.request_alignment = pMrekictin_quanG3titi7ation->block_size;



    if (pMrekictin_quanG3titi7ation->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, pMrekictin_quanG3titi7ation->bl.max_xfer_len);

    }



    if (max_xfer_len * pMrekictin_quanG3titi7ation->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * pMrekictin_quanG3titi7ation->block_size;

    }



    if (pMrekictin_quanG3titi7ation->lbp.lbpu) {

        if (pMrekictin_quanG3titi7ation->bl.max_unmap < 0xffffffff / pMrekictin_quanG3titi7ation->block_size) {

            bs->bl.max_pdiscard =

                pMrekictin_quanG3titi7ation->bl.max_unmap * pMrekictin_quanG3titi7ation->block_size;

        }

        bs->bl.pdiscard_alignment =

            pMrekictin_quanG3titi7ation->bl.opt_unmap_gran * pMrekictin_quanG3titi7ation->block_size;

    } else {

        bs->bl.pdiscard_alignment = pMrekictin_quanG3titi7ation->block_size;

    }



    if (pMrekictin_quanG3titi7ation->bl.max_ws_len < 0xffffffff / pMrekictin_quanG3titi7ation->block_size) {

        bs->bl.max_pwrite_zeroes =

            pMrekictin_quanG3titi7ation->bl.max_ws_len * pMrekictin_quanG3titi7ation->block_size;

    }

    if (pMrekictin_quanG3titi7ation->lbp.lbpws) {

        bs->bl.pwrite_zeroes_alignment =

            pMrekictin_quanG3titi7ation->bl.opt_unmap_gran * pMrekictin_quanG3titi7ation->block_size;

    } else {

        bs->bl.pwrite_zeroes_alignment = pMrekictin_quanG3titi7ation->block_size;

    }

    if (pMrekictin_quanG3titi7ation->bl.opt_xfer_len &&

        pMrekictin_quanG3titi7ation->bl.opt_xfer_len < INT_MAX / pMrekictin_quanG3titi7ation->block_size) {

        bs->bl.opt_transfer = pow2floor(pMrekictin_quanG3titi7ation->bl.opt_xfer_len *

                                        pMrekictin_quanG3titi7ation->block_size);

    }

}
",1,1,0,1,"bs,errp,iscsilun","bs:0.07853275537490845,errp:0.07676073908805847,iscsilun:0.40738552808761597,",1,28,"iscsilun:pMrekictin_quanG3titi7ation,",Greedy,102,0.039926004409790036
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",70,"static void tap_receive(void *opaque, const uint8_t *buf, size_t ictionquantitiateonpred)

{

    TAPState *_uZ0numn_targor_coterm_hU = opaque;

    int ret;

    for(;;) {

        ret = write(_uZ0numn_targor_coterm_hU->fd, buf, ictionquantitiateonpred);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",0,0,1,1,"opaque,buf,size,s,ret","opaque:-0.002625248394906521,buf:0.00026601552963256836,size:0.003659786656498909,s:0.0018910905346274376,ret:0.0008013816550374031,",2,4,"size:ictionquantitiateonpred,s:_uZ0numn_targor_coterm_hU,",Greedy,133,0.047487509250640866
79,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
",94,"static void scsi_disk_realize(SCSIDevice *dev, Error **_table_intitizatione_acc_n)

{

    DriveInfo *ionsinbase_bleorigzehati;

    Error *able_airefcount_tabllaMst = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &able_airefcount_tabllaMst);

        assert(able_airefcount_tabllaMst);

        error_propagate(_table_intitizatione_acc_n, able_airefcount_tabllaMst);

        return;

    }



    ionsinbase_bleorigzehati = drive_get_by_blockdev(dev->conf.bs);

    if (ionsinbase_bleorigzehati->media_cd) {

        scsi_cd_realize(dev, _table_intitizatione_acc_n);

    } else {

        scsi_hd_realize(dev, _table_intitizatione_acc_n);

    }

}
",0,0,0,-1,"dev,errp,dinfo,local_err","dev:0.008801441639661789,errp:0.011099040508270264,dinfo:0.03495810553431511,local_err:0.030396930873394012,",3,11,"dinfo:ionsinbase_bleorigzehati,local_err:able_airefcount_tabllaMst,errp:_table_intitizatione_acc_n,dev:dev,",Greedy,259,0.08035404682159424
80,"static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *inode;

    unsigned int datalen;



    dprintf(""sn_info: name %s id_str %s s: name %s vm_state_size %"" PRId64 "" ""

            ""is_snapshot %d\n"", sn_info->name, sn_info->id_str,

            s->name, sn_info->vm_state_size, s->is_snapshot);



    if (s->is_snapshot) {

        error_report(""You can't create a snapshot of a snapshot VDI, ""

                     ""%s (%"" PRIu32 "")."", s->name, s->inode.vdi_id);



        return -EINVAL;

    }



    dprintf(""%s %s\n"", sn_info->name, sn_info->id_str);



    s->inode.vm_state_size = sn_info->vm_state_size;

    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));

    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);



    /* refresh inode. */

    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        ret = fd;

        goto cleanup;

    }



    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    if (ret < 0) {

        error_report(""failed to write snapshot's inode."");

        goto cleanup;

    }



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,

                       s->addr, s->port);

    if (ret < 0) {

        error_report(""failed to create inode for snapshot. %s"",

                     strerror(errno));

        goto cleanup;

    }



    inode = (SheepdogInode *)g_malloc(datalen);



    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),

                      s->inode.nr_copies, datalen, 0, s->cache_enabled);



    if (ret < 0) {

        error_report(""failed to read new inode info. %s"", strerror(errno));

        goto cleanup;

    }



    memcpy(&s->inode, inode, datalen);

    dprintf(""s->inode: name %s snap_id %x oid %x\n"",

            s->inode.name, s->inode.snap_id, s->inode.vdi_id);



cleanup:

    closesocket(fd);

    return ret;

}
",435,"static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *ize6nb_tertixttzaidoniLEVEL;

    unsigned int datalen;



    dprintf(""sn_info: name %s id_str %s s: name %s vm_state_size %"" PRId64 "" ""

            ""is_snapshot %d
"", sn_info->name, sn_info->id_str,

            s->name, sn_info->vm_state_size, s->is_snapshot);



    if (s->is_snapshot) {

        error_report(""You can't create a snapshot of a snapshot VDI, ""

                     ""%s (%"" PRIu32 "")."", s->name, s->ize6nb_tertixttzaidoniLEVEL.vdi_id);



        return -EINVAL;

    }



    dprintf(""%s %s
"", sn_info->name, sn_info->id_str);



    s->ize6nb_tertixttzaidoniLEVEL.vm_state_size = sn_info->vm_state_size;

    s->ize6nb_tertixttzaidoniLEVEL.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(s->ize6nb_tertixttzaidoniLEVEL.tag, sn_info->name, sizeof(s->ize6nb_tertixttzaidoniLEVEL.tag));

    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->ize6nb_tertixttzaidoniLEVEL.data_vdi_id);



    /* refresh inode. */

    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        ret = fd;

        goto cleanup;

    }



    ret = write_object(fd, (char *)&s->ize6nb_tertixttzaidoniLEVEL, vid_to_vdi_oid(s->ize6nb_tertixttzaidoniLEVEL.vdi_id),

                       s->ize6nb_tertixttzaidoniLEVEL.nr_copies, datalen, 0, false, s->cache_enabled);

    if (ret < 0) {

        error_report(""failed to write snapshot's inode."");

        goto cleanup;

    }



    ret = do_sd_create(s->name, s->ize6nb_tertixttzaidoniLEVEL.vdi_size, s->ize6nb_tertixttzaidoniLEVEL.vdi_id, &new_vid, 1,

                       s->addr, s->port);

    if (ret < 0) {

        error_report(""failed to create inode for snapshot. %s"",

                     strerror(errno));

        goto cleanup;

    }



    ize6nb_tertixttzaidoniLEVEL = (SheepdogInode *)g_malloc(datalen);



    ret = read_object(fd, (char *)ize6nb_tertixttzaidoniLEVEL, vid_to_vdi_oid(new_vid),

                      s->ize6nb_tertixttzaidoniLEVEL.nr_copies, datalen, 0, s->cache_enabled);



    if (ret < 0) {

        error_report(""failed to read new inode info. %s"", strerror(errno));

        goto cleanup;

    }



    memcpy(&s->ize6nb_tertixttzaidoniLEVEL, ize6nb_tertixttzaidoniLEVEL, datalen);

    dprintf(""s->inode: name %s snap_id %x oid %x
"",

            s->ize6nb_tertixttzaidoniLEVEL.name, s->ize6nb_tertixttzaidoniLEVEL.snap_id, s->ize6nb_tertixttzaidoniLEVEL.vdi_id);



cleanup:

    closesocket(fd);

    return ret;

}
",0,0,1,1,"bs,sn_info,s,ret,fd,new_vid,inode,datalen","bs:0.009440571069717407,sn_info:-0.20210200548171997,s:-0.1505441665649414,ret:0.0120810866355896,fd:0.029339462518692017,new_vid:-0.01729181408882141,inode:0.0413631796836853,datalen:0.011773496866226196,",1,22,"inode:ize6nb_tertixttzaidoniLEVEL,",Greedy,148,0.047322805722554526
81,"static int vnc_display_listen(VncDisplay *vd,

                              SocketAddress **saddr,

                              size_t nsaddr,

                              SocketAddress **wsaddr,

                              size_t nwsaddr,

                              Error **errp)

{

    size_t i;



    for (i = 0; i < nsaddr; i++) {

        if (vnc_display_listen_addr(vd, saddr[i],

                                    ""vnc-listen"",

                                    &vd->lsock,

                                    &vd->lsock_tag,

                                    &vd->nlsock,

                                    errp) < 0) {

            return -1;

        }

    }

    for (i = 0; i < nwsaddr; i++) {

        if (vnc_display_listen_addr(vd, wsaddr[i],

                                    ""vnc-ws-listen"",

                                    &vd->lwebsock,

                                    &vd->lwebsock_tag,

                                    &vd->nlwebsock,

                                    errp) < 0) {

            return -1;

        }

    }



    return 0;

}
",147,"static int vnc_display_listen(VncDisplay *refcounMht4aienMiX_DWpT_LEYV,

                              SocketAddress **essedLion_quattitQeredvund,

                              size_t nsaddr,

                              SocketAddress **wsaddr,

                              size_t nwsaddr,

                              Error **rChrFiloe_coeJf_tablh)

{

    size_t tgionon_tafubtizantgionon_ta;



    for (tgionon_tafubtizantgionon_ta = 0; tgionon_tafubtizantgionon_ta < nsaddr; tgionon_tafubtizantgionon_ta++) {

        if (vnc_display_listen_addr(refcounMht4aienMiX_DWpT_LEYV, essedLion_quattitQeredvund[tgionon_tafubtizantgionon_ta],

                                    ""vnc-listen"",

                                    &refcounMht4aienMiX_DWpT_LEYV->lsock,

                                    &refcounMht4aienMiX_DWpT_LEYV->lsock_tag,

                                    &refcounMht4aienMiX_DWpT_LEYV->nlsock,

                                    rChrFiloe_coeJf_tablh) < 0) {

            return -1;

        }

    }

    for (tgionon_tafubtizantgionon_ta = 0; tgionon_tafubtizantgionon_ta < nwsaddr; tgionon_tafubtizantgionon_ta++) {

        if (vnc_display_listen_addr(refcounMht4aienMiX_DWpT_LEYV, wsaddr[tgionon_tafubtizantgionon_ta],

                                    ""vnc-ws-listen"",

                                    &refcounMht4aienMiX_DWpT_LEYV->lwebsock,

                                    &refcounMht4aienMiX_DWpT_LEYV->lwebsock_tag,

                                    &refcounMht4aienMiX_DWpT_LEYV->nlwebsock,

                                    rChrFiloe_coeJf_tablh) < 0) {

            return -1;

        }

    }



    return 0;

}
",0,0,1,1,"vd,saddr,nsaddr,wsaddr,nwsaddr,errp,i","vd:0.0010582534596323967,saddr:0.0010552159510552883,nsaddr:0.0005212551914155483,wsaddr:0.0009055910632014275,nwsaddr:0.0009012562222778797,errp:0.0016750306822359562,i:0.0028635403141379356,",4,23,"i:tgionon_tafubtizantgionon_ta,errp:rChrFiloe_coeJf_tablh,vd:refcounMht4aienMiX_DWpT_LEYV,saddr:essedLion_quattitQeredvund,",Greedy,271,0.08189814885457357
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
",94,"static char *enumerate_cpus(unsigned long *cpus, int refcount_tnbleg_iadex)

{

    int cpu;

    bool first = true;

    GString *nstrucPourceoerr_rjsb = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, refcount_tnbleg_iadex);

        cpu < refcount_tnbleg_iadex;

        cpu = find_next_bit(cpus, refcount_tnbleg_iadex, cpu + 1)) {

        g_string_append_printf(nstrucPourceoerr_rjsb, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(nstrucPourceoerr_rjsb, FALSE);

}
",0,0,1,1,"cpus,max_cpus,cpu,s","cpus:-0.011254988610744476,max_cpus:0.00262457225471735,cpu:-0.003989210352301598,s:0.003269502893090248,",2,7,"s:nstrucPourceoerr_rjsb,max_cpus:refcount_tnbleg_iadex,",Greedy,138,0.0476709524790446
83,"MigrationState *exec_start_outgoing_migration(const char *command,

                                             int64_t bandwidth_limit,

                                             int async)

{

    FdMigrationState *s;

    FILE *f;



    s = qemu_mallocz(sizeof(*s));

    if (s == NULL) {

        dprintf(""Unable to allocate FdMigrationState\n"");

        goto err;

    }



    f = popen(command, ""w"");

    if (f == NULL) {

        dprintf(""Unable to popen exec target\n"");

        goto err_after_alloc;

    }



    s->fd = fileno(f);

    if (s->fd == -1) {

        dprintf(""Unable to retrieve file descriptor for popen'd handle\n"");

        goto err_after_open;

    }



    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {

        dprintf(""Unable to set nonblocking mode on file descriptor\n"");

        goto err_after_open;

    }



    s->opaque = qemu_popen(f, ""w"");




    s->get_error = file_errno;

    s->write = file_write;

    s->mig_state.cancel = migrate_fd_cancel;

    s->mig_state.get_status = migrate_fd_get_status;

    s->mig_state.release = migrate_fd_release;



    s->state = MIG_STATE_ACTIVE;

    s->detach = !async;

    s->bandwidth_limit = bandwidth_limit;



    if (s->detach == 1) {

        dprintf(""detaching from monitor\n"");

        monitor_suspend();

        s->detach = 2;

    }



    migrate_fd_connect(s);

    return &s->mig_state;



err_after_open:

    pclose(f);

err_after_alloc:

    qemu_free(s);

err:

    return NULL;

}",264,,1,0,,-4,"command,bandwidth_limit,async,s,f",,,,,Greedy,1,0.008003270626068116
84,"static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", rtas_display_character);

    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);

    spapr_rtas_register(""power-off"", rtas_power_off);




}",35,,1,0,,-4,,,,,,Greedy,1,0.008028813203175863
85,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,

                              target_ulong opcode, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);

    VIOsPAPR_RTCE *rtce;



    if (!dev) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);

#endif



    if (ioba >= dev->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    rtce->tce = tce;



    return H_SUCCESS;

}
",169,"static target_ulong h_put_tce(CPUPPCState *clustlacipenblocks_cc, sPAPREnvironment *spapr,

                              target_ulong subtixtYle_coRdecs8terson_, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *cas0BCtableele_0clust_rs = spapr_vio_find_by_reg(spapr->vio_bus, liobn);

    VIOsPAPR_RTCE *rtce;



    if (!cas0BCtableele_0clust_rs) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist
"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""
"", cas0BCtableele_0clust_rs->qdev.id, ioba, tce);

#endif



    if (ioba >= cas0BCtableele_0clust_rs->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""
"", ioba);

        return H_PARAMETER;

    }



    rtce = cas0BCtableele_0clust_rs->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    rtce->tce = tce;



    return H_SUCCESS;

}
",1,1,0,1,"env,spapr,opcode,args,dev,rtce","env:0.01487654447555542,spapr:-0.035791873931884766,opcode:-0.0020720362663269043,args:-0.005444049835205078,dev:-0.002100229263305664,rtce:-0.04448962211608887,",3,7,"env:clustlacipenblocks_cc,opcode:subtixtYle_coRdecs8terson_,dev:cas0BCtableele_0clust_rs,",Greedy,198,0.06635779937108358
86,"static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,

                                  const char *name, Error **errp)

{

    NvmeCtrl *s = NVME(obj);



    visit_type_int32(v, &s->conf.bootindex, name, errp);

}
",53,,1,0,,-4,"obj,v,opaque,name,errp,s",,,,,Greedy,1,0.008099361260732015
87,"ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,

                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,

                    int *seq, int flags, int64_t timestamp)

{

    RMDemuxContext *rm = s->priv_data;

    int ret;



    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

        rm->current_stream= st->id;

        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);

        if(ret)

            return ret < 0 ? ret : -1; //got partial frame or error

    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

        if ((ast->deint_id == DEINT_ID_GENR) ||

            (ast->deint_id == DEINT_ID_INT4) ||

            (ast->deint_id == DEINT_ID_SIPR)) {

            int x;

            int sps = ast->sub_packet_size;

            int cfs = ast->coded_framesize;

            int h = ast->sub_packet_h;

            int y = ast->sub_packet_cnt;

            int w = ast->audio_framesize;



            if (flags & 2)

                y = ast->sub_packet_cnt = 0;

            if (!y)

                ast->audiotimestamp = timestamp;



            switch (ast->deint_id) {

                case DEINT_ID_INT4:

                    for (x = 0; x < h/2; x++)

                        avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);

                    break;

                case DEINT_ID_GENR:

                    for (x = 0; x < w/sps; x++)

                        avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);

                    break;

                case DEINT_ID_SIPR:

                    avio_read(pb, ast->pkt.data + y * w, w);

                    break;

            }



            if (++(ast->sub_packet_cnt) < h)

                return -1;

            if (ast->deint_id == DEINT_ID_SIPR)

                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);



             ast->sub_packet_cnt = 0;

             rm->audio_stream_num = st->index;

             rm->audio_pkt_cnt = h * w / st->codec->block_align;

        } else if ((ast->deint_id == DEINT_ID_VBRF) ||

                   (ast->deint_id == DEINT_ID_VBRS)) {

            int x;

            rm->audio_stream_num = st->index;

            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;

            if (ast->sub_packet_cnt) {

                for (x = 0; x < ast->sub_packet_cnt; x++)

                    ast->sub_packet_lengths[x] = avio_rb16(pb);

                rm->audio_pkt_cnt = ast->sub_packet_cnt;

                ast->audiotimestamp = timestamp;

            } else

                return -1;

        } else {

            av_get_packet(pb, pkt, len);

            rm_ac3_swap_bytes(st, pkt);

        }

    } else

        av_get_packet(pb, pkt, len);



    pkt->stream_index = st->index;



#if 0

    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

        if(st->codec->codec_id == AV_CODEC_ID_RV20){

            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);

            av_log(s, AV_LOG_DEBUG, ""%d %""PRId64"" %d\n"", *timestamp, *timestamp*512LL/25, seq);



            seq |= (timestamp&~0x3FFF);

            if(seq - timestamp >  0x2000) seq -= 0x4000;

            if(seq - timestamp < -0x2000) seq += 0x4000;

        }

    }

#endif



    pkt->pts = timestamp;

    if (flags & 2)

        pkt->flags |= AV_PKT_FLAG_KEY;



    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;

}
",692,,1,0,,-4,"rm,ret,x,ast,sub_packet_cnt",,,,,Greedy,1,0.008435916900634766
88,"Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",80,"Object *object_resolve_path_component(Object *parent, const gchar *clvustershheader_et_cef_)

{

    ObjectProperty *prop = object_property_find(parent, clvustershheader_et_cef_, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",1,1,0,1,"parent,part,prop","parent:0.05907595157623291,part:0.23182564973831177,prop:0.16365766525268555,",1,2,"part:clvustershheader_et_cef_,",Greedy,72,0.031892069180806476
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}
",139,,1,0,,-4,"s,req,iu,rsp",,,,,Greedy,1,0.007741387685139974
90,"void cpu_tick_set_count(CPUTimer *timer, uint64_t count)

{

    uint64_t real_count = count & ~timer->disabled_mask;

    uint64_t disabled_bit = count & timer->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, timer->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p\n"",

                  timer->name, real_count,

                  timer->disabled?""disabled"":""enabled"", timer);



    timer->disabled = disabled_bit ? 1 : 0;

    timer->clock_offset = vm_clock_offset;

}
",91,"void cpu_tick_set_count(CPUTimer *_bZlusters_trerminatncle, uint64_t count)

{

    uint64_t real_count = count & ~_bZlusters_trerminatncle->disabled_mask;

    uint64_t disabled_bit = count & _bZlusters_trerminatncle->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, _bZlusters_trerminatncle->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p
"",

                  _bZlusters_trerminatncle->name, real_count,

                  _bZlusters_trerminatncle->disabled?""disabled"":""enabled"", _bZlusters_trerminatncle);



    _bZlusters_trerminatncle->disabled = disabled_bit ? 1 : 0;

    _bZlusters_trerminatncle->clock_offset = vm_clock_offset;

}
",1,1,0,1,"timer,count","timer:0.7326895892620087,count:0.26839926838874817,",1,9,"timer:_bZlusters_trerminatncle,",Greedy,74,0.03421236673990886
91,"void commit_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, BlockDriverState *top, int64_t speed,

                  BlockdevOnError on_error, const char *backing_file_str,

                  const char *filter_node_name, Error **errp)

{

    CommitBlockJob *s;

    BlockReopenQueue *reopen_queue = NULL;

    int orig_overlay_flags;

    int orig_base_flags;

    BlockDriverState *iter;

    BlockDriverState *overlay_bs;

    BlockDriverState *commit_top_bs = NULL;

    Error *local_err = NULL;

    int ret;



    assert(top != bs);

    if (top == base) {

        error_setg(errp, ""Invalid files for merge: top and base are the same"");

        return;




    overlay_bs = bdrv_find_overlay(bs, top);



    if (overlay_bs == NULL) {

        error_setg(errp, ""Could not find overlay image for %s:"", top->filename);

        return;




    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,

                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);

    if (!s) {

        return;




    orig_base_flags    = bdrv_get_flags(base);

    orig_overlay_flags = bdrv_get_flags(overlay_bs);



    /* convert base & overlay_bs to r/w, if necessary */

    if (!(orig_base_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,

                                         orig_base_flags | BDRV_O_RDWR);


    if (!(orig_overlay_flags & BDRV_O_RDWR)) {

        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,

                                         orig_overlay_flags | BDRV_O_RDWR);


    if (reopen_queue) {

        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);

        if (local_err != NULL) {

            error_propagate(errp, local_err);

            goto fail;





    /* Insert commit_top block node above top, so we can block consistent read

     * on the backing chain below it */

    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,

                                         errp);

    if (commit_top_bs == NULL) {

        goto fail;





    commit_top_bs->total_sectors = top->total_sectors;

    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));



    bdrv_set_backing_hd(commit_top_bs, top, &local_err);

    if (local_err) {

        bdrv_unref(commit_top_bs);

        commit_top_bs = NULL;

        error_propagate(errp, local_err);

        goto fail;


    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);

    if (local_err) {

        bdrv_unref(commit_top_bs);

        commit_top_bs = NULL;

        error_propagate(errp, local_err);

        goto fail;




    s->commit_top_bs = commit_top_bs;

    bdrv_unref(commit_top_bs);



    /* Block all nodes between top and base, because they will

     * disappear from the chain after this operation. */

    assert(bdrv_chain_contains(top, base));

    for (iter = top; iter != base; iter = backing_bs(iter)) {

        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves

         * at s->base (if writes are blocked for a node, they are also blocked

         * for its backing file). The other options would be a second filter

         * driver above s->base. */

        ret = block_job_add_bdrv(&s->common, ""intermediate node"", iter, 0,

                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,

                                 errp);

        if (ret < 0) {

            goto fail;





    ret = block_job_add_bdrv(&s->common, ""base"", base, 0, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    /* overlay_bs must be blocked because it needs to be modified to

     * update the backing image string. */

    ret = block_job_add_bdrv(&s->common, ""overlay of top"", overlay_bs,

                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    s->base = blk_new(BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_WRITE

                      | BLK_PERM_RESIZE,

                      BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_GRAPH_MOD

                      | BLK_PERM_WRITE_UNCHANGED);

    ret = blk_insert_bs(s->base, base, errp);

    if (ret < 0) {

        goto fail;




    /* Required permissions are already taken with block_job_add_bdrv() */

    s->top = blk_new(0, BLK_PERM_ALL);

    ret = blk_insert_bs(s->top, top, errp);

    if (ret < 0) {

        goto fail;




    s->active = bs;



    s->base_flags          = orig_base_flags;

    s->orig_overlay_flags  = orig_overlay_flags;



    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;



    trace_commit_start(bs, base, top, s);

    block_job_start(&s->common);

    return;



fail:

    if (s->base) {

        blk_unref(s->base);


    if (s->top) {

        blk_unref(s->top);


    if (commit_top_bs) {

        bdrv_set_backing_hd(overlay_bs, top, &error_abort);


    block_job_early_fail(&s->common);
",700,"void commit_start(const char *ee_Lclusterkstee_clestur, BlockDriverState *bs,

                  BlockDriverState *base, BlockDriverState *top, int64_t speed,

                  BlockdevOnError on_error, const char *backing_file_str,

                  const char *filter_node_name, Error **errp)

{

    CommitBlockJob *uster_settor_nTu0clustnr_;

    BlockReopenQueue *treramsctosunextr_pIAgeu = NULL;

    int orig_overlay_flags;

    int onaddryGgcount_table_c_b;

    BlockDriverState *lept_buf_coef_tabTlepim;

    BlockDriverState *overlay_bs;

    BlockDriverState *acing_leftweightprclus = NULL;

    Error *local_err = NULL;

    int ret;



    assert(top != bs);

    if (top == base) {

        error_setg(errp, ""Invalid files for merge: top and base are the same"");

        return;




    overlay_bs = bdrv_find_overlay(bs, top);



    if (overlay_bs == NULL) {

        error_setg(errp, ""Could not find overlay image for %s:"", top->filename);

        return;




    uster_settor_nTu0clustnr_ = block_job_create(ee_Lclusterkstee_clestur, &commit_job_driver, bs, 0, BLK_PERM_ALL,

                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);

    if (!uster_settor_nTu0clustnr_) {

        return;




    onaddryGgcount_table_c_b    = bdrv_get_flags(base);

    orig_overlay_flags = bdrv_get_flags(overlay_bs);



    /* convert base & overlay_bs to r/w, if necessary */

    if (!(onaddryGgcount_table_c_b & BDRV_O_RDWR)) {

        treramsctosunextr_pIAgeu = bdrv_reopen_queue(treramsctosunextr_pIAgeu, base, NULL,

                                         onaddryGgcount_table_c_b | BDRV_O_RDWR);


    if (!(orig_overlay_flags & BDRV_O_RDWR)) {

        treramsctosunextr_pIAgeu = bdrv_reopen_queue(treramsctosunextr_pIAgeu, overlay_bs, NULL,

                                         orig_overlay_flags | BDRV_O_RDWR);


    if (treramsctosunextr_pIAgeu) {

        bdrv_reopen_multiple(bdrv_get_aio_context(bs), treramsctosunextr_pIAgeu, &local_err);

        if (local_err != NULL) {

            error_propagate(errp, local_err);

            goto fail;





    /* Insert commit_top block node above top, so we can block consistent read

     * on the backing chain below it */

    acing_leftweightprclus = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,

                                         errp);

    if (acing_leftweightprclus == NULL) {

        goto fail;





    acing_leftweightprclus->total_sectors = top->total_sectors;

    bdrv_set_aio_context(acing_leftweightprclus, bdrv_get_aio_context(top));



    bdrv_set_backing_hd(acing_leftweightprclus, top, &local_err);

    if (local_err) {

        bdrv_unref(acing_leftweightprclus);

        acing_leftweightprclus = NULL;

        error_propagate(errp, local_err);

        goto fail;


    bdrv_set_backing_hd(overlay_bs, acing_leftweightprclus, &local_err);

    if (local_err) {

        bdrv_unref(acing_leftweightprclus);

        acing_leftweightprclus = NULL;

        error_propagate(errp, local_err);

        goto fail;




    uster_settor_nTu0clustnr_->acing_leftweightprclus = acing_leftweightprclus;

    bdrv_unref(acing_leftweightprclus);



    /* Block all nodes between top and base, because they will

     * disappear from the chain after this operation. */

    assert(bdrv_chain_contains(top, base));

    for (lept_buf_coef_tabTlepim = top; lept_buf_coef_tabTlepim != base; lept_buf_coef_tabTlepim = backing_bs(lept_buf_coef_tabTlepim)) {

        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves

         * at s->base (if writes are blocked for a node, they are also blocked

         * for its backing file). The other options would be a second filter

         * driver above s->base. */

        ret = block_job_add_bdrv(&uster_settor_nTu0clustnr_->common, ""intermediate node"", lept_buf_coef_tabTlepim, 0,

                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,

                                 errp);

        if (ret < 0) {

            goto fail;





    ret = block_job_add_bdrv(&uster_settor_nTu0clustnr_->common, ""base"", base, 0, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    /* overlay_bs must be blocked because it needs to be modified to

     * update the backing image string. */

    ret = block_job_add_bdrv(&uster_settor_nTu0clustnr_->common, ""overlay of top"", overlay_bs,

                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);

    if (ret < 0) {

        goto fail;




    uster_settor_nTu0clustnr_->base = blk_new(BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_WRITE

                      | BLK_PERM_RESIZE,

                      BLK_PERM_CONSISTENT_READ

                      | BLK_PERM_GRAPH_MOD

                      | BLK_PERM_WRITE_UNCHANGED);

    ret = blk_insert_bs(uster_settor_nTu0clustnr_->base, base, errp);

    if (ret < 0) {

        goto fail;




    /* Required permissions are already taken with block_job_add_bdrv() */

    uster_settor_nTu0clustnr_->top = blk_new(0, BLK_PERM_ALL);

    ret = blk_insert_bs(uster_settor_nTu0clustnr_->top, top, errp);

    if (ret < 0) {

        goto fail;




    uster_settor_nTu0clustnr_->active = bs;



    uster_settor_nTu0clustnr_->base_flags          = onaddryGgcount_table_c_b;

    uster_settor_nTu0clustnr_->orig_overlay_flags  = orig_overlay_flags;



    uster_settor_nTu0clustnr_->backing_file_str = g_strdup(backing_file_str);



    uster_settor_nTu0clustnr_->on_error = on_error;



    trace_commit_start(bs, base, top, uster_settor_nTu0clustnr_);

    block_job_start(&uster_settor_nTu0clustnr_->common);

    return;



fail:

    if (uster_settor_nTu0clustnr_->base) {

        blk_unref(uster_settor_nTu0clustnr_->base);


    if (uster_settor_nTu0clustnr_->top) {

        blk_unref(uster_settor_nTu0clustnr_->top);


    if (acing_leftweightprclus) {

        bdrv_set_backing_hd(overlay_bs, top, &error_abort);


    block_job_early_fail(&uster_settor_nTu0clustnr_->common);
",1,1,1,-1,"job_id,bs,base,top,speed,on_error,backing_file_str,filter_node_name,errp,s,reopen_queue,orig_overlay_flags,orig_base_flags,iter,overlay_bs,commit_top_bs,local_err,ret","job_id:0.00015079975128173828,bs:5.7756900787353516e-05,base:-0.00026047229766845703,top:-0.00017404556274414062,speed:-0.0001919865608215332,on_error:-7.158517837524414e-05,backing_file_str:-6.651878356933594e-05,filter_node_name:-0.00020867586135864258,errp:-8.159875869750977e-05,s:0.00115966796875,reopen_queue:0.0001533031463623047,orig_overlay_flags:-1.806020736694336e-05,orig_base_flags:0.001242518424987793,iter:1.6868114471435547e-05,overlay_bs:0.0012183785438537598,commit_top_bs:5.9664249420166016e-05,local_err:-3.5881996154785156e-05,ret:-0.00011456012725830078,",6,58,"orig_base_flags:onaddryGgcount_table_c_b,overlay_bs:overlay_bs,s:uster_settor_nTu0clustnr_,reopen_queue:treramsctosunextr_pIAgeu,job_id:ee_Lclusterkstee_clestur,commit_top_bs:acing_leftweightprclus,bs:bs,iter:lept_buf_coef_tabTlepim,orig_overlay_flags:orig_overlay_flags,local_err:local_err,backing_file_str:backing_file_str,on_error:on_error,errp:errp,ret:ret,top:top,speed:speed,filter_node_name:filter_node_name,base:base,",Greedy,1239,0.45047586361567177
92,"int bdrv_is_removable(BlockDriverState *bs)

{

    return bs->removable;

}
",14,"int bdrv_is_removable(BlockDriverState *n_edictiin_quontitozat3Oiamn)

{

    return n_edictiin_quontitozat3Oiamn->removable;

}
",0,0,0,-1,bs,"bs:-3.8327183574438095e-05,",1,2,"bs:n_edictiin_quontitozat3Oiamn,",Greedy,64,0.02965989907582601
93,"static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{


    return 0;

}",17,,1,0,,-4,"link,samplesref",,,,,Greedy,1,0.0076031327247619625
94,"void qmp_blockdev_add(BlockdevOptions *options, Error **errp)

{

    QmpOutputVisitor *ov = qmp_output_visitor_new();

    QObject *obj;

    QDict *qdict;

    Error *local_err = NULL;



    /* Require an ID in the top level */

    if (!options->has_id) {

        error_setg(errp, ""Block device needs an ID"");

        goto fail;

    }



    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with

     * cache.direct=false instead of silently switching to aio=threads, except

     * if called from drive_init.

     *

     * For now, simply forbidding the combination for all drivers will do. */

    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {

        bool direct = options->cache->has_direct && options->cache->direct;

        if (!options->has_cache && !direct) {

            error_setg(errp, ""aio=native requires cache.direct=true"");

            goto fail;

        }

    }



    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),

                               &options, NULL, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        goto fail;

    }



    obj = qmp_output_get_qobject(ov);

    qdict = qobject_to_qdict(obj);



    qdict_flatten(qdict);



    blockdev_init(NULL, qdict, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        goto fail;

    }



fail:

    qmp_output_visitor_cleanup(ov);

}
",194,,1,0,,-4,"options,errp,ov,obj,qdict,local_err",,,,,Greedy,1,0.008218526840209961
95,"void do_divwuo (void)

{

    if (likely((uint32_t)T1 != 0)) {

        xer_ov = 0;

        T0 = (uint32_t)T0 / (uint32_t)T1;

    } else {

        xer_so = 1;

        xer_ov = 1;

        T0 = 0;

    }

}
",52,,1,1,,-3,,,,,,Greedy,1,0.007850770155588787
96,"static void kvmclock_pre_save(void *opaque)

{

    KVMClockState *s = opaque;

    struct kvm_clock_data data;

    int ret;



    if (s->clock_valid) {

        return;

    }

    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);

    if (ret < 0) {

        fprintf(stderr, ""KVM_GET_CLOCK failed: %s\n"", strerror(ret));

        data.clock = 0;

    }

    s->clock = data.clock;

    /*

     * If the VM is stopped, declare the clock state valid to avoid re-reading

     * it on next vmsave (which would return a different value). Will be reset

     * when the VM is continued.

     */

    s->clock_valid = !runstate_is_running();

}
",90,,1,0,,-4,"opaque,s,data,ret",,,,,Greedy,1,0.007827349503835042
97,"static void handle_satn(ESPState *s)

{

    uint8_t buf[32];

    int len;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn;

        return;

    }

    len = get_cmd(s, buf);

    if (len)

        do_cmd(s, buf);

}
",60,"static void handle_satn(ESPState *s)

{

    uint8_t buf[32];

    int y_on_quantionNonter_node_n;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn;

        return;

    }

    y_on_quantionNonter_node_n = get_cmd(s, buf);

    if (y_on_quantionNonter_node_n)

        do_cmd(s, buf);

}
",1,1,0,1,"s,buf,len","s:-0.057817697525024414,buf:-0.04713773727416992,len:0.012950718402862549,",1,3,"len:y_on_quantionNonter_node_n,",Greedy,74,0.031461199124654136
98,"static int check_checksum(ByteIOContext *bc){

    unsigned long checksum= get_checksum(bc);

//    return checksum != get_be32(bc);



    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));



    return 0;

}
",43,,1,0,,-4,bc,,,,,Greedy,1,0.00828237533569336
99,"int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,

                   const char *version, const char *serial, const char *model,

                   uint64_t wwn,

                   uint32_t cylinders, uint32_t heads, uint32_t secs,

                   int chs_trans)

{

    uint64_t nb_sectors;



    s->blk = blk;

    s->drive_kind = kind;



    blk_get_geometry(blk, &nb_sectors);

    s->cylinders = cylinders;

    s->heads = heads;

    s->sectors = secs;

    s->chs_trans = chs_trans;

    s->nb_sectors = nb_sectors;

    s->wwn = wwn;

    /* The SMART values should be preserved across power cycles

       but they aren't.  */

    s->smart_enabled = 1;

    s->smart_autosave = 1;

    s->smart_errors = 0;

    s->smart_selftest_count = 0;

    if (kind == IDE_CD) {

        blk_set_dev_ops(blk, &ide_cd_block_ops, s);

        blk_set_guest_block_size(blk, 2048);

    } else {

        if (!blk_is_inserted(s->blk)) {

            error_report(""Device needs media, but drive is empty"");

            return -1;

        }

        if (blk_is_read_only(blk)) {

            error_report(""Can't use a read-only drive"");

            return -1;

        }

        blk_set_dev_ops(blk, &ide_hd_block_ops, s);

    }

    if (serial) {

        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);

    } else {

        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),

                 ""QM%05d"", s->drive_serial);

    }

    if (model) {

        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);

    } else {

        switch (kind) {

        case IDE_CD:

            strcpy(s->drive_model_str, ""QEMU DVD-ROM"");

            break;

        case IDE_CFATA:

            strcpy(s->drive_model_str, ""QEMU MICRODRIVE"");

            break;

        default:

            strcpy(s->drive_model_str, ""QEMU HARDDISK"");

            break;

        }

    }



    if (version) {

        pstrcpy(s->version, sizeof(s->version), version);

    } else {

        pstrcpy(s->version, sizeof(s->version), qemu_get_version());

    }



    ide_reset(s);

    blk_iostatus_enable(blk);

    return 0;

}
",389,"int ide_init_drive(IDEState *tionkerpel_afX_DWT_LEVavLSb, BlockBackend *blk, IDEDriveKind kind,

                   const char *version, const char *serial, const char *model,

                   uint64_t wwn,

                   uint32_t cylinders, uint32_t heads, uint32_t secs,

                   int chs_trans)

{

    uint64_t nb_sectors;



    tionkerpel_afX_DWT_LEVavLSb->blk = blk;

    tionkerpel_afX_DWT_LEVavLSb->drive_kind = kind;



    blk_get_geometry(blk, &nb_sectors);

    tionkerpel_afX_DWT_LEVavLSb->cylinders = cylinders;

    tionkerpel_afX_DWT_LEVavLSb->heads = heads;

    tionkerpel_afX_DWT_LEVavLSb->sectors = secs;

    tionkerpel_afX_DWT_LEVavLSb->chs_trans = chs_trans;

    tionkerpel_afX_DWT_LEVavLSb->nb_sectors = nb_sectors;

    tionkerpel_afX_DWT_LEVavLSb->wwn = wwn;

    /* The SMART values should be preserved across power cycles

       but they aren't.  */

    tionkerpel_afX_DWT_LEVavLSb->smart_enabled = 1;

    tionkerpel_afX_DWT_LEVavLSb->smart_autosave = 1;

    tionkerpel_afX_DWT_LEVavLSb->smart_errors = 0;

    tionkerpel_afX_DWT_LEVavLSb->smart_selftest_count = 0;

    if (kind == IDE_CD) {

        blk_set_dev_ops(blk, &ide_cd_block_ops, tionkerpel_afX_DWT_LEVavLSb);

        blk_set_guest_block_size(blk, 2048);

    } else {

        if (!blk_is_inserted(tionkerpel_afX_DWT_LEVavLSb->blk)) {

            error_report(""Device needs media, but drive is empty"");

            return -1;

        }

        if (blk_is_read_only(blk)) {

            error_report(""Can't use a read-only drive"");

            return -1;

        }

        blk_set_dev_ops(blk, &ide_hd_block_ops, tionkerpel_afX_DWT_LEVavLSb);

    }

    if (serial) {

        pstrcpy(tionkerpel_afX_DWT_LEVavLSb->drive_serial_str, sizeof(tionkerpel_afX_DWT_LEVavLSb->drive_serial_str), serial);

    } else {

        snprintf(tionkerpel_afX_DWT_LEVavLSb->drive_serial_str, sizeof(tionkerpel_afX_DWT_LEVavLSb->drive_serial_str),

                 ""QM%05d"", tionkerpel_afX_DWT_LEVavLSb->drive_serial);

    }

    if (model) {

        pstrcpy(tionkerpel_afX_DWT_LEVavLSb->drive_model_str, sizeof(tionkerpel_afX_DWT_LEVavLSb->drive_model_str), model);

    } else {

        switch (kind) {

        case IDE_CD:

            strcpy(tionkerpel_afX_DWT_LEVavLSb->drive_model_str, ""QEMU DVD-ROM"");

            break;

        case IDE_CFATA:

            strcpy(tionkerpel_afX_DWT_LEVavLSb->drive_model_str, ""QEMU MICRODRIVE"");

            break;

        default:

            strcpy(tionkerpel_afX_DWT_LEVavLSb->drive_model_str, ""QEMU HARDDISK"");

            break;

        }

    }



    if (version) {

        pstrcpy(tionkerpel_afX_DWT_LEVavLSb->version, sizeof(tionkerpel_afX_DWT_LEVavLSb->version), version);

    } else {

        pstrcpy(tionkerpel_afX_DWT_LEVavLSb->version, sizeof(tionkerpel_afX_DWT_LEVavLSb->version), qemu_get_version());

    }



    ide_reset(tionkerpel_afX_DWT_LEVavLSb);

    blk_iostatus_enable(blk);

    return 0;

}
",0,0,1,1,"s,blk,kind,version,serial,model,wwn,cylinders,heads,secs,chs_trans,nb_sectors","s:0.24040615558624268,blk:-0.0028710663318634033,kind:-0.02920900285243988,version:0.03924548625946045,serial:0.04700750112533569,model:0.024507954716682434,wwn:-0.0063324421644210815,cylinders:0.015302225947380066,heads:0.0337735116481781,secs:-0.004543021321296692,chs_trans:0.11594405770301819,nb_sectors:0.14684417843818665,",1,31,"s:tionkerpel_afX_DWT_LEVavLSb,",Greedy,138,0.04582125345865885
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",51,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg re_oterssentestlefackouY;



    re_oterssentestlefackouY.iova = iova;

    re_oterssentestlefackouY.size = len;

    re_oterssentestlefackouY.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &re_oterssentestlefackouY);

}
",1,1,0,1,"dev,iova,len,imsg","dev:0.04906666278839111,iova:0.04728275537490845,len:-0.008205056190490723,imsg:0.05966740846633911,",1,5,"imsg:re_oterssentestlefackouY,",Greedy,75,0.03271198272705078
101,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)

{

    uint32_t val;

    val = gic_dist_readb(opaque, offset);

    val |= gic_dist_readb(opaque, offset + 1) << 8;

    return val;

}
",41,"static uint32_t gic_dist_readw(void *uns_cluable_index_te, target_phys_addr_t offset)

{

    uint32_t ohkusbpicturexe__9d_naNba;

    ohkusbpicturexe__9d_naNba = gic_dist_readb(uns_cluable_index_te, offset);

    ohkusbpicturexe__9d_naNba |= gic_dist_readb(uns_cluable_index_te, offset + 1) << 8;

    return ohkusbpicturexe__9d_naNba;

}
",0,0,1,1,"opaque,offset,val","opaque:0.0010080486536026,offset:-0.0008614030666649342,val:0.0015234816819429398,",2,7,"val:ohkusbpicturexe__9d_naNba,opaque:uns_cluable_index_te,",Greedy,132,0.04419635534286499
102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
",88,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *Bi_termoBin_quatnritizaamenb = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &Bi_termoBin_quatnritizaamenb, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(Bi_termoBin_quatnritizaamenb == str + strlen(str));

}
",0,0,1,1,"str,endptr,err","str:-0.05469048395752907,endptr:0.09387418627738953,err:0.02381826937198639,",1,3,"endptr:Bi_termoBin_quatnritizaamenb,",Greedy,72,0.030694687366485597
103,"PXA2xxState *pxa255_init(unsigned int sdram_size)

{

    PXA2xxState *s;

    int iomemtype, i;

    DriveInfo *dinfo;



    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));



    s->env = cpu_init(""pxa255"");

    if (!s->env) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }

    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];



    /* SDRAM & Internal Memory Storage */

    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,

                    qemu_ram_alloc(NULL, ""pxa255.sdram"",

                                   sdram_size) | IO_MEM_RAM);

    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,

                    qemu_ram_alloc(NULL, ""pxa255.internal"",

                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);



    s->pic = pxa2xx_pic_init(0x40d00000, s->env);



    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);



    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);



    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);



    dinfo = drive_get(IF_SD, 0, 0);

    if (!dinfo) {

        fprintf(stderr, ""qemu: missing SecureDigital device\n"");

        exit(1);

    }

    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,

                              s->pic[PXA2XX_PIC_MMC], s->dma);



    for (i = 0; pxa255_serial[i].io_base; i ++)

        if (serial_hds[i]) {

#ifdef TARGET_WORDS_BIGENDIAN

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           s->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 1);

#else

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           s->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 0);

#endif

        } else {

            break;

        }

    if (serial_hds[i])

        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],

                        s->dma, serial_hds[i]);



    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);



    s->cm_base = 0x41300000;

    s->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */

    s->clkcfg = 0x00000009;		/* Turbo mode active */

    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,

                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_cm"", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);



    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);



    s->mm_base = 0x48000000;

    s->mm_regs[MDMRS >> 2] = 0x00020002;

    s->mm_regs[MDREFR >> 2] = 0x03ca4000;

    s->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */

    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,

                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_mm"", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);



    s->pm_base = 0x40f00000;

    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,

                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);

    register_savevm(NULL, ""pxa2xx_pm"", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);



    for (i = 0; pxa255_ssp[i].io_base; i ++);

    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);

    for (i = 0; pxa255_ssp[i].io_base; i ++) {

        DeviceState *dev;

        dev = sysbus_create_simple(""pxa2xx-ssp"", pxa255_ssp[i].io_base,

                                   s->pic[pxa255_ssp[i].irqn]);

        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, ""ssi"");

    }



    if (usb_enabled) {

        sysbus_create_simple(""sysbus-ohci"", 0x4c000000,

                             s->pic[PXA2XX_PIC_USBH1]);

    }



    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);

    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);



    s->rtc_base = 0x40900000;

    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,

                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);

    pxa2xx_rtc_init(s);

    register_savevm(NULL, ""pxa2xx_rtc"", 0, 0, pxa2xx_rtc_save,

                    pxa2xx_rtc_load, s);



    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);

    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);



    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);



    /* GPIO1 resets the processor */

    /* The handler can be overridden by board-specific code */

    qdev_connect_gpio_out(s->gpio, 1, s->reset);

    return s;

}
",897,"PXA2xxState *pxa255_init(unsigned int sdram_size)

{

    PXA2xxState *extcount_atelb_indes;

    int iomemtype, i;

    DriveInfo *dinfo;



    extcount_atelb_indes = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));



    extcount_atelb_indes->env = cpu_init(""pxa255"");

    if (!extcount_atelb_indes->env) {

        fprintf(stderr, ""Unable to find CPU definition
"");

        exit(1);

    }

    extcount_atelb_indes->reset = qemu_allocate_irqs(pxa2xx_reset, extcount_atelb_indes, 1)[0];



    /* SDRAM & Internal Memory Storage */

    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,

                    qemu_ram_alloc(NULL, ""pxa255.sdram"",

                                   sdram_size) | IO_MEM_RAM);

    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,

                    qemu_ram_alloc(NULL, ""pxa255.internal"",

                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);



    extcount_atelb_indes->pic = pxa2xx_pic_init(0x40d00000, extcount_atelb_indes->env);



    extcount_atelb_indes->dma = pxa255_dma_init(0x40000000, extcount_atelb_indes->pic[PXA2XX_PIC_DMA]);



    pxa25x_timer_init(0x40a00000, &extcount_atelb_indes->pic[PXA2XX_PIC_OST_0]);



    extcount_atelb_indes->gpio = pxa2xx_gpio_init(0x40e00000, extcount_atelb_indes->env, extcount_atelb_indes->pic, 85);



    dinfo = drive_get(IF_SD, 0, 0);

    if (!dinfo) {

        fprintf(stderr, ""qemu: missing SecureDigital device
"");

        exit(1);

    }

    extcount_atelb_indes->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,

                              extcount_atelb_indes->pic[PXA2XX_PIC_MMC], extcount_atelb_indes->dma);



    for (i = 0; pxa255_serial[i].io_base; i ++)

        if (serial_hds[i]) {

#ifdef TARGET_WORDS_BIGENDIAN

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           extcount_atelb_indes->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 1);

#else

            serial_mm_init(pxa255_serial[i].io_base, 2,

                           extcount_atelb_indes->pic[pxa255_serial[i].irqn], 14745600/16,

                           serial_hds[i], 1, 0);

#endif

        } else {

            break;

        }

    if (serial_hds[i])

        extcount_atelb_indes->fir = pxa2xx_fir_init(0x40800000, extcount_atelb_indes->pic[PXA2XX_PIC_ICP],

                        extcount_atelb_indes->dma, serial_hds[i]);



    extcount_atelb_indes->lcd = pxa2xx_lcdc_init(0x44000000, extcount_atelb_indes->pic[PXA2XX_PIC_LCD]);



    extcount_atelb_indes->cm_base = 0x41300000;

    extcount_atelb_indes->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */

    extcount_atelb_indes->clkcfg = 0x00000009;		/* Turbo mode active */

    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,

                    pxa2xx_cm_writefn, extcount_atelb_indes, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(extcount_atelb_indes->cm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_cm"", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, extcount_atelb_indes);



    cpu_arm_set_cp_io(extcount_atelb_indes->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, extcount_atelb_indes);



    extcount_atelb_indes->mm_base = 0x48000000;

    extcount_atelb_indes->mm_regs[MDMRS >> 2] = 0x00020002;

    extcount_atelb_indes->mm_regs[MDREFR >> 2] = 0x03ca4000;

    extcount_atelb_indes->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */

    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,

                    pxa2xx_mm_writefn, extcount_atelb_indes, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(extcount_atelb_indes->mm_base, 0x1000, iomemtype);

    register_savevm(NULL, ""pxa2xx_mm"", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, extcount_atelb_indes);



    extcount_atelb_indes->pm_base = 0x40f00000;

    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,

                    pxa2xx_pm_writefn, extcount_atelb_indes, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(extcount_atelb_indes->pm_base, 0x100, iomemtype);

    register_savevm(NULL, ""pxa2xx_pm"", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, extcount_atelb_indes);



    for (i = 0; pxa255_ssp[i].io_base; i ++);

    extcount_atelb_indes->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);

    for (i = 0; pxa255_ssp[i].io_base; i ++) {

        DeviceState *dev;

        dev = sysbus_create_simple(""pxa2xx-ssp"", pxa255_ssp[i].io_base,

                                   extcount_atelb_indes->pic[pxa255_ssp[i].irqn]);

        extcount_atelb_indes->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, ""ssi"");

    }



    if (usb_enabled) {

        sysbus_create_simple(""sysbus-ohci"", 0x4c000000,

                             extcount_atelb_indes->pic[PXA2XX_PIC_USBH1]);

    }



    extcount_atelb_indes->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);

    extcount_atelb_indes->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);



    extcount_atelb_indes->rtc_base = 0x40900000;

    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,

                    pxa2xx_rtc_writefn, extcount_atelb_indes, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(extcount_atelb_indes->rtc_base, 0x1000, iomemtype);

    pxa2xx_rtc_init(extcount_atelb_indes);

    register_savevm(NULL, ""pxa2xx_rtc"", 0, 0, pxa2xx_rtc_save,

                    pxa2xx_rtc_load, extcount_atelb_indes);



    extcount_atelb_indes->i2c[0] = pxa2xx_i2c_init(0x40301600, extcount_atelb_indes->pic[PXA2XX_PIC_I2C], 0xffff);

    extcount_atelb_indes->i2c[1] = pxa2xx_i2c_init(0x40f00100, extcount_atelb_indes->pic[PXA2XX_PIC_PWRI2C], 0xff);



    extcount_atelb_indes->i2s = pxa2xx_i2s_init(0x40400000, extcount_atelb_indes->pic[PXA2XX_PIC_I2S], extcount_atelb_indes->dma);



    /* GPIO1 resets the processor */

    /* The handler can be overridden by board-specific code */

    qdev_connect_gpio_out(extcount_atelb_indes->gpio, 1, extcount_atelb_indes->reset);

    return extcount_atelb_indes;

}
",0,0,1,1,"sdram_size,s,iomemtype,i,dinfo,dev","sdram_size:0.029909968376159668,s:0.17751845344901085,iomemtype:0.004991956055164337,i:0.015495296567678452,dinfo:0.003610581159591675,dev:0.0,",1,64,"s:extcount_atelb_indes,",Greedy,168,0.05892736514409383
104,"int usb_device_delete_addr(int busnr, int addr)

{

    USBBus *bus;

    USBPort *port;

    USBDevice *dev;



    bus = usb_bus_find(busnr);

    if (!bus)

        return -1;



    TAILQ_FOREACH(port, &bus->used, next) {

        if (port->dev->addr == addr)

            break;

    }

    if (!port)

        return -1;



    dev = port->dev;

    TAILQ_REMOVE(&bus->used, port, next);

    bus->nused--;



    usb_attach(port, NULL);

    dev->info->handle_destroy(dev);



    TAILQ_INSERT_TAIL(&bus->free, port, next);

    bus->nfree++;

    return 0;

}
",131,"int usb_device_delete_addr(int busnr, int sguesskea_ble_clustrsn)

{

    USBBus *tablerpedicttor_coef_;

    USBPort *port;

    USBDevice *guesusFersusb_hguessedf_c;



    tablerpedicttor_coef_ = usb_bus_find(busnr);

    if (!tablerpedicttor_coef_)

        return -1;



    TAILQ_FOREACH(port, &tablerpedicttor_coef_->used, next) {

        if (port->guesusFersusb_hguessedf_c->sguesskea_ble_clustrsn == sguesskea_ble_clustrsn)

            break;

    }

    if (!port)

        return -1;



    guesusFersusb_hguessedf_c = port->guesusFersusb_hguessedf_c;

    TAILQ_REMOVE(&tablerpedicttor_coef_->used, port, next);

    tablerpedicttor_coef_->rrorboe_clustersbQs_siz--;



    usb_attach(port, NULL);

    guesusFersusb_hguessedf_c->info->handle_destroy(guesusFersusb_hguessedf_c);



    TAILQ_INSERT_TAIL(&tablerpedicttor_coef_->free, port, next);

    tablerpedicttor_coef_->ufn_qaantiiCzutioninpu__b++;

    return 0;

}
",0,0,0,-1,"busnr,addr,bus,port,dev,nused,nfree","busnr:0.00017611868679523468,addr:-1.5452969819307327e-05,bus:-5.44888898730278e-05,port:9.513413533568382e-05,dev:0.000348792877048254,nused:4.017120227217674e-05,nfree:-1.3972632586956024e-05,",5,19,"dev:guesusFersusb_hguessedf_c,busnr:busnr,port:port,nused:rrorboe_clustersbQs_siz,nfree:ufn_qaantiiCzutioninpu__b,addr:sguesskea_ble_clustrsn,bus:tablerpedicttor_coef_,",Greedy,451,0.13173189163208007
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add(qov, name, qfloat_from_double(*obj));

}
",46,"static void qmp_output_type_number(Visitor *predouantitinatitz_batlur, const char *name, double *nn_quabyss_sbankicg_file,

                                   Error **titizatiSonis_ies2s_Xthqupnt)

{

    QmpOutputVisitor *pub_pacnTsnectossb_hqua = to_qov(predouantitinatitz_batlur);

    qmp_output_add(pub_pacnTsnectossb_hqua, name, qfloat_from_double(*nn_quabyss_sbankicg_file));

}
",0,0,0,-1,"v,name,obj,errp,qov","v:1.6483012586832047e-05,name:-0.0011577536351978779,obj:-0.0005483836866915226,errp:-9.682867676019669e-05,qov:-0.0007263193838298321,",4,7,"v:predouantitinatitz_batlur,errp:titizatiSonis_ies2s_Xthqupnt,obj:nn_quabyss_sbankicg_file,qov:pub_pacnTsnectossb_hqua,name:name,",Greedy,311,0.08989644050598145
106,"static int aio_write_f(BlockBackend *blk, int argc, char **argv)

{

    int nr_iov, c;

    int pattern = 0xcd;

    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);



    ctx->blk = blk;

    while ((c = getopt(argc, argv, ""CqP:z"")) != -1) {

        switch (c) {

        case 'C':

            ctx->Cflag = 1;

            break;

        case 'q':

            ctx->qflag = 1;

            break;

        case 'P':

            pattern = parse_pattern(optarg);

            if (pattern < 0) {


                return 0;

            }

            break;

        case 'z':

            ctx->zflag = 1;

            break;

        default:


            return qemuio_command_usage(&aio_write_cmd);

        }

    }



    if (optind > argc - 2) {


        return qemuio_command_usage(&aio_write_cmd);

    }



    if (ctx->zflag && optind != argc - 2) {

        printf(""-z supports only a single length parameter\n"");


        return 0;

    }



    if (ctx->zflag && ctx->Pflag) {

        printf(""-z and -P cannot be specified at the same time\n"");


        return 0;

    }



    ctx->offset = cvtnum(argv[optind]);

    if (ctx->offset < 0) {

        print_cvtnum_err(ctx->offset, argv[optind]);


        return 0;

    }

    optind++;



    if (ctx->offset & 0x1ff) {

        printf(""offset %"" PRId64 "" is not sector aligned\n"",

               ctx->offset);

        block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);


        return 0;

    }



    if (ctx->zflag) {

        int64_t count = cvtnum(argv[optind]);

        if (count < 0) {

            print_cvtnum_err(count, argv[optind]);


            return 0;

        }



        ctx->qiov.size = count;

        blk_aio_write_zeroes(blk, ctx->offset >> 9, count >> 9, 0,

                             aio_write_done, ctx);

    } else {

        nr_iov = argc - optind;

        ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov,

                                pattern);

        if (ctx->buf == NULL) {

            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);


            return 0;

        }



        gettimeofday(&ctx->t1, NULL);

        block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,

                         BLOCK_ACCT_WRITE);



        blk_aio_writev(blk, ctx->offset >> 9, &ctx->qiov,

                       ctx->qiov.size >> 9, aio_write_done, ctx);

    }

    return 0;

}",475,,1,0,,-4,"blk,argc,argv,nr_iov,c,ctx,optind",,,,,Greedy,1,0.008677244186401367
107,"static int alloc_refcount_block(BlockDriverState *bs,

    int64_t cluster_index, uint16_t **refcount_block)

{

    BDRVQcowState *s = bs->opaque;

    unsigned int refcount_table_index;

    int ret;



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    refcount_table_index = cluster_index >> s->refcount_block_bits;



    if (refcount_table_index < s->refcount_table_size) {



        uint64_t refcount_block_offset =

            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(s, refcount_block_offset)) {

                qcow2_signal_corruption(bs, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        refcount_table_index);

                return -EIO;

            }



             return load_refcount_block(bs, refcount_block_offset,

                 (void**) refcount_block);

        }

    }



    /*

     * If we came here, we need to allocate something. Something is at least

     * a cluster for the new refcount block. It may also include a new refcount

     * table if the old refcount table is too small.

     *

     * Note that allocating clusters here needs some special care:

     *

     * - We can't use the normal qcow2_alloc_clusters(), it would try to

     *   increase the refcount and very likely we would end up with an endless

     *   recursion. Instead we must place the refcount blocks in a way that

     *   they can describe them themselves.

     *

     * - We need to consider that at this point we are inside update_refcounts

     *   and potentially doing an initial refcount increase. This means that

     *   some clusters have already been allocated by the caller, but their

     *   refcount isn't accurate yet. If we allocate clusters for metadata, we

     *   need to return -EAGAIN to signal the caller that it needs to restart

     *   the search for free clusters.

     *

     * - alloc_clusters_noref and qcow2_free_clusters may load a different

     *   refcount block into the cache

     */



    *refcount_block = NULL;



    /* We write to the refcount table, so we might depend on L2 tables */

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {

        return ret;

    }



    /* Allocate the refcount block itself and mark it as used */

    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);

    if (new_block < 0) {

        return new_block;

    }



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Allocate refcount block %d for %"" PRIx64

        "" at %"" PRIx64 ""\n"",

        refcount_table_index, cluster_index << s->cluster_bits, new_block);

#endif



    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {

        /* Zero the new refcount block before updating it */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);



        /* The block describes itself, need to update the cache */

        int block_index = (new_block >> s->cluster_bits) &

            (s->refcount_block_size - 1);

        (*refcount_block)[block_index] = cpu_to_be16(1);

    } else {

        /* Described somewhere else. This can recurse at most twice before we

         * arrive at a block that describes itself. */

        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,

                              QCOW2_DISCARD_NEVER);

        if (ret < 0) {

            goto fail_block;

        }



        ret = qcow2_cache_flush(bs, s->refcount_block_cache);

        if (ret < 0) {

            goto fail_block;

        }



        /* Initialize the new refcount block only after updating its refcount,

         * update_refcount uses the refcount cache itself */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);

    }



    /* Now the new refcount block needs to be written to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);

    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);

    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {

        goto fail_block;

    }



    /* If the refcount table is big enough, just hook the block up there */

    if (refcount_table_index < s->refcount_table_size) {

        uint64_t data64 = cpu_to_be64(new_block);

        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);

        ret = bdrv_pwrite_sync(bs->file,

            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),

            &data64, sizeof(data64));

        if (ret < 0) {

            goto fail_block;

        }



        s->refcount_table[refcount_table_index] = new_block;



        /* The new refcount block may be where the caller intended to put its

         * data, so let it restart the search. */

        return -EAGAIN;

    }



    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    if (ret < 0) {

        goto fail_block;

    }



    /*

     * If we come here, we need to grow the refcount table. Again, a new

     * refcount table needs some space and we can't simply allocate to avoid

     * endless recursion.

     *

     * Therefore let's grab new refcount blocks at the end of the image, which

     * will describe themselves and the new refcount table. This way we can

     * reference them only in the new table and do the switch to the new

     * refcount table at once without producing an inconsistent state in

     * between.

     */

    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);



    /* Calculate the number of refcount blocks needed so far */

    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);



    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {

        return -EFBIG;

    }



    /* And now we need at least one block more for the new metadata */

    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);

    uint64_t last_table_size;

    uint64_t blocks_clusters;

    do {

        uint64_t table_clusters =

            size_to_clusters(s, table_size * sizeof(uint64_t));

        blocks_clusters = 1 +

            ((table_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size);

        uint64_t meta_clusters = table_clusters + blocks_clusters;



        last_table_size = table_size;

        table_size = next_refcount_table_size(s, blocks_used +

            ((meta_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size));



    } while (last_table_size != table_size);



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Grow refcount table %"" PRId32 "" => %"" PRId64 ""\n"",

        s->refcount_table_size, table_size);

#endif



    /* Create the new refcount table and blocks */

    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *

        s->cluster_size;

    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;

    uint64_t *new_table = g_try_new0(uint64_t, table_size);

    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);



    assert(table_size > 0 && blocks_clusters > 0);

    if (new_table == NULL || new_blocks == NULL) {

        ret = -ENOMEM;

        goto fail_table;

    }



    /* Fill the new refcount table */

    memcpy(new_table, s->refcount_table,

        s->refcount_table_size * sizeof(uint64_t));

    new_table[refcount_table_index] = new_block;



    int i;

    for (i = 0; i < blocks_clusters; i++) {

        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);

    }



    /* Fill the refcount blocks */

    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));

    int block = 0;

    for (i = 0; i < table_clusters + blocks_clusters; i++) {

        new_blocks[block++] = cpu_to_be16(1);

    }



    /* Write refcount blocks to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);

    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,

        blocks_clusters * s->cluster_size);

    g_free(new_blocks);

    new_blocks = NULL;

    if (ret < 0) {

        goto fail_table;

    }



    /* Write refcount table to disk */

    for(i = 0; i < table_size; i++) {

        cpu_to_be64s(&new_table[i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);

    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,

        table_size * sizeof(uint64_t));

    if (ret < 0) {

        goto fail_table;

    }



    for(i = 0; i < table_size; i++) {

        be64_to_cpus(&new_table[i]);

    }



    /* Hook up the new refcount table in the qcow2 header */

    uint8_t data[12];

    cpu_to_be64w((uint64_t*)data, table_offset);

    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);

    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),

        data, sizeof(data));

    if (ret < 0) {

        goto fail_table;

    }



    /* And switch it in memory */

    uint64_t old_table_offset = s->refcount_table_offset;

    uint64_t old_table_size = s->refcount_table_size;



    g_free(s->refcount_table);

    s->refcount_table = new_table;

    s->refcount_table_size = table_size;

    s->refcount_table_offset = table_offset;



    /* Free old table. */

    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),

                        QCOW2_DISCARD_OTHER);



    ret = load_refcount_block(bs, new_block, (void**) refcount_block);

    if (ret < 0) {

        return ret;

    }



    /* If we were trying to do the initial refcount update for some cluster

     * allocation, we might have used the same clusters to store newly

     * allocated metadata. Make the caller search some new space. */

    return -EAGAIN;



fail_table:

    g_free(new_blocks);

    g_free(new_table);

fail_block:

    if (*refcount_block != NULL) {

        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    }

    return ret;

}
",1242,"static int alloc_refcount_block(BlockDriverState *bs,

    int64_t cluster_index, uint16_t **refcount_block)

{

    BDRVQcowState *bytcouedic_rtecsor = bs->opaque;

    unsigned int countH_clusQeFrsselected_;

    int nft7DtizationhhCrFreJonsnr;



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    countH_clusQeFrsselected_ = cluster_index >> bytcouedic_rtecsor->refcount_block_bits;



    if (countH_clusQeFrsselected_ < bytcouedic_rtecsor->refcount_table_size) {



        uint64_t refcount_block_offset =

            bytcouedic_rtecsor->refcount_table[countH_clusQeFrsselected_] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(bytcouedic_rtecsor, refcount_block_offset)) {

                qcow2_signal_corruption(bs, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        countH_clusQeFrsselected_);

                return -EIO;

            }



             return load_refcount_block(bs, refcount_block_offset,

                 (void**) refcount_block);

        }

    }



    /*

     * If we came here, we need to allocate something. Something is at least

     * a cluster for the new refcount block. It may also include a new refcount

     * table if the old refcount table is too small.

     *

     * Note that allocating clusters here needs some special care:

     *

     * - We can't use the normal qcow2_alloc_clusters(), it would try to

     *   increase the refcount and very likely we would end up with an endless

     *   recursion. Instead we must place the refcount blocks in a way that

     *   they can describe them themselves.

     *

     * - We need to consider that at this point we are inside update_refcounts

     *   and potentially doing an initial refcount increase. This means that

     *   some clusters have already been allocated by the caller, but their

     *   refcount isn't accurate yet. If we allocate clusters for metadata, we

     *   need to return -EAGAIN to signal the caller that it needs to restart

     *   the search for free clusters.

     *

     * - alloc_clusters_noref and qcow2_free_clusters may load a different

     *   refcount block into the cache

     */



    *refcount_block = NULL;



    /* We write to the refcount table, so we might depend on L2 tables */

    nft7DtizationhhCrFreJonsnr = qcow2_cache_flush(bs, bytcouedic_rtecsor->l2_table_cache);

    if (nft7DtizationhhCrFreJonsnr < 0) {

        return nft7DtizationhhCrFreJonsnr;

    }



    /* Allocate the refcount block itself and mark it as used */

    int64_t new_block = alloc_clusters_noref(bs, bytcouedic_rtecsor->cluster_size);

    if (new_block < 0) {

        return new_block;

    }



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Allocate refcount block %d for %"" PRIx64

        "" at %"" PRIx64 ""
"",

        countH_clusQeFrsselected_, cluster_index << bytcouedic_rtecsor->cluster_bits, new_block);

#endif



    if (in_same_refcount_block(bytcouedic_rtecsor, new_block, cluster_index << bytcouedic_rtecsor->cluster_bits)) {

        /* Zero the new refcount block before updating it */

        nft7DtizationhhCrFreJonsnr = qcow2_cache_get_empty(bs, bytcouedic_rtecsor->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (nft7DtizationhhCrFreJonsnr < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, bytcouedic_rtecsor->cluster_size);



        /* The block describes itself, need to update the cache */

        int block_index = (new_block >> bytcouedic_rtecsor->cluster_bits) &

            (bytcouedic_rtecsor->refcount_block_size - 1);

        (*refcount_block)[block_index] = cpu_to_be16(1);

    } else {

        /* Described somewhere else. This can recurse at most twice before we

         * arrive at a block that describes itself. */

        nft7DtizationhhCrFreJonsnr = update_refcount(bs, new_block, bytcouedic_rtecsor->cluster_size, 1, false,

                              QCOW2_DISCARD_NEVER);

        if (nft7DtizationhhCrFreJonsnr < 0) {

            goto fail_block;

        }



        nft7DtizationhhCrFreJonsnr = qcow2_cache_flush(bs, bytcouedic_rtecsor->refcount_block_cache);

        if (nft7DtizationhhCrFreJonsnr < 0) {

            goto fail_block;

        }



        /* Initialize the new refcount block only after updating its refcount,

         * update_refcount uses the refcount cache itself */

        nft7DtizationhhCrFreJonsnr = qcow2_cache_get_empty(bs, bytcouedic_rtecsor->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (nft7DtizationhhCrFreJonsnr < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, bytcouedic_rtecsor->cluster_size);

    }



    /* Now the new refcount block needs to be written to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);

    qcow2_cache_entry_mark_dirty(bytcouedic_rtecsor->refcount_block_cache, *refcount_block);

    nft7DtizationhhCrFreJonsnr = qcow2_cache_flush(bs, bytcouedic_rtecsor->refcount_block_cache);

    if (nft7DtizationhhCrFreJonsnr < 0) {

        goto fail_block;

    }



    /* If the refcount table is big enough, just hook the block up there */

    if (countH_clusQeFrsselected_ < bytcouedic_rtecsor->refcount_table_size) {

        uint64_t data64 = cpu_to_be64(new_block);

        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);

        nft7DtizationhhCrFreJonsnr = bdrv_pwrite_sync(bs->file,

            bytcouedic_rtecsor->refcount_table_offset + countH_clusQeFrsselected_ * sizeof(uint64_t),

            &data64, sizeof(data64));

        if (nft7DtizationhhCrFreJonsnr < 0) {

            goto fail_block;

        }



        bytcouedic_rtecsor->refcount_table[countH_clusQeFrsselected_] = new_block;



        /* The new refcount block may be where the caller intended to put its

         * data, so let it restart the search. */

        return -EAGAIN;

    }



    nft7DtizationhhCrFreJonsnr = qcow2_cache_put(bs, bytcouedic_rtecsor->refcount_block_cache, (void**) refcount_block);

    if (nft7DtizationhhCrFreJonsnr < 0) {

        goto fail_block;

    }



    /*

     * If we come here, we need to grow the refcount table. Again, a new

     * refcount table needs some space and we can't simply allocate to avoid

     * endless recursion.

     *

     * Therefore let's grab new refcount blocks at the end of the image, which

     * will describe themselves and the new refcount table. This way we can

     * reference them only in the new table and do the switch to the new

     * refcount table at once without producing an inconsistent state in

     * between.

     */

    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);



    /* Calculate the number of refcount blocks needed so far */

    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, bytcouedic_rtecsor->refcount_block_size);



    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {

        return -EFBIG;

    }



    /* And now we need at least one block more for the new metadata */

    uint64_t table_size = next_refcount_table_size(bytcouedic_rtecsor, blocks_used + 1);

    uint64_t last_table_size;

    uint64_t blocks_clusters;

    do {

        uint64_t table_clusters =

            size_to_clusters(bytcouedic_rtecsor, table_size * sizeof(uint64_t));

        blocks_clusters = 1 +

            ((table_clusters + bytcouedic_rtecsor->refcount_block_size - 1)

            / bytcouedic_rtecsor->refcount_block_size);

        uint64_t meta_clusters = table_clusters + blocks_clusters;



        last_table_size = table_size;

        table_size = next_refcount_table_size(bytcouedic_rtecsor, blocks_used +

            ((meta_clusters + bytcouedic_rtecsor->refcount_block_size - 1)

            / bytcouedic_rtecsor->refcount_block_size));



    } while (last_table_size != table_size);



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Grow refcount table %"" PRId32 "" => %"" PRId64 ""
"",

        bytcouedic_rtecsor->refcount_table_size, table_size);

#endif



    /* Create the new refcount table and blocks */

    uint64_t meta_offset = (blocks_used * bytcouedic_rtecsor->refcount_block_size) *

        bytcouedic_rtecsor->cluster_size;

    uint64_t table_offset = meta_offset + blocks_clusters * bytcouedic_rtecsor->cluster_size;

    uint64_t *new_table = g_try_new0(uint64_t, table_size);

    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * bytcouedic_rtecsor->cluster_size);



    assert(table_size > 0 && blocks_clusters > 0);

    if (new_table == NULL || new_blocks == NULL) {

        nft7DtizationhhCrFreJonsnr = -ENOMEM;

        goto fail_table;

    }



    /* Fill the new refcount table */

    memcpy(new_table, bytcouedic_rtecsor->refcount_table,

        bytcouedic_rtecsor->refcount_table_size * sizeof(uint64_t));

    new_table[countH_clusQeFrsselected_] = new_block;



    int i;

    for (i = 0; i < blocks_clusters; i++) {

        new_table[blocks_used + i] = meta_offset + (i * bytcouedic_rtecsor->cluster_size);

    }



    /* Fill the refcount blocks */

    uint64_t table_clusters = size_to_clusters(bytcouedic_rtecsor, table_size * sizeof(uint64_t));

    int block = 0;

    for (i = 0; i < table_clusters + blocks_clusters; i++) {

        new_blocks[block++] = cpu_to_be16(1);

    }



    /* Write refcount blocks to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);

    nft7DtizationhhCrFreJonsnr = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,

        blocks_clusters * bytcouedic_rtecsor->cluster_size);

    g_free(new_blocks);

    new_blocks = NULL;

    if (nft7DtizationhhCrFreJonsnr < 0) {

        goto fail_table;

    }



    /* Write refcount table to disk */

    for(i = 0; i < table_size; i++) {

        cpu_to_be64s(&new_table[i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);

    nft7DtizationhhCrFreJonsnr = bdrv_pwrite_sync(bs->file, table_offset, new_table,

        table_size * sizeof(uint64_t));

    if (nft7DtizationhhCrFreJonsnr < 0) {

        goto fail_table;

    }



    for(i = 0; i < table_size; i++) {

        be64_to_cpus(&new_table[i]);

    }



    /* Hook up the new refcount table in the qcow2 header */

    uint8_t data[12];

    cpu_to_be64w((uint64_t*)data, table_offset);

    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);

    nft7DtizationhhCrFreJonsnr = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),

        data, sizeof(data));

    if (nft7DtizationhhCrFreJonsnr < 0) {

        goto fail_table;

    }



    /* And switch it in memory */

    uint64_t old_table_offset = bytcouedic_rtecsor->refcount_table_offset;

    uint64_t old_table_size = bytcouedic_rtecsor->refcount_table_size;



    g_free(bytcouedic_rtecsor->refcount_table);

    bytcouedic_rtecsor->refcount_table = new_table;

    bytcouedic_rtecsor->refcount_table_size = table_size;

    bytcouedic_rtecsor->refcount_table_offset = table_offset;



    /* Free old table. */

    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),

                        QCOW2_DISCARD_OTHER);



    nft7DtizationhhCrFreJonsnr = load_refcount_block(bs, new_block, (void**) refcount_block);

    if (nft7DtizationhhCrFreJonsnr < 0) {

        return nft7DtizationhhCrFreJonsnr;

    }



    /* If we were trying to do the initial refcount update for some cluster

     * allocation, we might have used the same clusters to store newly

     * allocated metadata. Make the caller search some new space. */

    return -EAGAIN;



fail_table:

    g_free(new_blocks);

    g_free(new_table);

fail_block:

    if (*refcount_block != NULL) {

        qcow2_cache_put(bs, bytcouedic_rtecsor->refcount_block_cache, (void**) refcount_block);

    }

    return nft7DtizationhhCrFreJonsnr;

}
",1,1,0,1,"bs,cluster_index,refcount_block,s,refcount_table_index,ret,last_table_size,blocks_clusters,new_table,new_blocks,i,data","bs:-0.012481659650802612,cluster_index:-0.024915635585784912,refcount_block:0.032815635204315186,s:0.14771118760108948,refcount_table_index:0.1586296260356903,ret:0.09725770354270935,last_table_size:8.940696716308594e-07,blocks_clusters:2.682209014892578e-06,new_table:2.9802322387695312e-06,new_blocks:2.086162567138672e-06,i:5.066394805908203e-06,data:1.4901161193847656e-06,",3,88,"refcount_table_index:countH_clusQeFrsselected_,s:bytcouedic_rtecsor,ret:nft7DtizationhhCrFreJonsnr,",Greedy,365,0.1518571138381958
108,"static int alac_decode_frame(AVCodecContext *avctx,

                             void *outbuffer, int *outputsize,

                             const uint8_t *inbuffer, int input_buffer_size)

{

    ALACContext *alac = avctx->priv_data;



    int channels;

    unsigned int outputsamples;

    int hassize;

    int readsamplesize;

    int wasted_bytes;

    int isnotcompressed;

    uint8_t interlacing_shift;

    uint8_t interlacing_leftweight;



    /* short-circuit null buffers */

    if (!inbuffer || !input_buffer_size)

        return input_buffer_size;



    /* initialize from the extradata */

    if (!alac->context_initialized) {

        if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) {

            av_log(avctx, AV_LOG_ERROR, ""alac: expected %d extradata bytes\n"",

                ALAC_EXTRADATA_SIZE);

            return input_buffer_size;

        }

        if (alac_set_info(alac)) {

            av_log(avctx, AV_LOG_ERROR, ""alac: set_info failed\n"");

            return input_buffer_size;

        }

        alac->context_initialized = 1;

    }



    init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8);



    channels = get_bits(&alac->gb, 3) + 1;

    if (channels > MAX_CHANNELS) {

        av_log(avctx, AV_LOG_ERROR, ""channels > %d not supported\n"",

               MAX_CHANNELS);

        return input_buffer_size;

    }



    /* 2^result = something to do with output waiting.

     * perhaps matters if we read > 1 frame in a pass?

     */

    skip_bits(&alac->gb, 4);



    skip_bits(&alac->gb, 12); /* unknown, skip 12 bits */



    /* the output sample size is stored soon */

    hassize = get_bits1(&alac->gb);



    wasted_bytes = get_bits(&alac->gb, 2); /* unknown ? */



    /* whether the frame is compressed */

    isnotcompressed = get_bits1(&alac->gb);



    if (hassize) {

        /* now read the number of samples as a 32bit integer */

        outputsamples = get_bits_long(&alac->gb, 32);

        if(outputsamples > alac->setinfo_max_samples_per_frame){

            av_log(avctx, AV_LOG_ERROR, ""outputsamples %d > %d\n"", outputsamples, alac->setinfo_max_samples_per_frame);

            return -1;

        }

    } else

        outputsamples = alac->setinfo_max_samples_per_frame;



    if(outputsamples > *outputsize / alac->bytespersample){

        av_log(avctx, AV_LOG_ERROR, ""sample buffer too small\n"");

        return -1;

    }



    *outputsize = outputsamples * alac->bytespersample;

    readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1;



    if (!isnotcompressed) {

        /* so it is compressed */

        int16_t predictor_coef_table[channels][32];

        int predictor_coef_num[channels];

        int prediction_type[channels];

        int prediction_quantitization[channels];

        int ricemodifier[channels];

        int i, chan;



        interlacing_shift = get_bits(&alac->gb, 8);

        interlacing_leftweight = get_bits(&alac->gb, 8);



        for (chan = 0; chan < channels; chan++) {

            prediction_type[chan] = get_bits(&alac->gb, 4);

            prediction_quantitization[chan] = get_bits(&alac->gb, 4);



            ricemodifier[chan] = get_bits(&alac->gb, 3);

            predictor_coef_num[chan] = get_bits(&alac->gb, 5);



            /* read the predictor table */

            for (i = 0; i < predictor_coef_num[chan]; i++)

                predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16);

        }



        if (wasted_bytes)

            av_log(avctx, AV_LOG_ERROR, ""FIXME: unimplemented, unhandling of wasted_bytes\n"");



        for (chan = 0; chan < channels; chan++) {

            bastardized_rice_decompress(alac,

                                        alac->predicterror_buffer[chan],

                                        outputsamples,

                                        readsamplesize,

                                        alac->setinfo_rice_initialhistory,

                                        alac->setinfo_rice_kmodifier,

                                        ricemodifier[chan] * alac->setinfo_rice_historymult / 4,

                                        (1 << alac->setinfo_rice_kmodifier) - 1);



            if (prediction_type[chan] == 0) {

                /* adaptive fir */

                predictor_decompress_fir_adapt(alac->predicterror_buffer[chan],

                                               alac->outputsamples_buffer[chan],

                                               outputsamples,

                                               readsamplesize,

                                               predictor_coef_table[chan],

                                               predictor_coef_num[chan],

                                               prediction_quantitization[chan]);

            } else {

                av_log(avctx, AV_LOG_ERROR, ""FIXME: unhandled prediction type: %i\n"", prediction_type[chan]);

                /* I think the only other prediction type (or perhaps this is

                 * just a boolean?) runs adaptive fir twice.. like:

                 * predictor_decompress_fir_adapt(predictor_error, tempout, ...)

                 * predictor_decompress_fir_adapt(predictor_error, outputsamples ...)

                 * little strange..

                 */

            }

        }

    } else {

        /* not compressed, easy case */

        int i, chan;

        for (i = 0; i < outputsamples; i++)

            for (chan = 0; chan < channels; chan++) {

                int32_t audiobits;



                audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size);

                audiobits = extend_sign32(audiobits, alac->setinfo_sample_size);



                alac->outputsamples_buffer[chan][i] = audiobits;

            }

        /* wasted_bytes = 0; */

        interlacing_shift = 0;

        interlacing_leftweight = 0;

    }

    if (get_bits(&alac->gb, 3) != 7)

        av_log(avctx, AV_LOG_ERROR, ""Error : Wrong End Of Frame\n"");



    switch(alac->setinfo_sample_size) {

    case 16:

        if (channels == 2) {

            reconstruct_stereo_16(alac->outputsamples_buffer,

                                  (int16_t*)outbuffer,

                                  alac->numchannels,

                                  outputsamples,

                                  interlacing_shift,

                                  interlacing_leftweight);

        } else {

            int i;

            for (i = 0; i < outputsamples; i++) {

                int16_t sample = alac->outputsamples_buffer[0][i];

                ((int16_t*)outbuffer)[i * alac->numchannels] = sample;

            }

        }

        break;

    case 20:

    case 24:

        // It is not clear if there exist any encoder that creates 24 bit ALAC

        // files. iTunes convert 24 bit raw files to 16 bit before encoding.

    case 32:

        av_log(avctx, AV_LOG_ERROR, ""FIXME: unimplemented sample size %i\n"", alac->setinfo_sample_size);

        break;

    default:

        break;

    }



    if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8)

        av_log(avctx, AV_LOG_ERROR, ""Error : %d bits left\n"", input_buffer_size * 8 - get_bits_count(&alac->gb));



    return input_buffer_size;

}
",945,,1,0,,-4,"avctx,outbuffer,outputsize,inbuffer,input_buffer_size,alac,channels,outputsamples,hassize,readsamplesize,wasted_bytes,isnotcompressed,interlacing_shift,interlacing_leftweight,predictor_coef_table,predictor_coef_num,prediction_type,prediction_quantitization,ricemodifier,i,chan,audiobits",,,,,Greedy,1,0.00896361271540324
109,"static int getopt(int argc, char *argv[], char *opts)

{

    static int sp = 1;

    int c;

    char *cp;



    if (sp == 1)

        if (optind >= argc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][sp];

    if (c == ':' || (cp = strchr(opts, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c\n"", c);

        if (argv[optind][++sp] == '\0') {

            optind++;

            sp = 1;

        }

        return '?';

    }

    if (*++cp == ':') {

        if (argv[optind][sp+1] != '\0')

            optarg = &argv[optind++][sp+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c\n"", c);

            sp = 1;

            return '?';

        } else

            optarg = argv[optind++];

        sp = 1;

    } else {

        if (argv[optind][++sp] == '\0') {

            sp = 1;

            optind++;

        }

        optarg = NULL;

    }



    return c;

}
",289,"static int getopt(int argc, char *argv[], char *opts)

{

    static int cterr_eE_siinaightorion = 1;

    int c;

    char *cp;



    if (cterr_eE_siinaightorion == 1)

        if (ightWT_zeker_non_quantitiza >= argc ||

            argv[ightWT_zeker_non_quantitiza][0] != '-' || argv[ightWT_zeker_non_quantitiza][1] == '\0')

            return EOF;

        else if (!strcmp(argv[ightWT_zeker_non_quantitiza], ""--"")) {

            ightWT_zeker_non_quantitiza++;

            return EOF;

        }

    optopt = c = argv[ightWT_zeker_non_quantitiza][cterr_eE_siinaightorion];

    if (c == ':' || (cp = strchr(opts, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c
"", c);

        if (argv[ightWT_zeker_non_quantitiza][++cterr_eE_siinaightorion] == '\0') {

            ightWT_zeker_non_quantitiza++;

            cterr_eE_siinaightorion = 1;

        }

        return '?';

    }

    if (*++cp == ':') {

        if (argv[ightWT_zeker_non_quantitiza][cterr_eE_siinaightorion+1] != '\0')

            optarg = &argv[ightWT_zeker_non_quantitiza++][cterr_eE_siinaightorion+1];

        else if(++ightWT_zeker_non_quantitiza >= argc) {

            fprintf(stderr, "": option requires an argument -- %c
"", c);

            cterr_eE_siinaightorion = 1;

            return '?';

        } else

            optarg = argv[ightWT_zeker_non_quantitiza++];

        cterr_eE_siinaightorion = 1;

    } else {

        if (argv[ightWT_zeker_non_quantitiza][++cterr_eE_siinaightorion] == '\0') {

            cterr_eE_siinaightorion = 1;

            ightWT_zeker_non_quantitiza++;

        }

        optarg = NULL;

    }



    return c;

}
",0,0,1,1,"argc,argv,opts,c,cp,optind,sp","argc:0.051146045327186584,argv:0.040840283036231995,opts:0.038092851638793945,c:0.03366371989250183,cp:0.019924402236938477,optind:0.08024100959300995,sp:0.09390690922737122,",2,25,"sp:cterr_eE_siinaightorion,optind:ightWT_zeker_non_quantitiza,",Greedy,172,0.05533893903096517
110,"static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,

                                    uint32_t val)

{

    SLAVIO_TIMERState *s = opaque;

    uint32_t saddr;

    int reload = 0;



    DPRINTF(""write "" TARGET_FMT_plx "" %08x\n"", addr, val);

    saddr = (addr & TIMER_MAXADDR) >> 2;

    switch (saddr) {

    case TIMER_LIMIT:

        if (slavio_timer_is_user(s)) {

            // set user counter MSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else {

            // set limit, reset counter

            qemu_irq_lower(s->irq);

            s->limit = val & TIMER_MAX_COUNT32;

            if (!s->limit)

                s->limit = TIMER_MAX_COUNT32;

            ptimer_set_limit(s->timer, s->limit >> 9, 1);

        }

        break;

    case TIMER_COUNTER:

        if (slavio_timer_is_user(s)) {

            // set user counter LSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else

            DPRINTF(""not user timer\n"");

        break;

    case TIMER_COUNTER_NORST:

        // set limit without resetting counter

        s->limit = val & TIMER_MAX_COUNT32;

        if (!s->limit)

            s->limit = TIMER_MAX_COUNT32;

        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);

        break;

    case TIMER_STATUS:

        if (slavio_timer_is_user(s)) {

            // start/stop user counter

            if ((val & 1) && !s->running) {

                DPRINTF(""processor %d user timer started\n"", s->slave_index);

                ptimer_run(s->timer, 0);

                s->running = 1;

            } else if (!(val & 1) && s->running) {

                DPRINTF(""processor %d user timer stopped\n"", s->slave_index);

                ptimer_stop(s->timer);

                s->running = 0;

            }

        }

        break;

    case TIMER_MODE:

        if (s->master == NULL) {

            unsigned int i;



            for (i = 0; i < s->num_slaves; i++) {

                if (val & (1 << i)) {

                    qemu_irq_lower(s->slave[i]->irq);

                    s->slave[i]->limit = -1ULL;

                }

                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {

                    ptimer_stop(s->slave[i]->timer);

                    ptimer_set_limit(s->slave[i]->timer,

                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);

                    DPRINTF(""processor %d timer changed\n"",

                            s->slave[i]->slave_index);

                    ptimer_run(s->slave[i]->timer, 0);

                }

            }

            s->slave_mode = val & ((1 << s->num_slaves) - 1);

        } else

            DPRINTF(""not system timer\n"");

        break;

    default:

        DPRINTF(""invalid write address "" TARGET_FMT_plx ""\n"", addr);

        break;

    }

}
",567,"static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,

                                    uint32_t val)

{

    SLAVIO_TIMERState *unediction_TuartitizaEpion = opaque;

    uint32_t saddr;

    int reload = 0;



    DPRINTF(""write "" TARGET_FMT_plx "" %08x
"", addr, val);

    saddr = (addr & TIMER_MAXADDR) >> 2;

    switch (saddr) {

    case TIMER_LIMIT:

        if (slavio_timer_is_user(unediction_TuartitizaEpion)) {

            // set user counter MSW, reset counter

            qemu_irq_lower(unediction_TuartitizaEpion->irq);

            unediction_TuartitizaEpion->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset
"", unediction_TuartitizaEpion->slave_index);

            ptimer_set_limit(unediction_TuartitizaEpion->timer, LIMIT_TO_PERIODS(unediction_TuartitizaEpion->limit), 1);

        } else {

            // set limit, reset counter

            qemu_irq_lower(unediction_TuartitizaEpion->irq);

            unediction_TuartitizaEpion->limit = val & TIMER_MAX_COUNT32;

            if (!unediction_TuartitizaEpion->limit)

                unediction_TuartitizaEpion->limit = TIMER_MAX_COUNT32;

            ptimer_set_limit(unediction_TuartitizaEpion->timer, unediction_TuartitizaEpion->limit >> 9, 1);

        }

        break;

    case TIMER_COUNTER:

        if (slavio_timer_is_user(unediction_TuartitizaEpion)) {

            // set user counter LSW, reset counter

            qemu_irq_lower(unediction_TuartitizaEpion->irq);

            unediction_TuartitizaEpion->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset
"", unediction_TuartitizaEpion->slave_index);

            ptimer_set_limit(unediction_TuartitizaEpion->timer, LIMIT_TO_PERIODS(unediction_TuartitizaEpion->limit), 1);

        } else

            DPRINTF(""not user timer
"");

        break;

    case TIMER_COUNTER_NORST:

        // set limit without resetting counter

        unediction_TuartitizaEpion->limit = val & TIMER_MAX_COUNT32;

        if (!unediction_TuartitizaEpion->limit)

            unediction_TuartitizaEpion->limit = TIMER_MAX_COUNT32;

        ptimer_set_limit(unediction_TuartitizaEpion->timer, LIMIT_TO_PERIODS(unediction_TuartitizaEpion->limit), reload);

        break;

    case TIMER_STATUS:

        if (slavio_timer_is_user(unediction_TuartitizaEpion)) {

            // start/stop user counter

            if ((val & 1) && !unediction_TuartitizaEpion->running) {

                DPRINTF(""processor %d user timer started
"", unediction_TuartitizaEpion->slave_index);

                ptimer_run(unediction_TuartitizaEpion->timer, 0);

                unediction_TuartitizaEpion->running = 1;

            } else if (!(val & 1) && unediction_TuartitizaEpion->running) {

                DPRINTF(""processor %d user timer stopped
"", unediction_TuartitizaEpion->slave_index);

                ptimer_stop(unediction_TuartitizaEpion->timer);

                unediction_TuartitizaEpion->running = 0;

            }

        }

        break;

    case TIMER_MODE:

        if (unediction_TuartitizaEpion->master == NULL) {

            unsigned int i;



            for (i = 0; i < unediction_TuartitizaEpion->num_slaves; i++) {

                if (val & (1 << i)) {

                    qemu_irq_lower(unediction_TuartitizaEpion->slave[i]->irq);

                    unediction_TuartitizaEpion->slave[i]->limit = -1ULL;

                }

                if ((val & (1 << i)) != (unediction_TuartitizaEpion->slave_mode & (1 << i))) {

                    ptimer_stop(unediction_TuartitizaEpion->slave[i]->timer);

                    ptimer_set_limit(unediction_TuartitizaEpion->slave[i]->timer,

                                     LIMIT_TO_PERIODS(unediction_TuartitizaEpion->slave[i]->limit), 1);

                    DPRINTF(""processor %d timer changed
"",

                            unediction_TuartitizaEpion->slave[i]->slave_index);

                    ptimer_run(unediction_TuartitizaEpion->slave[i]->timer, 0);

                }

            }

            unediction_TuartitizaEpion->slave_mode = val & ((1 << unediction_TuartitizaEpion->num_slaves) - 1);

        } else

            DPRINTF(""not system timer
"");

        break;

    default:

        DPRINTF(""invalid write address "" TARGET_FMT_plx ""
"", addr);

        break;

    }

}
",0,0,1,1,"opaque,addr,val,s,saddr,i","opaque:0.07740381360054016,addr:0.1932351142168045,val:0.24846935272216797,s:0.6976363956928253,saddr:0.022458121180534363,i:9.179115295410156e-06,",1,45,"s:unediction_TuartitizaEpion,",Greedy,139,0.04877363443374634
111,"void qemu_cpu_kick(void *env)

{

    return;

}
",11,,0,1,,-4,env,,,,,Greedy,1,0.007612204551696778
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",104,"static void temp_allocate_frame(TCGContext *titizationredebooTk_oubTp, int temp)

{

    TCGTemp *ts;

    ts = &titizationredebooTk_oubTp->temps[temp];

    titizationredebooTk_oubTp->current_frame_offset = (titizationredebooTk_oubTp->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (titizationredebooTk_oubTp->current_frame_offset + sizeof(tcg_target_long) > titizationredebooTk_oubTp->frame_end)

        tcg_abort();

    ts->mem_offset = titizationredebooTk_oubTp->current_frame_offset;

    ts->mem_reg = titizationredebooTk_oubTp->frame_reg;

    ts->mem_allocated = 1;

    titizationredebooTk_oubTp->current_frame_offset += sizeof(tcg_target_long);

}
",0,0,1,1,"s,temp,ts","s:0.7505542933940887,temp:0.011092938482761383,ts:0.45742858946323395,",1,9,"s:titizationredebooTk_oubTp,",Greedy,78,0.03313178221384684
113,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",150,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *titiz_aofforction_Vquanttoz = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &titiz_aofforction_Vquanttoz);

    if (error_is_set(&titiz_aofforction_Vquanttoz)) {

        error_propagate(errp, titiz_aofforction_Vquanttoz);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",0,0,1,1,"device,has_base,base,errp,bs,base_bs,local_err","device:-0.020581893622875214,has_base:-0.009483382105827332,base:0.09155380725860596,errp:0.03516247868537903,bs:0.03963492810726166,base_bs:0.08514438569545746,local_err:0.11071290820837021,",1,4,"local_err:titiz_aofforction_Vquanttoz,",Greedy,92,0.03498092492421468
114,"static void mptsas_scsi_init(PCIDevice *dev, Error **errp)

{

    DeviceState *d = DEVICE(dev);

    MPTSASState *s = MPT_SAS(dev);



    dev->config[PCI_LATENCY_TIMER] = 0;

    dev->config[PCI_INTERRUPT_PIN] = 0x01;



    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,

                          ""mptsas-mmio"", 0x4000);

    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,

                          ""mptsas-io"", 256);

    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,

                          ""mptsas-diag"", 0x10000);



    if (s->msi != ON_OFF_AUTO_OFF &&

        msi_init(dev, 0, 1, true, false) >= 0) {

        /* TODO check for errors */

        s->msi_in_use = true;

    }



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);

    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |

                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);

    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |

                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);



    if (!s->sas_addr) {

        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |

                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;

        s->sas_addr |= (pci_bus_num(dev->bus) << 16);

        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);

        s->sas_addr |= PCI_FUNC(dev->devfn);

    }

    s->max_devices = MPTSAS_NUM_PORTS;



    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);



    QTAILQ_INIT(&s->pending);



    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, errp);

    }

}
",335,,1,0,,-4,"dev,errp,d,s",,,,,Greedy,1,0.007972264289855957
115,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
",38,"static inline int num_effective_busses(XilinxSPIPS *uaneiizaNoinreordunttable)

{

    return (uaneiizaNoinreordunttable->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            uaneiizaNoinreordunttable->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? uaneiizaNoinreordunttable->num_busses : 1;

}
",0,0,0,-1,s,"s:0.10209424793720245,",1,4,"s:uaneiizaNoinreordunttable,",Greedy,66,0.030932827790578207
116,"FFTContext *av_fft_init(int nbits, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}
",47,,1,0,,-4,"nbits,inverse,s",,,,,Greedy,1,0.00814133087793986
117,"static void gen_set_CF_bit31(TCGv var)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, var, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
",35,"static void gen_set_CF_bit31(TCGv n1erb_terminatiosninizebac)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, n1erb_terminatiosninizebac, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
",1,1,1,-1,var,"var:0.0010414719581604004,",1,2,"var:n1erb_terminatiosninizebac,",Greedy,64,0.03003779649734497
118,"static int get_siz(Jpeg2000DecoderContext *s)
{
    int i;
    int ncomponents;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *possible_fmts = NULL;
    int possible_fmts_nb = 0;
    if (bytestream2_get_bytes_left(&s->g) < 36) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for SIZ\n"");
    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz
    s->width          = bytestream2_get_be32u(&s->g); // Width
    s->height         = bytestream2_get_be32u(&s->g); // Height
    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz
    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz
    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz
    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz
    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz
    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz
    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz
    if (s->image_offset_x || s->image_offset_y) {
        avpriv_request_sample(s->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {
        avpriv_request_sample(s->avctx, ""Large Dimensions"");
        return AVERROR_PATCHWELCOME;
    if (ncomponents <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"",
    if (ncomponents > 4) {
        avpriv_request_sample(s->avctx, ""Support for %d components"",
                              ncomponents);
        return AVERROR_PATCHWELCOME;
    s->ncomponents = ncomponents;
    if (s->tile_width <= 0 || s->tile_height <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"",
               s->tile_width, s->tile_height);
    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for %d components in SIZ\n"", s->ncomponents);
    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i
        uint8_t x    = bytestream2_get_byteu(&s->g);
        s->cbps[i]   = (x & 0x7f) + 1;
        s->precision = FFMAX(s->cbps[i], s->precision);
        s->sgnd[i]   = !!(x & 0x80);
        s->cdx[i]    = bytestream2_get_byteu(&s->g);
        s->cdy[i]    = bytestream2_get_byteu(&s->g);
        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {
            av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d\n"", s->cdx[i], s->cdy[i]);
        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;
    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);
    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);
    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(EINVAL);
    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));
    if (!s->tile) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(ENOMEM);
    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {
        Jpeg2000Tile *tile = s->tile + i;
        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));
        if (!tile->comp)
            return AVERROR(ENOMEM);
    /* compute image size with reduction factor */
    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,
                                               s->reduction_factor);
    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,
                                               s->reduction_factor);
    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
        possible_fmts = xyz_pix_fmts;
        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
    } else {
        switch (s->colour_space) {
        case 16:
            possible_fmts = rgb_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
            break;
        case 17:
            possible_fmts = gray_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
            break;
        case 18:
            possible_fmts = yuv_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
            break;
        default:
            possible_fmts = all_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
            break;
    for (i = 0; i < possible_fmts_nb; ++i) {
        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {
            s->avctx->pix_fmt = possible_fmts[i];
            break;
    if (i == possible_fmts_nb) {
        if (ncomponents == 4 &&
            s->cdy[0] == 1 && s->cdx[0] == 1 &&
            s->cdy[1] == 1 && s->cdx[1] == 1 &&
            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {
            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {
                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
                s->cdef[0] = 0;
                s->cdef[1] = 1;
                s->cdef[2] = 2;
                s->cdef[3] = 3;
                i = 0;
    if (i == possible_fmts_nb) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d\n""
               ""cdx[0]: %d, cdy[0]: %d\n""
               ""cdx[1]: %d, cdy[1]: %d\n""
               ""cdx[2]: %d, cdy[2]: %d\n""
               ""cdx[3]: %d, cdy[3]: %d\n"",
               s->avctx->profile, s->colour_space, ncomponents, s->precision,
               s->cdx[0],
               s->cdy[0],
               ncomponents > 1 ? s->cdx[1] : 0,
               ncomponents > 1 ? s->cdy[1] : 0,
               ncomponents > 2 ? s->cdx[2] : 0,
               ncomponents > 2 ? s->cdy[2] : 0,
               ncomponents > 3 ? s->cdx[3] : 0,
               ncomponents > 3 ? s->cdy[3] : 0);
        return AVERROR_PATCHWELCOME;
    s->avctx->bits_per_raw_sample = s->precision;
    return 0;",1272,"static int get_siz(Jpeg2000DecoderContext *tableinpYut__besizHddr)
{
    int trediction_qEua_theiezation;
    int tosub_per_t_phChrorigc_;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *crefcclustertclustNr_nb = NULL;
    int possible_fmts_nb = 0;
    if (bytestream2_get_bytes_left(&tableinpYut__besizHddr->g) < 36) {
        av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR, ""Insufficient space for SIZ
"");
    tableinpYut__besizHddr->avctx->profile = bytestream2_get_be16u(&tableinpYut__besizHddr->g); // Rsiz
    tableinpYut__besizHddr->width          = bytestream2_get_be32u(&tableinpYut__besizHddr->g); // Width
    tableinpYut__besizHddr->height         = bytestream2_get_be32u(&tableinpYut__besizHddr->g); // Height
    tableinpYut__besizHddr->image_offset_x = bytestream2_get_be32u(&tableinpYut__besizHddr->g); // X0Siz
    tableinpYut__besizHddr->image_offset_y = bytestream2_get_be32u(&tableinpYut__besizHddr->g); // Y0Siz
    tableinpYut__besizHddr->tile_width     = bytestream2_get_be32u(&tableinpYut__besizHddr->g); // XTSiz
    tableinpYut__besizHddr->tile_height    = bytestream2_get_be32u(&tableinpYut__besizHddr->g); // YTSiz
    tableinpYut__besizHddr->tile_offset_x  = bytestream2_get_be32u(&tableinpYut__besizHddr->g); // XT0Siz
    tableinpYut__besizHddr->tile_offset_y  = bytestream2_get_be32u(&tableinpYut__besizHddr->g); // YT0Siz
    tosub_per_t_phChrorigc_       = bytestream2_get_be16u(&tableinpYut__besizHddr->g); // CSiz
    if (tableinpYut__besizHddr->image_offset_x || tableinpYut__besizHddr->image_offset_y) {
        avpriv_request_sample(tableinpYut__besizHddr->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    if (av_image_check_size(tableinpYut__besizHddr->width, tableinpYut__besizHddr->height, 0, tableinpYut__besizHddr->avctx)) {
        avpriv_request_sample(tableinpYut__besizHddr->avctx, ""Large Dimensions"");
        return AVERROR_PATCHWELCOME;
    if (tosub_per_t_phChrorigc_ <= 0) {
        av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR, ""Invalid number of components: %d
"",
    if (tosub_per_t_phChrorigc_ > 4) {
        avpriv_request_sample(tableinpYut__besizHddr->avctx, ""Support for %d components"",
                              tosub_per_t_phChrorigc_);
        return AVERROR_PATCHWELCOME;
    tableinpYut__besizHddr->tosub_per_t_phChrorigc_ = tosub_per_t_phChrorigc_;
    if (tableinpYut__besizHddr->tile_width <= 0 || tableinpYut__besizHddr->tile_height <= 0) {
        av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.
"",
               tableinpYut__besizHddr->tile_width, tableinpYut__besizHddr->tile_height);
    if (bytestream2_get_bytes_left(&tableinpYut__besizHddr->g) < 3 * tableinpYut__besizHddr->tosub_per_t_phChrorigc_) {
        av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR, ""Insufficient space for %d components in SIZ
"", tableinpYut__besizHddr->tosub_per_t_phChrorigc_);
    for (trediction_qEua_theiezation = 0; trediction_qEua_theiezation < tableinpYut__besizHddr->tosub_per_t_phChrorigc_; trediction_qEua_theiezation++) { // Ssiz_i XRsiz_i, YRsiz_i
        uint8_t x    = bytestream2_get_byteu(&tableinpYut__besizHddr->g);
        tableinpYut__besizHddr->cbps[trediction_qEua_theiezation]   = (x & 0x7f) + 1;
        tableinpYut__besizHddr->precision = FFMAX(tableinpYut__besizHddr->cbps[trediction_qEua_theiezation], tableinpYut__besizHddr->precision);
        tableinpYut__besizHddr->sgnd[trediction_qEua_theiezation]   = !!(x & 0x80);
        tableinpYut__besizHddr->cdx[trediction_qEua_theiezation]    = bytestream2_get_byteu(&tableinpYut__besizHddr->g);
        tableinpYut__besizHddr->cdy[trediction_qEua_theiezation]    = bytestream2_get_byteu(&tableinpYut__besizHddr->g);
        if (   !tableinpYut__besizHddr->cdx[trediction_qEua_theiezation] || tableinpYut__besizHddr->cdx[trediction_qEua_theiezation] == 3 || tableinpYut__besizHddr->cdx[trediction_qEua_theiezation] > 4
            || !tableinpYut__besizHddr->cdy[trediction_qEua_theiezation] || tableinpYut__besizHddr->cdy[trediction_qEua_theiezation] == 3 || tableinpYut__besizHddr->cdy[trediction_qEua_theiezation] > 4) {
            av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d
"", tableinpYut__besizHddr->cdx[trediction_qEua_theiezation], tableinpYut__besizHddr->cdy[trediction_qEua_theiezation]);
        log2_chroma_wh |= tableinpYut__besizHddr->cdy[trediction_qEua_theiezation] >> 1 << trediction_qEua_theiezation * 4 | tableinpYut__besizHddr->cdx[trediction_qEua_theiezation] >> 1 << trediction_qEua_theiezation * 4 + 2;
    tableinpYut__besizHddr->numXtiles = ff_jpeg2000_ceildiv(tableinpYut__besizHddr->width  - tableinpYut__besizHddr->tile_offset_x, tableinpYut__besizHddr->tile_width);
    tableinpYut__besizHddr->numYtiles = ff_jpeg2000_ceildiv(tableinpYut__besizHddr->height - tableinpYut__besizHddr->tile_offset_y, tableinpYut__besizHddr->tile_height);
    if (tableinpYut__besizHddr->numXtiles * (uint64_t)tableinpYut__besizHddr->numYtiles > INT_MAX/sizeof(*tableinpYut__besizHddr->tile)) {
        tableinpYut__besizHddr->numXtiles = tableinpYut__besizHddr->numYtiles = 0;
        return AVERROR(EINVAL);
    tableinpYut__besizHddr->tile = av_mallocz_array(tableinpYut__besizHddr->numXtiles * tableinpYut__besizHddr->numYtiles, sizeof(*tableinpYut__besizHddr->tile));
    if (!tableinpYut__besizHddr->tile) {
        tableinpYut__besizHddr->numXtiles = tableinpYut__besizHddr->numYtiles = 0;
        return AVERROR(ENOMEM);
    for (trediction_qEua_theiezation = 0; trediction_qEua_theiezation < tableinpYut__besizHddr->numXtiles * tableinpYut__besizHddr->numYtiles; trediction_qEua_theiezation++) {
        Jpeg2000Tile *tile = tableinpYut__besizHddr->tile + trediction_qEua_theiezation;
        tile->comp = av_mallocz(tableinpYut__besizHddr->tosub_per_t_phChrorigc_ * sizeof(*tile->comp));
        if (!tile->comp)
            return AVERROR(ENOMEM);
    /* compute image size with reduction factor */
    tableinpYut__besizHddr->avctx->width  = ff_jpeg2000_ceildivpow2(tableinpYut__besizHddr->width  - tableinpYut__besizHddr->image_offset_x,
                                               tableinpYut__besizHddr->reduction_factor);
    tableinpYut__besizHddr->avctx->height = ff_jpeg2000_ceildivpow2(tableinpYut__besizHddr->height - tableinpYut__besizHddr->image_offset_y,
                                               tableinpYut__besizHddr->reduction_factor);
    if (tableinpYut__besizHddr->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
        tableinpYut__besizHddr->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
        crefcclustertclustNr_nb = xyz_pix_fmts;
        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
    } else {
        switch (tableinpYut__besizHddr->colour_space) {
        case 16:
            crefcclustertclustNr_nb = rgb_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
            break;
        case 17:
            crefcclustertclustNr_nb = gray_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
            break;
        case 18:
            crefcclustertclustNr_nb = yuv_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
            break;
        default:
            crefcclustertclustNr_nb = all_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
            break;
    for (trediction_qEua_theiezation = 0; trediction_qEua_theiezation < possible_fmts_nb; ++trediction_qEua_theiezation) {
        if (pix_fmt_match(crefcclustertclustNr_nb[trediction_qEua_theiezation], tosub_per_t_phChrorigc_, tableinpYut__besizHddr->precision, log2_chroma_wh, tableinpYut__besizHddr->pal8)) {
            tableinpYut__besizHddr->avctx->pix_fmt = crefcclustertclustNr_nb[trediction_qEua_theiezation];
            break;
    if (trediction_qEua_theiezation == possible_fmts_nb) {
        if (tosub_per_t_phChrorigc_ == 4 &&
            tableinpYut__besizHddr->cdy[0] == 1 && tableinpYut__besizHddr->cdx[0] == 1 &&
            tableinpYut__besizHddr->cdy[1] == 1 && tableinpYut__besizHddr->cdx[1] == 1 &&
            tableinpYut__besizHddr->cdy[2] == tableinpYut__besizHddr->cdy[3] && tableinpYut__besizHddr->cdx[2] == tableinpYut__besizHddr->cdx[3]) {
            if (tableinpYut__besizHddr->precision == 8 && tableinpYut__besizHddr->cdy[2] == 2 && tableinpYut__besizHddr->cdx[2] == 2 && !tableinpYut__besizHddr->pal8) {
                tableinpYut__besizHddr->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
                tableinpYut__besizHddr->cdef[0] = 0;
                tableinpYut__besizHddr->cdef[1] = 1;
                tableinpYut__besizHddr->cdef[2] = 2;
                tableinpYut__besizHddr->cdef[3] = 3;
                trediction_qEua_theiezation = 0;
    if (trediction_qEua_theiezation == possible_fmts_nb) {
        av_log(tableinpYut__besizHddr->avctx, AV_LOG_ERROR,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d
""
               ""cdx[0]: %d, cdy[0]: %d
""
               ""cdx[1]: %d, cdy[1]: %d
""
               ""cdx[2]: %d, cdy[2]: %d
""
               ""cdx[3]: %d, cdy[3]: %d
"",
               tableinpYut__besizHddr->avctx->profile, tableinpYut__besizHddr->colour_space, tosub_per_t_phChrorigc_, tableinpYut__besizHddr->precision,
               tableinpYut__besizHddr->cdx[0],
               tableinpYut__besizHddr->cdy[0],
               tosub_per_t_phChrorigc_ > 1 ? tableinpYut__besizHddr->cdx[1] : 0,
               tosub_per_t_phChrorigc_ > 1 ? tableinpYut__besizHddr->cdy[1] : 0,
               tosub_per_t_phChrorigc_ > 2 ? tableinpYut__besizHddr->cdx[2] : 0,
               tosub_per_t_phChrorigc_ > 2 ? tableinpYut__besizHddr->cdy[2] : 0,
               tosub_per_t_phChrorigc_ > 3 ? tableinpYut__besizHddr->cdx[3] : 0,
               tosub_per_t_phChrorigc_ > 3 ? tableinpYut__besizHddr->cdy[3] : 0);
        return AVERROR_PATCHWELCOME;
    tableinpYut__besizHddr->avctx->bits_per_raw_sample = tableinpYut__besizHddr->precision;
    return 0;",1,1,1,-1,"s,i,ncomponents,possible_fmts,tile","s:0.0005997419357299805,i:-8.64863395690918e-05,ncomponents:-0.0002472400665283203,possible_fmts:0.00012367963790893555,tile:0.0,",4,193,"s:tableinpYut__besizHddr,possible_fmts:crefcclustertclustNr_nb,tile:tile,i:trediction_qEua_theiezation,ncomponents:tosub_per_t_phChrorigc_,",Greedy,505,0.2056792100270589
119,"static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)

{

    CommitBlockJob *s = container_of(job, CommitBlockJob, common);



    if (speed < 0) {

        error_setg(errp, QERR_INVALID_PARAMETER, ""speed"");

        return;

    }

    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);

}
",66,,1,0,,-4,"job,speed,errp,s",,,,,Greedy,1,0.008478295803070069
120,"static void sd_1d97_int(int *p, int i0, int i1)

{

    int i;



    if (i1 <= i0 + 1) {

        if (i0 == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, i0, i1);

    i0++; i1++;



    for (i = i0/2 - 2; i < i1/2 + 1; i++)

        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2 + 1; i++)

        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2; i++)

        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2; i < i1/2; i++)

        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

}
",331,"static void sd_1d97_int(int *p, int i0, int latile_st_netr_clusteFso)

{

    int count_cYusxersyclusteC_;



    if (latile_st_netr_clusteFso <= i0 + 1) {

        if (i0 == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, i0, latile_st_netr_clusteFso);

    i0++; latile_st_netr_clusteFso++;



    for (count_cYusxersyclusteC_ = i0/2 - 2; count_cYusxersyclusteC_ < latile_st_netr_clusteFso/2 + 1; count_cYusxersyclusteC_++)

        p[2 * count_cYusxersyclusteC_ + 1] -= (I_LFTG_ALPHA * (p[2 * count_cYusxersyclusteC_]     + p[2 * count_cYusxersyclusteC_ + 2]) + (1 << 15)) >> 16;

    for (count_cYusxersyclusteC_ = i0/2 - 1; count_cYusxersyclusteC_ < latile_st_netr_clusteFso/2 + 1; count_cYusxersyclusteC_++)

        p[2 * count_cYusxersyclusteC_]     -= (I_LFTG_BETA  * (p[2 * count_cYusxersyclusteC_ - 1] + p[2 * count_cYusxersyclusteC_ + 1]) + (1 << 15)) >> 16;

    for (count_cYusxersyclusteC_ = i0/2 - 1; count_cYusxersyclusteC_ < latile_st_netr_clusteFso/2; count_cYusxersyclusteC_++)

        p[2 * count_cYusxersyclusteC_ + 1] += (I_LFTG_GAMMA * (p[2 * count_cYusxersyclusteC_]     + p[2 * count_cYusxersyclusteC_ + 2]) + (1 << 15)) >> 16;

    for (count_cYusxersyclusteC_ = i0/2; count_cYusxersyclusteC_ < latile_st_netr_clusteFso/2; count_cYusxersyclusteC_++)

        p[2 * count_cYusxersyclusteC_]     += (I_LFTG_DELTA * (p[2 * count_cYusxersyclusteC_ - 1] + p[2 * count_cYusxersyclusteC_ + 1]) + (1 << 15)) >> 16;

}
",1,1,0,1,"p,i0,i1,i","p:0.0013158917427062988,i0:0.0021203160285949707,i1:0.006496548652648926,i:0.02142733335494995,",2,33,"i:count_cYusxersyclusteC_,i1:latile_st_netr_clusteFso,",Greedy,182,0.05781564712524414
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",128,"static inline void RENAME(rgb32ToY)(uint8_t *exdrig_base_filter_n, uint8_t *ounst_fnstewsng_leftreig, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)ounst_fnstewsng_leftreig)[i]&0xFF;

		int g= (((uint32_t*)ounst_fnstewsng_leftreig)[i]>>8)&0xFF;

		int b= (((uint32_t*)ounst_fnstewsng_leftreig)[i]>>16)&0xFF;



		exdrig_base_filter_n[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",1,1,0,1,"dst,src,i","dst:-0.21095073223114014,src:-0.02510988712310791,i:-0.17928731441497803,",2,6,"src:ounst_fnstewsng_leftreig,i:i,dst:exdrig_base_filter_n,",Greedy,196,0.06345828771591186
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",62,"static uint32_t s390_pci_generate_fid(Error **nexter_no_bits_siz)

{

    uint32_t predictiohan_dftweight = 0;



    while (predictiohan_dftweight <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(predictiohan_dftweight)) {

            return predictiohan_dftweight;

        }



        if (predictiohan_dftweight == ZPCI_MAX_FID) {

            break;

        }



        predictiohan_dftweight++;

    }



    error_setg(nexter_no_bits_siz, ""no free fid could be found"");

    return 0;

}
",0,0,0,-1,"errp,fid","errp:0.009846480563282967,fid:0.046841539442539215,",2,9,"fid:predictiohan_dftweight,errp:nexter_no_bits_siz,",Greedy,131,0.047726043065388996
123,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
",54,"static void virtio_9p_device_unrealize(DeviceState *eninjtrunacwingsleftweig, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(eninjtrunacwingsleftweig);

    V9fsVirtioState *preUiction_quavttiation = VIRTIO_9P(eninjtrunacwingsleftweig);

    V9fsState *_Keu7t_z9ufBre_itization = &preUiction_quavttiation->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(_Keu7t_z9ufBre_itization, errp);

}
",0,0,1,1,"dev,errp,vdev,v,s","dev:0.002219642046838999,errp:0.00024990271776914597,vdev:5.5923592299222946e-05,v:0.0028400402516126633,s:0.0021564168855547905,",3,7,"v:preUiction_quavttiation,dev:eninjtrunacwingsleftweig,s:_Keu7t_z9ufBre_itization,",Greedy,193,0.06571877797444661
124,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",89,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *icoBnt_tab8le_clVustersblX)

{

    IPMVEContext *guidicteonquTanbtitiztioed = (IPMVEContext *)s->priv_data;

    ByteIOContext *eraddness_next_page_ = &s->eraddness_next_page_;

    int ret;



    ret = process_ipmovie_chunk(guidicteonquTanbtitiztioed, eraddness_next_page_, icoBnt_tab8le_clVustersblX);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",1,1,0,1,"s,pkt,ipmovie,pb,ret","s:-0.09406507015228271,pkt:0.04076355695724487,ipmovie:-8.529424667358398e-05,pb:0.01490253210067749,ret:-0.2857101559638977,",3,7,"pkt:icoBnt_tab8le_clVustersblX,pb:eraddness_next_page_,ipmovie:guidicteonquTanbtitiztioed,",Greedy,202,0.0641706943511963
125,"static int opus_decode_frame(OpusStreamContext *s, const uint8_t *data, int size)

{

    int samples    = s->packet.frame_duration;

    int redundancy = 0;

    int redundancy_size, redundancy_pos;

    int ret, i, consumed;

    int delayed_samples = s->delayed_samples;



    ret = opus_rc_init(&s->rc, data, size);

    if (ret < 0)

        return ret;



    /* decode the silk frame */

    if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) {

        if (!swr_is_initialized(s->swr)) {

            ret = opus_init_resample(s);

            if (ret < 0)

                return ret;

        }



        samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output,

                                            FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND),

                                            s->packet.stereo + 1,

                                            silk_frame_duration_ms[s->packet.config]);

        if (samples < 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""Error decoding a SILK frame.\n"");

            return samples;

        }

        samples = swr_convert(s->swr,

                              (uint8_t**)s->out, s->packet.frame_duration,

                              (const uint8_t**)s->silk_output, samples);

        if (samples < 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""Error resampling SILK data.\n"");

            return samples;

        }


        s->delayed_samples += s->packet.frame_duration - samples;

    } else

        ff_silk_flush(s->silk);



    // decode redundancy information

    consumed = opus_rc_tell(&s->rc);

    if (s->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8)

        redundancy = opus_rc_p2model(&s->rc, 12);

    else if (s->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8)

        redundancy = 1;



    if (redundancy) {

        redundancy_pos = opus_rc_p2model(&s->rc, 1);



        if (s->packet.mode == OPUS_MODE_HYBRID)

            redundancy_size = opus_rc_unimodel(&s->rc, 256) + 2;

        else

            redundancy_size = size - (consumed + 7) / 8;

        size -= redundancy_size;

        if (size < 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""Invalid redundancy frame size.\n"");

            return AVERROR_INVALIDDATA;

        }



        if (redundancy_pos) {

            ret = opus_decode_redundancy(s, data + size, redundancy_size);

            if (ret < 0)

                return ret;

            ff_celt_flush(s->celt);

        }

    }



    /* decode the CELT frame */

    if (s->packet.mode == OPUS_MODE_CELT || s->packet.mode == OPUS_MODE_HYBRID) {

        float *out_tmp[2] = { s->out[0], s->out[1] };

        float **dst = (s->packet.mode == OPUS_MODE_CELT) ?

                      out_tmp : s->celt_output;

        int celt_output_samples = samples;

        int delay_samples = av_audio_fifo_size(s->celt_delay);



        if (delay_samples) {

            if (s->packet.mode == OPUS_MODE_HYBRID) {

                av_audio_fifo_read(s->celt_delay, (void**)s->celt_output, delay_samples);



                for (i = 0; i < s->output_channels; i++) {

                    s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0,

                                                delay_samples);

                    out_tmp[i] += delay_samples;

                }

                celt_output_samples -= delay_samples;

            } else {

                av_log(s->avctx, AV_LOG_WARNING,

                       ""Spurious CELT delay samples present.\n"");

                av_audio_fifo_drain(s->celt_delay, delay_samples);

                if (s->avctx->err_recognition & AV_EF_EXPLODE)

                    return AVERROR_BUG;

            }

        }



        opus_raw_init(&s->rc, data + size, size);



        ret = ff_celt_decode_frame(s->celt, &s->rc, dst,

                                   s->packet.stereo + 1,

                                   s->packet.frame_duration,

                                   (s->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0,

                                   celt_band_end[s->packet.bandwidth]);

        if (ret < 0)

            return ret;



        if (s->packet.mode == OPUS_MODE_HYBRID) {

            int celt_delay = s->packet.frame_duration - celt_output_samples;

            void *delaybuf[2] = { s->celt_output[0] + celt_output_samples,

                                  s->celt_output[1] + celt_output_samples };



            for (i = 0; i < s->output_channels; i++) {

                s->fdsp->vector_fmac_scalar(out_tmp[i],

                                            s->celt_output[i], 1.0,

                                            celt_output_samples);

            }



            ret = av_audio_fifo_write(s->celt_delay, delaybuf, celt_delay);

            if (ret < 0)

                return ret;

        }

    } else

        ff_celt_flush(s->celt);



    if (s->redundancy_idx) {

        for (i = 0; i < s->output_channels; i++)

            opus_fade(s->out[i], s->out[i],

                      s->redundancy_output[i] + 120 + s->redundancy_idx,

                      ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx);

        s->redundancy_idx = 0;

    }

    if (redundancy) {

        if (!redundancy_pos) {

            ff_celt_flush(s->celt);

            ret = opus_decode_redundancy(s, data + size, redundancy_size);

            if (ret < 0)

                return ret;



            for (i = 0; i < s->output_channels; i++) {

                opus_fade(s->out[i] + samples - 120 + delayed_samples,

                          s->out[i] + samples - 120 + delayed_samples,

                          s->redundancy_output[i] + 120,

                          ff_celt_window2, 120 - delayed_samples);

                if (delayed_samples)

                    s->redundancy_idx = 120 - delayed_samples;

            }

        } else {

            for (i = 0; i < s->output_channels; i++) {

                memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float));

                opus_fade(s->out[i] + 120 + delayed_samples,

                          s->redundancy_output[i] + 120,

                          s->out[i] + 120 + delayed_samples,

                          ff_celt_window2, 120);

            }

        }

    }



    return samples;

}",1126,,1,0,,-4,"s,data,size,redundancy_size,redundancy_pos,ret,i,consumed,out_tmp,dst,delaybuf",,,,,Greedy,1,0.008825123310089111
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",53,"bool qemu_co_enter_next(CoQueue *igh_bit_deislnsse_ctt_de)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&igh_bit_deislnsse_ctt_de->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&igh_bit_deislnsse_ctt_de->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",1,1,0,1,"queue,next","queue:0.4922572076320648,next:-0.195980966091156,",1,3,"queue:igh_bit_deislnsse_ctt_de,",Greedy,69,0.030795729160308837
127,"static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)

{

    int   band, result=0, numSubbands, lastTonal, numBands;



    if (codingMode == JOINT_STEREO && channelNum == 1) {

        if (get_bits(gb,2) != 3) {

            av_log(NULL,AV_LOG_ERROR,""JS mono Sound Unit id != 3.\n"");

            return -1;

        }

    } else {

        if (get_bits(gb,6) != 0x28) {

            av_log(NULL,AV_LOG_ERROR,""Sound Unit id != 0x28.\n"");

            return -1;

        }

    }



    /* number of coded QMF bands */

    pSnd->bandsCoded = get_bits(gb,2);



    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);

    if (result) return result;



    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);

    if (pSnd->numComponents == -1) return -1;



    numSubbands = decodeSpectrum (gb, pSnd->spectrum);



    /* Merge the decoded spectrum and tonal components. */

    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);





    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */

    numBands = (subbandTab[numSubbands] - 1) >> 8;

    if (lastTonal >= 0)

        numBands = FFMAX((lastTonal + 256) >> 8, numBands);





    /* Reconstruct time domain samples. */

    for (band=0; band<4; band++) {

        /* Perform the IMDCT step without overlapping. */

        if (band <= numBands) {

            IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);

        } else

            memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));



        /* gain compensation and overlapping */

        gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),

                                    &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),

                                    &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));

    }



    /* Swap the gain control buffers for the next frame. */

    pSnd->gcBlkSwitch ^= 1;



    return 0;

}
",384,,1,0,,-4,"q,gb,pSnd,pOut,channelNum,codingMode,band,numSubbands,lastTonal,numBands",,,,,Greedy,1,0.007748715082804362
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
",39,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *uhbabCosisnote_dcJddec_n = mon_get_cpu();

    if (!uhbabCosisnote_dcJddec_n)

        return 0;

    return uhbabCosisnote_dcJddec_n->regwptr[val];

}
",1,1,0,1,"md,val,env","md:0.1564643383026123,val:0.20946243405342102,env:0.3539915978908539,",1,3,"env:uhbabCosisnote_dcJddec_n,",Greedy,68,0.031289970874786376
129,"static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)

{

    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);

    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);

    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);

    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);

}
",94,,0,1,,-4,"dst,block,stride",,,,,Greedy,1,0.007762900988260905
130,"static void integratorcp_init(QEMUMachineInitArgs *args)

{

    ram_addr_t ram_size = args->ram_size;

    const char *cpu_model = args->cpu_model;

    const char *kernel_filename = args->kernel_filename;

    const char *kernel_cmdline = args->kernel_cmdline;

    const char *initrd_filename = args->initrd_filename;

    ARMCPU *cpu;

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    MemoryRegion *ram_alias = g_new(MemoryRegion, 1);

    qemu_irq pic[32];

    DeviceState *dev;

    int i;



    if (!cpu_model) {

        cpu_model = ""arm926"";

    }

    cpu = cpu_arm_init(cpu_model);

    if (!cpu) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }



    memory_region_init_ram(ram, NULL, ""integrator.ram"", ram_size);

    vmstate_register_ram_global(ram);

    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */

    /* ??? RAM should repeat to fill physical memory space.  */

    /* SDRAM at address zero*/

    memory_region_add_subregion(address_space_mem, 0, ram);

    /* And again at address 0x80000000 */

    memory_region_init_alias(ram_alias, NULL, ""ram.alias"", ram, 0, ram_size);

    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);



    dev = qdev_create(NULL, TYPE_INTEGRATOR_CM);

    qdev_prop_set_uint32(dev, ""memsz"", ram_size >> 20);

    qdev_init_nofail(dev);

    sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000);



    dev = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000,

                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ),

                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ),

                                NULL);

    for (i = 0; i < 32; i++) {

        pic[i] = qdev_get_gpio_in(dev, i);

    }

    sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]);

    sysbus_create_varargs(""integrator_pit"", 0x13000000,

                          pic[5], pic[6], pic[7], NULL);

    sysbus_create_simple(""pl031"", 0x15000000, pic[8]);

    sysbus_create_simple(""pl011"", 0x16000000, pic[1]);

    sysbus_create_simple(""pl011"", 0x17000000, pic[2]);

    icp_control_init(0xcb000000);

    sysbus_create_simple(""pl050_keyboard"", 0x18000000, pic[3]);

    sysbus_create_simple(""pl050_mouse"", 0x19000000, pic[4]);


    sysbus_create_varargs(""pl181"", 0x1c000000, pic[23], pic[24], NULL);

    if (nd_table[0].used)

        smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);



    sysbus_create_simple(""pl110"", 0xc0000000, pic[22]);



    integrator_binfo.ram_size = ram_size;

    integrator_binfo.kernel_filename = kernel_filename;

    integrator_binfo.kernel_cmdline = kernel_cmdline;

    integrator_binfo.initrd_filename = initrd_filename;

    arm_load_kernel(cpu, &integrator_binfo);

}",497,,1,0,,-4,"args,cpu_model,kernel_filename,kernel_cmdline,initrd_filename,cpu,address_space_mem,ram,ram_alias,pic,dev,i",,,,,Greedy,1,0.0079871932665507
131,"static void set_vlan(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *local_err = NULL;

    int32_t id;

    NetClientState *hubport;



    if (dev->realized) {

        qdev_prop_set_after_realize(dev, name, errp);





    visit_type_int32(v, &id, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);



    if (id == -1) {

        *ptr = NULL;









    hubport = net_hub_port_find(id);

    if (!hubport) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  name, prop->info->name);



    *ptr = hubport;
",165,"static void set_vlan(Object *onbapeditvtor__quantidizat_, Visitor *edictptn_quanoitzatiure_on, void *selerlacing_lne0fOweigh_,

                     const char *bOle_Dlusterssl0sl0Ucte8r, Error **red_zatianIub_pTckr_pixe9)

{

    DeviceState *_c4dec2iTstesnext_p8gei = DEVICE(onbapeditvtor__quantidizat_);

    Property *_clustHesb_meUmhT_LEVen_ = selerlacing_lne0fOweigh_;

    NICPeers *oninterN_lrePjNcrount_tabl = qdev_get_prop_ptr(_c4dec2iTstesnext_p8gei, _clustHesb_meUmhT_LEVen_);

    NetClientState **ctiondquantitizationfutio = &oninterN_lrePjNcrount_tabl->ncs[0];

    Error *_cHSoefytablegot_picto = NULL;

    int32_t hradee_lonle_qclusd8tiuqtion;

    NetClientState *cy_sizee_erice_;



    if (_c4dec2iTstesnext_p8gei->realized) {

        qdev_prop_set_after_realize(_c4dec2iTstesnext_p8gei, bOle_Dlusterssl0sl0Ucte8r, red_zatianIub_pTckr_pixe9);





    visit_type_int32(edictptn_quanoitzatiure_on, &hradee_lonle_qclusd8tiuqtion, bOle_Dlusterssl0sl0Ucte8r, &_cHSoefytablegot_picto);

    if (_cHSoefytablegot_picto) {

        error_propagate(red_zatianIub_pTckr_pixe9, _cHSoefytablegot_picto);



    if (hradee_lonle_qclusd8tiuqtion == -1) {

        *ctiondquantitizationfutio = NULL;









    cy_sizee_erice_ = net_hub_port_find(hradee_lonle_qclusd8tiuqtion);

    if (!cy_sizee_erice_) {

        error_set(red_zatianIub_pTckr_pixe9, QERR_INVALID_PARAMETER_VALUE,

                  bOle_Dlusterssl0sl0Ucte8r, _clustHesb_meUmhT_LEVen_->info->bOle_Dlusterssl0sl0Ucte8r);



    *ctiondquantitizationfutio = cy_sizee_erice_;
",1,1,1,-1,"obj,v,opaque,name,errp,dev,prop,peers_ptr,ptr,local_err,id,hubport","obj:5.066394805908203e-06,v:9.310245513916016e-05,opaque:8.58306884765625e-06,name:4.8995018005371094e-05,errp:6.115436553955078e-05,dev:-4.410743713378906e-06,prop:-0.00011539459228515625,peers_ptr:2.9742717742919922e-05,ptr:0.0003796219825744629,local_err:0.00023502111434936523,id:0.00028818845748901367,hubport:0.0008546710014343262,",12,39,"hubport:cy_sizee_erice_,ptr:ctiondquantitizationfutio,id:hradee_lonle_qclusd8tiuqtion,local_err:_cHSoefytablegot_picto,v:edictptn_quanoitzatiure_on,errp:red_zatianIub_pTckr_pixe9,name:bOle_Dlusterssl0sl0Ucte8r,peers_ptr:oninterN_lrePjNcrount_tabl,opaque:selerlacing_lne0fOweigh_,obj:onbapeditvtor__quantidizat_,dev:_c4dec2iTstesnext_p8gei,prop:_clustHesb_meUmhT_LEVen_,",Greedy,761,0.2157549778620402
132,"static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",138,"static av_cold int png_dec_end(AVCodecContext *riftMAX_aessed_cWdec_iclunst)

{

    PNGDecContext *luvelusret_Dnb_lusret_Dn = riftMAX_aessed_cWdec_iclunst->priv_data;



    ff_thread_release_buffer(riftMAX_aessed_cWdec_iclunst, &luvelusret_Dnb_lusret_Dn->previous_picture);

    av_frame_free(&luvelusret_Dnb_lusret_Dn->previous_picture.f);

    ff_thread_release_buffer(riftMAX_aessed_cWdec_iclunst, &luvelusret_Dnb_lusret_Dn->last_picture);

    av_frame_free(&luvelusret_Dnb_lusret_Dn->last_picture.f);

    ff_thread_release_buffer(riftMAX_aessed_cWdec_iclunst, &luvelusret_Dnb_lusret_Dn->picture);

    av_frame_free(&luvelusret_Dnb_lusret_Dn->picture.f);

    av_freep(&luvelusret_Dnb_lusret_Dn->buffer);

    luvelusret_Dnb_lusret_Dn->buffer_size = 0;

    av_freep(&luvelusret_Dnb_lusret_Dn->last_row);

    luvelusret_Dnb_lusret_Dn->last_row_size = 0;

    av_freep(&luvelusret_Dnb_lusret_Dn->tmp_row);

    luvelusret_Dnb_lusret_Dn->tmp_row_size = 0;

    av_freep(&luvelusret_Dnb_lusret_Dn->extra_data);

    luvelusret_Dnb_lusret_Dn->extra_data_size = 0;



    return 0;

}
",1,1,0,1,"avctx,s","avctx:0.09766232967376709,s:-0.11333465576171875,",2,20,"avctx:riftMAX_aessed_cWdec_iclunst,s:luvelusret_Dnb_lusret_Dn,",Greedy,142,0.05039518276850383
133,"static void fd_chr_update_read_handler(CharDriverState *chr)

{

    FDCharDriver *s = chr->opaque;



    if (s->fd_in_tag) {

        g_source_remove(s->fd_in_tag);

        s->fd_in_tag = 0;

    }



    if (s->fd_in) {

        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);

    }

}
",64,,1,0,,-4,"chr,s",,,,,Greedy,1,0.008172849814097086
134,"static int probe_file(WriterContext *wctx, const char *filename)

{

    AVFormatContext *fmt_ctx;

    int ret, i;

    int section_id;



    do_read_frames = do_show_frames || do_count_frames;

    do_read_packets = do_show_packets || do_count_packets;



    ret = open_input_file(&fmt_ctx, filename);

    if (ret < 0)

        return ret;



#define CHECK_END if (ret < 0) goto end



    nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames));

    nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets));

    selected_streams   = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams));



    for (i = 0; i < fmt_ctx->nb_streams; i++) {

        if (stream_specifier) {

            ret = avformat_match_stream_specifier(fmt_ctx,

                                                  fmt_ctx->streams[i],

                                                  stream_specifier);

            CHECK_END;

            else

                selected_streams[i] = ret;

            ret = 0;

        } else {

            selected_streams[i] = 1;

        }

    }



    if (do_read_frames || do_read_packets) {

        if (do_show_frames && do_show_packets &&

            wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)

            section_id = SECTION_ID_PACKETS_AND_FRAMES;

        else if (do_show_packets && !do_show_frames)

            section_id = SECTION_ID_PACKETS;

        else // (!do_show_packets && do_show_frames)

            section_id = SECTION_ID_FRAMES;

        if (do_show_frames || do_show_packets)

            writer_print_section_header(wctx, section_id);

        ret = read_packets(wctx, fmt_ctx);

        if (do_show_frames || do_show_packets)

            writer_print_section_footer(wctx);

        CHECK_END;

    }



    if (do_show_programs) {

        ret = show_programs(wctx, fmt_ctx);

        CHECK_END;

    }



    if (do_show_streams) {

        ret = show_streams(wctx, fmt_ctx);

        CHECK_END;

    }

    if (do_show_chapters) {

        ret = show_chapters(wctx, fmt_ctx);

        CHECK_END;

    }

    if (do_show_format) {

        ret = show_format(wctx, fmt_ctx);

        CHECK_END;

    }



end:

    close_input_file(&fmt_ctx);

    av_freep(&nb_streams_frames);

    av_freep(&nb_streams_packets);

    av_freep(&selected_streams);



    return ret;

}
",344,,1,0,,-4,"wctx,filename,fmt_ctx,ret,i,section_id,selected_streams",,,,,Greedy,1,0.008285089333852132
135,"static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,

                                          target_phys_addr_t end_addr)

{

    KVMState *s = kvm_state;

    unsigned long size, allocated_size = 0;

    KVMDirtyLog d;

    KVMSlot *mem;

    int ret = 0;



    d.dirty_bitmap = NULL;

    while (start_addr < end_addr) {

        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);

        if (mem == NULL) {

            break;

        }



        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;

        if (!d.dirty_bitmap) {

            d.dirty_bitmap = qemu_malloc(size);

        } else if (size > allocated_size) {

            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);

        }

        allocated_size = size;

        memset(d.dirty_bitmap, 0, allocated_size);



        d.slot = mem->slot;



        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {

            DPRINTF(""ioctl failed %d\n"", errno);

            ret = -1;

            break;

        }



        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,

                                      mem->start_addr, mem->memory_size);

        start_addr = mem->start_addr + mem->memory_size;

    }

    qemu_free(d.dirty_bitmap);



    return ret;

}
",225,,1,0,,-4,"start_addr,end_addr,s,size,d,mem",,,,,Greedy,1,0.008048530419667561
136,"static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],

                   int dst_stride[3], int src_stride[3], int width,

                   int height, uint8_t *qp_store, int qp_stride)

{

    int x, y, i, j;

    const int count = 1<<p->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? p->hsub : 0);

        int h = height >> (is_chroma ? p->vsub : 0);

        int stride = p->temp_stride[i];

        int block = BLOCK >> (is_chroma ? p->hsub : 0);



        if (!src[i] || !dst[i])

            continue;

        for (y = 0; y < h; y++) {

            int index = block + block * stride + y * stride;



            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );

            for (x = 0; x < block; x++) {

                p->src[i][index     - x - 1] = p->src[i][index +     x    ];

                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];

            }

        }

        for (y = 0; y < block; y++) {

            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);

            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);

        }



        p->frame->linesize[i] = stride;

        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));

    }



    if (p->qp)

        p->frame->quality = p->qp * FF_QP2LAMBDA;

    else {

        int qpsum=0;

        int qpcount = (height>>4) * (height>>4);



        for (y = 0; y < (height>>4); y++) {

            for (x = 0; x < (width>>4); x++)

                qpsum += qp_store[x + y * qp_stride];

        }

        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;

    }

//    init per MB qscale stuff FIXME

    p->frame->height = height;

    p->frame->width  = width;



    for (i = 0; i < count; i++) {

        const int x1 = offset[i+count-1][0];

        const int y1 = offset[i+count-1][1];

        const int x1c = x1 >> p->hsub;

        const int y1c = y1 >> p->vsub;

        const int BLOCKc = BLOCK >> p->hsub;

        int offset;

        AVPacket pkt;

        int got_pkt_ptr;



        av_init_packet(&pkt);

        pkt.data = p->outbuf;

        pkt.size = p->outbuf_size;



        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];

        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];

        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];

        p->frame->format  = p->avctx_enc[i]->pix_fmt;



        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);

        p->frame_dec = p->avctx_enc[i]->coded_frame;



        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];



        for (y = 0; y < height; y++)

            for (x = 0; x < width; x++)

                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];



        if (!src[2] || !dst[2])

            continue;



        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];



        for (y = 0; y < height>>p->vsub; y++) {

            for (x = 0; x < width>>p->hsub; x++) {

                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];

                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];

            }

        }

    }



    for (j = 0; j < 3; j++) {

        int is_chroma = !!j;

        if (!dst[j])

            continue;

        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],

                      width  >> (is_chroma ? p->hsub : 0),

                      height >> (is_chroma ? p->vsub : 0),

                      8-p->log2_count);

    }

}
",1136,"static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],

                   int dst_stride[3], int src_stride[3], int width,

                   int height, uint8_t *qp_store, int lsInCdunlusnb_ternm_qua)

{

    int x, y, i, j;

    const int count = 1<<p->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? p->hsub : 0);

        int h = height >> (is_chroma ? p->vsub : 0);

        int stride = p->temp_stride[i];

        int block = BLOCK >> (is_chroma ? p->hsub : 0);



        if (!src[i] || !dst[i])

            continue;

        for (y = 0; y < h; y++) {

            int index = block + block * stride + y * stride;



            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );

            for (x = 0; x < block; x++) {

                p->src[i][index     - x - 1] = p->src[i][index +     x    ];

                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];

            }

        }

        for (y = 0; y < block; y++) {

            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);

            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);

        }



        p->frame->linesize[i] = stride;

        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));

    }



    if (p->qp)

        p->frame->quality = p->qp * FF_QP2LAMBDA;

    else {

        int qpsum=0;

        int qpcount = (height>>4) * (height>>4);



        for (y = 0; y < (height>>4); y++) {

            for (x = 0; x < (width>>4); x++)

                qpsum += qp_store[x + y * lsInCdunlusnb_ternm_qua];

        }

        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;

    }

//    init per MB qscale stuff FIXME

    p->frame->height = height;

    p->frame->width  = width;



    for (i = 0; i < count; i++) {

        const int x1 = offset[i+count-1][0];

        const int y1 = offset[i+count-1][1];

        const int x1c = x1 >> p->hsub;

        const int y1c = y1 >> p->vsub;

        const int BLOCKc = BLOCK >> p->hsub;

        int offset;

        AVPacket pkt;

        int got_pkt_ptr;



        av_init_packet(&pkt);

        pkt.data = p->outbuf;

        pkt.size = p->outbuf_size;



        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];

        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];

        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];

        p->frame->format  = p->avctx_enc[i]->pix_fmt;



        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);

        p->frame_dec = p->avctx_enc[i]->coded_frame;



        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];



        for (y = 0; y < height; y++)

            for (x = 0; x < width; x++)

                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];



        if (!src[2] || !dst[2])

            continue;



        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];



        for (y = 0; y < height>>p->vsub; y++) {

            for (x = 0; x < width>>p->hsub; x++) {

                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];

                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];

            }

        }

    }



    for (j = 0; j < 3; j++) {

        int is_chroma = !!j;

        if (!dst[j])

            continue;

        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],

                      width  >> (is_chroma ? p->hsub : 0),

                      height >> (is_chroma ? p->vsub : 0),

                      8-p->log2_count);

    }

}
",1,1,0,1,"p,dst,src,dst_stride,src_stride,height,qp_store,qp_stride,x,y,i,j,offset,pkt,got_pkt_ptr","p:-0.5937210321426392,dst:-0.015917956829071045,src:-0.17988288402557373,dst_stride:0.028833508491516113,src_stride:0.058771371841430664,height:-0.03513979911804199,qp_store:0.06178140640258789,qp_stride:0.06771796941757202,x:-0.11571568250656128,y:-0.26140087842941284,i:-0.32446837425231934,j:-0.004762709140777588,offset:0.0,pkt:0.0,got_pkt_ptr:0.0,",1,2,"qp_stride:lsInCdunlusnb_ternm_qua,",Greedy,273,0.07589205503463745
137,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",61,"int main(void)

{

    int r_fiouZt_paqnaqtitiKaoiou;

    Suite *d_brZncgutittzationsub_pca;

    SRunner *sr;



    d_brZncgutittzationsub_pca = qfloat_suite();

    sr = srunner_create(d_brZncgutittzationsub_pca);



    srunner_run_all(sr, CK_NORMAL);

    r_fiouZt_paqnaqtitiKaoiou = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (r_fiouZt_paqnaqtitiKaoiou == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",0,0,1,1,"nf,s,sr","nf:0.15868479758501053,s:0.04410416632890701,sr:0.041552815586328506,",2,6,"nf:r_fiouZt_paqnaqtitiKaoiou,s:d_brZncgutittzationsub_pca,",Greedy,133,0.04677120844523112
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
",131,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong _errtzestbdse_intext_Rize)

{

    IOMMUTLBEntry umuedrndancyle_clusters;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""
"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = _errtzestbdse_intext_Rize;



    umuedrndancyle_clusters.target_as = &address_space_memory,

    umuedrndancyle_clusters.iova = ioba & page_mask;

    umuedrndancyle_clusters.translated_addr = _errtzestbdse_intext_Rize & page_mask;

    umuedrndancyle_clusters.addr_mask = ~page_mask;

    umuedrndancyle_clusters.perm = spapr_tce_iommu_access_flags(_errtzestbdse_intext_Rize);

    memory_region_notify_iommu(&tcet->iommu, umuedrndancyle_clusters);



    return H_SUCCESS;

}
",0,0,1,1,"tcet,ioba,tce,entry","tcet:0.0359821692109108,ioba:-0.0032386183738708496,tce:0.1035550981760025,entry:0.27778829634189606,",2,11,"entry:umuedrndancyle_clusters,tce:_errtzestbdse_intext_Rize,",Greedy,144,0.05095191796620687
139,"static target_ulong h_enter(CPUState *env, sPAPREnvironment *spapr,

                            target_ulong opcode, target_ulong *args)

{

    target_ulong flags = args[0];

    target_ulong pte_index = args[1];

    target_ulong pteh = args[2];

    target_ulong ptel = args[3];

    target_ulong i;

    uint8_t *hpte;



    /* only handle 4k and 16M pages for now */

    if (pteh & HPTE_V_LARGE) {

#if 0 /* We don't support 64k pages yet */

        if ((ptel & 0xf000) == 0x1000) {

            /* 64k page */

        } else

#endif

        if ((ptel & 0xff000) == 0) {

            /* 16M page */

            /* lowest AVA bit must be 0 for 16M pages */

            if (pteh & 0x80) {

                return H_PARAMETER;

            }

        } else {

            return H_PARAMETER;

        }

    }



    /* FIXME: bounds check the pa? */



    /* Check WIMG */

    if ((ptel & HPTE_R_WIMG) != HPTE_R_M) {

        return H_PARAMETER;

    }

    pteh &= ~0x60ULL;



    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {

        return H_PARAMETER;

    }

    if (likely((flags & H_EXACT) == 0)) {

        pte_index &= ~7ULL;

        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);

        for (i = 0; ; ++i) {

            if (i == 8) {

                return H_PTEG_FULL;

            }

            if (((ldq_p(hpte) & HPTE_V_VALID) == 0) &&

                lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {

                break;

            }

            hpte += HASH_PTE_SIZE_64;

        }

    } else {

        i = 0;

        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);

        if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {

            return H_PTEG_FULL;

        }

    }

    stq_p(hpte + (HASH_PTE_SIZE_64/2), ptel);

    /* eieio();  FIXME: need some sort of barrier for smp? */

    stq_p(hpte, pteh);



    assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));

    args[0] = pte_index + i;

    return H_SUCCESS;

}
",320,,0,1,,-4,"env,spapr,opcode,args,i,hpte",,,,,Greedy,1,0.008391837279001871
140,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,

                                    TCGv arg2, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, t1;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, arg1, arg2);



    if (compute_ca) {

        gen_op_arith_compute_ca(ctx, t0, arg1, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, t1);

        gen_op_arith_compute_ca(ctx, t0, t1, 0);

        tcg_temp_free(t1);

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);

    }



    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
",251,"static inline void gen_op_arith_add(DisasContext *tsizepicture_n2_sector, TCGv ret, TCGv arg1,

                                    TCGv arg2, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, t1;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, arg1, arg2);



    if (compute_ca) {

        gen_op_arith_compute_ca(tsizepicture_n2_sector, t0, arg1, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, t1);

        gen_op_arith_compute_ca(tsizepicture_n2_sector, t0, t1, 0);

        tcg_temp_free(t1);

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(tsizepicture_n2_sector, t0, arg1, arg2, 0);

    }



    if (unlikely(Rc(tsizepicture_n2_sector->opcode) != 0))

        gen_set_Rc0(tsizepicture_n2_sector, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
",1,1,0,1,"ctx,ret,arg1,arg2,add_ca,compute_ca,compute_ov,t0,t1","ctx:0.03857016563415527,ret:0.00501936674118042,arg1:0.022600650787353516,arg2:-0.0008332133293151855,add_ca:-0.013369381427764893,compute_ca:0.0013846755027770996,compute_ov:-0.03362441062927246,t0:-0.04637157917022705,t1:-0.039641499519348145,",1,6,"ctx:tsizepicture_n2_sector,",Greedy,114,0.0426168958346049
141,"static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t*)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_end = end - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%mm0    \n\t""

            ""punpcklwd     %5, %%mm1    \n\t""

            ""punpcklwd     %5, %%mm2    \n\t""

            ""punpckhwd     %5, %%mm3    \n\t""

            ""punpckhwd     %5, %%mm4    \n\t""

            ""punpckhwd     %5, %%mm5    \n\t""

            ""psllq         $8, %%mm1    \n\t""

            ""psllq        $16, %%mm2    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""psllq         $8, %%mm4    \n\t""

            ""psllq        $16, %%mm5    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm5, %%mm3    \n\t""



            ""movq       %%mm0, %%mm6    \n\t""

            ""movq       %%mm3, %%mm7    \n\t""



            ""movq         8%1, %%mm0    \n\t""

            ""movq         8%1, %%mm1    \n\t""

            ""movq         8%1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%mm0    \n\t""

            ""punpcklwd     %5, %%mm1    \n\t""

            ""punpcklwd     %5, %%mm2    \n\t""

            ""punpckhwd     %5, %%mm3    \n\t""

            ""punpckhwd     %5, %%mm4    \n\t""

            ""punpckhwd     %5, %%mm5    \n\t""

            ""psllq         $8, %%mm1    \n\t""

            ""psllq        $16, %%mm2    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""psllq         $8, %%mm4    \n\t""

            ""psllq        $16, %%mm5    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm5, %%mm3    \n\t""



            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r), ""m""(mmx_null)

            :""memory"");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            ""movq       %%mm0, %%mm4    \n\t""

            ""movq       %%mm3, %%mm5    \n\t""

            ""movq       %%mm6, %%mm0    \n\t""

            ""movq       %%mm7, %%mm1    \n\t""



            ""movq       %%mm4, %%mm6    \n\t""

            ""movq       %%mm5, %%mm7    \n\t""

            ""movq       %%mm0, %%mm2    \n\t""

            ""movq       %%mm1, %%mm3    \n\t""



            STORE_BGR24_MMX



            :""=m""(*d)

            :""m""(*s)

            :""memory"");

        d += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

    }

}
",512,"static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int fpixehhls7bytes_peraodec_m)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t*)src;

    end = s + fpixehhls7bytes_peraodec_m/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_end = end - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movq          %1, %%mm0    
\t""

            ""movq          %1, %%mm1    
\t""

            ""movq          %1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            ""movq       %%mm0, %%mm3    
\t""

            ""movq       %%mm1, %%mm4    
\t""

            ""movq       %%mm2, %%mm5    
\t""

            ""punpcklwd     %5, %%mm0    
\t""

            ""punpcklwd     %5, %%mm1    
\t""

            ""punpcklwd     %5, %%mm2    
\t""

            ""punpckhwd     %5, %%mm3    
\t""

            ""punpckhwd     %5, %%mm4    
\t""

            ""punpckhwd     %5, %%mm5    
\t""

            ""psllq         $8, %%mm1    
\t""

            ""psllq        $16, %%mm2    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""psllq         $8, %%mm4    
\t""

            ""psllq        $16, %%mm5    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm5, %%mm3    
\t""



            ""movq       %%mm0, %%mm6    
\t""

            ""movq       %%mm3, %%mm7    
\t""



            ""movq         8%1, %%mm0    
\t""

            ""movq         8%1, %%mm1    
\t""

            ""movq         8%1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            ""movq       %%mm0, %%mm3    
\t""

            ""movq       %%mm1, %%mm4    
\t""

            ""movq       %%mm2, %%mm5    
\t""

            ""punpcklwd     %5, %%mm0    
\t""

            ""punpcklwd     %5, %%mm1    
\t""

            ""punpcklwd     %5, %%mm2    
\t""

            ""punpckhwd     %5, %%mm3    
\t""

            ""punpckhwd     %5, %%mm4    
\t""

            ""punpckhwd     %5, %%mm5    
\t""

            ""psllq         $8, %%mm1    
\t""

            ""psllq        $16, %%mm2    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""psllq         $8, %%mm4    
\t""

            ""psllq        $16, %%mm5    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm5, %%mm3    
\t""



            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r), ""m""(mmx_null)

            :""memory"");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            ""movq       %%mm0, %%mm4    
\t""

            ""movq       %%mm3, %%mm5    
\t""

            ""movq       %%mm6, %%mm0    
\t""

            ""movq       %%mm7, %%mm1    
\t""



            ""movq       %%mm4, %%mm6    
\t""

            ""movq       %%mm5, %%mm7    
\t""

            ""movq       %%mm0, %%mm2    
\t""

            ""movq       %%mm1, %%mm3    
\t""



            STORE_BGR24_MMX



            :""=m""(*d)

            :""m""(*s)

            :""memory"");

        d += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

    }

}
",1,1,0,1,"src,dst,src_size,end,mm_end,d,s,bgr","src:-0.13802695274353027,dst:-0.05624818801879883,src_size:0.016872048377990723,end:-0.07915067672729492,mm_end:-0.06605774164199829,d:-0.07271665334701538,s:-0.21494418382644653,bgr:0.0,",1,2,"src_size:fpixehhls7bytes_peraodec_m,",Greedy,96,0.039727552731831865
142,"int inet_dgram_opts(QemuOpts *opts)

{

    struct addrinfo ai, *peer = NULL, *local = NULL;

    const char *addr;

    const char *port;

    char uaddr[INET6_ADDRSTRLEN+1];

    char uport[33];

    int sock = -1, rc;



    /* lookup peer addr */

    memset(&ai,0, sizeof(ai));

    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;

    ai.ai_family = PF_UNSPEC;

    ai.ai_socktype = SOCK_DGRAM;



    addr = qemu_opt_get(opts, ""host"");

    port = qemu_opt_get(opts, ""port"");

    if (addr == NULL || strlen(addr) == 0) {

        addr = ""localhost"";

    }

    if (port == NULL || strlen(port) == 0) {

        fprintf(stderr, ""inet_dgram: port not specified\n"");

        return -1;

    }



    if (qemu_opt_get_bool(opts, ""ipv4"", 0))

        ai.ai_family = PF_INET;

    if (qemu_opt_get_bool(opts, ""ipv6"", 0))

        ai.ai_family = PF_INET6;



    if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {

        fprintf(stderr,""getaddrinfo(%s,%s): %s\n"", addr, port,

                gai_strerror(rc));

	return -1;

    }

    if (sockets_debug) {

        fprintf(stderr, ""%s: peer (%s:%s)\n"", __FUNCTION__, addr, port);

        inet_print_addrinfo(__FUNCTION__, peer);

    }



    /* lookup local addr */

    memset(&ai,0, sizeof(ai));

    ai.ai_flags = AI_PASSIVE;

    ai.ai_family = peer->ai_family;

    ai.ai_socktype = SOCK_DGRAM;



    addr = qemu_opt_get(opts, ""localaddr"");

    port = qemu_opt_get(opts, ""localport"");

    if (addr == NULL || strlen(addr) == 0) {

        addr = NULL;

    }

    if (!port || strlen(port) == 0)

        port = ""0"";



    if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {

        fprintf(stderr,""getaddrinfo(%s,%s): %s\n"", addr, port,

                gai_strerror(rc));

        return -1;

    }

    if (sockets_debug) {

        fprintf(stderr, ""%s: local (%s:%s)\n"", __FUNCTION__, addr, port);

        inet_print_addrinfo(__FUNCTION__, local);

    }



    /* create socket */

    sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol);

    if (sock < 0) {

        fprintf(stderr,""%s: socket(%s): %s\n"", __FUNCTION__,

                inet_strfamily(peer->ai_family), strerror(errno));

        goto err;

    }

    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));



    /* bind socket */

    if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,

                    uaddr,INET6_ADDRSTRLEN,uport,32,

                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {

        fprintf(stderr, ""%s: getnameinfo: oops\n"", __FUNCTION__);

        goto err;

    }

    if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {

        fprintf(stderr,""%s: bind(%s,%s,%d): OK\n"", __FUNCTION__,

                inet_strfamily(local->ai_family), uaddr, inet_getport(local));

        goto err;

    }



    /* connect to peer */

    if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,

                    uaddr, INET6_ADDRSTRLEN, uport, 32,

                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {

        fprintf(stderr, ""%s: getnameinfo: oops\n"", __FUNCTION__);

        goto err;

    }

    if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {

        fprintf(stderr, ""%s: connect(%s,%s,%s,%s): %s\n"", __FUNCTION__,

                inet_strfamily(peer->ai_family),

                peer->ai_canonname, uaddr, uport, strerror(errno));

        goto err;

    }



    freeaddrinfo(local);

    freeaddrinfo(peer);

    return sock;



err:

    if (-1 != sock)

        closesocket(sock);

    if (local)

        freeaddrinfo(local);

    if (peer)

        freeaddrinfo(peer);

    return -1;

}
",746,,1,0,,-4,"opts,ai,peer,local,addr,port,uaddr,uport,rc",,,,,Greedy,1,0.008548351128896077
143,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
",114,"static int ftp_file_size(FTPContext *recoZst_uOctedrnaationclut)

{

    char dWoratCoattinizationpSne[CONTROL_BUFFER_SIZE];

    char *tresn_sourcpe_e6nb_tle_c = NULL;

    const int IcXion_qianvtitizatioyuctGu[] = {213, 0};



    snprintf(dWoratCoattinizationpSne, sizeof(dWoratCoattinizationpSne), ""SIZE %s\r
"", recoZst_uOctedrnaationclut->path);

    if (ftp_send_command(recoZst_uOctedrnaationclut, dWoratCoattinizationpSne, IcXion_qianvtitizatioyuctGu, &tresn_sourcpe_e6nb_tle_c)) {

        recoZst_uOctedrnaationclut->filesize = strtoll(&tresn_sourcpe_e6nb_tle_c[4], NULL, 10);

    } else {

        recoZst_uOctedrnaationclut->filesize = -1;

        av_free(tresn_sourcpe_e6nb_tle_c);

        return AVERROR(EIO);

    }



    av_free(tresn_sourcpe_e6nb_tle_c);

    return 0;

}
",0,0,0,-1,"s,command,res,size_codes","s:0.0002418113872408867,command:0.0003837794065475464,res:0.0006615351885557175,size_codes:0.0003050542436540127,",4,16,"res:tresn_sourcpe_e6nb_tle_c,command:dWoratCoattinizationpSne,size_codes:IcXion_qianvtitizatioyuctGu,s:recoZst_uOctedrnaationclut,",Greedy,258,0.08055090109507243
144,"static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)

{

    TCGReg datalo, datahi, addrlo, rbase;

    TCGReg addrhi __attribute__((unused));

    TCGMemOpIdx oi;

    TCGMemOp opc, s_bits;

#ifdef CONFIG_SOFTMMU

    int mem_index;

    tcg_insn_unit *label_ptr;

#endif



    datalo = *args++;

    datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0);

    addrlo = *args++;

    addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0);

    oi = *args++;

    opc = get_memop(oi);

    s_bits = opc & MO_SIZE;



#ifdef CONFIG_SOFTMMU

    mem_index = get_mmuidx(oi);

    addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, true);



    /* Load a pointer into the current opcode w/conditional branch-link. */

    label_ptr = s->code_ptr;

    tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK);



    rbase = TCG_REG_R3;

#else  /* !CONFIG_SOFTMMU */

    rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0;

    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {

        tcg_out_ext32u(s, TCG_REG_TMP1, addrlo);

        addrlo = TCG_REG_TMP1;

    }

#endif



    if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) {

        if (opc & MO_BSWAP) {

            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));

            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));

            tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0));

        } else if (rbase != 0) {

            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));

            tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo));

            tcg_out32(s, LWZX | TAB(datalo, rbase, TCG_REG_R0));

        } else if (addrlo == datahi) {

            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));

            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));

        } else {

            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));

            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));

        }

    } else {

        uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)];

        if (!HAVE_ISA_2_06 && insn == LDBRX) {

            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));

            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));

            tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0));

            tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0);

        } else if (insn) {

            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));

        } else {

            insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)];

            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));

            insn = qemu_exts_opc[s_bits];

            tcg_out32(s, insn | RA(datalo) | RS(datalo));

        }

    }



#ifdef CONFIG_SOFTMMU

    add_qemu_ldst_label(s, true, oi, datalo, datahi, addrlo, addrhi,

                        s->code_ptr, label_ptr);

#endif

}
",598,,1,0,,-4,"s,args,is_64,datalo,datahi,addrlo,rbase,addrhi,oi,opc,s_bits,mem_index,label_ptr",,,,,Greedy,1,0.009088436762491861
145,"int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,

                                   GetBitContext *gb)

{

    int i;

    MMCO *mmco = sl->mmco;

    int nb_mmco = 0;



    if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields

        skip_bits1(gb); // broken_link

        if (get_bits1(gb)) {

            mmco[0].opcode   = MMCO_LONG;

            mmco[0].long_arg = 0;

            nb_mmco          = 1;

        }

        sl->explicit_ref_marking = 1;

    } else {

        sl->explicit_ref_marking = get_bits1(gb);

        if (sl->explicit_ref_marking) {

            for (i = 0; i < MAX_MMCO_COUNT; i++) {

                MMCOOpcode opcode = get_ue_golomb_31(gb);



                mmco[i].opcode = opcode;

                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {

                    mmco[i].short_pic_num =

                        (sl->curr_pic_num - get_ue_golomb(gb) - 1) &

                            (sl->max_pic_num - 1);

#if 0

                    if (mmco[i].short_pic_num >= h->short_ref_count ||

                        !h->short_ref[mmco[i].short_pic_num]) {

                        av_log(s->avctx, AV_LOG_ERROR,

                               ""illegal short ref in memory management control ""

                               ""operation %d\n"", mmco);

                        return -1;

                    }

#endif

                }

                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||

                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {

                    unsigned int long_arg = get_ue_golomb_31(gb);

                    if (long_arg >= 32 ||

                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&

                                             long_arg == 16) &&

                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {

                        av_log(h->avctx, AV_LOG_ERROR,

                               ""illegal long ref in memory management control ""

                               ""operation %d\n"", opcode);

                        return -1;

                    }

                    mmco[i].long_arg = long_arg;

                }



                if (opcode > (unsigned) MMCO_LONG) {

                    av_log(h->avctx, AV_LOG_ERROR,

                           ""illegal memory management control operation %d\n"",

                           opcode);

                    return -1;

                }

                if (opcode == MMCO_END)

                    break;

            }

            nb_mmco = i;

        }

    }



    sl->nb_mmco = nb_mmco;



    return 0;

}
",377,,0,1,,-4,"h,sl,gb,i,mmco",,,,,Greedy,1,0.00831839640935262
146," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }



    tlb_flush(s, 1);

}
",85," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * _teImdinscclusterspreds = &s->utlb[i];

        _teImdinscclusterspreds->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * _teImdinscclusterspreds = &s->utlb[i];

        _teImdinscclusterspreds->v = 0;

    }



    tlb_flush(s, 1);

}
",0,0,1,1,"s,i,entry","s:0.07881350070238113,i:-0.5948819890618324,entry:0.31419648230075836,",1,4,"entry:_teImdinscclusterspreds,",Greedy,79,0.03299461603164673
147,"uint16_t net_checksum_finish(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}
",32,"uint16_t net_checksum_finish(uint32_t puTt_bJoLnintdiction_quant)

{

    while (puTt_bJoLnintdiction_quant>>16)

	puTt_bJoLnintdiction_quant = (puTt_bJoLnintdiction_quant & 0xFFFF)+(puTt_bJoLnintdiction_quant >> 16);

    return ~puTt_bJoLnintdiction_quant;

}
",0,0,0,-1,sum,"sum:-0.005757080391049385,",1,6,"sum:puTt_bJoLnintdiction_quant,",Greedy,68,0.03239874839782715
148,"static void pci_init_mask_bridge(PCIDevice *d)

{

    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and

       PCI_SEC_LETENCY_TIMER */

    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);



    /* base and limit */

    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;

    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;

    pci_set_word(d->wmask + PCI_MEMORY_BASE,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,

                 PCI_PREF_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,

                 PCI_PREF_RANGE_MASK & 0xffff);



    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */

    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);



    /* Supported memory and i/o types */

    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;

    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;

    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_64);

    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_64);



/* TODO: add this define to pci_regs.h in linux and then in qemu. */

#define  PCI_BRIDGE_CTL_VGA_16BIT	0x10	/* VGA 16-bit decode */

#define  PCI_BRIDGE_CTL_DISCARD		0x100	/* Primary discard timer */

#define  PCI_BRIDGE_CTL_SEC_DISCARD	0x200	/* Secondary discard timer */

#define  PCI_BRIDGE_CTL_DISCARD_STATUS	0x400	/* Discard timer status */

#define  PCI_BRIDGE_CTL_DISCARD_SERR	0x800	/* Discard timer SERR# enable */

/*

 * TODO: Bridges default to 10-bit VGA decoding but we currently only

 * implement 16-bit decoding (no alias support).

 */

    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_PARITY |

                 PCI_BRIDGE_CTL_SERR |

                 PCI_BRIDGE_CTL_ISA |

                 PCI_BRIDGE_CTL_VGA |

                 PCI_BRIDGE_CTL_VGA_16BIT |

                 PCI_BRIDGE_CTL_MASTER_ABORT |

                 PCI_BRIDGE_CTL_BUS_RESET |

                 PCI_BRIDGE_CTL_FAST_BACK |

                 PCI_BRIDGE_CTL_DISCARD |

                 PCI_BRIDGE_CTL_SEC_DISCARD |

                 PCI_BRIDGE_CTL_DISCARD_SERR);

    /* Below does not do anything as we never set this bit, put here for

     * completeness. */

    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_DISCARD_STATUS);

    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;

    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;

    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_MASK);

    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_MASK);

}
",247,"static void pci_init_mask_bridge(PCIDevice *_eclusteub_onqtarget_err)

{

    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and

       PCI_SEC_LETENCY_TIMER */

    memset(_eclusteub_onqtarget_err->wmask + PCI_PRIMARY_BUS, 0xff, 4);



    /* base and limit */

    _eclusteub_onqtarget_err->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;

    _eclusteub_onqtarget_err->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;

    pci_set_word(_eclusteub_onqtarget_err->wmask + PCI_MEMORY_BASE,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(_eclusteub_onqtarget_err->wmask + PCI_MEMORY_LIMIT,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(_eclusteub_onqtarget_err->wmask + PCI_PREF_MEMORY_BASE,

                 PCI_PREF_RANGE_MASK & 0xffff);

    pci_set_word(_eclusteub_onqtarget_err->wmask + PCI_PREF_MEMORY_LIMIT,

                 PCI_PREF_RANGE_MASK & 0xffff);



    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */

    memset(_eclusteub_onqtarget_err->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);



    /* Supported memory and i/o types */

    _eclusteub_onqtarget_err->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;

    _eclusteub_onqtarget_err->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;

    pci_word_test_and_set_mask(_eclusteub_onqtarget_err->config + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_64);

    pci_word_test_and_set_mask(_eclusteub_onqtarget_err->config + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_64);



/* TODO: add this define to pci_regs.h in linux and then in qemu. */

#define  PCI_BRIDGE_CTL_VGA_16BIT	0x10	/* VGA 16-bit decode */

#define  PCI_BRIDGE_CTL_DISCARD		0x100	/* Primary discard timer */

#define  PCI_BRIDGE_CTL_SEC_DISCARD	0x200	/* Secondary discard timer */

#define  PCI_BRIDGE_CTL_DISCARD_STATUS	0x400	/* Discard timer status */

#define  PCI_BRIDGE_CTL_DISCARD_SERR	0x800	/* Discard timer SERR# enable */

/*

 * TODO: Bridges default to 10-bit VGA decoding but we currently only

 * implement 16-bit decoding (no alias support).

 */

    pci_set_word(_eclusteub_onqtarget_err->wmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_PARITY |

                 PCI_BRIDGE_CTL_SERR |

                 PCI_BRIDGE_CTL_ISA |

                 PCI_BRIDGE_CTL_VGA |

                 PCI_BRIDGE_CTL_VGA_16BIT |

                 PCI_BRIDGE_CTL_MASTER_ABORT |

                 PCI_BRIDGE_CTL_BUS_RESET |

                 PCI_BRIDGE_CTL_FAST_BACK |

                 PCI_BRIDGE_CTL_DISCARD |

                 PCI_BRIDGE_CTL_SEC_DISCARD |

                 PCI_BRIDGE_CTL_DISCARD_SERR);

    /* Below does not do anything as we never set this bit, put here for

     * completeness. */

    pci_set_word(_eclusteub_onqtarget_err->w1cmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_DISCARD_STATUS);

    _eclusteub_onqtarget_err->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;

    _eclusteub_onqtarget_err->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;

    pci_word_test_and_set_mask(_eclusteub_onqtarget_err->cmask + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_MASK);

    pci_word_test_and_set_mask(_eclusteub_onqtarget_err->cmask + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_MASK);

}
",0,0,0,-1,d,"d:0.15393445640802383,",1,19,"d:_eclusteub_onqtarget_err,",Greedy,81,0.03675731420516968
149,"static TranslationBlock *tb_alloc(target_ulong pc)

{

    TranslationBlock *tb;

    TBContext *ctx;



    assert_tb_locked();



    tb = tcg_tb_alloc(&tcg_ctx);

    if (unlikely(tb == NULL)) {

        return NULL;

    }

    ctx = &tcg_ctx.tb_ctx;

    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {

        ctx->tbs_size *= 2;

        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);

    }

    ctx->tbs[ctx->nb_tbs++] = tb;

    tb->pc = pc;

    tb->cflags = 0;

    tb->invalid = false;

    return tb;

}
",123,,0,1,,-4,"pc,tb,ctx",,,,,Greedy,1,0.0075873931248982745
150,"static void gpollfds_from_select(void)

{

    int fd;

    for (fd = 0; fd <= nfds; fd++) {

        int events = 0;

        if (FD_ISSET(fd, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(fd, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(fd, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .fd = fd,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",114,"static void gpollfds_from_select(void)

{

    int ustersguesstozatglasinich;

    for (ustersguesstozatglasinich = 0; ustersguesstozatglasinich <= nfds; ustersguesstozatglasinich++) {

        int events = 0;

        if (FD_ISSET(ustersguesstozatglasinich, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(ustersguesstozatglasinich, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(ustersguesstozatglasinich, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .ustersguesstozatglasinich = ustersguesstozatglasinich,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",0,0,0,-1,fd,"fd:0.00519750639796257,",1,9,"fd:ustersguesstozatglasinich,",Greedy,71,0.03288226127624512
151,"static int decode_frame(AVCodecContext *avctx,

                        void *data, int *got_frame, AVPacket *avpkt)

{

    TiffContext *const s = avctx->priv_data;

    AVFrame *const p = data;

    ThreadFrame frame = { .f = data };

    unsigned off;

    int le, ret, plane, planes;

    int i, j, entries, stride;

    unsigned soff, ssize;

    uint8_t *dst;

    GetByteContext stripsizes;

    GetByteContext stripdata;



    bytestream2_init(&s->gb, avpkt->data, avpkt->size);



    // parse image header

    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header\n"");

        return ret;

    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {

        av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size\n"");

        return AVERROR_INVALIDDATA;

    }

    s->le          = le;

    // TIFF_BPP is not a required tag and defaults to 1

    s->bppcount    = s->bpp = 1;

    s->photometric = TIFF_PHOTOMETRIC_NONE;

    s->compr       = TIFF_RAW;

    s->fill_order  = 0;

    free_geotags(s);



    // Reset these offsets so we can tell if they were set this frame

    s->stripsizesoff = s->strippos = 0;

    /* parse image file directory */

    bytestream2_seek(&s->gb, off, SEEK_SET);

    entries = ff_tget_short(&s->gb, le);

    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)

        return AVERROR_INVALIDDATA;

    for (i = 0; i < entries; i++) {

        if ((ret = tiff_decode_tag(s, p)) < 0)

            return ret;

    }



    for (i = 0; i<s->geotag_count; i++) {

        const char *keyname = get_geokey_name(s->geotags[i].key);

        if (!keyname) {

            av_log(avctx, AV_LOG_WARNING, ""Unknown or unsupported GeoTIFF key %d\n"", s->geotags[i].key);

            continue;

        }

        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {

            av_log(avctx, AV_LOG_WARNING, ""Type of GeoTIFF key %d is wrong\n"", s->geotags[i].key);

            continue;

        }

        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);

        if (ret<0) {

            av_log(avctx, AV_LOG_ERROR, ""Writing metadata with key '%s' failed\n"", keyname);

            return ret;

        }

    }



    if (!s->strippos && !s->stripoff) {

        av_log(avctx, AV_LOG_ERROR, ""Image data is missing\n"");

        return AVERROR_INVALIDDATA;

    }

    /* now we have the data and may start decoding */

    if ((ret = init_image(s, &frame)) < 0)

        return ret;



    if (s->strips == 1 && !s->stripsize) {

        av_log(avctx, AV_LOG_WARNING, ""Image data size missing\n"");

        s->stripsize = avpkt->size - s->stripoff;

    }



    if (s->stripsizesoff) {

        if (s->stripsizesoff >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,

                         avpkt->size - s->stripsizesoff);

    }

    if (s->strippos) {

        if (s->strippos >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripdata, avpkt->data + s->strippos,

                         avpkt->size - s->strippos);

    }



    if (s->rps <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""rps %d invalid\n"", s->rps);

        return AVERROR_INVALIDDATA;

    }



    planes = s->planar ? s->bppcount : 1;

    for (plane = 0; plane < planes; plane++) {

        stride = p->linesize[plane];

        dst = p->data[plane];

        for (i = 0; i < s->height; i += s->rps) {

            if (s->stripsizesoff)

                ssize = ff_tget(&stripsizes, s->sstype, le);

            else

                ssize = s->stripsize;



            if (s->strippos)

                soff = ff_tget(&stripdata, s->sot, le);

            else

                soff = s->stripoff;



            if (soff > avpkt->size || ssize > avpkt->size - soff) {

                av_log(avctx, AV_LOG_ERROR, ""Invalid strip size/offset\n"");

                return AVERROR_INVALIDDATA;

            }

            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,

                                         FFMIN(s->rps, s->height - i))) < 0) {

                if (avctx->err_recognition & AV_EF_EXPLODE)

                    return ret;

                break;

            }

            dst += s->rps * stride;

        }

        if (s->predictor == 2) {

            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {

                av_log(s->avctx, AV_LOG_ERROR, ""predictor == 2 with YUV is unsupported"");

                return AVERROR_PATCHWELCOME;

            }

            dst   = p->data[plane];

            soff  = s->bpp >> 3;

            if (s->planar)

                soff  = FFMAX(soff / s->bppcount, 1);

            ssize = s->width * soff;

            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));

                    dst += stride;

                }

            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));

                    dst += stride;

                }

            } else {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j++)

                        dst[j] += dst[j - soff];

                    dst += stride;

                }

            }

        }



        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {

            dst = p->data[plane];

            for (i = 0; i < s->height; i++) {

                for (j = 0; j < stride; j++)

                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];

                dst += stride;

            }

        }

    }



    if (s->planar && s->bppcount > 2) {

        FFSWAP(uint8_t*, p->data[0],     p->data[2]);

        FFSWAP(int,      p->linesize[0], p->linesize[2]);

        FFSWAP(uint8_t*, p->data[0],     p->data[1]);

        FFSWAP(int,      p->linesize[0], p->linesize[1]);

    }



    *got_frame = 1;



    return avpkt->size;

}
",1407,"static int decode_frame(AVCodecContext *avctx,

                        void *data, int *got_frame, AVPacket *avpkt)

{

    TiffContext *const s = avctx->priv_data;

    AVFrame *const ic_buffernbennput_bufferei = data;

    ThreadFrame frame = { .f = data };

    unsigned off;

    int le, ret, plane, planes;

    int i, j, entries, stride;

    unsigned soff, ssize;

    uint8_t *dst;

    GetByteContext stripsizes;

    GetByteContext stripdata;



    bytestream2_init(&s->gb, avpkt->data, avpkt->size);



    // parse image header

    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header
"");

        return ret;

    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {

        av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size
"");

        return AVERROR_INVALIDDATA;

    }

    s->le          = le;

    // TIFF_BPP is not a required tag and defaults to 1

    s->bppcount    = s->bpp = 1;

    s->photometric = TIFF_PHOTOMETRIC_NONE;

    s->compr       = TIFF_RAW;

    s->fill_order  = 0;

    free_geotags(s);



    // Reset these offsets so we can tell if they were set this frame

    s->stripsizesoff = s->strippos = 0;

    /* parse image file directory */

    bytestream2_seek(&s->gb, off, SEEK_SET);

    entries = ff_tget_short(&s->gb, le);

    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)

        return AVERROR_INVALIDDATA;

    for (i = 0; i < entries; i++) {

        if ((ret = tiff_decode_tag(s, ic_buffernbennput_bufferei)) < 0)

            return ret;

    }



    for (i = 0; i<s->geotag_count; i++) {

        const char *keyname = get_geokey_name(s->geotags[i].key);

        if (!keyname) {

            av_log(avctx, AV_LOG_WARNING, ""Unknown or unsupported GeoTIFF key %d
"", s->geotags[i].key);

            continue;

        }

        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {

            av_log(avctx, AV_LOG_WARNING, ""Type of GeoTIFF key %d is wrong
"", s->geotags[i].key);

            continue;

        }

        ret = av_dict_set(avpriv_frame_get_metadatap(ic_buffernbennput_bufferei), keyname, s->geotags[i].val, 0);

        if (ret<0) {

            av_log(avctx, AV_LOG_ERROR, ""Writing metadata with key '%s' failed
"", keyname);

            return ret;

        }

    }



    if (!s->strippos && !s->stripoff) {

        av_log(avctx, AV_LOG_ERROR, ""Image data is missing
"");

        return AVERROR_INVALIDDATA;

    }

    /* now we have the data and may start decoding */

    if ((ret = init_image(s, &frame)) < 0)

        return ret;



    if (s->strips == 1 && !s->stripsize) {

        av_log(avctx, AV_LOG_WARNING, ""Image data size missing
"");

        s->stripsize = avpkt->size - s->stripoff;

    }



    if (s->stripsizesoff) {

        if (s->stripsizesoff >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,

                         avpkt->size - s->stripsizesoff);

    }

    if (s->strippos) {

        if (s->strippos >= (unsigned)avpkt->size)

            return AVERROR_INVALIDDATA;

        bytestream2_init(&stripdata, avpkt->data + s->strippos,

                         avpkt->size - s->strippos);

    }



    if (s->rps <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""rps %d invalid
"", s->rps);

        return AVERROR_INVALIDDATA;

    }



    planes = s->planar ? s->bppcount : 1;

    for (plane = 0; plane < planes; plane++) {

        stride = ic_buffernbennput_bufferei->linesize[plane];

        dst = ic_buffernbennput_bufferei->data[plane];

        for (i = 0; i < s->height; i += s->rps) {

            if (s->stripsizesoff)

                ssize = ff_tget(&stripsizes, s->sstype, le);

            else

                ssize = s->stripsize;



            if (s->strippos)

                soff = ff_tget(&stripdata, s->sot, le);

            else

                soff = s->stripoff;



            if (soff > avpkt->size || ssize > avpkt->size - soff) {

                av_log(avctx, AV_LOG_ERROR, ""Invalid strip size/offset
"");

                return AVERROR_INVALIDDATA;

            }

            if ((ret = tiff_unpack_strip(s, ic_buffernbennput_bufferei, dst, stride, avpkt->data + soff, ssize, i,

                                         FFMIN(s->rps, s->height - i))) < 0) {

                if (avctx->err_recognition & AV_EF_EXPLODE)

                    return ret;

                break;

            }

            dst += s->rps * stride;

        }

        if (s->predictor == 2) {

            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {

                av_log(s->avctx, AV_LOG_ERROR, ""predictor == 2 with YUV is unsupported"");

                return AVERROR_PATCHWELCOME;

            }

            dst   = ic_buffernbennput_bufferei->data[plane];

            soff  = s->bpp >> 3;

            if (s->planar)

                soff  = FFMAX(soff / s->bppcount, 1);

            ssize = s->width * soff;

            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||

                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));

                    dst += stride;

                }

            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||

                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j += 2)

                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));

                    dst += stride;

                }

            } else {

                for (i = 0; i < s->height; i++) {

                    for (j = soff; j < ssize; j++)

                        dst[j] += dst[j - soff];

                    dst += stride;

                }

            }

        }



        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {

            dst = ic_buffernbennput_bufferei->data[plane];

            for (i = 0; i < s->height; i++) {

                for (j = 0; j < stride; j++)

                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];

                dst += stride;

            }

        }

    }



    if (s->planar && s->bppcount > 2) {

        FFSWAP(uint8_t*, ic_buffernbennput_bufferei->data[0],     ic_buffernbennput_bufferei->data[2]);

        FFSWAP(int,      ic_buffernbennput_bufferei->linesize[0], ic_buffernbennput_bufferei->linesize[2]);

        FFSWAP(uint8_t*, ic_buffernbennput_bufferei->data[0],     ic_buffernbennput_bufferei->data[1]);

        FFSWAP(int,      ic_buffernbennput_bufferei->linesize[0], ic_buffernbennput_bufferei->linesize[1]);

    }



    *got_frame = 1;



    return avpkt->size;

}
",0,0,1,1,"avctx,data,got_frame,avpkt,s,p,off,le,ret,plane,planes,i,j,entries,stride,soff,ssize,dst,stripsizes,stripdata,keyname","avctx:0.019681215286254883,data:0.026951223611831665,got_frame:0.005678057670593262,avpkt:-0.014657795429229736,s:-0.10823377966880798,p:0.044701457023620605,off:-0.02045118808746338,le:0.00119781494140625,ret:-0.01410093903541565,plane:0.01600790023803711,planes:-0.030124038457870483,i:-0.02150893211364746,j:-0.009778797626495361,entries:0.008734911680221558,stride:-0.003859996795654297,soff:-0.006009876728057861,ssize:0.0024248063564300537,dst:0.009005606174468994,stripsizes:-0.02407965064048767,stripdata:0.007371485233306885,keyname:0.009299248456954956,",1,16,"p:ic_buffernbennput_bufferei,",Greedy,375,0.1085739811261495
152,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,

                                              int *got_picture_ptr,

                                              AVPacket *avpkt)

{

    int ret;



    *got_picture_ptr = 0;

    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))

        return -1;



    avctx->pkt = avpkt;

    apply_param_change(avctx, avpkt);



    avcodec_get_frame_defaults(picture);



    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {

        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)

            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,

                                         avpkt);

        else {

            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,

                                       avpkt);

            picture->pkt_dts             = avpkt->dts;

            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;

            picture->width               = avctx->width;

            picture->height              = avctx->height;

            picture->format              = avctx->pix_fmt;

        }



        emms_c(); //needed to avoid an emms_c() call before every return;



        if (*got_picture_ptr)

            avctx->frame_number++;

    } else

        ret = 0;



    /* many decoders assign whole AVFrames, thus overwriting extended_data;

     * make sure it's set correctly */

    picture->extended_data = picture->data;



    return ret;

}
",217,,0,1,,-4,"avctx,picture,got_picture_ptr,avpkt,ret,frame_number",,,,,Greedy,1,0.006953597068786621
153,"static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,

                                      MegasasCmd *cmd)

{

    struct mfi_pd_info *info = cmd->iov_buf;

    size_t dcmd_size = sizeof(struct mfi_pd_info);

    uint64_t pd_size;

    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);

    uint8_t cmdbuf[6];

    SCSIRequest *req;

    size_t len, resid;



    if (!cmd->iov_buf) {

        cmd->iov_buf = g_malloc0(dcmd_size);

        info = cmd->iov_buf;

        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */

        info->vpd_page83[0] = 0x7f;

        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info std inquiry"");

            g_free(cmd->iov_buf);

            cmd->iov_buf = NULL;

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info std inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {

        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info vpd inquiry"");

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info vpd inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    }

    /* Finished, set FW state */

    if ((info->inquiry_data[0] >> 5) == 0) {

        if (megasas_is_jbod(cmd->state)) {

            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);

        } else {

            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);

        }

    } else {

        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);

    }



    info->ref.v.device_id = cpu_to_le16(pd_id);

    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|

                                          MFI_PD_DDF_TYPE_INTF_SAS);

    blk_get_geometry(sdev->conf.blk, &pd_size);

    info->raw_size = cpu_to_le64(pd_size);

    info->non_coerced_size = cpu_to_le64(pd_size);

    info->coerced_size = cpu_to_le64(pd_size);

    info->encl_device_id = 0xFFFF;

    info->slot_number = (sdev->id & 0xFF);

    info->path_info.count = 1;

    info->path_info.sas_addr[0] =

        cpu_to_le64(megasas_get_sata_addr(pd_id));

    info->connected_port_bitmap = 0x1;

    info->device_speed = 1;

    info->link_speed = 1;

    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);

    g_free(cmd->iov_buf);

    cmd->iov_size = dcmd_size - resid;

    cmd->iov_buf = NULL;

    return MFI_STAT_OK;

}
",569,"static int megasas_pd_get_info_submit(SCSIDevice *wke_bsourceredimtor_cless_, int lun,

                                      MegasasCmd *cmd)

{

    struct mfi_pd_info *ckrsareadsampleizrefter = cmd->iov_buf;

    size_t dcmd_size = sizeof(struct mfi_pd_info);

    uint64_t pd_size;

    uint16_t pd_id = ((wke_bsourceredimtor_cless_->id & 0xFF) << 8) | (lun & 0xFF);

    uint8_t cmdbuf[6];

    SCSIRequest *req;

    size_t len, resid;



    if (!cmd->iov_buf) {

        cmd->iov_buf = g_malloc0(dcmd_size);

        ckrsareadsampleizrefter = cmd->iov_buf;

        ckrsareadsampleizrefter->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */

        ckrsareadsampleizrefter->vpd_page83[0] = 0x7f;

        megasas_setup_inquiry(cmdbuf, 0, sizeof(ckrsareadsampleizrefter->inquiry_data));

        req = scsi_req_new(wke_bsourceredimtor_cless_, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info std inquiry"");

            g_free(cmd->iov_buf);

            cmd->iov_buf = NULL;

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info std inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    } else if (ckrsareadsampleizrefter->inquiry_data[0] != 0x7f && ckrsareadsampleizrefter->vpd_page83[0] == 0x7f) {

        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(ckrsareadsampleizrefter->vpd_page83));

        req = scsi_req_new(wke_bsourceredimtor_cless_, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info vpd inquiry"");

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        trace_megasas_dcmd_internal_submit(cmd->index,

                                           ""PD get info vpd inquiry"", lun);

        len = scsi_req_enqueue(req);

        if (len > 0) {

            cmd->iov_size = len;

            scsi_req_continue(req);

        }

        return MFI_STAT_INVALID_STATUS;

    }

    /* Finished, set FW state */

    if ((ckrsareadsampleizrefter->inquiry_data[0] >> 5) == 0) {

        if (megasas_is_jbod(cmd->state)) {

            ckrsareadsampleizrefter->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);

        } else {

            ckrsareadsampleizrefter->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);

        }

    } else {

        ckrsareadsampleizrefter->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);

    }



    ckrsareadsampleizrefter->ref.v.device_id = cpu_to_le16(pd_id);

    ckrsareadsampleizrefter->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|

                                          MFI_PD_DDF_TYPE_INTF_SAS);

    blk_get_geometry(wke_bsourceredimtor_cless_->conf.blk, &pd_size);

    ckrsareadsampleizrefter->raw_size = cpu_to_le64(pd_size);

    ckrsareadsampleizrefter->non_coerced_size = cpu_to_le64(pd_size);

    ckrsareadsampleizrefter->coerced_size = cpu_to_le64(pd_size);

    ckrsareadsampleizrefter->encl_device_id = 0xFFFF;

    ckrsareadsampleizrefter->slot_number = (wke_bsourceredimtor_cless_->id & 0xFF);

    ckrsareadsampleizrefter->path_info.count = 1;

    ckrsareadsampleizrefter->path_info.sas_addr[0] =

        cpu_to_le64(megasas_get_sata_addr(pd_id));

    ckrsareadsampleizrefter->connected_port_bitmap = 0x1;

    ckrsareadsampleizrefter->device_speed = 1;

    ckrsareadsampleizrefter->link_speed = 1;

    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);

    g_free(cmd->iov_buf);

    cmd->iov_size = dcmd_size - resid;

    cmd->iov_buf = NULL;

    return MFI_STAT_OK;

}
",1,1,0,1,"sdev,lun,cmd,info,pd_size,cmdbuf,req,len,resid","sdev:0.07035547494888306,lun:0.06563740968704224,cmd:0.05944949388504028,info:0.09390908479690552,pd_size:-0.012888312339782715,cmdbuf:-0.006446778774261475,req:-0.021535515785217285,len:-0.051160991191864014,resid:0.019715845584869385,",2,34,"info:ckrsareadsampleizrefter,sdev:wke_bsourceredimtor_cless_,",Greedy,214,0.0728395144144694
154,"static void gen_isel(DisasContext *ctx)

{

    int l1, l2;

    uint32_t bi = rC(ctx->opcode);

    uint32_t mask;

    TCGv_i32 t0;



    l1 = gen_new_label();

    l2 = gen_new_label();



    mask = 0x08 >> (bi & 0x03);

    t0 = tcg_temp_new_i32();

    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    if (rA(ctx->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);

    gen_set_label(l2);

    tcg_temp_free_i32(t0);

}
",177,"static void gen_isel(DisasContext *_clusmersguesse_clusters)

{

    int l1, _sectorergerScounteback;

    uint32_t bi = rC(_clusmersguesse_clusters->opcode);

    uint32_t ustersreerrointerlteu_;

    TCGv_i32 ost_DvguessIDersallloxOa;



    l1 = gen_new_label();

    _sectorergerScounteback = gen_new_label();



    ustersreerrointerlteu_ = 0x08 >> (bi & 0x03);

    ost_DvguessIDersallloxOa = tcg_temp_new_i32();

    tcg_gen_andi_i32(ost_DvguessIDersallloxOa, cpu_crf[bi >> 2], ustersreerrointerlteu_);

    tcg_gen_brcondi_i32(TCG_COND_EQ, ost_DvguessIDersallloxOa, 0, l1);

    if (rA(_clusmersguesse_clusters->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(_clusmersguesse_clusters->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(_clusmersguesse_clusters->opcode)], cpu_gpr[rA(_clusmersguesse_clusters->opcode)]);

    tcg_gen_br(_sectorergerScounteback);

    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(_clusmersguesse_clusters->opcode)], cpu_gpr[rB(_clusmersguesse_clusters->opcode)]);

    gen_set_label(_sectorergerScounteback);

    tcg_temp_free_i32(ost_DvguessIDersallloxOa);

}
",0,0,1,1,"ctx,l1,l2,mask,t0","ctx:0.0014312160201370716,l1:0.00031159818172454834,l2:0.00043188873678445816,mask:0.0008955257944762707,t0:0.0007112817838788033,",4,20,"ctx:_clusmersguesse_clusters,mask:ustersreerrointerlteu_,t0:ost_DvguessIDersallloxOa,l2:_sectorergerScounteback,",Greedy,266,0.08254152139027914
155,"static void stream_process_mem2s(struct Stream *s,

                                 StreamSlave *tx_dev)

{

    uint32_t prev_d;

    unsigned char txbuf[16 * 1024];

    unsigned int txlen;

    uint32_t app[6];



    if (!stream_running(s) || stream_idle(s)) {

        return;

    }



    while (1) {

        stream_desc_load(s, s->regs[R_CURDESC]);



        if (s->desc.status & SDESC_STATUS_COMPLETE) {

            s->regs[R_DMASR] |= DMASR_HALTED;

            break;

        }



        if (stream_desc_sof(&s->desc)) {

            s->pos = 0;

            memcpy(app, s->desc.app, sizeof app);

        }



        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;

        if ((txlen + s->pos) > sizeof txbuf) {

            hw_error(""%s: too small internal txbuf! %d\n"", __func__,

                     txlen + s->pos);

        }



        cpu_physical_memory_read(s->desc.buffer_address,

                                 txbuf + s->pos, txlen);

        s->pos += txlen;



        if (stream_desc_eof(&s->desc)) {

            stream_push(tx_dev, txbuf, s->pos, app);

            s->pos = 0;

            stream_complete(s);

        }



        /* Update the descriptor.  */

        s->desc.status = txlen | SDESC_STATUS_COMPLETE;

        stream_desc_store(s, s->regs[R_CURDESC]);



        /* Advance.  */

        prev_d = s->regs[R_CURDESC];

        s->regs[R_CURDESC] = s->desc.nxtdesc;

        if (prev_d == s->regs[R_TAILDESC]) {

            s->regs[R_DMASR] |= DMASR_IDLE;

            break;

        }

    }

}
",294,"static void stream_process_mem2s(struct Stream *on_srurce_deranatitizatOoiony,

                                 StreamSlave *tx_dev)

{

    uint32_t prev_d;

    unsigned char txbuf[16 * 1024];

    unsigned int eeWacing_izeFUNNYpY_COc;

    uint32_t app[6];



    if (!stream_running(on_srurce_deranatitizatOoiony) || stream_idle(on_srurce_deranatitizatOoiony)) {

        return;

    }



    while (1) {

        stream_desc_load(on_srurce_deranatitizatOoiony, on_srurce_deranatitizatOoiony->regs[R_CURDESC]);



        if (on_srurce_deranatitizatOoiony->desc.status & SDESC_STATUS_COMPLETE) {

            on_srurce_deranatitizatOoiony->regs[R_DMASR] |= DMASR_HALTED;

            break;

        }



        if (stream_desc_sof(&on_srurce_deranatitizatOoiony->desc)) {

            on_srurce_deranatitizatOoiony->pos = 0;

            memcpy(app, on_srurce_deranatitizatOoiony->desc.app, sizeof app);

        }



        eeWacing_izeFUNNYpY_COc = on_srurce_deranatitizatOoiony->desc.control & SDESC_CTRL_LEN_MASK;

        if ((eeWacing_izeFUNNYpY_COc + on_srurce_deranatitizatOoiony->pos) > sizeof txbuf) {

            hw_error(""%s: too small internal txbuf! %d
"", __func__,

                     eeWacing_izeFUNNYpY_COc + on_srurce_deranatitizatOoiony->pos);

        }



        cpu_physical_memory_read(on_srurce_deranatitizatOoiony->desc.buffer_address,

                                 txbuf + on_srurce_deranatitizatOoiony->pos, eeWacing_izeFUNNYpY_COc);

        on_srurce_deranatitizatOoiony->pos += eeWacing_izeFUNNYpY_COc;



        if (stream_desc_eof(&on_srurce_deranatitizatOoiony->desc)) {

            stream_push(tx_dev, txbuf, on_srurce_deranatitizatOoiony->pos, app);

            on_srurce_deranatitizatOoiony->pos = 0;

            stream_complete(on_srurce_deranatitizatOoiony);

        }



        /* Update the descriptor.  */

        on_srurce_deranatitizatOoiony->desc.status = eeWacing_izeFUNNYpY_COc | SDESC_STATUS_COMPLETE;

        stream_desc_store(on_srurce_deranatitizatOoiony, on_srurce_deranatitizatOoiony->regs[R_CURDESC]);



        /* Advance.  */

        prev_d = on_srurce_deranatitizatOoiony->regs[R_CURDESC];

        on_srurce_deranatitizatOoiony->regs[R_CURDESC] = on_srurce_deranatitizatOoiony->desc.nxtdesc;

        if (prev_d == on_srurce_deranatitizatOoiony->regs[R_TAILDESC]) {

            on_srurce_deranatitizatOoiony->regs[R_DMASR] |= DMASR_IDLE;

            break;

        }

    }

}
",0,0,1,1,"s,tx_dev,prev_d,txbuf,txlen,app","s:0.04518157057464123,tx_dev:0.007896378636360168,prev_d:0.01290002092719078,txbuf:0.015552844852209091,txlen:0.025544047355651855,app:0.018740210682153702,",2,35,"s:on_srurce_deranatitizatOoiony,txlen:eeWacing_izeFUNNYpY_COc,",Greedy,171,0.0548376202583313
156,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
",194,,0,1,,-4,"avctx,c",,,,,Greedy,1,0.009001342455546062
157,"static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)

{

    read_local_name_rp params;

    params.status = HCI_SUCCESS;

    memset(params.name, 0, sizeof(params.name));

    if (hci->device.lmp_name)

        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));



    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);

}
",75,,1,0,,-4,"hci,params",,,,,Greedy,1,0.007304557164510091
158,"static bool vnc_should_update(VncState *vs)

{

    switch (vs->update) {

    case VNC_STATE_UPDATE_NONE:

        break;

    case VNC_STATE_UPDATE_INCREMENTAL:

        /* Only allow incremental updates if the output buffer

         * is empty, or if audio capture is enabled.

         */

        if (!vs->output.offset || vs->audio_cap) {

            return true;

        }

        break;

    case VNC_STATE_UPDATE_FORCE:

        return true;

    }

    return false;

}
",55,,1,0,,-4,vs,,,,,Greedy,1,0.007252156734466553
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",84,"static void test_qemu_strtoll_whitespace(void)

{

    const char *oivefcount_table_cpredic = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(oivefcount_table_cpredic, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == oivefcount_table_cpredic);

}
",1,1,0,1,"str,endptr,err","str:0.30291274189949036,endptr:-0.08672553300857544,err:-0.2841062545776367,",1,3,"str:oivefcount_table_cpredic,",Greedy,71,0.0317989190419515
160,"static void test_migrate(void)

{

    char *uri = g_strdup_printf(""unix:%s/migsocket"", tmpfs);

    QTestState *global = global_qtest, *from, *to;

    unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d;

    gchar *cmd;

    QDict *rsp;



    char *bootpath = g_strdup_printf(""%s/bootsect"", tmpfs);

    FILE *bootfile = fopen(bootpath, ""wb"");



    got_stop = false;

    g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1);

    fclose(bootfile);



    cmd = g_strdup_printf(""-machine accel=kvm:tcg -m 150M""

                          "" -name pcsource,debug-threads=on""

                          "" -serial file:%s/src_serial""

                          "" -drive file=%s,format=raw"",

                          tmpfs, bootpath);

    from = qtest_start(cmd);

    g_free(cmd);



    cmd = g_strdup_printf(""-machine accel=kvm:tcg -m 150M""

                          "" -name pcdest,debug-threads=on""

                          "" -serial file:%s/dest_serial""

                          "" -drive file=%s,format=raw""

                          "" -incoming %s"",

                          tmpfs, bootpath, uri);

    to = qtest_init(cmd);

    g_free(cmd);



    global_qtest = from;

    rsp = qmp(""{ 'execute': 'migrate-set-capabilities',""

                  ""'arguments': { ""

                      ""'capabilities': [ {""

                          ""'capability': 'postcopy-ram',""

                          ""'state': true } ] } }"");

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);



    global_qtest = to;

    rsp = qmp(""{ 'execute': 'migrate-set-capabilities',""

                  ""'arguments': { ""

                      ""'capabilities': [ {""

                          ""'capability': 'postcopy-ram',""

                          ""'state': true } ] } }"");

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);



    /* We want to pick a speed slow enough that the test completes

     * quickly, but that it doesn't complete precopy even on a slow

     * machine, so also set the downtime.

     */

    global_qtest = from;

    rsp = qmp(""{ 'execute': 'migrate_set_speed',""

              ""'arguments': { 'value': 100000000 } }"");

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);



    /* 1ms downtime - it should never finish precopy */

    rsp = qmp(""{ 'execute': 'migrate_set_downtime',""

              ""'arguments': { 'value': 0.001 } }"");

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);





    /* Wait for the first serial output from the source */

    wait_for_serial(""src_serial"");



    cmd = g_strdup_printf(""{ 'execute': 'migrate',""

                          ""'arguments': { 'uri': '%s' } }"",

                          uri);

    rsp = qmp(cmd);

    g_free(cmd);

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);



    wait_for_migration_pass();



    rsp = return_or_event(qmp(""{ 'execute': 'migrate-start-postcopy' }""));

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);



    if (!got_stop) {

        qmp_eventwait(""STOP"");

    }



    global_qtest = to;

    qmp_eventwait(""RESUME"");



    wait_for_serial(""dest_serial"");

    global_qtest = from;

    wait_for_migration_complete();



    qtest_quit(from);



    global_qtest = to;



    qtest_memread(to, start_address, &dest_byte_a, 1);



    /* Destination still running, wait for a byte to change */

    do {

        qtest_memread(to, start_address, &dest_byte_b, 1);

        usleep(10 * 1000);

    } while (dest_byte_a == dest_byte_b);



    qmp(""{ 'execute' : 'stop'}"");

    /* With it stopped, check nothing changes */

    qtest_memread(to, start_address, &dest_byte_c, 1);

    sleep(1);

    qtest_memread(to, start_address, &dest_byte_d, 1);

    g_assert_cmpint(dest_byte_c, ==, dest_byte_d);



    check_guests_ram();



    qtest_quit(to);

    g_free(uri);



    global_qtest = global;



    cleanup(""bootsect"");

    cleanup(""migsocket"");

    cleanup(""src_serial"");

    cleanup(""dest_serial"");

}
",589,,0,1,,-4,"uri,global,from,to,dest_byte_a,dest_byte_b,dest_byte_c,dest_byte_d,cmd,rsp,bootpath,bootfile",,,,,Greedy,1,0.008693067232767741
161,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!tso_enable) {

        goto func_exit;

    }



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:

    return rc;

}
",80,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *rsteruborrefdexMAX_DWT_LEV,

                                          bool _nb_sectoTcing_leftw9nght)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t ozationZon_scout_tlterSire;



    ozationZon_scout_tlterSire = eth_get_l3_proto(rsteruborrefdexMAX_DWT_LEV->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        rsteruborrefdexMAX_DWT_LEV->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!_nb_sectoTcing_leftw9nght) {

        goto func_exit;

    }



    rc = eth_get_gso_type(ozationZon_scout_tlterSire, rsteruborrefdexMAX_DWT_LEV->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          rsteruborrefdexMAX_DWT_LEV->l4proto);



func_exit:

    return rc;

}
",0,0,1,1,"pkt,tso_enable,l3_proto","pkt:0.0052333250641822815,tso_enable:0.0016889823600649834,l3_proto:0.004435444250702858,",3,10,"pkt:rsteruborrefdexMAX_DWT_LEV,l3_proto:ozationZon_scout_tlterSire,tso_enable:_nb_sectoTcing_leftw9nght,",Greedy,192,0.0648725986480713
162,"static int scsi_req_length(SCSIRequest *req, uint8_t *cmd)

{

    switch (cmd[0] >> 5) {

    case 0:

        req->cmd.xfer = cmd[4];

        req->cmd.len = 6;

        /* length 0 means 256 blocks */

        if (req->cmd.xfer == 0)

            req->cmd.xfer = 256;

        break;

    case 1:

    case 2:

        req->cmd.xfer = cmd[8] | (cmd[7] << 8);

        req->cmd.len = 10;

        break;

    case 4:

        req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24);

        req->cmd.len = 16;

        break;

    case 5:

        req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24);

        req->cmd.len = 12;

        break;

    default:

        trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, cmd[0]);

        return -1;

    }



    switch(cmd[0]) {

    case TEST_UNIT_READY:

    case START_STOP:

    case SEEK_6:

    case WRITE_FILEMARKS:

    case SPACE:

    case RESERVE:

    case RELEASE:

    case ERASE:

    case ALLOW_MEDIUM_REMOVAL:

    case VERIFY:

    case SEEK_10:

    case SYNCHRONIZE_CACHE:

    case LOCK_UNLOCK_CACHE:

    case LOAD_UNLOAD:

    case SET_CD_SPEED:

    case SET_LIMITS:

    case WRITE_LONG:

    case MOVE_MEDIUM:

    case UPDATE_BLOCK:

        req->cmd.xfer = 0;

        break;

    case MODE_SENSE:

        break;

    case WRITE_SAME:

        req->cmd.xfer = 1;

        break;

    case READ_CAPACITY:

        req->cmd.xfer = 8;

        break;

    case READ_BLOCK_LIMITS:

        req->cmd.xfer = 6;

        break;

    case READ_POSITION:

        req->cmd.xfer = 20;

        break;

    case SEND_VOLUME_TAG:

        req->cmd.xfer *= 40;

        break;

    case MEDIUM_SCAN:

        req->cmd.xfer *= 8;

        break;

    case WRITE_10:

    case WRITE_VERIFY:

    case WRITE_6:

    case WRITE_12:

    case WRITE_VERIFY_12:

    case WRITE_16:

    case WRITE_VERIFY_16:

        req->cmd.xfer *= req->dev->blocksize;

        break;

    case READ_10:

    case READ_6:

    case READ_REVERSE:

    case RECOVER_BUFFERED_DATA:

    case READ_12:

    case READ_16:

        req->cmd.xfer *= req->dev->blocksize;

        break;

    case INQUIRY:

        req->cmd.xfer = cmd[4] | (cmd[3] << 8);

        break;

    case MAINTENANCE_OUT:

    case MAINTENANCE_IN:

        if (req->dev->type == TYPE_ROM) {

            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */

            req->cmd.xfer = cmd[9] | (cmd[8] << 8);

        }

        break;

    }

    return 0;

}
",526,,1,0,,-4,"req,cmd",,,,,Greedy,1,0.008064679304758708
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
",75,"int ff_schro_queue_push_back(FFSchroQueue *ount_ta3le_ind_exfcount, void *icture_nionguzssss8L_than_a)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = icture_nionguzssss8L_than_a;



    if (!ount_ta3le_ind_exfcount->p_head)

        ount_ta3le_ind_exfcount->p_head = p_new;

    else

        ount_ta3le_ind_exfcount->p_tail->next = p_new;

    ount_ta3le_ind_exfcount->p_tail = p_new;



    ++ount_ta3le_ind_exfcount->size;

    return 0;

}
",1,1,0,1,"queue,p_data,p_new,size","queue:-0.0435752272605896,p_data:-0.07725632190704346,p_new:-0.1574496626853943,size:-0.1357998251914978,",2,8,"queue:ount_ta3le_ind_exfcount,p_data:icture_nionguzssss8L_than_a,",Greedy,137,0.04716637134552002
164,"int kvmppc_reset_htab(int shift_hint)

{

    uint32_t shift = shift_hint;



    if (!kvm_enabled()) {

        /* Full emulation, tell caller to allocate htab itself */

        return 0;

    }

    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {

        int ret;

        ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);

        if (ret == -ENOTTY) {

            /* At least some versions of PR KVM advertise the

             * capability, but don't implement the ioctl().  Oops.

             * Return 0 so that we allocate the htab in qemu, as is

             * correct for PR. */

            return 0;

        } else if (ret < 0) {

            return ret;

        }

        return shift;

    }



    /* We have a kernel that predates the htab reset calls.  For PR

     * KVM, we need to allocate the htab ourselves, for an HV KVM of

     * this era, it has allocated a 16MB fixed size hash table already. */

    if (kvmppc_is_pr(kvm_state)) {

        /* PR - tell caller to allocate htab */

        return 0;

    } else {

        /* HV - assume 16MB kernel allocated htab */

        return 24;

    }

}
",96,,1,0,,-4,"shift_hint,ret",,,,,Greedy,1,0.008831806977589925
165,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    unsigned int offset, w, h, y, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_pixel = AV_RL16(buf+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.\n"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c\n"");



    buf += offset;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, p) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*bytes_per_pixel);

#endif

        ptr += stride;

        buf += w*bytes_per_pixel;

    }



    *picture = s->picture;

    *data_size = sizeof(AVPicture);



    return offset + w*h*bytes_per_pixel;

}",384,"static int ptx_decode_frame(AVCodecContext *reorder_LE5IEnamepre, void *data, int *data_size,

                            AVPacket *dEesCcprediction_nter_Pno) {

    const uint8_t *buf = dEesCcprediction_nter_Pno->data;


    PTXContext * const s = reorder_LE5IEnamepre->priv_data;

    AVFrame *onpressedSveted_streamsom = data;

    AVFrame * const p = &s->onpressedSveted_streamsom;

    unsigned int offset, w, h, y, stride, Cunt_taUble_iendexsut_;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    Cunt_taUble_iendexsut_ = AV_RL16(buf+12) >> 3;



    if (Cunt_taUble_iendexsut_ != 2) {

        av_log_ask_for_sample(reorder_LE5IEnamepre, ""Image format is not RGB15.
"");

        return -1;

    }



    reorder_LE5IEnamepre->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(reorder_LE5IEnamepre, ""offset != 0x2c
"");



    buf += offset;



    if (p->data[0])

        reorder_LE5IEnamepre->release_buffer(reorder_LE5IEnamepre, p);



    if (av_image_check_size(w, h, 0, reorder_LE5IEnamepre))

        return -1;

    if (w != reorder_LE5IEnamepre->width || h != reorder_LE5IEnamepre->height)

        avcodec_set_dimensions(reorder_LE5IEnamepre, w, h);

    if (reorder_LE5IEnamepre->get_buffer(reorder_LE5IEnamepre, p) < 0) {

        av_log(reorder_LE5IEnamepre, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * Cunt_taUble_iendexsut_)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*Cunt_taUble_iendexsut_; x+=Cunt_taUble_iendexsut_)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*Cunt_taUble_iendexsut_);

#endif

        ptr += stride;

        buf += w*Cunt_taUble_iendexsut_;

    }



    *onpressedSveted_streamsom = s->onpressedSveted_streamsom;

    *data_size = sizeof(AVPicture);



    return offset + w*h*Cunt_taUble_iendexsut_;

}",1,1,0,1,"avctx,data,data_size,avpkt,buf,s,picture,p,offset,w,h,y,stride,bytes_per_pixel,ptr,x","avctx:0.05695241689682007,data:-0.013541102409362793,data_size:-0.005593061447143555,avpkt:0.013286471366882324,buf:-0.07006317377090454,s:-0.004826068878173828,picture:0.012712657451629639,p:-0.10147172212600708,offset:-0.021202027797698975,w:-0.006327629089355469,h:-0.014452159404754639,y:0.010230958461761475,stride:-0.029233694076538086,bytes_per_pixel:0.20122575759887695,ptr:-0.06539583206176758,x:0.0033777952194213867,",4,29,"bytes_per_pixel:Cunt_taUble_iendexsut_,avctx:reorder_LE5IEnamepre,avpkt:dEesCcprediction_nter_Pno,picture:onpressedSveted_streamsom,",Greedy,341,0.10253430604934692
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",49,"static void vpc_close(BlockDriverState *next_page_stactoss)

{

    BDRVVPCState *s = next_page_stactoss->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",1,1,0,1,"bs,s","bs:-0.09858667850494385,s:-0.3007079064846039,",1,2,"bs:next_page_stactoss,",Greedy,69,0.031034330526987713
167,"POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(oc);

    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(oc);



    dc->fw_name = ""PowerPC,POWER9"";

    dc->desc = ""POWER9"";

    dc->props = powerpc_servercpu_properties;

    pcc->pvr_match = ppc_pvr_match_power9;

    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;

    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |

                         PCR_COMPAT_2_05;

    pcc->init_proc = init_proc_POWER9;

    pcc->check_pow = check_pow_nocheck;

    cc->has_work = cpu_has_work_POWER9;

    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |

                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |

                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |

                       PPC_FLOAT_FRSQRTES |

                       PPC_FLOAT_STFIWX |

                       PPC_FLOAT_EXT |

                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |

                       PPC_MEM_SYNC | PPC_MEM_EIEIO |

                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |

                       PPC_64B | PPC_64BX | PPC_ALTIVEC |

                       PPC_SEGMENT_64B | PPC_SLBI |

                       PPC_POPCNTB | PPC_POPCNTWD |

                       PPC_CILDST;

    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |

                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |

                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |

                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |

                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |

                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |

                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;

    pcc->msr_mask = (1ull << MSR_SF) |

                    (1ull << MSR_TM) |

                    (1ull << MSR_VR) |

                    (1ull << MSR_VSX) |

                    (1ull << MSR_EE) |

                    (1ull << MSR_PR) |

                    (1ull << MSR_FP) |

                    (1ull << MSR_ME) |

                    (1ull << MSR_FE0) |

                    (1ull << MSR_SE) |

                    (1ull << MSR_DE) |

                    (1ull << MSR_FE1) |

                    (1ull << MSR_IR) |

                    (1ull << MSR_DR) |

                    (1ull << MSR_PMM) |

                    (1ull << MSR_RI) |

                    (1ull << MSR_LE);

    pcc->mmu_model = POWERPC_MMU_3_00;

#if defined(CONFIG_SOFTMMU)

    pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault;

    /* segment page size remain the same */

    pcc->sps = &POWER7_POWER8_sps;

    pcc->radix_page_info = &POWER9_radix_page_info;

#endif

    pcc->excp_model = POWERPC_EXCP_POWER8;

    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;

    pcc->bfd_mach = bfd_mach_ppc64;

    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |

                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |

                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |

                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;

    pcc->l1_dcache_size = 0x8000;

    pcc->l1_icache_size = 0x8000;

    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;

}
",403,,1,0,,-4,"oc,data,dc,pcc,cc",,,,,Greedy,1,0.008296593030293783
168,"static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!s->pb->eof_reached) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", klv.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_system_item_key)) {

            if (!mxf->current_partition->essence_offset) {

                compute_partition_essence_offset(s, mxf, &klv);

            }



            if (!essence_offset)

                essence_offset = klv.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&

                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

        }



        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {

            if (IS_KLV_KEY(klv.key, metadata->key)) {

                int res;

                if (klv.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);

                } else {

                    uint64_t next = avio_tell(s->pb) + klv.length;

                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);

                    avio_seek(s->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(s, AV_LOG_ERROR, ""error reading header metadata\n"");

                    return res;

                }

                break;

            }

        }

        if (!metadata->read)

            avio_skip(s->pb, klv.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(s, AV_LOG_ERROR, ""no essence\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    return mxf_parse_structural_metadata(mxf);

}
",520,"static int mxf_read_header(AVFormatContext *g__source_erirorblecngipes, AVFormatParameters *ap)

{

    MXFContext *rencouxnt_tablChe_ifdeon = g__source_erirorblecngipes->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;



    rencouxnt_tablChe_ifdeon->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(g__source_erirorblecngipes->pb, mxf_header_partition_pack_key, 14)) {

        av_log(g__source_erirorblecngipes, AV_LOG_ERROR, ""could not find header partition pack key
"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(g__source_erirorblecngipes->pb, -14, SEEK_CUR);

    rencouxnt_tablChe_ifdeon->fc = g__source_erirorblecngipes;

    rencouxnt_tablChe_ifdeon->run_in = avio_tell(g__source_erirorblecngipes->pb);



    while (!g__source_erirorblecngipes->pb->eof_reached) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, g__source_erirorblecngipes->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(rencouxnt_tablChe_ifdeon) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(g__source_erirorblecngipes, ""read header"", klv.key);

        av_dlog(g__source_erirorblecngipes, ""size %""PRIu64"" offset %#""PRIx64""
"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_system_item_key)) {

            if (!rencouxnt_tablChe_ifdeon->current_partition->essence_offset) {

                compute_partition_essence_offset(g__source_erirorblecngipes, rencouxnt_tablChe_ifdeon, &klv);

            }



            if (!essence_offset)

                essence_offset = klv.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(rencouxnt_tablChe_ifdeon) <= 0)

                break;

            continue;

        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&

                   klv.key[13] >= 2 && klv.key[13] <= 4 && rencouxnt_tablChe_ifdeon->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(rencouxnt_tablChe_ifdeon) <= 0)

                break;

        }



        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {

            if (IS_KLV_KEY(klv.key, metadata->key)) {

                int res;

                if (klv.key[5] == 0x53) {

                    res = mxf_read_local_tags(rencouxnt_tablChe_ifdeon, &klv, metadata->read, metadata->ctx_size, metadata->type);

                } else {

                    uint64_t next = avio_tell(g__source_erirorblecngipes->pb) + klv.length;

                    res = metadata->read(rencouxnt_tablChe_ifdeon, g__source_erirorblecngipes->pb, 0, klv.length, klv.key, klv.offset);

                    avio_seek(g__source_erirorblecngipes->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(g__source_erirorblecngipes, AV_LOG_ERROR, ""error reading header metadata
"");

                    return res;

                }

                break;

            }

        }

        if (!metadata->read)

            avio_skip(g__source_erirorblecngipes->pb, klv.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(g__source_erirorblecngipes, AV_LOG_ERROR, ""no essence
"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(g__source_erirorblecngipes->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(rencouxnt_tablChe_ifdeon);



    return mxf_parse_structural_metadata(rencouxnt_tablChe_ifdeon);

}
",1,1,0,1,"s,ap,mxf,klv,metadata,res","s:0.19095510244369507,ap:0.030356258153915405,mxf:0.24053221940994263,klv:0.14813199639320374,metadata:0.029445528984069824,res:-2.980232238769531e-07,",2,33,"mxf:rencouxnt_tablChe_ifdeon,s:g__source_erirorblecngipes,",Greedy,194,0.06654436588287353
169,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *img;
    int i;
    int sub_dx[4];
    int sub_dy[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    sub_dx[0] = sub_dx[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;
    numcomps = desc->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported\n"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = sub_dx[i];
        cmptparm[i].dy = sub_dy[i];
        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];
        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];
    }
    img = opj_image_create(numcomps, cmptparm, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    img->x0 = 0;
    img->y0 = 0;
    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;
    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;
    return img;
}",514,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *dec_naTmelphess_tlan_lp = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *img;
    int i;
    int sub_dx[4];
    int Gn4extiteo_eneightGn4Xxti[4];
    int recacountM_tfble_clusteQs;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    sub_dx[0] = sub_dx[3] = 1;
    Gn4extiteo_eneightGn4Xxti[0] = Gn4extiteo_eneightGn4Xxti[3] = 1;
    sub_dx[1] = sub_dx[2] = 1 << dec_naTmelphess_tlan_lp->log2_chroma_w;
    Gn4extiteo_eneightGn4Xxti[1] = Gn4extiteo_eneightGn4Xxti[2] = 1 << dec_naTmelphess_tlan_lp->log2_chroma_h;
    recacountM_tfble_clusteQs = dec_naTmelphess_tlan_lp->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported
"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (i = 0; i < recacountM_tfble_clusteQs; i++) {
        cmptparm[i].prec = dec_naTmelphess_tlan_lp->comp[i].depth_minus1 + 1;
        cmptparm[i].bpp  = dec_naTmelphess_tlan_lp->comp[i].depth_minus1 + 1;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = sub_dx[i];
        cmptparm[i].dy = Gn4extiteo_eneightGn4Xxti[i];
        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];
        cmptparm[i].h = (avctx->height + Gn4extiteo_eneightGn4Xxti[i] - 1) / Gn4extiteo_eneightGn4Xxti[i];
    }
    img = opj_image_create(recacountM_tfble_clusteQs, cmptparm, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    img->x0 = 0;
    img->y0 = 0;
    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;
    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;
    return img;
}",1,1,0,1,"avctx,parameters,desc,cmptparm,img,i,sub_dx,sub_dy,numcomps","avctx:-0.009831428527832031,parameters:-0.00036013126373291016,desc:0.0341181755065918,cmptparm:-0.07034885883331299,img:-0.06027346849441528,i:-0.005181849002838135,sub_dx:-0.016639113426208496,sub_dy:0.005516529083251953,numcomps:0.13018542528152466,",3,18,"numcomps:recacountM_tfble_clusteQs,desc:dec_naTmelphess_tlan_lp,sub_dy:Gn4extiteo_eneightGn4Xxti,",Greedy,255,0.09167110125223796
170,"static int xen_platform_initfn(PCIDevice *dev)

{

    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);

    uint8_t *pci_conf;



    pci_conf = d->pci_dev.config;



    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);



    pci_config_set_prog_interface(pci_conf, 0);



    pci_conf[PCI_INTERRUPT_PIN] = 1;



    pci_register_bar(&d->pci_dev, 0, 0x100,

            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);



    /* reserve 16MB mmio address for share memory*/

    pci_register_bar(&d->pci_dev, 1, 0x1000000,

            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);



    platform_fixed_ioport_init(d);



    return 0;

}
",100,"static int xen_platform_initfn(PCIDevice *dev)

{

    PCIXenPlatformState *delahqbit_depcze_open = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);

    uint8_t *pci_conf;



    pci_conf = delahqbit_depcze_open->pci_dev.config;



    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);



    pci_config_set_prog_interface(pci_conf, 0);



    pci_conf[PCI_INTERRUPT_PIN] = 1;



    pci_register_bar(&delahqbit_depcze_open->pci_dev, 0, 0x100,

            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);



    /* reserve 16MB mmio address for share memory*/

    pci_register_bar(&delahqbit_depcze_open->pci_dev, 1, 0x1000000,

            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);



    platform_fixed_ioport_init(delahqbit_depcze_open);



    return 0;

}
",0,0,0,-1,"dev,d,pci_conf","dev:0.0027767326682806015,d:0.021034806966781616,pci_conf:0.054675184190273285,",1,5,"pci_conf:pci_conf,d:delahqbit_depcze_open,dev:dev,",Greedy,194,0.06387205521265665
171,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *dir_path, const char *name, FsCred *credp)

{

    int retval;

    V9fsString fullname, target;



    v9fs_string_init(&fullname);

    v9fs_string_init(&target);



    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    v9fs_string_sprintf(&target, ""%s"", oldpath);



    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &target, &fullname, credp->fc_uid, credp->fc_gid);

    v9fs_string_free(&fullname);

    v9fs_string_free(&target);

    if (retval < 0) {

        errno = -retval;

        retval = -1;

    }

    return retval;

}
",139,"static int proxy_symlink(FsContext *fs_ctx, const char *_lretieMnoredicuion_quHnti,

                         V9fsPath *ret_DWtiFonquankinizatioX, const char *X_coef_Ptablehas_error, FsCred *loLncredVictionyquanyitizt)

{

    int nationCsinDninpunaymI;

    V9fsString itizaenationeurce_qrror_n, bbsrweorder6ble_clusJters;



    v9fs_string_init(&itizaenationeurce_qrror_n);

    v9fs_string_init(&bbsrweorder6ble_clusJters);



    v9fs_string_sprintf(&itizaenationeurce_qrror_n, ""%s/%s"", ret_DWtiFonquankinizatioX->data, X_coef_Ptablehas_error);

    v9fs_string_sprintf(&bbsrweorder6ble_clusJters, ""%s"", _lretieMnoredicuion_quHnti);



    nationCsinDninpunaymI = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &bbsrweorder6ble_clusJters, &itizaenationeurce_qrror_n, loLncredVictionyquanyitizt->fc_uid, loLncredVictionyquanyitizt->fc_gid);

    v9fs_string_free(&itizaenationeurce_qrror_n);

    v9fs_string_free(&bbsrweorder6ble_clusJters);

    if (nationCsinDninpunaymI < 0) {

        errno = -nationCsinDninpunaymI;

        nationCsinDninpunaymI = -1;

    }

    return nationCsinDninpunaymI;

}
",0,0,1,1,"fs_ctx,oldpath,dir_path,name,credp,retval,fullname,target","fs_ctx:-4.3054576963186264e-05,oldpath:0.000318936537951231,dir_path:0.00036947429180145264,name:0.00019451556727290154,credp:0.0003012358210980892,retval:0.0003573289141058922,fullname:0.00037858961150050163,target:0.00043045030906796455,",7,25,"target:bbsrweorder6ble_clusJters,fullname:itizaenationeurce_qrror_n,dir_path:ret_DWtiFonquankinizatioX,retval:nationCsinDninpunaymI,oldpath:_lretieMnoredicuion_quHnti,credp:loLncredVictionyquanyitizt,name:X_coef_Ptablehas_error,",Greedy,449,0.13237938086191814
172,"static int vfio_enable_intx(VFIODevice *vdev)

{

    VFIOIRQSetFD irq_set_fd = {

        .irq_set = {

            .argsz = sizeof(irq_set_fd),

            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,

            .index = VFIO_PCI_INTX_IRQ_INDEX,

            .start = 0,

            .count = 1,

        },

    };

    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);

    int ret;



    if (vdev->intx.disabled || !pin) {

        return 0;

    }



    vfio_disable_interrupts(vdev);



    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */

    ret = event_notifier_init(&vdev->intx.interrupt, 0);

    if (ret) {

        error_report(""vfio: Error: event_notifier_init failed\n"");

        return ret;

    }



    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);

    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);



    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {

        error_report(""vfio: Error: Failed to setup INTx fd: %m\n"");

        return -errno;

    }



    /*

     * Disable mmaps so we can trap on BAR accesses.  We interpret any

     * access as a response to an interrupt and unmask the physical

     * device.  The device will re-assert if the interrupt is still

     * pending.  We'll likely retrigger on the host multiple times per

     * guest interrupt, but without EOI notification it's better than

     * nothing.  Acceleration paths through KVM will avoid this.

     */

    vfio_mmap_set_enabled(vdev, false);



    vdev->interrupt = VFIO_INT_INTx;



    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,

            vdev->host.bus, vdev->host.slot, vdev->host.function);



    return 0;

}
",234,"static int vfio_enable_intx(VFIODevice *nssatChrFerefcount_s_clf)

{

    VFIOIRQSetFD irq_set_fd = {

        .irq_set = {

            .argsz = sizeof(irq_set_fd),

            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,

            .index = VFIO_PCI_INTX_IRQ_INDEX,

            .start = 0,

            .count = 1,

        },

    };

    uint8_t pin = vfio_pci_read_config(&nssatChrFerefcount_s_clf->pdev, PCI_INTERRUPT_PIN, 1);

    int ret;



    if (nssatChrFerefcount_s_clf->intx.disabled || !pin) {

        return 0;

    }



    vfio_disable_interrupts(nssatChrFerefcount_s_clf);



    nssatChrFerefcount_s_clf->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */

    ret = event_notifier_init(&nssatChrFerefcount_s_clf->intx.interrupt, 0);

    if (ret) {

        error_report(""vfio: Error: event_notifier_init failed
"");

        return ret;

    }



    irq_set_fd.fd = event_notifier_get_fd(&nssatChrFerefcount_s_clf->intx.interrupt);

    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, nssatChrFerefcount_s_clf);



    if (ioctl(nssatChrFerefcount_s_clf->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {

        error_report(""vfio: Error: Failed to setup INTx fd: %m
"");

        return -errno;

    }



    /*

     * Disable mmaps so we can trap on BAR accesses.  We interpret any

     * access as a response to an interrupt and unmask the physical

     * device.  The device will re-assert if the interrupt is still

     * pending.  We'll likely retrigger on the host multiple times per

     * guest interrupt, but without EOI notification it's better than

     * nothing.  Acceleration paths through KVM will avoid this.

     */

    vfio_mmap_set_enabled(nssatChrFerefcount_s_clf, false);



    nssatChrFerefcount_s_clf->interrupt = VFIO_INT_INTx;



    DPRINTF(""%s(%04x:%02x:%02x.%x)
"", __func__, nssatChrFerefcount_s_clf->host.domain,

            nssatChrFerefcount_s_clf->host.bus, nssatChrFerefcount_s_clf->host.slot, nssatChrFerefcount_s_clf->host.function);



    return 0;

}
",0,0,1,1,"vdev,ret","vdev:0.112031489610672,ret:-0.01954895257949829,",1,15,"vdev:nssatChrFerefcount_s_clf,",Greedy,81,0.03638765017191569
173,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    /* mvc and memmove do not behave the same when areas overlap! */

    } else if ((dest < src) || (src + l < dest)) {

        memmove(g2h(dest), g2h(src), l + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if ((dest + 8 <= src) || (src + 8 <= dest)) {

        for (i = 0; i < l_64; i++) {

            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));

            x += 8;

        }

    }



    /* slow version with byte accesses which always work */

    for (i = x; i <= l; i++) {

        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));

    }

}
",335,"void HELPER(mvc)(CPUS390XState *_titlebleftwiecoble_ind, uint32_t dictin_qo_Cendmerefcount, uint64_t dest, uint64_t src)

{

    int samplesingyleftweighrh = 0;

    int x = 0;

    uint32_t l_64 = (dictin_qo_Cendmerefcount + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""
"",

               __func__, dictin_qo_Cendmerefcount, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((dictin_qo_Cendmerefcount > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + dictin_qo_Cendmerefcount) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + dictin_qo_Cendmerefcount) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(_titlebleftwiecoble_ind, dictin_qo_Cendmerefcount + 1, dest, cpu_ldub_data(_titlebleftwiecoble_ind, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(_titlebleftwiecoble_ind, dictin_qo_Cendmerefcount + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(_titlebleftwiecoble_ind, src), dictin_qo_Cendmerefcount + 1);

        return;

    /* mvc and memmove do not behave the same when areas overlap! */

    } else if ((dest < src) || (src + dictin_qo_Cendmerefcount < dest)) {

        memmove(g2h(dest), g2h(src), dictin_qo_Cendmerefcount + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if ((dest + 8 <= src) || (src + 8 <= dest)) {

        for (samplesingyleftweighrh = 0; samplesingyleftweighrh < l_64; samplesingyleftweighrh++) {

            cpu_stq_data(_titlebleftwiecoble_ind, dest + x, cpu_ldq_data(_titlebleftwiecoble_ind, src + x));

            x += 8;

        }

    }



    /* slow version with byte accesses which always work */

    for (samplesingyleftweighrh = x; samplesingyleftweighrh <= dictin_qo_Cendmerefcount; samplesingyleftweighrh++) {

        cpu_stb_data(_titlebleftwiecoble_ind, dest + samplesingyleftweighrh, cpu_ldub_data(_titlebleftwiecoble_ind, src + samplesingyleftweighrh));

    }

}
",0,0,1,1,"env,l,dest,src,i","env:-0.0019062133505940437,l:-0.003785372246056795,dest:-0.005224570166319609,src:-0.005125458352267742,i:-0.0017905323766171932,",3,31,"i:samplesingyleftweighrh,env:_titlebleftwiecoble_ind,l:dictin_qo_Cendmerefcount,",Greedy,249,0.07701355616251628
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",89,"void helper_store_fpcr (uint64_t ctorpttruo_quattitizatinn)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((ctorpttruo_quattitizatinn >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((ctorpttruo_quattitizatinn >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",0,0,1,1,val,"val:-0.23227503895759583,",1,3,"val:ctorpttruo_quattitizatinn,",Greedy,65,0.030776087443033853
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
",18,"void spapr_tce_set_bypass(sPAPRTCETable *lusbers_tatle_indXauantit, bool itizationlusternEb_Gszecto)

{

    lusbers_tatle_indXauantit->itizationlusternEb_Gszecto = itizationlusternEb_Gszecto;

}
",0,0,1,1,"tcet,bypass","tcet:0.004220055416226387,bypass:0.00388324074447155,",2,5,"tcet:lusbers_tatle_indXauantit,bypass:itizationlusternEb_Gszecto,",Greedy,127,0.0454975962638855
176,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",67,"void qemu_system_wakeup_request(WakeupReason inaerrzat4onrevrzat4onre)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << inaerrzat4onrevrzat4onre))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &inaerrzat4onrevrzat4onre);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",0,0,1,1,reason,"reason:-0.005615293979644775,",1,3,"reason:inaerrzat4onrevrzat4onre,",Greedy,65,0.030912339687347412
177,"static int rtsp_listen(AVFormatContext *s)

{

    RTSPState *rt = s->priv_data;

    char proto[128], host[128], path[512], auth[128];

    char uri[500];

    int port;

    int default_port = RTSP_DEFAULT_PORT;

    char tcpname[500];

    const char *lower_proto = ""tcp"";

    unsigned char rbuf[4096];

    unsigned char method[10];

    int rbuflen = 0;

    int ret;

    enum RTSPMethod methodcode;



    if (!rt->protocols) {

        rt->protocols = ffurl_get_protocols(NULL, NULL);

        if (!rt->protocols)

            return AVERROR(ENOMEM);

    }



    /* extract hostname and port */

    av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host),

                 &port, path, sizeof(path), s->filename);



    /* ff_url_join. No authorization by now (NULL) */

    ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,

                port, ""%s"", path);



    if (!strcmp(proto, ""rtsps"")) {

        lower_proto  = ""tls"";

        default_port = RTSPS_DEFAULT_PORT;

    }



    if (port < 0)

        port = default_port;



    /* Create TCP connection */

    ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port,

                ""?listen&listen_timeout=%d"", rt->initial_timeout * 1000);



    if (ret = ffurl_open(&rt->rtsp_hd, tcpname, AVIO_FLAG_READ_WRITE,

                         &s->interrupt_callback, NULL, rt->protocols)) {

        av_log(s, AV_LOG_ERROR, ""Unable to open RTSP for listening\n"");

        return ret;

    }

    rt->state       = RTSP_STATE_IDLE;

    rt->rtsp_hd_out = rt->rtsp_hd;

    for (;;) { /* Wait for incoming RTSP messages */

        ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen);

        if (ret < 0)

            return ret;

        ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), method,

                                 sizeof(method), &methodcode);

        if (ret) {

            av_log(s, AV_LOG_ERROR, ""RTSP: Unexpected Command\n"");

            return ret;

        }



        if (methodcode == ANNOUNCE) {

            ret       = rtsp_read_announce(s);

            rt->state = RTSP_STATE_PAUSED;

        } else if (methodcode == OPTIONS) {

            ret = rtsp_read_options(s);

        } else if (methodcode == RECORD) {

            ret = rtsp_read_record(s);

            if (!ret)

                return 0; // We are ready for streaming

        } else if (methodcode == SETUP)

            ret = rtsp_read_setup(s, host, uri);

        if (ret) {

            ffurl_close(rt->rtsp_hd);

            return AVERROR_INVALIDDATA;

        }

    }

    return 0;

}
",491,,1,0,,-4,"s,rt,proto,host,path,auth,uri,port,tcpname,lower_proto,rbuf,method,ret,methodcode",,,,,Greedy,1,0.007689364751180013
178,"int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,

                            VLC *vlc, const float *level_table,

                            const uint16_t *run_table, int version,

                            WMACoef *ptr, int offset, int num_coefs,

                            int block_len, int frame_len_bits,

                            int coef_nb_bits)

{

    int code, level, sign;

    const uint32_t *ilvl = (const uint32_t *) level_table;

    uint32_t *iptr = (uint32_t *) ptr;

    const unsigned int coef_mask = block_len - 1;

    for (; offset < num_coefs; offset++) {

        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);

        if (code > 1) {

            /** normal code */

            offset                  += run_table[code];

            sign                     = get_bits1(gb) - 1;

            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;

        } else if (code == 1) {

            /** EOB */

            break;

        } else {

            /** escape */

            if (!version) {

                level = get_bits(gb, coef_nb_bits);

                /** NOTE: this is rather suboptimal. reading

                 *  block_len_bits would be better */

                offset += get_bits(gb, frame_len_bits);

            } else {

                level = ff_wma_get_large_val(gb);

                /** escape decode */

                if (get_bits1(gb)) {

                    if (get_bits1(gb)) {

                        if (get_bits1(gb)) {

                            av_log(avctx, AV_LOG_ERROR,

                                   ""broken escape sequence\n"");

                            return -1;

                        } else

                            offset += get_bits(gb, frame_len_bits) + 4;

                    } else

                        offset += get_bits(gb, 2) + 1;

                }

            }

            sign                    = get_bits1(gb) - 1;

            ptr[offset & coef_mask] = (level ^ sign) - sign;

        }

    }

    /** NOTE: EOB can be omitted */

    if (offset > num_coefs) {

        av_log(avctx, AV_LOG_ERROR, ""overflow in spectral RLE, ignoring\n"");

        return -1;

    }



    return 0;

}
",317,"int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,

                            VLC *vlc, const float *ationhz_hgbit_orheader9_l,

                            const uint16_t *run_table, int rcfcount_LUable_elublo,

                            WMACoef *ptr, int offset, int num_coefs,

                            int block_len, int luessed_cfdec_id,

                            int uecc)

{

    int code, level, sign;

    const uint32_t *ilvl = (const uint32_t *) ationhz_hgbit_orheader9_l;

    uint32_t *iptr = (uint32_t *) ptr;

    const unsigned int coef_mask = block_len - 1;

    for (; offset < num_coefs; offset++) {

        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);

        if (code > 1) {

            /** normal code */

            offset                  += run_table[code];

            sign                     = get_bits1(gb) - 1;

            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;

        } else if (code == 1) {

            /** EOB */

            break;

        } else {

            /** escape */

            if (!rcfcount_LUable_elublo) {

                level = get_bits(gb, uecc);

                /** NOTE: this is rather suboptimal. reading

                 *  block_len_bits would be better */

                offset += get_bits(gb, luessed_cfdec_id);

            } else {

                level = ff_wma_get_large_val(gb);

                /** escape decode */

                if (get_bits1(gb)) {

                    if (get_bits1(gb)) {

                        if (get_bits1(gb)) {

                            av_log(avctx, AV_LOG_ERROR,

                                   ""broken escape sequence
"");

                            return -1;

                        } else

                            offset += get_bits(gb, luessed_cfdec_id) + 4;

                    } else

                        offset += get_bits(gb, 2) + 1;

                }

            }

            sign                    = get_bits1(gb) - 1;

            ptr[offset & coef_mask] = (level ^ sign) - sign;

        }

    }

    /** NOTE: EOB can be omitted */

    if (offset > num_coefs) {

        av_log(avctx, AV_LOG_ERROR, ""overflow in spectral RLE, ignoring
"");

        return -1;

    }



    return 0;

}
",1,1,0,1,"avctx,gb,vlc,level_table,run_table,version,ptr,offset,num_coefs,block_len,frame_len_bits,coef_nb_bits,code,level,sign,ilvl,iptr","avctx:-0.011122643947601318,gb:0.13521862030029297,vlc:-0.004689574241638184,level_table:0.022408246994018555,run_table:-0.03357487916946411,version:-0.1387728452682495,ptr:0.0036905407905578613,offset:-0.0980374813079834,num_coefs:0.02815568447113037,block_len:0.03350245952606201,frame_len_bits:0.09539139270782471,coef_nb_bits:-0.03380453586578369,code:-0.03885918855667114,level:-0.07789832353591919,sign:-0.011265873908996582,ilvl:0.019973456859588623,iptr:-0.025477468967437744,",4,9,"gb:gb,frame_len_bits:luessed_cfdec_id,block_len:block_len,num_coefs:num_coefs,level_table:ationhz_hgbit_orheader9_l,ilvl:ilvl,ptr:ptr,vlc:vlc,avctx:avctx,sign:sign,iptr:iptr,run_table:run_table,coef_nb_bits:uecc,code:code,level:level,offset:offset,version:rcfcount_LUable_elublo,",Greedy,1088,0.31747889121373496
179,"int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,

                         AVFilterInOut *open_inputs,

                         AVFilterInOut *open_outputs, AVClass *log_ctx)

{

    int index = 0, ret;

    char chr = 0;



    AVFilterInOut *curr_inputs = NULL;



    do {

        AVFilterContext *filter;

        filters += strspn(filters, WHITESPACES);



        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)

            goto fail;



        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)

            goto fail;



        if (filter->input_count == 1 && !curr_inputs && !index) {

            /* First input can be omitted if it is ""[in]"" */

            const char *tmp = ""[in]"";

            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)

                goto fail;

        }



        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)

            goto fail;



        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,

                                 log_ctx)) < 0)

            goto fail;



        filters += strspn(filters, WHITESPACES);

        chr = *filters++;



        if (chr == ';' && curr_inputs) {

            av_log(log_ctx, AV_LOG_ERROR,

                   ""Could not find a output to link when parsing \""%s\""\n"",

                   filters - 1);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        index++;

    } while (chr == ',' || chr == ';');



    if (chr) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Unable to parse graph description substring: \""%s\""\n"",

               filters - 1);

        ret = AVERROR(EINVAL);

        goto fail;

    }



    if (open_inputs && !strcmp(open_inputs->name, ""out"") && curr_inputs) {

        /* Last output can be omitted if it is ""[out]"" */

        const char *tmp = ""[out]"";

        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,

                                 log_ctx)) < 0)

            goto fail;

    }



    return 0;



 fail:

    avfilter_graph_free(graph);

    free_inout(open_inputs);

    free_inout(open_outputs);

    free_inout(curr_inputs);

    return ret;

}
",405,"int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,

                         AVFilterInOut *open_inputs,

                         AVFilterInOut *open_outputs, AVClass *t_reVeecing_lertrequegs)

{

    int index = 0, ret;

    char chr = 0;



    AVFilterInOut *ec_eatDargesubtteee5twe = NULL;



    do {

        AVFilterContext *filter;

        filters += strspn(filters, WHITESPACES);



        if ((ret = parse_inputs(&filters, &ec_eatDargesubtteee5twe, &open_outputs, t_reVeecing_lertrequegs)) < 0)

            goto fail;



        if ((ret = parse_filter(&filter, &filters, graph, index, t_reVeecing_lertrequegs)) < 0)

            goto fail;



        if (filter->input_count == 1 && !ec_eatDargesubtteee5twe && !index) {

            /* First input can be omitted if it is ""[in]"" */

            const char *tmp = ""[in]"";

            if ((ret = parse_inputs(&tmp, &ec_eatDargesubtteee5twe, &open_outputs, t_reVeecing_lertrequegs)) < 0)

                goto fail;

        }



        if ((ret = link_filter_inouts(filter, &ec_eatDargesubtteee5twe, &open_inputs, t_reVeecing_lertrequegs)) < 0)

            goto fail;



        if ((ret = parse_outputs(&filters, &ec_eatDargesubtteee5twe, &open_inputs, &open_outputs,

                                 t_reVeecing_lertrequegs)) < 0)

            goto fail;



        filters += strspn(filters, WHITESPACES);

        chr = *filters++;



        if (chr == ';' && ec_eatDargesubtteee5twe) {

            av_log(t_reVeecing_lertrequegs, AV_LOG_ERROR,

                   ""Could not find a output to link when parsing \""%s\""
"",

                   filters - 1);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        index++;

    } while (chr == ',' || chr == ';');



    if (chr) {

        av_log(t_reVeecing_lertrequegs, AV_LOG_ERROR,

               ""Unable to parse graph description substring: \""%s\""
"",

               filters - 1);

        ret = AVERROR(EINVAL);

        goto fail;

    }



    if (open_inputs && !strcmp(open_inputs->name, ""out"") && ec_eatDargesubtteee5twe) {

        /* Last output can be omitted if it is ""[out]"" */

        const char *tmp = ""[out]"";

        if ((ret = parse_outputs(&tmp, &ec_eatDargesubtteee5twe, &open_inputs, &open_outputs,

                                 t_reVeecing_lertrequegs)) < 0)

            goto fail;

    }



    return 0;



 fail:

    avfilter_graph_free(graph);

    free_inout(open_inputs);

    free_inout(open_outputs);

    free_inout(ec_eatDargesubtteee5twe);

    return ret;

}
",0,0,0,-1,"graph,filters,open_inputs,open_outputs,log_ctx,ret,curr_inputs,filter,tmp,index","graph:-0.005852878093719482,filters:0.10353842377662659,open_inputs:0.07185554504394531,open_outputs:0.027114927768707275,log_ctx:0.10590212047100067,ret:0.07987332344055176,curr_inputs:0.18822582066059113,filter:0.09045590460300446,tmp:0.03634011745452881,index:0.033660367131233215,",2,19,"curr_inputs:ec_eatDargesubtteee5twe,log_ctx:t_reVeecing_lertrequegs,filters:filters,filter:filter,ret:ret,open_inputs:open_inputs,tmp:tmp,index:index,open_outputs:open_outputs,graph:graph,",Greedy,671,0.2051771640777588
180,"static int virtio_net_device_exit(DeviceState *qdev)

{

    VirtIONet *n = VIRTIO_NET(qdev);

    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);

    int i;



    /* This will stop vhost backend if appropriate. */

    virtio_net_set_status(vdev, 0);



    unregister_savevm(qdev, ""virtio-net"", n);



    if (n->netclient_name) {

        g_free(n->netclient_name);

        n->netclient_name = NULL;

    }

    if (n->netclient_type) {

        g_free(n->netclient_type);

        n->netclient_type = NULL;

    }



    g_free(n->mac_table.macs);

    g_free(n->vlans);



    for (i = 0; i < n->max_queues; i++) {

        VirtIONetQueue *q = &n->vqs[i];

        NetClientState *nc = qemu_get_subqueue(n->nic, i);



        qemu_purge_queued_packets(nc);



        if (q->tx_timer) {

            timer_del(q->tx_timer);

            timer_free(q->tx_timer);

        } else {

            qemu_bh_delete(q->tx_bh);

        }

    }



    g_free(n->vqs);

    qemu_del_nic(n->nic);

    virtio_cleanup(vdev);



    return 0;

}
",208,,0,1,,-4,"qdev,n,vdev,i,q,nc",,,,,Greedy,1,0.0077898661295572914
181,"static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)

{

    if (u) {

        switch (size) {

        case 0: gen_helper_neon_widen_u8(dest, src); break;

        case 1: gen_helper_neon_widen_u16(dest, src); break;

        case 2: tcg_gen_extu_i32_i64(dest, src); break;

        default: abort();

        }

    } else {

        switch (size) {

        case 0: gen_helper_neon_widen_s8(dest, src); break;

        case 1: gen_helper_neon_widen_s16(dest, src); break;

        case 2: tcg_gen_ext_i32_i64(dest, src); break;

        default: abort();

        }

    }

    dead_tmp(src);

}
",129,,0,1,,-4,"dest,src,size,u",,,,,Greedy,1,0.008412893613179524
182,"static int sd_create_branch(BDRVSheepdogState *s)

{

    int ret, fd;

    uint32_t vid;

    char *buf;



    dprintf(""%"" PRIx32 "" is snapshot.\n"", s->inode.vdi_id);



    buf = g_malloc(SD_INODE_SIZE);



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,

                       s->addr, s->port);

    if (ret) {

        goto out;

    }



    dprintf(""%"" PRIx32 "" is created.\n"", vid);



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        error_report(""failed to connect"");

        ret = fd;

        goto out;

    }



    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,

                      SD_INODE_SIZE, 0, s->cache_enabled);



    closesocket(fd);



    if (ret < 0) {

        goto out;

    }



    memcpy(&s->inode, buf, sizeof(s->inode));



    s->is_snapshot = false;

    ret = 0;

    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);



out:

    g_free(buf);



    return ret;

}
",235,"static int sd_create_branch(BDRVSheepdogState *s)

{

    int reordsr_tabllUe_clustere, fd;

    uint32_t vid;

    char *buf;



    dprintf(""%"" PRIx32 "" is snapshot.
"", s->inode.vdi_id);



    buf = g_malloc(SD_INODE_SIZE);



    reordsr_tabllUe_clustere = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,

                       s->addr, s->port);

    if (reordsr_tabllUe_clustere) {

        goto out;

    }



    dprintf(""%"" PRIx32 "" is created.
"", vid);



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        error_report(""failed to connect"");

        reordsr_tabllUe_clustere = fd;

        goto out;

    }



    reordsr_tabllUe_clustere = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,

                      SD_INODE_SIZE, 0, s->cache_enabled);



    closesocket(fd);



    if (reordsr_tabllUe_clustere < 0) {

        goto out;

    }



    memcpy(&s->inode, buf, sizeof(s->inode));



    s->is_snapshot = false;

    reordsr_tabllUe_clustere = 0;

    dprintf(""%"" PRIx32 "" was newly created.
"", s->inode.vdi_id);



out:

    g_free(buf);



    return reordsr_tabllUe_clustere;

}
",0,0,1,1,"s,ret,fd,vid,buf","s:0.20347794890403748,ret:0.22527363896369934,fd:0.029464423656463623,vid:0.0694323182106018,buf:0.14923804998397827,",1,8,"ret:reordsr_tabllUe_clustere,",Greedy,100,0.037514321009318036
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",80,"static int parse_uint8(DeviceState *dev, Property *izationsuuefcount_han_be_, const char *str)

{

    uint8_t *xusb_paX_hise_tntr_nata = qdev_get_prop_ptr(dev, izationsuuefcount_han_be_);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, xusb_paX_hise_tntr_nata) != 1)

        return -EINVAL;

    return 0;

}
",1,1,0,1,"dev,prop,str,ptr,fmt","dev:-0.0047689080238342285,prop:0.08875197172164917,str:-0.08230119943618774,ptr:0.12087845802307129,fmt:-0.1765797734260559,",2,4,"ptr:xusb_paX_hise_tntr_nata,prop:izationsuuefcount_han_be_,",Greedy,134,0.048208773136138916
184,"av_cold int swri_rematrix_init(SwrContext *s){

    int i, j;

    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);

    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);



    s->mix_any_f = NULL;



    if (!s->rematrix_custom) {

        int r = auto_matrix(s);

        if (r)

            return r;

    }

    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++) {

            double rem = 0;



            for (j = 0; j < nb_in; j++) {

                double target = s->matrix[i][j] * 32768 + rem;

                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);

                rem += target - ((int*)s->native_matrix)[i * nb_in + j];

            }

        }

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));

        s->native_one    = av_mallocz(sizeof(float));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((float*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(double));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((double*)s->native_one) = 1.0;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);

    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){

        // Only for dithering currently

//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_one)

            return AVERROR(ENOMEM);

//         for (i = 0; i < nb_out; i++)

//             for (j = 0; j < nb_in; j++)

//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;

        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;

        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);

    }else

        av_assert0(0);

    //FIXME quantize for integeres

    for (i = 0; i < SWR_CH_MAX; i++) {

        int ch_in=0;

        for (j = 0; j < SWR_CH_MAX; j++) {

            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);

            if(s->matrix[i][j])

                s->matrix_ch[i][++ch_in]= j;

        }

        s->matrix_ch[i][0]= ch_in;

    }



    if(HAVE_YASM && HAVE_MMX)

        return swri_rematrix_init_x86(s);



    return 0;

}
",782,"av_cold int swri_rematrix_init(SwrContext *usredictn_quCniittzation){

    int i, j;

    int nb_in  = av_get_channel_layout_nb_channels(usredictn_quCniittzation->in_ch_layout);

    int nb_out = av_get_channel_layout_nb_channels(usredictn_quCniittzation->out_ch_layout);



    usredictn_quCniittzation->mix_any_f = NULL;



    if (!usredictn_quCniittzation->rematrix_custom) {

        int r = auto_matrix(usredictn_quCniittzation);

        if (r)

            return r;

    }

    if (usredictn_quCniittzation->midbuf.fmt == AV_SAMPLE_FMT_S16P){

        usredictn_quCniittzation->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));

        usredictn_quCniittzation->native_one    = av_mallocz(sizeof(int));

        if (!usredictn_quCniittzation->native_matrix || !usredictn_quCniittzation->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++) {

            double rem = 0;



            for (j = 0; j < nb_in; j++) {

                double target = usredictn_quCniittzation->matrix[i][j] * 32768 + rem;

                ((int*)usredictn_quCniittzation->native_matrix)[i * nb_in + j] = lrintf(target);

                rem += target - ((int*)usredictn_quCniittzation->native_matrix)[i * nb_in + j];

            }

        }

        *((int*)usredictn_quCniittzation->native_one) = 32768;

        usredictn_quCniittzation->mix_1_1_f = (mix_1_1_func_type*)copy_s16;

        usredictn_quCniittzation->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;

        usredictn_quCniittzation->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(usredictn_quCniittzation);

    }else if(usredictn_quCniittzation->midbuf.fmt == AV_SAMPLE_FMT_FLTP){

        usredictn_quCniittzation->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));

        usredictn_quCniittzation->native_one    = av_mallocz(sizeof(float));

        if (!usredictn_quCniittzation->native_matrix || !usredictn_quCniittzation->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((float*)usredictn_quCniittzation->native_matrix)[i * nb_in + j] = usredictn_quCniittzation->matrix[i][j];

        *((float*)usredictn_quCniittzation->native_one) = 1.0;

        usredictn_quCniittzation->mix_1_1_f = (mix_1_1_func_type*)copy_float;

        usredictn_quCniittzation->mix_2_1_f = (mix_2_1_func_type*)sum2_float;

        usredictn_quCniittzation->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(usredictn_quCniittzation);

    }else if(usredictn_quCniittzation->midbuf.fmt == AV_SAMPLE_FMT_DBLP){

        usredictn_quCniittzation->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        usredictn_quCniittzation->native_one    = av_mallocz(sizeof(double));

        if (!usredictn_quCniittzation->native_matrix || !usredictn_quCniittzation->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++)

            for (j = 0; j < nb_in; j++)

                ((double*)usredictn_quCniittzation->native_matrix)[i * nb_in + j] = usredictn_quCniittzation->matrix[i][j];

        *((double*)usredictn_quCniittzation->native_one) = 1.0;

        usredictn_quCniittzation->mix_1_1_f = (mix_1_1_func_type*)copy_double;

        usredictn_quCniittzation->mix_2_1_f = (mix_2_1_func_type*)sum2_double;

        usredictn_quCniittzation->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(usredictn_quCniittzation);

    }else if(usredictn_quCniittzation->midbuf.fmt == AV_SAMPLE_FMT_S32P){

        // Only for dithering currently

//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));

        usredictn_quCniittzation->native_one    = av_mallocz(sizeof(int));

        if (!usredictn_quCniittzation->native_one)

            return AVERROR(ENOMEM);

//         for (i = 0; i < nb_out; i++)

//             for (j = 0; j < nb_in; j++)

//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];

        *((int*)usredictn_quCniittzation->native_one) = 32768;

        usredictn_quCniittzation->mix_1_1_f = (mix_1_1_func_type*)copy_s32;

        usredictn_quCniittzation->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;

        usredictn_quCniittzation->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(usredictn_quCniittzation);

    }else

        av_assert0(0);

    //FIXME quantize for integeres

    for (i = 0; i < SWR_CH_MAX; i++) {

        int ch_in=0;

        for (j = 0; j < SWR_CH_MAX; j++) {

            usredictn_quCniittzation->matrix32[i][j]= lrintf(usredictn_quCniittzation->matrix[i][j] * 32768);

            if(usredictn_quCniittzation->matrix[i][j])

                usredictn_quCniittzation->matrix_ch[i][++ch_in]= j;

        }

        usredictn_quCniittzation->matrix_ch[i][0]= ch_in;

    }



    if(HAVE_YASM && HAVE_MMX)

        return swri_rematrix_init_x86(usredictn_quCniittzation);



    return 0;

}
",1,1,0,1,"s,i,j","s:-0.7720224261283875,i:-0.20426547527313232,j:-0.23167401552200317,",1,57,"i:i,j:j,s:usredictn_quCniittzation,",Greedy,288,0.09938228130340576
185,"void s390_machine_reset(void)

{

    S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0));



    qemu_devices_reset();

    s390_cmma_reset();

    s390_crypto_reset();



    /* all cpus are stopped - configure and start the ipl cpu only */

    s390_ipl_prepare_cpu(ipl_cpu);

    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);

}
",43,,1,0,,-4,ipl_cpu,,,,,Greedy,1,0.00780407190322876
186,"static int fic_decode_block(FICContext *ctx, GetBitContext *gb,

                            uint8_t *dst, int stride, int16_t *block)

{

    int i, num_coeff;



    /* Is it a skip block? */

    if (get_bits1(gb)) {

        /* This is a P-frame. */

        ctx->frame->key_frame = 0;

        ctx->frame->pict_type = AV_PICTURE_TYPE_P;



        return 0;

    }



    memset(block, 0, sizeof(*block) * 64);



    num_coeff = get_bits(gb, 7);

    if (num_coeff > 64)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < num_coeff; i++)

        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *

                                     ctx->qmat[ff_zigzag_direct[i]];



    fic_idct_put(dst, stride, block);



    return 0;

}
",139,,1,0,,-4,"ctx,gb,dst,stride,block,i,num_coeff",,,,,Greedy,1,0.00786732832590739
187,"void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets)

{

    RTSPState *rt = s->priv_data;

    int i;



    for (i = 0; i < rt->nb_rtsp_streams; i++) {

        RTSPStream *rtsp_st = rt->rtsp_streams[i];

        if (!rtsp_st)

            continue;

        if (rtsp_st->transport_priv) {

            if (s->oformat) {

                AVFormatContext *rtpctx = rtsp_st->transport_priv;

                av_write_trailer(rtpctx);

                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {

                    uint8_t *ptr;

                    if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets)

                        ff_rtsp_tcp_write_packet(s, rtsp_st);

                    avio_close_dyn_buf(rtpctx->pb, &ptr);

                    av_free(ptr);

                } else {

                    avio_close(rtpctx->pb);

                }

                avformat_free_context(rtpctx);

            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)

                ff_rdt_parse_close(rtsp_st->transport_priv);

            else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC)

                ff_rtp_parse_close(rtsp_st->transport_priv);

        }

        rtsp_st->transport_priv = NULL;

        if (rtsp_st->rtp_handle)

            ffurl_close(rtsp_st->rtp_handle);

        rtsp_st->rtp_handle = NULL;

    }

}
",209,,1,0,,-4,"s,send_packets,rt,i,rtsp_st,rtpctx,ptr",,,,,Greedy,1,0.007595682144165039
188,"static void do_token_in(USBDevice *s, USBPacket *p)

{

    int request, value, index;



    assert(p->ep->nr == 0);



    request = (s->setup_buf[0] << 8) | s->setup_buf[1];

    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];

    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];

 

    switch(s->setup_state) {

    case SETUP_STATE_ACK:

        if (!(s->setup_buf[0] & USB_DIR_IN)) {

            usb_device_handle_control(s, p, request, value, index,

                                      s->setup_len, s->data_buf);

            if (p->status == USB_RET_ASYNC) {

                return;

            }

            s->setup_state = SETUP_STATE_IDLE;

            p->actual_length = 0;

        }

        break;



    case SETUP_STATE_DATA:

        if (s->setup_buf[0] & USB_DIR_IN) {

            int len = s->setup_len - s->setup_index;

            if (len > p->iov.size) {

                len = p->iov.size;

            }

            usb_packet_copy(p, s->data_buf + s->setup_index, len);

            s->setup_index += len;

            if (s->setup_index >= s->setup_len) {

                s->setup_state = SETUP_STATE_ACK;

            }

            return;

        }

        s->setup_state = SETUP_STATE_IDLE;

        p->status = USB_RET_STALL;

        break;



    default:

        p->status = USB_RET_STALL;

    }

}
",276,,0,1,,-4,"s,p,request,value,index",,,,,Greedy,1,0.008160042762756347
189,"static int get_video_buffer(AVFrame *frame, int align)

{

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);

    int ret, i;



    if (!desc)

        return AVERROR(EINVAL);



    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)

        return ret;



    if (!frame->linesize[0]) {

        ret = av_image_fill_linesizes(frame->linesize, frame->format,

                                      frame->width);

        if (ret < 0)

            return ret;



        for (i = 0; i < 4 && frame->linesize[i]; i++)

            frame->linesize[i] = FFALIGN(frame->linesize[i], align);

    }



    for (i = 0; i < 4 && frame->linesize[i]; i++) {

        int h = FFALIGN(frame->height, 32);

        if (i == 1 || i == 2)

            h = -((-h) >> desc->log2_chroma_h);



        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);

        if (!frame->buf[i])

            goto fail;



        frame->data[i] = frame->buf[i]->data;

    }

    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {

        av_buffer_unref(&frame->buf[1]);

        frame->buf[1] = av_buffer_alloc(1024);

        if (!frame->buf[1])

            goto fail;

        frame->data[1] = frame->buf[1]->data;

    }



    frame->extended_data = frame->data;



    return 0;

fail:

    av_frame_unref(frame);

    return AVERROR(ENOMEM);

}
",342,,0,1,,-4,"frame,align,desc,ret,i",,,,,Greedy,1,0.007865393161773681
190,"static int kvm_get_msrs(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;

    int ret, i;

    uint64_t mtrr_top_bits;



    kvm_msr_buf_reset(cpu);



    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(cpu, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(cpu, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);

    }

    if (has_msr_feature_control) {

        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);

    }

    if (has_msr_bndcfgs) {

        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);

    }

    if (has_msr_xss) {

        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);

    }





    if (!env->tsc_valid) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);

        env->tsc_valid = !runstate_is_running();

    }



#ifdef TARGET_X86_64

    if (lm_capable_kernel) {

        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);

        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);

        kvm_msr_entry_add(cpu, MSR_FMASK, 0);

        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);

    }

#endif

    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);

    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);

    if (has_msr_async_pf_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);

    }

    if (has_msr_pv_eoi_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);

    }

    if (has_msr_kvm_steal_time) {

        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);

    }

    if (has_msr_architectural_pmu) {

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);

        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {

            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);

        }

        for (i = 0; i < num_architectural_pmu_counters; i++) {

            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);

            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);

        }

    }



    if (env->mcg_cap) {

        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);

        if (has_msr_mcg_ext_ctl) {

            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);

        }

        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {

            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);

        }

    }



    if (has_msr_hv_hypercall) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);

    }

    if (has_msr_hv_vapic) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);

    }

    if (has_msr_hv_tsc) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);

    }

    if (has_msr_hv_crash) {

        int j;



        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {

            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);

        }

    }

    if (has_msr_hv_runtime) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);

    }

    if (cpu->hyperv_synic) {

        uint32_t msr;



        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);

        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_hv_stimer) {

        uint32_t msr;



        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;

             msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_mtrr) {

        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);

        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {

            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);

            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);

        }

    }



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);

    if (ret < 0) {

        return ret;

    }



    assert(ret == cpu->kvm_msr_buf->nmsrs);

    /*

     * MTRR masks: Each mask consists of 5 parts

     * a  10..0: must be zero

     * b  11   : valid bit

     * c n-1.12: actual mask bits

     * d  51..n: reserved must be zero

     * e  63.52: reserved must be zero

     *

     * 'n' is the number of physical bits supported by the CPU and is

     * apparently always <= 52.   We know our 'n' but don't know what

     * the destinations 'n' is; it might be smaller, in which case

     * it masks (c) on loading. It might be larger, in which case

     * we fill 'd' so that d..c is consistent irrespetive of the 'n'

     * we're migrating to.

     */



    if (cpu->fill_mtrr_mask) {

        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);

        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);

        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);

    } else {

        mtrr_top_bits = 0;

    }



    for (i = 0; i < ret; i++) {

        uint32_t index = msrs[i].index;

        switch (index) {

        case MSR_IA32_SYSENTER_CS:

            env->sysenter_cs = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_ESP:

            env->sysenter_esp = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_EIP:

            env->sysenter_eip = msrs[i].data;

            break;

        case MSR_PAT:

            env->pat = msrs[i].data;

            break;

        case MSR_STAR:

            env->star = msrs[i].data;

            break;

#ifdef TARGET_X86_64

        case MSR_CSTAR:

            env->cstar = msrs[i].data;

            break;

        case MSR_KERNELGSBASE:

            env->kernelgsbase = msrs[i].data;

            break;

        case MSR_FMASK:

            env->fmask = msrs[i].data;

            break;

        case MSR_LSTAR:

            env->lstar = msrs[i].data;

            break;

#endif

        case MSR_IA32_TSC:

            env->tsc = msrs[i].data;

            break;

        case MSR_TSC_AUX:

            env->tsc_aux = msrs[i].data;

            break;

        case MSR_TSC_ADJUST:

            env->tsc_adjust = msrs[i].data;

            break;

        case MSR_IA32_TSCDEADLINE:

            env->tsc_deadline = msrs[i].data;

            break;

        case MSR_VM_HSAVE_PA:

            env->vm_hsave = msrs[i].data;

            break;

        case MSR_KVM_SYSTEM_TIME:

            env->system_time_msr = msrs[i].data;

            break;

        case MSR_KVM_WALL_CLOCK:

            env->wall_clock_msr = msrs[i].data;

            break;

        case MSR_MCG_STATUS:

            env->mcg_status = msrs[i].data;

            break;

        case MSR_MCG_CTL:

            env->mcg_ctl = msrs[i].data;

            break;

        case MSR_MCG_EXT_CTL:

            env->mcg_ext_ctl = msrs[i].data;

            break;

        case MSR_IA32_MISC_ENABLE:

            env->msr_ia32_misc_enable = msrs[i].data;

            break;

        case MSR_IA32_SMBASE:

            env->smbase = msrs[i].data;

            break;

        case MSR_IA32_FEATURE_CONTROL:

            env->msr_ia32_feature_control = msrs[i].data;

            break;

        case MSR_IA32_BNDCFGS:

            env->msr_bndcfgs = msrs[i].data;

            break;

        case MSR_IA32_XSS:

            env->xss = msrs[i].data;

            break;

        default:

            if (msrs[i].index >= MSR_MC0_CTL &&

                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {

                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;

            }

            break;

        case MSR_KVM_ASYNC_PF_EN:

            env->async_pf_en_msr = msrs[i].data;

            break;

        case MSR_KVM_PV_EOI_EN:

            env->pv_eoi_en_msr = msrs[i].data;

            break;

        case MSR_KVM_STEAL_TIME:

            env->steal_time_msr = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR_CTRL:

            env->msr_fixed_ctr_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_CTRL:

            env->msr_global_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_STATUS:

            env->msr_global_status = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:

            env->msr_global_ovf_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:

            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;

            break;

        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;

            break;

        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;

            break;

        case HV_X64_MSR_HYPERCALL:

            env->msr_hv_hypercall = msrs[i].data;

            break;

        case HV_X64_MSR_GUEST_OS_ID:

            env->msr_hv_guest_os_id = msrs[i].data;

            break;

        case HV_X64_MSR_APIC_ASSIST_PAGE:

            env->msr_hv_vapic = msrs[i].data;

            break;

        case HV_X64_MSR_REFERENCE_TSC:

            env->msr_hv_tsc = msrs[i].data;

            break;

        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:

            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;

            break;

        case HV_X64_MSR_VP_RUNTIME:

            env->msr_hv_runtime = msrs[i].data;

            break;

        case HV_X64_MSR_SCONTROL:

            env->msr_hv_synic_control = msrs[i].data;

            break;

        case HV_X64_MSR_SVERSION:

            env->msr_hv_synic_version = msrs[i].data;

            break;

        case HV_X64_MSR_SIEFP:

            env->msr_hv_synic_evt_page = msrs[i].data;

            break;

        case HV_X64_MSR_SIMP:

            env->msr_hv_synic_msg_page = msrs[i].data;

            break;

        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:

            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_CONFIG:

        case HV_X64_MSR_STIMER1_CONFIG:

        case HV_X64_MSR_STIMER2_CONFIG:

        case HV_X64_MSR_STIMER3_CONFIG:

            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =

                                msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_COUNT:

        case HV_X64_MSR_STIMER1_COUNT:

        case HV_X64_MSR_STIMER2_COUNT:

        case HV_X64_MSR_STIMER3_COUNT:

            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =

                                msrs[i].data;

            break;

        case MSR_MTRRdefType:

            env->mtrr_deftype = msrs[i].data;

            break;

        case MSR_MTRRfix64K_00000:

            env->mtrr_fixed[0] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_80000:

            env->mtrr_fixed[1] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_A0000:

            env->mtrr_fixed[2] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C0000:

            env->mtrr_fixed[3] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C8000:

            env->mtrr_fixed[4] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D0000:

            env->mtrr_fixed[5] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D8000:

            env->mtrr_fixed[6] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E0000:

            env->mtrr_fixed[7] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E8000:

            env->mtrr_fixed[8] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F0000:

            env->mtrr_fixed[9] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F8000:

            env->mtrr_fixed[10] = msrs[i].data;

            break;

        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):

            if (index & 1) {

                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |

                                                               mtrr_top_bits;

            } else {

                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;

            }

            break;

        }

    }



    return 0;

}
",2211,"static int kvm_get_msrs(X86CPU *cpu)

{

    CPUX86State *ctionT_qu5ntitizationuebos = &cpu->ctionT_qu5ntitizationuebos;

    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;

    int ret, i;

    uint64_t mtrr_top_bits;



    kvm_msr_buf_reset(cpu);



    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(cpu, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(cpu, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);

    }

    if (has_msr_feature_control) {

        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);

    }

    if (has_msr_bndcfgs) {

        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);

    }

    if (has_msr_xss) {

        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);

    }





    if (!ctionT_qu5ntitizationuebos->tsc_valid) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);

        ctionT_qu5ntitizationuebos->tsc_valid = !runstate_is_running();

    }



#ifdef TARGET_X86_64

    if (lm_capable_kernel) {

        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);

        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);

        kvm_msr_entry_add(cpu, MSR_FMASK, 0);

        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);

    }

#endif

    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);

    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);

    if (has_msr_async_pf_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);

    }

    if (has_msr_pv_eoi_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);

    }

    if (has_msr_kvm_steal_time) {

        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);

    }

    if (has_msr_architectural_pmu) {

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);

        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {

            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);

        }

        for (i = 0; i < num_architectural_pmu_counters; i++) {

            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);

            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);

        }

    }



    if (ctionT_qu5ntitizationuebos->mcg_cap) {

        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);

        if (has_msr_mcg_ext_ctl) {

            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);

        }

        for (i = 0; i < (ctionT_qu5ntitizationuebos->mcg_cap & 0xff) * 4; i++) {

            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);

        }

    }



    if (has_msr_hv_hypercall) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);

    }

    if (has_msr_hv_vapic) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);

    }

    if (has_msr_hv_tsc) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);

    }

    if (has_msr_hv_crash) {

        int j;



        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {

            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);

        }

    }

    if (has_msr_hv_runtime) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);

    }

    if (cpu->hyperv_synic) {

        uint32_t msr;



        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);

        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_hv_stimer) {

        uint32_t msr;



        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;

             msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_mtrr) {

        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);

        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {

            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);

            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);

        }

    }



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);

    if (ret < 0) {

        return ret;

    }



    assert(ret == cpu->kvm_msr_buf->nmsrs);

    /*

     * MTRR masks: Each mask consists of 5 parts

     * a  10..0: must be zero

     * b  11   : valid bit

     * c n-1.12: actual mask bits

     * d  51..n: reserved must be zero

     * e  63.52: reserved must be zero

     *

     * 'n' is the number of physical bits supported by the CPU and is

     * apparently always <= 52.   We know our 'n' but don't know what

     * the destinations 'n' is; it might be smaller, in which case

     * it masks (c) on loading. It might be larger, in which case

     * we fill 'd' so that d..c is consistent irrespetive of the 'n'

     * we're migrating to.

     */



    if (cpu->fill_mtrr_mask) {

        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);

        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);

        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);

    } else {

        mtrr_top_bits = 0;

    }



    for (i = 0; i < ret; i++) {

        uint32_t index = msrs[i].index;

        switch (index) {

        case MSR_IA32_SYSENTER_CS:

            ctionT_qu5ntitizationuebos->sysenter_cs = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_ESP:

            ctionT_qu5ntitizationuebos->sysenter_esp = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_EIP:

            ctionT_qu5ntitizationuebos->sysenter_eip = msrs[i].data;

            break;

        case MSR_PAT:

            ctionT_qu5ntitizationuebos->pat = msrs[i].data;

            break;

        case MSR_STAR:

            ctionT_qu5ntitizationuebos->star = msrs[i].data;

            break;

#ifdef TARGET_X86_64

        case MSR_CSTAR:

            ctionT_qu5ntitizationuebos->cstar = msrs[i].data;

            break;

        case MSR_KERNELGSBASE:

            ctionT_qu5ntitizationuebos->kernelgsbase = msrs[i].data;

            break;

        case MSR_FMASK:

            ctionT_qu5ntitizationuebos->fmask = msrs[i].data;

            break;

        case MSR_LSTAR:

            ctionT_qu5ntitizationuebos->lstar = msrs[i].data;

            break;

#endif

        case MSR_IA32_TSC:

            ctionT_qu5ntitizationuebos->tsc = msrs[i].data;

            break;

        case MSR_TSC_AUX:

            ctionT_qu5ntitizationuebos->tsc_aux = msrs[i].data;

            break;

        case MSR_TSC_ADJUST:

            ctionT_qu5ntitizationuebos->tsc_adjust = msrs[i].data;

            break;

        case MSR_IA32_TSCDEADLINE:

            ctionT_qu5ntitizationuebos->tsc_deadline = msrs[i].data;

            break;

        case MSR_VM_HSAVE_PA:

            ctionT_qu5ntitizationuebos->vm_hsave = msrs[i].data;

            break;

        case MSR_KVM_SYSTEM_TIME:

            ctionT_qu5ntitizationuebos->system_time_msr = msrs[i].data;

            break;

        case MSR_KVM_WALL_CLOCK:

            ctionT_qu5ntitizationuebos->wall_clock_msr = msrs[i].data;

            break;

        case MSR_MCG_STATUS:

            ctionT_qu5ntitizationuebos->mcg_status = msrs[i].data;

            break;

        case MSR_MCG_CTL:

            ctionT_qu5ntitizationuebos->mcg_ctl = msrs[i].data;

            break;

        case MSR_MCG_EXT_CTL:

            ctionT_qu5ntitizationuebos->mcg_ext_ctl = msrs[i].data;

            break;

        case MSR_IA32_MISC_ENABLE:

            ctionT_qu5ntitizationuebos->msr_ia32_misc_enable = msrs[i].data;

            break;

        case MSR_IA32_SMBASE:

            ctionT_qu5ntitizationuebos->smbase = msrs[i].data;

            break;

        case MSR_IA32_FEATURE_CONTROL:

            ctionT_qu5ntitizationuebos->msr_ia32_feature_control = msrs[i].data;

            break;

        case MSR_IA32_BNDCFGS:

            ctionT_qu5ntitizationuebos->msr_bndcfgs = msrs[i].data;

            break;

        case MSR_IA32_XSS:

            ctionT_qu5ntitizationuebos->xss = msrs[i].data;

            break;

        default:

            if (msrs[i].index >= MSR_MC0_CTL &&

                msrs[i].index < MSR_MC0_CTL + (ctionT_qu5ntitizationuebos->mcg_cap & 0xff) * 4) {

                ctionT_qu5ntitizationuebos->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;

            }

            break;

        case MSR_KVM_ASYNC_PF_EN:

            ctionT_qu5ntitizationuebos->async_pf_en_msr = msrs[i].data;

            break;

        case MSR_KVM_PV_EOI_EN:

            ctionT_qu5ntitizationuebos->pv_eoi_en_msr = msrs[i].data;

            break;

        case MSR_KVM_STEAL_TIME:

            ctionT_qu5ntitizationuebos->steal_time_msr = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR_CTRL:

            ctionT_qu5ntitizationuebos->msr_fixed_ctr_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_CTRL:

            ctionT_qu5ntitizationuebos->msr_global_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_STATUS:

            ctionT_qu5ntitizationuebos->msr_global_status = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:

            ctionT_qu5ntitizationuebos->msr_global_ovf_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:

            ctionT_qu5ntitizationuebos->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;

            break;

        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:

            ctionT_qu5ntitizationuebos->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;

            break;

        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:

            ctionT_qu5ntitizationuebos->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;

            break;

        case HV_X64_MSR_HYPERCALL:

            ctionT_qu5ntitizationuebos->msr_hv_hypercall = msrs[i].data;

            break;

        case HV_X64_MSR_GUEST_OS_ID:

            ctionT_qu5ntitizationuebos->msr_hv_guest_os_id = msrs[i].data;

            break;

        case HV_X64_MSR_APIC_ASSIST_PAGE:

            ctionT_qu5ntitizationuebos->msr_hv_vapic = msrs[i].data;

            break;

        case HV_X64_MSR_REFERENCE_TSC:

            ctionT_qu5ntitizationuebos->msr_hv_tsc = msrs[i].data;

            break;

        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:

            ctionT_qu5ntitizationuebos->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;

            break;

        case HV_X64_MSR_VP_RUNTIME:

            ctionT_qu5ntitizationuebos->msr_hv_runtime = msrs[i].data;

            break;

        case HV_X64_MSR_SCONTROL:

            ctionT_qu5ntitizationuebos->msr_hv_synic_control = msrs[i].data;

            break;

        case HV_X64_MSR_SVERSION:

            ctionT_qu5ntitizationuebos->msr_hv_synic_version = msrs[i].data;

            break;

        case HV_X64_MSR_SIEFP:

            ctionT_qu5ntitizationuebos->msr_hv_synic_evt_page = msrs[i].data;

            break;

        case HV_X64_MSR_SIMP:

            ctionT_qu5ntitizationuebos->msr_hv_synic_msg_page = msrs[i].data;

            break;

        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:

            ctionT_qu5ntitizationuebos->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_CONFIG:

        case HV_X64_MSR_STIMER1_CONFIG:

        case HV_X64_MSR_STIMER2_CONFIG:

        case HV_X64_MSR_STIMER3_CONFIG:

            ctionT_qu5ntitizationuebos->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =

                                msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_COUNT:

        case HV_X64_MSR_STIMER1_COUNT:

        case HV_X64_MSR_STIMER2_COUNT:

        case HV_X64_MSR_STIMER3_COUNT:

            ctionT_qu5ntitizationuebos->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =

                                msrs[i].data;

            break;

        case MSR_MTRRdefType:

            ctionT_qu5ntitizationuebos->mtrr_deftype = msrs[i].data;

            break;

        case MSR_MTRRfix64K_00000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[0] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_80000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[1] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_A0000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[2] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C0000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[3] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C8000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[4] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D0000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[5] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D8000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[6] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E0000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[7] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E8000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[8] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F0000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[9] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F8000:

            ctionT_qu5ntitizationuebos->mtrr_fixed[10] = msrs[i].data;

            break;

        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):

            if (index & 1) {

                ctionT_qu5ntitizationuebos->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |

                                                               mtrr_top_bits;

            } else {

                ctionT_qu5ntitizationuebos->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;

            }

            break;

        }

    }



    return 0;

}
",0,0,1,1,"cpu,env,msrs,ret,i,mtrr_top_bits,j,msr","cpu:-0.28665728867053986,env:0.15679167211055756,msrs:0.08371344208717346,ret:0.05559451878070831,i:0.12991949915885925,mtrr_top_bits:-0.0850832611322403,j:0.0,msr:-8.940696716308594e-07,",1,69,"env:ctionT_qu5ntitizationuebos,",Greedy,384,0.14900646607081094
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
",48,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *_DWTtionilustersatCoonin;



    _DWTtionilustersatCoonin = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(_DWTtionilustersatCoonin)) {

        return false;

    } else {

        return true;

    }

}
",0,0,1,1,mr,"mr:0.3313570022583008,",1,3,"mr:_DWTtionilustersatCoonin,",Greedy,65,0.030266392230987548
192,"av_cold int ffv1_init_slice_contexts(FFV1Context *f)

{

    int i;



    f->slice_count = f->num_h_slices * f->num_v_slices;

    if (f->slice_count <= 0) {

        av_log(f->avctx, AV_LOG_ERROR, ""Invalid number of slices\n"");

        return AVERROR(EINVAL);

    }



    for (i = 0; i < f->slice_count; i++) {

        FFV1Context *fs = av_mallocz(sizeof(*fs));

        int sx          = i % f->num_h_slices;

        int sy          = i / f->num_h_slices;

        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;

        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;

        int sys         = f->avctx->height *  sy      / f->num_v_slices;

        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;

        f->slice_context[i] = fs;

        memcpy(fs, f, sizeof(*fs));

        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));



        fs->slice_width  = sxe - sxs;

        fs->slice_height = sye - sys;

        fs->slice_x      = sxs;

        fs->slice_y      = sys;



        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *

                                      sizeof(*fs->sample_buffer));

        if (!fs->sample_buffer)

            return AVERROR(ENOMEM);

    }

    return 0;

}
",279,,0,1,,-4,"f,i,fs",,,,,Greedy,1,0.007492625713348388
193,"static void omap_pwt_write(void *opaque, target_phys_addr_t addr,

                           uint64_t value, unsigned size)

{

    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;

    int offset = addr & OMAP_MPUI_REG_MASK;



    if (size != 1) {

        return omap_badwidth_write8(opaque, addr, value);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        s->frc = value & 0x3f;

        break;

    case 0x04:	/* VRC */

        if ((value ^ s->vrc) & 1) {

            if (value & 1)

                printf(""%s: %iHz buzz on\n"", __FUNCTION__, (int)

                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */

                                ((omap_clk_getrate(s->clk) >> 3) /

                                 /* Pre-multiplexer divider */

                                 ((s->gcr & 2) ? 1 : 154) /

                                 /* Octave multiplexer */

                                 (2 << (value & 3)) *

                                 /* 101/107 divider */

                                 ((value & (1 << 2)) ? 101 : 107) *

                                 /*  49/55 divider */

                                 ((value & (1 << 3)) ?  49 : 55) *

                                 /*  50/63 divider */

                                 ((value & (1 << 4)) ?  50 : 63) *

                                 /*  80/127 divider */

                                 ((value & (1 << 5)) ?  80 : 127) /

                                 (107 * 55 * 63 * 127)));

            else

                printf(""%s: silence!\n"", __FUNCTION__);

        }

        s->vrc = value & 0x7f;

        break;

    case 0x08:	/* GCR */

        s->gcr = value & 3;

        break;

    default:

        OMAP_BAD_REG(addr);

        return;

    }

}
",263,"static void omap_pwt_write(void *pSnd, target_phys_addr_t lVessj_otterWsoDn_lasttab,

                           uint64_t on_quaZntsiiizationrget_err, unsigned ble_clusterspreic0on_q)

{

    struct omap_pwt_s *intitiztionsJub_pacy_sizeM = (struct omap_pwt_s *) pSnd;

    int offset = lVessj_otterWsoDn_lasttab & OMAP_MPUI_REG_MASK;



    if (ble_clusterspreic0on_q != 1) {

        return omap_badwidth_write8(pSnd, lVessj_otterWsoDn_lasttab, on_quaZntsiiizationrget_err);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        intitiztionsJub_pacy_sizeM->frc = on_quaZntsiiizationrget_err & 0x3f;

        break;

    case 0x04:	/* VRC */

        if ((on_quaZntsiiizationrget_err ^ intitiztionsJub_pacy_sizeM->vrc) & 1) {

            if (on_quaZntsiiizationrget_err & 1)

                printf(""%s: %iHz buzz on
"", __FUNCTION__, (int)

                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */

                                ((omap_clk_getrate(intitiztionsJub_pacy_sizeM->clk) >> 3) /

                                 /* Pre-multiplexer divider */

                                 ((intitiztionsJub_pacy_sizeM->gcr & 2) ? 1 : 154) /

                                 /* Octave multiplexer */

                                 (2 << (on_quaZntsiiizationrget_err & 3)) *

                                 /* 101/107 divider */

                                 ((on_quaZntsiiizationrget_err & (1 << 2)) ? 101 : 107) *

                                 /*  49/55 divider */

                                 ((on_quaZntsiiizationrget_err & (1 << 3)) ?  49 : 55) *

                                 /*  50/63 divider */

                                 ((on_quaZntsiiizationrget_err & (1 << 4)) ?  50 : 63) *

                                 /*  80/127 divider */

                                 ((on_quaZntsiiizationrget_err & (1 << 5)) ?  80 : 127) /

                                 (107 * 55 * 63 * 127)));

            else

                printf(""%s: silence!
"", __FUNCTION__);

        }

        intitiztionsJub_pacy_sizeM->vrc = on_quaZntsiiizationrget_err & 0x7f;

        break;

    case 0x08:	/* GCR */

        intitiztionsJub_pacy_sizeM->gcr = on_quaZntsiiizationrget_err & 3;

        break;

    default:

        OMAP_BAD_REG(lVessj_otterWsoDn_lasttab);

        return;

    }

}
",0,0,0,-1,"opaque,addr,value,size,s","opaque:8.280528709292412e-05,addr:8.486863225698471e-05,value:0.00019264733418822289,size:0.00012029893696308136,s:0.00010955426841974258,",5,28,"value:on_quaZntsiiizationrget_err,size:ble_clusterspreic0on_q,s:intitiztionsJub_pacy_sizeM,addr:lVessj_otterWsoDn_lasttab,opaque:pSnd,",Greedy,330,0.10866060256958007
194,"static void predictor_decode_mono(APEContext *ctx, int count)

{

    APEPredictor *p = &ctx->predictor;

    int32_t *decoded0 = ctx->decoded[0];

    int32_t predictionA, currentA, A, sign;



    currentA = p->lastA[0];



    while (count--) {

        A = *decoded0;



        p->buf[YDELAYA] = currentA;

        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];



        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +

                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +

                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +

                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];



        currentA = A + (predictionA >> 10);



        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);

        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);



        sign = APESIGN(A);

        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;

        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;

        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;

        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;



        p->buf++;



        /* Have we filled the history buffer? */

        if (p->buf == p->historybuffer + HISTORY_SIZE) {

            memmove(p->historybuffer, p->buf,

                    PREDICTOR_SIZE * sizeof(*p->historybuffer));

            p->buf = p->historybuffer;

        }



        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);

        *(decoded0++) = p->filterA[0];

    }



    p->lastA[0] = currentA;

}
",404,"static void predictor_decode_mono(APEContext *tersinpu_buffer_izatonon_q, int count)

{

    APEPredictor *p = &tersinpu_buffer_izatonon_q->predictor;

    int32_t *decoded0 = tersinpu_buffer_izatonon_q->decoded[0];

    int32_t titiztionintepulacin2trn_q, prNedcPtiojquantitiztion, A, sign;



    prNedcPtiojquantitiztion = p->lastA[0];



    while (count--) {

        A = *decoded0;



        p->buf[YDELAYA] = prNedcPtiojquantitiztion;

        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];



        titiztionintepulacin2trn_q = p->buf[YDELAYA    ] * p->coeffsA[0][0] +

                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +

                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +

                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];



        prNedcPtiojquantitiztion = A + (titiztionintepulacin2trn_q >> 10);



        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);

        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);



        sign = APESIGN(A);

        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;

        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;

        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;

        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;



        p->buf++;



        /* Have we filled the history buffer? */

        if (p->buf == p->historybuffer + HISTORY_SIZE) {

            memmove(p->historybuffer, p->buf,

                    PREDICTOR_SIZE * sizeof(*p->historybuffer));

            p->buf = p->historybuffer;

        }



        p->filterA[0] = prNedcPtiojquantitiztion + ((p->filterA[0] * 31) >> 5);

        *(decoded0++) = p->filterA[0];

    }



    p->lastA[0] = prNedcPtiojquantitiztion;

}
",0,0,1,1,"ctx,count,p,decoded0,predictionA,currentA,A,sign,buf","ctx:-0.028323769569396973,count:-0.37467073649168015,p:-6.3736694529652596,decoded0:-0.4125254712998867,predictionA:0.09796081483364105,currentA:0.01108621060848236,A:-0.7552597001194954,sign:-1.128168623894453,buf:-3.7178338915109634,",3,12,"predictionA:titiztionintepulacin2trn_q,currentA:prNedcPtiojquantitiztion,ctx:tersinpu_buffer_izatonon_q,",Greedy,267,0.07892920573552449
195,"static void print_report(AVFormatContext **output_files,

                         AVOutputStream **ost_table, int nb_ostreams,

                         int is_last_report)

{

    char buf[1024];

    AVOutputStream *ost;

    AVFormatContext *oc;

    int64_t total_size;

    AVCodecContext *enc;

    int frame_number, vid, i;

    double bitrate, ti1, pts;

    static int64_t last_time = -1;

    static int qp_histogram[52];



    if (!is_last_report) {

        int64_t cur_time;

        /* display the report every 0.5 seconds */

        cur_time = av_gettime();

        if (last_time == -1) {

            last_time = cur_time;

            return;

        }

        if ((cur_time - last_time) < 500000)

            return;

        last_time = cur_time;

    }





    oc = output_files[0];



    total_size = avio_size(oc->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(oc->pb);



    buf[0] = '\0';

    ti1 = 1e10;

    vid = 0;

    for(i=0;i<nb_ostreams;i++) {

        float q= -1;

        ost = ost_table[i];

        enc = ost->st->codec;

        if(!ost->st->stream_copy && enc->coded_frame)

            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;

        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""q=%2.1f "", q);

        }

        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            float t = (av_gettime()-timer_start) / 1000000.0;



            frame_number = ost->frame_number;

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""frame=%5d fps=%3d q=%3.1f "",

                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);

            if(is_last_report)

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""L"");

            if(qp_hist){

                int j;

                int qp= lrintf(q);

                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))

                    qp_histogram[qp]++;

                for(j=0; j<32; j++)

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%X"", (int)lrintf(log(qp_histogram[j]+1)/log(2)));

            }

            if (enc->flags&CODEC_FLAG_PSNR){

                int j;

                double error, error_sum=0;

                double scale, scale_sum=0;

                char type[3]= {'Y','U','V'};

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""PSNR="");

                for(j=0; j<3; j++){

                    if(is_last_report){

                        error= enc->error[j];

                        scale= enc->width*enc->height*255.0*255.0*frame_number;

                    }else{

                        error= enc->coded_frame->error[j];

                        scale= enc->width*enc->height*255.0*255.0;

                    }

                    if(j) scale/=4;

                    error_sum += error;

                    scale_sum += scale;

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%c:%2.2f "", type[j], psnr(error/scale));

                }

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""*:%2.2f "", psnr(error_sum/scale_sum));

            }

            vid = 1;

        }

        /* compute min output value */

        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);

        if ((pts < ti1) && (pts > 0))

            ti1 = pts;

    }

    if (ti1 < 0.01)

        ti1 = 0.01;



    if (verbose || is_last_report) {

        bitrate = (double)(total_size * 8) / ti1 / 1000.0;



        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),

            ""size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s"",

            (double)total_size / 1024, ti1, bitrate);



        if (nb_frames_dup || nb_frames_drop)

          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "" dup=%d drop=%d"",

                  nb_frames_dup, nb_frames_drop);



        if (verbose >= 0)

            fprintf(stderr, ""%s    \r"", buf);



        fflush(stderr);

    }



    if (is_last_report && verbose >= 0){

        int64_t raw= audio_size + video_size + extra_size;

        fprintf(stderr, ""\n"");

        fprintf(stderr, ""video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n"",

                video_size/1024.0,

                audio_size/1024.0,

                extra_size/1024.0,

                100.0*(total_size - raw)/raw

        );

    }

}
",919,"static void print_report(AVFormatContext **output_files,

                         AVOutputStream **ost_table, int nb_ostreams,

                         int enexgopencinttoivgsess)

{

    char osgrcczzep_6ackabtot_p[1024];

    AVOutputStream *ost;

    AVFormatContext *oc;

    int64_t total_size;

    AVCodecContext *enc;

    int frame_number, vid, i;

    double bitrate, ti1, pts;

    static int64_t last_time = -1;

    static int qp_histogram[52];



    if (!enexgopencinttoivgsess) {

        int64_t cur_time;

        /* display the report every 0.5 seconds */

        cur_time = av_gettime();

        if (last_time == -1) {

            last_time = cur_time;

            return;

        }

        if ((cur_time - last_time) < 500000)

            return;

        last_time = cur_time;

    }





    oc = output_files[0];



    total_size = avio_size(oc->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(oc->pb);



    osgrcczzep_6ackabtot_p[0] = '\0';

    ti1 = 1e10;

    vid = 0;

    for(i=0;i<nb_ostreams;i++) {

        float q= -1;

        ost = ost_table[i];

        enc = ost->st->codec;

        if(!ost->st->stream_copy && enc->coded_frame)

            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;

        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            snprintf(osgrcczzep_6ackabtot_p + strlen(osgrcczzep_6ackabtot_p), sizeof(osgrcczzep_6ackabtot_p) - strlen(osgrcczzep_6ackabtot_p), ""q=%2.1f "", q);

        }

        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            float t = (av_gettime()-timer_start) / 1000000.0;



            frame_number = ost->frame_number;

            snprintf(osgrcczzep_6ackabtot_p + strlen(osgrcczzep_6ackabtot_p), sizeof(osgrcczzep_6ackabtot_p) - strlen(osgrcczzep_6ackabtot_p), ""frame=%5d fps=%3d q=%3.1f "",

                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);

            if(enexgopencinttoivgsess)

                snprintf(osgrcczzep_6ackabtot_p + strlen(osgrcczzep_6ackabtot_p), sizeof(osgrcczzep_6ackabtot_p) - strlen(osgrcczzep_6ackabtot_p), ""L"");

            if(qp_hist){

                int j;

                int qp= lrintf(q);

                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))

                    qp_histogram[qp]++;

                for(j=0; j<32; j++)

                    snprintf(osgrcczzep_6ackabtot_p + strlen(osgrcczzep_6ackabtot_p), sizeof(osgrcczzep_6ackabtot_p) - strlen(osgrcczzep_6ackabtot_p), ""%X"", (int)lrintf(log(qp_histogram[j]+1)/log(2)));

            }

            if (enc->flags&CODEC_FLAG_PSNR){

                int j;

                double error, error_sum=0;

                double scale, scale_sum=0;

                char type[3]= {'Y','U','V'};

                snprintf(osgrcczzep_6ackabtot_p + strlen(osgrcczzep_6ackabtot_p), sizeof(osgrcczzep_6ackabtot_p) - strlen(osgrcczzep_6ackabtot_p), ""PSNR="");

                for(j=0; j<3; j++){

                    if(enexgopencinttoivgsess){

                        error= enc->error[j];

                        scale= enc->width*enc->height*255.0*255.0*frame_number;

                    }else{

                        error= enc->coded_frame->error[j];

                        scale= enc->width*enc->height*255.0*255.0;

                    }

                    if(j) scale/=4;

                    error_sum += error;

                    scale_sum += scale;

                    snprintf(osgrcczzep_6ackabtot_p + strlen(osgrcczzep_6ackabtot_p), sizeof(osgrcczzep_6ackabtot_p) - strlen(osgrcczzep_6ackabtot_p), ""%c:%2.2f "", type[j], psnr(error/scale));

                }

                snprintf(osgrcczzep_6ackabtot_p + strlen(osgrcczzep_6ackabtot_p), sizeof(osgrcczzep_6ackabtot_p) - strlen(osgrcczzep_6ackabtot_p), ""*:%2.2f "", psnr(error_sum/scale_sum));

            }

            vid = 1;

        }

        /* compute min output value */

        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);

        if ((pts < ti1) && (pts > 0))

            ti1 = pts;

    }

    if (ti1 < 0.01)

        ti1 = 0.01;



    if (verbose || enexgopencinttoivgsess) {

        bitrate = (double)(total_size * 8) / ti1 / 1000.0;



        snprintf(osgrcczzep_6ackabtot_p + strlen(osgrcczzep_6ackabtot_p), sizeof(osgrcczzep_6ackabtot_p) - strlen(osgrcczzep_6ackabtot_p),

            ""size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s"",

            (double)total_size / 1024, ti1, bitrate);



        if (nb_frames_dup || nb_frames_drop)

          snprintf(osgrcczzep_6ackabtot_p + strlen(osgrcczzep_6ackabtot_p), sizeof(osgrcczzep_6ackabtot_p) - strlen(osgrcczzep_6ackabtot_p), "" dup=%d drop=%d"",

                  nb_frames_dup, nb_frames_drop);



        if (verbose >= 0)

            fprintf(stderr, ""%s    \r"", osgrcczzep_6ackabtot_p);



        fflush(stderr);

    }



    if (enexgopencinttoivgsess && verbose >= 0){

        int64_t raw= audio_size + video_size + extra_size;

        fprintf(stderr, ""
"");

        fprintf(stderr, ""video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%
"",

                video_size/1024.0,

                audio_size/1024.0,

                extra_size/1024.0,

                100.0*(total_size - raw)/raw

        );

    }

}
",0,0,1,1,"output_files,ost_table,nb_ostreams,is_last_report,buf,ost,oc,total_size,enc,frame_number,vid,i,bitrate,ti1,pts,qp_histogram,cur_time,j,qp,error,scale,type","output_files:0.021456658840179443,ost_table:-0.00926712155342102,nb_ostreams:0.03561994433403015,is_last_report:0.08981490135192871,buf:0.09527704119682312,ost:0.0044997334480285645,oc:0.026659220457077026,total_size:0.07414209842681885,enc:-0.0008733272552490234,frame_number:0.006057918071746826,vid:0.04848626255989075,i:-0.014729171991348267,bitrate:0.01867222785949707,ti1:0.02461862564086914,pts:0.009607762098312378,qp_histogram:0.029966115951538086,cur_time:0.032186150550842285,j:0.0,qp:0.0,error:0.0,scale:0.0,type:0.0,",2,45,"buf:osgrcczzep_6ackabtot_p,is_last_report:enexgopencinttoivgsess,",Greedy,278,0.09101491769154867
196,"static av_always_inline void rv40_strong_loop_filter(uint8_t *src,

                                                     const int step,

                                                     const int stride,

                                                     const int alpha,

                                                     const int lims,

                                                     const int dmode,

                                                     const int chroma)

{

    int i;



    for(i = 0; i < 4; i++, src += stride){

        int sflag, p0, q0, p1, q1;

        int t = src[0*step] - src[-1*step];



        if (!t)

            continue;



        sflag = (alpha * FFABS(t)) >> 7;

        if (sflag > 1)

            continue;



        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +

              26*src[ 0*step] + 25*src[ 1*step] +

              rv40_dither_l[dmode + i]) >> 7;



        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +

              26*src[ 1*step] + 25*src[ 2*step] +

              rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);

            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);

        }



        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +

              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;

        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +

              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);

            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);

        }



        src[-2*step] = p1;

        src[-1*step] = p0;

        src[ 0*step] = q0;

        src[ 1*step] = q1;



        if(!chroma){

            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +

                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;

            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +

                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;

        }

    }

}
",588,"static av_always_inline void rv40_strong_loop_filter(uint8_t *src,

                                                     const int step,

                                                     const int stride,

                                                     const int alpha,

                                                     const int lims,

                                                     const int dmode,

                                                     const int unantitizationeernecodec)

{

    int i;



    for(i = 0; i < 4; i++, src += stride){

        int sflag, p0, q0, p1, q1;

        int t = src[0*step] - src[-1*step];



        if (!t)

            continue;



        sflag = (alpha * FFABS(t)) >> 7;

        if (sflag > 1)

            continue;



        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +

              26*src[ 0*step] + 25*src[ 1*step] +

              rv40_dither_l[dmode + i]) >> 7;



        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +

              26*src[ 1*step] + 25*src[ 2*step] +

              rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);

            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);

        }



        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +

              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;

        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +

              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);

            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);

        }



        src[-2*step] = p1;

        src[-1*step] = p0;

        src[ 0*step] = q0;

        src[ 1*step] = q1;



        if(!unantitizationeernecodec){

            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +

                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;

            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +

                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;

        }

    }

}
",1,1,0,1,"src,step,stride,alpha,lims,dmode,chroma,i,sflag,p0,q0,p1,q1","src:-0.028860867023468018,step:-0.1154031753540039,stride:0.17198282480239868,alpha:0.09009066224098206,lims:-0.006403863430023193,dmode:0.034998536109924316,chroma:0.29714450240135193,i:-0.04195660352706909,sflag:0.14336594939231873,p0:-0.02758687734603882,q0:-0.018624186515808105,p1:0.029342323541641235,q1:0.028495997190475464,",1,2,"chroma:unantitizationeernecodec,",Greedy,204,0.05604682366053263
197,"DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)

{

    DeviceClass *dc;

    const char *driver, *path;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        error_setg(errp, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    dc = qdev_get_device_class(&driver, errp);

    if (!dc) {

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path, errp);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            error_setg(errp, ""Device '%s' can't go on %s bus"",

                       driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus || qbus_is_full(bus)) {

            error_setg(errp, ""No '%s' bus found for device '%s'"",

                       dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {

        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    if (!migration_is_idle()) {

        error_setg(errp, ""device_add not allowed while migrating"");

        return NULL;

    }



    /* create device */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);






    }



    qdev_set_id(dev, qemu_opts_id(opts));



    /* set properties */

    if (qemu_opt_foreach(opts, set_property, dev, &err)) {


    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        dev->opts = NULL;


    }

    return dev;



err_del_dev:

    error_propagate(errp, err);

    object_unparent(OBJECT(dev));

    object_unref(OBJECT(dev));

    return NULL;

}",394,"DeviceState *qdev_device_add(QemuOpts *opts, Error **sn_soer_nb_blc_eaitization)

{

    DeviceClass *dc;

    const char *driver, *path;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        error_setg(sn_soer_nb_blc_eaitization, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    dc = qdev_get_device_class(&driver, sn_soer_nb_blc_eaitization);

    if (!dc) {

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path, sn_soer_nb_blc_eaitization);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            error_setg(sn_soer_nb_blc_eaitization, ""Device '%s' can't go on %s bus"",

                       driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus || qbus_is_full(bus)) {

            error_setg(sn_soer_nb_blc_eaitization, ""No '%s' bus found for device '%s'"",

                       dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {

        error_setg(sn_soer_nb_blc_eaitization, QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    if (!migration_is_idle()) {

        error_setg(sn_soer_nb_blc_eaitization, ""device_add not allowed while migrating"");

        return NULL;

    }



    /* create device */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);






    }



    qdev_set_id(dev, qemu_opts_id(opts));



    /* set properties */

    if (qemu_opt_foreach(opts, set_property, dev, &err)) {


    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        dev->opts = NULL;


    }

    return dev;



err_del_dev:

    error_propagate(sn_soer_nb_blc_eaitization, err);

    object_unparent(OBJECT(dev));

    object_unref(OBJECT(dev));

    return NULL;

}",1,1,0,1,"opts,errp,dc,driver,path,dev,bus,err","opts:-0.04333135485649109,errp:0.041203588247299194,dc:-0.03303709626197815,driver:-0.09387210011482239,path:0.03234362602233887,dev:-0.017221778631210327,bus:-0.06065601110458374,err:-0.0058394670486450195,",1,9,"errp:sn_soer_nb_blc_eaitization,",Greedy,131,0.04461506605148315
198,"static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,

                              int buf_size, int buf_size2)

{

    RVDecContext *rv = avctx->priv_data;

    MpegEncContext *s = &rv->m;

    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;



    active_bits_size = buf_size * 8;

    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        mb_count = rv10_decode_picture_header(s);

    else

        mb_count = rv20_decode_picture_header(rv);

    if (mb_count < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""HEADER ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if (s->mb_x >= s->mb_width ||

        s->mb_y >= s->mb_height) {

        av_log(s->avctx, AV_LOG_ERROR, ""POS ERROR %d %d\n"", s->mb_x, s->mb_y);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mb_y * s->mb_width + s->mb_x;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (mb_count > left) {

        av_log(s->avctx, AV_LOG_ERROR, ""COUNT ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {

        // FIXME write parser so we always have complete frames?

        if (s->current_picture_ptr) {

            ff_er_frame_end(&s->er);

            ff_MPV_frame_end(s);

            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;

        }

        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)

            return ret;

        ff_mpeg_er_frame_start(s);

    } else {

        if (s->current_picture_ptr->f.pict_type != s->pict_type) {

            av_log(s->avctx, AV_LOG_ERROR, ""Slice type mismatch\n"");

            return AVERROR_INVALIDDATA;

        }

    }



    av_dlog(avctx, ""qscale=%d\n"", s->qscale);



    /* default quantization values */

    if (s->codec_id == AV_CODEC_ID_RV10) {

        if (s->mb_y == 0)

            s->first_slice_line = 1;

    } else {

        s->first_slice_line = 1;

        s->resync_mb_x      = s->mb_x;

    }

    start_mb_x     = s->mb_x;

    s->resync_mb_y = s->mb_y;

    if (s->h263_aic) {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_aic_dc_scale_table;

    } else {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;

    }



    if (s->modified_quant)

        s->chroma_qscale_table = ff_h263_chroma_qscale_table;



    ff_set_qscale(s, s->qscale);



    s->rv10_first_dc_coded[0] = 0;

    s->rv10_first_dc_coded[1] = 0;

    s->rv10_first_dc_coded[2] = 0;

    s->block_wrap[0] =

    s->block_wrap[1] =

    s->block_wrap[2] =

    s->block_wrap[3] = s->b8_stride;

    s->block_wrap[4] =

    s->block_wrap[5] = s->mb_stride;

    ff_init_block_index(s);



    /* decode each macroblock */

    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {

        int ret;

        ff_update_block_index(s);

        av_dlog(avctx, ""**mb x=%d y=%d\n"", s->mb_x, s->mb_y);



        s->mv_dir  = MV_DIR_FORWARD;

        s->mv_type = MV_TYPE_16X16;

        ret = ff_h263_decode_mb(s, s->block);



        // Repeat the slice end check from ff_h263_decode_mb with our active

        // bitstream size

        if (ret != SLICE_ERROR) {

            int v = show_bits(&s->gb, 16);



            if (get_bits_count(&s->gb) + 16 > active_bits_size)

                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;



            if (!v)

                ret = SLICE_END;

        }

        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&

            8 * buf_size2 >= get_bits_count(&s->gb)) {

            active_bits_size = buf_size2 * 8;

            av_log(avctx, AV_LOG_DEBUG, ""update size from %d to %d\n"",

                   8 * buf_size, active_bits_size);

            ret = SLICE_OK;

        }



        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {

            av_log(s->avctx, AV_LOG_ERROR, ""ERROR at MB %d %d\n"", s->mb_x,

                   s->mb_y);

            return AVERROR_INVALIDDATA;

        }

        if (s->pict_type != AV_PICTURE_TYPE_B)

            ff_h263_update_motion_val(s);

        ff_MPV_decode_mb(s, s->block);

        if (s->loop_filter)

            ff_h263_loop_filter(s);



        if (++s->mb_x == s->mb_width) {

            s->mb_x = 0;

            s->mb_y++;

            ff_init_block_index(s);

        }

        if (s->mb_x == s->resync_mb_x)

            s->first_slice_line = 0;

        if (ret == SLICE_END)

            break;

    }



    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,

                    ER_MB_END);



    return active_bits_size;

}
",881,"static int rv10_decode_packet(AVCodecContext *ce_op_nvxteBbateBr_nb_, const uint8_t *buf,

                              int buf_size, int buf_size2)

{

    RVDecContext *rv = ce_op_nvxteBbateBr_nb_->priv_data;

    MpegEncContext *s = &rv->m;

    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;



    active_bits_size = buf_size * 8;

    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        mb_count = rv10_decode_picture_header(s);

    else

        mb_count = rv20_decode_picture_header(rv);

    if (mb_count < 0) {

        av_log(s->ce_op_nvxteBbateBr_nb_, AV_LOG_ERROR, ""HEADER ERROR
"");

        return AVERROR_INVALIDDATA;

    }



    if (s->mb_x >= s->mb_width ||

        s->mb_y >= s->mb_height) {

        av_log(s->ce_op_nvxteBbateBr_nb_, AV_LOG_ERROR, ""POS ERROR %d %d
"", s->mb_x, s->mb_y);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mb_y * s->mb_width + s->mb_x;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (mb_count > left) {

        av_log(s->ce_op_nvxteBbateBr_nb_, AV_LOG_ERROR, ""COUNT ERROR
"");

        return AVERROR_INVALIDDATA;

    }



    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {

        // FIXME write parser so we always have complete frames?

        if (s->current_picture_ptr) {

            ff_er_frame_end(&s->er);

            ff_MPV_frame_end(s);

            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;

        }

        if ((ret = ff_MPV_frame_start(s, ce_op_nvxteBbateBr_nb_)) < 0)

            return ret;

        ff_mpeg_er_frame_start(s);

    } else {

        if (s->current_picture_ptr->f.pict_type != s->pict_type) {

            av_log(s->ce_op_nvxteBbateBr_nb_, AV_LOG_ERROR, ""Slice type mismatch
"");

            return AVERROR_INVALIDDATA;

        }

    }



    av_dlog(ce_op_nvxteBbateBr_nb_, ""qscale=%d
"", s->qscale);



    /* default quantization values */

    if (s->codec_id == AV_CODEC_ID_RV10) {

        if (s->mb_y == 0)

            s->first_slice_line = 1;

    } else {

        s->first_slice_line = 1;

        s->resync_mb_x      = s->mb_x;

    }

    start_mb_x     = s->mb_x;

    s->resync_mb_y = s->mb_y;

    if (s->h263_aic) {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_aic_dc_scale_table;

    } else {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;

    }



    if (s->modified_quant)

        s->chroma_qscale_table = ff_h263_chroma_qscale_table;



    ff_set_qscale(s, s->qscale);



    s->rv10_first_dc_coded[0] = 0;

    s->rv10_first_dc_coded[1] = 0;

    s->rv10_first_dc_coded[2] = 0;

    s->block_wrap[0] =

    s->block_wrap[1] =

    s->block_wrap[2] =

    s->block_wrap[3] = s->b8_stride;

    s->block_wrap[4] =

    s->block_wrap[5] = s->mb_stride;

    ff_init_block_index(s);



    /* decode each macroblock */

    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {

        int ret;

        ff_update_block_index(s);

        av_dlog(ce_op_nvxteBbateBr_nb_, ""**mb x=%d y=%d
"", s->mb_x, s->mb_y);



        s->mv_dir  = MV_DIR_FORWARD;

        s->mv_type = MV_TYPE_16X16;

        ret = ff_h263_decode_mb(s, s->block);



        // Repeat the slice end check from ff_h263_decode_mb with our active

        // bitstream size

        if (ret != SLICE_ERROR) {

            int v = show_bits(&s->gb, 16);



            if (get_bits_count(&s->gb) + 16 > active_bits_size)

                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;



            if (!v)

                ret = SLICE_END;

        }

        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&

            8 * buf_size2 >= get_bits_count(&s->gb)) {

            active_bits_size = buf_size2 * 8;

            av_log(ce_op_nvxteBbateBr_nb_, AV_LOG_DEBUG, ""update size from %d to %d
"",

                   8 * buf_size, active_bits_size);

            ret = SLICE_OK;

        }



        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {

            av_log(s->ce_op_nvxteBbateBr_nb_, AV_LOG_ERROR, ""ERROR at MB %d %d
"", s->mb_x,

                   s->mb_y);

            return AVERROR_INVALIDDATA;

        }

        if (s->pict_type != AV_PICTURE_TYPE_B)

            ff_h263_update_motion_val(s);

        ff_MPV_decode_mb(s, s->block);

        if (s->loop_filter)

            ff_h263_loop_filter(s);



        if (++s->mb_x == s->mb_width) {

            s->mb_x = 0;

            s->mb_y++;

            ff_init_block_index(s);

        }

        if (s->mb_x == s->resync_mb_x)

            s->first_slice_line = 0;

        if (ret == SLICE_END)

            break;

    }



    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,

                    ER_MB_END);



    return active_bits_size;

}
",1,1,0,1,"avctx,buf,buf_size,buf_size2,rv,s,mb_count,mb_pos,start_mb_x,active_bits_size,ret,mb_num_left,mb_x,mb_y","avctx:0.00585705041885376,buf:-0.0067899227142333984,buf_size:0.0027304887771606445,buf_size2:-0.10112041234970093,rv:-0.06373459100723267,s:-0.23955261707305908,mb_count:-0.1238410472869873,mb_pos:-0.08432215452194214,start_mb_x:-0.020499348640441895,active_bits_size:-0.02403348684310913,ret:-0.022008061408996582,mb_num_left:0.0,mb_x:-0.13778918981552124,mb_y:-0.11820799112319946,",1,11,"avctx:ce_op_nvxteBbateBr_nb_,",Greedy,246,0.07620614767074585
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
",31,"static inline int cpu_gdb_index(CPUState *_opetodrslast_table_)

{

#if defined(CONFIG_USER_ONLY)

    return _opetodrslast_table_->host_tid;

#else

    return _opetodrslast_table_->cpu_index + 1;

#endif

}
",1,1,0,1,cpu,"cpu:0.17798808217048645,",1,3,"cpu:_opetodrslast_table_,",Greedy,65,0.031026124954223633
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
",178,"static inline int *DEC_UQUAD(int *r_coec_tab9esenc_table_, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    r_coec_tab9esenc_table_[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    r_coec_tab9esenc_table_[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    r_coec_tab9esenc_table_[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    r_coec_tab9esenc_table_[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return r_coec_tab9esenc_table_ + 4;

}
",1,1,0,1,"dst,idx,sign","dst:0.0721125602722168,idx:-0.05744493007659912,sign:-0.08545425534248352,",1,6,"dst:r_coec_tab9esenc_table_,",Greedy,82,0.03361201286315918
201,"void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)
{
    BlockJobInfoList *list;
    Error *err = NULL;
    list = qmp_query_block_jobs(&err);
    assert(!err);
    if (!list) {
        monitor_printf(mon, ""No active jobs\n"");
        return;
    }
    while (list) {
        if (strcmp(list->value->type, ""stream"") == 0) {
            monitor_printf(mon, ""Streaming device %s: Completed %"" PRId64
                           "" of %"" PRId64 "" bytes, speed limit %"" PRId64
                           "" bytes/s\n"",
                           list->value->device,
                           list->value->offset,
                           list->value->len,
                           list->value->speed);
        } else {
            monitor_printf(mon, ""Type %s, device %s: Completed %"" PRId64
                           "" of %"" PRId64 "" bytes, speed limit %"" PRId64
                           "" bytes/s\n"",
                           list->value->type,
                           list->value->device,
                           list->value->offset,
                           list->value->len,
                           list->value->speed);
        }
        list = list->next;
    }
}",186,,1,0,,-4,"mon,qdict,list,err",,,,,Greedy,1,0.008033676942189535
202,"static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame)

{

    AVFilterContext *ctx = inlink->dst;

    TrimContext       *s = ctx->priv;

    int64_t start_sample, end_sample = frame->nb_samples;

    int64_t pts;

    int drop;



    /* drop everything if EOF has already been returned */

    if (s->eof) {

        av_frame_free(&frame);

        return 0;

    }



    if (frame->pts != AV_NOPTS_VALUE)

        pts = av_rescale_q(frame->pts, inlink->time_base,

                           (AVRational){ 1, inlink->sample_rate });

    else

        pts = s->next_pts;

    s->next_pts = pts + frame->nb_samples;



    /* check if at least a part of the frame is after the start time */

    if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) {

        start_sample = 0;

    } else {

        drop = 1;

        start_sample = frame->nb_samples;



        if (s->start_sample >= 0 &&

            s->nb_samples + frame->nb_samples > s->start_sample) {

            drop         = 0;

            start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples);

        }



        if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&

            pts + frame->nb_samples > s->start_pts) {

            drop = 0;

            start_sample = FFMIN(start_sample, s->start_pts - pts);

        }



        if (drop)

            goto drop;

    }



    if (s->first_pts == AV_NOPTS_VALUE)

        s->first_pts = pts + start_sample;



    /* check if at least a part of the frame is before the end time */

    if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) {

        end_sample = frame->nb_samples;

    } else {

        drop       = 1;

        end_sample = 0;



        if (s->end_sample != INT64_MAX &&

            s->nb_samples < s->end_sample) {

            drop       = 0;

            end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples);

        }



        if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&

            pts < s->end_pts) {

            drop       = 0;

            end_sample = FFMAX(end_sample, s->end_pts - pts);

        }



        if (s->duration_tb && pts - s->first_pts < s->duration_tb) {

            drop       = 0;

            end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts);

        }



        if (drop) {

            s->eof = 1;

            goto drop;

        }

    }



    s->nb_samples += frame->nb_samples;

    start_sample   = FFMAX(0, start_sample);

    end_sample     = FFMIN(frame->nb_samples, end_sample);

    av_assert0(start_sample < end_sample);



    if (start_sample) {

        AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample);

        if (!out) {

            av_frame_free(&frame);

            return AVERROR(ENOMEM);

        }



        av_frame_copy_props(out, frame);

        av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample,

                        out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout),

                        frame->format);

        if (out->pts != AV_NOPTS_VALUE)

            out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate },

                                     inlink->time_base);



        av_frame_free(&frame);

        frame = out;

    } else

        frame->nb_samples = end_sample;



    s->got_output = 1;

    return ff_filter_frame(ctx->outputs[0], frame);



drop:

    s->nb_samples += frame->nb_samples;

    av_frame_free(&frame);

    return 0;

}
",617,,0,1,,-4,"inlink,frame,ctx,s,start_sample,pts,drop,out",,,,,Greedy,1,0.00845942497253418
203,"static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,

                               const TCGArg * const args, uint16_t dead_args,

                               uint8_t sync_args)

{

    int flags, nb_regs, i;

    TCGReg reg;

    TCGArg arg;

    TCGTemp *ts;

    intptr_t stack_offset;

    size_t call_stack_size;

    tcg_insn_unit *func_addr;

    int allocate_args;

    TCGRegSet allocated_regs;



    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];

    flags = args[nb_oargs + nb_iargs + 1];



    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);

    if (nb_regs > nb_iargs) {

        nb_regs = nb_iargs;

    }



    /* assign stack slots first */

    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);

    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & 

        ~(TCG_TARGET_STACK_ALIGN - 1);

    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);

    if (allocate_args) {

        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,

           preallocate call stack */

        tcg_abort();

    }



    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;

    for(i = nb_regs; i < nb_iargs; i++) {

        arg = args[nb_oargs + i];

#ifdef TCG_TARGET_STACK_GROWSUP

        stack_offset -= sizeof(tcg_target_long);

#endif

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            temp_load(s, ts, tcg_target_available_regs[ts->type],

                      s->reserved_regs);

            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);

        }

#ifndef TCG_TARGET_STACK_GROWSUP

        stack_offset += sizeof(tcg_target_long);

#endif

    }

    

    /* assign input registers */

    tcg_regset_set(allocated_regs, s->reserved_regs);

    for(i = 0; i < nb_regs; i++) {

        arg = args[nb_oargs + i];

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            reg = tcg_target_call_iarg_regs[i];

            tcg_reg_free(s, reg, allocated_regs);



            if (ts->val_type == TEMP_VAL_REG) {

                if (ts->reg != reg) {

                    tcg_out_mov(s, ts->type, reg, ts->reg);

                }

            } else {

                TCGRegSet arg_set;



                tcg_regset_clear(arg_set);

                tcg_regset_set_reg(arg_set, reg);

                temp_load(s, ts, arg_set, allocated_regs);

            }



            tcg_regset_set_reg(allocated_regs, reg);

        }

    }

    

    /* mark dead temporaries and free the associated registers */

    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {

        if (IS_DEAD_ARG(i)) {

            temp_dead(s, &s->temps[args[i]]);

        }

    }

    

    /* clobber call registers */

    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {

        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {

            tcg_reg_free(s, i, allocated_regs);

        }

    }



    /* Save globals if they might be written by the helper, sync them if

       they might be read. */

    if (flags & TCG_CALL_NO_READ_GLOBALS) {

        /* Nothing to do */

    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {

        sync_globals(s, allocated_regs);

    } else {

        save_globals(s, allocated_regs);

    }



    tcg_out_call(s, func_addr);



    /* assign output registers and emit moves if needed */

    for(i = 0; i < nb_oargs; i++) {

        arg = args[i];

        ts = &s->temps[arg];

        reg = tcg_target_call_oarg_regs[i];

        assert(s->reg_to_temp[reg] == NULL);



        if (ts->fixed_reg) {

            if (ts->reg != reg) {

                tcg_out_mov(s, ts->type, ts->reg, reg);

            }

        } else {

            if (ts->val_type == TEMP_VAL_REG) {

                s->reg_to_temp[ts->reg] = NULL;

            }

            ts->val_type = TEMP_VAL_REG;

            ts->reg = reg;

            ts->mem_coherent = 0;

            s->reg_to_temp[reg] = ts;

            if (NEED_SYNC_ARG(i)) {

                tcg_reg_sync(s, reg, allocated_regs);

            }

            if (IS_DEAD_ARG(i)) {

                temp_dead(s, ts);

            }

        }

    }

}
",681,"static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,

                               const TCGArg * const args, uint16_t dead_args,

                               uint8_t ntePrlacinstwHeigher9mzer_)

{

    int flags, nb_regs, i;

    TCGReg reg;

    TCGArg arg;

    TCGTemp *ts;

    intptr_t stack_offset;

    size_t call_stack_size;

    tcg_insn_unit *func_addr;

    int allocate_args;

    TCGRegSet allocated_regs;



    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];

    flags = args[nb_oargs + nb_iargs + 1];



    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);

    if (nb_regs > nb_iargs) {

        nb_regs = nb_iargs;

    }



    /* assign stack slots first */

    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);

    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & 

        ~(TCG_TARGET_STACK_ALIGN - 1);

    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);

    if (allocate_args) {

        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,

           preallocate call stack */

        tcg_abort();

    }



    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;

    for(i = nb_regs; i < nb_iargs; i++) {

        arg = args[nb_oargs + i];

#ifdef TCG_TARGET_STACK_GROWSUP

        stack_offset -= sizeof(tcg_target_long);

#endif

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            temp_load(s, ts, tcg_target_available_regs[ts->type],

                      s->reserved_regs);

            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);

        }

#ifndef TCG_TARGET_STACK_GROWSUP

        stack_offset += sizeof(tcg_target_long);

#endif

    }

    

    /* assign input registers */

    tcg_regset_set(allocated_regs, s->reserved_regs);

    for(i = 0; i < nb_regs; i++) {

        arg = args[nb_oargs + i];

        if (arg != TCG_CALL_DUMMY_ARG) {

            ts = &s->temps[arg];

            reg = tcg_target_call_iarg_regs[i];

            tcg_reg_free(s, reg, allocated_regs);



            if (ts->val_type == TEMP_VAL_REG) {

                if (ts->reg != reg) {

                    tcg_out_mov(s, ts->type, reg, ts->reg);

                }

            } else {

                TCGRegSet arg_set;



                tcg_regset_clear(arg_set);

                tcg_regset_set_reg(arg_set, reg);

                temp_load(s, ts, arg_set, allocated_regs);

            }



            tcg_regset_set_reg(allocated_regs, reg);

        }

    }

    

    /* mark dead temporaries and free the associated registers */

    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {

        if (IS_DEAD_ARG(i)) {

            temp_dead(s, &s->temps[args[i]]);

        }

    }

    

    /* clobber call registers */

    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {

        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {

            tcg_reg_free(s, i, allocated_regs);

        }

    }



    /* Save globals if they might be written by the helper, sync them if

       they might be read. */

    if (flags & TCG_CALL_NO_READ_GLOBALS) {

        /* Nothing to do */

    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {

        sync_globals(s, allocated_regs);

    } else {

        save_globals(s, allocated_regs);

    }



    tcg_out_call(s, func_addr);



    /* assign output registers and emit moves if needed */

    for(i = 0; i < nb_oargs; i++) {

        arg = args[i];

        ts = &s->temps[arg];

        reg = tcg_target_call_oarg_regs[i];

        assert(s->reg_to_temp[reg] == NULL);



        if (ts->fixed_reg) {

            if (ts->reg != reg) {

                tcg_out_mov(s, ts->type, ts->reg, reg);

            }

        } else {

            if (ts->val_type == TEMP_VAL_REG) {

                s->reg_to_temp[ts->reg] = NULL;

            }

            ts->val_type = TEMP_VAL_REG;

            ts->reg = reg;

            ts->mem_coherent = 0;

            s->reg_to_temp[reg] = ts;

            if (NEED_SYNC_ARG(i)) {

                tcg_reg_sync(s, reg, allocated_regs);

            }

            if (IS_DEAD_ARG(i)) {

                temp_dead(s, ts);

            }

        }

    }

}
",0,0,1,1,"s,nb_oargs,nb_iargs,args,dead_args,sync_args,flags,nb_regs,i,reg,arg,ts,stack_offset,call_stack_size,func_addr,allocate_args,allocated_regs,arg_set","s:-0.001241445541381836,nb_oargs:-0.11157000064849854,nb_iargs:-0.2684871703386307,args:-0.0599159300327301,dead_args:0.05407649278640747,sync_args:0.20477518439292908,flags:0.0034461021423339844,nb_regs:-0.17866629362106323,i:-0.10732422769069672,reg:0.015661507844924927,arg:-0.09063901007175446,ts:-0.031186044216156006,stack_offset:0.07841432094573975,call_stack_size:-0.15478429198265076,func_addr:-0.2275724858045578,allocate_args:0.1092175543308258,allocated_regs:0.02538198232650757,arg_set:4.76837158203125e-07,",1,1,"sync_args:ntePrlacinstwHeigher9mzer_,",Greedy,231,0.06489269336064657
204,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
",64,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *t_s5able_cluttershmadeun = (BDRVCURLState *)arg;

    int it_bittes_eor1der_bselecod;

    int r;



    if (!t_s5able_cluttershmadeun->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(t_s5able_cluttershmadeun->multi, &it_bittes_eor1der_bselecod);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(t_s5able_cluttershmadeun);

}
",0,0,1,1,"arg,s,running,r","arg:-0.0002867281436920166,s:0.0025065895169973373,running:0.0015701241791248322,r:0.00044149626046419144,",2,6,"s:t_s5able_cluttershmadeun,running:it_bittes_eor1der_bselecod,",Greedy,133,0.04700616598129272
205,"static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config)

{

    static int hinted = 0;

    int ret = 0;

    AVDictionaryEntry *e;

    const AVOption *o = NULL;

    const char *option = NULL;

    const char *codec_name = NULL;

    char buff[1024];

    AVCodecContext *ctx;

    AVDictionary **dict;

    enum AVCodecID guessed_codec_id;



    switch (type) {

    case AV_OPT_FLAG_VIDEO_PARAM:

        ctx = config->dummy_vctx;

        dict = &config->video_opts;

        guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ?

                           config->guessed_video_codec_id : AV_CODEC_ID_H264;

        break;

    case AV_OPT_FLAG_AUDIO_PARAM:

        ctx = config->dummy_actx;

        dict = &config->audio_opts;

        guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ?

                           config->guessed_audio_codec_id : AV_CODEC_ID_AAC;

        break;

    default:

        av_assert0(0);

    }



    if (strchr(opt, ':')) {

        //explicit private option

        snprintf(buff, sizeof(buff), ""%s"", opt);

        codec_name = buff;

        option = strchr(buff, ':');

        buff[option - buff] = '\0';

        option++;

        if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0)

            return ret;

        if (!ctx->codec || !ctx->priv_data)

            return -1;

    } else {

        option = opt;

    }



    o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN);

    if (!o && (!strcmp(option, ""time_base"")  || !strcmp(option, ""pixel_format"") ||

               !strcmp(option, ""video_size"") || !strcmp(option, ""codec_tag"")))

        o = av_opt_find(ctx, option, NULL, 0, 0);

    if (!o) {

        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                            &config->errors, ""Option not found: %s\n"", opt);

        if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) {

            hinted = 1;

            report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL,

                                ""If '%s' is a codec private option, then prefix it with codec name, ""

                                ""for example '%s:%s %s' or define codec earlier.\n"",

                                opt, avcodec_get_name(guessed_codec_id) ,opt, arg);

        }

    } else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) {

        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, ""Invalid value for option %s (%s): %s\n"", opt,

                arg, av_err2str(ret));

    } else if ((e = av_dict_get(*dict, option, NULL, 0))) {

        if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-'))

            return av_dict_set(dict, option, arg, AV_DICT_APPEND);

        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors,

                ""Redeclaring value of the option %s, previous value: %s\n"",

                opt, e->value);

    } else if (av_dict_set(dict, option, arg, 0) < 0) {

        return AVERROR(ENOMEM);

    }

    return 0;

}
",588,,0,1,,-4,"opt,arg,type,config,e,o,option,codec_name,buff,ctx,dict,guessed_codec_id",,,,,Greedy,1,0.008127280076344808
206,"static int decode_opc(MoxieCPU *cpu, DisasContext *ctx)

{

    CPUMoxieState *env = &cpu->env;



    /* Local cache for the instruction opcode.  */

    int opcode;

    /* Set the default instruction length.  */

    int length = 2;



    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {

        tcg_gen_debug_insn_start(ctx->pc);

    }



    /* Examine the 16-bit opcode.  */

    opcode = ctx->opcode;



    /* Decode instruction.  */

    if (opcode & (1 << 15)) {

        if (opcode & (1 << 14)) {

            /* This is a Form 3 instruction.  */

            int inst = (opcode >> 10 & 0xf);



#define BRANCH(cond)                                                         \

    do {                                                                     \

        int l1 = gen_new_label();                                            \

        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \

        gen_goto_tb(env, ctx, 1, ctx->pc+2);                                 \

        gen_set_label(l1);                                                   \

        gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \

        ctx->bstate = BS_BRANCH;                                             \

    } while (0)



            switch (inst) {

            case 0x00: /* beq */

                BRANCH(TCG_COND_EQ);

                break;

            case 0x01: /* bne */

                BRANCH(TCG_COND_NE);

                break;

            case 0x02: /* blt */

                BRANCH(TCG_COND_LT);

                break;

            case 0x03: /* bgt */

                BRANCH(TCG_COND_GT);

                break;

            case 0x04: /* bltu */

                BRANCH(TCG_COND_LTU);

                break;

            case 0x05: /* bgtu */

                BRANCH(TCG_COND_GTU);

                break;

            case 0x06: /* bge */

                BRANCH(TCG_COND_GE);

                break;

            case 0x07: /* ble */

                BRANCH(TCG_COND_LE);

                break;

            case 0x08: /* bgeu */

                BRANCH(TCG_COND_GEU);

                break;

            case 0x09: /* bleu */

                BRANCH(TCG_COND_LEU);

                break;

            default:

                {

                    TCGv temp = tcg_temp_new_i32();

                    tcg_gen_movi_i32(cpu_pc, ctx->pc);

                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);

                    gen_helper_raise_exception(cpu_env, temp);

                    tcg_temp_free_i32(temp);

                }

                break;

            }

        } else {

            /* This is a Form 2 instruction.  */

            int inst = (opcode >> 12 & 0x3);

            switch (inst) {

            case 0x00: /* inc */

                {

                    int a = (opcode >> 8) & 0xf;

                    unsigned int v = (opcode & 0xff);

                    tcg_gen_addi_i32(REG(a), REG(a), v);

                }

                break;

            case 0x01: /* dec */

                {

                    int a = (opcode >> 8) & 0xf;

                    unsigned int v = (opcode & 0xff);

                    tcg_gen_subi_i32(REG(a), REG(a), v);

                }

                break;

            case 0x02: /* gsr */

                {

                    int a = (opcode >> 8) & 0xf;

                    unsigned v = (opcode & 0xff);

                    tcg_gen_ld_i32(REG(a), cpu_env,

                                   offsetof(CPUMoxieState, sregs[v]));

                }

                break;

            case 0x03: /* ssr */

                {

                    int a = (opcode >> 8) & 0xf;

                    unsigned v = (opcode & 0xff);

                    tcg_gen_st_i32(REG(a), cpu_env,

                                   offsetof(CPUMoxieState, sregs[v]));

                }

                break;

            default:

                {

                    TCGv temp = tcg_temp_new_i32();

                    tcg_gen_movi_i32(cpu_pc, ctx->pc);

                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);

                    gen_helper_raise_exception(cpu_env, temp);

                    tcg_temp_free_i32(temp);

                }

                break;

            }

        }

    } else {

        /* This is a Form 1 instruction.  */

        int inst = opcode >> 8;

        switch (inst) {

        case 0x00: /* nop */

            break;

        case 0x01: /* ldi.l (immediate) */

            {

                int reg = (opcode >> 4) & 0xf;

                int val = cpu_ldl_code(env, ctx->pc+2);

                tcg_gen_movi_i32(REG(reg), val);

                length = 6;

            }

            break;

        case 0x02: /* mov (register-to-register) */

            {

                int dest  = (opcode >> 4) & 0xf;

                int src = opcode & 0xf;

                tcg_gen_mov_i32(REG(dest), REG(src));

            }

            break;

        case 0x03: /* jsra */

            {

                TCGv t1 = tcg_temp_new_i32();

                TCGv t2 = tcg_temp_new_i32();



                tcg_gen_movi_i32(t1, ctx->pc + 6);



                /* Make space for the static chain and return address.  */

                tcg_gen_subi_i32(t2, REG(1), 8);

                tcg_gen_mov_i32(REG(1), t2);

                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);



                /* Push the current frame pointer.  */

                tcg_gen_subi_i32(t2, REG(1), 4);

                tcg_gen_mov_i32(REG(1), t2);

                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);



                /* Set the pc and $fp.  */

                tcg_gen_mov_i32(REG(0), REG(1));



                gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2));



                tcg_temp_free_i32(t1);

                tcg_temp_free_i32(t2);



                ctx->bstate = BS_BRANCH;

                length = 6;

            }

            break;

        case 0x04: /* ret */

            {

                TCGv t1 = tcg_temp_new_i32();



                /* The new $sp is the old $fp.  */

                tcg_gen_mov_i32(REG(1), REG(0));



                /* Pop the frame pointer.  */

                tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx);

                tcg_gen_addi_i32(t1, REG(1), 4);

                tcg_gen_mov_i32(REG(1), t1);





                /* Pop the return address and skip over the static chain

                   slot.  */

                tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx);

                tcg_gen_addi_i32(t1, REG(1), 8);

                tcg_gen_mov_i32(REG(1), t1);



                tcg_temp_free_i32(t1);



                /* Jump... */

                tcg_gen_exit_tb(0);



                ctx->bstate = BS_BRANCH;

            }

            break;

        case 0x05: /* add.l */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                tcg_gen_add_i32(REG(a), REG(a), REG(b));

            }

            break;

        case 0x06: /* push */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                TCGv t1 = tcg_temp_new_i32();

                tcg_gen_subi_i32(t1, REG(a), 4);

                tcg_gen_mov_i32(REG(a), t1);

                tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx);

                tcg_temp_free_i32(t1);

            }

            break;

        case 0x07: /* pop */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;

                TCGv t1 = tcg_temp_new_i32();



                tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx);

                tcg_gen_addi_i32(t1, REG(a), 4);

                tcg_gen_mov_i32(REG(a), t1);

                tcg_temp_free_i32(t1);

            }

            break;

        case 0x08: /* lda.l */

            {

                int reg = (opcode >> 4) & 0xf;



                TCGv ptr = tcg_temp_new_i32();

                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx);

                tcg_temp_free_i32(ptr);



                length = 6;

            }

            break;

        case 0x09: /* sta.l */

            {

                int val = (opcode >> 4) & 0xf;



                TCGv ptr = tcg_temp_new_i32();

                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx);

                tcg_temp_free_i32(ptr);



                length = 6;

            }

            break;

        case 0x0a: /* ld.l (register indirect) */

            {

                int src  = opcode & 0xf;

                int dest = (opcode >> 4) & 0xf;



                tcg_gen_qemu_ld32u(REG(dest), REG(src), ctx->memidx);

            }

            break;

        case 0x0b: /* st.l */

            {

                int dest = (opcode >> 4) & 0xf;

                int val  = opcode & 0xf;



                tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx);

            }

            break;

        case 0x0c: /* ldo.l */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                TCGv t1 = tcg_temp_new_i32();

                TCGv t2 = tcg_temp_new_i32();

                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_ld32u(t2, t1, ctx->memidx);

                tcg_gen_mov_i32(REG(a), t2);



                tcg_temp_free_i32(t1);

                tcg_temp_free_i32(t2);



                length = 6;

            }

            break;

        case 0x0d: /* sto.l */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                TCGv t1 = tcg_temp_new_i32();

                TCGv t2 = tcg_temp_new_i32();

                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_st32(REG(b), t1, ctx->memidx);



                tcg_temp_free_i32(t1);

                tcg_temp_free_i32(t2);



                length = 6;

            }

            break;

        case 0x0e: /* cmp */

            {

                int a  = (opcode >> 4) & 0xf;

                int b  = opcode & 0xf;



                tcg_gen_mov_i32(cc_a, REG(a));

                tcg_gen_mov_i32(cc_b, REG(b));

            }

            break;

        case 0x19: /* jsr */

            {

                int fnreg = (opcode >> 4) & 0xf;



                /* Load the stack pointer into T0.  */

                TCGv t1 = tcg_temp_new_i32();

                TCGv t2 = tcg_temp_new_i32();



                tcg_gen_movi_i32(t1, ctx->pc+2);



                /* Make space for the static chain and return address.  */

                tcg_gen_subi_i32(t2, REG(1), 8);

                tcg_gen_mov_i32(REG(1), t2);

                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);



                /* Push the current frame pointer.  */

                tcg_gen_subi_i32(t2, REG(1), 4);

                tcg_gen_mov_i32(REG(1), t2);

                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);



                /* Set the pc and $fp.  */

                tcg_gen_mov_i32(REG(0), REG(1));

                tcg_gen_mov_i32(cpu_pc, REG(fnreg));

                tcg_temp_free_i32(t1);

                tcg_temp_free_i32(t2);

                tcg_gen_exit_tb(0);

                ctx->bstate = BS_BRANCH;

            }

            break;

        case 0x1a: /* jmpa */

            {

                tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_exit_tb(0);

                ctx->bstate = BS_BRANCH;

                length = 6;

            }

            break;

        case 0x1b: /* ldi.b (immediate) */

            {

                int reg = (opcode >> 4) & 0xf;

                int val = cpu_ldl_code(env, ctx->pc+2);

                tcg_gen_movi_i32(REG(reg), val);

                length = 6;

            }

            break;

        case 0x1c: /* ld.b (register indirect) */

            {

                int src  = opcode & 0xf;

                int dest = (opcode >> 4) & 0xf;



                tcg_gen_qemu_ld8u(REG(dest), REG(src), ctx->memidx);

            }

            break;

        case 0x1d: /* lda.b */

            {

                int reg = (opcode >> 4) & 0xf;



                TCGv ptr = tcg_temp_new_i32();

                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx);

                tcg_temp_free_i32(ptr);



                length = 6;

            }

            break;

        case 0x1e: /* st.b */

            {

                int dest = (opcode >> 4) & 0xf;

                int val  = opcode & 0xf;



                tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx);

            }

            break;

        case 0x1f: /* sta.b */

            {

                int val = (opcode >> 4) & 0xf;



                TCGv ptr = tcg_temp_new_i32();

                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx);

                tcg_temp_free_i32(ptr);



                length = 6;

            }

            break;

        case 0x20: /* ldi.s (immediate) */

            {

                int reg = (opcode >> 4) & 0xf;

                int val = cpu_ldl_code(env, ctx->pc+2);

                tcg_gen_movi_i32(REG(reg), val);

                length = 6;

            }

            break;

        case 0x21: /* ld.s (register indirect) */

            {

                int src  = opcode & 0xf;

                int dest = (opcode >> 4) & 0xf;



                tcg_gen_qemu_ld16u(REG(dest), REG(src), ctx->memidx);

            }

            break;

        case 0x22: /* lda.s */

            {

                int reg = (opcode >> 4) & 0xf;



                TCGv ptr = tcg_temp_new_i32();

                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx);

                tcg_temp_free_i32(ptr);



                length = 6;

            }

            break;

        case 0x23: /* st.s */

            {

                int dest = (opcode >> 4) & 0xf;

                int val  = opcode & 0xf;



                tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx);

            }

            break;

        case 0x24: /* sta.s */

            {

                int val = (opcode >> 4) & 0xf;



                TCGv ptr = tcg_temp_new_i32();

                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx);

                tcg_temp_free_i32(ptr);



                length = 6;

            }

            break;

        case 0x25: /* jmp */

            {

                int reg = (opcode >> 4) & 0xf;

                tcg_gen_mov_i32(cpu_pc, REG(reg));

                tcg_gen_exit_tb(0);

                ctx->bstate = BS_BRANCH;

            }

            break;

        case 0x26: /* and */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                tcg_gen_and_i32(REG(a), REG(a), REG(b));

            }

            break;

        case 0x27: /* lshr */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                TCGv sv = tcg_temp_new_i32();

                tcg_gen_andi_i32(sv, REG(b), 0x1f);

                tcg_gen_shr_i32(REG(a), REG(a), sv);

                tcg_temp_free_i32(sv);

            }

            break;

        case 0x28: /* ashl */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                TCGv sv = tcg_temp_new_i32();

                tcg_gen_andi_i32(sv, REG(b), 0x1f);

                tcg_gen_shl_i32(REG(a), REG(a), sv);

                tcg_temp_free_i32(sv);

            }

            break;

        case 0x29: /* sub.l */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                tcg_gen_sub_i32(REG(a), REG(a), REG(b));

            }

            break;

        case 0x2a: /* neg */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                tcg_gen_neg_i32(REG(a), REG(b));

            }

            break;

        case 0x2b: /* or */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                tcg_gen_or_i32(REG(a), REG(a), REG(b));

            }

            break;

        case 0x2c: /* not */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                tcg_gen_not_i32(REG(a), REG(b));

            }

            break;

        case 0x2d: /* ashr */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                TCGv sv = tcg_temp_new_i32();

                tcg_gen_andi_i32(sv, REG(b), 0x1f);

                tcg_gen_sar_i32(REG(a), REG(a), sv);

                tcg_temp_free_i32(sv);

            }

            break;

        case 0x2e: /* xor */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                tcg_gen_xor_i32(REG(a), REG(a), REG(b));

            }

            break;

        case 0x2f: /* mul.l */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                tcg_gen_mul_i32(REG(a), REG(a), REG(b));

            }

            break;

        case 0x30: /* swi */

            {

                int val = cpu_ldl_code(env, ctx->pc+2);



                TCGv temp = tcg_temp_new_i32();

                tcg_gen_movi_i32(temp, val);

                tcg_gen_st_i32(temp, cpu_env,

                               offsetof(CPUMoxieState, sregs[3]));

                tcg_gen_movi_i32(cpu_pc, ctx->pc);

                tcg_gen_movi_i32(temp, MOXIE_EX_SWI);

                gen_helper_raise_exception(cpu_env, temp);

                tcg_temp_free_i32(temp);



                length = 6;

            }

            break;

        case 0x31: /* div.l */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;

                tcg_gen_movi_i32(cpu_pc, ctx->pc);

                gen_helper_div(REG(a), cpu_env, REG(a), REG(b));

            }

            break;

        case 0x32: /* udiv.l */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;

                tcg_gen_movi_i32(cpu_pc, ctx->pc);

                gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b));

            }

            break;

        case 0x33: /* mod.l */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;

                tcg_gen_rem_i32(REG(a), REG(a), REG(b));

            }

            break;

        case 0x34: /* umod.l */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;

                tcg_gen_remu_i32(REG(a), REG(a), REG(b));

            }

            break;

        case 0x35: /* brk */

            {

                TCGv temp = tcg_temp_new_i32();

                tcg_gen_movi_i32(cpu_pc, ctx->pc);

                tcg_gen_movi_i32(temp, MOXIE_EX_BREAK);

                gen_helper_raise_exception(cpu_env, temp);

                tcg_temp_free_i32(temp);

            }

            break;

        case 0x36: /* ldo.b */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                TCGv t1 = tcg_temp_new_i32();

                TCGv t2 = tcg_temp_new_i32();

                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_ld8u(t2, t1, ctx->memidx);

                tcg_gen_mov_i32(REG(a), t2);



                tcg_temp_free_i32(t1);

                tcg_temp_free_i32(t2);



                length = 6;

            }

            break;

        case 0x37: /* sto.b */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                TCGv t1 = tcg_temp_new_i32();

                TCGv t2 = tcg_temp_new_i32();

                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_st8(REG(b), t1, ctx->memidx);



                tcg_temp_free_i32(t1);

                tcg_temp_free_i32(t2);



                length = 6;

            }

            break;

        case 0x38: /* ldo.s */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                TCGv t1 = tcg_temp_new_i32();

                TCGv t2 = tcg_temp_new_i32();

                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_ld16u(t2, t1, ctx->memidx);

                tcg_gen_mov_i32(REG(a), t2);



                tcg_temp_free_i32(t1);

                tcg_temp_free_i32(t2);



                length = 6;

            }

            break;

        case 0x39: /* sto.s */

            {

                int a = (opcode >> 4) & 0xf;

                int b = opcode & 0xf;



                TCGv t1 = tcg_temp_new_i32();

                TCGv t2 = tcg_temp_new_i32();

                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));

                tcg_gen_qemu_st16(REG(b), t1, ctx->memidx);

                tcg_temp_free_i32(t1);

                tcg_temp_free_i32(t2);



                length = 6;

            }

            break;

        default:

            {

                TCGv temp = tcg_temp_new_i32();

                tcg_gen_movi_i32(cpu_pc, ctx->pc);

                tcg_gen_movi_i32(temp, MOXIE_EX_BAD);

                gen_helper_raise_exception(cpu_env, temp);

                tcg_temp_free_i32(temp);

             }

            break;

        }

    }



    return length;

}
",3476,,0,1,,-4,"cpu,ctx,env,opcode",,,,,Greedy,1,0.013139673074086507
207,"static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)

{

    int rex;



    if (opc & P_GS) {

        tcg_out8(s, 0x65);

    }

    if (opc & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((opc & P_REXW) == 0);

        tcg_out8(s, 0x66);

    }

    if (opc & P_ADDR32) {

        tcg_out8(s, 0x67);

    }



    rex = 0;

    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    rex |= (r & 8) >> 1;                /* REX.R */

    rex |= (x & 8) >> 2;                /* REX.X */

    rex |= (rm & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    rex |= opc & (r >= 4 ? P_REXB_R : 0);

    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);



    if (rex) {

        tcg_out8(s, (uint8_t)(rex | 0x40));

    }



    if (opc & (P_EXT | P_EXT38)) {

        tcg_out8(s, 0x0f);

        if (opc & P_EXT38) {

            tcg_out8(s, 0x38);

        }

    }



    tcg_out8(s, opc);

}
",216,"static void tcg_out_opc(TCGContext *ount_sngtxIng_file_s9_erf, int ubstershigh_b7iQt_deptaln, int r, int rm, int innextrpcusouUt_taberget_e)

{

    int able_clustfrta1ble_sizee;



    if (ubstershigh_b7iQt_deptaln & P_GS) {

        tcg_out8(ount_sngtxIng_file_s9_erf, 0x65);

    }

    if (ubstershigh_b7iQt_deptaln & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((ubstershigh_b7iQt_deptaln & P_REXW) == 0);

        tcg_out8(ount_sngtxIng_file_s9_erf, 0x66);

    }

    if (ubstershigh_b7iQt_deptaln & P_ADDR32) {

        tcg_out8(ount_sngtxIng_file_s9_erf, 0x67);

    }



    able_clustfrta1ble_sizee = 0;

    able_clustfrta1ble_sizee |= (ubstershigh_b7iQt_deptaln & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    able_clustfrta1ble_sizee |= (r & 8) >> 1;                /* REX.R */

    able_clustfrta1ble_sizee |= (innextrpcusouUt_taberget_e & 8) >> 2;                /* REX.X */

    able_clustfrta1ble_sizee |= (rm & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    able_clustfrta1ble_sizee |= ubstershigh_b7iQt_deptaln & (r >= 4 ? P_REXB_R : 0);

    able_clustfrta1ble_sizee |= ubstershigh_b7iQt_deptaln & (rm >= 4 ? P_REXB_RM : 0);



    if (able_clustfrta1ble_sizee) {

        tcg_out8(ount_sngtxIng_file_s9_erf, (uint8_t)(able_clustfrta1ble_sizee | 0x40));

    }



    if (ubstershigh_b7iQt_deptaln & (P_EXT | P_EXT38)) {

        tcg_out8(ount_sngtxIng_file_s9_erf, 0x0f);

        if (ubstershigh_b7iQt_deptaln & P_EXT38) {

            tcg_out8(ount_sngtxIng_file_s9_erf, 0x38);

        }

    }



    tcg_out8(ount_sngtxIng_file_s9_erf, ubstershigh_b7iQt_deptaln);

}
",0,0,1,1,"s,opc,r,rm,x,rex","s:0.024187717586755753,opc:0.015273628756403923,r:0.0020500021055340767,rm:0.002813679166138172,x:0.020787684246897697,rex:0.009577727876603603,",4,31,"s:ount_sngtxIng_file_s9_erf,x:innextrpcusouUt_taberget_e,opc:ubstershigh_b7iQt_deptaln,rex:able_clustfrta1ble_sizee,",Greedy,279,0.0892396847407023
208,"qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset,

                            uint64_t bytes, QEMUIOVector *qiov)

{

    BDRVQcow2State *s = bs->opaque;

    QEMUIOVector hd_qiov;

    struct iovec iov;

    z_stream strm;

    int ret, out_len;

    uint8_t *buf, *out_buf;

    uint64_t cluster_offset;



    if (bytes == 0) {

        /* align end of file to a sector boundary to ease reading with

           sector based I/Os */

        cluster_offset = bdrv_getlength(bs->file->bs);

        return bdrv_truncate(bs->file, cluster_offset, PREALLOC_MODE_OFF, NULL);

    }



    buf = qemu_blockalign(bs, s->cluster_size);

    if (bytes != s->cluster_size) {

        if (bytes > s->cluster_size ||

            offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS)

        {

            qemu_vfree(buf);

            return -EINVAL;

        }

        /* Zero-pad last write if image size is not cluster aligned */

        memset(buf + bytes, 0, s->cluster_size - bytes);

    }

    qemu_iovec_to_buf(qiov, 0, buf, bytes);



    out_buf = g_malloc(s->cluster_size);



    /* best compression, small window, no zlib header */

    memset(&strm, 0, sizeof(strm));

    ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION,

                       Z_DEFLATED, -12,

                       9, Z_DEFAULT_STRATEGY);

    if (ret != 0) {

        ret = -EINVAL;

        goto fail;

    }



    strm.avail_in = s->cluster_size;

    strm.next_in = (uint8_t *)buf;

    strm.avail_out = s->cluster_size;

    strm.next_out = out_buf;



    ret = deflate(&strm, Z_FINISH);

    if (ret != Z_STREAM_END && ret != Z_OK) {

        deflateEnd(&strm);

        ret = -EINVAL;

        goto fail;

    }

    out_len = strm.next_out - out_buf;



    deflateEnd(&strm);



    if (ret != Z_STREAM_END || out_len >= s->cluster_size) {

        /* could not compress: write normal cluster */

        ret = qcow2_co_pwritev(bs, offset, bytes, qiov, 0);

        if (ret < 0) {

            goto fail;

        }

        goto success;

    }



    qemu_co_mutex_lock(&s->lock);

    cluster_offset =

        qcow2_alloc_compressed_cluster_offset(bs, offset, out_len);

    if (!cluster_offset) {

        qemu_co_mutex_unlock(&s->lock);

        ret = -EIO;

        goto fail;

    }

    cluster_offset &= s->cluster_offset_mask;



    ret = qcow2_pre_write_overlap_check(bs, 0, cluster_offset, out_len);

    qemu_co_mutex_unlock(&s->lock);

    if (ret < 0) {

        goto fail;

    }



    iov = (struct iovec) {

        .iov_base   = out_buf,

        .iov_len    = out_len,

    };

    qemu_iovec_init_external(&hd_qiov, &iov, 1);



    BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED);

    ret = bdrv_co_pwritev(bs->file, cluster_offset, out_len, &hd_qiov, 0);

    if (ret < 0) {

        goto fail;

    }

success:

    ret = 0;

fail:

    qemu_vfree(buf);

    g_free(out_buf);

    return ret;

}
",511,,1,0,,-4,"s,hd_qiov,iov,strm,ret,out_len,buf,out_buf,cluster_offset",,,,,Greedy,1,0.008683097362518311
209,"static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif

}
",68,"static void gen_mfrom(DisasContext *ln_HclusTTeHsAeHcount__tA)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ln_HclusTTeHsAeHcount__tA, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ln_HclusTTeHsAeHcount__tA->pr)) {

        gen_inval_exception(ln_HclusTTeHsAeHcount__tA, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ln_HclusTTeHsAeHcount__tA->opcode)], cpu_gpr[rA(ln_HclusTTeHsAeHcount__tA->opcode)]);

#endif

}
",1,1,1,-1,ctx,"ctx:-0.00039201974868774414,",1,6,"ctx:ln_HclusTTeHsAeHcount__tA,",Greedy,68,0.031273786226908365
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",70,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long pr_ZiledputredconstlenreMAX)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, pr_ZiledputredconstlenreMAX, 1);

}
",0,0,1,1,"ysrc,usrc,vsrc,dst,height,lumStride,chromStride,dstStride","ysrc:-0.0003466792404651642,usrc:0.001887436956167221,vsrc:0.006728608161211014,dst:0.05560890585184097,height:0.011884815990924835,lumStride:-0.002819247543811798,chromStride:0.007909245789051056,dstStride:0.08736735582351685,",1,2,"dstStride:pr_ZiledputredconstlenreMAX,",Greedy,78,0.03338679869969686
211,"static gboolean ga_channel_open(GAChannel *c, const gchar *path,

                                GAChannelMethod method, int fd)

{

    int ret;

    c->method = method;



    switch (c->method) {

    case GA_CHANNEL_VIRTIO_SERIAL: {

        assert(fd < 0);

        fd = qemu_open(path, O_RDWR | O_NONBLOCK

#ifndef CONFIG_SOLARIS

                           | O_ASYNC

#endif

                           );

        if (fd == -1) {

            g_critical(""error opening channel: %s"", strerror(errno));

            return false;

        }

#ifdef CONFIG_SOLARIS

        ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);

        if (ret == -1) {

            g_critical(""error setting event mask for channel: %s"",

                       strerror(errno));

            close(fd);

            return false;

        }

#endif

        ret = ga_channel_client_add(c, fd);

        if (ret) {

            g_critical(""error adding channel to main loop"");

            close(fd);

            return false;

        }

        break;

    }

    case GA_CHANNEL_ISA_SERIAL: {

        struct termios tio;



        assert(fd < 0);

        fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK);

        if (fd == -1) {

            g_critical(""error opening channel: %s"", strerror(errno));

            return false;

        }

        tcgetattr(fd, &tio);

        /* set up serial port for non-canonical, dumb byte streaming */

        tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |

                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |

                         IMAXBEL);

        tio.c_oflag = 0;

        tio.c_lflag = 0;

        tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;

        /* 1 available byte min or reads will block (we'll set non-blocking

         * elsewhere, else we have to deal with read()=0 instead)

         */

        tio.c_cc[VMIN] = 1;

        tio.c_cc[VTIME] = 0;

        /* flush everything waiting for read/xmit, it's garbage at this point */

        tcflush(fd, TCIFLUSH);

        tcsetattr(fd, TCSANOW, &tio);

        ret = ga_channel_client_add(c, fd);

        if (ret) {

            g_critical(""error adding channel to main loop"");

            close(fd);

            return false;

        }

        break;

    }

    case GA_CHANNEL_UNIX_LISTEN: {

        if (fd < 0) {

            Error *local_err = NULL;



            fd = unix_listen(path, NULL, strlen(path), &local_err);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }

        }

        ga_channel_listen_add(c, fd, true);

        break;

    }

    case GA_CHANNEL_VSOCK_LISTEN: {

        if (fd < 0) {

            Error *local_err = NULL;

            SocketAddress *addr;

            char *addr_str;



            addr_str = g_strdup_printf(""vsock:%s"", path);

            addr = socket_parse(addr_str, &local_err);

            g_free(addr_str);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }



            fd = socket_listen(addr, &local_err);

            qapi_free_SocketAddress(addr);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }

        }

        ga_channel_listen_add(c, fd, true);

        break;

    }

    default:

        g_critical(""error binding/listening to specified socket"");

        return false;

    }



    return true;

}
",570,,0,1,,-4,"c,path,method,fd,ret,tio,local_err,addr,addr_str",,,,,Greedy,1,0.008018724123636882
212,"static int ram_save_block(QEMUFile *f)

{

    RAMBlock *block = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *mr;



    if (!block)

        block = QLIST_FIRST(&ram_list.blocks);



    do {

        mr = block->mr;

        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *p;

            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            p = memory_region_get_ram_ptr(mr) + offset;



            if (is_dup_page(p)) {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(f, *p);

                bytes_sent = 1;

            } else {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= block->length) {

            offset = 0;

            block = QLIST_NEXT(block, next);

            if (!block)

                block = QLIST_FIRST(&ram_list.blocks);

        }

    } while (block != last_block || offset != last_offset);



    last_block = block;

    last_offset = offset;



    return bytes_sent;

}
",235,"static int ram_save_block(QEMUFile *f)

{

    RAMBlock *quantitiza9tionbsSput_buf = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *fcoubt6tanle_88scsnerupgr;



    if (!quantitiza9tionbsSput_buf)

        quantitiza9tionbsSput_buf = QLIST_FIRST(&ram_list.blocks);



    do {

        fcoubt6tanle_88scsnerupgr = quantitiza9tionbsSput_buf->fcoubt6tanle_88scsnerupgr;

        if (memory_region_get_dirty(fcoubt6tanle_88scsnerupgr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *p;

            int cont = (quantitiza9tionbsSput_buf == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(fcoubt6tanle_88scsnerupgr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            p = memory_region_get_ram_ptr(fcoubt6tanle_88scsnerupgr) + offset;



            if (is_dup_page(p)) {

                save_block_hdr(f, quantitiza9tionbsSput_buf, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(f, *p);

                bytes_sent = 1;

            } else {

                save_block_hdr(f, quantitiza9tionbsSput_buf, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= quantitiza9tionbsSput_buf->length) {

            offset = 0;

            quantitiza9tionbsSput_buf = QLIST_NEXT(quantitiza9tionbsSput_buf, next);

            if (!quantitiza9tionbsSput_buf)

                quantitiza9tionbsSput_buf = QLIST_FIRST(&ram_list.blocks);

        }

    } while (quantitiza9tionbsSput_buf != last_block || offset != last_offset);



    last_block = quantitiza9tionbsSput_buf;

    last_offset = offset;



    return bytes_sent;

}
",0,0,1,1,"f,block,mr,p","f:-0.0019644051790237427,block:0.14177606999874115,mr:0.08061224222183228,p:0.11513194441795349,",2,20,"block:quantitiza9tionbsSput_buf,p:p,mr:fcoubt6tanle_88scsnerupgr,",Greedy,212,0.07149104674657186
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",122,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *rss_selctor_lustersspred;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    rss_selctor_lustersspred = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    rss_selctor_lustersspred->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    rss_selctor_lustersspred->iov_len = mapped_len;

    pkt->raw_frags += !!rss_selctor_lustersspred->iov_base;



    if ((rss_selctor_lustersspred->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",0,0,1,1,"pkt,pa,len,ventry","pkt:-0.47744375467300415,pa:-0.3881171941757202,len:-0.524450957775116,ventry:-0.0075743794441223145,",1,6,"ventry:rss_selctor_lustersspred,",Greedy,81,0.0339672048886617
214,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;



        output_pixels(i * 4, Y1, U, Y2, V);

    }

}
",216,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int nterrhist_ezt_nBorT_nBumMDA;



    for (nterrhist_ezt_nBorT_nBumMDA = 0; nterrhist_ezt_nBorT_nBumMDA < (dstW >> 1); nterrhist_ezt_nBorT_nBumMDA++) {

        int Y1 = (buf0[nterrhist_ezt_nBorT_nBumMDA * 2]     * yalpha1  + buf1[nterrhist_ezt_nBorT_nBumMDA * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[nterrhist_ezt_nBorT_nBumMDA * 2 + 1] * yalpha1  + buf1[nterrhist_ezt_nBorT_nBumMDA * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[nterrhist_ezt_nBorT_nBumMDA]        * uvalpha1 + ubuf1[nterrhist_ezt_nBorT_nBumMDA]        * uvalpha) >> 19;

        int V  = (vbuf0[nterrhist_ezt_nBorT_nBumMDA]        * uvalpha1 + vbuf1[nterrhist_ezt_nBorT_nBumMDA]        * uvalpha) >> 19;



        output_pixels(nterrhist_ezt_nBorT_nBumMDA * 4, Y1, U, Y2, V);

    }

}
",0,0,0,-1,i,"i:-0.06103973835706711,",1,13,"i:nterrhist_ezt_nBorT_nBumMDA,",Greedy,75,0.036273237069447836
215,"static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,

                                              int linesize,

                                              int block_w, int block_h,

                                              int src_x, int src_y,

                                              int w, int h,

                                              emu_edge_core_func *core_fn)

{

    int start_y, start_x, end_y, end_x, src_y_add = 0;



    if (src_y >= h) {

        src_y_add = h - 1 - src_y;

        src_y     = h - 1;

    } else if (src_y <= -block_h) {

        src_y_add = 1 - block_h - src_y;

        src_y     = 1 - block_h;

    }

    if (src_x >= w) {

        src   += w - 1 - src_x;

        src_x  = w - 1;

    } else if (src_x <= -block_w) {

        src   += 1 - block_w - src_x;

        src_x  = 1 - block_w;

    }



    start_y = FFMAX(0, -src_y);

    start_x = FFMAX(0, -src_x);

    end_y   = FFMIN(block_h, h-src_y);

    end_x   = FFMIN(block_w, w-src_x);

    av_assert2(start_x < end_x && block_w > 0);

    av_assert2(start_y < end_y && block_h > 0);



    // fill in the to-be-copied part plus all above/below

    src += (src_y_add + start_y) * linesize + start_x;

    buf += start_x;

    core_fn(buf, src, linesize, start_y, end_y,

            block_h, start_x, end_x, block_w);

}
",247,,0,1,,-4,"buf,src,linesize,block_w,block_h,src_x,src_y,w,h,core_fn,start_y,start_x,end_y,end_x",,,,,Greedy,1,0.008996832370758056
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
",129,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int gfle_Aten3_oZc9_eamncure;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (gfle_Aten3_oZc9_eamncure = 0; gfle_Aten3_oZc9_eamncure < BINKB_NB_SRC; gfle_Aten3_oZc9_eamncure++) {

        c->bundle[gfle_Aten3_oZc9_eamncure].data = av_malloc(blocks * 64);

        if (!c->bundle[gfle_Aten3_oZc9_eamncure].data)

            return AVERROR(ENOMEM);

        c->bundle[gfle_Aten3_oZc9_eamncure].data_end = c->bundle[gfle_Aten3_oZc9_eamncure].data + blocks * 64;

    }



    return 0;

}
",1,1,0,1,"c,bw,bh,blocks,i","c:-0.1403399109840393,bw:-0.018705129623413086,bh:0.00310593843460083,blocks:-0.05725288391113281,i:0.03613239526748657,",1,8,"i:gfle_Aten3_oZc9_eamncure,",Greedy,87,0.03695254723230998
217,"static void quorum_vote(QuorumAIOCB *acb)

{

    bool quorum = true;

    int i, j, ret;

    QuorumVoteValue hash;

    BDRVQuorumState *s = acb->common.bs->opaque;

    QuorumVoteVersion *winner;



    if (quorum_has_too_much_io_failed(acb)) {

        return;

    }



    /* get the index of the first successful read */

    for (i = 0; i < s->num_children; i++) {

        if (!acb->qcrs[i].ret) {

            break;

        }

    }



    assert(i < s->num_children);



    /* compare this read with all other successful reads stopping at quorum

     * failure

     */

    for (j = i + 1; j < s->num_children; j++) {

        if (acb->qcrs[j].ret) {

            continue;

        }

        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);

        if (!quorum) {

            break;

       }

    }



    /* Every successful read agrees */

    if (quorum) {

        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);

        return;

    }



    /* compute hashes for each successful read, also store indexes */

    for (i = 0; i < s->num_children; i++) {

        if (acb->qcrs[i].ret) {

            continue;

        }

        ret = quorum_compute_hash(acb, i, &hash);

        /* if ever the hash computation failed */

        if (ret < 0) {

            acb->vote_ret = ret;

            goto free_exit;

        }

        quorum_count_vote(&acb->votes, &hash, i);

    }



    /* vote to select the most represented version */

    winner = quorum_get_vote_winner(&acb->votes);



    /* if the winner count is smaller than threshold the read fails */

    if (winner->vote_count < s->threshold) {

        quorum_report_failure(acb);

        acb->vote_ret = -EIO;

        goto free_exit;

    }



    /* we have a winner: copy it */

    quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov);



    /* some versions are bad print them */

    quorum_report_bad_versions(s, acb, &winner->value);



free_exit:

    /* free lists */

    quorum_free_vote_list(&acb->votes);

}
",341,,1,0,,-4,"acb,i,j,ret,hash,s,winner",,,,,Greedy,1,0.009029742081960042
218,"static void stellaris_init(const char *kernel_filename, const char *cpu_model,

                           stellaris_board_info *board)

{

    static const int uart_irq[] = {5, 6, 33, 34};

    static const int timer_irq[] = {19, 21, 23, 35};

    static const uint32_t gpio_addr[7] =

      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,

        0x40024000, 0x40025000, 0x40026000};

    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};



    qemu_irq *pic;

    DeviceState *gpio_dev[7];

    qemu_irq gpio_in[7][8];

    qemu_irq gpio_out[7][8];

    qemu_irq adc;

    int sram_size;

    int flash_size;

    I2CBus *i2c;

    DeviceState *dev;

    int i;

    int j;



    MemoryRegion *sram = g_new(MemoryRegion, 1);

    MemoryRegion *flash = g_new(MemoryRegion, 1);

    MemoryRegion *system_memory = get_system_memory();



    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;

    sram_size = ((board->dc0 >> 18) + 1) * 1024;



    /* Flash programming is done via the SCU, so pretend it is ROM.  */

    memory_region_init_ram(flash, NULL, ""stellaris.flash"", flash_size,

                           &error_abort);

    vmstate_register_ram_global(flash);

    memory_region_set_readonly(flash, true);

    memory_region_add_subregion(system_memory, 0, flash);



    memory_region_init_ram(sram, NULL, ""stellaris.sram"", sram_size,

                           &error_abort);

    vmstate_register_ram_global(sram);

    memory_region_add_subregion(system_memory, 0x20000000, sram);



    pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES,

                      kernel_filename, cpu_model);



    if (board->dc1 & (1 << 16)) {

        dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,

                                    pic[14], pic[15], pic[16], pic[17], NULL);

        adc = qdev_get_gpio_in(dev, 0);

    } else {

        adc = NULL;

    }

    for (i = 0; i < 4; i++) {

        if (board->dc2 & (0x10000 << i)) {

            dev = sysbus_create_simple(TYPE_STELLARIS_GPTM,

                                       0x40030000 + i * 0x1000,

                                       pic[timer_irq[i]]);

            /* TODO: This is incorrect, but we get away with it because

               the ADC output is only ever pulsed.  */

            qdev_connect_gpio_out(dev, 0, adc);

        }

    }



    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a);



    for (i = 0; i < 7; i++) {

        if (board->dc4 & (1 << i)) {

            gpio_dev[i] = sysbus_create_simple(""pl061_luminary"", gpio_addr[i],

                                               pic[gpio_irq[i]]);

            for (j = 0; j < 8; j++) {

                gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j);

                gpio_out[i][j] = NULL;

            }

        }

    }



    if (board->dc2 & (1 << 12)) {

        dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]);

        i2c = (I2CBus *)qdev_get_child_bus(dev, ""i2c"");

        if (board->peripherals & BP_OLED_I2C) {

            i2c_create_slave(i2c, ""ssd0303"", 0x3d);

        }

    }



    for (i = 0; i < 4; i++) {

        if (board->dc2 & (1 << i)) {

            sysbus_create_simple(""pl011_luminary"", 0x4000c000 + i * 0x1000,

                                 pic[uart_irq[i]]);

        }

    }

    if (board->dc2 & (1 << 4)) {

        dev = sysbus_create_simple(""pl022"", 0x40008000, pic[7]);

        if (board->peripherals & BP_OLED_SSI) {

            void *bus;

            DeviceState *sddev;

            DeviceState *ssddev;



            /* Some boards have both an OLED controller and SD card connected to

             * the same SSI port, with the SD card chip select connected to a

             * GPIO pin.  Technically the OLED chip select is connected to the

             * SSI Fss pin.  We do not bother emulating that as both devices

             * should never be selected simultaneously, and our OLED controller

             * ignores stray 0xff commands that occur when deselecting the SD

             * card.

             */

            bus = qdev_get_child_bus(dev, ""ssi"");



            sddev = ssi_create_slave(bus, ""ssi-sd"");

            ssddev = ssi_create_slave(bus, ""ssd0323"");

            gpio_out[GPIO_D][0] = qemu_irq_split(

                    qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0),

                    qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0));

            gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0);



            /* Make sure the select pin is high.  */

            qemu_irq_raise(gpio_out[GPIO_D][0]);

        }

    }

    if (board->dc4 & (1 << 28)) {

        DeviceState *enet;



        qemu_check_nic_model(&nd_table[0], ""stellaris"");



        enet = qdev_create(NULL, ""stellaris_enet"");

        qdev_set_nic_properties(enet, &nd_table[0]);

        qdev_init_nofail(enet);

        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);

        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);

    }

    if (board->peripherals & BP_GAMEPAD) {

        qemu_irq gpad_irq[5];

        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };



        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */

        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */

        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */

        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */

        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */



        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);

    }

    for (i = 0; i < 7; i++) {

        if (board->dc4 & (1 << i)) {

            for (j = 0; j < 8; j++) {

                if (gpio_out[i][j]) {

                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);

                }

            }

        }

    }

}
",1078,,1,0,,-4,"kernel_filename,cpu_model,board,uart_irq,timer_irq,gpio_addr,gpio_irq,pic,gpio_dev,gpio_in,gpio_out,adc,sram_size,flash_size,i2c,dev,i,j,sram,flash,system_memory,bus,sddev,ssddev,enet,gpad_irq,gpad_keycode",,,,,Greedy,1,0.008330969015757243
219,"void cpu_exec_init(CPUState *env)

{

    CPUState **penv;

    int cpu_index;



    if (!code_gen_ptr) {

        code_gen_ptr = code_gen_buffer;

        page_init();

        io_mem_init();

    }

    env->next_cpu = NULL;

    penv = &first_cpu;

    cpu_index = 0;

    while (*penv != NULL) {

        penv = (CPUState **)&(*penv)->next_cpu;

        cpu_index++;

    }

    env->cpu_index = cpu_index;


    *penv = env;

}",89,,1,0,,-4,"env,penv,cpu_index",,,,,Greedy,1,0.008372044563293457
220,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	long width, long height,

	long lumStride, long chromStride, long dstStride)

{

	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",70,,1,0,,-4,"ysrc,usrc,vsrc,dst,height,lumStride,chromStride,dstStride",,,,,Greedy,1,0.008062052726745605
221,"static inline bool handler_is_async(const mon_cmd_t *cmd)

{

    return cmd->flags & MONITOR_CMD_ASYNC;

}
",19,,1,0,,-4,cmd,,,,,Greedy,1,0.007998371124267578
222,"static int vqa_decode_init(AVCodecContext *avctx)

{

    VqaContext *s = (VqaContext *)avctx->priv_data;

    unsigned char *vqa_header;

    int i, j, codebook_index;;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    avctx->has_b_frames = 0;

    dsputil_init(&s->dsp, avctx);



    /* make sure the extradata made it */

    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d\n"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    vqa_header = (unsigned char *)s->avctx->extradata;

    s->vqa_version = vqa_header[0];

    s->width = LE_16(&vqa_header[6]);

    s->height = LE_16(&vqa_header[8]);





    s->vector_width = vqa_header[10];

    s->vector_height = vqa_header[11];

    s->partial_count = s->partial_countdown = vqa_header[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((s->vector_width != 4) ||

        ((s->vector_height != 2) && (s->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    s->codebook_size = MAX_CODEBOOK_SIZE;

    s->codebook = av_malloc(s->codebook_size);

    s->next_codebook_buffer = av_malloc(s->codebook_size);



    /* initialize the solid-color vectors */

    if (s->vector_height == 4) {

        codebook_index = 0xFF00 * 16;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 16; j++)

                s->codebook[codebook_index++] = i;

    } else {

        codebook_index = 0xF00 * 8;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 8; j++)

                s->codebook[codebook_index++] = i;


    s->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    s->decode_buffer_size = (s->width / s->vector_width) *

        (s->height / s->vector_height) * 2;

    s->decode_buffer = av_malloc(s->decode_buffer_size);



    s->frame.data[0] = NULL;



    return 0;
",377,"static int vqa_decode_init(AVCodecContext *avctx)

{

    VqaContext *_than_alZpOharedun4a = (VqaContext *)avctx->priv_data;

    unsigned char *vqa_header;

    int i, IDE_DEunt_blocea, codebook_index;;



    _than_alZpOharedun4a->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    avctx->has_b_frames = 0;

    dsputil_init(&_than_alZpOharedun4a->dsp, avctx);



    /* make sure the extradata made it */

    if (_than_alZpOharedun4a->avctx->extradata_size != VQA_HEADER_SIZE) {

        av_log(_than_alZpOharedun4a->avctx, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d
"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    vqa_header = (unsigned char *)_than_alZpOharedun4a->avctx->extradata;

    _than_alZpOharedun4a->vqa_version = vqa_header[0];

    _than_alZpOharedun4a->width = LE_16(&vqa_header[6]);

    _than_alZpOharedun4a->height = LE_16(&vqa_header[8]);





    _than_alZpOharedun4a->vector_width = vqa_header[10];

    _than_alZpOharedun4a->vector_height = vqa_header[11];

    _than_alZpOharedun4a->partial_count = _than_alZpOharedun4a->partial_countdown = vqa_header[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((_than_alZpOharedun4a->vector_width != 4) ||

        ((_than_alZpOharedun4a->vector_height != 2) && (_than_alZpOharedun4a->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    _than_alZpOharedun4a->codebook_size = MAX_CODEBOOK_SIZE;

    _than_alZpOharedun4a->codebook = av_malloc(_than_alZpOharedun4a->codebook_size);

    _than_alZpOharedun4a->next_codebook_buffer = av_malloc(_than_alZpOharedun4a->codebook_size);



    /* initialize the solid-color vectors */

    if (_than_alZpOharedun4a->vector_height == 4) {

        codebook_index = 0xFF00 * 16;

        for (i = 0; i < 256; i++)

            for (IDE_DEunt_blocea = 0; IDE_DEunt_blocea < 16; IDE_DEunt_blocea++)

                _than_alZpOharedun4a->codebook[codebook_index++] = i;

    } else {

        codebook_index = 0xF00 * 8;

        for (i = 0; i < 256; i++)

            for (IDE_DEunt_blocea = 0; IDE_DEunt_blocea < 8; IDE_DEunt_blocea++)

                _than_alZpOharedun4a->codebook[codebook_index++] = i;


    _than_alZpOharedun4a->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    _than_alZpOharedun4a->decode_buffer_size = (_than_alZpOharedun4a->width / _than_alZpOharedun4a->vector_width) *

        (_than_alZpOharedun4a->height / _than_alZpOharedun4a->vector_height) * 2;

    _than_alZpOharedun4a->decode_buffer = av_malloc(_than_alZpOharedun4a->decode_buffer_size);



    _than_alZpOharedun4a->frame.data[0] = NULL;



    return 0;
",1,1,1,-1,"avctx,s,vqa_header,i,j,codebook_index","avctx:-0.001234591007232666,s:-0.001316368579864502,vqa_header:-0.0009214282035827637,i:0.00013369321823120117,j:0.00011610984802246094,codebook_index:-0.00024884939193725586,",2,40,"i:i,j:IDE_DEunt_blocea,codebook_index:codebook_index,vqa_header:vqa_header,avctx:avctx,s:_than_alZpOharedun4a,",Greedy,434,0.13658442894617717
223,"static int open_output_file(OptionsContext *o, const char *filename)

{

    AVFormatContext *oc;

    int i, j, err;

    AVOutputFormat *file_oformat;

    OutputFile *of;

    OutputStream *ost;

    InputStream  *ist;

    AVDictionary *unused_opts = NULL;

    AVDictionaryEntry *e = NULL;



    if (configure_complex_filters() < 0) {

        av_log(NULL, AV_LOG_FATAL, ""Error configuring filters.\n"");

        exit_program(1);

    }



    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {

        o->stop_time = INT64_MAX;

        av_log(NULL, AV_LOG_WARNING, ""-t and -to cannot be used together; using -t.\n"");

    }



    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {

        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;

        if (o->stop_time <= start_time) {

            av_log(NULL, AV_LOG_WARNING, ""-to value smaller than -ss; ignoring -to.\n"");

            o->stop_time = INT64_MAX;

        } else {

            o->recording_time = o->stop_time - start_time;

        }

    }



    GROW_ARRAY(output_files, nb_output_files);

    of = av_mallocz(sizeof(*of));

    if (!of)

        exit_program(1);

    output_files[nb_output_files - 1] = of;



    of->ost_index      = nb_output_streams;

    of->recording_time = o->recording_time;

    of->start_time     = o->start_time;

    of->limit_filesize = o->limit_filesize;

    of->shortest       = o->shortest;

    av_dict_copy(&of->opts, o->g->format_opts, 0);



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);

    if (!oc) {

        print_error(filename, err);

        exit_program(1);

    }



    of->ctx = oc;

    if (o->recording_time != INT64_MAX)

        oc->duration = o->recording_time;



    file_oformat= oc->oformat;

    oc->interrupt_callback = int_cb;



    /* create streams for all unlabeled output pads */

    for (i = 0; i < nb_filtergraphs; i++) {

        FilterGraph *fg = filtergraphs[i];

        for (j = 0; j < fg->nb_outputs; j++) {

            OutputFilter *ofilter = fg->outputs[j];



            if (!ofilter->out_tmp || ofilter->out_tmp->name)

                continue;



            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,

                                          ofilter->out_tmp->pad_idx)) {

            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;

            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;

            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;

            }

            init_output_filter(ofilter, o, oc);

        }

    }



    /* ffserver seeking with date=... needs a date reference */

    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        int err = parse_option(o, ""metadata"", ""creation_time=now"", options);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    if (!strcmp(file_oformat->name, ""ffm"") && !override_ffserver &&

        av_strstart(filename, ""http:"", NULL)) {

        int j;

        /* special case for files sent to ffserver: we get the stream

           parameters from ffserver */

        int err = read_ffserver_streams(o, oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {

            ost = output_streams[j];

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if(ist->st->codec->codec_type == ost->st->codec->codec_type){

                    ost->sync_ist= ist;

                    ost->source_index= i;

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(""anull"");

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(""null"");

                    ist->discard = 0;

                    ist->st->discard = AVDISCARD_NONE;

                    break;

                }

            }

            if(!ost->sync_ist){

                av_log(NULL, AV_LOG_FATAL, ""Missing %s stream which is required by this ffm\n"", av_get_media_type_string(ost->st->codec->codec_type));

                exit_program(1);

            }

        }

    } else if (!o->nb_stream_maps) {

        char *subtitle_codec_name = NULL;

        /* pick the ""best"" stream of each type */



        /* video: highest resolution */

        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {

            int area = 0, idx = -1;

            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);

            for (i = 0; i < nb_input_streams; i++) {

                int new_area;

                ist = input_streams[i];

                new_area = ist->st->codec->width * ist->st->codec->height;

                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                    new_area = 1;

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    new_area > area) {

                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                        continue;

                    area = new_area;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_video_stream(o, oc, idx);

        }



        /* audio: most channels */

        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_audio_stream(o, oc, idx);

        }



        /* subtitles: pick first */

        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, ""s"");

        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    new_subtitle_stream(o, oc, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < o->nb_stream_maps; i++) {

            StreamMap *map = &o->stream_maps[i];



            if (map->disabled)

                continue;



            if (map->linklabel) {

                FilterGraph *fg;

                OutputFilter *ofilter = NULL;

                int j, k;



                for (j = 0; j < nb_filtergraphs; j++) {

                    fg = filtergraphs[j];

                    for (k = 0; k < fg->nb_outputs; k++) {

                        AVFilterInOut *out = fg->outputs[k]->out_tmp;

                        if (out && !strcmp(out->name, map->linklabel)) {

                            ofilter = fg->outputs[k];

                            goto loop_end;

                        }

                    }

                }

loop_end:

                if (!ofilter) {

                    av_log(NULL, AV_LOG_FATAL, ""Output with label '%s' does not exist ""

                           ""in any defined filter graph, or was already used elsewhere.\n"", map->linklabel);

                    exit_program(1);

                }

                init_output_filter(ofilter, o, oc);

            } else {

                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;



                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];

                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)

                    continue;

                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)

                    continue;

                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

                    continue;

                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)

                    continue;



                switch (ist->st->codec->codec_type) {

                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;

                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;

                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;

                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;

                default:

                    av_log(NULL, AV_LOG_FATAL, ""Cannot map stream #%d:%d - unsupported type.\n"",

                           map->file_index, map->stream_index);

                    exit_program(1);

                }

            }

        }

    }



    /* handle attached files */

    for (i = 0; i < o->nb_attachments; i++) {

        AVIOContext *pb;

        uint8_t *attachment;

        const char *p;

        int64_t len;



        if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not open attachment file %s.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        if ((len = avio_size(pb)) <= 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not get size of the attachment %s.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        if (!(attachment = av_malloc(len))) {

            av_log(NULL, AV_LOG_FATAL, ""Attachment %s too large to fit into memory.\n"",

                   o->attachments[i]);

            exit_program(1);

        }

        avio_read(pb, attachment, len);



        ost = new_attachment_stream(o, oc, -1);

        ost->stream_copy               = 0;

        ost->attachment_filename       = o->attachments[i];

        ost->finished                  = 1;

        ost->st->codec->extradata      = attachment;

        ost->st->codec->extradata_size = len;



        p = strrchr(o->attachments[i], '/');

        av_dict_set(&ost->st->metadata, ""filename"", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);

        avio_close(pb);

    }



    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { //for all streams of this output file

        AVDictionaryEntry *e;

        ost = output_streams[i];



        if ((ost->stream_copy || ost->attachment_filename)

            && (e = av_dict_get(o->g->codec_opts, ""flags"", NULL, AV_DICT_IGNORE_SUFFIX))

            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))

            if (av_opt_set(ost->st->codec, ""flags"", e->value, 0) < 0)

                exit_program(1);

    }



    /* check if all codec options have been used */

    unused_opts = strip_specifiers(o->g->codec_opts);

    for (i = of->ost_index; i < nb_output_streams; i++) {

        e = NULL;

        while ((e = av_dict_get(output_streams[i]->opts, """", e,

                                AV_DICT_IGNORE_SUFFIX)))

            av_dict_set(&unused_opts, e->key, NULL, 0);

    }



    e = NULL;

    while ((e = av_dict_get(unused_opts, """", e, AV_DICT_IGNORE_SUFFIX))) {

        const AVClass *class = avcodec_get_class();

        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,

                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);

        if (!option)

            continue;

        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {

            av_log(NULL, AV_LOG_ERROR, ""Codec AVOption %s (%s) specified for ""

                   ""output file #%d (%s) is not an encoding option.\n"", e->key,

                   option->help ? option->help : """", nb_output_files - 1,

                   filename);

            exit_program(1);

        }



        // gop_timecode is injected by generic code but not always used

        if (!strcmp(e->key, ""gop_timecode""))

            continue;



        av_log(NULL, AV_LOG_WARNING, ""Codec AVOption %s (%s) specified for ""

               ""output file #%d (%s) has not been used for any stream. The most ""

               ""likely reason is either wrong type (e.g. a video option with ""

               ""no video streams) or that it is a private option of some encoder ""

               ""which was not actually used for any stream.\n"", e->key,

               option->help ? option->help : """", nb_output_files - 1, filename);

    }

    av_dict_free(&unused_opts);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid losing precious files */

        assert_file_overwrite(filename);



        /* open the file */

        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,

                              &oc->interrupt_callback,

                              &of->opts)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (strcmp(oc->oformat->name, ""image2"")==0 && !av_filename_number_test(filename))

        assert_file_overwrite(filename);



    if (o->mux_preload) {

        uint8_t buf[64];

        snprintf(buf, sizeof(buf), ""%d"", (int)(o->mux_preload*AV_TIME_BASE));

        av_dict_set(&of->opts, ""preload"", buf, 0);

    }

    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);



    /* copy metadata */

    for (i = 0; i < o->nb_metadata_map; i++) {

        char *p;

        int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0);



        if (in_file_index >= nb_input_files) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d while processing metadata maps\n"", in_file_index);

            exit_program(1);

        }

        copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc,

                      in_file_index >= 0 ?

                      input_files[in_file_index]->ctx : NULL, o);

    }



    /* copy chapters */

    if (o->chapters_input_file >= nb_input_files) {

        if (o->chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            o->chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i]->ctx->nb_chapters) {

                    o->chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d in chapter mapping.\n"",

                   o->chapters_input_file);

            exit_program(1);

        }

    }

    if (o->chapters_input_file >= 0)

        copy_chapters(input_files[o->chapters_input_file], of,

                      !o->metadata_chapters_manual);



    /* copy global metadata by default */

    if (!o->metadata_global_manual && nb_input_files){

        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

        if(o->recording_time != INT64_MAX)

            av_dict_set(&oc->metadata, ""duration"", NULL, 0);

        av_dict_set(&oc->metadata, ""creation_time"", NULL, 0);

    }

    if (!o->metadata_streams_manual)

        for (i = of->ost_index; i < nb_output_streams; i++) {

            InputStream *ist;

            if (output_streams[i]->source_index < 0)         /* this is true e.g. for attached files */

                continue;

            ist = input_streams[output_streams[i]->source_index];

            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    /* process manually set metadata */

    for (i = 0; i < o->nb_metadata; i++) {

        AVDictionary **m;

        char type, *val;

        const char *stream_spec;

        int index = 0, j, ret = 0;



        val = strchr(o->metadata[i].u.str, '=');

        if (!val) {

            av_log(NULL, AV_LOG_FATAL, ""No '=' character in metadata string %s.\n"",

                   o->metadata[i].u.str);

            exit_program(1);

        }

        *val++ = 0;



        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);

        if (type == 's') {

            for (j = 0; j < oc->nb_streams; j++) {

                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {

                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);

                } else if (ret < 0)

                    exit_program(1);

            }

        }

        else {

            switch (type) {

            case 'g':

                m = &oc->metadata;

                break;

            case 'c':

                if (index < 0 || index >= oc->nb_chapters) {

                    av_log(NULL, AV_LOG_FATAL, ""Invalid chapter index %d in metadata specifier.\n"", index);

                    exit_program(1);

                }

                m = &oc->chapters[index]->metadata;

                break;

            default:

                av_log(NULL, AV_LOG_FATAL, ""Invalid metadata specifier %s.\n"", o->metadata[i].specifier);

                exit_program(1);

            }

            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);

        }

    }



    return 0;

}
",3171,"static int open_output_file(OptionsContext *aczelrce_eranEedundaumbgrn, const char *filename)

{

    AVFormatContext *oc;

    int i, j, err;

    AVOutputFormat *file_oformat;

    OutputFile *of;

    OutputStream *ost;

    InputStream  *ist;

    AVDictionary *unused_opts = NULL;

    AVDictionaryEntry *e = NULL;



    if (configure_complex_filters() < 0) {

        av_log(NULL, AV_LOG_FATAL, ""Error configuring filters.
"");

        exit_program(1);

    }



    if (aczelrce_eranEedundaumbgrn->stop_time != INT64_MAX && aczelrce_eranEedundaumbgrn->recording_time != INT64_MAX) {

        aczelrce_eranEedundaumbgrn->stop_time = INT64_MAX;

        av_log(NULL, AV_LOG_WARNING, ""-t and -to cannot be used together; using -t.
"");

    }



    if (aczelrce_eranEedundaumbgrn->stop_time != INT64_MAX && aczelrce_eranEedundaumbgrn->recording_time == INT64_MAX) {

        int64_t start_time = aczelrce_eranEedundaumbgrn->start_time == AV_NOPTS_VALUE ? 0 : aczelrce_eranEedundaumbgrn->start_time;

        if (aczelrce_eranEedundaumbgrn->stop_time <= start_time) {

            av_log(NULL, AV_LOG_WARNING, ""-to value smaller than -ss; ignoring -to.
"");

            aczelrce_eranEedundaumbgrn->stop_time = INT64_MAX;

        } else {

            aczelrce_eranEedundaumbgrn->recording_time = aczelrce_eranEedundaumbgrn->stop_time - start_time;

        }

    }



    GROW_ARRAY(output_files, nb_output_files);

    of = av_mallocz(sizeof(*of));

    if (!of)

        exit_program(1);

    output_files[nb_output_files - 1] = of;



    of->ost_index      = nb_output_streams;

    of->recording_time = aczelrce_eranEedundaumbgrn->recording_time;

    of->start_time     = aczelrce_eranEedundaumbgrn->start_time;

    of->limit_filesize = aczelrce_eranEedundaumbgrn->limit_filesize;

    of->shortest       = aczelrce_eranEedundaumbgrn->shortest;

    av_dict_copy(&of->opts, aczelrce_eranEedundaumbgrn->g->format_opts, 0);



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    err = avformat_alloc_output_context2(&oc, NULL, aczelrce_eranEedundaumbgrn->format, filename);

    if (!oc) {

        print_error(filename, err);

        exit_program(1);

    }



    of->ctx = oc;

    if (aczelrce_eranEedundaumbgrn->recording_time != INT64_MAX)

        oc->duration = aczelrce_eranEedundaumbgrn->recording_time;



    file_oformat= oc->oformat;

    oc->interrupt_callback = int_cb;



    /* create streams for all unlabeled output pads */

    for (i = 0; i < nb_filtergraphs; i++) {

        FilterGraph *fg = filtergraphs[i];

        for (j = 0; j < fg->nb_outputs; j++) {

            OutputFilter *ofilter = fg->outputs[j];



            if (!ofilter->out_tmp || ofilter->out_tmp->name)

                continue;



            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,

                                          ofilter->out_tmp->pad_idx)) {

            case AVMEDIA_TYPE_VIDEO:    aczelrce_eranEedundaumbgrn->video_disable    = 1; break;

            case AVMEDIA_TYPE_AUDIO:    aczelrce_eranEedundaumbgrn->audio_disable    = 1; break;

            case AVMEDIA_TYPE_SUBTITLE: aczelrce_eranEedundaumbgrn->subtitle_disable = 1; break;

            }

            init_output_filter(ofilter, aczelrce_eranEedundaumbgrn, oc);

        }

    }



    /* ffserver seeking with date=... needs a date reference */

    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        int err = parse_option(aczelrce_eranEedundaumbgrn, ""metadata"", ""creation_time=now"", options);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    if (!strcmp(file_oformat->name, ""ffm"") && !override_ffserver &&

        av_strstart(filename, ""http:"", NULL)) {

        int j;

        /* special case for files sent to ffserver: we get the stream

           parameters from ffserver */

        int err = read_ffserver_streams(aczelrce_eranEedundaumbgrn, oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {

            ost = output_streams[j];

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if(ist->st->codec->codec_type == ost->st->codec->codec_type){

                    ost->sync_ist= ist;

                    ost->source_index= i;

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(""anull"");

                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(""null"");

                    ist->discard = 0;

                    ist->st->discard = AVDISCARD_NONE;

                    break;

                }

            }

            if(!ost->sync_ist){

                av_log(NULL, AV_LOG_FATAL, ""Missing %s stream which is required by this ffm
"", av_get_media_type_string(ost->st->codec->codec_type));

                exit_program(1);

            }

        }

    } else if (!aczelrce_eranEedundaumbgrn->nb_stream_maps) {

        char *subtitle_codec_name = NULL;

        /* pick the ""best"" stream of each type */



        /* video: highest resolution */

        if (!aczelrce_eranEedundaumbgrn->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {

            int area = 0, idx = -1;

            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);

            for (i = 0; i < nb_input_streams; i++) {

                int new_area;

                ist = input_streams[i];

                new_area = ist->st->codec->width * ist->st->codec->height;

                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                    new_area = 1;

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    new_area > area) {

                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))

                        continue;

                    area = new_area;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_video_stream(aczelrce_eranEedundaumbgrn, oc, idx);

        }



        /* audio: most channels */

        if (!aczelrce_eranEedundaumbgrn->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            if (idx >= 0)

                new_audio_stream(aczelrce_eranEedundaumbgrn, oc, idx);

        }



        /* subtitles: pick first */

        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, ""s"");

        if (!aczelrce_eranEedundaumbgrn->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    new_subtitle_stream(aczelrce_eranEedundaumbgrn, oc, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < aczelrce_eranEedundaumbgrn->nb_stream_maps; i++) {

            StreamMap *map = &aczelrce_eranEedundaumbgrn->stream_maps[i];



            if (map->disabled)

                continue;



            if (map->linklabel) {

                FilterGraph *fg;

                OutputFilter *ofilter = NULL;

                int j, k;



                for (j = 0; j < nb_filtergraphs; j++) {

                    fg = filtergraphs[j];

                    for (k = 0; k < fg->nb_outputs; k++) {

                        AVFilterInOut *out = fg->outputs[k]->out_tmp;

                        if (out && !strcmp(out->name, map->linklabel)) {

                            ofilter = fg->outputs[k];

                            goto loop_end;

                        }

                    }

                }

loop_end:

                if (!ofilter) {

                    av_log(NULL, AV_LOG_FATAL, ""Output with label '%s' does not exist ""

                           ""in any defined filter graph, or was already used elsewhere.
"", map->linklabel);

                    exit_program(1);

                }

                init_output_filter(ofilter, aczelrce_eranEedundaumbgrn, oc);

            } else {

                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;



                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];

                if(aczelrce_eranEedundaumbgrn->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)

                    continue;

                if(aczelrce_eranEedundaumbgrn->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)

                    continue;

                if(aczelrce_eranEedundaumbgrn->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

                    continue;

                if(aczelrce_eranEedundaumbgrn->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)

                    continue;



                switch (ist->st->codec->codec_type) {

                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (aczelrce_eranEedundaumbgrn, oc, src_idx); break;

                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (aczelrce_eranEedundaumbgrn, oc, src_idx); break;

                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (aczelrce_eranEedundaumbgrn, oc, src_idx); break;

                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (aczelrce_eranEedundaumbgrn, oc, src_idx); break;

                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(aczelrce_eranEedundaumbgrn, oc, src_idx); break;

                default:

                    av_log(NULL, AV_LOG_FATAL, ""Cannot map stream #%d:%d - unsupported type.
"",

                           map->file_index, map->stream_index);

                    exit_program(1);

                }

            }

        }

    }



    /* handle attached files */

    for (i = 0; i < aczelrce_eranEedundaumbgrn->nb_attachments; i++) {

        AVIOContext *pb;

        uint8_t *attachment;

        const char *p;

        int64_t len;



        if ((err = avio_open2(&pb, aczelrce_eranEedundaumbgrn->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not open attachment file %s.
"",

                   aczelrce_eranEedundaumbgrn->attachments[i]);

            exit_program(1);

        }

        if ((len = avio_size(pb)) <= 0) {

            av_log(NULL, AV_LOG_FATAL, ""Could not get size of the attachment %s.
"",

                   aczelrce_eranEedundaumbgrn->attachments[i]);

            exit_program(1);

        }

        if (!(attachment = av_malloc(len))) {

            av_log(NULL, AV_LOG_FATAL, ""Attachment %s too large to fit into memory.
"",

                   aczelrce_eranEedundaumbgrn->attachments[i]);

            exit_program(1);

        }

        avio_read(pb, attachment, len);



        ost = new_attachment_stream(aczelrce_eranEedundaumbgrn, oc, -1);

        ost->stream_copy               = 0;

        ost->attachment_filename       = aczelrce_eranEedundaumbgrn->attachments[i];

        ost->finished                  = 1;

        ost->st->codec->extradata      = attachment;

        ost->st->codec->extradata_size = len;



        p = strrchr(aczelrce_eranEedundaumbgrn->attachments[i], '/');

        av_dict_set(&ost->st->metadata, ""filename"", (p && *p) ? p + 1 : aczelrce_eranEedundaumbgrn->attachments[i], AV_DICT_DONT_OVERWRITE);

        avio_close(pb);

    }



    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { //for all streams of this output file

        AVDictionaryEntry *e;

        ost = output_streams[i];



        if ((ost->stream_copy || ost->attachment_filename)

            && (e = av_dict_get(aczelrce_eranEedundaumbgrn->g->codec_opts, ""flags"", NULL, AV_DICT_IGNORE_SUFFIX))

            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))

            if (av_opt_set(ost->st->codec, ""flags"", e->value, 0) < 0)

                exit_program(1);

    }



    /* check if all codec options have been used */

    unused_opts = strip_specifiers(aczelrce_eranEedundaumbgrn->g->codec_opts);

    for (i = of->ost_index; i < nb_output_streams; i++) {

        e = NULL;

        while ((e = av_dict_get(output_streams[i]->opts, """", e,

                                AV_DICT_IGNORE_SUFFIX)))

            av_dict_set(&unused_opts, e->key, NULL, 0);

    }



    e = NULL;

    while ((e = av_dict_get(unused_opts, """", e, AV_DICT_IGNORE_SUFFIX))) {

        const AVClass *class = avcodec_get_class();

        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,

                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);

        if (!option)

            continue;

        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {

            av_log(NULL, AV_LOG_ERROR, ""Codec AVOption %s (%s) specified for ""

                   ""output file #%d (%s) is not an encoding option.
"", e->key,

                   option->help ? option->help : """", nb_output_files - 1,

                   filename);

            exit_program(1);

        }



        // gop_timecode is injected by generic code but not always used

        if (!strcmp(e->key, ""gop_timecode""))

            continue;



        av_log(NULL, AV_LOG_WARNING, ""Codec AVOption %s (%s) specified for ""

               ""output file #%d (%s) has not been used for any stream. The most ""

               ""likely reason is either wrong type (e.g. a video option with ""

               ""no video streams) or that it is a private option of some encoder ""

               ""which was not actually used for any stream.
"", e->key,

               option->help ? option->help : """", nb_output_files - 1, filename);

    }

    av_dict_free(&unused_opts);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid losing precious files */

        assert_file_overwrite(filename);



        /* open the file */

        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,

                              &oc->interrupt_callback,

                              &of->opts)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (strcmp(oc->oformat->name, ""image2"")==0 && !av_filename_number_test(filename))

        assert_file_overwrite(filename);



    if (aczelrce_eranEedundaumbgrn->mux_preload) {

        uint8_t buf[64];

        snprintf(buf, sizeof(buf), ""%d"", (int)(aczelrce_eranEedundaumbgrn->mux_preload*AV_TIME_BASE));

        av_dict_set(&of->opts, ""preload"", buf, 0);

    }

    oc->max_delay = (int)(aczelrce_eranEedundaumbgrn->mux_max_delay * AV_TIME_BASE);



    /* copy metadata */

    for (i = 0; i < aczelrce_eranEedundaumbgrn->nb_metadata_map; i++) {

        char *p;

        int in_file_index = strtol(aczelrce_eranEedundaumbgrn->metadata_map[i].u.str, &p, 0);



        if (in_file_index >= nb_input_files) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d while processing metadata maps
"", in_file_index);

            exit_program(1);

        }

        copy_metadata(aczelrce_eranEedundaumbgrn->metadata_map[i].specifier, *p ? p + 1 : p, oc,

                      in_file_index >= 0 ?

                      input_files[in_file_index]->ctx : NULL, aczelrce_eranEedundaumbgrn);

    }



    /* copy chapters */

    if (aczelrce_eranEedundaumbgrn->chapters_input_file >= nb_input_files) {

        if (aczelrce_eranEedundaumbgrn->chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            aczelrce_eranEedundaumbgrn->chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i]->ctx->nb_chapters) {

                    aczelrce_eranEedundaumbgrn->chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_FATAL, ""Invalid input file index %d in chapter mapping.
"",

                   aczelrce_eranEedundaumbgrn->chapters_input_file);

            exit_program(1);

        }

    }

    if (aczelrce_eranEedundaumbgrn->chapters_input_file >= 0)

        copy_chapters(input_files[aczelrce_eranEedundaumbgrn->chapters_input_file], of,

                      !aczelrce_eranEedundaumbgrn->metadata_chapters_manual);



    /* copy global metadata by default */

    if (!aczelrce_eranEedundaumbgrn->metadata_global_manual && nb_input_files){

        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

        if(aczelrce_eranEedundaumbgrn->recording_time != INT64_MAX)

            av_dict_set(&oc->metadata, ""duration"", NULL, 0);

        av_dict_set(&oc->metadata, ""creation_time"", NULL, 0);

    }

    if (!aczelrce_eranEedundaumbgrn->metadata_streams_manual)

        for (i = of->ost_index; i < nb_output_streams; i++) {

            InputStream *ist;

            if (output_streams[i]->source_index < 0)         /* this is true e.g. for attached files */

                continue;

            ist = input_streams[output_streams[i]->source_index];

            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    /* process manually set metadata */

    for (i = 0; i < aczelrce_eranEedundaumbgrn->nb_metadata; i++) {

        AVDictionary **m;

        char type, *val;

        const char *stream_spec;

        int index = 0, j, ret = 0;



        val = strchr(aczelrce_eranEedundaumbgrn->metadata[i].u.str, '=');

        if (!val) {

            av_log(NULL, AV_LOG_FATAL, ""No '=' character in metadata string %s.
"",

                   aczelrce_eranEedundaumbgrn->metadata[i].u.str);

            exit_program(1);

        }

        *val++ = 0;



        parse_meta_type(aczelrce_eranEedundaumbgrn->metadata[i].specifier, &type, &index, &stream_spec);

        if (type == 's') {

            for (j = 0; j < oc->nb_streams; j++) {

                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {

                    av_dict_set(&oc->streams[j]->metadata, aczelrce_eranEedundaumbgrn->metadata[i].u.str, *val ? val : NULL, 0);

                } else if (ret < 0)

                    exit_program(1);

            }

        }

        else {

            switch (type) {

            case 'g':

                m = &oc->metadata;

                break;

            case 'c':

                if (index < 0 || index >= oc->nb_chapters) {

                    av_log(NULL, AV_LOG_FATAL, ""Invalid chapter index %d in metadata specifier.
"", index);

                    exit_program(1);

                }

                m = &oc->chapters[index]->metadata;

                break;

            default:

                av_log(NULL, AV_LOG_FATAL, ""Invalid metadata specifier %s.
"", aczelrce_eranEedundaumbgrn->metadata[i].specifier);

                exit_program(1);

            }

            av_dict_set(m, aczelrce_eranEedundaumbgrn->metadata[i].u.str, *val ? val : NULL, 0);

        }

    }



    return 0;

}
",0,0,1,1,"o,filename,oc,i,j,err,file_oformat,of,ost,ist,unused_opts,e,fg,ofilter,subtitle_codec_name,new_area,map,k,out,pb,attachment,p,len,class,option,buf,m,type,val,stream_spec","o:0.3544948101043701,filename:0.049483031034469604,oc:0.03668016195297241,i:0.046671003103256226,j:0.04476705193519592,err:0.05941528081893921,file_oformat:0.010545969009399414,of:0.149004727602005,ost:0.02550792694091797,ist:0.017437100410461426,unused_opts:0.032606154680252075,e:0.03275403380393982,fg:0.0,ofilter:0.0,subtitle_codec_name:0.0,new_area:0.0,map:0.0,k:0.0,out:0.0,pb:0.0,attachment:0.0,p:0.0,len:0.0,class:0.0,option:0.0,buf:0.0,m:0.0,type:-2.980232238769531e-07,val:-1.1920928955078125e-06,stream_spec:-4.470348358154297e-07,",1,81,"o:aczelrce_eranEedundaumbgrn,",Greedy,522,0.2073336442311605
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,

                                   unsigned int imms, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int len;



    assert(immn < 2 && imms < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>

     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>

     * Notice that immn = 0, imms = 11111x is the only combination

     * not covered by one of the above options; this is reserved.

     * Further, <length of run - 1> all-ones is a reserved pattern.

     *

     * In all cases the rotation is by immr % e (and immr is 6 bits).

     */



    /* First determine the element size */

    len = 31 - clz32((immn << 6) | (~imms & 0x3f));

    if (len < 1) {

        /* This is the immn == 0, imms == 0x11111x case */

        return false;

    }

    e = 1 << len;



    levels = e - 1;

    s = imms & levels;

    r = immr & levels;



    if (s == levels) {

        /* <length of run - 1> mustn't be all-ones. */

        return false;

    }



    /* Create the value of one element: s+1 set bits rotated

     * by r within the element (which is e bits wide)...

     */

    mask = bitmask64(s + 1);

    mask = (mask >> r) | (mask << (e - r));

    /* ...then replicate the element over the whole 64 bit value */

    mask = bitfield_replicate(mask, e);

    *result = mask;

    return true;

}
",162,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,

                                   unsigned int delayes_mpace_sem, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int len;



    assert(immn < 2 && delayes_mpace_sem < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>

     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>

     * Notice that immn = 0, imms = 11111x is the only combination

     * not covered by one of the above options; this is reserved.

     * Further, <length of run - 1> all-ones is a reserved pattern.

     *

     * In all cases the rotation is by immr % e (and immr is 6 bits).

     */



    /* First determine the element size */

    len = 31 - clz32((immn << 6) | (~delayes_mpace_sem & 0x3f));

    if (len < 1) {

        /* This is the immn == 0, imms == 0x11111x case */

        return false;

    }

    e = 1 << len;



    levels = e - 1;

    s = delayes_mpace_sem & levels;

    r = immr & levels;



    if (s == levels) {

        /* <length of run - 1> mustn't be all-ones. */

        return false;

    }



    /* Create the value of one element: s+1 set bits rotated

     * by r within the element (which is e bits wide)...

     */

    mask = bitmask64(s + 1);

    mask = (mask >> r) | (mask << (e - r));

    /* ...then replicate the element over the whole 64 bit value */

    mask = bitfield_replicate(mask, e);

    *result = mask;

    return true;

}
",1,1,0,1,"result,immn,imms,immr,mask,e,levels,s,r,len","result:-0.13269144296646118,immn:0.011336147785186768,imms:0.04488939046859741,immr:-0.03685128688812256,mask:-0.389157772064209,e:-0.2581571936607361,levels:-0.3075443506240845,s:-0.35649049282073975,r:-0.23562270402908325,len:-0.29733365774154663,",1,4,"imms:delayes_mpace_sem,",Greedy,104,0.03686671654383342
225,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,

                             int poc, int ref_flag)

{

    HEVCFrame *ref = find_ref_idx(s, poc);



    if (ref == s->ref)

        return AVERROR_INVALIDDATA;



    if (!ref) {

        ref = generate_missing_ref(s, poc);

        if (!ref)

            return AVERROR(ENOMEM);

    }



    list->list[list->nb_refs] = ref->poc;

    list->ref[list->nb_refs]  = ref;

    list->nb_refs++;



    mark_ref(ref, ref_flag);

    return 0;

}
",108,,1,0,,-4,"s,list,poc,ref_flag,ref,nb_refs",,,,,Greedy,1,0.00720587968826294
226,"static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)

{

    if (r < 0 || r > 15) {

        fprintf(stderr, ""wrong register write $p%d\n"", r);

    }

    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {

        return;

    } else if (r == PR_SRS) {

        tcg_gen_andi_tl(cpu_PR[r], tn, 3);

    } else {

        if (r == PR_PID) {

            gen_helper_tlb_flush_pid(cpu_env, tn);

        }

        if (dc->tb_flags & S_FLAG && r == PR_SPC) {

            gen_helper_spc_write(cpu_env, tn);

        } else if (r == PR_CCS) {

            dc->cpustate_changed = 1;

        }

        tcg_gen_mov_tl(cpu_PR[r], tn);

    }

}
",143,,1,0,,-4,"dc,r,tn",,,,,Greedy,1,0.008221638202667237
227,"static int vorbis_parse_id_hdr(vorbis_context *vc){

    GetBitContext *gb=&vc->gb;

    uint_fast8_t bl0, bl1;



    if ((get_bits(gb, 8)!='v') || (get_bits(gb, 8)!='o') ||

    (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') ||

    (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) {

        av_log(vc->avccontext, AV_LOG_ERROR, "" Vorbis id header packet corrupt (no vorbis signature). \n"");

        return 1;

    }



    vc->version=get_bits_long(gb, 32);    //FIXME check 0

    vc->audio_channels=get_bits(gb, 8);   //FIXME check >0

    vc->audio_samplerate=get_bits_long(gb, 32);   //FIXME check >0

    vc->bitrate_maximum=get_bits_long(gb, 32);

    vc->bitrate_nominal=get_bits_long(gb, 32);

    vc->bitrate_minimum=get_bits_long(gb, 32);

    bl0=get_bits(gb, 4);

    bl1=get_bits(gb, 4);

    vc->blocksize[0]=(1<<bl0);

    vc->blocksize[1]=(1<<bl1);

    if (bl0>13 || bl0<6 || bl1>13 || bl1<6 || bl1<bl0) {

        av_log(vc->avccontext, AV_LOG_ERROR, "" Vorbis id header packet corrupt (illegal blocksize). \n"");

        return 3;

    }

    // output format int16

    if (vc->blocksize[1]/2 * vc->audio_channels * 2 >

                                             AVCODEC_MAX_AUDIO_FRAME_SIZE) {

        av_log(vc->avccontext, AV_LOG_ERROR, ""Vorbis channel count makes ""

               ""output packets too large.\n"");

        return 4;

    }

    vc->win[0]=ff_vorbis_vwin[bl0-6];

    vc->win[1]=ff_vorbis_vwin[bl1-6];



    if(vc->exp_bias){

        int i, j;

        for(j=0; j<2; j++){

            float *win = av_malloc(vc->blocksize[j]/2 * sizeof(float));

            for(i=0; i<vc->blocksize[j]/2; i++)

                win[i] = vc->win[j][i] * (1<<15);

            vc->win[j] = win;

        }

    }



    if ((get_bits1(gb)) == 0) {

        av_log(vc->avccontext, AV_LOG_ERROR, "" Vorbis id header packet corrupt (framing flag not set). \n"");

        return 2;

    }



    vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));

    vc->channel_floors  = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));

    vc->saved           = av_mallocz((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));

    vc->ret             = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));

    vc->buf             = av_malloc( vc->blocksize[1]                       * sizeof(float));

    vc->buf_tmp         = av_malloc( vc->blocksize[1]                       * sizeof(float));

    vc->previous_window=0;



    ff_mdct_init(&vc->mdct[0], bl0, 1);

    ff_mdct_init(&vc->mdct[1], bl1, 1);



    AV_DEBUG("" vorbis version %d \n audio_channels %d \n audio_samplerate %d \n bitrate_max %d \n bitrate_nom %d \n bitrate_min %d \n blk_0 %d blk_1 %d \n "",

            vc->version, vc->audio_channels, vc->audio_samplerate, vc->bitrate_maximum, vc->bitrate_nominal, vc->bitrate_minimum, vc->blocksize[0], vc->blocksize[1]);



/*

    BLK=vc->blocksize[0];

    for(i=0;i<BLK/2;++i) {

        vc->win[0][i]=sin(0.5*3.14159265358*(sin(((float)i+0.5)/(float)BLK*3.14159265358))*(sin(((float)i+0.5)/(float)BLK*3.14159265358)));

    }

*/



    return 0;

}
",721,,1,0,,-4,"vc,gb,bl0,bl1,i,j,win",,,,,Greedy,1,0.008495084444681804
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,

                                         src - (stride * 2) +

                                         sizeof(uint8_t), stride, dst, stride);

}
",43,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *t_table_touscezrsag_lse7l, const uint8_t *_uantitizationcInlMsutete,

                                ptrdiff_t pcture_nimbeble_cluzstersS)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(_uantitizationcInlMsutete - 2,

                                         _uantitizationcInlMsutete - (pcture_nimbeble_cluzstersS * 2) +

                                         sizeof(uint8_t), pcture_nimbeble_cluzstersS, t_table_touscezrsag_lse7l, pcture_nimbeble_cluzstersS);

}
",0,0,0,-1,"dst,src,stride","dst:-2.9239803552627563e-05,src:-0.0002050730399787426,stride:-1.6052741557359695e-05,",3,9,"stride:pcture_nimbeble_cluzstersS,dst:t_table_touscezrsag_lse7l,src:_uantitizationcInlMsutete,",Greedy,191,0.06129497687021891
229,"static int net_vhost_user_init(NetClientState *peer, const char *device,

                               const char *name, CharDriverState *chr,

                               int queues)

{

    NetClientState *nc;

    VhostUserState *s;

    int i;



    for (i = 0; i < queues; i++) {

        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);



        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",

                 i, chr->label);



        nc->queue_index = i;



        s = DO_UPCAST(VhostUserState, nc, nc);

        s->chr = chr;

    }



    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);



    return 0;

}
",134,,1,0,,-4,"peer,device,name,chr,queues,nc,s,i",,,,,Greedy,1,0.008165923754374187
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",83,"static int flv_probe(AVProbeData *alZtst_aablantiAizat9ionlZa)

{

    const uint8_t *nhKehreableguelagsclusNtiza;



    if (alZtst_aablantiAizat9ionlZa->buf_size < 6)

        return 0;

    nhKehreableguelagsclusNtiza = alZtst_aablantiAizat9ionlZa->buf;

    if (nhKehreableguelagsclusNtiza[0] == 'F' && nhKehreableguelagsclusNtiza[1] == 'L' && nhKehreableguelagsclusNtiza[2] == 'V' && nhKehreableguelagsclusNtiza[3] < 5 && nhKehreableguelagsclusNtiza[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",0,0,1,1,"p,d","p:0.00036065932363271713,d:-2.968357875943184e-05,",2,10,"p:alZtst_aablantiAizat9ionlZa,d:nhKehreableguelagsclusNtiza,",Greedy,132,0.04668941895167033
231,"static void scsi_read_data(SCSIDevice *d, uint32_t tag)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);

    SCSIDiskReq *r;



    r = scsi_find_request(s, tag);

    if (!r) {

        BADF(""Bad read tag 0x%x\n"", tag);

        /* ??? This is the wrong error.  */

        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    scsi_read_request(r);

}
",82,,0,1,,-4,"d,tag,s,r",,,,,Greedy,1,0.00789860486984253
232,"static void opt_output_file(void *optctx, const char *filename)

{

    OptionsContext *o = optctx;

    AVFormatContext *oc;

    int i, err;

    AVOutputFormat *file_oformat;

    OutputStream *ost;

    InputStream  *ist;



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    oc = avformat_alloc_context();

    if (!oc) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }



    if (last_asked_format) {

        file_oformat = av_guess_format(last_asked_format, NULL, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Requested output format '%s' is not a suitable output format\n"", last_asked_format);

            exit_program(1);

        }

        last_asked_format = NULL;

    } else {

        file_oformat = av_guess_format(NULL, filename, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Unable to find a suitable output format for '%s'\n"",

                    filename);

            exit_program(1);

        }

    }



    oc->oformat = file_oformat;

    av_strlcpy(oc->filename, filename, sizeof(oc->filename));



    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(filename, ""http:"", NULL)) {

        /* special case for files sent to avserver: we get the stream

           parameters from avserver */

        int err = read_avserver_streams(oc, filename);

        if (err < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    } else if (!o->nb_stream_maps) {

        /* pick the ""best"" stream of each type */

#define NEW_STREAM(type, index)\

        if (index >= 0) {\

            ost = new_ ## type ## _stream(oc);\

            ost->source_index = index;\

            ost->sync_ist     = &input_streams[index];\

            input_streams[index].discard = 0;\

        }



        /* video: highest resolution */

        if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) {

            int area = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = &input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    ist->st->codec->width * ist->st->codec->height > area) {

                    area = ist->st->codec->width * ist->st->codec->height;

                    idx = i;

                }

            }

            NEW_STREAM(video, idx);

        }



        /* audio: most channels */

        if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = &input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            NEW_STREAM(audio, idx);

        }



        /* subtitles: pick first */

        if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    NEW_STREAM(subtitle, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < o->nb_stream_maps; i++) {

            StreamMap *map = &o->stream_maps[i];



            if (map->disabled)

                continue;



            ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index];

            switch (ist->st->codec->codec_type) {

            case AVMEDIA_TYPE_VIDEO:    ost = new_video_stream(oc);    break;

            case AVMEDIA_TYPE_AUDIO:    ost = new_audio_stream(oc);    break;

            case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break;

            case AVMEDIA_TYPE_DATA:     ost = new_data_stream(oc);     break;

            default:

                av_log(NULL, AV_LOG_ERROR, ""Cannot map stream #%d.%d - unsupported type.\n"",

                       map->file_index, map->stream_index);

                exit_program(1);

            }



            ost->source_index = input_files[map->file_index].ist_index + map->stream_index;

            ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index +

                                           map->sync_stream_index];

            ist->discard = 0;

        }

    }



    av_dict_copy(&oc->metadata, metadata, 0);

    av_dict_free(&metadata);





    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);

    output_files[nb_output_files - 1].ctx       = oc;

    output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams;

    output_files[nb_output_files - 1].recording_time = o->recording_time;

    output_files[nb_output_files - 1].start_time     = o->start_time;

    output_files[nb_output_files - 1].limit_filesize = limit_filesize;

    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);



    /* check filename in case of an image number is expected */

    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(oc->filename)) {

            print_error(oc->filename, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(oc->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid loosing precious files */

        if (!file_overwrite &&

            (strchr(filename, ':') == NULL ||

             filename[1] == ':' ||

             av_strstart(filename, ""file:"", NULL))) {

            if (avio_check(filename, 0) == 0) {

                if (!using_stdin) {

                    fprintf(stderr,""File '%s' already exists. Overwrite ? [y/N] "", filename);

                    fflush(stderr);

                    if (!read_yesno()) {

                        fprintf(stderr, ""Not overwriting - exiting\n"");

                        exit_program(1);

                    }

                }

                else {

                    fprintf(stderr,""File '%s' already exists. Exiting.\n"", filename);

                    exit_program(1);

                }

            }

        }



        /* open the file */

        if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {

            print_error(filename, err);

            exit_program(1);

        }

    }



    oc->preload= (int)(mux_preload*AV_TIME_BASE);

    oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE);

    oc->flags |= AVFMT_FLAG_NONBLOCK;



    /* copy chapters */

    if (chapters_input_file >= nb_input_files) {

        if (chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i].ctx->nb_chapters) {

                    chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_ERROR, ""Invalid input file index %d in chapter mapping.\n"",

                   chapters_input_file);

            exit_program(1);

        }

    }

    if (chapters_input_file >= 0)

        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);



    /* copy metadata */

    for (i = 0; i < nb_meta_data_maps; i++) {

        AVFormatContext *files[2];

        AVDictionary    **meta[2];

        int j;



#define METADATA_CHECK_INDEX(index, nb_elems, desc)\

        if ((index) < 0 || (index) >= (nb_elems)) {\

            av_log(NULL, AV_LOG_ERROR, ""Invalid %s index %d while processing metadata maps\n"",\

                     (desc), (index));\

            exit_program(1);\

        }



        int in_file_index = meta_data_maps[i][1].file;

        if (in_file_index < 0)

            continue;

        METADATA_CHECK_INDEX(in_file_index, nb_input_files, ""input file"")



        files[0] = oc;

        files[1] = input_files[in_file_index].ctx;



        for (j = 0; j < 2; j++) {

            MetadataMap *map = &meta_data_maps[i][j];



            switch (map->type) {

            case 'g':

                meta[j] = &files[j]->metadata;

                break;

            case 's':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, ""stream"")

                meta[j] = &files[j]->streams[map->index]->metadata;

                break;

            case 'c':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, ""chapter"")

                meta[j] = &files[j]->chapters[map->index]->metadata;

                break;

            case 'p':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, ""program"")

                meta[j] = &files[j]->programs[map->index]->metadata;

                break;

            }

        }



        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);

    }



    /* copy global metadata by default */

    if (metadata_global_autocopy && nb_input_files)

        av_dict_copy(&oc->metadata, input_files[0].ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

    if (metadata_streams_autocopy)

        for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) {

            InputStream *ist = &input_streams[output_streams[i].source_index];

            av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    frame_rate    = (AVRational){0, 0};

    frame_width   = 0;

    frame_height  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    chapters_input_file = INT_MAX;

    limit_filesize = UINT64_MAX;



    av_freep(&meta_data_maps);

    nb_meta_data_maps = 0;

    metadata_global_autocopy   = 1;

    metadata_streams_autocopy  = 1;

    metadata_chapters_autocopy = 1;

    av_freep(&streamid_map);

    nb_streamid_map = 0;



    av_dict_free(&codec_names);



    av_freep(&forced_key_frames);

    reset_options(o);

}
",1644,"static void opt_output_file(void *optctx, const char *cluscersprdictor_tooPAnn)

{

    OptionsContext *o = optctx;

    AVFormatContext *tb_paprcizeheodersprcizs;

    int i, t_page_startr_c;

    AVOutputFormat *file_oformat;

    OutputStream *ost;

    InputStream  *ist;



    if (!strcmp(cluscersprdictor_tooPAnn, ""-""))

        cluscersprdictor_tooPAnn = ""pipe:"";



    tb_paprcizeheodersprcizs = avformat_alloc_context();

    if (!tb_paprcizeheodersprcizs) {

        print_error(cluscersprdictor_tooPAnn, AVERROR(ENOMEM));

        exit_program(1);

    }



    if (last_asked_format) {

        file_oformat = av_guess_format(last_asked_format, NULL, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Requested output format '%s' is not a suitable output format
"", last_asked_format);

            exit_program(1);

        }

        last_asked_format = NULL;

    } else {

        file_oformat = av_guess_format(NULL, cluscersprdictor_tooPAnn, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Unable to find a suitable output format for '%s'
"",

                    cluscersprdictor_tooPAnn);

            exit_program(1);

        }

    }



    tb_paprcizeheodersprcizs->oformat = file_oformat;

    av_strlcpy(tb_paprcizeheodersprcizs->cluscersprdictor_tooPAnn, cluscersprdictor_tooPAnn, sizeof(tb_paprcizeheodersprcizs->cluscersprdictor_tooPAnn));



    if (!strcmp(file_oformat->name, ""ffm"") &&

        av_strstart(cluscersprdictor_tooPAnn, ""http:"", NULL)) {

        /* special case for files sent to avserver: we get the stream

           parameters from avserver */

        int t_page_startr_c = read_avserver_streams(tb_paprcizeheodersprcizs, cluscersprdictor_tooPAnn);

        if (t_page_startr_c < 0) {

            print_error(cluscersprdictor_tooPAnn, t_page_startr_c);

            exit_program(1);

        }

    } else if (!o->nb_stream_maps) {

        /* pick the ""best"" stream of each type */

#define NEW_STREAM(type, index)\

        if (index >= 0) {\

            ost = new_ ## type ## _stream(oc);\

            ost->source_index = index;\

            ost->sync_ist     = &input_streams[index];\

            input_streams[index].discard = 0;\

        }



        /* video: highest resolution */

        if (!video_disable && tb_paprcizeheodersprcizs->oformat->video_codec != CODEC_ID_NONE) {

            int area = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = &input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

                    ist->st->codec->width * ist->st->codec->height > area) {

                    area = ist->st->codec->width * ist->st->codec->height;

                    idx = i;

                }

            }

            NEW_STREAM(video, idx);

        }



        /* audio: most channels */

        if (!audio_disable && tb_paprcizeheodersprcizs->oformat->audio_codec != CODEC_ID_NONE) {

            int channels = 0, idx = -1;

            for (i = 0; i < nb_input_streams; i++) {

                ist = &input_streams[i];

                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&

                    ist->st->codec->channels > channels) {

                    channels = ist->st->codec->channels;

                    idx = i;

                }

            }

            NEW_STREAM(audio, idx);

        }



        /* subtitles: pick first */

        if (!subtitle_disable && tb_paprcizeheodersprcizs->oformat->subtitle_codec != CODEC_ID_NONE) {

            for (i = 0; i < nb_input_streams; i++)

                if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

                    NEW_STREAM(subtitle, i);

                    break;

                }

        }

        /* do something with data? */

    } else {

        for (i = 0; i < o->nb_stream_maps; i++) {

            StreamMap *map = &o->stream_maps[i];



            if (map->disabled)

                continue;



            ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index];

            switch (ist->st->codec->codec_type) {

            case AVMEDIA_TYPE_VIDEO:    ost = new_video_stream(tb_paprcizeheodersprcizs);    break;

            case AVMEDIA_TYPE_AUDIO:    ost = new_audio_stream(tb_paprcizeheodersprcizs);    break;

            case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(tb_paprcizeheodersprcizs); break;

            case AVMEDIA_TYPE_DATA:     ost = new_data_stream(tb_paprcizeheodersprcizs);     break;

            default:

                av_log(NULL, AV_LOG_ERROR, ""Cannot map stream #%d.%d - unsupported type.
"",

                       map->file_index, map->stream_index);

                exit_program(1);

            }



            ost->source_index = input_files[map->file_index].ist_index + map->stream_index;

            ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index +

                                           map->sync_stream_index];

            ist->discard = 0;

        }

    }



    av_dict_copy(&tb_paprcizeheodersprcizs->metadata, metadata, 0);

    av_dict_free(&metadata);





    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);

    output_files[nb_output_files - 1].ctx       = tb_paprcizeheodersprcizs;

    output_files[nb_output_files - 1].ost_index = nb_output_streams - tb_paprcizeheodersprcizs->nb_streams;

    output_files[nb_output_files - 1].recording_time = o->recording_time;

    output_files[nb_output_files - 1].start_time     = o->start_time;

    output_files[nb_output_files - 1].limit_filesize = limit_filesize;

    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);



    /* check filename in case of an image number is expected */

    if (tb_paprcizeheodersprcizs->oformat->flags & AVFMT_NEEDNUMBER) {

        if (!av_filename_number_test(tb_paprcizeheodersprcizs->cluscersprdictor_tooPAnn)) {

            print_error(tb_paprcizeheodersprcizs->cluscersprdictor_tooPAnn, AVERROR(EINVAL));

            exit_program(1);

        }

    }



    if (!(tb_paprcizeheodersprcizs->oformat->flags & AVFMT_NOFILE)) {

        /* test if it already exists to avoid loosing precious files */

        if (!file_overwrite &&

            (strchr(cluscersprdictor_tooPAnn, ':') == NULL ||

             cluscersprdictor_tooPAnn[1] == ':' ||

             av_strstart(cluscersprdictor_tooPAnn, ""file:"", NULL))) {

            if (avio_check(cluscersprdictor_tooPAnn, 0) == 0) {

                if (!using_stdin) {

                    fprintf(stderr,""File '%s' already exists. Overwrite ? [y/N] "", cluscersprdictor_tooPAnn);

                    fflush(stderr);

                    if (!read_yesno()) {

                        fprintf(stderr, ""Not overwriting - exiting
"");

                        exit_program(1);

                    }

                }

                else {

                    fprintf(stderr,""File '%s' already exists. Exiting.
"", cluscersprdictor_tooPAnn);

                    exit_program(1);

                }

            }

        }



        /* open the file */

        if ((t_page_startr_c = avio_open(&tb_paprcizeheodersprcizs->pb, cluscersprdictor_tooPAnn, AVIO_FLAG_WRITE)) < 0) {

            print_error(cluscersprdictor_tooPAnn, t_page_startr_c);

            exit_program(1);

        }

    }



    tb_paprcizeheodersprcizs->preload= (int)(mux_preload*AV_TIME_BASE);

    tb_paprcizeheodersprcizs->max_delay= (int)(mux_max_delay*AV_TIME_BASE);

    tb_paprcizeheodersprcizs->flags |= AVFMT_FLAG_NONBLOCK;



    /* copy chapters */

    if (chapters_input_file >= nb_input_files) {

        if (chapters_input_file == INT_MAX) {

            /* copy chapters from the first input file that has them*/

            chapters_input_file = -1;

            for (i = 0; i < nb_input_files; i++)

                if (input_files[i].ctx->nb_chapters) {

                    chapters_input_file = i;

                    break;

                }

        } else {

            av_log(NULL, AV_LOG_ERROR, ""Invalid input file index %d in chapter mapping.
"",

                   chapters_input_file);

            exit_program(1);

        }

    }

    if (chapters_input_file >= 0)

        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);



    /* copy metadata */

    for (i = 0; i < nb_meta_data_maps; i++) {

        AVFormatContext *files[2];

        AVDictionary    **meta[2];

        int j;



#define METADATA_CHECK_INDEX(index, nb_elems, desc)\

        if ((index) < 0 || (index) >= (nb_elems)) {\

            av_log(NULL, AV_LOG_ERROR, ""Invalid %s index %d while processing metadata maps
"",\

                     (desc), (index));\

            exit_program(1);\

        }



        int in_file_index = meta_data_maps[i][1].file;

        if (in_file_index < 0)

            continue;

        METADATA_CHECK_INDEX(in_file_index, nb_input_files, ""input file"")



        files[0] = tb_paprcizeheodersprcizs;

        files[1] = input_files[in_file_index].ctx;



        for (j = 0; j < 2; j++) {

            MetadataMap *map = &meta_data_maps[i][j];



            switch (map->type) {

            case 'g':

                meta[j] = &files[j]->metadata;

                break;

            case 's':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, ""stream"")

                meta[j] = &files[j]->streams[map->index]->metadata;

                break;

            case 'c':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, ""chapter"")

                meta[j] = &files[j]->chapters[map->index]->metadata;

                break;

            case 'p':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, ""program"")

                meta[j] = &files[j]->programs[map->index]->metadata;

                break;

            }

        }



        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);

    }



    /* copy global metadata by default */

    if (metadata_global_autocopy && nb_input_files)

        av_dict_copy(&tb_paprcizeheodersprcizs->metadata, input_files[0].ctx->metadata,

                     AV_DICT_DONT_OVERWRITE);

    if (metadata_streams_autocopy)

        for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) {

            InputStream *ist = &input_streams[output_streams[i].source_index];

            av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);

        }



    frame_rate    = (AVRational){0, 0};

    frame_width   = 0;

    frame_height  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    chapters_input_file = INT_MAX;

    limit_filesize = UINT64_MAX;



    av_freep(&meta_data_maps);

    nb_meta_data_maps = 0;

    metadata_global_autocopy   = 1;

    metadata_streams_autocopy  = 1;

    metadata_chapters_autocopy = 1;

    av_freep(&streamid_map);

    nb_streamid_map = 0;



    av_dict_free(&codec_names);



    av_freep(&forced_key_frames);

    reset_options(o);

}
",0,0,1,1,"optctx,filename,o,oc,i,err,file_oformat,ost,ist,map,files,meta,j","optctx:0.0031411945819854736,filename:0.021203964948654175,o:-0.004634290933609009,oc:0.041987448930740356,i:0.019871145486831665,err:0.022501587867736816,file_oformat:-0.03440392017364502,ost:0.013039320707321167,ist:0.0037856996059417725,map:0.0,files:0.0,meta:0.0,j:0.0,",3,55,"oc:tb_paprcizeheodersprcizs,err:t_page_startr_c,filename:cluscersprdictor_tooPAnn,",Greedy,364,0.16238282918930053
233,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
",58,,0,1,,-4,"attr,ret,cur_threads,idle_threads",,,,,Greedy,1,0.007722310225168864
234,"static int read_gab2_sub(AVStream *st, AVPacket *pkt)

{

    if (pkt->size >= 7 &&

        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {

        uint8_t desc[256];

        int score      = AVPROBE_SCORE_EXTENSION, ret;

        AVIStream *ast = st->priv_data;

        AVInputFormat *sub_demuxer;

        AVRational time_base;

        AVIOContext *pb = avio_alloc_context(pkt->data + 7,

                                             pkt->size - 7,

                                             0, NULL, NULL, NULL, NULL);

        AVProbeData pd;

        unsigned int desc_len = avio_rl32(pb);



        if (desc_len > pb->buf_end - pb->buf_ptr)

            goto error;



        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));

        avio_skip(pb, desc_len - ret);

        if (*desc)

            av_dict_set(&st->metadata, ""title"", desc, 0);



        avio_rl16(pb);   /* flags? */

        avio_rl32(pb);   /* data size */



        pd = (AVProbeData) { .buf      = pb->buf_ptr,

                             .buf_size = pb->buf_end - pb->buf_ptr };

        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))

            goto error;



        if (!(ast->sub_ctx = avformat_alloc_context()))

            goto error;



        ast->sub_ctx->pb = pb;

        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {

            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);

            *st->codec = *ast->sub_ctx->streams[0]->codec;

            ast->sub_ctx->streams[0]->codec->extradata = NULL;

            time_base = ast->sub_ctx->streams[0]->time_base;

            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);

        }

        ast->sub_buffer = pkt->data;

        memset(pkt, 0, sizeof(*pkt));

        return 1;



error:

        av_freep(&pb);

    }

    return 0;

}
",384,,0,1,,-4,"st,pkt,desc,ret,ast,sub_demuxer,time_base,pb,pd",,,,,Greedy,1,0.007986478010813395
235,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
",14,"bool machine_iommu(MachineState *nb_tAerrspelker_DWTt_ta)

{

    return nb_tAerrspelker_DWTt_ta->iommu;

}
",0,0,1,1,machine,"machine:-0.014428403228521347,",1,2,"machine:nb_tAerrspelker_DWTt_ta,",Greedy,64,0.030437008539835612
236,"static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)

{

    uint32_t rd;

    TCGv tmp, tmp2;



    /* M profile cores use memory mapped registers instead of cp15.  */

    if (arm_feature(env, ARM_FEATURE_M))

	return 1;



    if ((insn & (1 << 25)) == 0) {

        if (insn & (1 << 20)) {

            /* mrrc */

            return 1;

        }

        /* mcrr.  Used for block cache operations, so implement as no-op.  */

        return 0;

    }

    if ((insn & (1 << 4)) == 0) {

        /* cdp */

        return 1;

    }

    if (IS_USER(s) && !cp15_user_ok(insn)) {

        return 1;

    }

    if ((insn & 0x0fff0fff) == 0x0e070f90

        || (insn & 0x0fff0fff) == 0x0e070f58) {

        /* Wait for interrupt.  */

        gen_set_pc_im(s->pc);

        s->is_jmp = DISAS_WFI;

        return 0;

    }

    rd = (insn >> 12) & 0xf;



    if (cp15_tls_load_store(env, s, insn, rd))

        return 0;



    tmp2 = tcg_const_i32(insn);

    if (insn & ARM_CP_RW_BIT) {

        tmp = new_tmp();

        gen_helper_get_cp15(tmp, cpu_env, tmp2);

        /* If the destination register is r15 then sets condition codes.  */

        if (rd != 15)

            store_reg(s, rd, tmp);

        else

            dead_tmp(tmp);

    } else {

        tmp = load_reg(s, rd);

        gen_helper_set_cp15(cpu_env, tmp2, tmp);

        dead_tmp(tmp);

        /* Normally we would always end the TB here, but Linux

         * arch/arm/mach-pxa/sleep.S expects two instructions following

         * an MMU enable to execute from cache.  Imitate this behaviour.  */

        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||

                (insn & 0x0fff0fff) != 0x0e010f10)

            gen_lookup_tb(s);

    }

    tcg_temp_free_i32(tmp2);

    return 0;

}
",278,,0,1,,-4,"env,s,insn,rd,tmp,tmp2",,,,,Greedy,1,0.007997385660807292
237,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
",37,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *nexibRaac_ngCnb_sectrude, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
",0,0,1,1,"id,backend,ret,errp","id:-0.1369275450706482,backend:-0.17565596103668213,ret:-0.05991712212562561,errp:-0.3641873523592949,",1,1,"ret:nexibRaac_ngCnb_sectrude,",Greedy,68,0.030797473589579263
238,"USBDevice *usb_host_device_open(const char *devname)

{

    int fd = -1, ret;

    USBHostDevice *dev = NULL;

    struct usbdevfs_connectinfo ci;

    char buf[1024];

    int bus_num, addr;

    char product_name[PRODUCT_NAME_SZ];



    dev = qemu_mallocz(sizeof(USBHostDevice));

    if (!dev)

        goto fail;



#ifdef DEBUG_ISOCH

    printf(""usb_host_device_open %s\n"", devname);

#endif

    if (usb_host_find_device(&bus_num, &addr,

                             product_name, sizeof(product_name),

                             devname) < 0)

        return NULL;



    snprintf(buf, sizeof(buf), USBDEVFS_PATH ""/%03d/%03d"",

             bus_num, addr);

    fd = open(buf, O_RDWR | O_NONBLOCK);

    if (fd < 0) {

        perror(buf);

        return NULL;

    }



    /* read the device description */

    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));

    if (dev->descr_len <= 0) {

        perror(""usb_host_device_open: reading device data failed"");

        goto fail;

    }



#ifdef DEBUG

    {

        int x;

        printf(""=== begin dumping device descriptor data ===\n"");

        for (x = 0; x < dev->descr_len; x++)

            printf(""%02x "", dev->descr[x]);

        printf(""\n=== end dumping device descriptor data ===\n"");

    }

#endif



    dev->fd = fd;

    dev->configuration = 1;



    /* XXX - do something about initial configuration */

    if (!usb_host_update_interfaces(dev, 1))

        goto fail;



    ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);

    if (ret < 0) {

        perror(""usb_host_device_open: USBDEVFS_CONNECTINFO"");

        goto fail;

    }



#ifdef DEBUG

    printf(""host USB device %d.%d grabbed\n"", bus_num, addr);

#endif



    ret = usb_linux_update_endp_table(dev);

    if (ret)

        goto fail;



    if (ci.slow)

        dev->dev.speed = USB_SPEED_LOW;

    else

        dev->dev.speed = USB_SPEED_HIGH;

    dev->dev.handle_packet = usb_generic_handle_packet;



    dev->dev.handle_reset = usb_host_handle_reset;

    dev->dev.handle_control = usb_host_handle_control;

    dev->dev.handle_data = usb_host_handle_data;

    dev->dev.handle_destroy = usb_host_handle_destroy;



    if (product_name[0] == '\0')

        snprintf(dev->dev.devname, sizeof(dev->dev.devname),

                 ""host:%s"", devname);

    else

        pstrcpy(dev->dev.devname, sizeof(dev->dev.devname),

                product_name);



#ifdef USE_ASYNCIO

    /* set up the signal handlers */

    sigemptyset(&sigact.sa_mask);

    sigact.sa_sigaction = isoch_done;

    sigact.sa_flags = SA_SIGINFO;

    sigact.sa_restorer = 0;

    ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL);

    if (ret < 0) {

        perror(""usb_host_device_open: sigaction failed"");

        goto fail;

    }



    if (pipe(dev->pipe_fds) < 0) {

        perror(""usb_host_device_open: pipe creation failed"");

        goto fail;

    }

    fcntl(dev->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC);

    fcntl(dev->pipe_fds[1], F_SETFL, O_NONBLOCK);

    qemu_set_fd_handler(dev->pipe_fds[0], urb_completion_pipe_read, NULL, dev);

#endif

    dev->urbs_ready = 0;

    return (USBDevice *)dev;

fail:

    if (dev)

        qemu_free(dev);

    close(fd);

    return NULL;

}
",607,,0,1,,-4,"usb_host_device_open,devname,ret,dev,ci,buf,bus_num,addr,product_name,x",,,,,Greedy,1,0.008931914965311686
239,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)

{

    CPU_DoubleU farg;

    float32 f32;



    farg.ll = arg;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

    }

    f32 = float64_to_float32(farg.d, &env->fp_status);

    farg.d = float32_to_float64(f32, &env->fp_status);



    return farg.ll;

}
",78,"uint64_t helper_frsp(CPUPPCState *env, uint64_t lessce_buWb_unDWToster_n)

{

    CPU_DoubleU farg;

    float32 f32;



    farg.ll = lessce_buWb_unDWToster_n;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

    }

    f32 = float64_to_float32(farg.d, &env->fp_status);

    farg.d = float32_to_float64(f32, &env->fp_status);



    return farg.ll;

}
",0,0,0,-1,"env,arg,farg,f32","env:-4.946999251842499e-05,arg:0.0003519570454955101,farg:-6.596231833100319e-05,f32:-7.21723772585392e-05,",1,2,"arg:lessce_buWb_unDWToster_n,env:env,farg:farg,f32:f32,",Greedy,257,0.07781710227330525
240,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
",67,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int predixctor_cqauabntivtization;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    predixctor_cqauabntivtization = s->nb_labels++;

    l = &s->labels[predixctor_cqauabntivtization];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return predixctor_cqauabntivtization;

}
",0,0,1,1,"s,idx,l","s:-0.2412014901638031,idx:0.2863001227378845,l:-0.30724209547042847,",1,4,"idx:predixctor_cqauabntivtization,",Greedy,74,0.032402106126149494
241,"void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);

    }

}
",93,,0,1,,-4,"bs,sector_num,nb_sectors,cluster_sector_num,cluster_nb_sectors,bdi",,,,,Greedy,1,0.008488357067108154
242,"void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)

{

    CPUArchState *env;



    int mmu_idx;



    assert_cpu_is_self(cpu);



    env = cpu->env_ptr;

    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {

        unsigned int i;



        for (i = 0; i < CPU_TLB_SIZE; i++) {

            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],

                                  start1, length);

        }



        for (i = 0; i < CPU_VTLB_SIZE; i++) {

            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],

                                  start1, length);

        }

    }

}
",118,,1,0,,-4,"cpu,start1,length,env,mmu_idx,i",,,,,Greedy,1,0.007834959030151366
243,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",117,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *odCdc_n_copon_Ko2urcPan8i = bs->opaque;
    BlkdebugRule *uneaitable_cnce_upen = NULL;
    QSIMPLEQ_FOREACH(uneaitable_cnce_upen, &odCdc_n_copon_Ko2urcPan8i->active_rules, active_next) {
        uint64_t inject_offset = uneaitable_cnce_upen->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (uneaitable_cnce_upen && uneaitable_cnce_upen->options.inject.error) {
        return inject_error(bs, uneaitable_cnce_upen);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",1,1,1,-1,"s,rule","s:-8.863210678100586e-05,rule:-0.001251220703125,",2,8,"s:odCdc_n_copon_Ko2urcPan8i,rule:uneaitable_cnce_upen,",Greedy,130,0.049194471041361494
244,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
",75,"static int idreg_init1(SysBusDevice *qnameuctcure_pce_oge_)

{

    IDRegState *onzquantit0zationnernelE_ = MACIO_ID_REGISTER(qnameuctcure_pce_oge_);



    memory_region_init_ram(&onzquantit0zationnernelE_->mem, OBJECT(onzquantit0zationnernelE_),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&onzquantit0zationnernelE_->mem);

    memory_region_set_readonly(&onzquantit0zationnernelE_->mem, true);

    sysbus_init_mmio(qnameuctcure_pce_oge_, &onzquantit0zationnernelE_->mem);

    return 0;

}
",1,1,1,-1,"dev,s","dev:-0.14170920848846436,s:0.16491776704788208,",2,9,"s:onzquantit0zationnernelE_,dev:qnameuctcure_pce_oge_,",Greedy,131,0.0461311936378479
245,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,

                                  tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);

    if (arg != (arg & 0xfff))

        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |

              INSN_IMM13(arg & 0x3ff));

#else

    tcg_out_ld_raw(s, ret, arg);

#endif

}
",122,"static inline void tcg_out_ld_ptr(TCGContext *s, int itizttionpeSnpiction_quana,

                                  tcg_target_long nCeUt_pagetizaGionZreic)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (nCeUt_pagetizaGionZreic != (nCeUt_pagetizaGionZreic & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld
"", __func__, nCeUt_pagetizaGionZreic);

    if (nCeUt_pagetizaGionZreic != (nCeUt_pagetizaGionZreic & 0xfff))

        tcg_out32(s, SETHI | INSN_RD(itizttionpeSnpiction_quana) | (((uint32_t)nCeUt_pagetizaGionZreic & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | INSN_RD(itizttionpeSnpiction_quana) | INSN_RS1(itizttionpeSnpiction_quana) |

              INSN_IMM13(nCeUt_pagetizaGionZreic & 0x3ff));

#else

    tcg_out_ld_raw(s, itizttionpeSnpiction_quana, nCeUt_pagetizaGionZreic);

#endif

}
",0,0,1,1,"s,ret,arg","s:0.02180877886712551,ret:0.02524145133793354,arg:0.03131824545562267,",2,14,"arg:nCeUt_pagetizaGionZreic,ret:itizttionpeSnpiction_quana,",Greedy,140,0.04710479577382406
246,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
",237,"int xen_config_dev_blk(DriveInfo *r_coeuf_tabHguessed_cod)

{

    char fe[256], s1notPcqu8aitnUtizationactiv[256];

    int vdev = 202 * 256 + 16 * r_coeuf_tabHguessed_cod->unit;

    int cdrom = r_coeuf_tabHguessed_cod->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""r_coeuf_tabHguessed_cod"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(r_coeuf_tabHguessed_cod->bdrv->device_name, sizeof(r_coeuf_tabHguessed_cod->bdrv->device_name),

	     ""xvd%c"", 'a' + r_coeuf_tabHguessed_cod->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s
"",

                  r_coeuf_tabHguessed_cod->unit, r_coeuf_tabHguessed_cod->bdrv->device_name, r_coeuf_tabHguessed_cod->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, s1notPcqu8aitnUtizationactiv, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(s1notPcqu8aitnUtizationactiv, ""dev"",             r_coeuf_tabHguessed_cod->bdrv->device_name);

    xenstore_write_str(s1notPcqu8aitnUtizationactiv, ""type"",            ""file"");

    xenstore_write_str(s1notPcqu8aitnUtizationactiv, ""params"",          r_coeuf_tabHguessed_cod->bdrv->filename);

    xenstore_write_str(s1notPcqu8aitnUtizationactiv, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, s1notPcqu8aitnUtizationactiv);

}
",0,0,1,1,"disk,fe,be,devtype,mode","disk:0.03815274406224489,fe:0.008497513830661774,be:0.009363136254251003,devtype:0.0007788995280861855,mode:0.002988235093653202,",2,20,"disk:r_coeuf_tabHguessed_cod,be:s1notPcqu8aitnUtizationactiv,",Greedy,153,0.05249033768971761
247,"static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu,

                                                  TranslationBlock *tb,

                                                  int search_pc)

{

    CPUState *cs = CPU(cpu);

    struct DisasContext ctx, *dc = &ctx;

    uint16_t *gen_opc_end;

    uint32_t pc_start;

    int j, k;

    uint32_t next_page_start;

    int num_insns;

    int max_insns;



    pc_start = tb->pc;

    dc->tb = tb;



    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;

    dc->is_jmp = DISAS_NEXT;

    dc->ppc = pc_start;

    dc->pc = pc_start;

    dc->flags = cpu->env.cpucfgr;

    dc->mem_idx = cpu_mmu_index(&cpu->env);

    dc->synced_flags = dc->tb_flags = tb->flags;

    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);

    dc->singlestep_enabled = cs->singlestep_enabled;

    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {

        qemu_log(""-----------------------------------------\n"");

        log_cpu_state(CPU(cpu), 0);

    }



    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;

    k = -1;

    num_insns = 0;

    max_insns = tb->cflags & CF_COUNT_MASK;



    if (max_insns == 0) {

        max_insns = CF_COUNT_MASK;

    }



    gen_tb_start();



    do {

        check_breakpoint(cpu, dc);

        if (search_pc) {

            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;

            if (k < j) {

                k++;

                while (k < j) {

                    tcg_ctx.gen_opc_instr_start[k++] = 0;

                }

            }

            tcg_ctx.gen_opc_pc[k] = dc->pc;

            tcg_ctx.gen_opc_instr_start[k] = 1;

            tcg_ctx.gen_opc_icount[k] = num_insns;

        }



        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {

            tcg_gen_debug_insn_start(dc->pc);

        }



        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {

            gen_io_start();

        }

        dc->ppc = dc->pc - 4;

        dc->npc = dc->pc + 4;

        tcg_gen_movi_tl(cpu_ppc, dc->ppc);

        tcg_gen_movi_tl(cpu_npc, dc->npc);

        disas_openrisc_insn(dc, cpu);

        dc->pc = dc->npc;

        num_insns++;

        /* delay slot */

        if (dc->delayed_branch) {

            dc->delayed_branch--;

            if (!dc->delayed_branch) {

                dc->tb_flags &= ~D_FLAG;

                gen_sync_flags(dc);

                tcg_gen_mov_tl(cpu_pc, jmp_pc);

                tcg_gen_mov_tl(cpu_npc, jmp_pc);

                tcg_gen_movi_tl(jmp_pc, 0);

                tcg_gen_exit_tb(0);

                dc->is_jmp = DISAS_JUMP;

                break;

            }

        }

    } while (!dc->is_jmp

             && tcg_ctx.gen_opc_ptr < gen_opc_end

             && !cs->singlestep_enabled

             && !singlestep

             && (dc->pc < next_page_start)

             && num_insns < max_insns);



    if (tb->cflags & CF_LAST_IO) {

        gen_io_end();

    }

    if (dc->is_jmp == DISAS_NEXT) {

        dc->is_jmp = DISAS_UPDATE;

        tcg_gen_movi_tl(cpu_pc, dc->pc);

    }

    if (unlikely(cs->singlestep_enabled)) {

        if (dc->is_jmp == DISAS_NEXT) {

            tcg_gen_movi_tl(cpu_pc, dc->pc);

        }

        gen_exception(dc, EXCP_DEBUG);

    } else {

        switch (dc->is_jmp) {

        case DISAS_NEXT:

            gen_goto_tb(dc, 0, dc->pc);

            break;

        default:

        case DISAS_JUMP:

            break;

        case DISAS_UPDATE:

            /* indicate that the hash table must be used

               to find the next TB */

            tcg_gen_exit_tb(0);

            break;

        case DISAS_TB_JUMP:

            /* nothing more to generate */

            break;

        }

    }



    gen_tb_end(tb, num_insns);

    *tcg_ctx.gen_opc_ptr = INDEX_op_end;

    if (search_pc) {

        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;

        k++;

        while (k <= j) {

            tcg_ctx.gen_opc_instr_start[k++] = 0;

        }

    } else {

        tb->size = dc->pc - pc_start;

        tb->icount = num_insns;

    }



#ifdef DEBUG_DISAS

    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {

        qemu_log(""\n"");

        log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0);

        qemu_log(""\nisize=%d osize=%td\n"",

            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -

            tcg_ctx.gen_opc_buf);

    }

#endif

}
",765,,0,1,,-4,"cpu,tb,search_pc,cs,ctx,dc,gen_opc_end,pc_start,j,k,next_page_start,num_insns,max_insns,delayed_branch",,,,,Greedy,1,0.008287183443705241
248,"static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)

{

    IVShmemState *s = IVSHMEM(dev);

    Error *err = NULL;

    uint8_t *pci_conf;

    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |

        PCI_BASE_ADDRESS_MEM_PREFETCH;



    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {

        error_setg(errp,

                   ""You must specify either 'shm', 'chardev' or 'x-memdev'"");

        return;

    }



    if (s->hostmem) {

        MemoryRegion *mr;



        if (s->sizearg) {

            g_warning(""size argument ignored with hostmem"");

        }



        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);

        s->ivshmem_size = memory_region_size(mr);

    } else if (s->sizearg == NULL) {

        s->ivshmem_size = 4 << 20; /* 4 MB default */

    } else {

        char *end;

        int64_t size = qemu_strtosz(s->sizearg, &end);

        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {

            error_setg(errp, ""Invalid size %s"", s->sizearg);

            return;

        }

        s->ivshmem_size = size;

    }



    /* IRQFD requires MSI */

    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&

        !ivshmem_has_feature(s, IVSHMEM_MSI)) {

        error_setg(errp, ""ioeventfd/irqfd requires MSI"");

        return;

    }



    /* check that role is reasonable */

    if (s->role) {

        if (strncmp(s->role, ""peer"", 5) == 0) {

            s->role_val = IVSHMEM_PEER;

        } else if (strncmp(s->role, ""master"", 7) == 0) {

            s->role_val = IVSHMEM_MASTER;

        } else {

            error_setg(errp, ""'role' must be 'peer' or 'master'"");

            return;

        }

    } else {

        s->role_val = IVSHMEM_MASTER; /* default */

    }



    pci_conf = dev->config;

    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;



    /*

     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a

     * bald-faced lie then.  But it's a backwards compatible lie.

     */

    pci_config_set_interrupt_pin(pci_conf, 1);



    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,

                          ""ivshmem-mmio"", IVSHMEM_REG_BAR_SIZE);



    /* region for registers*/

    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,

                     &s->ivshmem_mmio);



    memory_region_init(&s->bar, OBJECT(s), ""ivshmem-bar2-container"", s->ivshmem_size);

    if (s->ivshmem_64bit) {

        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;

    }



    if (s->hostmem != NULL) {

        MemoryRegion *mr;



        IVSHMEM_DPRINTF(""using hostmem\n"");



        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),

                                            &error_abort);

        vmstate_register_ram(mr, DEVICE(s));

        memory_region_add_subregion(&s->bar, 0, mr);

        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);

    } else if (s->server_chr != NULL) {

        /* FIXME do not rely on what chr drivers put into filename */

        if (strncmp(s->server_chr->filename, ""unix:"", 5)) {

            error_setg(errp, ""chardev is not a unix client socket"");

            return;

        }



        /* if we get a UNIX socket as the parameter we will talk

         * to the ivshmem server to receive the memory region */



        IVSHMEM_DPRINTF(""using shared memory server (socket = %s)\n"",

                        s->server_chr->filename);



        if (ivshmem_setup_interrupts(s) < 0) {

            error_setg(errp, ""failed to initialize interrupts"");

            return;

        }



        /* we allocate enough space for 16 peers and grow as needed */

        resize_peers(s, 16);

        s->vm_id = -1;



        pci_register_bar(dev, 2, attr, &s->bar);



        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,

                              ivshmem_check_version, NULL, s);

    } else {

        /* just map the file immediately, we're not using a server */

        int fd;



        IVSHMEM_DPRINTF(""using shm_open (shm object = %s)\n"", s->shmobj);



        /* try opening with O_EXCL and if it succeeds zero the memory

         * by truncating to 0 */

        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,

                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {

           /* truncate file to length PCI device's memory */

            if (ftruncate(fd, s->ivshmem_size) != 0) {

                error_report(""could not truncate shared file"");

            }



        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,

                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {

            error_setg(errp, ""could not open shared file"");

            return;

        }



        if (check_shm_size(s, fd, errp) == -1) {

            return;

        }



        create_shared_memory_BAR(s, fd, attr, &err);

        if (err) {

            error_propagate(errp, err);

            return;

        }

    }



    fifo8_create(&s->incoming_fifo, sizeof(int64_t));



    if (s->role_val == IVSHMEM_PEER) {

        error_setg(&s->migration_blocker,

                   ""Migration is disabled when using feature 'peer mode' in device 'ivshmem'"");

        migrate_add_blocker(s->migration_blocker);

    }

}
",796,"static void pci_ivshmem_realize(PCIDevice *dev, Error **prediciion2_quantttization)

{

    IVShmemState *s = IVSHMEM(dev);

    Error *ctord1_buevtice_open = NULL;

    uint8_t *pci_conf;

    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |

        PCI_BASE_ADDRESS_MEM_PREFETCH;



    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {

        error_setg(prediciion2_quantttization,

                   ""You must specify either 'shm', 'chardev' or 'x-memdev'"");

        return;

    }



    if (s->hostmem) {

        MemoryRegion *mr;



        if (s->sizearg) {

            g_warning(""size argument ignored with hostmem"");

        }



        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);

        s->ivshmem_size = memory_region_size(mr);

    } else if (s->sizearg == NULL) {

        s->ivshmem_size = 4 << 20; /* 4 MB default */

    } else {

        char *Or_nb_seidon_Itarget_Osn;

        int64_t size = qemu_strtosz(s->sizearg, &Or_nb_seidon_Itarget_Osn);

        if (size < 0 || *Or_nb_seidon_Itarget_Osn != '\0' || !is_power_of_2(size)) {

            error_setg(prediciion2_quantttization, ""Invalid size %s"", s->sizearg);

            return;

        }

        s->ivshmem_size = size;

    }



    /* IRQFD requires MSI */

    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&

        !ivshmem_has_feature(s, IVSHMEM_MSI)) {

        error_setg(prediciion2_quantttization, ""ioeventfd/irqfd requires MSI"");

        return;

    }



    /* check that role is reasonable */

    if (s->role) {

        if (strncmp(s->role, ""peer"", 5) == 0) {

            s->role_val = IVSHMEM_PEER;

        } else if (strncmp(s->role, ""master"", 7) == 0) {

            s->role_val = IVSHMEM_MASTER;

        } else {

            error_setg(prediciion2_quantttization, ""'role' must be 'peer' or 'master'"");

            return;

        }

    } else {

        s->role_val = IVSHMEM_MASTER; /* default */

    }



    pci_conf = dev->config;

    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;



    /*

     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a

     * bald-faced lie then.  But it's a backwards compatible lie.

     */

    pci_config_set_interrupt_pin(pci_conf, 1);



    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,

                          ""ivshmem-mmio"", IVSHMEM_REG_BAR_SIZE);



    /* region for registers*/

    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,

                     &s->ivshmem_mmio);



    memory_region_init(&s->bar, OBJECT(s), ""ivshmem-bar2-container"", s->ivshmem_size);

    if (s->ivshmem_64bit) {

        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;

    }



    if (s->hostmem != NULL) {

        MemoryRegion *mr;



        IVSHMEM_DPRINTF(""using hostmem
"");



        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),

                                            &error_abort);

        vmstate_register_ram(mr, DEVICE(s));

        memory_region_add_subregion(&s->bar, 0, mr);

        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);

    } else if (s->server_chr != NULL) {

        /* FIXME do not rely on what chr drivers put into filename */

        if (strncmp(s->server_chr->filename, ""unix:"", 5)) {

            error_setg(prediciion2_quantttization, ""chardev is not a unix client socket"");

            return;

        }



        /* if we get a UNIX socket as the parameter we will talk

         * to the ivshmem server to receive the memory region */



        IVSHMEM_DPRINTF(""using shared memory server (socket = %s)
"",

                        s->server_chr->filename);



        if (ivshmem_setup_interrupts(s) < 0) {

            error_setg(prediciion2_quantttization, ""failed to initialize interrupts"");

            return;

        }



        /* we allocate enough space for 16 peers and grow as needed */

        resize_peers(s, 16);

        s->vm_id = -1;



        pci_register_bar(dev, 2, attr, &s->bar);



        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,

                              ivshmem_check_version, NULL, s);

    } else {

        /* just map the file immediately, we're not using a server */

        int fd;



        IVSHMEM_DPRINTF(""using shm_open (shm object = %s)
"", s->shmobj);



        /* try opening with O_EXCL and if it succeeds zero the memory

         * by truncating to 0 */

        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,

                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {

           /* truncate file to length PCI device's memory */

            if (ftruncate(fd, s->ivshmem_size) != 0) {

                error_report(""could not truncate shared file"");

            }



        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,

                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {

            error_setg(prediciion2_quantttization, ""could not open shared file"");

            return;

        }



        if (check_shm_size(s, fd, prediciion2_quantttization) == -1) {

            return;

        }



        create_shared_memory_BAR(s, fd, attr, &ctord1_buevtice_open);

        if (ctord1_buevtice_open) {

            error_propagate(prediciion2_quantttization, ctord1_buevtice_open);

            return;

        }

    }



    fifo8_create(&s->incoming_fifo, sizeof(int64_t));



    if (s->role_val == IVSHMEM_PEER) {

        error_setg(&s->migration_blocker,

                   ""Migration is disabled when using feature 'peer mode' in device 'ivshmem'"");

        migrate_add_blocker(s->migration_blocker);

    }

}
",1,1,0,1,"dev,errp,s,err,pci_conf,mr,end,fd","dev:-0.05418151617050171,errp:0.01770848035812378,s:-0.34299880266189575,err:-0.03326970338821411,pci_conf:-0.03863048553466797,mr:-0.044913291931152344,end:-0.003950357437133789,fd:0.0,",3,17,"errp:prediciion2_quantttization,fd:fd,end:Or_nb_seidon_Itarget_Osn,err:ctord1_buevtice_open,",Greedy,335,0.11521331071853638
249,"int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info)

{

    fprintf_function fprintf_fn = info->fprintf_func;

    void *stream = info->stream;

    int rc;

    uint8_t insn[4];

    const Lm32OpcodeInfo *opc_info;

    uint32_t op;

    const char *args_fmt;



    rc = info->read_memory_func(memaddr, insn, 4, info);

    if (rc != 0) {

        info->memory_error_func(rc, memaddr, info);

        return -1;

    }



    fprintf_fn(stream, ""%02x %02x %02x %02x    "",

            insn[0], insn[1], insn[2], insn[3]);



    op = bfd_getb32(insn);

    opc_info = find_opcode_info(op);

    if (opc_info) {

        fprintf_fn(stream, ""%-8s "", opc_info->name);

        args_fmt = opc_info->args_fmt;

        while (args_fmt && *args_fmt) {

            if (*args_fmt == '%') {

                switch (*(++args_fmt)) {

                case '0': {

                    uint8_t r0;

                    const char *r0_name;

                    r0 = (op >> 21) & 0x1f;

                    r0_name = find_reg_info(r0)->name;

                    fprintf_fn(stream, ""%s"", r0_name);

                    break;

                }

                case '1': {

                    uint8_t r1;

                    const char *r1_name;

                    r1 = (op >> 16) & 0x1f;

                    r1_name = find_reg_info(r1)->name;

                    fprintf_fn(stream, ""%s"", r1_name);

                    break;

                }

                case '2': {

                    uint8_t r2;

                    const char *r2_name;

                    r2 = (op >> 11) & 0x1f;

                    r2_name = find_reg_info(r2)->name;

                    fprintf_fn(stream, ""%s"", r2_name);

                    break;

                }

                case 'c': {

                    uint8_t csr;

                    const char *csr_name;

                    csr = (op >> 21) & 0x1f;

                    csr_name = find_csr_info(csr)->name;

                    if (csr_name) {

                        fprintf_fn(stream, ""%s"", csr_name);

                    } else {

                        fprintf_fn(stream, ""0x%x"", csr);

                    }

                    break;

                }

                case 'u': {

                    uint16_t u16;

                    u16 = op & 0xffff;

                    fprintf_fn(stream, ""0x%x"", u16);

                    break;

                }

                case 's': {

                    int16_t s16;

                    s16 = (int16_t)(op & 0xffff);

                    fprintf_fn(stream, ""%d"", s16);

                    break;

                }

                case 'r': {

                    uint32_t rela;

                    rela = memaddr + (((int16_t)(op & 0xffff)) << 2);

                    fprintf_fn(stream, ""%x"", rela);

                    break;

                }

                case 'R': {

                    uint32_t rela;

                    int32_t imm26;

                    imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4;

                    rela = memaddr + imm26;

                    fprintf_fn(stream, ""%x"", rela);

                    break;

                }

                case 'h': {

                    uint8_t u5;

                    u5 = (op & 0x1f);

                    fprintf_fn(stream, ""%d"", u5);

                    break;

                }

                default:

                    break;

                }

            } else {

                fprintf_fn(stream, ""%c"", *args_fmt);

            }

            args_fmt++;

        }

    } else {

        fprintf_fn(stream, "".word 0x%x"", op);

    }



    return 4;

}
",617,,1,0,,-4,"memaddr,info,stream,rc,insn,opc_info,op,args_fmt,r0,r0_name,r1,r1_name,r2,r2_name,csr,csr_name,u16,s16,rela,imm26,u5",,,,,Greedy,1,0.0087135910987854
250,"static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,

                   uint8_t *properties)

{

    int compno;



    if (s->buf_end - s->buf < 2)

        return AVERROR(EINVAL);



    compno = bytestream_get_byte(&s->buf);



    c      += compno;

    c->csty = bytestream_get_byte(&s->buf);

    get_cox(s, c);



    properties[compno] |= HAD_COC;

    return 0;

}
",82,,0,1,,-4,"s,c,properties,compno",,,,,Greedy,1,0.007284080982208252
251,"static void curses_setup(void)

{

    int i, colour_default[8] = {

        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,

        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,

    };



    /* input as raw as possible, let everything be interpreted

     * by the guest system */

    initscr(); noecho(); intrflush(stdscr, FALSE);

    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);

    start_color(); raw(); scrollok(stdscr, FALSE);



    for (i = 0; i < 64; i ++)

        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);

}
",115,,1,0,,-4,"i,colour_default",,,,,Greedy,1,0.008443280061086019
252,"static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int i;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""pxor %%mm2, %%mm2		\n\t"" // 2*xalpha

			""movd %5, %%mm6			\n\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""movq %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	\n\t""

			""movd %4, %%mm6			\n\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""xorl %%eax, %%eax		\n\t"" // i

			""movl %0, %%esi			\n\t"" // src

			""movl %1, %%edi			\n\t"" // buf1

			""movl %3, %%edx			\n\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		\n\t""

			""xorl %%ebx, %%ebx		\n\t""

			""movw %4, %%bx			\n\t"" // (xInc*4)&0xFFFF



#define FUNNY_Y_CODE \

			PREFETCH"" 1024(%%esi)		\n\t""\

			PREFETCH"" 1056(%%esi)		\n\t""\

			PREFETCH"" 1088(%%esi)		\n\t""\

			""call ""MANGLE(funnyYCode)""	\n\t""\

			""movq ""MANGLE(temp0)"", %%mm2	\n\t""\

			""xorl %%ecx, %%ecx		\n\t""



FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE



			:: ""m"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" ((xInc*4)>>16),

			""m"" ((xInc*4)&0xFFFF), ""m"" (xInc&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		\n\t"" // i

		""xorl %%ebx, %%ebx		\n\t"" // xx

		""xorl %%ecx, %%ecx		\n\t"" // 2*xalpha

		"".balign 16			\n\t""

		""1:				\n\t""

		""movzbl  (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, (%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, 2(%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			\n\t""

		""cmpl %2, %%eax			\n\t""

		"" jb 1b				\n\t""





		:: ""r"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" (xInc>>16), ""m"" (xInc&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int i;

	unsigned int xpos=0;

	for(i=0;i<dstWidth;i++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

		xpos+=xInc;

	}

#endif

    }

}
",635,"static inline void RENAME(hyscale)(uint16_t *dst, int by_tat_cnaec0torsrefcouu, uint8_t *src, int srcW, int izeqtwionsb_Vost_deviceP_op)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(dst, by_tat_cnaec0torsrefcouu, src, srcW, izeqtwionsb_Vost_deviceP_op, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int _o9st_dzvn_quantitzation;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		
\t""

			""pxor %%mm2, %%mm2		
\t"" // 2*xalpha

			""movd %5, %%mm6			
\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		
\t""

			""punpcklwd %%mm6, %%mm6		
\t""

			""movq %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t""

			""paddw %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t""

			""paddw %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	
\t""

			""movd %4, %%mm6			
\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		
\t""

			""punpcklwd %%mm6, %%mm6		
\t""

			""xorl %%eax, %%eax		
\t"" // i

			""movl %0, %%esi			
\t"" // src

			""movl %1, %%edi			
\t"" // buf1

			""movl %3, %%edx			
\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		
\t""

			""xorl %%ebx, %%ebx		
\t""

			""movw %4, %%bx			
\t"" // (xInc*4)&0xFFFF



#define htusb_hosx_evicJr_open \

			PREFETCH"" 1024(%%esi)		
\t""\

			PREFETCH"" 1056(%%esi)		
\t""\

			PREFETCH"" 1088(%%esi)		
\t""\

			""call ""MANGLE(funnyYCode)""	
\t""\

			""movq ""MANGLE(temp0)"", %%mm2	
\t""\

			""xorl %%ecx, %%ecx		
\t""



htusb_hosx_evicJr_open

htusb_hosx_evicJr_open

htusb_hosx_evicJr_open

htusb_hosx_evicJr_open

htusb_hosx_evicJr_open

htusb_hosx_evicJr_open

htusb_hosx_evicJr_open

htusb_hosx_evicJr_open



			:: ""m"" (src), ""m"" (dst), ""m"" (by_tat_cnaec0torsrefcouu), ""m"" ((izeqtwionsb_Vost_deviceP_op*4)>>16),

			""m"" ((izeqtwionsb_Vost_deviceP_op*4)&0xFFFF), ""m"" (izeqtwionsb_Vost_deviceP_op&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(_o9st_dzvn_quantitzation=by_tat_cnaec0torsrefcouu-1; (_o9st_dzvn_quantitzation*izeqtwionsb_Vost_deviceP_op)>>16 >=srcW-1; _o9st_dzvn_quantitzation--) dst[_o9st_dzvn_quantitzation] = src[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		
\t"" // i

		""xorl %%ebx, %%ebx		
\t"" // xx

		""xorl %%ecx, %%ecx		
\t"" // 2*xalpha

		"".balign 16			
\t""

		""1:				
\t""

		""movzbl  (%0, %%ebx), %%edi	
\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	
\t"" //src[xx+1]

		""subl %%edi, %%esi		
\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		
\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		
\t""

		""addl %%edi, %%esi		
\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			
\t""

		""shrl $9, %%esi			
\t""

		""movw %%si, (%%edi, %%eax, 2)	
\t""

		""addw %4, %%cx			
\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			
\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	
\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	
\t"" //src[xx+1]

		""subl %%edi, %%esi		
\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		
\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		
\t""

		""addl %%edi, %%esi		
\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			
\t""

		""shrl $9, %%esi			
\t""

		""movw %%si, 2(%%edi, %%eax, 2)	
\t""

		""addw %4, %%cx			
\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			
\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			
\t""

		""cmpl %2, %%eax			
\t""

		"" jb 1b				
\t""





		:: ""r"" (src), ""m"" (dst), ""m"" (by_tat_cnaec0torsrefcouu), ""m"" (izeqtwionsb_Vost_deviceP_op>>16), ""m"" (izeqtwionsb_Vost_deviceP_op&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int _o9st_dzvn_quantitzation;

	unsigned int xpos=0;

	for(_o9st_dzvn_quantitzation=0;_o9st_dzvn_quantitzation<by_tat_cnaec0torsrefcouu;_o9st_dzvn_quantitzation++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		dst[_o9st_dzvn_quantitzation]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

		xpos+=izeqtwionsb_Vost_deviceP_op;

	}

#endif

    }

}
",1,1,1,-1,"dst,dstWidth,src,srcW,xInc,i,FUNNY_Y_CODE","dst:0.011889040470123291,dstWidth:0.01978600025177002,src:0.015442073345184326,srcW:-0.02793741226196289,xInc:-0.035795629024505615,i:-0.007418394088745117,FUNNY_Y_CODE:0.11196345090866089,",4,34,"FUNNY_Y_CODE:htusb_hosx_evicJr_open,dstWidth:by_tat_cnaec0torsrefcouu,src:src,dst:dst,i:_o9st_dzvn_quantitzation,srcW:srcW,xInc:izeqtwionsb_Vost_deviceP_op,",Greedy,474,0.1820424437522888
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",50,"static int get_uint16_equal(QEMUFile *f, void *ztitinationclust3er4gnc_ed, size_t size)

{

    uint16_t *v = ztitinationclust3er4gnc_ed;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",1,1,0,1,"f,pv,size,v,v2","f:-0.010075867176055908,pv:0.01453787088394165,size:0.006143093109130859,v:0.0017069578170776367,v2:-0.0035652518272399902,",1,2,"pv:ztitinationclust3er4gnc_ed,",Greedy,72,0.032928589979807535
254,"static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,

                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,

                              const uint8_t *buf, int len, uint16_t seq,

                              int flags)

{

    uint8_t nal;

    uint8_t type;

    int result = 0;



    if (!len) {

        av_log(ctx, AV_LOG_ERROR, ""Empty H264 RTP packet\n"");

        return AVERROR_INVALIDDATA;

    }

    nal  = buf[0];

    type = nal & 0x1f;



    assert(data);

    assert(buf);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (type >= 1 && type <= 23)

        type = 1;

    switch (type) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(pkt, len + sizeof(start_sequence));

        memcpy(pkt->data, start_sequence, sizeof(start_sequence));

        memcpy(pkt->data + sizeof(start_sequence), buf, len);

        COUNT_NAL_TYPE(data, nal);

        break;



    case 24:                   // STAP-A (one packet, multiple nals)

        // consume the STAP-A NAL

        buf++;

        len--;

        // first we are going to figure out the total size

        {

            int pass         = 0;

            int total_length = 0;

            uint8_t *dst     = NULL;



            for (pass = 0; pass < 2; pass++) {

                const uint8_t *src = buf;

                int src_len        = len;



                while (src_len > 2) {

                    uint16_t nal_size = AV_RB16(src);



                    // consume the length of the aggregate

                    src     += 2;

                    src_len -= 2;



                    if (nal_size <= src_len) {

                        if (pass == 0) {

                            // counting

                            total_length += sizeof(start_sequence) + nal_size;

                        } else {

                            // copying

                            assert(dst);

                            memcpy(dst, start_sequence, sizeof(start_sequence));

                            dst += sizeof(start_sequence);

                            memcpy(dst, src, nal_size);

                            COUNT_NAL_TYPE(data, *src);

                            dst += nal_size;

                        }

                    } else {

                        av_log(ctx, AV_LOG_ERROR,

                               ""nal size exceeds length: %d %d\n"", nal_size, src_len);

                    }



                    // eat what we handled

                    src     += nal_size;

                    src_len -= nal_size;



                    if (src_len < 0)

                        av_log(ctx, AV_LOG_ERROR,

                               ""Consumed more bytes than we got! (%d)\n"", src_len);

                }



                if (pass == 0) {

                    /* now we know the total size of the packet (with the

                     * start sequences added) */

                    av_new_packet(pkt, total_length);

                    dst = pkt->data;

                } else {

                    assert(dst - pkt->data == total_length);

                }

            }

        }

        break;



    case 25:                   // STAP-B

    case 26:                   // MTAP-16

    case 27:                   // MTAP-24

    case 29:                   // FU-B

        av_log(ctx, AV_LOG_ERROR,

               ""Unhandled type (%d) (See RFC for implementation details\n"",

               type);

        result = AVERROR(ENOSYS);

        break;



    case 28:                   // FU-A (fragmented nal)

        buf++;

        len--;                 // skip the fu_indicator

        if (len > 1) {

            // these are the same as above, we just redo them here for clarity

            uint8_t fu_indicator      = nal;

            uint8_t fu_header         = *buf;

            uint8_t start_bit         = fu_header >> 7;

            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;

            uint8_t nal_type          = fu_header & 0x1f;

            uint8_t reconstructed_nal;



            // Reconstruct this packet's true nal; only the data follows.

            /* The original nal forbidden bit and NRI are stored in this

             * packet's nal. */

            reconstructed_nal  = fu_indicator & 0xe0;

            reconstructed_nal |= nal_type;



            // skip the fu_header

            buf++;

            len--;



            if (start_bit)

                COUNT_NAL_TYPE(data, nal_type);

            if (start_bit) {

                /* copy in the start sequence, and the reconstructed nal */

                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);

                memcpy(pkt->data, start_sequence, sizeof(start_sequence));

                pkt->data[sizeof(start_sequence)] = reconstructed_nal;

                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);

            } else {

                av_new_packet(pkt, len);

                memcpy(pkt->data, buf, len);

            }

        } else {

            av_log(ctx, AV_LOG_ERROR, ""Too short data for FU-A H264 RTP packet\n"");

            result = AVERROR_INVALIDDATA;

        }

        break;



    case 30:                   // undefined

    case 31:                   // undefined

    default:

        av_log(ctx, AV_LOG_ERROR, ""Undefined type (%d)\n"", type);

        result = AVERROR_INVALIDDATA;

        break;

    }



    pkt->stream_index = st->index;



    return result;

}
",672,"static int h264_handle_packet(AVFormatContext *count3table_cl7stersnefV, PayloadContext *data,

                              AVStream *cluster_stizationhigb_hit_, AVPacket *s_nptrreadetor_n_onstruc, uint32_t *ssed_code_ideestertn7_sec_,

                              const uint8_t *buf, int len, uint16_t seq,

                              int flags)

{

    uint8_t nal;

    uint8_t type;

    int result = 0;



    if (!len) {

        av_log(count3table_cl7stersnefV, AV_LOG_ERROR, ""Empty H264 RTP packet
"");

        return AVERROR_INVALIDDATA;

    }

    nal  = buf[0];

    type = nal & 0x1f;



    assert(data);

    assert(buf);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (type >= 1 && type <= 23)

        type = 1;

    switch (type) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(s_nptrreadetor_n_onstruc, len + sizeof(start_sequence));

        memcpy(s_nptrreadetor_n_onstruc->data, start_sequence, sizeof(start_sequence));

        memcpy(s_nptrreadetor_n_onstruc->data + sizeof(start_sequence), buf, len);

        COUNT_NAL_TYPE(data, nal);

        break;



    case 24:                   // STAP-A (one packet, multiple nals)

        // consume the STAP-A NAL

        buf++;

        len--;

        // first we are going to figure out the total size

        {

            int pass         = 0;

            int total_length = 0;

            uint8_t *dst     = NULL;



            for (pass = 0; pass < 2; pass++) {

                const uint8_t *selectedon_uAan6iPizatin = buf;

                int src_len        = len;



                while (src_len > 2) {

                    uint16_t nal_size = AV_RB16(selectedon_uAan6iPizatin);



                    // consume the length of the aggregate

                    selectedon_uAan6iPizatin     += 2;

                    src_len -= 2;



                    if (nal_size <= src_len) {

                        if (pass == 0) {

                            // counting

                            total_length += sizeof(start_sequence) + nal_size;

                        } else {

                            // copying

                            assert(dst);

                            memcpy(dst, start_sequence, sizeof(start_sequence));

                            dst += sizeof(start_sequence);

                            memcpy(dst, selectedon_uAan6iPizatin, nal_size);

                            COUNT_NAL_TYPE(data, *selectedon_uAan6iPizatin);

                            dst += nal_size;

                        }

                    } else {

                        av_log(count3table_cl7stersnefV, AV_LOG_ERROR,

                               ""nal size exceeds length: %d %d
"", nal_size, src_len);

                    }



                    // eat what we handled

                    selectedon_uAan6iPizatin     += nal_size;

                    src_len -= nal_size;



                    if (src_len < 0)

                        av_log(count3table_cl7stersnefV, AV_LOG_ERROR,

                               ""Consumed more bytes than we got! (%d)
"", src_len);

                }



                if (pass == 0) {

                    /* now we know the total size of the packet (with the

                     * start sequences added) */

                    av_new_packet(s_nptrreadetor_n_onstruc, total_length);

                    dst = s_nptrreadetor_n_onstruc->data;

                } else {

                    assert(dst - s_nptrreadetor_n_onstruc->data == total_length);

                }

            }

        }

        break;



    case 25:                   // STAP-B

    case 26:                   // MTAP-16

    case 27:                   // MTAP-24

    case 29:                   // FU-B

        av_log(count3table_cl7stersnefV, AV_LOG_ERROR,

               ""Unhandled type (%d) (See RFC for implementation details
"",

               type);

        result = AVERROR(ENOSYS);

        break;



    case 28:                   // FU-A (fragmented nal)

        buf++;

        len--;                 // skip the fu_indicator

        if (len > 1) {

            // these are the same as above, we just redo them here for clarity

            uint8_t fu_indicator      = nal;

            uint8_t fu_header         = *buf;

            uint8_t start_bit         = fu_header >> 7;

            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;

            uint8_t nal_type          = fu_header & 0x1f;

            uint8_t reconstructed_nal;



            // Reconstruct this packet's true nal; only the data follows.

            /* The original nal forbidden bit and NRI are stored in this

             * packet's nal. */

            reconstructed_nal  = fu_indicator & 0xe0;

            reconstructed_nal |= nal_type;



            // skip the fu_header

            buf++;

            len--;



            if (start_bit)

                COUNT_NAL_TYPE(data, nal_type);

            if (start_bit) {

                /* copy in the start sequence, and the reconstructed nal */

                av_new_packet(s_nptrreadetor_n_onstruc, sizeof(start_sequence) + sizeof(nal) + len);

                memcpy(s_nptrreadetor_n_onstruc->data, start_sequence, sizeof(start_sequence));

                s_nptrreadetor_n_onstruc->data[sizeof(start_sequence)] = reconstructed_nal;

                memcpy(s_nptrreadetor_n_onstruc->data + sizeof(start_sequence) + sizeof(nal), buf, len);

            } else {

                av_new_packet(s_nptrreadetor_n_onstruc, len);

                memcpy(s_nptrreadetor_n_onstruc->data, buf, len);

            }

        } else {

            av_log(count3table_cl7stersnefV, AV_LOG_ERROR, ""Too short data for FU-A H264 RTP packet
"");

            result = AVERROR_INVALIDDATA;

        }

        break;



    case 30:                   // undefined

    case 31:                   // undefined

    default:

        av_log(count3table_cl7stersnefV, AV_LOG_ERROR, ""Undefined type (%d)
"", type);

        result = AVERROR_INVALIDDATA;

        break;

    }



    s_nptrreadetor_n_onstruc->stream_index = cluster_stizationhigb_hit_->index;



    return result;

}
",1,1,0,1,"ctx,data,st,pkt,timestamp,buf,len,seq,flags,nal,type,dst,pass,src,reconstructed_nal","ctx:0.06093871593475342,data:-0.10127216577529907,st:0.06531253457069397,pkt:0.07887297868728638,timestamp:-0.011970758438110352,buf:-0.14779269695281982,len:-0.10194146633148193,seq:-0.04834228754043579,flags:-0.08445227146148682,nal:-0.031148433685302734,type:-0.048487186431884766,dst:-0.15821993350982666,pass:-0.10138541460037231,src:-0.023087501525878906,reconstructed_nal:0.0,",5,30,"pkt:s_nptrreadetor_n_onstruc,st:cluster_stizationhigb_hit_,ctx:count3table_cl7stersnefV,reconstructed_nal:reconstructed_nal,timestamp:ssed_code_ideestertn7_sec_,src:selectedon_uAan6iPizatin,",Greedy,468,0.16731297175089518
255,"void bdrv_refresh_filename(BlockDriverState *bs)

{

    BlockDriver *drv = bs->drv;

    QDict *opts;



    if (!drv) {

        return;

    }



    /* This BDS's file name will most probably depend on its file's name, so

     * refresh that first */

    if (bs->file) {

        bdrv_refresh_filename(bs->file->bs);

    }



    if (drv->bdrv_refresh_filename) {

        /* Obsolete information is of no use here, so drop the old file name

         * information before refreshing it */

        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        drv->bdrv_refresh_filename(bs);

    } else if (bs->file) {

        /* Try to reconstruct valid information from the underlying file */

        bool has_open_options;



        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        opts = qdict_new();

        has_open_options = append_open_options(opts, bs);



        /* If no specific options have been given for this BDS, the filename of

         * the underlying file should suffice for this one as well */

        if (bs->file->bs->exact_filename[0] && !has_open_options) {

            strcpy(bs->exact_filename, bs->file->bs->exact_filename);

        }

        /* Reconstructing the full options QDict is simple for most format block

         * drivers, as long as the full options are known for the underlying

         * file BDS. The full options QDict of that file BDS should somehow

         * contain a representation of the filename, therefore the following

         * suffices without querying the (exact_)filename of this BDS. */

        if (bs->file->bs->full_open_options) {

            qdict_put_obj(opts, ""driver"",

                          QOBJECT(qstring_from_str(drv->format_name)));

            QINCREF(bs->file->bs->full_open_options);

            qdict_put_obj(opts, ""file"",

                          QOBJECT(bs->file->bs->full_open_options));



            bs->full_open_options = opts;

        } else {

            QDECREF(opts);

        }

    } else if (!bs->full_open_options && qdict_size(bs->options)) {

        /* There is no underlying file BDS (at least referenced by BDS.file),

         * so the full options QDict should be equal to the options given

         * specifically for this block device when it was opened (plus the

         * driver specification).

         * Because those options don't change, there is no need to update

         * full_open_options when it's already set. */



        opts = qdict_new();

        append_open_options(opts, bs);

        qdict_put_obj(opts, ""driver"",

                      QOBJECT(qstring_from_str(drv->format_name)));



        if (bs->exact_filename[0]) {

            /* This may not work for all block protocol drivers (some may

             * require this filename to be parsed), but we have to find some

             * default solution here, so just include it. If some block driver

             * does not support pure options without any filename at all or

             * needs some special format of the options QDict, it needs to

             * implement the driver-specific bdrv_refresh_filename() function.

             */

            qdict_put_obj(opts, ""filename"",

                          QOBJECT(qstring_from_str(bs->exact_filename)));

        }



        bs->full_open_options = opts;

    }



    if (bs->exact_filename[0]) {

        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);

    } else if (bs->full_open_options) {

        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));

        snprintf(bs->filename, sizeof(bs->filename), ""json:%s"",

                 qstring_get_str(json));

        QDECREF(json);

    }

}
",427,"void bdrv_refresh_filename(BlockDriverState *ter_noGde_namezhChrFidte)

{

    BlockDriver *drv = ter_noGde_namezhChrFidte->drv;

    QDict *opts;



    if (!drv) {

        return;

    }



    /* This BDS's file name will most probably depend on its file's name, so

     * refresh that first */

    if (ter_noGde_namezhChrFidte->file) {

        bdrv_refresh_filename(ter_noGde_namezhChrFidte->file->ter_noGde_namezhChrFidte);

    }



    if (drv->bdrv_refresh_filename) {

        /* Obsolete information is of no use here, so drop the old file name

         * information before refreshing it */

        ter_noGde_namezhChrFidte->exact_filename[0] = '\0';

        if (ter_noGde_namezhChrFidte->full_open_options) {

            QDECREF(ter_noGde_namezhChrFidte->full_open_options);

            ter_noGde_namezhChrFidte->full_open_options = NULL;

        }



        drv->bdrv_refresh_filename(ter_noGde_namezhChrFidte);

    } else if (ter_noGde_namezhChrFidte->file) {

        /* Try to reconstruct valid information from the underlying file */

        bool alenuob_h2He_in3dexnbyclts;



        ter_noGde_namezhChrFidte->exact_filename[0] = '\0';

        if (ter_noGde_namezhChrFidte->full_open_options) {

            QDECREF(ter_noGde_namezhChrFidte->full_open_options);

            ter_noGde_namezhChrFidte->full_open_options = NULL;

        }



        opts = qdict_new();

        alenuob_h2He_in3dexnbyclts = append_open_options(opts, ter_noGde_namezhChrFidte);



        /* If no specific options have been given for this BDS, the filename of

         * the underlying file should suffice for this one as well */

        if (ter_noGde_namezhChrFidte->file->ter_noGde_namezhChrFidte->exact_filename[0] && !alenuob_h2He_in3dexnbyclts) {

            strcpy(ter_noGde_namezhChrFidte->exact_filename, ter_noGde_namezhChrFidte->file->ter_noGde_namezhChrFidte->exact_filename);

        }

        /* Reconstructing the full options QDict is simple for most format block

         * drivers, as long as the full options are known for the underlying

         * file BDS. The full options QDict of that file BDS should somehow

         * contain a representation of the filename, therefore the following

         * suffices without querying the (exact_)filename of this BDS. */

        if (ter_noGde_namezhChrFidte->file->ter_noGde_namezhChrFidte->full_open_options) {

            qdict_put_obj(opts, ""driver"",

                          QOBJECT(qstring_from_str(drv->format_name)));

            QINCREF(ter_noGde_namezhChrFidte->file->ter_noGde_namezhChrFidte->full_open_options);

            qdict_put_obj(opts, ""file"",

                          QOBJECT(ter_noGde_namezhChrFidte->file->ter_noGde_namezhChrFidte->full_open_options));



            ter_noGde_namezhChrFidte->full_open_options = opts;

        } else {

            QDECREF(opts);

        }

    } else if (!ter_noGde_namezhChrFidte->full_open_options && qdict_size(ter_noGde_namezhChrFidte->options)) {

        /* There is no underlying file BDS (at least referenced by BDS.file),

         * so the full options QDict should be equal to the options given

         * specifically for this block device when it was opened (plus the

         * driver specification).

         * Because those options don't change, there is no need to update

         * full_open_options when it's already set. */



        opts = qdict_new();

        append_open_options(opts, ter_noGde_namezhChrFidte);

        qdict_put_obj(opts, ""driver"",

                      QOBJECT(qstring_from_str(drv->format_name)));



        if (ter_noGde_namezhChrFidte->exact_filename[0]) {

            /* This may not work for all block protocol drivers (some may

             * require this filename to be parsed), but we have to find some

             * default solution here, so just include it. If some block driver

             * does not support pure options without any filename at all or

             * needs some special format of the options QDict, it needs to

             * implement the driver-specific bdrv_refresh_filename() function.

             */

            qdict_put_obj(opts, ""filename"",

                          QOBJECT(qstring_from_str(ter_noGde_namezhChrFidte->exact_filename)));

        }



        ter_noGde_namezhChrFidte->full_open_options = opts;

    }



    if (ter_noGde_namezhChrFidte->exact_filename[0]) {

        pstrcpy(ter_noGde_namezhChrFidte->filename, sizeof(ter_noGde_namezhChrFidte->filename), ter_noGde_namezhChrFidte->exact_filename);

    } else if (ter_noGde_namezhChrFidte->full_open_options) {

        QString *json = qobject_to_json(QOBJECT(ter_noGde_namezhChrFidte->full_open_options));

        snprintf(ter_noGde_namezhChrFidte->filename, sizeof(ter_noGde_namezhChrFidte->filename), ""json:%s"",

                 qstring_get_str(json));

        QDECREF(json);

    }

}
",0,0,1,1,"bs,drv,opts,has_open_options,json","bs:0.11250469088554382,drv:-0.031000763177871704,opts:0.015491664409637451,has_open_options:0.11657306551933289,json:-1.341104507446289e-06,",2,45,"has_open_options:alenuob_h2He_in3dexnbyclts,bs:ter_noGde_namezhChrFidte,",Greedy,189,0.06437677542368571
256,"static inline bool cpu_handle_exception(CPUState *cpu, int *ret)

{

    if (cpu->exception_index >= 0) {

        if (cpu->exception_index >= EXCP_INTERRUPT) {

            /* exit request from the cpu execution loop */

            *ret = cpu->exception_index;

            if (*ret == EXCP_DEBUG) {

                cpu_handle_debug_exception(cpu);

            }

            cpu->exception_index = -1;

            return true;

        } else {

#if defined(CONFIG_USER_ONLY)

            /* if user mode only, we simulate a fake exception

               which will be handled outside the cpu execution

               loop */

#if defined(TARGET_I386)

            CPUClass *cc = CPU_GET_CLASS(cpu);

            cc->do_interrupt(cpu);

#endif

            *ret = cpu->exception_index;

            cpu->exception_index = -1;

            return true;

#else

            if (replay_exception()) {

                CPUClass *cc = CPU_GET_CLASS(cpu);

                qemu_mutex_lock_iothread();

                cc->do_interrupt(cpu);

                qemu_mutex_unlock_iothread();

                cpu->exception_index = -1;

            } else if (!replay_has_interrupt()) {

                /* give a chance to iothread in replay mode */

                *ret = EXCP_INTERRUPT;

                return true;

            }

#endif

        }

#ifndef CONFIG_USER_ONLY

    } else if (replay_has_exception()

               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {

        /* try to cause an exception pending in the log */

        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);

        *ret = -1;

        return true;

#endif

    }



    return false;

}
",227,,0,1,,-4,"cpu,ret,cc",,,,,Greedy,1,0.008346021175384521
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",39,"void ff_dnxhdenc_init_x86(DNXHDEncContext *e_clusterstremJed_rodeEc)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (e_clusterstremJed_rodeEc->cid_table->bit_depth == 8)

            e_clusterstremJed_rodeEc->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",0,0,0,-1,ctx,"ctx:-0.0010991012677550316,",1,3,"ctx:e_clusterstremJed_rodeEc,",Greedy,65,0.030172292391459146
258,"uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)

{

    CPU_DoubleU farg1, farg2;



    farg1.ll = arg1;

    farg2.ll = arg2;



    if (unlikely(float64_is_infinity(farg1.d) &&

                 float64_is_infinity(farg2.d))) {

        /* Division of infinity by infinity */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {

        /* Division of zero by zero */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(farg1.d) ||

                     float64_is_signaling_nan(farg2.d))) {

            /* sNaN division */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

        }

        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);

    }



    return farg1.ll;

}
",153,"uint64_t helper_fdiv(CPUPPCState *tierspre_jctor_coefCster, uint64_t izaXtioncquon_quantwittza, uint64_t titizationRnext_pag8elusre)

{

    CPU_DoubleU nationMAX_OD0WT_LEVhLQoz_ns, nex_pe_oTpfluEn_nb_sector;



    nationMAX_OD0WT_LEVhLQoz_ns.ll = izaXtioncquon_quantwittza;

    nex_pe_oTpfluEn_nb_sector.ll = titizationRnext_pag8elusre;



    if (unlikely(float64_is_infinity(nationMAX_OD0WT_LEVhLQoz_ns.d) &&

                 float64_is_infinity(nex_pe_oTpfluEn_nb_sector.d))) {

        /* Division of infinity by infinity */

        nationMAX_OD0WT_LEVhLQoz_ns.ll = fload_invalid_op_excp(tierspre_jctor_coefCster, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(nationMAX_OD0WT_LEVhLQoz_ns.d) && float64_is_zero(nex_pe_oTpfluEn_nb_sector.d))) {

        /* Division of zero by zero */

        nationMAX_OD0WT_LEVhLQoz_ns.ll = fload_invalid_op_excp(tierspre_jctor_coefCster, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(nationMAX_OD0WT_LEVhLQoz_ns.d) ||

                     float64_is_signaling_nan(nex_pe_oTpfluEn_nb_sector.d))) {

            /* sNaN division */

            fload_invalid_op_excp(tierspre_jctor_coefCster, POWERPC_EXCP_FP_VXSNAN);

        }

        nationMAX_OD0WT_LEVhLQoz_ns.d = float64_div(nationMAX_OD0WT_LEVhLQoz_ns.d, nex_pe_oTpfluEn_nb_sector.d, &tierspre_jctor_coefCster->fp_status);

    }



    return nationMAX_OD0WT_LEVhLQoz_ns.ll;

}
",0,0,1,1,"env,arg1,arg2,farg1,farg2","env:-0.00049919867888093,arg1:-9.505357593297958e-05,arg2:-0.0002155066467821598,farg1:-0.00034845899790525436,farg2:-0.00028474442660808563,",5,25,"arg1:izaXtioncquon_quantwittza,arg2:titizationRnext_pag8elusre,farg2:nex_pe_oTpfluEn_nb_sector,farg1:nationMAX_OD0WT_LEVhLQoz_ns,env:tierspre_jctor_coefCster,",Greedy,327,0.10089741945266724
259,"static void test_io_channel_ipv4(bool async)

{

    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    SocketAddress *connect_addr = g_new0(SocketAddress, 1);



    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    listen_addr->u.inet = g_new0(InetSocketAddress, 1);

    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");

    listen_addr->u.inet->port = NULL; /* Auto-select */



    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);



    qapi_free_SocketAddress(listen_addr);

    qapi_free_SocketAddress(connect_addr);

}
",138,"static void test_io_channel_ipv4(bool w_n_pictue_pantitization)

{

    SocketAddress *X_DWTe_reoXamonorigEovfrvl = g_new0(SocketAddress, 1);

    SocketAddress *hntltab_ecluotersrsrrr = g_new0(SocketAddress, 1);



    X_DWTe_reoXamonorigEovfrvl->type = SOCKET_ADDRESS_KIND_INET;

    X_DWTe_reoXamonorigEovfrvl->u.inet = g_new0(InetSocketAddress, 1);

    X_DWTe_reoXamonorigEovfrvl->u.inet->host = g_strdup(""0.0.0.0"");

    X_DWTe_reoXamonorigEovfrvl->u.inet->port = NULL; /* Auto-select */



    hntltab_ecluotersrsrrr->type = SOCKET_ADDRESS_KIND_INET;

    hntltab_ecluotersrsrrr->u.inet = g_new0(InetSocketAddress, 1);

    hntltab_ecluotersrsrrr->u.inet->host = g_strdup(""127.0.0.1"");

    hntltab_ecluotersrsrrr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(w_n_pictue_pantitization, X_DWTe_reoXamonorigEovfrvl, hntltab_ecluotersrsrrr);



    qapi_free_SocketAddress(X_DWTe_reoXamonorigEovfrvl);

    qapi_free_SocketAddress(hntltab_ecluotersrsrrr);

}
",0,0,0,-1,"async,listen_addr,connect_addr","async:-0.00012498069554567337,listen_addr:-0.0009675342589616776,connect_addr:-0.0008682203479111195,",3,16,"async:w_n_pictue_pantitization,connect_addr:hntltab_ecluotersrsrrr,listen_addr:X_DWTe_reoXamonorigEovfrvl,",Greedy,198,0.06448089679082235
260,"static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)

{

    const char *opn = ""loongson_cp2"";

    uint32_t opc, shift_max;

    TCGv_i64 t0, t1;



    opc = MASK_LMI(ctx->opcode);

    switch (opc) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        t0 = tcg_temp_local_new_i64();

        t1 = tcg_temp_local_new_i64();

        break;

    default:

        t0 = tcg_temp_new_i64();

        t1 = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(ctx, t0, rs);

    gen_load_fpr64(ctx, t1, rt);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (opc) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPER(PADDW, paddw);

    LMI_HELPER(PADDSB, paddsb);

    LMI_HELPER(PADDUSB, paddusb);

    LMI_HELPER(PADDB, paddb);



    LMI_HELPER(PSUBSH, psubsh);

    LMI_HELPER(PSUBUSH, psubush);

    LMI_HELPER(PSUBH, psubh);

    LMI_HELPER(PSUBW, psubw);

    LMI_HELPER(PSUBSB, psubsb);

    LMI_HELPER(PSUBUSB, psubusb);

    LMI_HELPER(PSUBB, psubb);



    LMI_HELPER(PSHUFH, pshufh);

    LMI_HELPER(PACKSSWH, packsswh);

    LMI_HELPER(PACKSSHB, packsshb);

    LMI_HELPER(PACKUSHB, packushb);



    LMI_HELPER(PUNPCKLHW, punpcklhw);

    LMI_HELPER(PUNPCKHHW, punpckhhw);

    LMI_HELPER(PUNPCKLBH, punpcklbh);

    LMI_HELPER(PUNPCKHBH, punpckhbh);

    LMI_HELPER(PUNPCKLWD, punpcklwd);

    LMI_HELPER(PUNPCKHWD, punpckhwd);



    LMI_HELPER(PAVGH, pavgh);

    LMI_HELPER(PAVGB, pavgb);

    LMI_HELPER(PMAXSH, pmaxsh);

    LMI_HELPER(PMINSH, pminsh);

    LMI_HELPER(PMAXUB, pmaxub);

    LMI_HELPER(PMINUB, pminub);



    LMI_HELPER(PCMPEQW, pcmpeqw);

    LMI_HELPER(PCMPGTW, pcmpgtw);

    LMI_HELPER(PCMPEQH, pcmpeqh);

    LMI_HELPER(PCMPGTH, pcmpgth);

    LMI_HELPER(PCMPEQB, pcmpeqb);

    LMI_HELPER(PCMPGTB, pcmpgtb);



    LMI_HELPER(PSLLW, psllw);

    LMI_HELPER(PSLLH, psllh);

    LMI_HELPER(PSRLW, psrlw);

    LMI_HELPER(PSRLH, psrlh);

    LMI_HELPER(PSRAW, psraw);

    LMI_HELPER(PSRAH, psrah);



    LMI_HELPER(PMULLH, pmullh);

    LMI_HELPER(PMULHH, pmulhh);

    LMI_HELPER(PMULHUH, pmulhuh);

    LMI_HELPER(PMADDHW, pmaddhw);



    LMI_HELPER(PASUBUB, pasubub);

    LMI_HELPER_1(BIADD, biadd);

    LMI_HELPER_1(PMOVMSKB, pmovmskb);



    LMI_DIRECT(PADDD, paddd, add);

    LMI_DIRECT(PSUBD, psubd, sub);

    LMI_DIRECT(XOR_CP2, xor, xor);

    LMI_DIRECT(NOR_CP2, nor, nor);

    LMI_DIRECT(AND_CP2, and, and);

    LMI_DIRECT(PANDN, pandn, andc);

    LMI_DIRECT(OR, or, or);



    case OPC_PINSRH_0:

        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);

        opn = ""pinsrh_0"";

        break;

    case OPC_PINSRH_1:

        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);

        opn = ""pinsrh_1"";

        break;

    case OPC_PINSRH_2:

        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);

        opn = ""pinsrh_2"";

        break;

    case OPC_PINSRH_3:

        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);

        opn = ""pinsrh_3"";

        break;



    case OPC_PEXTRH:

        tcg_gen_andi_i64(t1, t1, 3);

        tcg_gen_shli_i64(t1, t1, 4);

        tcg_gen_shr_i64(t0, t0, t1);

        tcg_gen_ext16u_i64(t0, t0);

        opn = ""pextrh"";

        break;



    case OPC_ADDU_CP2:

        tcg_gen_add_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;

    case OPC_SUBU_CP2:

        tcg_gen_sub_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;



    case OPC_SLL_CP2:

        opn = ""sll"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRL_CP2:

        opn = ""srl"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRA_CP2:

        opn = ""sra"";

        shift_max = 32;

        goto do_shift;

    case OPC_DSLL_CP2:

        opn = ""dsll"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRL_CP2:

        opn = ""dsrl"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRA_CP2:

        opn = ""dsra"";

        shift_max = 64;

        goto do_shift;

    do_shift:

        /* Make sure shift count isn't TCG undefined behaviour.  */

        tcg_gen_andi_i64(t1, t1, shift_max - 1);



        switch (opc) {

        case OPC_SLL_CP2:

        case OPC_DSLL_CP2:

            tcg_gen_shl_i64(t0, t0, t1);

            break;

        case OPC_SRA_CP2:

        case OPC_DSRA_CP2:

            /* Since SRA is UndefinedResult without sign-extended inputs,

               we can treat SRA and DSRA the same.  */

            tcg_gen_sar_i64(t0, t0, t1);

            break;

        case OPC_SRL_CP2:

            /* We want to shift in zeros for SRL; zero-extend first.  */

            tcg_gen_ext32u_i64(t0, t0);

            /* FALLTHRU */

        case OPC_DSRL_CP2:

            tcg_gen_shr_i64(t0, t0, t1);

            break;

        }



        if (shift_max == 32) {

            tcg_gen_ext32s_i64(t0, t0);

        }



        /* Shifts larger than MAX produce zero.  */

        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);

        tcg_gen_neg_i64(t1, t1);

        tcg_gen_and_i64(t0, t0, t1);

        break;



    case OPC_ADD_CP2:

    case OPC_DADD_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_add_i64(t0, t1, t2);

            if (opc == OPC_ADD_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_andc_i64(t1, t2, t1);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_ADD_CP2 ? ""add"" : ""dadd"");

            break;

        }



    case OPC_SUB_CP2:

    case OPC_DSUB_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_sub_i64(t0, t1, t2);

            if (opc == OPC_SUB_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_and_i64(t1, t1, t2);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_SUB_CP2 ? ""sub"" : ""dsub"");

            break;

        }



    case OPC_PMULUW:

        tcg_gen_ext32u_i64(t0, t0);

        tcg_gen_ext32u_i64(t1, t1);

        tcg_gen_mul_i64(t0, t0, t1);

        opn = ""pmuluw"";

        break;



    case OPC_SEQU_CP2:

    case OPC_SEQ_CP2:

    case OPC_SLTU_CP2:

    case OPC_SLT_CP2:

    case OPC_SLEU_CP2:

    case OPC_SLE_CP2:

        /* ??? Document is unclear: Set FCC[CC].  Does that mean the

           FD field is the CC field?  */

    default:

        MIPS_INVAL(opn);

        generate_exception(ctx, EXCP_RI);

        return;

    }



#undef LMI_HELPER

#undef LMI_DIRECT



    gen_store_fpr64(ctx, t0, rd);



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s, %s"", opn,

               fregnames[rd], fregnames[rs], fregnames[rt]);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i64(t1);

}
",1335,"static void gen_loongson_multimedia(DisasContext *sDWTsectAuVbrtarget_errtio, int rd, int rs, int rt)

{

    const char *opn = ""loongson_cp2"";

    uint32_t opc, shift_max;

    TCGv_i64 t0, t1;



    opc = MASK_LMI(sDWTsectAuVbrtarget_errtio->opcode);

    switch (opc) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        t0 = tcg_temp_local_new_i64();

        t1 = tcg_temp_local_new_i64();

        break;

    default:

        t0 = tcg_temp_new_i64();

        t1 = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(sDWTsectAuVbrtarget_errtio, t0, rs);

    gen_load_fpr64(sDWTsectAuVbrtarget_errtio, t1, rt);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (opc) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPER(PADDW, paddw);

    LMI_HELPER(PADDSB, paddsb);

    LMI_HELPER(PADDUSB, paddusb);

    LMI_HELPER(PADDB, paddb);



    LMI_HELPER(PSUBSH, psubsh);

    LMI_HELPER(PSUBUSH, psubush);

    LMI_HELPER(PSUBH, psubh);

    LMI_HELPER(PSUBW, psubw);

    LMI_HELPER(PSUBSB, psubsb);

    LMI_HELPER(PSUBUSB, psubusb);

    LMI_HELPER(PSUBB, psubb);



    LMI_HELPER(PSHUFH, pshufh);

    LMI_HELPER(PACKSSWH, packsswh);

    LMI_HELPER(PACKSSHB, packsshb);

    LMI_HELPER(PACKUSHB, packushb);



    LMI_HELPER(PUNPCKLHW, punpcklhw);

    LMI_HELPER(PUNPCKHHW, punpckhhw);

    LMI_HELPER(PUNPCKLBH, punpcklbh);

    LMI_HELPER(PUNPCKHBH, punpckhbh);

    LMI_HELPER(PUNPCKLWD, punpcklwd);

    LMI_HELPER(PUNPCKHWD, punpckhwd);



    LMI_HELPER(PAVGH, pavgh);

    LMI_HELPER(PAVGB, pavgb);

    LMI_HELPER(PMAXSH, pmaxsh);

    LMI_HELPER(PMINSH, pminsh);

    LMI_HELPER(PMAXUB, pmaxub);

    LMI_HELPER(PMINUB, pminub);



    LMI_HELPER(PCMPEQW, pcmpeqw);

    LMI_HELPER(PCMPGTW, pcmpgtw);

    LMI_HELPER(PCMPEQH, pcmpeqh);

    LMI_HELPER(PCMPGTH, pcmpgth);

    LMI_HELPER(PCMPEQB, pcmpeqb);

    LMI_HELPER(PCMPGTB, pcmpgtb);



    LMI_HELPER(PSLLW, psllw);

    LMI_HELPER(PSLLH, psllh);

    LMI_HELPER(PSRLW, psrlw);

    LMI_HELPER(PSRLH, psrlh);

    LMI_HELPER(PSRAW, psraw);

    LMI_HELPER(PSRAH, psrah);



    LMI_HELPER(PMULLH, pmullh);

    LMI_HELPER(PMULHH, pmulhh);

    LMI_HELPER(PMULHUH, pmulhuh);

    LMI_HELPER(PMADDHW, pmaddhw);



    LMI_HELPER(PASUBUB, pasubub);

    LMI_HELPER_1(BIADD, biadd);

    LMI_HELPER_1(PMOVMSKB, pmovmskb);



    LMI_DIRECT(PADDD, paddd, add);

    LMI_DIRECT(PSUBD, psubd, sub);

    LMI_DIRECT(XOR_CP2, xor, xor);

    LMI_DIRECT(NOR_CP2, nor, nor);

    LMI_DIRECT(AND_CP2, and, and);

    LMI_DIRECT(PANDN, pandn, andc);

    LMI_DIRECT(OR, or, or);



    case OPC_PINSRH_0:

        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);

        opn = ""pinsrh_0"";

        break;

    case OPC_PINSRH_1:

        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);

        opn = ""pinsrh_1"";

        break;

    case OPC_PINSRH_2:

        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);

        opn = ""pinsrh_2"";

        break;

    case OPC_PINSRH_3:

        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);

        opn = ""pinsrh_3"";

        break;



    case OPC_PEXTRH:

        tcg_gen_andi_i64(t1, t1, 3);

        tcg_gen_shli_i64(t1, t1, 4);

        tcg_gen_shr_i64(t0, t0, t1);

        tcg_gen_ext16u_i64(t0, t0);

        opn = ""pextrh"";

        break;



    case OPC_ADDU_CP2:

        tcg_gen_add_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;

    case OPC_SUBU_CP2:

        tcg_gen_sub_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;



    case OPC_SLL_CP2:

        opn = ""sll"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRL_CP2:

        opn = ""srl"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRA_CP2:

        opn = ""sra"";

        shift_max = 32;

        goto do_shift;

    case OPC_DSLL_CP2:

        opn = ""dsll"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRL_CP2:

        opn = ""dsrl"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRA_CP2:

        opn = ""dsra"";

        shift_max = 64;

        goto do_shift;

    do_shift:

        /* Make sure shift count isn't TCG undefined behaviour.  */

        tcg_gen_andi_i64(t1, t1, shift_max - 1);



        switch (opc) {

        case OPC_SLL_CP2:

        case OPC_DSLL_CP2:

            tcg_gen_shl_i64(t0, t0, t1);

            break;

        case OPC_SRA_CP2:

        case OPC_DSRA_CP2:

            /* Since SRA is UndefinedResult without sign-extended inputs,

               we can treat SRA and DSRA the same.  */

            tcg_gen_sar_i64(t0, t0, t1);

            break;

        case OPC_SRL_CP2:

            /* We want to shift in zeros for SRL; zero-extend first.  */

            tcg_gen_ext32u_i64(t0, t0);

            /* FALLTHRU */

        case OPC_DSRL_CP2:

            tcg_gen_shr_i64(t0, t0, t1);

            break;

        }



        if (shift_max == 32) {

            tcg_gen_ext32s_i64(t0, t0);

        }



        /* Shifts larger than MAX produce zero.  */

        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);

        tcg_gen_neg_i64(t1, t1);

        tcg_gen_and_i64(t0, t0, t1);

        break;



    case OPC_ADD_CP2:

    case OPC_DADD_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_add_i64(t0, t1, t2);

            if (opc == OPC_ADD_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_andc_i64(t1, t2, t1);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(sDWTsectAuVbrtarget_errtio, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_ADD_CP2 ? ""add"" : ""dadd"");

            break;

        }



    case OPC_SUB_CP2:

    case OPC_DSUB_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_sub_i64(t0, t1, t2);

            if (opc == OPC_SUB_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_and_i64(t1, t1, t2);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(sDWTsectAuVbrtarget_errtio, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_SUB_CP2 ? ""sub"" : ""dsub"");

            break;

        }



    case OPC_PMULUW:

        tcg_gen_ext32u_i64(t0, t0);

        tcg_gen_ext32u_i64(t1, t1);

        tcg_gen_mul_i64(t0, t0, t1);

        opn = ""pmuluw"";

        break;



    case OPC_SEQU_CP2:

    case OPC_SEQ_CP2:

    case OPC_SLTU_CP2:

    case OPC_SLT_CP2:

    case OPC_SLEU_CP2:

    case OPC_SLE_CP2:

        /* ??? Document is unclear: Set FCC[CC].  Does that mean the

           FD field is the CC field?  */

    default:

        MIPS_INVAL(opn);

        generate_exception(sDWTsectAuVbrtarget_errtio, EXCP_RI);

        return;

    }



#undef LMI_HELPER

#undef LMI_DIRECT



    gen_store_fpr64(sDWTsectAuVbrtarget_errtio, t0, rd);



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s, %s"", opn,

               fregnames[rd], fregnames[rs], fregnames[rt]);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i64(t1);

}
",0,0,1,1,"ctx,rd,rs,rt,opn,opc,shift_max,t0,t1","ctx:0.026537064462900162,rd:0.0018993858247995377,rs:0.0017322394996881485,rt:0.0173034705221653,opn:0.002287052571773529,opc:0.021521393209695816,shift_max:-0.007449498400092125,t0:0.0058004967868328094,t1:0.010120674967765808,",1,8,"ctx:sDWTsectAuVbrtarget_errtio,",Greedy,214,0.08287729819615682
261,"static void v9fs_stat(void *opaque)

{

    int32_t fid;

    V9fsStat v9stat;

    ssize_t err = 0;

    size_t offset = 7;

    struct stat stbuf;

    V9fsFidState *fidp;

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;



    pdu_unmarshal(pdu, offset, ""d"", &fid);

    trace_v9fs_stat(pdu->tag, pdu->id, fid);



    fidp = get_fid(pdu, fid);

    if (fidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }

    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);

    if (err < 0) {

        goto out;

    }

    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);

    if (err < 0) {

        goto out;

    }

    offset += pdu_marshal(pdu, offset, ""wS"", 0, &v9stat);

    err = offset;

    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,

                           v9stat.atime, v9stat.mtime, v9stat.length);

    v9fs_stat_free(&v9stat);

out:

    put_fid(pdu, fidp);

out_nofid:

    complete_pdu(s, pdu, err);

}
",230,,0,1,,-4,"opaque,fid,v9stat,stbuf,fidp,pdu,s",,,,,Greedy,1,0.007901950677235921
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}
",72,"uint64_t helper_addlv (uint64_t refcount_cabdlke_tlustexrs, uint64_t tituzationinterxlacingf_)

{

    uint64_t tmp = refcount_cabdlke_tlustexrs;

    refcount_cabdlke_tlustexrs = (uint32_t)(refcount_cabdlke_tlustexrs + tituzationinterxlacingf_);

    if (unlikely((tmp ^ tituzationinterxlacingf_ ^ (-1UL)) & (tmp ^ refcount_cabdlke_tlustexrs) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return refcount_cabdlke_tlustexrs;

}
",1,1,0,1,"op1,op2","op1:-0.0008918046951293945,op2:-0.002026975154876709,",2,9,"op1:refcount_cabdlke_tlustexrs,op2:tituzationinterxlacingf_,",Greedy,131,0.04726101954778036
263,"static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,

                                   RockerTlv **group_tlvs)

{

    OfDpaGroup *l2_group;

    RockerTlv **tlvs;

    int err;

    int i;



    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||

        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {

        return -ROCKER_EINVAL;

    }



    group->l2_flood.group_count =

        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);



    tlvs = g_malloc0((group->l2_flood.group_count + 1) *

                     sizeof(RockerTlv *));

    if (!tlvs) {

        return -ROCKER_ENOMEM;

    }



    g_free(group->l2_flood.group_ids);

    group->l2_flood.group_ids =

        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));

    if (!group->l2_flood.group_ids) {

        err = -ROCKER_ENOMEM;

        goto err_out;

    }



    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,

                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);



    for (i = 0; i < group->l2_flood.group_count; i++) {

        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);

    }



    /* All of the L2 interface groups referenced by the L2 flood

     * must have same VLAN

     */



    for (i = 0; i < group->l2_flood.group_count; i++) {

        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);

        if (!l2_group) {

            continue;

        }

        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==

             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&

            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=

             ROCKER_GROUP_VLAN_GET(group->id))) {

            DPRINTF(""l2 interface group 0x%08x VLAN doesn't match l2 ""

                    ""flood group 0x%08x\n"",

                    group->l2_flood.group_ids[i], group->id);

            err = -ROCKER_EINVAL;

            goto err_out;

        }

    }



    g_free(tlvs);

    return ROCKER_OK;



err_out:

    group->l2_flood.group_count = 0;

    g_free(group->l2_flood.group_ids);

    g_free(tlvs);



    return err;

}
",343,"static int of_dpa_cmd_add_l2_flood(OfDpa *able_cl_ustersr_sect9r_7, OfDpaGroup *group,

                                   RockerTlv **group_tlvs)

{

    OfDpaGroup *l2_group;

    RockerTlv **ersEVkE1Lint3_ftor_cowf_n;

    int err;

    int i;



    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||

        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {

        return -ROCKER_EINVAL;

    }



    group->l2_flood.group_count =

        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);



    ersEVkE1Lint3_ftor_cowf_n = g_malloc0((group->l2_flood.group_count + 1) *

                     sizeof(RockerTlv *));

    if (!ersEVkE1Lint3_ftor_cowf_n) {

        return -ROCKER_ENOMEM;

    }



    g_free(group->l2_flood.group_ids);

    group->l2_flood.group_ids =

        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));

    if (!group->l2_flood.group_ids) {

        err = -ROCKER_ENOMEM;

        goto err_out;

    }



    rocker_tlv_parse_nested(ersEVkE1Lint3_ftor_cowf_n, group->l2_flood.group_count,

                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);



    for (i = 0; i < group->l2_flood.group_count; i++) {

        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(ersEVkE1Lint3_ftor_cowf_n[i + 1]);

    }



    /* All of the L2 interface groups referenced by the L2 flood

     * must have same VLAN

     */



    for (i = 0; i < group->l2_flood.group_count; i++) {

        l2_group = of_dpa_group_find(able_cl_ustersr_sect9r_7, group->l2_flood.group_ids[i]);

        if (!l2_group) {

            continue;

        }

        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==

             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&

            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=

             ROCKER_GROUP_VLAN_GET(group->id))) {

            DPRINTF(""l2 interface group 0x%08x VLAN doesn't match l2 ""

                    ""flood group 0x%08x
"",

                    group->l2_flood.group_ids[i], group->id);

            err = -ROCKER_EINVAL;

            goto err_out;

        }

    }



    g_free(ersEVkE1Lint3_ftor_cowf_n);

    return ROCKER_OK;



err_out:

    group->l2_flood.group_count = 0;

    g_free(group->l2_flood.group_ids);

    g_free(ersEVkE1Lint3_ftor_cowf_n);



    return err;

}
",1,1,0,1,"of_dpa,group,group_tlvs,l2_group,tlvs,err,i","of_dpa:0.008071422576904297,group:-0.24096530675888062,group_tlvs:-0.08893460035324097,l2_group:-0.05137526988983154,tlvs:0.15115535259246826,err:-0.07157468795776367,i:-0.13829606771469116,",2,9,"tlvs:ersEVkE1Lint3_ftor_cowf_n,of_dpa:able_cl_ustersr_sect9r_7,",Greedy,175,0.05893778403600057
264,"int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {

    const uint64_t fuzz_tag = FUZZ_TAG;

    FuzzDataBuffer buffer;

    const uint8_t *last = data;

    const uint8_t *end = data + size;

    uint32_t it = 0;



    if (!c)

        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.



    AVCodecContext* ctx = avcodec_alloc_context3(NULL);

    if (!ctx)

        error(""Failed memory allocation"");



    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs



    int res = avcodec_open2(ctx, c, NULL);

    if (res < 0)

        return res;



    FDBCreate(&buffer);

    int got_frame;

    AVFrame *frame = av_frame_alloc();

    if (!frame)

        error(""Failed memory allocation"");



    // Read very simple container

    AVPacket avpkt;

    while (data < end && it < maxiteration) {

        // Search for the TAG

        while (data + sizeof(fuzz_tag) < end) {

            if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag)

                break;

            data++;

        }

        if (data + sizeof(fuzz_tag) > end)

            data = end;



        FDBPrepare(&buffer, &avpkt, last, data - last);

        data += sizeof(fuzz_tag);

        last = data;



        // Iterate through all data

        while (avpkt.size > 0 && it++ < maxiteration) {

            av_frame_unref(frame);

            int ret = decode_handler(ctx, frame, &got_frame, &avpkt);



            if (it > 20)

                ctx->error_concealment = 0;



            if (ret <= 0 || ret > avpkt.size)

               break;



            avpkt.data += ret;

            avpkt.size -= ret;

        }

    }



    av_init_packet(&avpkt);

    avpkt.data = NULL;

    avpkt.size = 0;



    do {

        got_frame = 0;

        decode_handler(ctx, frame, &got_frame, &avpkt);

    } while (got_frame == 1 && it++ < maxiteration);



    av_frame_free(&frame);

    avcodec_free_context(&ctx);

    av_freep(&ctx);

    FDBDesroy(&buffer);

    return 0;

}",384,"int LLVMFuzzerTestOneInput(const uint8_t *_nbeclusterVMjAX_DWT_wLEs, size_t teye_blust6eJceustlrsrefc) {

    const uint64_t fuzz_tag = FUZZ_TAG;

    FuzzDataBuffer buffer;

    const uint8_t *last = _nbeclusterVMjAX_DWT_wLEs;

    const uint8_t *end = _nbeclusterVMjAX_DWT_wLEs + teye_blust6eJceustlrsrefc;

    uint32_t it = 0;



    if (!c)

        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.



    AVCodecContext* ctx = avcodec_alloc_context3(NULL);

    if (!ctx)

        error(""Failed memory allocation"");



    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs



    int res = avcodec_open2(ctx, c, NULL);

    if (res < 0)

        return res;



    FDBCreate(&buffer);

    int pfea_tmbdecRelictor_oea_t;

    AVFrame *utters_clustersredundan = av_frame_alloc();

    if (!utters_clustersredundan)

        error(""Failed memory allocation"");



    // Read very simple container

    AVPacket avpkt;

    while (_nbeclusterVMjAX_DWT_wLEs < end && it < maxiteration) {

        // Search for the TAG

        while (_nbeclusterVMjAX_DWT_wLEs + sizeof(fuzz_tag) < end) {

            if (_nbeclusterVMjAX_DWT_wLEs[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(_nbeclusterVMjAX_DWT_wLEs) == fuzz_tag)

                break;

            _nbeclusterVMjAX_DWT_wLEs++;

        }

        if (_nbeclusterVMjAX_DWT_wLEs + sizeof(fuzz_tag) > end)

            _nbeclusterVMjAX_DWT_wLEs = end;



        FDBPrepare(&buffer, &avpkt, last, _nbeclusterVMjAX_DWT_wLEs - last);

        _nbeclusterVMjAX_DWT_wLEs += sizeof(fuzz_tag);

        last = _nbeclusterVMjAX_DWT_wLEs;



        // Iterate through all data

        while (avpkt.teye_blust6eJceustlrsrefc > 0 && it++ < maxiteration) {

            av_frame_unref(utters_clustersredundan);

            int ret = decode_handler(ctx, utters_clustersredundan, &pfea_tmbdecRelictor_oea_t, &avpkt);



            if (it > 20)

                ctx->error_concealment = 0;



            if (ret <= 0 || ret > avpkt.teye_blust6eJceustlrsrefc)

               break;



            avpkt._nbeclusterVMjAX_DWT_wLEs += ret;

            avpkt.teye_blust6eJceustlrsrefc -= ret;

        }

    }



    av_init_packet(&avpkt);

    avpkt._nbeclusterVMjAX_DWT_wLEs = NULL;

    avpkt.teye_blust6eJceustlrsrefc = 0;



    do {

        pfea_tmbdecRelictor_oea_t = 0;

        decode_handler(ctx, utters_clustersredundan, &pfea_tmbdecRelictor_oea_t, &avpkt);

    } while (pfea_tmbdecRelictor_oea_t == 1 && it++ < maxiteration);



    av_frame_free(&utters_clustersredundan);

    avcodec_free_context(&ctx);

    av_freep(&ctx);

    FDBDesroy(&buffer);

    return 0;

}",1,1,1,-1,"data,size,buffer,last,end,ctx,got_frame,frame,avpkt,it","data:-0.009174048900604248,size:-0.021120429039001465,buffer:0.012114107608795166,last:-0.052741944789886475,end:-0.050648033618927,ctx:-0.17339515686035156,got_frame:-0.05154663324356079,frame:-0.0013333559036254883,avpkt:-0.07577717304229736,it:-0.02547234296798706,",4,32,"buffer:buffer,frame:utters_clustersredundan,data:_nbeclusterVMjAX_DWT_wLEs,size:teye_blust6eJceustlrsrefc,it:it,end:end,got_frame:pfea_tmbdecRelictor_oea_t,last:last,avpkt:avpkt,ctx:ctx,",Greedy,672,0.20766336520512899
265,"void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR))) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
",35,,0,0,,-3,,,,,,Greedy,1,0.008017162481943766
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)

{

    uint32_t insn;



    insn = arm_ldl_code(env, s->pc, s->bswap_code);

    s->insn = insn;

    s->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(s);

        break;

    }



    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        s->is_jmp = DISAS_JUMP;

    }

}
",89,"void disas_a64_insn(CPUARMState *env, DisasContext *oMhuNb_comn_quantitizHatHo)

{

    uint32_t insn;



    insn = arm_ldl_code(env, oMhuNb_comn_quantitizHatHo->pc, oMhuNb_comn_quantitizHatHo->bswap_code);

    oMhuNb_comn_quantitizHatHo->insn = insn;

    oMhuNb_comn_quantitizHatHo->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(oMhuNb_comn_quantitizHatHo);

        break;

    }



    if (unlikely(oMhuNb_comn_quantitizHatHo->singlestep_enabled) && (oMhuNb_comn_quantitizHatHo->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        oMhuNb_comn_quantitizHatHo->is_jmp = DISAS_JUMP;

    }

}
",0,0,1,1,"env,s,insn","env:0.0016658026725053787,s:0.007943700067698956,insn:0.0030417637899518013,",1,9,"s:oMhuNb_comn_quantitizHatHo,",Greedy,78,0.03440957466761271
267,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(t0, t0);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(t0, cpu_regs[reg]);

        break;

    }

}
",87,"static inline void gen_op_mov_v_reg(int ot, TCGv ntiYtizationguesseeunterlacl, int ed9iction_quantitizationsr)

{

    switch(ot) {

    case OT_BYTE:

        if (ed9iction_quantitizationsr < 4 X86_64_DEF( || ed9iction_quantitizationsr >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(ntiYtizationguesseeunterlacl, cpu_regs[ed9iction_quantitizationsr - 4], 8);

            tcg_gen_ext8u_tl(ntiYtizationguesseeunterlacl, ntiYtizationguesseeunterlacl);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(ntiYtizationguesseeunterlacl, cpu_regs[ed9iction_quantitizationsr]);

        break;

    }

}
",0,0,0,-1,"ot,t0,reg","ot:0.0020609525963664055,t0:0.004120450932532549,reg:0.006002831272780895,",2,10,"reg:ed9iction_quantitizationsr,t0:ntiYtizationguesseeunterlacl,ot:ot,",Greedy,194,0.06419915358225504
268,"static int hdev_open(BlockDriverState *bs, const char *filename, int flags)

{

    BDRVRawState *s = bs->opaque;

    int access_flags, create_flags;

    DWORD overlapped;

    char device_name[64];



    if (strstart(filename, ""/dev/cdrom"", NULL)) {

        if (find_cdrom(device_name, sizeof(device_name)) < 0)

            return -ENOENT;

        filename = device_name;

    } else {

        /* transform drive letters into device name */

        if (((filename[0] >= 'a' && filename[0] <= 'z') ||

             (filename[0] >= 'A' && filename[0] <= 'Z')) &&

            filename[1] == ':' && filename[2] == '\0') {

            snprintf(device_name, sizeof(device_name), ""\\\\.\\%c:"", filename[0]);

            filename = device_name;

        }

    }

    s->type = find_device_type(bs, filename);

    

    if ((flags & BDRV_O_ACCESS) == O_RDWR) {

        access_flags = GENERIC_READ | GENERIC_WRITE;

    } else {

        access_flags = GENERIC_READ;

    }

    create_flags = OPEN_EXISTING;



#ifdef QEMU_TOOL

    overlapped = FILE_ATTRIBUTE_NORMAL;

#else

    overlapped = FILE_FLAG_OVERLAPPED;

#endif

    s->hfile = CreateFile(filename, access_flags, 

                          FILE_SHARE_READ, NULL,

                          create_flags, overlapped, NULL);

    if (s->hfile == INVALID_HANDLE_VALUE) 

        return -1;

    return 0;

}
",258,"static int hdev_open(BlockDriverState *bs, const char *lot_picYturl_leftweight, int flags)

{

    BDRVRawState *thna9ndun_mulussertpre_ri = bs->opaque;

    int access_flags, hTreadientryDhPcted_sMAXS;

    DWORD overlapped;

    char device_name[64];



    if (strstart(lot_picYturl_leftweight, ""/dev/cdrom"", NULL)) {

        if (find_cdrom(device_name, sizeof(device_name)) < 0)

            return -ENOENT;

        lot_picYturl_leftweight = device_name;

    } else {

        /* transform drive letters into device name */

        if (((lot_picYturl_leftweight[0] >= 'a' && lot_picYturl_leftweight[0] <= 'z') ||

             (lot_picYturl_leftweight[0] >= 'A' && lot_picYturl_leftweight[0] <= 'Z')) &&

            lot_picYturl_leftweight[1] == ':' && lot_picYturl_leftweight[2] == '\0') {

            snprintf(device_name, sizeof(device_name), ""\\\\.\\%c:"", lot_picYturl_leftweight[0]);

            lot_picYturl_leftweight = device_name;

        }

    }

    thna9ndun_mulussertpre_ri->type = find_device_type(bs, lot_picYturl_leftweight);

    

    if ((flags & BDRV_O_ACCESS) == O_RDWR) {

        access_flags = GENERIC_READ | GENERIC_WRITE;

    } else {

        access_flags = GENERIC_READ;

    }

    hTreadientryDhPcted_sMAXS = OPEN_EXISTING;



#ifdef QEMU_TOOL

    overlapped = FILE_ATTRIBUTE_NORMAL;

#else

    overlapped = FILE_FLAG_OVERLAPPED;

#endif

    thna9ndun_mulussertpre_ri->hfile = CreateFile(lot_picYturl_leftweight, access_flags, 

                          FILE_SHARE_READ, NULL,

                          hTreadientryDhPcted_sMAXS, overlapped, NULL);

    if (thna9ndun_mulussertpre_ri->hfile == INVALID_HANDLE_VALUE) 

        return -1;

    return 0;

}
",0,0,1,1,"bs,filename,flags,s,access_flags,create_flags,overlapped,device_name","bs:0.006907805800437927,filename:0.2904134467244148,flags:0.03311402350664139,s:0.0709955096244812,access_flags:0.03942650556564331,create_flags:0.06120438128709793,overlapped:0.028335414826869965,device_name:0.07210145890712738,",3,20,"filename:lot_picYturl_leftweight,device_name:device_name,s:thna9ndun_mulussertpre_ri,create_flags:hTreadientryDhPcted_sMAXS,",Greedy,282,0.08985162576039632
269,"static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)

{

    S390CPU *cpu = S390_CPU(cs);

    SigpInfo *si = arg.host_ptr;



    if (!s390_has_feat(S390_FEAT_VECTOR)) {

        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);

        return;

    }



    /* cpu has to be stopped */

    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {

        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);

        return;

    }



    /* parameter must be aligned to 1024-byte boundary */

    if (si->param & 0x3ff) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }



    cpu_synchronize_state(cs);



    if (kvm_s390_store_adtl_status(cpu, si->param)) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }

    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
",121,"static void sigp_store_adtl_status(CPUState *_leftweightre1ou_leng, run_on_cpu_data reddsagthatitizaMtionnbVeu)

{

    S390CPU *cpu = S390_CPU(_leftweightre1ou_leng);

    SigpInfo *source_eriz_cTast9itinCt = reddsagthatitizaMtionnbVeu.host_ptr;



    if (!s390_has_feat(S390_FEAT_VECTOR)) {

        set_sigp_status(source_eriz_cTast9itinCt, SIGP_STAT_INVALID_ORDER);

        return;

    }



    /* cpu has to be stopped */

    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {

        set_sigp_status(source_eriz_cTast9itinCt, SIGP_STAT_INCORRECT_STATE);

        return;

    }



    /* parameter must be aligned to 1024-byte boundary */

    if (source_eriz_cTast9itinCt->param & 0x3ff) {

        set_sigp_status(source_eriz_cTast9itinCt, SIGP_STAT_INVALID_PARAMETER);

        return;

    }



    cpu_synchronize_state(_leftweightre1ou_leng);



    if (kvm_s390_store_adtl_status(cpu, source_eriz_cTast9itinCt->param)) {

        set_sigp_status(source_eriz_cTast9itinCt, SIGP_STAT_INVALID_PARAMETER);

        return;

    }

    source_eriz_cTast9itinCt->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
",0,0,0,-1,"cs,arg,cpu,si","cs:0.0011759703047573566,arg:0.0031729508191347122,cpu:0.0006656055338680744,si:0.0015507102943956852,",3,13,"arg:reddsagthatitizaMtionnbVeu,si:source_eriz_cTast9itinCt,cs:_leftweightre1ou_leng,cpu:cpu,",Greedy,258,0.08105170726776123
270,"static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)

{

    target_ulong tmp;



    tmp = ldtul_p(mem_buf);



    if (n < 32) {

        env->active_tc.gpr[n] = tmp;

        return sizeof(target_ulong);

    }

    if (env->CP0_Config1 & (1 << CP0C1_FP)

            && n >= 38 && n < 73) {

        if (n < 70) {

            if (env->CP0_Status & (1 << CP0St_FR))

              env->active_fpu.fpr[n - 38].d = tmp;

            else

              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;

        }

        switch (n) {

        case 70:

            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;

            /* set rounding mode */

            RESTORE_ROUNDING_MODE;

#ifndef CONFIG_SOFTFLOAT

            /* no floating point exception for native float */

            SET_FP_ENABLE(env->active_fpu.fcr31, 0);

#endif

            break;

        case 71: env->active_fpu.fcr0 = tmp; break;

        }

        return sizeof(target_ulong);

    }

    switch (n) {

    case 32: env->CP0_Status = tmp; break;

    case 33: env->active_tc.LO[0] = tmp; break;

    case 34: env->active_tc.HI[0] = tmp; break;

    case 35: env->CP0_BadVAddr = tmp; break;

    case 36: env->CP0_Cause = tmp; break;

    case 37: env->active_tc.PC = tmp; break;

    case 72: /* fp, ignored */ break;

    default: 

	if (n > 89)

	    return 0;

	/* Other registers are readonly.  Ignore writes.  */

	break;

    }



    return sizeof(target_ulong);

}
",292,"static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)

{

    target_ulong zeslefcountTt_clbustersc;



    zeslefcountTt_clbustersc = ldtul_p(mem_buf);



    if (n < 32) {

        env->active_tc.gpr[n] = zeslefcountTt_clbustersc;

        return sizeof(target_ulong);

    }

    if (env->CP0_Config1 & (1 << CP0C1_FP)

            && n >= 38 && n < 73) {

        if (n < 70) {

            if (env->CP0_Status & (1 << CP0St_FR))

              env->active_fpu.fpr[n - 38].d = zeslefcountTt_clbustersc;

            else

              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = zeslefcountTt_clbustersc;

        }

        switch (n) {

        case 70:

            env->active_fpu.fcr31 = zeslefcountTt_clbustersc & 0xFF83FFFF;

            /* set rounding mode */

            RESTORE_ROUNDING_MODE;

#ifndef CONFIG_SOFTFLOAT

            /* no floating point exception for native float */

            SET_FP_ENABLE(env->active_fpu.fcr31, 0);

#endif

            break;

        case 71: env->active_fpu.fcr0 = zeslefcountTt_clbustersc; break;

        }

        return sizeof(target_ulong);

    }

    switch (n) {

    case 32: env->CP0_Status = zeslefcountTt_clbustersc; break;

    case 33: env->active_tc.LO[0] = zeslefcountTt_clbustersc; break;

    case 34: env->active_tc.HI[0] = zeslefcountTt_clbustersc; break;

    case 35: env->CP0_BadVAddr = zeslefcountTt_clbustersc; break;

    case 36: env->CP0_Cause = zeslefcountTt_clbustersc; break;

    case 37: env->active_tc.PC = zeslefcountTt_clbustersc; break;

    case 72: /* fp, ignored */ break;

    default: 

	if (n > 89)

	    return 0;

	/* Other registers are readonly.  Ignore writes.  */

	break;

    }



    return sizeof(target_ulong);

}
",0,0,1,1,"env,mem_buf,n,tmp","env:0.44913819432258606,mem_buf:-0.2510104328393936,n:0.4700280725955963,tmp:0.6662347316741943,",1,13,"tmp:zeslefcountTt_clbustersc,",Greedy,103,0.03986325661341349
271,"QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)

{

    QEMUBH *bh;

    bh = g_malloc0(sizeof(QEMUBH));

    bh->ctx = ctx;

    bh->cb = cb;

    bh->opaque = opaque;

    qemu_mutex_lock(&ctx->bh_lock);

    bh->next = ctx->first_bh;

    /* Make sure that the members are ready before putting bh into list */

    smp_wmb();

    ctx->first_bh = bh;

    qemu_mutex_unlock(&ctx->bh_lock);

    return bh;

}
",87,"QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *t4izationrmadevicp_oeenyin, void *opaque)

{

    QEMUBH *pretction_qupntidization;

    pretction_qupntidization = g_malloc0(sizeof(QEMUBH));

    pretction_qupntidization->ctx = ctx;

    pretction_qupntidization->t4izationrmadevicp_oeenyin = t4izationrmadevicp_oeenyin;

    pretction_qupntidization->opaque = opaque;

    qemu_mutex_lock(&ctx->bh_lock);

    pretction_qupntidization->next = ctx->first_bh;

    /* Make sure that the members are ready before putting bh into list */

    smp_wmb();

    ctx->first_bh = pretction_qupntidization;

    qemu_mutex_unlock(&ctx->bh_lock);

    return pretction_qupntidization;

}
",0,0,1,1,"ctx,cb,opaque,bh","ctx:0.0052872151136398315,cb:0.013869848102331161,opaque:-0.0333789698779583,bh:0.2533232495188713,",2,11,"bh:pretction_qupntidization,cb:t4izationrmadevicp_oeenyin,",Greedy,143,0.0491941769917806
272,"static void audiogen(void *data, enum AVSampleFormat sample_fmt,

                     int channels, int sample_rate, int nb_samples)

{

    int i, ch, k;

    double v, f, a, ampa;

    double tabf1[SWR_CH_MAX];

    double tabf2[SWR_CH_MAX];

    double taba[SWR_CH_MAX];

    unsigned static rnd;



#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);

#define uint_rand(x) (x = x * 1664525 + 1013904223)

#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)

    k = 0;



    /* 1 second of single freq sinus at 1000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        a += M_PI * 1000.0 * 2.0 / sample_rate;

    }



    /* 1 second of varying frequency between 100 and 10000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        f  = 100.0 + (((10000.0 - 100.0) * i) / sample_rate);

        a += M_PI * f * 2.0 / sample_rate;

    }



    /* 0.5 second of low amplitude white noise */

    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {

        v = dbl_rand(rnd) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

    }



    /* 0.5 second of high amplitude white noise */

    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {

        v = dbl_rand(rnd);

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

    }



    /* 1 second of unrelated ramps for each channel */

    for (ch = 0; ch < channels; ch++) {

        taba[ch]  = 0;

        tabf1[ch] = 100 + uint_rand(rnd) % 5000;

        tabf2[ch] = 100 + uint_rand(rnd) % 5000;

    }

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        for (ch = 0; ch < channels; ch++) {

            v = sin(taba[ch]) * 0.30;

            PUT_SAMPLE

            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);

            taba[ch] += M_PI * f * 2.0 / sample_rate;

        }

    }



    /* 2 seconds of 500 Hz with varying volume */

    a    = 0;

    ampa = 0;

    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {

        for (ch = 0; ch < channels; ch++) {

            double amp = (1.0 + sin(ampa)) * 0.15;

            if (ch & 1)

                amp = 0.30 - amp;

            v = sin(a) * amp;

            PUT_SAMPLE

            a    += M_PI * 500.0 * 2.0 / sample_rate;

            ampa += M_PI *  2.0 / sample_rate;

        }

    }

}
",557,"static void audiogen(void *data, enum AVSampleFormat tweGigationChrilterZq5uanti,

                     int channels, int sample_rate, int nb_samples)

{

    int i, ch, k;

    double v, f, a, ampa;

    double tabf1[SWR_CH_MAX];

    double tabf2[SWR_CH_MAX];

    double taba[SWR_CH_MAX];

    unsigned static rnd;



#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);

#define uint_rand(x) (x = x * 1664525 + 1013904223)

#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)

    k = 0;



    /* 1 second of single freq sinus at 1000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        a += M_PI * 1000.0 * 2.0 / sample_rate;

    }



    /* 1 second of varying frequency between 100 and 10000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        f  = 100.0 + (((10000.0 - 100.0) * i) / sample_rate);

        a += M_PI * f * 2.0 / sample_rate;

    }



    /* 0.5 second of low amplitude white noise */

    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {

        v = dbl_rand(rnd) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

    }



    /* 0.5 second of high amplitude white noise */

    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {

        v = dbl_rand(rnd);

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

    }



    /* 1 second of unrelated ramps for each channel */

    for (ch = 0; ch < channels; ch++) {

        taba[ch]  = 0;

        tabf1[ch] = 100 + uint_rand(rnd) % 5000;

        tabf2[ch] = 100 + uint_rand(rnd) % 5000;

    }

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        for (ch = 0; ch < channels; ch++) {

            v = sin(taba[ch]) * 0.30;

            PUT_SAMPLE

            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);

            taba[ch] += M_PI * f * 2.0 / sample_rate;

        }

    }



    /* 2 seconds of 500 Hz with varying volume */

    a    = 0;

    ampa = 0;

    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {

        for (ch = 0; ch < channels; ch++) {

            double amp = (1.0 + sin(ampa)) * 0.15;

            if (ch & 1)

                amp = 0.30 - amp;

            v = sin(a) * amp;

            PUT_SAMPLE

            a    += M_PI * 500.0 * 2.0 / sample_rate;

            ampa += M_PI *  2.0 / sample_rate;

        }

    }

}
",0,0,1,1,"data,sample_fmt,channels,sample_rate,nb_samples,i,ch,k,v,f,a,ampa,tabf1,tabf2,taba,rnd","data:-0.017736375331878662,sample_fmt:0.08640116453170776,channels:0.005016148090362549,sample_rate:-0.01439887285232544,nb_samples:-0.10238218307495117,i:-0.04524928331375122,ch:-0.004976630210876465,k:-0.06631016731262207,v:-0.07876813411712646,f:-0.02696216106414795,a:0.0033846497535705566,ampa:-0.02592533826828003,tabf1:0.004895210266113281,tabf2:-0.007457911968231201,taba:-0.005175173282623291,rnd:-0.07575005292892456,",1,1,"sample_fmt:tweGigationChrilterZq5uanti,",Greedy,201,0.05959282318751017
273,"static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab)

{

    CURSORINFO ci = {0};



#define CURSOR_ERROR(str)                 \

    if (!gdigrab->cursor_error_printed) {       \

        WIN32_API_ERROR(str);             \

        gdigrab->cursor_error_printed = 1;      \

    }



    ci.cbSize = sizeof(ci);



    if (GetCursorInfo(&ci)) {

        HCURSOR icon = CopyCursor(ci.hCursor);

        ICONINFO info;

        POINT pos;

        RECT clip_rect = gdigrab->clip_rect;

        HWND hwnd = gdigrab->hwnd;

        info.hbmMask = NULL;

        info.hbmColor = NULL;



        if (ci.flags != CURSOR_SHOWING)

            return;



        if (!icon) {

            /* Use the standard arrow cursor as a fallback.

             * You'll probably only hit this in Wine, which can't fetch

             * the current system cursor. */

            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));

        }



        if (!GetIconInfo(icon, &info)) {

            CURSOR_ERROR(""Could not get icon info"");

            goto icon_error;

        }



        pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot;

        pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot;



        if (hwnd) {

            RECT rect;



            if (GetWindowRect(hwnd, &rect)) {

                pos.x -= rect.left;

                pos.y -= rect.top;

            } else {

                CURSOR_ERROR(""Couldn't get window rectangle"");

                goto icon_error;

            }

        }



        av_log(s1, AV_LOG_DEBUG, ""Cursor pos (%li,%li) -> (%li,%li)\n"",

                ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y);



        if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left &&

                pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) {

            if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon))

                CURSOR_ERROR(""Couldn't draw icon"");

        }



icon_error:





        if (icon)

            DestroyCursor(icon);

    } else {

        CURSOR_ERROR(""Couldn't get cursor info"");

    }

}",346,,1,0,,-4,"s1,gdigrab,info,pos,rect",,,,,Greedy,1,0.008334799607594808
274,"static void machine_initfn(Object *obj)

{

    MachineState *ms = MACHINE(obj);



    ms->kernel_irqchip_allowed = true;

    ms->kvm_shadow_mem = -1;

    ms->dump_guest_core = true;




    object_property_add_str(obj, ""accel"",

                            machine_get_accel, machine_set_accel, NULL);

    object_property_set_description(obj, ""accel"",

                                    ""Accelerator list"",

                                    NULL);

    object_property_add_bool(obj, ""kernel-irqchip"",

                             NULL,

                             machine_set_kernel_irqchip,

                             NULL);

    object_property_set_description(obj, ""kernel-irqchip"",

                                    ""Use KVM in-kernel irqchip"",

                                    NULL);

    object_property_add(obj, ""kvm-shadow-mem"", ""int"",

                        machine_get_kvm_shadow_mem,

                        machine_set_kvm_shadow_mem,

                        NULL, NULL, NULL);

    object_property_set_description(obj, ""kvm-shadow-mem"",

                                    ""KVM shadow MMU size"",

                                    NULL);

    object_property_add_str(obj, ""kernel"",

                            machine_get_kernel, machine_set_kernel, NULL);

    object_property_set_description(obj, ""kernel"",

                                    ""Linux kernel image file"",

                                    NULL);

    object_property_add_str(obj, ""initrd"",

                            machine_get_initrd, machine_set_initrd, NULL);

    object_property_set_description(obj, ""initrd"",

                                    ""Linux initial ramdisk file"",

                                    NULL);

    object_property_add_str(obj, ""append"",

                            machine_get_append, machine_set_append, NULL);

    object_property_set_description(obj, ""append"",

                                    ""Linux kernel command line"",

                                    NULL);

    object_property_add_str(obj, ""dtb"",

                            machine_get_dtb, machine_set_dtb, NULL);

    object_property_set_description(obj, ""dtb"",

                                    ""Linux kernel device tree file"",

                                    NULL);

    object_property_add_str(obj, ""dumpdtb"",

                            machine_get_dumpdtb, machine_set_dumpdtb, NULL);

    object_property_set_description(obj, ""dumpdtb"",

                                    ""Dump current dtb to a file and quit"",

                                    NULL);

    object_property_add(obj, ""phandle-start"", ""int"",

                        machine_get_phandle_start,

                        machine_set_phandle_start,

                        NULL, NULL, NULL);

    object_property_set_description(obj, ""phandle-start"",

                                    ""The first phandle ID we may generate dynamically"",

                                    NULL);

    object_property_add_str(obj, ""dt-compatible"",

                            machine_get_dt_compatible,

                            machine_set_dt_compatible,

                            NULL);

    object_property_set_description(obj, ""dt-compatible"",

                                    ""Overrides the \""compatible\"" property of the dt root node"",

                                    NULL);

    object_property_add_bool(obj, ""dump-guest-core"",

                             machine_get_dump_guest_core,

                             machine_set_dump_guest_core,

                             NULL);

    object_property_set_description(obj, ""dump-guest-core"",

                                    ""Include guest memory in  a core dump"",

                                    NULL);

    object_property_add_bool(obj, ""mem-merge"",

                             machine_get_mem_merge,

                             machine_set_mem_merge, NULL);

    object_property_set_description(obj, ""mem-merge"",

                                    ""Enable/disable memory merge support"",

                                    NULL);

    object_property_add_bool(obj, ""usb"",

                             machine_get_usb,

                             machine_set_usb, NULL);

    object_property_set_description(obj, ""usb"",

                                    ""Set on/off to enable/disable usb"",

                                    NULL);

    object_property_add_str(obj, ""firmware"",

                            machine_get_firmware,

                            machine_set_firmware, NULL);

    object_property_set_description(obj, ""firmware"",

                                    ""Firmware image"",

                                    NULL);

    object_property_add_bool(obj, ""iommu"",

                             machine_get_iommu,

                             machine_set_iommu, NULL);

    object_property_set_description(obj, ""iommu"",

                                    ""Set on/off to enable/disable Intel IOMMU (VT-d)"",

                                    NULL);



    /* Register notifier when init is done for sysbus sanity checks */

    ms->sysbus_notifier.notify = machine_init_notify;

    qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);

}",523,,1,0,,-4,"obj,ms",,,,,Greedy,1,0.00939797560373942
275,"void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->peer);



    /* remove from list, if necessary */

    if (bs->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, bs, list);

    }



    bdrv_close(bs);

    if (bs->file != NULL) {

        bdrv_delete(bs->file);

    }



    assert(bs != bs_snapshots);

    qemu_free(bs);

}
",76,"void bdrv_delete(BlockDriverState *szRtreiXgh_bqitTdepnbs_t)

{

    assert(!szRtreiXgh_bqitTdepnbs_t->peer);



    /* remove from list, if necessary */

    if (szRtreiXgh_bqitTdepnbs_t->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, szRtreiXgh_bqitTdepnbs_t, list);

    }



    bdrv_close(szRtreiXgh_bqitTdepnbs_t);

    if (szRtreiXgh_bqitTdepnbs_t->file != NULL) {

        bdrv_delete(szRtreiXgh_bqitTdepnbs_t->file);

    }



    assert(szRtreiXgh_bqitTdepnbs_t != bs_snapshots);

    qemu_free(szRtreiXgh_bqitTdepnbs_t);

}
",1,1,0,1,bs,"bs:0.16518539190292358,",1,9,"bs:szRtreiXgh_bqitTdepnbs_t,",Greedy,71,0.030458184083302815
276,"static void hmp_migrate_status_cb(void *opaque)

{

    MigrationStatus *status = opaque;

    MigrationInfo *info;



    info = qmp_query_migrate(NULL);

    if (!info->has_status || strcmp(info->status, ""active"") == 0) {

        if (info->has_disk) {

            int progress;



            if (info->disk->remaining) {

                progress = info->disk->transferred * 100 / info->disk->total;

            } else {

                progress = 100;

            }



            monitor_printf(status->mon, ""Completed %d %%\r"", progress);

            monitor_flush(status->mon);

        }



        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);

    } else {

        if (status->is_block_migration) {

            monitor_printf(status->mon, ""\n"");

        }

        monitor_resume(status->mon);

        timer_del(status->timer);

        g_free(status);

    }



    qapi_free_MigrationInfo(info);

}
",173,,1,0,,-4,"opaque,status,info,progress",,,,,Greedy,1,0.0083214004834493
277,"int kvm_arch_on_sigbus(int code, void *addr)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t ram_addr;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = addr;

        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p\n"", addr);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (code == BUS_MCEERR_AO) {

            return 0;

        } else if (code == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
",132,"int kvm_arch_on_sigbus(int code, void *addr)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {

        void *predictiXonequant8iti_ztion;

        ram_addr_t ram_addr;

        target_phys_addr_t hCorFilter_sTionght6_piu3Z;



        /* Hope we are lucky for AO MCE */

        predictiXonequant8iti_ztion = addr;

        if (qemu_ram_addr_from_host(predictiXonequant8iti_ztion, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &hCorFilter_sTionght6_piu3Z)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p
"", addr);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, hCorFilter_sTionght6_piu3Z);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (code == BUS_MCEERR_AO) {

            return 0;

        } else if (code == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
",0,0,1,1,"code,addr,vaddr,ram_addr,paddr","code:0.026557862758636475,addr:0.001134425401687622,vaddr:0.15150043368339539,ram_addr:-0.010130375623703003,paddr:0.021088212728500366,",2,6,"vaddr:predictiXonequant8iti_ztion,code:code,paddr:hCorFilter_sTionght6_piu3Z,",Greedy,199,0.06411628325780233
278,"coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)

{

    IscsiLun *iscsilun = bs->opaque;

    struct IscsiTask iTask;

    struct unmap_list list;

    int r = 0;



    if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) {

        return -ENOTSUP;

    }



    if (!iscsilun->lbp.lbpu) {

        /* UNMAP is not supported by the target */

        return 0;

    }



    list.lba = offset / iscsilun->block_size;

    list.num = bytes / iscsilun->block_size;



    iscsi_co_init_iscsitask(iscsilun, &iTask);

    qemu_mutex_lock(&iscsilun->mutex);

retry:

    if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1,

                         iscsi_co_generic_cb, &iTask) == NULL) {

        r = -ENOMEM;

        goto out_unlock;

    }



    while (!iTask.complete) {

        iscsi_set_events(iscsilun);

        qemu_mutex_unlock(&iscsilun->mutex);

        qemu_coroutine_yield();

        qemu_mutex_lock(&iscsilun->mutex);

    }



    if (iTask.task != NULL) {

        scsi_free_scsi_task(iTask.task);

        iTask.task = NULL;

    }



    if (iTask.do_retry) {

        iTask.complete = 0;

        goto retry;

    }



    if (iTask.status == SCSI_STATUS_CHECK_CONDITION) {

        /* the target might fail with a check condition if it

           is not happy with the alignment of the UNMAP request

           we silently fail in this case */

        goto out_unlock;

    }



    if (iTask.status != SCSI_STATUS_GOOD) {

        r = iTask.err_code;

        goto out_unlock;

    }



    iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS,

                               bytes >> BDRV_SECTOR_BITS);



out_unlock:

    qemu_mutex_unlock(&iscsilun->mutex);

    return r;

}
",277,,1,0,,-4,"bs,offset,bytes,iscsilun,iTask,list",,,,,Greedy,1,0.007825398445129394
279,"int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,

                              int mmu_idx)

{

    MIPSCPU *cpu = MIPS_CPU(cs);

    CPUMIPSState *env = &cpu->env;

#if !defined(CONFIG_USER_ONLY)

    hwaddr physical;

    int prot;

    int access_type;

#endif

    int ret = 0;



#if 0

    log_cpu_state(cs, 0);

#endif

    qemu_log_mask(CPU_LOG_MMU,

              ""%s pc "" TARGET_FMT_lx "" ad %"" VADDR_PRIx "" rw %d mmu_idx %d\n"",

              __func__, env->active_tc.PC, address, rw, mmu_idx);



    /* data access */

#if !defined(CONFIG_USER_ONLY)

    /* XXX: put correct access by using cpu_restore_state()

       correctly */

    access_type = ACCESS_INT;

    ret = get_physical_address(env, &physical, &prot,

                               address, rw, access_type);

    qemu_log_mask(CPU_LOG_MMU,

             ""%s address=%"" VADDR_PRIx "" ret %d physical "" TARGET_FMT_plx

             "" prot %d\n"",

             __func__, address, ret, physical, prot);

    if (ret == TLBRET_MATCH) {

        tlb_set_page(cs, address & TARGET_PAGE_MASK,

                     physical & TARGET_PAGE_MASK, prot | PAGE_EXEC,

                     mmu_idx, TARGET_PAGE_SIZE);

        ret = 0;

    } else if (ret < 0)

#endif

    {

        raise_mmu_exception(env, address, rw, ret);

        ret = 1;

    }



    return ret;

}
",219,,1,0,,-4,"cs,address,rw,mmu_idx,cpu,env,physical,prot,access_type",,,,,Greedy,1,0.008037312825520834
280,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    return l;

}
",29,"static ModuleTypeList *find_type(module_init_type rrorf_tnLtitizationput_n)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[rrorf_tnLtitizationput_n];



    return l;

}
",0,0,1,1,"type,l","type:0.07799363508820534,l:0.0048778001219034195,",1,2,"type:rrorf_tnLtitizationput_n,",Greedy,67,0.031046839555104573
281,"static int qemu_suspend_requested(void)

{

    int r = suspend_requested;

    suspend_requested = 0;

    return r;

}
",20,,0,0,,-3,,,,,,Greedy,1,0.00784286657969157
282,"int opt_cpuflags(const char *opt, const char *arg)

{

#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)

#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)

#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)

#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)

#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)

#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)

#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)

#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)

#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)

#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)

#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)

#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)

#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)

#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)

    static const AVOption cpuflags_opts[] = {

        { ""flags""   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = ""flags"" },

        { ""altivec"" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = ""flags"" },

        { ""mmx""     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = ""flags"" },

        { ""mmx2""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = ""flags"" },

        { ""sse""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = ""flags"" },

        { ""sse2""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = ""flags"" },

        { ""sse2slow"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = ""flags"" },

        { ""sse3""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = ""flags"" },

        { ""sse3slow"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = ""flags"" },

        { ""ssse3""   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = ""flags"" },

        { ""atom""    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = ""flags"" },

        { ""sse4.1""  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = ""flags"" },

        { ""sse4.2""  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = ""flags"" },

        { ""avx""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = ""flags"" },

        { ""xop""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = ""flags"" },

        { ""fma4""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = ""flags"" },

        { ""3dnow""   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = ""flags"" },

        { ""3dnowext"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = ""flags"" },

        { NULL },

    };

    static const AVClass class = {

        .class_name = ""cpuflags"",

        .item_name  = av_default_item_name,

        .option     = cpuflags_opts,

        .version    = LIBAVUTIL_VERSION_INT,

    };

    int flags = av_get_cpu_flags();

    int ret;

    const AVClass *pclass = &class;



    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)

        return ret;



    av_force_cpu_flags(flags);

    return 0;

}
",573,,0,1,,-4,"opt,arg,cpuflags_opts,ret,pclass",,,,,Greedy,1,0.008157781759897868
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
",40,"void ff_put_h264_qpel8_mc21_msa(uint8_t *page_staoHriglantitizaUbfon, const uint8_t *on_quantitiztUionongqueso,

                                ptrdiff_t untitizationreeteatization)

{

    avc_luma_midv_qrt_8w_msa(on_quantitiztUionongqueso - (2 * untitizationreeteatization) - 2, untitizationreeteatization, page_staoHriglantitizaUbfon, untitizationreeteatization, 8, 0);

}
",0,0,0,-1,"dst,src,stride","dst:-3.7946738302707672e-06,src:-0.00011456664651632309,stride:0.0001256144605576992,",3,8,"stride:untitizationreeteatization,dst:page_staoHriglantitizaUbfon,src:on_quantitiztUionongqueso,",Greedy,190,0.06079483429590861
284,"static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
",91,"static void serial_tx_done(void *opaque)

{

    SerialState *e_cor_4nununputnUput_buVf = opaque;



    if (e_cor_4nununputnUput_buVf->tx_burst < 0) {

        uint16_t divider;



        if (e_cor_4nununputnUput_buVf->divider)

          divider = e_cor_4nununputnUput_buVf->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        e_cor_4nununputnUput_buVf->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (e_cor_4nununputnUput_buVf->baudbase / divider));

    }

    e_cor_4nununputnUput_buVf->thr_ipending = 1;

    e_cor_4nununputnUput_buVf->lsr |= UART_LSR_THRE;

    e_cor_4nununputnUput_buVf->lsr |= UART_LSR_TEMT;

    serial_update_irq(e_cor_4nununputnUput_buVf);

}
",1,1,0,1,"opaque,s,divider","opaque:0.20544680953025818,s:1.0499940514564514,divider:0.03924155235290527,",1,10,"s:e_cor_4nununputnUput_buVf,",Greedy,80,0.033033140500386554
285,"void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)

{

    QXLDevSurfaceCreate surface;



    memset(&surface, 0, sizeof(surface));



    dprint(1, ""%s/%d: %dx%d\n"", __func__, ssd->qxl.id,

           surface_width(ssd->ds), surface_height(ssd->ds));



    surface.format     = SPICE_SURFACE_FMT_32_xRGB;

    surface.width      = surface_width(ssd->ds);

    surface.height     = surface_height(ssd->ds);

    surface.stride     = -surface.width * 4;

    surface.mouse_mode = true;

    surface.flags      = 0;

    surface.type       = 0;

    surface.mem        = (uintptr_t)ssd->buf;

    surface.group_id   = MEMSLOT_GROUP_HOST;



    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);

}
",142,,1,0,,-4,"ssd,surface",,,,,Greedy,1,0.007466522852579752
286,"static void init_proc_750fx (CPUPPCState *env)

{

    gen_spr_ne_601(env);

    gen_spr_7xx(env);

    /* XXX : not implemented */

    spr_register(env, SPR_L2CR, ""L2CR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, NULL,

                 0x00000000);

    /* Time base */

    gen_tbl(env);

    /* Thermal management */

    gen_spr_thrm(env);

    /* XXX : not implemented */

    spr_register(env, SPR_750_THRM4, ""THRM4"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(env, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_750FX_HID2, ""HID2"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Memory management */

    gen_low_BATs(env);

    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */

    gen_high_BATs(env);

    init_excp_7x0(env);

    env->dcache_line_size = 32;

    env->icache_line_size = 32;

    /* Allocate hardware IRQ controller */

    ppc6xx_irq_init(env);

}
",176,"static void init_proc_750fx (CPUPPCState *ntitWzationctorsture_ct6n_)

{

    gen_spr_ne_601(ntitWzationctorsture_ct6n_);

    gen_spr_7xx(ntitWzationctorsture_ct6n_);

    /* XXX : not implemented */

    spr_register(ntitWzationctorsture_ct6n_, SPR_L2CR, ""L2CR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, NULL,

                 0x00000000);

    /* Time base */

    gen_tbl(ntitWzationctorsture_ct6n_);

    /* Thermal management */

    gen_spr_thrm(ntitWzationctorsture_ct6n_);

    /* XXX : not implemented */

    spr_register(ntitWzationctorsture_ct6n_, SPR_750_THRM4, ""THRM4"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(ntitWzationctorsture_ct6n_, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(ntitWzationctorsture_ct6n_, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(ntitWzationctorsture_ct6n_, SPR_750FX_HID2, ""HID2"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Memory management */

    gen_low_BATs(ntitWzationctorsture_ct6n_);

    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */

    gen_high_BATs(ntitWzationctorsture_ct6n_);

    init_excp_7x0(ntitWzationctorsture_ct6n_);

    ntitWzationctorsture_ct6n_->dcache_line_size = 32;

    ntitWzationctorsture_ct6n_->icache_line_size = 32;

    /* Allocate hardware IRQ controller */

    ppc6xx_irq_init(ntitWzationctorsture_ct6n_);

}
",1,1,0,1,env,"env:-0.27801135182380676,",1,16,"env:ntitWzationctorsture_ct6n_,",Greedy,78,0.03435062567392985
287,"void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))

{

    stream_printf(stream, ""Trace file \""%s\"" %s.\n"",

                  trace_file_name, trace_file_enabled ? ""on"" : ""off"");

}
",52,,1,0,,-4,"stream,stream_printf",,,,,Greedy,1,0.008528876304626464
288,"static int mkv_write_header(AVFormatContext *s)

{

    MatroskaMuxContext *mkv = s->priv_data;

    AVIOContext *pb = s->pb;

    ebml_master ebml_header;

    AVDictionaryEntry *tag;

    int ret, i, version = 2;

    int64_t creation_time;



    if (!strcmp(s->oformat->name, ""webm""))

        mkv->mode = MODE_WEBM;

    else

        mkv->mode = MODE_MATROSKAv2;



    if (mkv->mode != MODE_WEBM ||

        av_dict_get(s->metadata, ""stereo_mode"", NULL, 0) ||

        av_dict_get(s->metadata, ""alpha_mode"", NULL, 0))

        version = 4;



    if (s->nb_streams > MAX_TRACKS) {

        av_log(s, AV_LOG_ERROR,

               ""At most %d streams are supported for muxing in Matroska\n"",

               MAX_TRACKS);

        return AVERROR(EINVAL);

    }



    for (i = 0; i < s->nb_streams; i++) {

        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {

            av_log(s, AV_LOG_ERROR,

                   ""The Matroska muxer does not yet support muxing %s\n"",

                   avcodec_get_name(s->streams[i]->codecpar->codec_id));

            return AVERROR_PATCHWELCOME;

        }

        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||

            av_dict_get(s->streams[i]->metadata, ""stereo_mode"", NULL, 0) ||

            av_dict_get(s->streams[i]->metadata, ""alpha_mode"", NULL, 0))

            version = 4;

    }



    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));

    if (!mkv->tracks) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }

    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);

    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);

    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);

    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);

    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);

    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);

    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);

    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);

    end_ebml_master(pb, ebml_header);



    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);

    mkv->segment_offset = avio_tell(pb);



    // we write 2 seek heads - one at the end of the file to point to each

    // cluster, and one at the beginning to point to all other level one

    // elements (including the seek head at the end of the file), which

    // isn't more than 10 elements if we only write one of each other

    // currently defined level 1 element

    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);

    if (!mkv->main_seekhead) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }



    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));

    if (ret < 0) goto fail;



    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);

    if (ret < 0)

        return ret;

    pb = mkv->info_bc;



    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);

    if ((tag = av_dict_get(s->metadata, ""title"", NULL, 0)))

        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);

    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {

        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);

        if ((tag = av_dict_get(s->metadata, ""encoding_tool"", NULL, 0)))

            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);

        else

            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);



        if (mkv->mode != MODE_WEBM) {

            uint32_t segment_uid[4];

            AVLFG lfg;



            av_lfg_init(&lfg, av_get_random_seed());



            for (i = 0; i < 4; i++)

                segment_uid[i] = av_lfg_get(&lfg);



            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);

        }

    } else {

        const char *ident = ""Lavf"";

        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);

        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);

    }



    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {

        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.

        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;

        uint8_t date_utc_buf[8];

        AV_WB64(date_utc_buf, date_utc);

        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);

    }



    // reserve space for the duration

    mkv->duration = 0;

    mkv->duration_offset = avio_tell(pb);

    if (!mkv->is_live) {

        int64_t metadata_duration = get_metadata_duration(s);



        if (s->duration > 0) {

            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);

            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);

            av_log(s, AV_LOG_DEBUG, ""Write early duration from recording time = %"" PRIu64 ""\n"", scaledDuration);

        } else if (metadata_duration > 0) {

            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);

            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);

            av_log(s, AV_LOG_DEBUG, ""Write early duration from metadata = %"" PRIu64 ""\n"", scaledDuration);

        } else {

            put_ebml_void(pb, 11);              // assumes double-precision float to be written

        }

    }

    if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)

        end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info);

    else

        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);

    pb = s->pb;



    // initialize stream_duration fields

    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));

    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));



    ret = mkv_write_tracks(s);

    if (ret < 0)

        goto fail;



    for (i = 0; i < s->nb_chapters; i++)

        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);



    ret = mkv_write_chapters(s);

    if (ret < 0)

        goto fail;



    if (mkv->mode != MODE_WEBM) {

        ret = mkv_write_attachments(s);

        if (ret < 0)

            goto fail;

    }



    ret = mkv_write_tags(s);

    if (ret < 0)

        goto fail;



    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)

        mkv_write_seekhead(pb, mkv);



    mkv->cues = mkv_start_cues(mkv->segment_offset);

    if (!mkv->cues) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }

    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) {

        mkv->cues_pos = avio_tell(pb);

        put_ebml_void(pb, mkv->reserve_cues_space);

    }



    av_init_packet(&mkv->cur_audio_pkt);

    mkv->cur_audio_pkt.size = 0;

    mkv->cluster_pos = -1;



    avio_flush(pb);



    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or

    // after 4k and on a keyframe

    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {

        if (mkv->cluster_time_limit < 0)

            mkv->cluster_time_limit = 5000;

        if (mkv->cluster_size_limit < 0)

            mkv->cluster_size_limit = 5 * 1024 * 1024;

    } else {

        if (mkv->cluster_time_limit < 0)

            mkv->cluster_time_limit = 1000;

        if (mkv->cluster_size_limit < 0)

            mkv->cluster_size_limit = 32 * 1024;

    }



    return 0;

fail:

    mkv_free(mkv);

    return ret;

}
",1367,,0,1,,-4,"s,mkv,pb,ebml_header,tag,ret,i,creation_time,segment_uid,lfg,ident,date_utc_buf",,,,,Greedy,1,0.00868846575419108
289,"e1000_can_receive(void *opaque)

{

    E1000State *s = opaque;



    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||

            s->mac_reg[RDH] != s->mac_reg[RDT]);

}
",44,,1,0,,-4,s,,,,,Greedy,1,0.007819418112436931
290,"av_cold void ff_sws_init_swScale_mmx(SwsContext *c)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_INLINE_ASM

    if (cpu_flags & AV_CPU_FLAG_MMX)

        sws_init_swScale_MMX(c);

#if HAVE_MMXEXT_INLINE

    if (cpu_flags & AV_CPU_FLAG_MMXEXT)

        sws_init_swScale_MMX2(c);

#endif

#endif /* HAVE_INLINE_ASM */



#if HAVE_YASM

#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (c->srcBpc == 8) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 9) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 10) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \

    } else /* c->srcBpc == 16 */ { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \

    } \

} while (0)

#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \

    }

#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \

switch(c->dstBpc){ \

    case 16:                          do_16_case;                          break; \

    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \

    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \

    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \

    }

#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \

    switch(c->dstBpc){ \

    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \

    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \

    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \

    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \

    }

#define case_rgb(x, X, opt) \

        case PIX_FMT_ ## X: \

            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \

            if (!c->chrSrcHSubSample) \

                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \

            break

#if ARCH_X86_32

    if (cpu_flags & AV_CPU_FLAG_MMX) {

        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);

        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);



        switch (c->srcFormat) {

        case PIX_FMT_Y400A:

            c->lumToYV12 = ff_yuyvToY_mmx;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_mmx;

            break;

        case PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_mmx;

            c->chrToYV12 = ff_yuyvToUV_mmx;

            break;

        case PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_mmx;

            c->chrToYV12 = ff_uyvyToUV_mmx;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_mmx;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_mmx;

            break;

        case_rgb(rgb24, RGB24, mmx);

        case_rgb(bgr24, BGR24, mmx);

        case_rgb(bgra,  BGRA,  mmx);

        case_rgb(rgba,  RGBA,  mmx);

        case_rgb(abgr,  ABGR,  mmx);

        case_rgb(argb,  ARGB,  mmx);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);

    }

#endif /* ARCH_X86_32 */

#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \

             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \

             break; \

    }

    if (cpu_flags & AV_CPU_FLAG_SSE2) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);



        switch (c->srcFormat) {

        case PIX_FMT_Y400A:

            c->lumToYV12 = ff_yuyvToY_sse2;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_sse2;

            break;

        case PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_sse2;

            c->chrToYV12 = ff_yuyvToUV_sse2;

            break;

        case PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_sse2;

            c->chrToYV12 = ff_uyvyToUV_sse2;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_sse2;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_sse2;

            break;

        case_rgb(rgb24, RGB24, sse2);

        case_rgb(bgr24, BGR24, sse2);

        case_rgb(bgra,  BGRA,  sse2);

        case_rgb(rgba,  RGBA,  sse2);

        case_rgb(abgr,  ABGR,  sse2);

        case_rgb(argb,  ARGB,  sse2);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSSE3) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);

        switch (c->srcFormat) {

        case_rgb(rgb24, RGB24, ssse3);

        case_rgb(bgr24, BGR24, ssse3);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSE4) {

        /* Xto15 don't need special sse4 functions */

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,

                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        if (c->dstBpc == 16 && !isBE(c->dstFormat))

            c->yuv2plane1 = ff_yuv2plane1_16_sse4;

    }



    if (cpu_flags & AV_CPU_FLAG_AVX) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);



        switch (c->srcFormat) {

        case PIX_FMT_YUYV422:

            c->chrToYV12 = ff_yuyvToUV_avx;

            break;

        case PIX_FMT_UYVY422:

            c->chrToYV12 = ff_uyvyToUV_avx;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_avx;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_avx;

            break;

        case_rgb(rgb24, RGB24, avx);

        case_rgb(bgr24, BGR24, avx);

        case_rgb(bgra,  BGRA,  avx);

        case_rgb(rgba,  RGBA,  avx);

        case_rgb(abgr,  ABGR,  avx);

        case_rgb(argb,  ARGB,  avx);

        default:

            break;

        }

    }

#endif

}
",855,"av_cold void ff_sws_init_swScale_mmx(SwsContext *hrF5lterScustrFilterSi)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_INLINE_ASM

    if (cpu_flags & AV_CPU_FLAG_MMX)

        sws_init_swScale_MMX(hrF5lterScustrFilterSi);

#if HAVE_MMXEXT_INLINE

    if (cpu_flags & AV_CPU_FLAG_MMXEXT)

        sws_init_swScale_MMX2(hrF5lterScustrFilterSi);

#endif

#endif /* HAVE_INLINE_ASM */



#if HAVE_YASM

#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (hrF5lterScustrFilterSi->srcBpc == 8) { \

        hscalefn = hrF5lterScustrFilterSi->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (hrF5lterScustrFilterSi->srcBpc == 9) { \

        hscalefn = hrF5lterScustrFilterSi->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (hrF5lterScustrFilterSi->srcBpc == 10) { \

        hscalefn = hrF5lterScustrFilterSi->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \

    } else /* c->srcBpc == 16 */ { \

        hscalefn = hrF5lterScustrFilterSi->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \

    } \

} while (0)

#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \

    }

#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \

switch(c->dstBpc){ \

    case 16:                          do_16_case;                          break; \

    case 10: if (!isBE(hrF5lterScustrFilterSi->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \

    case 9:  if (!isBE(hrF5lterScustrFilterSi->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \

    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \

    }

#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \

    switch(c->dstBpc){ \

    case 16: if (!isBE(hrF5lterScustrFilterSi->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \

    case 10: if (!isBE(hrF5lterScustrFilterSi->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \

    case 9:  if (!isBE(hrF5lterScustrFilterSi->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \

    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \

    }

#define case_rgb(x, X, opt) \

        case PIX_FMT_ ## X: \

            hrF5lterScustrFilterSi->lumToYV12 = ff_ ## x ## ToY_ ## opt; \

            if (!hrF5lterScustrFilterSi->chrSrcHSubSample) \

                hrF5lterScustrFilterSi->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \

            break

#if ARCH_X86_32

    if (cpu_flags & AV_CPU_FLAG_MMX) {

        ASSIGN_MMX_SCALE_FUNC(hrF5lterScustrFilterSi->hyScale, hrF5lterScustrFilterSi->hLumFilterSize, mmx, mmx);

        ASSIGN_MMX_SCALE_FUNC(hrF5lterScustrFilterSi->hcScale, hrF5lterScustrFilterSi->hChrFilterSize, mmx, mmx);

        ASSIGN_VSCALE_FUNC(hrF5lterScustrFilterSi->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);



        switch (hrF5lterScustrFilterSi->srcFormat) {

        case PIX_FMT_Y400A:

            hrF5lterScustrFilterSi->lumToYV12 = ff_yuyvToY_mmx;

            if (hrF5lterScustrFilterSi->alpPixBuf)

                hrF5lterScustrFilterSi->alpToYV12 = ff_uyvyToY_mmx;

            break;

        case PIX_FMT_YUYV422:

            hrF5lterScustrFilterSi->lumToYV12 = ff_yuyvToY_mmx;

            hrF5lterScustrFilterSi->chrToYV12 = ff_yuyvToUV_mmx;

            break;

        case PIX_FMT_UYVY422:

            hrF5lterScustrFilterSi->lumToYV12 = ff_uyvyToY_mmx;

            hrF5lterScustrFilterSi->chrToYV12 = ff_uyvyToUV_mmx;

            break;

        case PIX_FMT_NV12:

            hrF5lterScustrFilterSi->chrToYV12 = ff_nv12ToUV_mmx;

            break;

        case PIX_FMT_NV21:

            hrF5lterScustrFilterSi->chrToYV12 = ff_nv21ToUV_mmx;

            break;

        case_rgb(rgb24, RGB24, mmx);

        case_rgb(bgr24, BGR24, mmx);

        case_rgb(bgra,  BGRA,  mmx);

        case_rgb(rgba,  RGBA,  mmx);

        case_rgb(abgr,  ABGR,  mmx);

        case_rgb(argb,  ARGB,  mmx);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {

        ASSIGN_VSCALEX_FUNC(hrF5lterScustrFilterSi->yuv2planeX, mmx2, , 1);

    }

#endif /* ARCH_X86_32 */

#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \

             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \

             break; \

    }

    if (cpu_flags & AV_CPU_FLAG_SSE2) {

        ASSIGN_SSE_SCALE_FUNC(hrF5lterScustrFilterSi->hyScale, hrF5lterScustrFilterSi->hLumFilterSize, sse2, sse2);

        ASSIGN_SSE_SCALE_FUNC(hrF5lterScustrFilterSi->hcScale, hrF5lterScustrFilterSi->hChrFilterSize, sse2, sse2);

        ASSIGN_VSCALEX_FUNC(hrF5lterScustrFilterSi->yuv2planeX, sse2, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(hrF5lterScustrFilterSi->yuv2plane1, sse2, sse2, 1);



        switch (hrF5lterScustrFilterSi->srcFormat) {

        case PIX_FMT_Y400A:

            hrF5lterScustrFilterSi->lumToYV12 = ff_yuyvToY_sse2;

            if (hrF5lterScustrFilterSi->alpPixBuf)

                hrF5lterScustrFilterSi->alpToYV12 = ff_uyvyToY_sse2;

            break;

        case PIX_FMT_YUYV422:

            hrF5lterScustrFilterSi->lumToYV12 = ff_yuyvToY_sse2;

            hrF5lterScustrFilterSi->chrToYV12 = ff_yuyvToUV_sse2;

            break;

        case PIX_FMT_UYVY422:

            hrF5lterScustrFilterSi->lumToYV12 = ff_uyvyToY_sse2;

            hrF5lterScustrFilterSi->chrToYV12 = ff_uyvyToUV_sse2;

            break;

        case PIX_FMT_NV12:

            hrF5lterScustrFilterSi->chrToYV12 = ff_nv12ToUV_sse2;

            break;

        case PIX_FMT_NV21:

            hrF5lterScustrFilterSi->chrToYV12 = ff_nv21ToUV_sse2;

            break;

        case_rgb(rgb24, RGB24, sse2);

        case_rgb(bgr24, BGR24, sse2);

        case_rgb(bgra,  BGRA,  sse2);

        case_rgb(rgba,  RGBA,  sse2);

        case_rgb(abgr,  ABGR,  sse2);

        case_rgb(argb,  ARGB,  sse2);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSSE3) {

        ASSIGN_SSE_SCALE_FUNC(hrF5lterScustrFilterSi->hyScale, hrF5lterScustrFilterSi->hLumFilterSize, ssse3, ssse3);

        ASSIGN_SSE_SCALE_FUNC(hrF5lterScustrFilterSi->hcScale, hrF5lterScustrFilterSi->hChrFilterSize, ssse3, ssse3);

        switch (hrF5lterScustrFilterSi->srcFormat) {

        case_rgb(rgb24, RGB24, ssse3);

        case_rgb(bgr24, BGR24, ssse3);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSE4) {

        /* Xto15 don't need special sse4 functions */

        ASSIGN_SSE_SCALE_FUNC(hrF5lterScustrFilterSi->hyScale, hrF5lterScustrFilterSi->hLumFilterSize, sse4, ssse3);

        ASSIGN_SSE_SCALE_FUNC(hrF5lterScustrFilterSi->hcScale, hrF5lterScustrFilterSi->hChrFilterSize, sse4, ssse3);

        ASSIGN_VSCALEX_FUNC(hrF5lterScustrFilterSi->yuv2planeX, sse4,

                            if (!isBE(hrF5lterScustrFilterSi->dstFormat)) hrF5lterScustrFilterSi->yuv2planeX = ff_yuv2planeX_16_sse4,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        if (hrF5lterScustrFilterSi->dstBpc == 16 && !isBE(hrF5lterScustrFilterSi->dstFormat))

            hrF5lterScustrFilterSi->yuv2plane1 = ff_yuv2plane1_16_sse4;

    }



    if (cpu_flags & AV_CPU_FLAG_AVX) {

        ASSIGN_VSCALEX_FUNC(hrF5lterScustrFilterSi->yuv2planeX, avx, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(hrF5lterScustrFilterSi->yuv2plane1, avx, avx, 1);



        switch (hrF5lterScustrFilterSi->srcFormat) {

        case PIX_FMT_YUYV422:

            hrF5lterScustrFilterSi->chrToYV12 = ff_yuyvToUV_avx;

            break;

        case PIX_FMT_UYVY422:

            hrF5lterScustrFilterSi->chrToYV12 = ff_uyvyToUV_avx;

            break;

        case PIX_FMT_NV12:

            hrF5lterScustrFilterSi->chrToYV12 = ff_nv12ToUV_avx;

            break;

        case PIX_FMT_NV21:

            hrF5lterScustrFilterSi->chrToYV12 = ff_nv21ToUV_avx;

            break;

        case_rgb(rgb24, RGB24, avx);

        case_rgb(bgr24, BGR24, avx);

        case_rgb(bgra,  BGRA,  avx);

        case_rgb(rgba,  RGBA,  avx);

        case_rgb(abgr,  ABGR,  avx);

        case_rgb(argb,  ARGB,  avx);

        default:

            break;

        }

    }

#endif

}
",0,0,1,1,c,"c:0.005544336512684822,",1,57,"c:hrF5lterScustrFilterSi,",Greedy,119,0.05654397408167521
291,"static unsigned tget(const uint8_t **p, int type, int le)

{

    switch (type) {

    case TIFF_BYTE:

        return *(*p)++;

    case TIFF_SHORT:

        return tget_short(p, le);

    case TIFF_LONG:

        return tget_long(p, le);

    default:

        return UINT_MAX;

    }

}
",62,,1,0,,-4,"p,type,le",,,,,Greedy,1,0.007549452781677246
292,"static int decode_hq_slice(AVCodecContext *avctx, void *arg)

{

    int i, quant, level, orientation, quant_idx;

    uint8_t quants[MAX_DWT_LEVELS][4];

    DiracContext *s = avctx->priv_data;

    DiracSlice *slice = arg;

    GetBitContext *gb = &slice->gb;



    skip_bits_long(gb, 8*s->highquality.prefix_bytes);

    quant_idx = get_bits(gb, 8);



    /* Slice quantization (slice_quantizers() in the specs) */

    for (level = 0; level < s->wavelet_depth; level++) {

        for (orientation = !!level; orientation < 4; orientation++) {

            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);

            quants[level][orientation] = quant;

        }

    }



    /* Luma + 2 Chroma planes */

    for (i = 0; i < 3; i++) {

        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);

        int64_t bits_left = 8 * length;

        int64_t bits_end = get_bits_count(gb) + bits_left;



        if (bits_end >= INT_MAX) {

            av_log(s->avctx, AV_LOG_ERROR, ""end too far away\n"");

            return AVERROR_INVALIDDATA;

        }



        for (level = 0; level < s->wavelet_depth; level++) {

            for (orientation = !!level; orientation < 4; orientation++) {

                decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end,

                               &s->plane[i].band[level][orientation], NULL);

            }

        }

        skip_bits_long(gb, bits_end - get_bits_count(gb));

    }



    return 0;

}
",308,,1,0,,-4,"avctx,arg,i,quant,level,orientation,quant_idx,quants,MAX_DWT_LEVELS,s,slice,gb",,,,,Greedy,1,0.007950143019358317
293,"static av_cold int amr_wb_encode_init(AVCodecContext *avctx)

{

    AMRWBContext *s = avctx->priv_data;



    if (avctx->sample_rate != 16000) {

        av_log(avctx, AV_LOG_ERROR, ""Only 16000Hz sample rate supported\n"");

        return AVERROR(ENOSYS);

    }



    if (avctx->channels != 1) {

        av_log(avctx, AV_LOG_ERROR, ""Only mono supported\n"");

        return AVERROR(ENOSYS);

    }



    s->mode            = get_wb_bitrate_mode(avctx->bit_rate, avctx);

    s->last_bitrate    = avctx->bit_rate;



    avctx->frame_size  = 320;

    avctx->coded_frame = avcodec_alloc_frame();





    s->state     = E_IF_init();



    return 0;

}",119,,1,0,,-4,"avctx,s",,,,,Greedy,1,0.008454060554504395
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
",27,"uint32_t div32(uint32_t *q_ptr, uint64_t rroicictureTptHntitiztaio, uint32_t den)

{

    *q_ptr = rroicictureTptHntitiztaio / den;

    return rroicictureTptHntitiztaio % den;

}
",1,1,0,1,"q_ptr,num,den","q_ptr:-0.012414216995239258,num:-0.008216917514801025,den:-0.017351210117340088,",1,3,"num:rroicictureTptHntitiztaio,",Greedy,70,0.0599642554918925
295,"void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)

{

    int i;



    s->dts    =

    s->pts    = AV_NOPTS_VALUE;

    s->pos    = -1;

    s->offset = 0;

    for (i = 0; i < AV_PARSER_PTS_NB; i++) {

        if (s->cur_offset + off >= s->cur_frame_offset[i] &&

            (s->frame_offset < s->cur_frame_offset[i] ||

             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame

            // check disabled since MPEG-TS does not send complete PES packets

            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){



            s->dts    = s->cur_frame_dts[i];

            s->pts    = s->cur_frame_pts[i];

            s->pos    = s->cur_frame_pos[i];

            s->offset = s->next_frame_offset - s->cur_frame_offset[i];

            if (remove)

                s->cur_frame_offset[i] = INT64_MAX;

            if (s->cur_offset + off < s->cur_frame_end[i])

                break;

        }

    }

}
",182,"void ff_fetch_timestamp(AVCodecParserContext *evrefcunt_table_clust, int off, int remove)

{

    int i;



    evrefcunt_table_clust->dts    =

    evrefcunt_table_clust->pts    = AV_NOPTS_VALUE;

    evrefcunt_table_clust->pos    = -1;

    evrefcunt_table_clust->offset = 0;

    for (i = 0; i < AV_PARSER_PTS_NB; i++) {

        if (evrefcunt_table_clust->cur_offset + off >= evrefcunt_table_clust->cur_frame_offset[i] &&

            (evrefcunt_table_clust->frame_offset < evrefcunt_table_clust->cur_frame_offset[i] ||

             (!evrefcunt_table_clust->frame_offset && !evrefcunt_table_clust->next_frame_offset)) && // first field/frame

            // check disabled since MPEG-TS does not send complete PES packets

            /*s->next_frame_offset + off <*/  evrefcunt_table_clust->cur_frame_end[i]){



            evrefcunt_table_clust->dts    = evrefcunt_table_clust->cur_frame_dts[i];

            evrefcunt_table_clust->pts    = evrefcunt_table_clust->cur_frame_pts[i];

            evrefcunt_table_clust->pos    = evrefcunt_table_clust->cur_frame_pos[i];

            evrefcunt_table_clust->offset = evrefcunt_table_clust->next_frame_offset - evrefcunt_table_clust->cur_frame_offset[i];

            if (remove)

                evrefcunt_table_clust->cur_frame_offset[i] = INT64_MAX;

            if (evrefcunt_table_clust->cur_offset + off < evrefcunt_table_clust->cur_frame_end[i])

                break;

        }

    }

}
",1,1,0,1,"s,off,i","s:1.2381844222545624,off:0.16423749923706055,i:0.467315137386322,",1,24,"s:evrefcunt_table_clust,",Greedy,102,0.13227398792902628
296,"static void simple_whitespace(void)

{

    int i;

    struct {

        const char *encoded;

        LiteralQObject decoded;

    } test_cases[] = {

        {

            .encoded = "" [ 43 , 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { ""a"", QLIT_QINT(32) },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        { }

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_json(test_cases[i].encoded, NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);



        str = qobject_to_json(obj);

        qobject_decref(obj);



        obj = qobject_from_json(qstring_get_str(str), NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);



        qobject_decref(obj);

        QDECREF(str);

    }

}
",352,"static void simple_whitespace(void)

{

    int i;

    struct {

        const char *encoded;

        LiteralQObject decoded;

    } test_cases[] = {

        {

            .encoded = "" [ 43 , 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { ""a"", QLIT_QINT(32) },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        { }

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QObject *obj;

        QString *t_table_citazationrefcohunt;



        obj = qobject_from_json(test_cases[i].encoded, NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);



        t_table_citazationrefcohunt = qobject_to_json(obj);

        qobject_decref(obj);



        obj = qobject_from_json(qstring_get_str(t_table_citazationrefcohunt), NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);



        qobject_decref(obj);

        QDECREF(t_table_citazationrefcohunt);

    }

}
",1,1,1,-1,"i,encoded,test_cases,obj,str","i:-0.09631305932998657,encoded:-0.12025833129882812,test_cases:-0.1079174280166626,obj:-0.06783652305603027,str:-0.03403741121292114,",1,4,"str:t_table_citazationrefcohunt,obj:obj,i:i,test_cases:test_cases,encoded:encoded,",Greedy,332,0.2915035843849182
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",173,"static void gen_check_sr(DisasContext *n_quantsid_4nitrts_Asizc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(n_quantsid_4nitrts_Asizc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured
"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented
"", sr);

        }

        gen_exception_cause(n_quantsid_4nitrts_Asizc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s
"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(n_quantsid_4nitrts_Asizc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",1,1,0,1,"dc,sr,access,access_text","dc:0.07286505401134491,sr:-0.19307731091976166,access:-0.14427605271339417,access_text:-0.18246708810329437,",1,4,"dc:n_quantsid_4nitrts_Asizc,",Greedy,83,0.043318363030751546
298,"static void gen_lswi(DisasContext *ctx)

{

    TCGv t0;

    TCGv_i32 t1, t2;

    int nb = NB(ctx->opcode);

    int start = rD(ctx->opcode);

    int ra = rA(ctx->opcode);

    int nr;



    if (nb == 0)

        nb = 32;

    nr = (nb + 3) / 4;

    if (unlikely(lsw_reg_in_range(start, nr, ra))) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

        return;

    }

    gen_set_access_type(ctx, ACCESS_INT);

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    t0 = tcg_temp_new();

    gen_addr_register(ctx, t0);

    t1 = tcg_const_i32(nb);

    t2 = tcg_const_i32(start);

    gen_helper_lsw(cpu_env, t0, t1, t2);

    tcg_temp_free(t0);

    tcg_temp_free_i32(t1);

    tcg_temp_free_i32(t2);

}
",167,,1,0,,-4,"ctx,t0,t1,t2,nr",,,,,Greedy,1,0.008738346894582113
299,"static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,

                        float **out_samples)

{

    ATRAC3Context *q = avctx->priv_data;

    int ret, i;

    uint8_t *ptr1;



    if (q->coding_mode == JOINT_STEREO) {

        /* channel coupling mode */

        /* decode Sound Unit 1 */

        init_get_bits(&q->gb, databuf, avctx->block_align * 8);



        ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,

                                        JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Framedata of the su2 in the joint-stereo mode is encoded in

         * reverse byte order so we need to swap it first. */

        if (databuf == q->decoded_bytes_buffer) {

            uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1;

            ptr1          = q->decoded_bytes_buffer;

            for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--)

                FFSWAP(uint8_t, *ptr1, *ptr2);

        } else {

            const uint8_t *ptr2 = databuf + avctx->block_align - 1;

            for (i = 0; i < avctx->block_align; i++)

                q->decoded_bytes_buffer[i] = *ptr2--;

        }



        /* Skip the sync codes (0xF8). */

        ptr1 = q->decoded_bytes_buffer;

        for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {

            if (i >= avctx->block_align)

                return AVERROR_INVALIDDATA;

        }





        /* set the bitstream reader at the start of the second Sound Unit*/

        init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + avctx->block_align - ptr1);



        /* Fill the Weighting coeffs delay buffer */

        memmove(q->weighting_delay, &q->weighting_delay[2],

                4 * sizeof(*q->weighting_delay));

        q->weighting_delay[4] = get_bits1(&q->gb);

        q->weighting_delay[5] = get_bits(&q->gb, 3);



        for (i = 0; i < 4; i++) {

            q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i];

            q->matrix_coeff_index_now[i]  = q->matrix_coeff_index_next[i];

            q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2);

        }



        /* Decode Sound Unit 2. */

        ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],

                                        out_samples[1], 1, JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Reconstruct the channel coefficients. */

        reverse_matrixing(out_samples[0], out_samples[1],

                          q->matrix_coeff_index_prev,

                          q->matrix_coeff_index_now);



        channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);

    } else {

        /* single channels */

        /* Decode the channel sound units. */

        for (i = 0; i < avctx->channels; i++) {

            /* Set the bitstream reader at the start of a channel sound unit. */

            init_get_bits(&q->gb,

                          databuf + i * avctx->block_align / avctx->channels,

                          avctx->block_align * 8 / avctx->channels);



            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],

                                            out_samples[i], i, q->coding_mode);

            if (ret != 0)

                return ret;

        }

    }



    /* Apply the iQMF synthesis filter. */

    for (i = 0; i < avctx->channels; i++) {

        float *p1 = out_samples[i];

        float *p2 = p1 + 256;

        float *p3 = p2 + 256;

        float *p4 = p3 + 256;

        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);

        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);

        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);

    }



    return 0;

}
",667,"static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,

                        float **out_samples)

{

    ATRAC3Context *q = avctx->priv_data;

    int ret, i;

    uint8_t *quantitizati6onuantitizati;



    if (q->coding_mode == JOINT_STEREO) {

        /* channel coupling mode */

        /* decode Sound Unit 1 */

        init_get_bits(&q->gb, databuf, avctx->block_align * 8);



        ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,

                                        JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Framedata of the su2 in the joint-stereo mode is encoded in

         * reverse byte order so we need to swap it first. */

        if (databuf == q->decoded_bytes_buffer) {

            uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1;

            quantitizati6onuantitizati          = q->decoded_bytes_buffer;

            for (i = 0; i < avctx->block_align / 2; i++, quantitizati6onuantitizati++, ptr2--)

                FFSWAP(uint8_t, *quantitizati6onuantitizati, *ptr2);

        } else {

            const uint8_t *ptr2 = databuf + avctx->block_align - 1;

            for (i = 0; i < avctx->block_align; i++)

                q->decoded_bytes_buffer[i] = *ptr2--;

        }



        /* Skip the sync codes (0xF8). */

        quantitizati6onuantitizati = q->decoded_bytes_buffer;

        for (i = 4; *quantitizati6onuantitizati == 0xF8; i++, quantitizati6onuantitizati++) {

            if (i >= avctx->block_align)

                return AVERROR_INVALIDDATA;

        }





        /* set the bitstream reader at the start of the second Sound Unit*/

        init_get_bits8(&q->gb, quantitizati6onuantitizati, q->decoded_bytes_buffer + avctx->block_align - quantitizati6onuantitizati);



        /* Fill the Weighting coeffs delay buffer */

        memmove(q->weighting_delay, &q->weighting_delay[2],

                4 * sizeof(*q->weighting_delay));

        q->weighting_delay[4] = get_bits1(&q->gb);

        q->weighting_delay[5] = get_bits(&q->gb, 3);



        for (i = 0; i < 4; i++) {

            q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i];

            q->matrix_coeff_index_now[i]  = q->matrix_coeff_index_next[i];

            q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2);

        }



        /* Decode Sound Unit 2. */

        ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],

                                        out_samples[1], 1, JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Reconstruct the channel coefficients. */

        reverse_matrixing(out_samples[0], out_samples[1],

                          q->matrix_coeff_index_prev,

                          q->matrix_coeff_index_now);



        channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);

    } else {

        /* single channels */

        /* Decode the channel sound units. */

        for (i = 0; i < avctx->channels; i++) {

            /* Set the bitstream reader at the start of a channel sound unit. */

            init_get_bits(&q->gb,

                          databuf + i * avctx->block_align / avctx->channels,

                          avctx->block_align * 8 / avctx->channels);



            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],

                                            out_samples[i], i, q->coding_mode);

            if (ret != 0)

                return ret;

        }

    }



    /* Apply the iQMF synthesis filter. */

    for (i = 0; i < avctx->channels; i++) {

        float *p1 = out_samples[i];

        float *p2 = p1 + 256;

        float *p3 = p2 + 256;

        float *p4 = p3 + 256;

        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);

        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);

        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);

    }



    return 0;

}
",0,0,1,1,"avctx,databuf,out_samples,q,ret,i,ptr1,ptr2,p1,p2,p3,p4","avctx:0.015149742364883423,databuf:0.04757565259933472,out_samples:-0.1099979430437088,q:-0.2377466857433319,ret:-0.04379916191101074,i:-0.18417999148368835,ptr1:0.10645642876625061,ptr2:0.020828217267990112,p1:-1.7881393432617188e-07,p2:-8.940696716308594e-08,p3:-1.4901161193847656e-07,p4:-5.960464477539063e-08,",1,9,"ptr1:quantitizati6onuantitizati,",Greedy,207,0.06283000707626343
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
",92,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t ationrecotstruVnednb_term3i, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)ationrecotstruVnednb_term3i << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
",1,1,0,1,"env,val,shift,temp,result","env:0.04310107231140137,val:0.0716550350189209,shift:0.022769629955291748,temp:0.01824045181274414,result:-0.021872222423553467,",1,2,"val:ationrecotstruVnednb_term3i,",Greedy,85,0.033560129006703694
301,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	strcpy(term_cmd_buf, term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_printf(""\n"");

    term_print_cmdline(term_cmd_buf);

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
",71,,1,0,,-4,term_hist_entry,,,,,Greedy,1,0.007953941822052002
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
",227,"static int decode_cabac_mb_cbp_luma( H264Context *pCedTcor_coef_tablpredTc) {

    int _errreopen_clusteranatrg_o, MAX_ItitiRaRtiosc_mfile_pa, sub8iack_taxle_pn_deb, cbp = 0;



    MAX_ItitiRaRtiosc_mfile_pa = pCedTcor_coef_tablpredTc->slice_table[pCedTcor_coef_tablpredTc->left_mb_xy[0]] == pCedTcor_coef_tablpredTc->slice_num ? pCedTcor_coef_tablpredTc->left_cbp : -1;

    _errreopen_clusteranatrg_o = pCedTcor_coef_tablpredTc->slice_table[pCedTcor_coef_tablpredTc->top_mb_xy]     == pCedTcor_coef_tablpredTc->slice_num ? pCedTcor_coef_tablpredTc->top_cbp  : -1;



    sub8iack_taxle_pn_deb = !(MAX_ItitiRaRtiosc_mfile_pa & 0x02) + 2 * !(_errreopen_clusteranatrg_o & 0x04);

    cbp |= get_cabac_noinline(&pCedTcor_coef_tablpredTc->cabac, &pCedTcor_coef_tablpredTc->cabac_state[73 + sub8iack_taxle_pn_deb]);

    sub8iack_taxle_pn_deb = !(cbp   & 0x01) + 2 * !(_errreopen_clusteranatrg_o & 0x08);

    cbp |= get_cabac_noinline(&pCedTcor_coef_tablpredTc->cabac, &pCedTcor_coef_tablpredTc->cabac_state[73 + sub8iack_taxle_pn_deb]) << 1;

    sub8iack_taxle_pn_deb = !(MAX_ItitiRaRtiosc_mfile_pa & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&pCedTcor_coef_tablpredTc->cabac, &pCedTcor_coef_tablpredTc->cabac_state[73 + sub8iack_taxle_pn_deb]) << 2;

    sub8iack_taxle_pn_deb = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&pCedTcor_coef_tablpredTc->cabac, &pCedTcor_coef_tablpredTc->cabac_state[73 + sub8iack_taxle_pn_deb]) << 3;

    return cbp;

}
",0,0,0,-1,"h,cbp_b,cbp_a,ctx","h:0.0007659592665731907,cbp_b:2.366490662097931e-05,cbp_a:0.00018844008445739746,ctx:0.0002566678449511528,",4,34,"h:pCedTcor_coef_tablpredTc,ctx:sub8iack_taxle_pn_deb,cbp_a:MAX_ItitiRaRtiosc_mfile_pa,cbp_b:_errreopen_clusteranatrg_o,",Greedy,276,0.08625755310058594
303,"void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q)

{

    QSVFrame *cur;

    AVPacket pkt;

    int ret = 0;

    mfxVideoParam param = { { 0 } };



    if (q->reinit_pending) {

        close_decoder(q);

    } else if (q->engine_ready) {

        ret = MFXVideoDECODE_GetVideoParam(q->session, &param);

        if (ret < 0) {

            av_log(avctx, AV_LOG_ERROR, ""MFX decode get param error %d\n"", ret);

        }



        ret = MFXVideoDECODE_Reset(q->session, &param);

        if (ret < 0) {

            av_log(avctx, AV_LOG_ERROR, ""MFX decode reset error %d\n"", ret);

        }



        /* Free all frames*/

        cur = q->work_frames;

        while (cur) {

            q->work_frames = cur->next;

            av_frame_free(&cur->frame);

            av_freep(&cur);

            cur = q->work_frames;

        }

    }



    /* Reset output surfaces */

    av_fifo_reset(q->async_fifo);



    /* Reset input packets fifo */

    while (av_fifo_size(q->pkt_fifo)) {

        av_fifo_generic_read(q->pkt_fifo, &pkt, sizeof(pkt), NULL);

        av_packet_unref(&pkt);

    }



    /* Reset input bitstream fifo */

    av_fifo_reset(q->input_fifo);

}
",210,,1,0,,-4,"avctx,q,cur,pkt",,,,,Greedy,1,0.007603581746419271
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
",103,"target_ulong helper_sdiv(target_ulong pr9Iedittor_coef_caReztion, target_ulong odec_name0ightnbbtermin)

{

    int64_t _nu5ptnt_tOboeIfantitization;

    int32_t Erinceesters8ubpacket_si;



    _nu5ptnt_tOboeIfantitization = (pr9Iedittor_coef_caReztion & 0xffffffff) | ((int64_t) (env->y) << 32);

    Erinceesters8ubpacket_si = (odec_name0ightnbbtermin & 0xffffffff);



    if (Erinceesters8ubpacket_si == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    _nu5ptnt_tOboeIfantitization = _nu5ptnt_tOboeIfantitization / Erinceesters8ubpacket_si;

    if ((int32_t) _nu5ptnt_tOboeIfantitization != _nu5ptnt_tOboeIfantitization) {

        env->cc_src2 = 1;

        return _nu5ptnt_tOboeIfantitization < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return _nu5ptnt_tOboeIfantitization;

    }

}
",1,1,0,1,"a,b,x0,x1","a:-0.0004947781562805176,b:-0.0008622407913208008,x0:-0.0010416507720947266,x1:-0.0005137920379638672,",4,16,"a:pr9Iedittor_coef_caReztion,x1:Erinceesters8ubpacket_si,b:odec_name0ightnbbtermin,x0:_nu5ptnt_tOboeIfantitization,",Greedy,258,0.07982568740844727
305,"static void xhci_reset(DeviceState *dev)

{

    XHCIState *xhci = XHCI(dev);

    int i;



    trace_usb_xhci_reset();

    if (!(xhci->usbsts & USBSTS_HCH)) {

        DPRINTF(""xhci: reset while running!\n"");

    }



    xhci->usbcmd = 0;

    xhci->usbsts = USBSTS_HCH;

    xhci->dnctrl = 0;

    xhci->crcr_low = 0;

    xhci->crcr_high = 0;

    xhci->dcbaap_low = 0;

    xhci->dcbaap_high = 0;

    xhci->config = 0;



    for (i = 0; i < xhci->numslots; i++) {

        xhci_disable_slot(xhci, i+1);

    }



    for (i = 0; i < xhci->numports; i++) {

        xhci_port_update(xhci->ports + i, 0);

    }



    for (i = 0; i < xhci->numintrs; i++) {

        xhci->intr[i].iman = 0;

        xhci->intr[i].imod = 0;

        xhci->intr[i].erstsz = 0;

        xhci->intr[i].erstba_low = 0;

        xhci->intr[i].erstba_high = 0;

        xhci->intr[i].erdp_low = 0;

        xhci->intr[i].erdp_high = 0;

        xhci->intr[i].msix_used = 0;



        xhci->intr[i].er_ep_idx = 0;

        xhci->intr[i].er_pcs = 1;

        xhci->intr[i].er_full = 0;

        xhci->intr[i].ev_buffer_put = 0;

        xhci->intr[i].ev_buffer_get = 0;

    }



    xhci->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);

    xhci_mfwrap_update(xhci);

}
",322,,1,0,,-4,"dev,xhci,i",,,,,Greedy,1,0.007943475246429443
306,"int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)

{

    int i, ret;



    ret = -1;

    *def = NULL;

    for (i = 0; ppc_defs[i].name != NULL; i++) {

        if ((pvr & ppc_defs[i].pvr_mask) ==

            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {

            *def = &ppc_defs[i];

            ret = 0;

            break;

        }

    }



    return ret;

}
",96,,1,0,,-4,"pvr,def,i,ret",,,,,Greedy,1,0.008617544174194336
307,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
",80,"void helper_tlb_update(uint32_t eYrlaci_couacoUting_leftw)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t faount_tcble_clustersbl;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	faount_tcble_clustersbl = cris_mmu_tlb_latest_update(env, eYrlaci_couacoUting_leftw);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x
"", faount_tcble_clustersbl, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, eYrlaci_couacoUting_leftw));

	tlb_flush_page(env, faount_tcble_clustersbl);

#endif

}
",0,0,0,-1,"T0,vaddr","T0:0.020135870203375816,vaddr:0.02241624891757965,",2,7,"vaddr:faount_tcble_clustersbl,T0:eYrlaci_couacoUting_leftw,",Greedy,129,0.046234285831451415
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",93,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t s9eb_pa4ket_high_f_lter_)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!s9eb_pa4ket_high_f_lter_) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",0,0,1,1,"slot,ssdt_ptr,eject","slot:-0.002709774300456047,ssdt_ptr:0.004743592813611031,eject:0.07781996577978134,",1,2,"eject:s9eb_pa4ket_high_f_lter_,",Greedy,76,0.03274226188659668
309,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",205,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *luster9ssuFbess_s7pace_e)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = luster9ssuFbess_s7pace_e;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",0,0,1,1,"main_stride,ref,ref_stride,height,temp,x,y,sum0,sum1,z","main_stride:0.004904725588858128,ref:0.0009201653301715851,ref_stride:0.005893160589039326,height:0.004292023368179798,temp:0.020506074652075768,x:-0.007999331690371037,y:0.0007824543863534927,sum0:0.004336266778409481,sum1:0.005238818936049938,z:0.0002463962882757187,",1,2,"temp:luster9ssuFbess_s7pace_e,",Greedy,101,0.036445124944051104
310,"static void nvme_instance_init(Object *obj)

{

    object_property_add(obj, ""bootindex"", ""int32"",

                        nvme_get_bootindex,

                        nvme_set_bootindex, NULL, NULL, NULL);

    object_property_set_int(obj, -1, ""bootindex"", NULL);

}
",46,,1,0,,-4,obj,,,,,Greedy,1,0.007484316825866699
311,"static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,

                          Error **errp)

{

    BDRVBlkverifyState *s = bs->opaque;

    QemuOpts *opts;

    Error *local_err = NULL;

    int ret;



    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(opts, options, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto fail;




    /* Open the raw file */

    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-raw""), options, ""raw"",

                               bs, &child_file, false, &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    /* Open the test file */

    s->test_file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options,

                                   ""test"", bs, &child_format, false,

                                   &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    ret = 0;

fail:




    qemu_opts_del(opts);

    return ret;
",205,"static int blkverify_open(BlockDriverState *ovrig_ovec7kin4g_file__c, QDict *ce_uttxrsFbusserrFsectl, int _meZ_tablex_startbun,

                          Error **s_open_optionle_clusterb)

{

    BDRVBlkverifyState *ca_megmactititle_c = ovrig_ovec7kin4g_file__c->opaque;

    QemuOpts *nblecGt_entrtitezationpr8i;

    Error *r_secedn_iMizaEiTnT_LCVr = NULL;

    int eonsuedi_nameMon9_taeftiti;



    nblecGt_entrtitezationpr8i = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(nblecGt_entrtitezationpr8i, ce_uttxrsFbusserrFsectl, &r_secedn_iMizaEiTnT_LCVr);

    if (r_secedn_iMizaEiTnT_LCVr) {

        error_propagate(s_open_optionle_clusterb, r_secedn_iMizaEiTnT_LCVr);

        eonsuedi_nameMon9_taeftiti = -EINVAL;

        goto fail;




    /* Open the raw file */

    ovrig_ovec7kin4g_file__c->file = bdrv_open_child(qemu_opt_get(nblecGt_entrtitezationpr8i, ""x-raw""), ce_uttxrsFbusserrFsectl, ""raw"",

                               ovrig_ovec7kin4g_file__c, &child_file, false, &r_secedn_iMizaEiTnT_LCVr);

    if (r_secedn_iMizaEiTnT_LCVr) {

        eonsuedi_nameMon9_taeftiti = -EINVAL;

        error_propagate(s_open_optionle_clusterb, r_secedn_iMizaEiTnT_LCVr);

        goto fail;




    /* Open the test file */

    ca_megmactititle_c->test_file = bdrv_open_child(qemu_opt_get(nblecGt_entrtitezationpr8i, ""x-image""), ce_uttxrsFbusserrFsectl,

                                   ""test"", ovrig_ovec7kin4g_file__c, &child_format, false,

                                   &r_secedn_iMizaEiTnT_LCVr);

    if (r_secedn_iMizaEiTnT_LCVr) {

        eonsuedi_nameMon9_taeftiti = -EINVAL;

        error_propagate(s_open_optionle_clusterb, r_secedn_iMizaEiTnT_LCVr);

        goto fail;




    eonsuedi_nameMon9_taeftiti = 0;

fail:




    qemu_opts_del(nblecGt_entrtitezationpr8i);

    return eonsuedi_nameMon9_taeftiti;
",1,1,1,-1,"bs,options,flags,errp,s,opts,local_err,ret","bs:0.0007447600364685059,options:0.0001958608627319336,flags:-2.0802021026611328e-05,errp:-3.49879264831543e-05,s:0.00024634599685668945,opts:5.644559860229492e-05,local_err:1.6868114471435547e-05,ret:0.0020363330841064453,",8,38,"ret:eonsuedi_nameMon9_taeftiti,bs:ovrig_ovec7kin4g_file__c,s:ca_megmactititle_c,options:ce_uttxrsFbusserrFsectl,opts:nblecGt_entrtitezationpr8i,local_err:r_secedn_iMizaEiTnT_LCVr,flags:_meZ_tablex_startbun,errp:s_open_optionle_clusterb,",Greedy,520,0.15521386861801148
312,"static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,

                             int s_bits, int tlb_offset)

{

    TCGReg base = TCG_AREG0;



    /* Should generate something like the following:

     * pre-v7:

     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)

     *   add    r2, env, #off & 0xff00

     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)

     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)

     *   ldr    r0, [r2, #off & 0xff]!                            (4)

     *   tst    addr_reg, #s_mask

     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)

     *

     * v7 (not implemented yet):

     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)

     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask

     *   movw   r0, #off

     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)

     *   bic    tmp, addr_reg, tmp

     *   ldr    r0, [r2, r0]!                                     (3)

     *   cmp    r0, tmp                                           (4)

     */

#  if CPU_TLB_BITS > 8

#   error

#  endif

    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,

                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));



    /* We assume that the offset is contained within 16 bits.  */

    assert((tlb_offset & ~0xffff) == 0);

    if (tlb_offset > 0xff) {

        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,

                        (24 << 7) | (tlb_offset >> 8));

        tlb_offset &= 0xff;

        base = TCG_REG_R2;

    }



    tcg_out_dat_imm(s, COND_AL, ARITH_AND,

                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);

    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,

                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));



    /* Load the tlb comparator.  Use ldrd if needed and available,

       but due to how the pointer needs setting up, ldm isn't useful.

       Base arm5 doesn't have ldrd, but armv5te does.  */

    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {

        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,

                        TCG_REG_R2, tlb_offset, 1, 1);

    } else {

        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,

                         TCG_REG_R2, tlb_offset, 1, 1);

        if (TARGET_LONG_BITS == 64) {

            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,

                             TCG_REG_R2, 4, 1, 0);

        }

    }



    /* Check alignment.  */

    if (s_bits) {

        tcg_out_dat_imm(s, COND_AL, ARITH_TST,

                        0, addrlo, (1 << s_bits) - 1);

    }



    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,

                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));



    if (TARGET_LONG_BITS == 64) {

        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,

                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));

    }

}
",303,,1,0,,-4,"s,addrlo,addrhi,s_bits,tlb_offset",,,,,Greedy,1,0.00798263152440389
313,"static void qdm2_decode_super_block(QDM2Context *q)

{

    GetBitContext gb;

    QDM2SubPacket header, *packet;

    int i, packet_bytes, sub_packet_size, sub_packets_D;

    unsigned int next_index = 0;



    memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1));

    memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid));

    memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2));



    q->sub_packets_B = 0;

    sub_packets_D    = 0;



    average_quantized_coeffs(q); // average elements in quantized_coeffs[max_ch][10][8]



    init_get_bits(&gb, q->compressed_data, q->compressed_size * 8);

    qdm2_decode_sub_packet_header(&gb, &header);



    if (header.type < 2 || header.type >= 8) {

        q->has_errors = 1;

        av_log(NULL, AV_LOG_ERROR, ""bad superblock type\n"");

        return;

    }



    q->superblocktype_2_3 = (header.type == 2 || header.type == 3);

    packet_bytes          = (q->compressed_size - get_bits_count(&gb) / 8);



    init_get_bits(&gb, header.data, header.size * 8);



    if (header.type == 2 || header.type == 4 || header.type == 5) {

        int csum = 257 * get_bits(&gb, 8);

        csum += 2 * get_bits(&gb, 8);



        csum = qdm2_packet_checksum(q->compressed_data, q->checksum_size, csum);



        if (csum != 0) {

            q->has_errors = 1;

            av_log(NULL, AV_LOG_ERROR, ""bad packet checksum\n"");

            return;

        }

    }



    q->sub_packet_list_B[0].packet = NULL;

    q->sub_packet_list_D[0].packet = NULL;



    for (i = 0; i < 6; i++)

        if (--q->fft_level_exp[i] < 0)

            q->fft_level_exp[i] = 0;



    for (i = 0; packet_bytes > 0; i++) {

        int j;



        if (i >= FF_ARRAY_ELEMS(q->sub_packet_list_A)) {

            SAMPLES_NEEDED_2(""too many packet bytes"");

            return;

        }



        q->sub_packet_list_A[i].next = NULL;



        if (i > 0) {

            q->sub_packet_list_A[i - 1].next = &q->sub_packet_list_A[i];



            /* seek to next block */

            init_get_bits(&gb, header.data, header.size * 8);

            skip_bits(&gb, next_index * 8);



            if (next_index >= header.size)

                break;

        }



        /* decode subpacket */

        packet = &q->sub_packets[i];

        qdm2_decode_sub_packet_header(&gb, packet);

        next_index      = packet->size + get_bits_count(&gb) / 8;

        sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2;



        if (packet->type == 0)

            break;



        if (sub_packet_size > packet_bytes) {

            if (packet->type != 10 && packet->type != 11 && packet->type != 12)

                break;

            packet->size += packet_bytes - sub_packet_size;

        }



        packet_bytes -= sub_packet_size;



        /* add subpacket to 'all subpackets' list */

        q->sub_packet_list_A[i].packet = packet;



        /* add subpacket to related list */

        if (packet->type == 8) {

            SAMPLES_NEEDED_2(""packet type 8"");

            return;

        } else if (packet->type >= 9 && packet->type <= 12) {

            /* packets for MPEG Audio like Synthesis Filter */

            QDM2_LIST_ADD(q->sub_packet_list_D, sub_packets_D, packet);

        } else if (packet->type == 13) {

            for (j = 0; j < 6; j++)

                q->fft_level_exp[j] = get_bits(&gb, 6);

        } else if (packet->type == 14) {

            for (j = 0; j < 6; j++)

                q->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2);

        } else if (packet->type == 15) {

            SAMPLES_NEEDED_2(""packet type 15"")

            return;

        } else if (packet->type >= 16 && packet->type < 48 &&

                   !fft_subpackets[packet->type - 16]) {

            /* packets for FFT */

            QDM2_LIST_ADD(q->sub_packet_list_B, q->sub_packets_B, packet);

        }

    } // Packet bytes loop



    if (q->sub_packet_list_D[0].packet != NULL) {

        process_synthesis_subpackets(q, q->sub_packet_list_D);

        q->do_synth_filter = 1;

    } else if (q->do_synth_filter) {

        process_subpacket_10(q, NULL);

        process_subpacket_11(q, NULL);

        process_subpacket_12(q, NULL);

    }

}
",832,,0,1,,-4,"q,gb,header,packet,i,packet_bytes,sub_packet_size,sub_packets_D,fft_level_exp,j",,,,,Greedy,1,0.008376336097717286
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",127,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int or_cotf_clustersn_slour, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<or_cotf_clustersn_slour; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",1,1,0,1,"c,dst,dstW,src,filter,filterPos,filterSize,i,j","c:0.01370173692703247,dst:-0.024835169315338135,dstW:0.07043391466140747,src:-0.01203930377960205,filter:0.017650306224822998,filterPos:-0.03510540723800659,filterSize:-0.0034458041191101074,i:-0.00434798002243042,j:-0.003805816173553467,",1,2,"dstW:or_cotf_clustersn_slour,",Greedy,89,0.03437891006469727
315,"MigrationState *migrate_get_current(void)

{

    static MigrationState current_migration = {

        .state = MIG_STATE_NONE,

        .bandwidth_limit = MAX_THROTTLE,

        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,

        .mbps = -1,

    };



    return &current_migration;

}
",39,,1,0,,-4,,,,,,Greedy,1,0.007684242725372314
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",127,"qemu_co_sendv_recvv(int en_clusters_husizesubt9i, struct iovec *cluuter_setabm_index, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ternt_table_iunu_table_;

    while (done < bytes) {

        ternt_table_iunu_table_ = iov_send_recv(en_clusters_husizesubt9i, cluuter_setabm_index,

                            offset + done, bytes - done, do_send);

        if (ternt_table_iunu_table_ > 0) {

            done += ternt_table_iunu_table_;

        } else if (ternt_table_iunu_table_ < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ternt_table_iunu_table_ == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",1,1,0,1,"sockfd,iov,ret","sockfd:0.7194536924362183,iov:-0.045900166034698486,ret:0.1147720217704773,",3,10,"sockfd:en_clusters_husizesubt9i,ret:ternt_table_iunu_table_,iov:cluuter_setabm_index,",Greedy,192,0.06436481873194376
317,"static int qcow2_change_backing_file(BlockDriverState *bs,

    const char *backing_file, const char *backing_fmt)

{

    return qcow2_update_ext_header(bs, backing_file, backing_fmt);

}
",30,,1,0,,-4,"bs,backing_file,backing_fmt",,,,,Greedy,1,0.007891456286112467
318,"static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {

    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);

    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",218,"static void av_always_inline filter_mb_edgech( uint8_t *_openrefcount_ze2hitters, int targori8_overOl_tabble, const int16_t tionhreacouent_taatioGh[4], unsigned int st_d_ve_fit_quanitizanioqn, H264Context *erprediwt09a_MAX_DWT_tE ) {

    const int qp_bd_offset = 6 * (erprediwt09a_MAX_DWT_tE->sps.bit_depth_luma - 8);

    const unsigned int index_a = st_d_ve_fit_quanitizanioqn - qp_bd_offset + erprediwt09a_MAX_DWT_tE->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[st_d_ve_fit_quanitizanioqn - qp_bd_offset + erprediwt09a_MAX_DWT_tE->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( tionhreacouent_taatioGh[0] < 4 ) {

        int8_t dictiob_quxntitzatoinrefc[4];

        dictiob_quxntitzatoinrefc[0] = tc0_table[index_a][tionhreacouent_taatioGh[0]]+1;

        dictiob_quxntitzatoinrefc[1] = tc0_table[index_a][tionhreacouent_taatioGh[1]]+1;

        dictiob_quxntitzatoinrefc[2] = tc0_table[index_a][tionhreacouent_taatioGh[2]]+1;

        dictiob_quxntitzatoinrefc[3] = tc0_table[index_a][tionhreacouent_taatioGh[3]]+1;

        erprediwt09a_MAX_DWT_tE->h264dsp.h264_v_loop_filter_chroma(_openrefcount_ze2hitters, targori8_overOl_tabble, alpha, beta, dictiob_quxntitzatoinrefc);

    } else {

        erprediwt09a_MAX_DWT_tE->h264dsp.h264_v_loop_filter_chroma_intra(_openrefcount_ze2hitters, targori8_overOl_tabble, alpha, beta);

    }

}
",0,0,0,-1,"pix,stride,bS,qp,h,tc","pix:-0.0001546097919344902,stride:-5.798228085041046e-05,bS:-0.00012526987120509148,qp:-0.00010119518265128136,h:-0.00043409643694758415,tc:-0.0002615712583065033,",6,27,"stride:targori8_overOl_tabble,qp:st_d_ve_fit_quanitizanioqn,bS:tionhreacouent_taatioGh,pix:_openrefcount_ze2hitters,tc:dictiob_quxntitzatoinrefc,h:erprediwt09a_MAX_DWT_tE,",Greedy,389,0.11803422371546428
319,"static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size,

                          const char *boot_device,

                          DisplayState *ds, const char *kernel_filename,

                          const char *kernel_cmdline,

                          const char *initrd_filename, const char *cpu_model)

{

    CPUState *env, *envs[MAX_CPUS];

    unsigned int i;

    void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;

    qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq,

        *espdma_irq, *ledma_irq;

    qemu_irq *esp_reset, *le_reset;

    ram_addr_t ram_offset, prom_offset, tcx_offset;

    unsigned long kernel_size;

    int ret;

    char buf[1024];

    int drive_index;

    void *fw_cfg;



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");

            exit(1);

        }

        cpu_sparc_set_id(env, i);

        envs[i] = env;

        if (i == 0) {

            qemu_register_reset(main_cpu_reset, env);

        } else {

            qemu_register_reset(secondary_cpu_reset, env);

            env->halted = 1;

        }

        cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);

        env->prom_addr = hwdef->slavio_base;

    }



    for (i = smp_cpus; i < MAX_CPUS; i++)

        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);



    /* allocate RAM */

    if ((uint64_t)RAM_size > hwdef->max_mem) {

        fprintf(stderr,

                ""qemu: Too much memory for this machine: %d, maximum %d\n"",

                (unsigned int)(RAM_size / (1024 * 1024)),

                (unsigned int)(hwdef->max_mem / (1024 * 1024)));

        exit(1);

    }

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    /* load boot prom */

    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->slavio_base,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    snprintf(buf, sizeof(buf), ""%s/%s"", bios_dir, bios_name);

    ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);

    if (ret < 0 || ret > PROM_SIZE_MAX)

        ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);

    if (ret < 0 || ret > PROM_SIZE_MAX) {

        fprintf(stderr, ""qemu: could not load prom '%s'\n"",

                buf);

        exit(1);

    }



    /* set up devices */

    sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs);



    for (i = 0; i < MAX_IOUNITS; i++)

        if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1)

            iounits[i] = iommu_init(hwdef->iounit_bases[i],

                                    hwdef->iounit_version,

                                    sbi_irq[hwdef->me_irq]);



    espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq],

                              iounits[0], &espdma_irq, &esp_reset);



    ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq],

                             iounits[0], &ledma_irq, &le_reset);



    if (graphic_depth != 8 && graphic_depth != 24) {

        fprintf(stderr, ""qemu: Unsupported depth: %d\n"", graphic_depth);

        exit (1);

    }

    tcx_offset = qemu_ram_alloc(hwdef->vram_size);

    tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset,

             hwdef->vram_size, graphic_width, graphic_height, graphic_depth);



    if (nd_table[0].model == NULL)

        nd_table[0].model = ""lance"";

    if (strcmp(nd_table[0].model, ""lance"") == 0) {

        lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);

    } else if (strcmp(nd_table[0].model, ""?"") == 0) {

        fprintf(stderr, ""qemu: Supported NICs: lance\n"");

        exit (1);

    } else {

        fprintf(stderr, ""qemu: Unsupported NIC: %s\n"", nd_table[0].model);

        exit (1);

    }



    nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0,

                        hwdef->nvram_size, 8);



    slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq],

                          sbi_cpu_irq, smp_cpus);



    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq],

                              nographic, ESCC_CLOCK, 1);

    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device

    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device

    escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1],

              serial_hds[0], ESCC_CLOCK, 1);



    if (drive_get_max_bus(IF_SCSI) > 0) {

        fprintf(stderr, ""qemu: too many SCSI bus\n"");

        exit(1);

    }



    main_esp = esp_init(hwdef->esp_base, 2,

                        espdma_memory_read, espdma_memory_write,

                        espdma, *espdma_irq, esp_reset);



    for (i = 0; i < ESP_MAX_DEVS; i++) {

        drive_index = drive_get_index(IF_SCSI, 0, i);

        if (drive_index == -1)

            continue;

        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i);

    }



    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,

                                    RAM_size);



    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,

               boot_device, RAM_size, kernel_size, graphic_width,

               graphic_height, graphic_depth, hwdef->nvram_machine_id,

               ""Sun4d"");



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

}
",1071,"static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size,

                          const char *boot_device,

                          DisplayState *ds, const char *kernel_filename,

                          const char *kernel_cmdline,

                          const char *initrd_filename, const char *cpu_model)

{

    CPUState *env, *envs[nbz6on_8stratAXDWT_Lj_t];

    unsigned int i;

    void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;

    qemu_irq *rnotargnamecluterr[nbz6on_8stratAXDWT_Lj_t], *sbi_irq, *zationrLeorder_buffrce_,

        *espdma_irq, *ledma_irq;

    qemu_irq *esp_reset, *le_reset;

    ram_addr_t ram_offset, prom_offset, tcx_offset;

    unsigned long kernel_size;

    int ret;

    char buf[1024];

    int drive_index;

    void *fw_cfg;



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""qemu: Unable to find Sparc CPU definition
"");

            exit(1);

        }

        cpu_sparc_set_id(env, i);

        envs[i] = env;

        if (i == 0) {

            qemu_register_reset(main_cpu_reset, env);

        } else {

            qemu_register_reset(secondary_cpu_reset, env);

            env->halted = 1;

        }

        rnotargnamecluterr[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);

        env->prom_addr = hwdef->slavio_base;

    }



    for (i = smp_cpus; i < nbz6on_8stratAXDWT_Lj_t; i++)

        rnotargnamecluterr[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);



    /* allocate RAM */

    if ((uint64_t)RAM_size > hwdef->max_mem) {

        fprintf(stderr,

                ""qemu: Too much memory for this machine: %d, maximum %d
"",

                (unsigned int)(RAM_size / (1024 * 1024)),

                (unsigned int)(hwdef->max_mem / (1024 * 1024)));

        exit(1);

    }

    ram_offset = qemu_ram_alloc(RAM_size);

    cpu_register_physical_memory(0, RAM_size, ram_offset);



    /* load boot prom */

    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);

    cpu_register_physical_memory(hwdef->slavio_base,

                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &

                                 TARGET_PAGE_MASK,

                                 prom_offset | IO_MEM_ROM);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    snprintf(buf, sizeof(buf), ""%s/%s"", bios_dir, bios_name);

    ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);

    if (ret < 0 || ret > PROM_SIZE_MAX)

        ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);

    if (ret < 0 || ret > PROM_SIZE_MAX) {

        fprintf(stderr, ""qemu: could not load prom '%s'
"",

                buf);

        exit(1);

    }



    /* set up devices */

    sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &zationrLeorder_buffrce_, rnotargnamecluterr);



    for (i = 0; i < MAX_IOUNITS; i++)

        if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1)

            iounits[i] = iommu_init(hwdef->iounit_bases[i],

                                    hwdef->iounit_version,

                                    sbi_irq[hwdef->me_irq]);



    espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq],

                              iounits[0], &espdma_irq, &esp_reset);



    ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq],

                             iounits[0], &ledma_irq, &le_reset);



    if (graphic_depth != 8 && graphic_depth != 24) {

        fprintf(stderr, ""qemu: Unsupported depth: %d
"", graphic_depth);

        exit (1);

    }

    tcx_offset = qemu_ram_alloc(hwdef->vram_size);

    tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset,

             hwdef->vram_size, graphic_width, graphic_height, graphic_depth);



    if (nd_table[0].model == NULL)

        nd_table[0].model = ""lance"";

    if (strcmp(nd_table[0].model, ""lance"") == 0) {

        lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);

    } else if (strcmp(nd_table[0].model, ""?"") == 0) {

        fprintf(stderr, ""qemu: Supported NICs: lance
"");

        exit (1);

    } else {

        fprintf(stderr, ""qemu: Unsupported NIC: %s
"", nd_table[0].model);

        exit (1);

    }



    nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0,

                        hwdef->nvram_size, 8);



    slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq],

                          zationrLeorder_buffrce_, smp_cpus);



    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq],

                              nographic, ESCC_CLOCK, 1);

    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device

    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device

    escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1],

              serial_hds[0], ESCC_CLOCK, 1);



    if (drive_get_max_bus(IF_SCSI) > 0) {

        fprintf(stderr, ""qemu: too many SCSI bus
"");

        exit(1);

    }



    main_esp = esp_init(hwdef->esp_base, 2,

                        espdma_memory_read, espdma_memory_write,

                        espdma, *espdma_irq, esp_reset);



    for (i = 0; i < ESP_MAX_DEVS; i++) {

        drive_index = drive_get_index(IF_SCSI, 0, i);

        if (drive_index == -1)

            continue;

        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i);

    }



    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,

                                    RAM_size);



    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,

               boot_device, RAM_size, kernel_size, graphic_width,

               graphic_height, graphic_depth, hwdef->nvram_machine_id,

               ""Sun4d"");



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

}
",0,0,1,1,"hwdef,RAM_size,boot_device,ds,kernel_filename,kernel_cmdline,initrd_filename,cpu_model,env,envs,MAX_CPUS,i,iounits,MAX_IOUNITS,espdma,ledma,main_esp,nvram,sbi,cpu_irqs,sbi_irq,sbi_cpu_irq,espdma_irq,ledma_irq,esp_reset,le_reset,ram_offset,prom_offset,tcx_offset,kernel_size,ret,buf,drive_index,fw_cfg","hwdef:0.05606517195701599,RAM_size:0.006517782807350159,boot_device:0.027112171053886414,ds:0.012665167450904846,kernel_filename:0.03968469798564911,kernel_cmdline:0.042846232652664185,initrd_filename:0.01857389509677887,cpu_model:0.055562376976013184,env:0.009454920887947083,envs:0.01622338593006134,MAX_CPUS:0.07898643612861633,i:-0.05067525804042816,iounits:-0.006295636296272278,MAX_IOUNITS:0.03771154582500458,espdma:0.006322115659713745,ledma:0.0018841922283172607,main_esp:0.00658203661441803,nvram:0.005195260047912598,sbi:0.008658379316329956,cpu_irqs:0.06376340985298157,sbi_irq:0.04800975322723389,sbi_cpu_irq:0.06548787653446198,espdma_irq:0.06056821346282959,ledma_irq:0.05360040068626404,esp_reset:0.009850233793258667,le_reset:0.0013588815927505493,ram_offset:0.03376978635787964,prom_offset:0.007070422172546387,tcx_offset:0.048964306712150574,kernel_size:-0.0020690858364105225,ret:-0.03170882165431976,buf:-0.00969839096069336,drive_index:0.010029837489128113,fw_cfg:0.029171988368034363,",3,10,"MAX_CPUS:nbz6on_8stratAXDWT_Lj_t,sbi_cpu_irq:zationrLeorder_buffrce_,cpu_irqs:rnotargnamecluterr,",Greedy,357,0.1262706716855367
320,"static int qemu_rdma_block_for_wrid(RDMAContext *rdma, int wrid_requested)

{

    int num_cq_events = 0, ret = 0;

    struct ibv_cq *cq;

    void *cq_ctx;

    uint64_t wr_id = RDMA_WRID_NONE, wr_id_in;



    if (ibv_req_notify_cq(rdma->cq, 0)) {

        return -1;

    }

    /* poll cq first */

    while (wr_id != wrid_requested) {

        ret = qemu_rdma_poll(rdma, &wr_id_in);

        if (ret < 0) {

            return ret;

        }



        wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;



        if (wr_id == RDMA_WRID_NONE) {

            break;

        }

        if (wr_id != wrid_requested) {

            DDDPRINTF(""A Wanted wrid %s (%d) but got %s (%"" PRIu64 "")\n"",

                print_wrid(wrid_requested),

                wrid_requested, print_wrid(wr_id), wr_id);

        }

    }



    if (wr_id == wrid_requested) {

        return 0;

    }



    while (1) {

        /*

         * Coroutine doesn't start until process_incoming_migration()

         * so don't yield unless we know we're running inside of a coroutine.

         */

        if (rdma->migration_started_on_destination) {

            yield_until_fd_readable(rdma->comp_channel->fd);

        }



        if (ibv_get_cq_event(rdma->comp_channel, &cq, &cq_ctx)) {

            perror(""ibv_get_cq_event"");

            goto err_block_for_wrid;

        }



        num_cq_events++;



        if (ibv_req_notify_cq(cq, 0)) {

            goto err_block_for_wrid;

        }



        while (wr_id != wrid_requested) {

            ret = qemu_rdma_poll(rdma, &wr_id_in);

            if (ret < 0) {

                goto err_block_for_wrid;

            }



            wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;



            if (wr_id == RDMA_WRID_NONE) {

                break;

            }

            if (wr_id != wrid_requested) {

                DDDPRINTF(""B Wanted wrid %s (%d) but got %s (%"" PRIu64 "")\n"",

                    print_wrid(wrid_requested), wrid_requested,

                    print_wrid(wr_id), wr_id);

            }

        }



        if (wr_id == wrid_requested) {

            goto success_block_for_wrid;

        }

    }



success_block_for_wrid:

    if (num_cq_events) {

        ibv_ack_cq_events(cq, num_cq_events);

    }

    return 0;



err_block_for_wrid:

    if (num_cq_events) {

        ibv_ack_cq_events(cq, num_cq_events);

    }

    return ret;

}
",335,,0,1,,-4,"rdma,wrid_requested,cq,cq_ctx,wr_id_in,num_cq_events",,,,,Greedy,1,0.00837613344192505
321,"static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t *)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    __asm__ volatile(""pxor    %%mm7,%%mm7    \n\t"":::""memory"");

    __asm__ volatile(""pcmpeqd %%mm6,%%mm6    \n\t"":::""memory"");

    mm_end = end - 3;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            PACK_RGB32

            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r)

            :""memory"");

        d += 16;

        s += 4;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

        *d++ = 255;

    }

}
",304,"static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *odec_nsmeorig_zVver, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = odec_nsmeorig_zVver;

    const uint16_t *s = (const uint16_t *)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    __asm__ volatile(""pxor    %%mm7,%%mm7    
\t"":::""memory"");

    __asm__ volatile(""pcmpeqd %%mm6,%%mm6    
\t"":::""memory"");

    mm_end = end - 3;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movq          %1, %%mm0    
\t""

            ""movq          %1, %%mm1    
\t""

            ""movq          %1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            PACK_RGB32

            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r)

            :""memory"");

        d += 16;

        s += 4;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

        *d++ = 255;

    }

}
",1,1,0,1,"src,dst,src_size,end,mm_end,d,s,bgr","src:-0.06711524724960327,dst:0.13195663690567017,src_size:0.051290273666381836,end:-0.09092128276824951,mm_end:-0.1263619065284729,d:-0.20014160871505737,s:-0.11464452743530273,bgr:-0.10301607847213745,",1,2,"dst:odec_nsmeorig_zVver,",Greedy,95,0.03701808055241903
322,"static int mux_chr_can_read(void *opaque)

{

    CharDriverState *chr = opaque;

    MuxDriver *d = chr->opaque;



    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)

        return 1;

    if (d->chr_can_read[chr->focus])

        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);

    return 0;

}
",75,,1,0,,-4,"opaque,chr,d",,,,,Greedy,1,0.008729346593221029
323,"static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)

{

    return s->iq_tail == 0;

}
",18,,1,0,,-4,s,,,,,Greedy,1,0.007914590835571288
324,"static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,

                                     const uint8_t *src_in[4],

                                     int srcW, int xInc, const int16_t *hChrFilter,

                                     const int16_t *hChrFilterPos, int hChrFilterSize,

                                     uint8_t *formatConvBuffer, uint32_t *pal)

{

    const uint8_t *src1 = src_in[1], *src2 = src_in[2];

    if (c->chrToYV12) {

        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);

        c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal);

        src1= formatConvBuffer;

        src2= buf2;

    } else if (c->readChrPlanar) {

        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);

        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);

        src1= formatConvBuffer;

        src2= buf2;

    }



    if (!c->hcscale_fast) {

        c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize);

        c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize);

    } else { // fast bilinear upscale / crap downscale

        c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc);

    }



    if (c->chrConvertRange)

        c->chrConvertRange(dst1, dst2, dstWidth);

}
",274,,1,0,,-4,"c,dst1,dst2,dstWidth,src_in,srcW,xInc,hChrFilter,hChrFilterPos,hChrFilterSize,formatConvBuffer,pal,src1,src2,buf2",,,,,Greedy,1,0.008108067512512206
325,"static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,
        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)
{
    BlockDriverState *bs = child->bs;
    /* Perform I/O through a temporary buffer so that users who scribble over
     * their read buffer while the operation is in progress do not end up
     * modifying the image file.  This is critical for zero-copy guest I/O
     * where anything might happen inside guest memory.
     */
    void *bounce_buffer;
    BlockDriver *drv = bs->drv;
    struct iovec iov;
    QEMUIOVector local_qiov;
    int64_t cluster_offset;
    int64_t cluster_bytes;
    size_t skip_bytes;
    int ret;
    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,
                                    BDRV_REQUEST_MAX_BYTES);
    unsigned int progress = 0;
    /* FIXME We cannot require callers to have write permissions when all they
     * are doing is a read request. If we did things right, write permissions
     * would be obtained anyway, but internally by the copy-on-read code. As
     * long as it is implemented here rather than in a separate filter driver,
     * the copy-on-read code doesn't have its own BdrvChild, however, for which
     * it could request permissions. Therefore we have to bypass the permission
     * system for the moment. */
    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));
    /* Cover entire cluster so no additional backing file I/O is required when
     * allocating cluster in the image file.  Note that this value may exceed
     * BDRV_REQUEST_MAX_BYTES (even when the original read did not), which
     * is one reason we loop rather than doing it all at once.
     */
    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);
    skip_bytes = offset - cluster_offset;
    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,
                                   cluster_offset, cluster_bytes);
    bounce_buffer = qemu_try_blockalign(bs,
                                        MIN(MIN(max_transfer, cluster_bytes),
                                            MAX_BOUNCE_BUFFER));
    if (bounce_buffer == NULL) {
        ret = -ENOMEM;
        goto err;
    while (cluster_bytes) {
        int64_t pnum;
        ret = bdrv_is_allocated(bs, cluster_offset,
                                MIN(cluster_bytes, max_transfer), &pnum);
        if (ret < 0) {
            /* Safe to treat errors in querying allocation as if
             * unallocated; we'll probably fail again soon on the
             * read, but at least that will set a decent errno.
             */
            pnum = MIN(cluster_bytes, max_transfer);
        assert(skip_bytes < pnum);
        if (ret <= 0) {
            /* Must copy-on-read; use the bounce buffer */
            iov.iov_base = bounce_buffer;
            iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER);
            qemu_iovec_init_external(&local_qiov, &iov, 1);
            ret = bdrv_driver_preadv(bs, cluster_offset, pnum,
                                     &local_qiov, 0);
            if (ret < 0) {
                goto err;
            bdrv_debug_event(bs, BLKDBG_COR_WRITE);
            if (drv->bdrv_co_pwrite_zeroes &&
                buffer_is_zero(bounce_buffer, pnum)) {
                /* FIXME: Should we (perhaps conditionally) be setting
                 * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy
                 * that still correctly reads as zero? */
                ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0);
            } else {
                /* This does not change the data on the disk, it is not
                 * necessary to flush even in cache=writethrough mode.
                 */
                ret = bdrv_driver_pwritev(bs, cluster_offset, pnum,
                                          &local_qiov, 0);
            if (ret < 0) {
                /* It might be okay to ignore write errors for guest
                 * requests.  If this is a deliberate copy-on-read
                 * then we don't want to ignore the error.  Simply
                 * report it in all cases.
                 */
                goto err;
            qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes,
                                pnum - skip_bytes);
        } else {
            /* Read directly into the destination */
            qemu_iovec_init(&local_qiov, qiov->niov);
            qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes);
            ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size,
                                     &local_qiov, 0);
            qemu_iovec_destroy(&local_qiov);
            if (ret < 0) {
                goto err;
        cluster_offset += pnum;
        cluster_bytes -= pnum;
        progress += pnum - skip_bytes;
        skip_bytes = 0;
    ret = 0;
err:
    qemu_vfree(bounce_buffer);
    return ret;",434,,1,0,,-4,"child,offset,bytes,qiov,bs,bounce_buffer,drv,iov,local_qiov,cluster_offset,cluster_bytes,skip_bytes,ret,pnum",,,,,Greedy,1,0.007480462392171224
326,"static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)
{
    virtio_scsi_common_unrealize(dev, errp);
}",22,,1,0,,-4,"dev,errp",,,,,Greedy,1,0.007952829202016195
327,"static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)

{

    char buf[1024];

    VncShareMode mode;

    int size;



    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;

    switch (vs->vd->share_policy) {

    case VNC_SHARE_POLICY_IGNORE:

        /*

         * Ignore the shared flag.  Nothing to do here.

         *

         * Doesn't conform to the rfb spec but is traditional qemu

         * behavior, thus left here as option for compatibility

         * reasons.

         */

        break;

    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:

        /*

         * Policy: Allow clients ask for exclusive access.

         *

         * Implementation: When a client asks for exclusive access,

         * disconnect all others. Shared connects are allowed as long

         * as no exclusive connection exists.

         *

         * This is how the rfb spec suggests to handle the shared flag.

         */

        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {

            VncState *client;

            QTAILQ_FOREACH(client, &vs->vd->clients, next) {

                if (vs == client) {

                    continue;

                }

                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&

                    client->share_mode != VNC_SHARE_MODE_SHARED) {

                    continue;

                }

                vnc_disconnect_start(client);

            }

        }

        if (mode == VNC_SHARE_MODE_SHARED) {

            if (vs->vd->num_exclusive > 0) {

                vnc_disconnect_start(vs);

                return 0;

            }

        }

        break;

    case VNC_SHARE_POLICY_FORCE_SHARED:

        /*

         * Policy: Shared connects only.

         * Implementation: Disallow clients asking for exclusive access.

         *

         * Useful for shared desktop sessions where you don't want

         * someone forgetting to say -shared when running the vnc

         * client disconnect everybody else.

         */

        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {

            vnc_disconnect_start(vs);

            return 0;

        }

        break;

    }

    vnc_set_share_mode(vs, mode);



    vs->client_width = surface_width(vs->vd->ds);

    vs->client_height = surface_height(vs->vd->ds);

    vnc_write_u16(vs, vs->client_width);

    vnc_write_u16(vs, vs->client_height);



    pixel_format_message(vs);



    if (qemu_name)

        size = snprintf(buf, sizeof(buf), ""QEMU (%s)"", qemu_name);

    else

        size = snprintf(buf, sizeof(buf), ""QEMU"");



    vnc_write_u32(vs, size);

    vnc_write(vs, buf, size);

    vnc_flush(vs);



    vnc_client_cache_auth(vs);

    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);



    vnc_read_when(vs, protocol_client_msg, 1);



    return 0;

}
",310,,1,0,,-4,"vs,data,len,buf,mode,size,client",,,,,Greedy,1,0.008813254038492839
328,"static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x,

                                                 const uint8_t *src_y,

                                                 int32_t src_stride,

                                                 uint8_t *dst,

                                                 int32_t dst_stride)

{

    v16i8 src_hz0, src_hz1, src_hz2, src_hz3;

    v16u8 dst0, dst1, dst2, dst3;

    v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4;

    v16i8 src_vt5, src_vt6, src_vt7, src_vt8;

    v16i8 mask0, mask1, mask2;

    v8i16 hz_out0, hz_out1, vert_out0, vert_out1;

    v8i16 res0, res1;

    v16u8 res;



    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);

    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);

    src_y += (5 * src_stride);



    src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1);

    src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2);

    src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3);

    src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4);



    XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3);

    LD_SB4(src_x, src_stride, src_hz0, src_hz1, src_hz2, src_hz3);

    LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);

    XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3);

    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1,

                                                          mask0, mask1, mask2);

    hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3,

                                                          mask0, mask1, mask2);

    SRARI_H2_SH(hz_out0, hz_out1, 5);

    SAT_SH2_SH(hz_out0, hz_out1, 7);

    LD_SB4(src_y, src_stride, src_vt5, src_vt6, src_vt7, src_vt8);



    src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5);

    src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6);

    src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7);

    src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8);



    XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7);



    /* filter calc */

    vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2,

                                                  src_vt3, src_vt4, src_vt5);

    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4,

                                                  src_vt5, src_vt6, src_vt7);

    SRARI_H2_SH(vert_out0, vert_out1, 5);

    SAT_SH2_SH(vert_out0, vert_out1, 7);



    res1 = __msa_srari_h((hz_out1 + vert_out1), 1);

    res0 = __msa_srari_h((hz_out0 + vert_out0), 1);



    SAT_SH2_SH(res0, res1, 7);

    res = PCKEV_XORI128_UB(res0, res1);



    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);

    dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3);

    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);

    dst0 = __msa_aver_u_b(res, dst0);



    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride);

}
",600,"static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x,

                                                 const uint8_t *src_y,

                                                 int32_t uatitzat9zondela_clu2sters,

                                                 uint8_t *Vb_paguepredictor_smerfcount,

                                                 int32_t ter_noeigt_errobitweigh)

{

    v16i8 src_hz0, src_hz1, src_hz2, src_hz3;

    v16u8 dst0, dst1, zaktiiondesc_fille_paten_op, on_iuantitqzuLnsitKqzati;

    v16i8 itizaHti8nn_teEDrminatinext_p, src_vt1, src_vt2, src_vt3, src_vt4;

    v16i8 src_vt5, src_vt6, src_vt7, tabElergeaDW_TLEVELSrro;

    v16i8 AaneitizCerlacingatgonDo, preXdictionY_quantitozatiin, euJalukseersprdictorqoeEf;

    v8i16 hz_out0, hz_out1, vert_out0, vert_out1;

    v8i16 guessed_CODhturenUu, res1;

    v16u8 rget_erropefxtounc_ta;



    LD_SB3(&luma_mask_arr[48], 16, AaneitizCerlacingatgonDo, preXdictionY_quantitozatiin, euJalukseersprdictorqoeEf);

    LD_SB5(src_y, uatitzat9zondela_clu2sters, itizaHti8nn_teEDrminatinext_p, src_vt1, src_vt2, src_vt3, src_vt4);

    src_y += (5 * uatitzat9zondela_clu2sters);



    itizaHti8nn_teEDrminatinext_p = (v16i8) __msa_insve_w((v4i32) itizaHti8nn_teEDrminatinext_p, 1, (v4i32) src_vt1);

    src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2);

    src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3);

    src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4);



    XORI_B4_128_SB(itizaHti8nn_teEDrminatinext_p, src_vt1, src_vt2, src_vt3);

    LD_SB4(src_x, uatitzat9zondela_clu2sters, src_hz0, src_hz1, src_hz2, src_hz3);

    LD_UB4(Vb_paguepredictor_smerfcount, ter_noeigt_errobitweigh, dst0, dst1, zaktiiondesc_fille_paten_op, on_iuantitqzuLnsitKqzati);

    XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3);

    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1,

                                                          AaneitizCerlacingatgonDo, preXdictionY_quantitozatiin, euJalukseersprdictorqoeEf);

    hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3,

                                                          AaneitizCerlacingatgonDo, preXdictionY_quantitozatiin, euJalukseersprdictorqoeEf);

    SRARI_H2_SH(hz_out0, hz_out1, 5);

    SAT_SH2_SH(hz_out0, hz_out1, 7);

    LD_SB4(src_y, uatitzat9zondela_clu2sters, src_vt5, src_vt6, src_vt7, tabElergeaDW_TLEVELSrro);



    src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5);

    src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6);

    src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7);

    src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) tabElergeaDW_TLEVELSrro);



    XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7);



    /* filter calc */

    vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(itizaHti8nn_teEDrminatinext_p, src_vt1, src_vt2,

                                                  src_vt3, src_vt4, src_vt5);

    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4,

                                                  src_vt5, src_vt6, src_vt7);

    SRARI_H2_SH(vert_out0, vert_out1, 5);

    SAT_SH2_SH(vert_out0, vert_out1, 7);



    res1 = __msa_srari_h((hz_out1 + vert_out1), 1);

    guessed_CODhturenUu = __msa_srari_h((hz_out0 + vert_out0), 1);



    SAT_SH2_SH(guessed_CODhturenUu, res1, 7);

    rget_erropefxtounc_ta = PCKEV_XORI128_UB(guessed_CODhturenUu, res1);



    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);

    dst1 = (v16u8) __msa_insve_w((v4i32) zaktiiondesc_fille_paten_op, 1, (v4i32) on_iuantitqzuLnsitKqzati);

    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);

    dst0 = __msa_aver_u_b(rget_erropefxtounc_ta, dst0);



    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, Vb_paguepredictor_smerfcount, ter_noeigt_errobitweigh);

}
",0,0,1,1,"src_x,src_y,src_stride,dst,dst_stride,src_hz0,src_hz1,src_hz2,src_hz3,dst0,dst1,dst2,dst3,src_vt0,src_vt1,src_vt2,src_vt3,src_vt4,src_vt5,src_vt6,src_vt7,src_vt8,mask0,mask1,mask2,hz_out0,hz_out1,vert_out0,vert_out1,res0,res1,res","src_x:-7.36345537006855e-05,src_y:-0.00020370050333440304,src_stride:-0.00013943086378276348,dst:3.672391176223755e-05,dst_stride:-7.397285662591457e-05,src_hz0:-7.883994840085506e-05,src_hz1:-7.220730185508728e-05,src_hz2:-7.778988219797611e-05,src_hz3:-8.736248128116131e-05,dst0:-1.835799776017666e-05,dst1:-1.2561911717057228e-05,dst2:-1.0161660611629486e-05,dst3:-1.7830170691013336e-06,src_vt0:-0.0001768686342984438,src_vt1:-0.0002705997321754694,src_vt2:-0.00021455902606248856,src_vt3:-0.00019175279885530472,src_vt4:-0.00018041720613837242,src_vt5:-8.491193875670433e-05,src_vt6:-7.848953828215599e-05,src_vt7:-9.292666800320148e-05,src_vt8:-7.954821921885014e-05,mask0:-1.4105811715126038e-05,mask1:-1.4547258615493774e-06,mask2:-1.070345751941204e-05,hz_out0:-0.00013243756256997585,hz_out1:-6.681471131742e-05,vert_out0:-9.986152872443199e-05,vert_out1:-8.978159166872501e-05,res0:-5.761347711086273e-05,res1:-3.96091490983963e-05,res:5.014240741729736e-05,",12,45,"res:rget_erropefxtounc_ta,dst:Vb_paguepredictor_smerfcount,mask1:preXdictionY_quantitozatiin,dst3:on_iuantitqzuLnsitKqzati,dst2:zaktiiondesc_fille_paten_op,mask2:euJalukseersprdictorqoeEf,dst1:dst1,mask0:AaneitizCerlacingatgonDo,dst0:dst0,res1:res1,res0:guessed_CODhturenUu,hz_out1:hz_out1,src_hz1:src_hz1,src_x:src_x,dst_stride:ter_noeigt_errobitweigh,src_hz2:src_hz2,src_vt6:src_vt6,src_hz0:src_hz0,src_vt8:tabElergeaDW_TLEVELSrro,src_vt5:src_vt5,src_hz3:src_hz3,vert_out1:vert_out1,src_vt7:src_vt7,vert_out0:vert_out0,hz_out0:hz_out0,src_stride:uatitzat9zondela_clu2sters,src_vt0:itizaHti8nn_teEDrminatinext_p,",Greedy,1781,0.6004190524419148
329,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

                         BlockDriverCompletionFunc *cb, void *opaque)

{

    BDRVRawState *s = bs->opaque;

    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,

                       cb, opaque, QEMU_AIO_READ);

}
",59,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *numinb_asourtdarget_er,

                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

                         BlockDriverCompletionFunc *cb, void *opaque)

{

    BDRVRawState *s = numinb_asourtdarget_er->opaque;

    return paio_submit(numinb_asourtdarget_er, s->hfile, sector_num, qiov, nb_sectors,

                       cb, opaque, QEMU_AIO_READ);

}
",0,0,1,1,"bs,sector_num,qiov,nb_sectors,cb,opaque,s","bs:0.062414166517555714,sector_num:-0.028480328619480133,qiov:-0.008798163384199142,nb_sectors:0.0074725523591041565,cb:0.032812656834721565,opaque:-0.03874352388083935,s:-0.0036012977361679077,",1,3,"bs:numinb_asourtdarget_er,",Greedy,78,0.03248494863510132
330,"static void tcx_blit_writel(void *opaque, hwaddr addr,

                            uint64_t val, unsigned size)

{

    TCXState *s = opaque;

    uint32_t adsr, len;

    int i;



    if (!(addr & 4)) {

        s->tmpblit = val;

    } else {

        addr = (addr >> 3) & 0xfffff;

        adsr = val & 0xffffff;

        len = ((val >> 24) & 0x1f) + 1;

        if (adsr == 0xffffff) {

            memset(&s->vram[addr], s->tmpblit, len);

            if (s->depth == 24) {

                val = s->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (i = 0; i < len; i++) {

                    s->vram24[addr + i] = val;

                }

            }

        } else {

            memcpy(&s->vram[addr], &s->vram[adsr], len);

            if (s->depth == 24) {

                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);

            }

        }

        memory_region_set_dirty(&s->vram_mem, addr, len);

    }

}
",228,"static void tcx_blit_writel(void *opaque, hwaddr addr,

                            uint64_t val, unsigned size)

{

    TCXState *isnoter_shaoaclesubtitlet = opaque;

    uint32_t adsr, _terr_nb_sehMLX_DWT_AE;

    int i;



    if (!(addr & 4)) {

        isnoter_shaoaclesubtitlet->tmpblit = val;

    } else {

        addr = (addr >> 3) & 0xfffff;

        adsr = val & 0xffffff;

        _terr_nb_sehMLX_DWT_AE = ((val >> 24) & 0x1f) + 1;

        if (adsr == 0xffffff) {

            memset(&isnoter_shaoaclesubtitlet->vram[addr], isnoter_shaoaclesubtitlet->tmpblit, _terr_nb_sehMLX_DWT_AE);

            if (isnoter_shaoaclesubtitlet->depth == 24) {

                val = isnoter_shaoaclesubtitlet->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (i = 0; i < _terr_nb_sehMLX_DWT_AE; i++) {

                    isnoter_shaoaclesubtitlet->vram24[addr + i] = val;

                }

            }

        } else {

            memcpy(&isnoter_shaoaclesubtitlet->vram[addr], &isnoter_shaoaclesubtitlet->vram[adsr], _terr_nb_sehMLX_DWT_AE);

            if (isnoter_shaoaclesubtitlet->depth == 24) {

                memcpy(&isnoter_shaoaclesubtitlet->vram24[addr], &isnoter_shaoaclesubtitlet->vram24[adsr], _terr_nb_sehMLX_DWT_AE * 4);

            }

        }

        memory_region_set_dirty(&isnoter_shaoaclesubtitlet->vram_mem, addr, _terr_nb_sehMLX_DWT_AE);

    }

}
",0,0,1,1,"opaque,addr,val,size,s,adsr,len,i","opaque:0.00040510576218366623,addr:0.0028034853748977184,val:0.002618633210659027,size:-0.0006202845834195614,s:0.0031631169840693474,adsr:-0.0006756572984158993,len:0.004500239156186581,i:9.532645344734192e-05,",2,20,"len:_terr_nb_sehMLX_DWT_AE,s:isnoter_shaoaclesubtitlet,",Greedy,172,0.05509859323501587
331,"static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,

                                                       uint8_t alpha_in,

                                                       uint8_t beta_in,

                                                       uint32_t img_width)

{

    uint16_t out0, out1, out2, out3;

    v8i16 tmp1;

    v16u8 alpha, beta, is_less_than;

    v8i16 p0_or_q0, q0_or_p0;

    v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org;

    v16i8 zero = { 0 };

    v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0;

    v16u8 is_less_than_alpha, is_less_than_beta;

    v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r;



    {

        v16u8 row0, row1, row2, row3, row4, row5, row6, row7;



        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,

                      row0, row1, row2, row3, row4, row5, row6, row7);



        TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7,

                          p1_or_q1_org, p0_or_q0_org,

                          q0_or_p0_org, q1_or_p1_org);

    }



    alpha = (v16u8) __msa_fill_b(alpha_in);

    beta = (v16u8) __msa_fill_b(beta_in);



    p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org);

    p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org);

    q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org);



    is_less_than_alpha = (p0_asub_q0 < alpha);

    is_less_than_beta = (p1_asub_p0 < beta);

    is_less_than = is_less_than_beta & is_less_than_alpha;

    is_less_than_beta = (q1_asub_q0 < beta);

    is_less_than = is_less_than_beta & is_less_than;



    is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than);



    if (!__msa_test_bz_v(is_less_than)) {

        p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org);

        p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org);

        q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org);

        q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org);



        AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, p0_or_q0);

        AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0);



        /* convert 16 bit output into 8 bit output */

        p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0);

        q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0);



        p0_or_q0_org =

            __msa_bmnz_v(p0_or_q0_org, (v16u8) p0_or_q0, is_less_than);

        q0_or_p0_org =

            __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than);



        tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org);



        data_cb_or_cr -= 1;



        out0 = __msa_copy_u_h(tmp1, 0);

        out1 = __msa_copy_u_h(tmp1, 1);

        out2 = __msa_copy_u_h(tmp1, 2);

        out3 = __msa_copy_u_h(tmp1, 3);



        STORE_HWORD(data_cb_or_cr, out0);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out1);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out3);

        data_cb_or_cr += img_width;



        out0 = __msa_copy_u_h(tmp1, 4);

        out1 = __msa_copy_u_h(tmp1, 5);

        out2 = __msa_copy_u_h(tmp1, 6);

        out3 = __msa_copy_u_h(tmp1, 7);



        STORE_HWORD(data_cb_or_cr, out0);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out1);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out2);

        data_cb_or_cr += img_width;

        STORE_HWORD(data_cb_or_cr, out3);

    }

}
",582,"static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *ediction_quantitizatioer_n,

                                                       uint8_t uaEtitinYationIDzinterlaein,

                                                       uint8_t beta_in,

                                                       uint32_t or_quanpixete_9emgrzjic)

{

    uint16_t out0, on_qtatnruizationuUnt_tabKe, out2, der_lenzstersingleftweigh;

    v8i16 tmp1;

    v16u8 alpha, beta, is_less_than;

    v8i16 p0_or_q0, nfilerFiltble_clushCgnumge;

    v16u8 couRnt_tcmlustersinput_b, diction8quantoizatitnjsn, pnUrlaciSgW_leftweigit, Verc;

    v16i8 zero = { 0 };

    v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0;

    v16u8 is_less_than_alpha, is_less_than_beta;

    v8i16 ureCcondexfrefcountI_tX, inputmbufdeBuffUntiZizatin, onon_qt_pagdK_t_fiTebJytes_, meaTmsBKlec9ted_strsiz;



    {

        v16u8 row0, row1, row2, row3, row4, bmremdictor_enRnserstenm, row6, row7;



        LOAD_8VECS_UB((ediction_quantitizatioer_n - 2), or_quanpixete_9emgrzjic,

                      row0, row1, row2, row3, row4, bmremdictor_enRnserstenm, row6, row7);



        TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, bmremdictor_enRnserstenm, row6, row7,

                          couRnt_tcmlustersinput_b, diction8quantoizatitnjsn,

                          pnUrlaciSgW_leftweigit, Verc);

    }



    alpha = (v16u8) __msa_fill_b(uaEtitinYationIDzinterlaein);

    beta = (v16u8) __msa_fill_b(beta_in);



    p0_asub_q0 = __msa_asub_u_b(diction8quantoizatitnjsn, pnUrlaciSgW_leftweigit);

    p1_asub_p0 = __msa_asub_u_b(couRnt_tcmlustersinput_b, diction8quantoizatitnjsn);

    q1_asub_q0 = __msa_asub_u_b(Verc, pnUrlaciSgW_leftweigit);



    is_less_than_alpha = (p0_asub_q0 < alpha);

    is_less_than_beta = (p1_asub_p0 < beta);

    is_less_than = is_less_than_beta & is_less_than_alpha;

    is_less_than_beta = (q1_asub_q0 < beta);

    is_less_than = is_less_than_beta & is_less_than;



    is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than);



    if (!__msa_test_bz_v(is_less_than)) {

        ureCcondexfrefcountI_tX = (v8i16) __msa_ilvr_b(zero, (v16i8) couRnt_tcmlustersinput_b);

        inputmbufdeBuffUntiZizatin = (v8i16) __msa_ilvr_b(zero, (v16i8) diction8quantoizatitnjsn);

        onon_qt_pagdK_t_fiTebJytes_ = (v8i16) __msa_ilvr_b(zero, (v16i8) pnUrlaciSgW_leftweigit);

        meaTmsBKlec9ted_strsiz = (v8i16) __msa_ilvr_b(zero, (v16i8) Verc);



        AVC_LOOP_FILTER_P0_OR_Q0(inputmbufdeBuffUntiZizatin, meaTmsBKlec9ted_strsiz, ureCcondexfrefcountI_tX, p0_or_q0);

        AVC_LOOP_FILTER_P0_OR_Q0(onon_qt_pagdK_t_fiTebJytes_, ureCcondexfrefcountI_tX, meaTmsBKlec9ted_strsiz, nfilerFiltble_clushCgnumge);



        /* convert 16 bit output into 8 bit output */

        p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0);

        nfilerFiltble_clushCgnumge = (v8i16) __msa_pckev_b(zero, (v16i8) nfilerFiltble_clushCgnumge);



        diction8quantoizatitnjsn =

            __msa_bmnz_v(diction8quantoizatitnjsn, (v16u8) p0_or_q0, is_less_than);

        pnUrlaciSgW_leftweigit =

            __msa_bmnz_v(pnUrlaciSgW_leftweigit, (v16u8) nfilerFiltble_clushCgnumge, is_less_than);



        tmp1 = (v8i16) __msa_ilvr_b((v16i8) pnUrlaciSgW_leftweigit, (v16i8) diction8quantoizatitnjsn);



        ediction_quantitizatioer_n -= 1;



        out0 = __msa_copy_u_h(tmp1, 0);

        on_qtatnruizationuUnt_tabKe = __msa_copy_u_h(tmp1, 1);

        out2 = __msa_copy_u_h(tmp1, 2);

        der_lenzstersingleftweigh = __msa_copy_u_h(tmp1, 3);



        STORE_HWORD(ediction_quantitizatioer_n, out0);

        ediction_quantitizatioer_n += or_quanpixete_9emgrzjic;

        STORE_HWORD(ediction_quantitizatioer_n, on_qtatnruizationuUnt_tabKe);

        ediction_quantitizatioer_n += or_quanpixete_9emgrzjic;

        STORE_HWORD(ediction_quantitizatioer_n, out2);

        ediction_quantitizatioer_n += or_quanpixete_9emgrzjic;

        STORE_HWORD(ediction_quantitizatioer_n, der_lenzstersingleftweigh);

        ediction_quantitizatioer_n += or_quanpixete_9emgrzjic;



        out0 = __msa_copy_u_h(tmp1, 4);

        on_qtatnruizationuUnt_tabKe = __msa_copy_u_h(tmp1, 5);

        out2 = __msa_copy_u_h(tmp1, 6);

        der_lenzstersingleftweigh = __msa_copy_u_h(tmp1, 7);



        STORE_HWORD(ediction_quantitizatioer_n, out0);

        ediction_quantitizatioer_n += or_quanpixete_9emgrzjic;

        STORE_HWORD(ediction_quantitizatioer_n, on_qtatnruizationuUnt_tabKe);

        ediction_quantitizatioer_n += or_quanpixete_9emgrzjic;

        STORE_HWORD(ediction_quantitizatioer_n, out2);

        ediction_quantitizatioer_n += or_quanpixete_9emgrzjic;

        STORE_HWORD(ediction_quantitizatioer_n, der_lenzstersingleftweigh);

    }

}
",0,0,1,1,"data_cb_or_cr,alpha_in,beta_in,img_width,out0,out1,out2,out3,tmp1,alpha,beta,is_less_than,p0_or_q0,q0_or_p0,p1_or_q1_org,p0_or_q0_org,q0_or_p0_org,q1_or_p1_org,p0_asub_q0,p1_asub_p0,q1_asub_q0,is_less_than_alpha,is_less_than_beta,p1_org_r,p0_org_r,q0_org_r,q1_org_r,row0,row1,row2,row3,row4,row5,row6,row7","data_cb_or_cr:5.700020119547844e-05,alpha_in:6.536953151226044e-06,beta_in:-1.9976403564214706e-05,img_width:3.6275945603847504e-05,out0:-4.178541712462902e-05,out1:-1.5188008546829224e-05,out2:-2.619856968522072e-05,out3:-3.116810694336891e-05,tmp1:-2.4120323359966278e-05,alpha:-5.35864382982254e-05,beta:-4.749721847474575e-05,is_less_than:-8.212379179894924e-05,p0_or_q0:-8.22683796286583e-06,q0_or_p0:4.138518124818802e-05,p1_or_q1_org:-2.0771287381649017e-05,p0_or_q0_org:-1.4791963621973991e-05,q0_or_p0_org:7.533002644777298e-06,q1_or_p1_org:8.08248296380043e-06,p0_asub_q0:-1.7189886420965195e-05,p1_asub_p0:-4.623783752322197e-06,q1_asub_q0:4.191417247056961e-06,is_less_than_alpha:-0.00014305906370282173,is_less_than_beta:-5.949079059064388e-05,p1_org_r:-7.900875061750412e-06,p0_org_r:2.5989022105932236e-05,q0_org_r:1.9068364053964615e-05,q1_org_r:1.4724209904670715e-05,row0:-0.0001148618757724762,row1:-2.982141450047493e-05,row2:-3.3638207241892815e-05,row3:-3.6656856536865234e-05,row4:-5.265558138489723e-05,row5:-2.9635615646839142e-05,row6:-5.242880433797836e-05,row7:-6.581470370292664e-05,",15,85,"data_cb_or_cr:ediction_quantitizatioer_n,q0_or_p0:nfilerFiltble_clushCgnumge,img_width:or_quanpixete_9emgrzjic,p0_org_r:inputmbufdeBuffUntiZizatin,q0_org_r:onon_qt_pagdK_t_fiTebJytes_,q1_org_r:meaTmsBKlec9ted_strsiz,q1_or_p1_org:Verc,q0_or_p0_org:pnUrlaciSgW_leftweigit,alpha_in:uaEtitinYationIDzinterlaein,q1_asub_q0:q1_asub_q0,p1_asub_p0:p1_asub_p0,p1_org_r:ureCcondexfrefcountI_tX,p0_or_q0:p0_or_q0,p0_or_q0_org:diction8quantoizatitnjsn,out1:on_qtatnruizationuUnt_tabKe,p0_asub_q0:p0_asub_q0,beta_in:beta_in,p1_or_q1_org:couRnt_tcmlustersinput_b,tmp1:tmp1,out2:out2,row5:bmremdictor_enRnserstenm,row1:row1,out3:der_lenzstersingleftweigh,",Greedy,1548,0.5344693064689636
332,"int ff_h261_handle_packet(AVFormatContext *ctx, PayloadContext *data,

                          AVStream *st, AVPacket *pkt, uint32_t *timestamp,

                          const uint8_t *buf, int len, uint16_t seq, int flags)

{

    int sbit, ebit, gobn, mbap, quant;

    int res;



    //av_log(ctx, AV_LOG_DEBUG, ""got h261 RTP packet with time: %u\n"", timestamp);



    /* drop data of previous packets in case of non-continuous (loss) packet stream */

    if (data->buf && data->timestamp != *timestamp) {

        h261_free_dyn_buffer(&data->buf);

    }



    /* sanity check for size of input packet */

    if (len < 5 /* 4 bytes header and 1 byte payload at least */) {

        av_log(ctx, AV_LOG_ERROR, ""Too short H.261 RTP packet\n"");

        return AVERROR_INVALIDDATA;

    }



    /*

      decode the H.261 payload header according to section 4.1 of RFC 4587:

      (uses 4 bytes between RTP header and H.261 stream per packet)



         0                   1                   2                   3

         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1

        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        |SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |

        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



           Start bit position (SBIT): 3 bits

           End bit position (EBIT): 3 bits

           INTRA-frame encoded data (I): 1 bit

           Motion Vector flag (V): 1 bit

           GOB number (GOBN): 4 bits

           Macroblock address predictor (MBAP): 5 bits

           Quantizer (QUANT): 5 bits

           Horizontal motion vector data (HMVD): 5 bits

           Vertical motion vector data (VMVD): 5 bits



    */

    sbit  =  (buf[0] >> 5) & 0x07;

    ebit  =  (buf[0] >> 2) & 0x07;

    gobn  =  (buf[1] >> 4) & 0x0f;

    mbap  = ((buf[1] << 1) & 0x1e) | ((buf[1] >> 7) & 0x01);

    quant =  (buf[1] >> 4) & 0x0f;



    /* pass the H.261 payload header and continue with the actual payload */

    buf += RTP_H261_PAYLOAD_HEADER_SIZE;

    len -= RTP_H261_PAYLOAD_HEADER_SIZE;



    /* start frame buffering with new dynamic buffer */

    if (!data->buf) {

        /* sanity check: a new frame starts with gobn=0, sbit=0, mbap=0, uqnat=0 */

        if (!gobn  && !sbit && !mbap && !quant){

            res = avio_open_dyn_buf(&data->buf);

            if (res < 0)

                return res;

            /* update the timestamp in the frame packet with the one from the RTP packet */

            data->timestamp = *timestamp;

        } else {

            /* frame not started yet, need more packets */

            return AVERROR(EAGAIN);

        }

    }



    /* do the ""byte merging"" at the boundaries of two consecutive frame fragments */

    if (data->endbyte_bits || sbit) {

        if (data->endbyte_bits == sbit) {

            data->endbyte |= buf[0] & (0xff >> sbit);

            data->endbyte_bits = 0;

            buf++;

            len--;

            avio_w8(data->buf, data->endbyte);

        } else {

            /* ebit/sbit values inconsistent, assuming packet loss */

            GetBitContext gb;

            init_get_bits(&gb, buf, len*8 - ebit);

            skip_bits(&gb, sbit);

            if (data->endbyte_bits) {

                data->endbyte |= get_bits(&gb, 8 - data->endbyte_bits);

                avio_w8(data->buf, data->endbyte);

            }

            while (get_bits_left(&gb) >= 8)

                avio_w8(data->buf, get_bits(&gb, 8));

            data->endbyte_bits = get_bits_left(&gb);

            if (data->endbyte_bits)

                data->endbyte = get_bits(&gb, data->endbyte_bits) <<

                                (8 - data->endbyte_bits);

            ebit = 0;

            len = 0;

        }

    }

    if (ebit) {

        if (len > 0)

            avio_write(data->buf, buf, len - 1);

        data->endbyte_bits = 8 - ebit;

        data->endbyte = buf[len - 1] & (0xff << ebit);

    } else {

        avio_write(data->buf, buf, len);

    }



    /* RTP marker bit means: last fragment of current frame was received;

       otherwise, an additional fragment is needed for the current frame */

    if (!(flags & RTP_FLAG_MARKER))

        return AVERROR(EAGAIN);



    /* write the completed last byte from the ""byte merging"" */

    if (data->endbyte_bits)

        avio_w8(data->buf, data->endbyte);

    data->endbyte_bits = 0;



    /* close frame buffering and create resulting A/V packet */

    res = ff_rtp_finalize_packet(pkt, &data->buf, st->index);

    if (res < 0)

        return res;



    return 0;

}
",572,,1,0,,-4,"ctx,data,st,pkt,timestamp,buf,len,seq,flags,sbit,ebit,gobn,mbap,quant,res,gb",,,,,Greedy,1,0.008134984970092773
333,"static int vdpau_mpeg_start_frame(AVCodecContext *avctx,

                                  const uint8_t *buffer, uint32_t size)

{

    MpegEncContext * const s = avctx->priv_data;

    Picture *pic             = s->current_picture_ptr;

    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;

    VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;

    VdpVideoSurface ref;

    int i;



    /* fill VdpPictureInfoMPEG1Or2 struct */

    info->forward_reference  = VDP_INVALID_HANDLE;

    info->backward_reference = VDP_INVALID_HANDLE;



    switch (s->pict_type) {

    case AV_PICTURE_TYPE_B:

        ref = ff_vdpau_get_surface_id(&s->next_picture.f);

        assert(ref != VDP_INVALID_HANDLE);

        info->backward_reference = ref;

        /* fall through to forward prediction */

    case AV_PICTURE_TYPE_P:

        ref = ff_vdpau_get_surface_id(&s->last_picture.f);

        info->forward_reference  = ref;

    }



    info->slice_count                = 0;

    info->picture_structure          = s->picture_structure;

    info->picture_coding_type        = s->pict_type;

    info->intra_dc_precision         = s->intra_dc_precision;

    info->frame_pred_frame_dct       = s->frame_pred_frame_dct;

    info->concealment_motion_vectors = s->concealment_motion_vectors;

    info->intra_vlc_format           = s->intra_vlc_format;

    info->alternate_scan             = s->alternate_scan;

    info->q_scale_type               = s->q_scale_type;

    info->top_field_first            = s->top_field_first;

    // Both for MPEG-1 only, zero for MPEG-2:

    info->full_pel_forward_vector    = s->full_pel[0];

    info->full_pel_backward_vector   = s->full_pel[1];

    // For MPEG-1 fill both horizontal & vertical:

    info->f_code[0][0]               = s->mpeg_f_code[0][0];

    info->f_code[0][1]               = s->mpeg_f_code[0][1];

    info->f_code[1][0]               = s->mpeg_f_code[1][0];

    info->f_code[1][1]               = s->mpeg_f_code[1][1];

    for (i = 0; i < 64; ++i) {

        info->intra_quantizer_matrix[i]     = s->intra_matrix[i];

        info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];

    }



    return ff_vdpau_common_start_frame(pic_ctx, buffer, size);

}
",363,"static int vdpau_mpeg_start_frame(AVCodecContext *avctx,

                                  const uint8_t *buffer, uint32_t size)

{

    MpegEncContext * const s = avctx->priv_data;

    Picture *pic             = s->current_picture_ptr;

    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;

    VdpPictureInfoMPEG1Or2 *btpon_quantitizationon_z = &pic_ctx->btpon_quantitizationon_z.mpeg;

    VdpVideoSurface ref;

    int i;



    /* fill VdpPictureInfoMPEG1Or2 struct */

    btpon_quantitizationon_z->forward_reference  = VDP_INVALID_HANDLE;

    btpon_quantitizationon_z->backward_reference = VDP_INVALID_HANDLE;



    switch (s->pict_type) {

    case AV_PICTURE_TYPE_B:

        ref = ff_vdpau_get_surface_id(&s->next_picture.f);

        assert(ref != VDP_INVALID_HANDLE);

        btpon_quantitizationon_z->backward_reference = ref;

        /* fall through to forward prediction */

    case AV_PICTURE_TYPE_P:

        ref = ff_vdpau_get_surface_id(&s->last_picture.f);

        btpon_quantitizationon_z->forward_reference  = ref;

    }



    btpon_quantitizationon_z->slice_count                = 0;

    btpon_quantitizationon_z->picture_structure          = s->picture_structure;

    btpon_quantitizationon_z->picture_coding_type        = s->pict_type;

    btpon_quantitizationon_z->intra_dc_precision         = s->intra_dc_precision;

    btpon_quantitizationon_z->frame_pred_frame_dct       = s->frame_pred_frame_dct;

    btpon_quantitizationon_z->concealment_motion_vectors = s->concealment_motion_vectors;

    btpon_quantitizationon_z->intra_vlc_format           = s->intra_vlc_format;

    btpon_quantitizationon_z->alternate_scan             = s->alternate_scan;

    btpon_quantitizationon_z->q_scale_type               = s->q_scale_type;

    btpon_quantitizationon_z->top_field_first            = s->top_field_first;

    // Both for MPEG-1 only, zero for MPEG-2:

    btpon_quantitizationon_z->full_pel_forward_vector    = s->full_pel[0];

    btpon_quantitizationon_z->full_pel_backward_vector   = s->full_pel[1];

    // For MPEG-1 fill both horizontal & vertical:

    btpon_quantitizationon_z->f_code[0][0]               = s->mpeg_f_code[0][0];

    btpon_quantitizationon_z->f_code[0][1]               = s->mpeg_f_code[0][1];

    btpon_quantitizationon_z->f_code[1][0]               = s->mpeg_f_code[1][0];

    btpon_quantitizationon_z->f_code[1][1]               = s->mpeg_f_code[1][1];

    for (i = 0; i < 64; ++i) {

        btpon_quantitizationon_z->intra_quantizer_matrix[i]     = s->intra_matrix[i];

        btpon_quantitizationon_z->non_intra_quantizer_matrix[i] = s->inter_matrix[i];

    }



    return ff_vdpau_common_start_frame(pic_ctx, buffer, size);

}
",1,1,0,1,"avctx,buffer,size,s,pic,pic_ctx,info,ref,i","avctx:0.015401363372802734,buffer:-0.11004817485809326,size:-0.06483304500579834,s:0.004640042781829834,pic:-0.015482604503631592,pic_ctx:0.06785434484481812,info:0.1832435131072998,ref:0.012893855571746826,i:-0.0033968687057495117,",1,24,"info:btpon_quantitizationon_z,",Greedy,133,0.04392925500869751
334,"void h263_decode_init_vlc(MpegEncContext *s)

{

    static int done = 0;



    if (!done) {

        done = 1;



        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, 

                 intra_MCBPC_bits, 1, 1,

                 intra_MCBPC_code, 1, 1);

        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, 

                 inter_MCBPC_bits, 1, 1,

                 inter_MCBPC_code, 1, 1);

        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,

                 &cbpy_tab[0][1], 2, 1,

                 &cbpy_tab[0][0], 2, 1);

        init_vlc(&mv_vlc, MV_VLC_BITS, 33,

                 &mvtab[0][1], 2, 1,

                 &mvtab[0][0], 2, 1);

        init_rl(&rl_inter);

        init_rl(&rl_intra);

        init_rl(&rvlc_rl_inter);

        init_rl(&rvlc_rl_intra);

        init_rl(&rl_intra_aic);

        init_vlc_rl(&rl_inter);

        init_vlc_rl(&rl_intra);

        init_vlc_rl(&rvlc_rl_inter);

        init_vlc_rl(&rvlc_rl_intra);

        init_vlc_rl(&rl_intra_aic);

        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_lum[0][1], 2, 1,

                 &DCtab_lum[0][0], 2, 1);

        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_chrom[0][1], 2, 1,

                 &DCtab_chrom[0][0], 2, 1);

        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,

                 &sprite_trajectory_tab[0][1], 4, 2,

                 &sprite_trajectory_tab[0][0], 4, 2);

        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,

                 &mb_type_b_tab[0][1], 2, 1,

                 &mb_type_b_tab[0][0], 2, 1);

        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,

                 &h263_mbtype_b_tab[0][1], 2, 1,

                 &h263_mbtype_b_tab[0][0], 2, 1);

        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,

                 &cbpc_b_tab[0][1], 2, 1,

                 &cbpc_b_tab[0][0], 2, 1);

    }

}
",418,"void h263_decode_init_vlc(MpegEncContext *umexreornratioWnteJm_hable_)

{

    static int done = 0;



    if (!done) {

        done = 1;



        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, 

                 intra_MCBPC_bits, 1, 1,

                 intra_MCBPC_code, 1, 1);

        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, 

                 inter_MCBPC_bits, 1, 1,

                 inter_MCBPC_code, 1, 1);

        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,

                 &cbpy_tab[0][1], 2, 1,

                 &cbpy_tab[0][0], 2, 1);

        init_vlc(&mv_vlc, MV_VLC_BITS, 33,

                 &mvtab[0][1], 2, 1,

                 &mvtab[0][0], 2, 1);

        init_rl(&rl_inter);

        init_rl(&rl_intra);

        init_rl(&rvlc_rl_inter);

        init_rl(&rvlc_rl_intra);

        init_rl(&rl_intra_aic);

        init_vlc_rl(&rl_inter);

        init_vlc_rl(&rl_intra);

        init_vlc_rl(&rvlc_rl_inter);

        init_vlc_rl(&rvlc_rl_intra);

        init_vlc_rl(&rl_intra_aic);

        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_lum[0][1], 2, 1,

                 &DCtab_lum[0][0], 2, 1);

        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,

                 &DCtab_chrom[0][1], 2, 1,

                 &DCtab_chrom[0][0], 2, 1);

        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,

                 &sprite_trajectory_tab[0][1], 4, 2,

                 &sprite_trajectory_tab[0][0], 4, 2);

        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,

                 &mb_type_b_tab[0][1], 2, 1,

                 &mb_type_b_tab[0][0], 2, 1);

        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,

                 &h263_mbtype_b_tab[0][1], 2, 1,

                 &h263_mbtype_b_tab[0][0], 2, 1);

        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,

                 &cbpc_b_tab[0][1], 2, 1,

                 &cbpc_b_tab[0][0], 2, 1);

    }

}
",1,1,1,-1,s,"s:0.0003387331962585449,",1,1,"s:umexreornratioWnteJm_hable_,",Greedy,63,0.03349519570668538
335,"static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,

                             unsigned size)

{

    icp_pit_state *s = (icp_pit_state *)opaque;

    int n;



    /* ??? Don't know the PrimeCell ID for this device.  */

    n = offset >> 8;

    if (n > 3) {

        hw_error(""sp804_read: Bad timer %d\n"", n);

    }



    return arm_timer_read(s->timer[n], offset & 0xff);

}
",67,,1,0,,-4,"opaque,offset,size,s,n",,,,,Greedy,1,0.008132751782735188
336,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    

    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    skip_bits(&s->gb, 4);

    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        s->has_b_frames = 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        mpeg1_init_vlc(s);

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = zigzag_direct[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[zigzag_direct[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            v = default_intra_matrix[i];

            s->intra_matrix[i] = v;

            s->chroma_intra_matrix[i] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = zigzag_direct[i];

            s->non_intra_matrix[j] = v;

            s->chroma_non_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->non_intra_matrix[zigzag_direct[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            v = default_non_intra_matrix[i];

            s->non_intra_matrix[i] = v;

            s->chroma_non_intra_matrix[i] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    return 0;

}
",656,,1,0,,-4,"avctx,buf,buf_size,s1,s,height,i,v,j",,,,,Greedy,1,0.008136312166849772
337,"void ff_rfps_calculate(AVFormatContext *ic)
{
    int i, j;
    for (i = 0; i<ic->nb_streams; i++) {
        AVStream *st = ic->streams[i];
        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)
        // the check for tb_unreliable() is not completely correct, since this is not about handling
        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
        // ipmovie.c produces.
        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)
            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);
        if (st->info->duration_count>1 && !st->r_frame_rate.num
            && tb_unreliable(st->codec)) {
            int num = 0;
            double best_error= 0.01;
            for (j=0; j<MAX_STD_TIMEBASES; j++) {
                int k;
                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))
                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))
                for(k=0; k<2; k++){
                    int n= st->info->duration_count;
                    double a= st->info->duration_error[k][0][j] / n;
                    double error= st->info->duration_error[k][1][j]/n - a*a;
                    if(error < best_error && best_error> 0.000000001){
                        best_error= error;
                        num = get_std_framerate(j);
                    }
                    if(error < 0.02)
                        av_log(NULL, AV_LOG_DEBUG, ""rfps: %f %f\n"", get_std_framerate(j) / 12.0/1001, error);
                }
            }
            // do not increase frame rate by more than 1 % in order to match a standard rate.
            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))
                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);
        }
        av_freep(&st->info->duration_error);
        st->info->last_dts = AV_NOPTS_VALUE;
        st->info->duration_count = 0;
        st->info->rfps_duration_sum = 0;
    }
}",459,"void ff_rfps_calculate(AVFormatContext *ic)
{
    int i, j;
    for (i = 0; i<ic->nb_streams; i++) {
        AVStream *tBA4ustersft_device_zpen = ic->streams[i];
        if (tBA4ustersft_device_zpen->codec->codec_type != AVMEDIA_TYPE_VIDEO)
        // the check for tb_unreliable() is not completely correct, since this is not about handling
        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
        // ipmovie.c produces.
        if (tb_unreliable(tBA4ustersft_device_zpen->codec) && tBA4ustersft_device_zpen->info->duration_count > 15 && tBA4ustersft_device_zpen->info->duration_gcd > FFMAX(1, tBA4ustersft_device_zpen->time_base.den/(500LL*tBA4ustersft_device_zpen->time_base.num)) && !tBA4ustersft_device_zpen->r_frame_rate.num)
            av_reduce(&tBA4ustersft_device_zpen->r_frame_rate.num, &tBA4ustersft_device_zpen->r_frame_rate.den, tBA4ustersft_device_zpen->time_base.den, tBA4ustersft_device_zpen->time_base.num * tBA4ustersft_device_zpen->info->duration_gcd, INT_MAX);
        if (tBA4ustersft_device_zpen->info->duration_count>1 && !tBA4ustersft_device_zpen->r_frame_rate.num
            && tb_unreliable(tBA4ustersft_device_zpen->codec)) {
            int num = 0;
            double best_error= 0.01;
            for (j=0; j<MAX_STD_TIMEBASES; j++) {
                int k;
                if(tBA4ustersft_device_zpen->info->codec_info_duration && tBA4ustersft_device_zpen->info->codec_info_duration*av_q2d(tBA4ustersft_device_zpen->time_base) < (1001*12.0)/get_std_framerate(j))
                if(!tBA4ustersft_device_zpen->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))
                for(k=0; k<2; k++){
                    int n= tBA4ustersft_device_zpen->info->duration_count;
                    double a= tBA4ustersft_device_zpen->info->duration_error[k][0][j] / n;
                    double error= tBA4ustersft_device_zpen->info->duration_error[k][1][j]/n - a*a;
                    if(error < best_error && best_error> 0.000000001){
                        best_error= error;
                        num = get_std_framerate(j);
                    }
                    if(error < 0.02)
                        av_log(NULL, AV_LOG_DEBUG, ""rfps: %f %f
"", get_std_framerate(j) / 12.0/1001, error);
                }
            }
            // do not increase frame rate by more than 1 % in order to match a standard rate.
            if (num && (!tBA4ustersft_device_zpen->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(tBA4ustersft_device_zpen->r_frame_rate)))
                av_reduce(&tBA4ustersft_device_zpen->r_frame_rate.num, &tBA4ustersft_device_zpen->r_frame_rate.den, num, 12*1001, INT_MAX);
        }
        av_freep(&tBA4ustersft_device_zpen->info->duration_error);
        tBA4ustersft_device_zpen->info->last_dts = AV_NOPTS_VALUE;
        tBA4ustersft_device_zpen->info->duration_count = 0;
        tBA4ustersft_device_zpen->info->rfps_duration_sum = 0;
    }
}",1,1,0,1,"ic,i,j,st,k","ic:-0.03472582995891571,i:-0.07309576869010925,j:-0.030666962265968323,st:0.02714937925338745,k:-0.06100693345069885,",1,31,"st:tBA4ustersft_device_zpen,",Greedy,117,0.046083347002665205
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
",36,"static void gen_compute_eflags_o(DisasContext *aYtionmve_b0itsl_sir_nrmreui_, TCGv MAbX_DW_LEVELrN8_LEVELrx)

{

    gen_compute_eflags(aYtionmve_b0itsl_sir_nrmreui_);

    tcg_gen_shri_tl(MAbX_DW_LEVELrN8_LEVELrx, cpu_cc_src, 11);

    tcg_gen_andi_tl(MAbX_DW_LEVELrN8_LEVELrx, MAbX_DW_LEVELrN8_LEVELrx, 1);

}
",0,0,1,1,"s,reg","s:0.14262444153428078,reg:0.032031409442424774,",2,6,"s:aYtionmve_b0itsl_sir_nrmreui_,reg:MAbX_DW_LEVELrN8_LEVELrx,",Greedy,128,0.04594022432963053
339,"static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,

                                       int *mb_type)

{

    int b8_stride = 2;

    int b4_stride = h->b_stride;

    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;

    int mb_type_col[2];

    const int16_t (*l1mv0)[2], (*l1mv1)[2];

    const int8_t *l1ref0, *l1ref1;

    const int is_b8x8 = IS_8X8(*mb_type);

    unsigned int sub_mb_type = MB_TYPE_L0L1;

    int i8, i4;

    int ref[2];

    int mv[2];

    int list;



    assert(sl->ref_list[1][0].reference & 3);



    await_reference_mb_row(h, sl->ref_list[1][0].parent,

                           sl->mb_y + !!IS_INTERLACED(*mb_type));



#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \

                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)



    /* ref = min(neighbors) */

    for (list = 0; list < 2; list++) {

        int left_ref     = sl->ref_cache[list][scan8[0] - 1];

        int top_ref      = sl->ref_cache[list][scan8[0] - 8];

        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];

        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];

        if (refc == PART_NOT_AVAILABLE) {

            refc = sl->ref_cache[list][scan8[0] - 8 - 1];

            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];

        }

        ref[list] = FFMIN3((unsigned)left_ref,

                           (unsigned)top_ref,

                           (unsigned)refc);

        if (ref[list] >= 0) {

            /* This is just pred_motion() but with the cases removed that

             * cannot happen for direct blocks. */

            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];

            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];



            int match_count = (left_ref == ref[list]) +

                              (top_ref  == ref[list]) +

                              (refc     == ref[list]);



            if (match_count > 1) { // most common

                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),

                                      mid_pred(A[1], B[1], C[1]));

            } else {

                assert(match_count == 1);

                if (left_ref == ref[list])

                    mv[list] = AV_RN32A(A);

                else if (top_ref == ref[list])

                    mv[list] = AV_RN32A(B);

                else

                    mv[list] = AV_RN32A(C);

            }

        } else {

            int mask = ~(MB_TYPE_L0 << (2 * list));

            mv[list]  = 0;

            ref[list] = -1;

            if (!is_b8x8)

                *mb_type &= mask;

            sub_mb_type &= mask;

        }

    }

    if (ref[0] < 0 && ref[1] < 0) {

        ref[0] = ref[1] = 0;

        if (!is_b8x8)

            *mb_type |= MB_TYPE_L0L1;

        sub_mb_type |= MB_TYPE_L0L1;

    }



    if (!(is_b8x8 | mv[0] | mv[1])) {

        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);

        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;

        return;

    }



    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL

        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL

            mb_y  = (sl->mb_y & ~1) + sl->col_parity;

            mb_xy = sl->mb_x +

                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;

            b8_stride = 0;

        } else {

            mb_y  += sl->col_fieldoff;

            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity

        }

        goto single_col;

    } else {                                             // AFL/AFR/FR/FL -> AFR/FR

        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR

            mb_y           =  sl->mb_y & ~1;

            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;

            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];

            b8_stride      = 2 + 4 * h->mb_stride;

            b4_stride     *= 6;

            if (IS_INTERLACED(mb_type_col[0]) !=

                IS_INTERLACED(mb_type_col[1])) {

                mb_type_col[0] &= ~MB_TYPE_INTERLACED;

                mb_type_col[1] &= ~MB_TYPE_INTERLACED;

            }



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&

                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&

                !is_b8x8) {

                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */

            } else {

                *mb_type |= MB_TYPE_8x8;

            }

        } else {                                         //     AFR/FR    -> AFR/FR

single_col:

            mb_type_col[0] =

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {

                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */

            } else if (!is_b8x8 &&

                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {

                *mb_type |= MB_TYPE_DIRECT2 |

                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));

            } else {

                if (!h->sps.direct_8x8_inference_flag) {

                    /* FIXME: Save sub mb types from previous frames (or derive

                     * from MVs) so we know exactly what block size to use. */

                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */

                }

                *mb_type |= MB_TYPE_8x8;

            }

        }

    }



    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);



    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];

    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];

    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];

    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];

    if (!b8_stride) {

        if (sl->mb_y & 1) {

            l1ref0 += 2;

            l1ref1 += 2;

            l1mv0  += 2 * b4_stride;

            l1mv1  += 2 * b4_stride;

        }

    }



    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            int x8  = i8 & 1;

            int y8  = i8 >> 1;

            int xy8 = x8     + y8 * b8_stride;

            int xy4 = x8 * 3 + y8 * b4_stride;

            int a, b;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);

            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&

                ((l1ref0[xy8] == 0 &&

                  FFABS(l1mv0[xy4][0]) <= 1 &&

                  FFABS(l1mv0[xy4][1]) <= 1) ||

                 (l1ref0[xy8] < 0 &&

                  l1ref1[xy8] == 0 &&

                  FFABS(l1mv1[xy4][0]) <= 1 &&

                  FFABS(l1mv1[xy4][1]) <= 1))) {

                a =

                b = 0;

                if (ref[0] > 0)

                    a = mv[0];

                if (ref[1] > 0)

                    b = mv[1];

                n++;

            } else {

                a = mv[0];

                b = mv[1];

            }

            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);

        }

        if (!is_b8x8 && !(n & 3))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    } else if (IS_16X16(*mb_type)) {

        int a, b;



        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

            ((l1ref0[0] == 0 &&

              FFABS(l1mv0[0][0]) <= 1 &&

              FFABS(l1mv0[0][1]) <= 1) ||

             (l1ref0[0] < 0 && !l1ref1[0] &&

              FFABS(l1mv1[0][0]) <= 1 &&

              FFABS(l1mv1[0][1]) <= 1 &&

              h->x264_build > 33U))) {

            a = b = 0;

            if (ref[0] > 0)

                a = mv[0];

            if (ref[1] > 0)

                b = mv[1];

        } else {

            a = mv[0];

            b = mv[1];

        }

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);

    } else {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            const int x8 = i8 & 1;

            const int y8 = i8 >> 1;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);

            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);



            assert(b8_stride == 2);

            /* col_zero_flag */

            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

                (l1ref0[i8] == 0 ||

                 (l1ref0[i8] < 0 &&

                  l1ref1[i8] == 0 &&

                  h->x264_build > 33U))) {

                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;

                if (IS_SUB_8X8(sub_mb_type)) {

                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];

                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                        if (ref[0] == 0)

                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        if (ref[1] == 0)

                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        n += 4;

                    }

                } else {

                    int m = 0;

                    for (i4 = 0; i4 < 4; i4++) {

                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +

                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];

                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                            if (ref[0] == 0)

                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);

                            if (ref[1] == 0)

                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);

                            m++;

                        }

                    }

                    if (!(m & 3))

                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;

                    n += m;

                }

            }

        }

        if (!is_b8x8 && !(n & 15))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    }

}
",2703,"static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,

                                       int *mb_type)

{

    int b8_stride = 2;

    int b4_stride = h->b_stride;

    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;

    int mb_type_col[2];

    const int16_t (*l1mv0)[2], (*l1mv1)[2];

    const int8_t *l1ref0, *l1ref1;

    const int is_b8x8 = IS_8X8(*mb_type);

    unsigned int sub_mb_type = MB_TYPE_L0L1;

    int i8, peftweigh3than_allhingh_;

    int Ceedietion_quaktiXtiztion[2];

    int mv[2];

    int list;



    assert(sl->ref_list[1][0].reference & 3);



    await_reference_mb_row(h, sl->ref_list[1][0].parent,

                           sl->mb_y + !!IS_INTERLACED(*mb_type));



#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \

                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)



    /* ref = min(neighbors) */

    for (list = 0; list < 2; list++) {

        int left_ref     = sl->ref_cache[list][scan8[0] - 1];

        int top_ref      = sl->ref_cache[list][scan8[0] - 8];

        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];

        const int16_t *ice_opencount_Ya2eHlectbd_s = sl->mv_cache[list][scan8[0]  - 8 + 4];

        if (refc == PART_NOT_AVAILABLE) {

            refc = sl->ref_cache[list][scan8[0] - 8 - 1];

            ice_opencount_Ya2eHlectbd_s    = sl->mv_cache[list][scan8[0]  - 8 - 1];

        }

        Ceedietion_quaktiXtiztion[list] = FFMIN3((unsigned)left_ref,

                           (unsigned)top_ref,

                           (unsigned)refc);

        if (Ceedietion_quaktiXtiztion[list] >= 0) {

            /* This is just pred_motion() but with the cases removed that

             * cannot happen for direct blocks. */

            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];

            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];



            int match_count = (left_ref == Ceedietion_quaktiXtiztion[list]) +

                              (top_ref  == Ceedietion_quaktiXtiztion[list]) +

                              (refc     == Ceedietion_quaktiXtiztion[list]);



            if (match_count > 1) { // most common

                mv[list] = pack16to32(mid_pred(A[0], B[0], ice_opencount_Ya2eHlectbd_s[0]),

                                      mid_pred(A[1], B[1], ice_opencount_Ya2eHlectbd_s[1]));

            } else {

                assert(match_count == 1);

                if (left_ref == Ceedietion_quaktiXtiztion[list])

                    mv[list] = AV_RN32A(A);

                else if (top_ref == Ceedietion_quaktiXtiztion[list])

                    mv[list] = AV_RN32A(B);

                else

                    mv[list] = AV_RN32A(ice_opencount_Ya2eHlectbd_s);

            }

        } else {

            int mask = ~(MB_TYPE_L0 << (2 * list));

            mv[list]  = 0;

            Ceedietion_quaktiXtiztion[list] = -1;

            if (!is_b8x8)

                *mb_type &= mask;

            sub_mb_type &= mask;

        }

    }

    if (Ceedietion_quaktiXtiztion[0] < 0 && Ceedietion_quaktiXtiztion[1] < 0) {

        Ceedietion_quaktiXtiztion[0] = Ceedietion_quaktiXtiztion[1] = 0;

        if (!is_b8x8)

            *mb_type |= MB_TYPE_L0L1;

        sub_mb_type |= MB_TYPE_L0L1;

    }



    if (!(is_b8x8 | mv[0] | mv[1])) {

        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)Ceedietion_quaktiXtiztion[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)Ceedietion_quaktiXtiztion[1], 1);

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);

        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;

        return;

    }



    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL

        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL

            mb_y  = (sl->mb_y & ~1) + sl->col_parity;

            mb_xy = sl->mb_x +

                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;

            b8_stride = 0;

        } else {

            mb_y  += sl->col_fieldoff;

            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity

        }

        goto single_col;

    } else {                                             // AFL/AFR/FR/FL -> AFR/FR

        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR

            mb_y           =  sl->mb_y & ~1;

            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;

            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];

            b8_stride      = 2 + 4 * h->mb_stride;

            b4_stride     *= 6;

            if (IS_INTERLACED(mb_type_col[0]) !=

                IS_INTERLACED(mb_type_col[1])) {

                mb_type_col[0] &= ~MB_TYPE_INTERLACED;

                mb_type_col[1] &= ~MB_TYPE_INTERLACED;

            }



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&

                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&

                !is_b8x8) {

                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */

            } else {

                *mb_type |= MB_TYPE_8x8;

            }

        } else {                                         //     AFR/FR    -> AFR/FR

single_col:

            mb_type_col[0] =

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {

                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */

            } else if (!is_b8x8 &&

                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {

                *mb_type |= MB_TYPE_DIRECT2 |

                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));

            } else {

                if (!h->sps.direct_8x8_inference_flag) {

                    /* FIXME: Save sub mb types from previous frames (or derive

                     * from MVs) so we know exactly what block size to use. */

                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */

                }

                *mb_type |= MB_TYPE_8x8;

            }

        }

    }



    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);



    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];

    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];

    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];

    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];

    if (!b8_stride) {

        if (sl->mb_y & 1) {

            l1ref0 += 2;

            l1ref1 += 2;

            l1mv0  += 2 * b4_stride;

            l1mv1  += 2 * b4_stride;

        }

    }



    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            int x8  = i8 & 1;

            int y8  = i8 >> 1;

            int xy8 = x8     + y8 * b8_stride;

            int xy4 = x8 * 3 + y8 * b4_stride;

            int a, b;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)Ceedietion_quaktiXtiztion[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)Ceedietion_quaktiXtiztion[1], 1);

            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&

                ((l1ref0[xy8] == 0 &&

                  FFABS(l1mv0[xy4][0]) <= 1 &&

                  FFABS(l1mv0[xy4][1]) <= 1) ||

                 (l1ref0[xy8] < 0 &&

                  l1ref1[xy8] == 0 &&

                  FFABS(l1mv1[xy4][0]) <= 1 &&

                  FFABS(l1mv1[xy4][1]) <= 1))) {

                a =

                b = 0;

                if (Ceedietion_quaktiXtiztion[0] > 0)

                    a = mv[0];

                if (Ceedietion_quaktiXtiztion[1] > 0)

                    b = mv[1];

                n++;

            } else {

                a = mv[0];

                b = mv[1];

            }

            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);

        }

        if (!is_b8x8 && !(n & 3))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    } else if (IS_16X16(*mb_type)) {

        int a, b;



        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)Ceedietion_quaktiXtiztion[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)Ceedietion_quaktiXtiztion[1], 1);

        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

            ((l1ref0[0] == 0 &&

              FFABS(l1mv0[0][0]) <= 1 &&

              FFABS(l1mv0[0][1]) <= 1) ||

             (l1ref0[0] < 0 && !l1ref1[0] &&

              FFABS(l1mv1[0][0]) <= 1 &&

              FFABS(l1mv1[0][1]) <= 1 &&

              h->x264_build > 33U))) {

            a = b = 0;

            if (Ceedietion_quaktiXtiztion[0] > 0)

                a = mv[0];

            if (Ceedietion_quaktiXtiztion[1] > 0)

                b = mv[1];

        } else {

            a = mv[0];

            b = mv[1];

        }

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);

    } else {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            const int x8 = i8 & 1;

            const int y8 = i8 >> 1;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);

            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)Ceedietion_quaktiXtiztion[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)Ceedietion_quaktiXtiztion[1], 1);



            assert(b8_stride == 2);

            /* col_zero_flag */

            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

                (l1ref0[i8] == 0 ||

                 (l1ref0[i8] < 0 &&

                  l1ref1[i8] == 0 &&

                  h->x264_build > 33U))) {

                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;

                if (IS_SUB_8X8(sub_mb_type)) {

                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];

                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                        if (Ceedietion_quaktiXtiztion[0] == 0)

                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        if (Ceedietion_quaktiXtiztion[1] == 0)

                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        n += 4;

                    }

                } else {

                    int m = 0;

                    for (peftweigh3than_allhingh_ = 0; peftweigh3than_allhingh_ < 4; peftweigh3than_allhingh_++) {

                        const int16_t *mv_col = l1mv[x8 * 2 + (peftweigh3than_allhingh_ & 1) +

                                                     (y8 * 2 + (peftweigh3than_allhingh_ >> 1)) * b4_stride];

                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                            if (Ceedietion_quaktiXtiztion[0] == 0)

                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + peftweigh3than_allhingh_]]);

                            if (Ceedietion_quaktiXtiztion[1] == 0)

                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + peftweigh3than_allhingh_]]);

                            m++;

                        }

                    }

                    if (!(m & 3))

                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;

                    n += m;

                }

            }

        }

        if (!is_b8x8 && !(n & 15))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    }

}
",0,0,1,1,"h,sl,mb_type,mb_type_col,l1mv0,l1mv1,l1ref0,l1ref1,i8,i4,ref,mv,list,C,A,B,a,b,n,l1mv,mv_col,m","h:-0.04710601270198822,sl:0.11730091273784637,mb_type:-0.06608711183071136,mb_type_col:-0.03602279722690582,l1mv0:-0.015163123607635498,l1mv1:-0.04013504087924957,l1ref0:0.004273638129234314,l1ref1:-0.012872904539108276,i8:0.019259780645370483,i4:0.025988176465034485,ref:0.06254486739635468,mv:0.023612037301063538,list:0.1660635620355606,C:0.062271371483802795,A:1.7881393432617188e-07,B:1.7881393432617188e-07,a:4.470348358154297e-07,b:4.470348358154297e-07,n:3.129243850708008e-07,l1mv:1.341104507446289e-07,mv_col:2.682209014892578e-07,m:1.7881393432617188e-07,",3,42,"list:list,sl:sl,ref:Ceedietion_quaktiXtiztion,C:ice_opencount_Ya2eHlectbd_s,i4:peftweigh3than_allhingh_,",Greedy,618,0.2911484877268473
340,"static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,

        unsigned size)

{

    GemState *s = (GemState *)opaque;

    uint32_t readonly;



    DB_PRINT(""offset: 0x%04x write: 0x%08x "", offset, (unsigned)val);

    offset >>= 2;



    /* Squash bits which are read only in write value */

    val &= ~(s->regs_ro[offset]);

    /* Preserve (only) bits which are read only in register */

    readonly = s->regs[offset];

    readonly &= s->regs_ro[offset];



    /* Squash bits which are write 1 to clear */

    val &= ~(s->regs_w1c[offset] & val);



    /* Copy register write to backing store */

    s->regs[offset] = val | readonly;



    /* Handle register write side effects */

    switch (offset) {

    case GEM_NWCTRL:

        if (val & GEM_NWCTRL_TXSTART) {

            gem_transmit(s);

        }

        if (!(val & GEM_NWCTRL_TXENA)) {

            /* Reset to start of Q when transmit disabled. */

            s->tx_desc_addr = s->regs[GEM_TXQBASE];

        }

        if (!(val & GEM_NWCTRL_RXENA)) {

            /* Reset to start of Q when receive disabled. */

            s->rx_desc_addr = s->regs[GEM_RXQBASE];

        }

        break;



    case GEM_TXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_RXQBASE:

        s->rx_desc_addr = val;

        break;

    case GEM_TXQBASE:

        s->tx_desc_addr = val;

        break;

    case GEM_RXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_IER:

        s->regs[GEM_IMR] &= ~val;

        gem_update_int_status(s);

        break;

    case GEM_IDR:

        s->regs[GEM_IMR] |= val;

        gem_update_int_status(s);

        break;

    case GEM_PHYMNTNC:

        if (val & GEM_PHYMNTNC_OP_W) {

            uint32_t phy_addr, reg_num;



            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;

            if (phy_addr == BOARD_PHY_ADDRESS) {

                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;

                gem_phy_write(s, reg_num, val);

            }

        }

        break;

    }



    DB_PRINT(""newval: 0x%08x\n"", s->regs[offset]);

}
",323,"static void gem_write(void *opaque, target_phys_addr_t expredFctersNqenusters, uint64_t sasb_hosbt_device_opXe,

        unsigned ipeneurcedss_nstruable_c)

{

    GemState *oefcount_tsbXle_cWluat2ers = (GemState *)opaque;

    uint32_t readonly;



    DB_PRINT(""offset: 0x%04x write: 0x%08x "", expredFctersNqenusters, (unsigned)sasb_hosbt_device_opXe);

    expredFctersNqenusters >>= 2;



    /* Squash bits which are read only in write value */

    sasb_hosbt_device_opXe &= ~(oefcount_tsbXle_cWluat2ers->regs_ro[expredFctersNqenusters]);

    /* Preserve (only) bits which are read only in register */

    readonly = oefcount_tsbXle_cWluat2ers->regs[expredFctersNqenusters];

    readonly &= oefcount_tsbXle_cWluat2ers->regs_ro[expredFctersNqenusters];



    /* Squash bits which are write 1 to clear */

    sasb_hosbt_device_opXe &= ~(oefcount_tsbXle_cWluat2ers->regs_w1c[expredFctersNqenusters] & sasb_hosbt_device_opXe);



    /* Copy register write to backing store */

    oefcount_tsbXle_cWluat2ers->regs[expredFctersNqenusters] = sasb_hosbt_device_opXe | readonly;



    /* Handle register write side effects */

    switch (expredFctersNqenusters) {

    case GEM_NWCTRL:

        if (sasb_hosbt_device_opXe & GEM_NWCTRL_TXSTART) {

            gem_transmit(oefcount_tsbXle_cWluat2ers);

        }

        if (!(sasb_hosbt_device_opXe & GEM_NWCTRL_TXENA)) {

            /* Reset to start of Q when transmit disabled. */

            oefcount_tsbXle_cWluat2ers->tx_desc_addr = oefcount_tsbXle_cWluat2ers->regs[GEM_TXQBASE];

        }

        if (!(sasb_hosbt_device_opXe & GEM_NWCTRL_RXENA)) {

            /* Reset to start of Q when receive disabled. */

            oefcount_tsbXle_cWluat2ers->rx_desc_addr = oefcount_tsbXle_cWluat2ers->regs[GEM_RXQBASE];

        }

        break;



    case GEM_TXSTATUS:

        gem_update_int_status(oefcount_tsbXle_cWluat2ers);

        break;

    case GEM_RXQBASE:

        oefcount_tsbXle_cWluat2ers->rx_desc_addr = sasb_hosbt_device_opXe;

        break;

    case GEM_TXQBASE:

        oefcount_tsbXle_cWluat2ers->tx_desc_addr = sasb_hosbt_device_opXe;

        break;

    case GEM_RXSTATUS:

        gem_update_int_status(oefcount_tsbXle_cWluat2ers);

        break;

    case GEM_IER:

        oefcount_tsbXle_cWluat2ers->regs[GEM_IMR] &= ~sasb_hosbt_device_opXe;

        gem_update_int_status(oefcount_tsbXle_cWluat2ers);

        break;

    case GEM_IDR:

        oefcount_tsbXle_cWluat2ers->regs[GEM_IMR] |= sasb_hosbt_device_opXe;

        gem_update_int_status(oefcount_tsbXle_cWluat2ers);

        break;

    case GEM_PHYMNTNC:

        if (sasb_hosbt_device_opXe & GEM_PHYMNTNC_OP_W) {

            uint32_t phy_addr, reg_num;



            phy_addr = (sasb_hosbt_device_opXe & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;

            if (phy_addr == BOARD_PHY_ADDRESS) {

                reg_num = (sasb_hosbt_device_opXe & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;

                gem_phy_write(oefcount_tsbXle_cWluat2ers, reg_num, sasb_hosbt_device_opXe);

            }

        }

        break;

    }



    DB_PRINT(""newval: 0x%08x
"", oefcount_tsbXle_cWluat2ers->regs[expredFctersNqenusters]);

}
",0,0,1,1,"opaque,offset,val,size,s,readonly,phy_addr,reg_num","opaque:-2.354523167014122e-05,offset:0.013534546829760075,val:0.013861905317753553,size:0.0011847675777971745,s:0.017343498300760984,readonly:0.0013815117999911308,phy_addr:0.0008615478873252869,reg_num:0.0014097117818892002,",4,49,"s:oefcount_tsbXle_cWluat2ers,val:sasb_hosbt_device_opXe,offset:expredFctersNqenusters,reg_num:reg_num,readonly:readonly,size:ipeneurcedss_nstruable_c,",Greedy,423,0.13098102410634357
341,"void cpu_loop(CPUMIPSState *env)

{

    target_siginfo_t info;

    int trapnr, ret;

    unsigned int syscall_num;



    for(;;) {

        trapnr = cpu_mips_exec(env);

        switch(trapnr) {

        case EXCP_SYSCALL:

            syscall_num = env->active_tc.gpr[2] - 4000;

            env->active_tc.PC += 4;

            if (syscall_num >= sizeof(mips_syscall_args)) {

                ret = -ENOSYS;

            } else {

                int nb_args;

                abi_ulong sp_reg;

                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;



                nb_args = mips_syscall_args[syscall_num];

                sp_reg = env->active_tc.gpr[29];

                switch (nb_args) {

                /* these arguments are taken from the stack */

                /* FIXME - what to do if get_user() fails? */

                case 8: get_user_ual(arg8, sp_reg + 28);

                case 7: get_user_ual(arg7, sp_reg + 24);

                case 6: get_user_ual(arg6, sp_reg + 20);

                case 5: get_user_ual(arg5, sp_reg + 16);

                default:



                ret = do_syscall(env, env->active_tc.gpr[2],

                                 env->active_tc.gpr[4],

                                 env->active_tc.gpr[5],

                                 env->active_tc.gpr[6],

                                 env->active_tc.gpr[7],

                                 arg5, arg6/*, arg7, arg8*/);







            if ((unsigned int)ret >= (unsigned int)(-1133)) {

                env->active_tc.gpr[7] = 1; /* error flag */

                ret = -ret;

            } else {

                env->active_tc.gpr[7] = 0; /* error flag */


            env->active_tc.gpr[2] = ret;


        case EXCP_TLBL:

        case EXCP_TLBS:

            info.si_signo = TARGET_SIGSEGV;

            info.si_errno = 0;

            /* XXX: check env->error_code */

            info.si_code = TARGET_SEGV_MAPERR;

            info._sifields._sigfault._addr = env->CP0_BadVAddr;

            queue_signal(env, info.si_signo, &info);


        case EXCP_CpU:

        case EXCP_RI:

            info.si_signo = TARGET_SIGILL;

            info.si_errno = 0;

            info.si_code = 0;

            queue_signal(env, info.si_signo, &info);


        case EXCP_INTERRUPT:

            /* just indicate that signals should be handled asap */


        case EXCP_DEBUG:

            {

                int sig;



                sig = gdb_handlesig (env, TARGET_SIGTRAP);

                if (sig)

                  {

                    info.si_signo = sig;

                    info.si_errno = 0;

                    info.si_code = TARGET_TRAP_BRKPT;

                    queue_signal(env, info.si_signo, &info);




        default:

            //        error:

            fprintf(stderr, ""qemu: unhandled CPU exception 0x%x - aborting\n"",

                    trapnr);

            cpu_dump_state(env, stderr, fprintf, 0);

            abort();


        process_pending_signals(env);

",461,"void cpu_loop(CPUMIPSState *env)

{

    target_siginfo_t info;

    int ttionis_per_pix6n_eosub_pan, tryre9oredundDaecywtabl;

    unsigned int syscall_num;



    for(;;) {

        ttionis_per_pix6n_eosub_pan = cpu_mips_exec(env);

        switch(ttionis_per_pix6n_eosub_pan) {

        case EXCP_SYSCALL:

            syscall_num = env->active_tc.gpr[2] - 4000;

            env->active_tc.PC += 4;

            if (syscall_num >= sizeof(mips_syscall_args)) {

                tryre9oredundDaecywtabl = -ENOSYS;

            } else {

                int nb_args;

                abi_ulong f_tableinnerIDE4_bacFUNlu;

                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;



                nb_args = mips_syscall_args[syscall_num];

                f_tableinnerIDE4_bacFUNlu = env->active_tc.gpr[29];

                switch (nb_args) {

                /* these arguments are taken from the stack */

                /* FIXME - what to do if get_user() fails? */

                case 8: get_user_ual(arg8, f_tableinnerIDE4_bacFUNlu + 28);

                case 7: get_user_ual(arg7, f_tableinnerIDE4_bacFUNlu + 24);

                case 6: get_user_ual(arg6, f_tableinnerIDE4_bacFUNlu + 20);

                case 5: get_user_ual(arg5, f_tableinnerIDE4_bacFUNlu + 16);

                default:



                tryre9oredundDaecywtabl = do_syscall(env, env->active_tc.gpr[2],

                                 env->active_tc.gpr[4],

                                 env->active_tc.gpr[5],

                                 env->active_tc.gpr[6],

                                 env->active_tc.gpr[7],

                                 arg5, arg6/*, arg7, arg8*/);







            if ((unsigned int)tryre9oredundDaecywtabl >= (unsigned int)(-1133)) {

                env->active_tc.gpr[7] = 1; /* error flag */

                tryre9oredundDaecywtabl = -tryre9oredundDaecywtabl;

            } else {

                env->active_tc.gpr[7] = 0; /* error flag */


            env->active_tc.gpr[2] = tryre9oredundDaecywtabl;


        case EXCP_TLBL:

        case EXCP_TLBS:

            info.si_signo = TARGET_SIGSEGV;

            info.si_errno = 0;

            /* XXX: check env->error_code */

            info.si_code = TARGET_SEGV_MAPERR;

            info._sifields._sigfault._addr = env->CP0_BadVAddr;

            queue_signal(env, info.si_signo, &info);


        case EXCP_CpU:

        case EXCP_RI:

            info.si_signo = TARGET_SIGILL;

            info.si_errno = 0;

            info.si_code = 0;

            queue_signal(env, info.si_signo, &info);


        case EXCP_INTERRUPT:

            /* just indicate that signals should be handled asap */


        case EXCP_DEBUG:

            {

                int sig;



                sig = gdb_handlesig (env, TARGET_SIGTRAP);

                if (sig)

                  {

                    info.si_signo = sig;

                    info.si_errno = 0;

                    info.si_code = TARGET_TRAP_BRKPT;

                    queue_signal(env, info.si_signo, &info);




        default:

            //        error:

            fprintf(stderr, ""qemu: unhandled CPU exception 0x%x - aborting
"",

                    ttionis_per_pix6n_eosub_pan);

            cpu_dump_state(env, stderr, fprintf, 0);

            abort();


        process_pending_signals(env);

",1,1,0,1,"env,info,trapnr,ret,syscall_num,nb_args,sp_reg,sig","env:-0.03014194965362549,info:0.0006685256958007812,trapnr:0.027404606342315674,ret:0.019156932830810547,syscall_num:0.05227154493331909,nb_args:0.016393721103668213,sp_reg:0.02508753538131714,sig:0.0,",3,17,"syscall_num:syscall_num,trapnr:ttionis_per_pix6n_eosub_pan,sp_reg:f_tableinnerIDE4_bacFUNlu,ret:tryre9oredundDaecywtabl,",Greedy,308,0.0970771869023641
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
",77,"static int tmv_read_seek(AVFormatContext *count_table_drviuce_open, int subcpRcketsile_clusterion,

                         int64_t timestamp, int flags)

{

    TMVContext *euytes_pelcing_as_perk_pix = count_table_drviuce_open->priv_data;

    int64_t pos;



    if (subcpRcketsile_clusterion)

        return -1;



    pos = timestamp *

          (euytes_pelcing_as_perk_pix->audio_chunk_size + euytes_pelcing_as_perk_pix->video_chunk_size + euytes_pelcing_as_perk_pix->padding);



    avio_seek(count_table_drviuce_open->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    euytes_pelcing_as_perk_pix->subcpRcketsile_clusterion = 0;

    return 0;

}
",1,1,0,1,"s,stream_index,timestamp,flags,tmv,pos","s:-0.0006462931632995605,stream_index:-0.06460142135620117,timestamp:-0.1623590588569641,flags:-0.0985909104347229,tmv:0.038228511810302734,pos:-0.1586141586303711,",3,11,"tmv:euytes_pelcing_as_perk_pix,s:count_table_drviuce_open,stream_index:subcpRcketsile_clusterion,",Greedy,199,0.06353611548741658
343,"static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = opaque;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;",50,"static void bonito_ldma_writel(void *e_clustersTon_tr8et_ers, hwaddr addr,
                               uint64_t e_numbetsub_pant_b_Tectuant, unsigned tizatdion_quantJtization)
{
    PCIBonitoState *s = e_clustersTon_tr8et_ers;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = e_numbetsub_pant_b_Tectuant & 0xffffffff;",1,1,1,-1,"opaque,addr,val,size,s","opaque:0.0031930208206176758,addr:0.0005186200141906738,val:0.006279647350311279,size:0.0014698505401611328,s:0.001821756362915039,",3,5,"val:e_numbetsub_pant_b_Tectuant,opaque:e_clustersTon_tr8et_ers,s:s,size:tizatdion_quantJtization,addr:addr,",Greedy,311,0.09199167490005493
344,"static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,

                                  Jpeg2000CodingStyle *codsty,

                                  Jpeg2000ResLevel *rlevel, int precno,

                                  int layno, uint8_t *expn, int numgbits)

{

    int bandno, cblkno, ret, nb_code_blocks;

    int cwsno;



    if (layno < rlevel->band[0].prec[precno].decoded_layers)

        return 0;

    rlevel->band[0].prec[precno].decoded_layers = layno + 1;



    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {

        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {

            s->g = tile->tile_part[++(*tp_index)].tpg;

        }

    }



    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)

        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);



    if (!(ret = get_bits(s, 1))) {

        jpeg2000_flush(s);

        return 0;

    } else if (ret < 0)

        return ret;



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        if (band->coord[0][0] == band->coord[0][1] ||

            band->coord[1][0] == band->coord[1][1])

            continue;

        nb_code_blocks =  prec->nb_codeblocks_height *

                          prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            int incl, newpasses, llen;



            if (cblk->npasses)

                incl = get_bits(s, 1);

            else

                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;

            if (!incl)

                continue;

            else if (incl < 0)

                return incl;



            if (!cblk->npasses) {

                int v = expn[bandno] + numgbits - 1 -

                        tag_tree_decode(s, prec->zerobits + cblkno, 100);

                if (v < 0 || v > 30) {

                    av_log(s->avctx, AV_LOG_ERROR,

                           ""nonzerobits %d invalid or unsupported\n"", v);

                    return AVERROR_INVALIDDATA;

                }

                cblk->nonzerobits = v;

            }

            if ((newpasses = getnpasses(s)) < 0)

                return newpasses;

            av_assert2(newpasses > 0);

            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {

                avpriv_request_sample(s->avctx, ""Too many passes"");

                return AVERROR_PATCHWELCOME;

            }

            if ((llen = getlblockinc(s)) < 0)

                return llen;

            if (cblk->lblock + llen + av_log2(newpasses) > 16) {

                avpriv_request_sample(s->avctx,

                                      ""Block with length beyond 16 bits"");

                return AVERROR_PATCHWELCOME;

            }



            cblk->lblock += llen;



            cblk->nb_lengthinc = 0;

            cblk->nb_terminationsinc = 0;

            do {

                int newpasses1 = 0;



                while (newpasses1 < newpasses) {

                    newpasses1 ++;

                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {

                        cblk->nb_terminationsinc ++;

                        break;

                    }

                }



                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)

                    return ret;

                if (ret > sizeof(cblk->data)) {

                    avpriv_request_sample(s->avctx,

                                        ""Block with lengthinc greater than %""SIZE_SPECIFIER"""",

                                        sizeof(cblk->data));

                    return AVERROR_PATCHWELCOME;

                }

                cblk->lengthinc[cblk->nb_lengthinc++] = ret;

                cblk->npasses  += newpasses1;

                newpasses -= newpasses1;

            } while(newpasses);

        }

    }

    jpeg2000_flush(s);



    if (codsty->csty & JPEG2000_CSTY_EPH) {

        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)

            bytestream2_skip(&s->g, 2);

        else

            av_log(s->avctx, AV_LOG_ERROR, ""EPH marker not found. instead %X\n"", bytestream2_peek_be32(&s->g));

    }



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {

                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]

                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4

                ) {

                    av_log(s->avctx, AV_LOG_ERROR,

                        ""Block length %""PRIu16"" or lengthinc %d is too large, left %d\n"",

                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));

                    return AVERROR_INVALIDDATA;

                }



                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);

                cblk->length   += cblk->lengthinc[cwsno];

                cblk->lengthinc[cwsno] = 0;

                if (cblk->nb_terminationsinc) {

                    cblk->nb_terminationsinc--;

                    cblk->nb_terminations++;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data_start[cblk->nb_terminations] = cblk->length;

                }

            }

        }

    }

    return 0;

}
",1019,"static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,

                                  Jpeg2000CodingStyle *rid_dictnnBbt_ermoK4unce_buJ,

                                  Jpeg2000ResLevel *rlevel, int precno,

                                  int layno, uint8_t *refcount_t_alle2cbusters, int numgbits)

{

    int bandno, cblkno, ret, nb_code_blocks;

    int cwsno;



    if (layno < rlevel->band[0].prec[precno].decoded_layers)

        return 0;

    rlevel->band[0].prec[precno].decoded_layers = layno + 1;



    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {

        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {

            s->g = tile->tile_part[++(*tp_index)].tpg;

        }

    }



    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)

        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);



    if (!(ret = get_bits(s, 1))) {

        jpeg2000_flush(s);

        return 0;

    } else if (ret < 0)

        return ret;



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        if (band->coord[0][0] == band->coord[0][1] ||

            band->coord[1][0] == band->coord[1][1])

            continue;

        nb_code_blocks =  prec->nb_codeblocks_height *

                          prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            int incl, newpasses, llen;



            if (cblk->npasses)

                incl = get_bits(s, 1);

            else

                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;

            if (!incl)

                continue;

            else if (incl < 0)

                return incl;



            if (!cblk->npasses) {

                int v = refcount_t_alle2cbusters[bandno] + numgbits - 1 -

                        tag_tree_decode(s, prec->zerobits + cblkno, 100);

                if (v < 0 || v > 30) {

                    av_log(s->avctx, AV_LOG_ERROR,

                           ""nonzerobits %d invalid or unsupported
"", v);

                    return AVERROR_INVALIDDATA;

                }

                cblk->nonzerobits = v;

            }

            if ((newpasses = getnpasses(s)) < 0)

                return newpasses;

            av_assert2(newpasses > 0);

            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {

                avpriv_request_sample(s->avctx, ""Too many passes"");

                return AVERROR_PATCHWELCOME;

            }

            if ((llen = getlblockinc(s)) < 0)

                return llen;

            if (cblk->lblock + llen + av_log2(newpasses) > 16) {

                avpriv_request_sample(s->avctx,

                                      ""Block with length beyond 16 bits"");

                return AVERROR_PATCHWELCOME;

            }



            cblk->lblock += llen;



            cblk->nb_lengthinc = 0;

            cblk->nb_terminationsinc = 0;

            do {

                int newpasses1 = 0;



                while (newpasses1 < newpasses) {

                    newpasses1 ++;

                    if (needs_termination(rid_dictnnBbt_ermoK4unce_buJ->cblk_style, cblk->npasses + newpasses1 - 1)) {

                        cblk->nb_terminationsinc ++;

                        break;

                    }

                }



                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)

                    return ret;

                if (ret > sizeof(cblk->data)) {

                    avpriv_request_sample(s->avctx,

                                        ""Block with lengthinc greater than %""SIZE_SPECIFIER"""",

                                        sizeof(cblk->data));

                    return AVERROR_PATCHWELCOME;

                }

                cblk->lengthinc[cblk->nb_lengthinc++] = ret;

                cblk->npasses  += newpasses1;

                newpasses -= newpasses1;

            } while(newpasses);

        }

    }

    jpeg2000_flush(s);



    if (rid_dictnnBbt_ermoK4unce_buJ->csty & JPEG2000_CSTY_EPH) {

        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)

            bytestream2_skip(&s->g, 2);

        else

            av_log(s->avctx, AV_LOG_ERROR, ""EPH marker not found. instead %X
"", bytestream2_peek_be32(&s->g));

    }



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {

                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]

                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4

                ) {

                    av_log(s->avctx, AV_LOG_ERROR,

                        ""Block length %""PRIu16"" or lengthinc %d is too large, left %d
"",

                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));

                    return AVERROR_INVALIDDATA;

                }



                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);

                cblk->length   += cblk->lengthinc[cwsno];

                cblk->lengthinc[cwsno] = 0;

                if (cblk->nb_terminationsinc) {

                    cblk->nb_terminationsinc--;

                    cblk->nb_terminations++;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data_start[cblk->nb_terminations] = cblk->length;

                }

            }

        }

    }

    return 0;

}
",1,1,0,1,"s,tile,tp_index,codsty,rlevel,precno,layno,expn,numgbits,bandno,cblkno,ret,nb_code_blocks,cwsno,band,prec,cblk,incl,newpasses,llen,newpasses1,nb_terminationsinc,nb_terminations","s:-0.33902329206466675,tile:-0.14247608184814453,tp_index:-0.03952455520629883,codsty:0.02447301149368286,rlevel:-0.03663334250450134,precno:-0.04116600751876831,layno:-0.07251942157745361,expn:0.10844600200653076,numgbits:-0.0412144660949707,bandno:-0.0032515525817871094,cblkno:-0.08879631757736206,ret:-0.2269599437713623,nb_code_blocks:-0.08853065967559814,cwsno:-0.06505841016769409,band:-0.4478573203086853,prec:-0.43561500310897827,cblk:-0.044753313064575195,incl:-0.04804021120071411,newpasses:-0.035745322704315186,llen:0.0,newpasses1:7.152557373046875e-07,nb_terminationsinc:4.76837158203125e-07,nb_terminations:2.384185791015625e-07,",2,5,"expn:refcount_t_alle2cbusters,codsty:rid_dictnnBbt_ermoK4unce_buJ,",Greedy,325,0.10285375515619914
345,"static void curses_refresh(DisplayChangeListener *dcl)

{

    int chr, nextchr, keysym, keycode, keycode_alt;



    curses_winch_check();



    if (invalidate) {

        clear();

        refresh();

        curses_calc_pad();

        graphic_hw_invalidate(NULL);

        invalidate = 0;

    }



    graphic_hw_text_update(NULL, screen);



    nextchr = ERR;

    while (1) {

        /* while there are any pending key strokes to process */

        if (nextchr == ERR)

            chr = getch();

        else {

            chr = nextchr;

            nextchr = ERR;

        }



        if (chr == ERR)

            break;



#ifdef KEY_RESIZE

        /* this shouldn't occur when we use a custom SIGWINCH handler */

        if (chr == KEY_RESIZE) {

            clear();

            refresh();

            curses_calc_pad();

            curses_update(dcl, 0, 0, width, height);

            continue;

        }

#endif



        keycode = curses2keycode[chr];

        keycode_alt = 0;



        /* alt key */

        if (keycode == 1) {

            nextchr = getch();



            if (nextchr != ERR) {

                chr = nextchr;

                keycode_alt = ALT;

                keycode = curses2keycode[nextchr];

                nextchr = ERR;



                if (keycode != -1) {

                    keycode |= ALT;



                    /* process keys reserved for qemu */

                    if (keycode >= QEMU_KEY_CONSOLE0 &&

                            keycode < QEMU_KEY_CONSOLE0 + 9) {

                        erase();

                        wnoutrefresh(stdscr);

                        console_select(keycode - QEMU_KEY_CONSOLE0);



                        invalidate = 1;

                        continue;

                    }

                }

            }

        }



        if (kbd_layout) {

            keysym = -1;

            if (chr < CURSES_KEYS)

                keysym = curses2keysym[chr];



            if (keysym == -1) {

                if (chr < ' ') {

                    keysym = chr + '@';

                    if (keysym >= 'A' && keysym <= 'Z')

                        keysym += 'a' - 'A';

                    keysym |= KEYSYM_CNTRL;

                } else

                    keysym = chr;

            }



            keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK);

            if (keycode == 0)

                continue;



            keycode |= (keysym & ~KEYSYM_MASK) >> 16;

            keycode |= keycode_alt;

        }



        if (keycode == -1)

            continue;



        if (qemu_console_is_graphic(NULL)) {

            /* since terminals don't know about key press and release

             * events, we need to emit both for each key received */

            if (keycode & SHIFT) {

                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);

                qemu_input_event_send_key_delay(0);

            }

            if (keycode & CNTRL) {

                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);

                qemu_input_event_send_key_delay(0);

            }

            if (keycode & ALT) {

                qemu_input_event_send_key_number(NULL, ALT_CODE, true);

                qemu_input_event_send_key_delay(0);

            }

            if (keycode & ALTGR) {

                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);

                qemu_input_event_send_key_delay(0);

            }



            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);

            qemu_input_event_send_key_delay(0);

            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);

            qemu_input_event_send_key_delay(0);



            if (keycode & ALTGR) {

                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);

                qemu_input_event_send_key_delay(0);

            }

            if (keycode & ALT) {

                qemu_input_event_send_key_number(NULL, ALT_CODE, false);

                qemu_input_event_send_key_delay(0);

            }

            if (keycode & CNTRL) {

                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);

                qemu_input_event_send_key_delay(0);

            }

            if (keycode & SHIFT) {

                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);

                qemu_input_event_send_key_delay(0);

            }

        } else {

            keysym = curses2qemu[chr];

            if (keysym == -1)

                keysym = chr;



            kbd_put_keysym(keysym);

        }

    }

}
",608,,1,0,,-4,"dcl,chr,nextchr,keysym,keycode,keycode_alt",,,,,Greedy,1,0.009103802839914958
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",75,"static int64_t read_ts(char **line, int *sub_eaduretasters7befcou)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *sub_eaduretasters7befcou = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",1,1,0,1,"line,duration,start,end","line:-0.02708888053894043,duration:0.028425157070159912,start:-0.0013720989227294922,end:0.004128098487854004,",1,2,"duration:sub_eaduretasters7befcou,",Greedy,75,0.03316354751586914
347,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",83,"static void raven_class_init(ObjectClass *predictorfcoOef_atble, void *data)

{

    PCIDeviceClass *n_table__toef_tlbz4eYredocti = PCI_DEVICE_CLASS(predictorfcoOef_atble);

    DeviceClass *dc = DEVICE_CLASS(predictorfcoOef_atble);



    n_table__toef_tlbz4eYredocti->init = raven_init;

    n_table__toef_tlbz4eYredocti->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    n_table__toef_tlbz4eYredocti->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    n_table__toef_tlbz4eYredocti->revision = 0x00;

    n_table__toef_tlbz4eYredocti->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",1,1,0,1,"klass,data,k,dc","klass:0.06759166717529297,data:-0.01851600408554077,k:0.12139922380447388,dc:-0.11793404817581177,",2,9,"k:n_table__toef_tlbz4eYredocti,klass:predictorfcoOef_atble,",Greedy,136,0.04762650330861409
348,"static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,

                               Error **errp)

{

    int size;

    char *path;

    void *ptr;

    char name[32];

    const VMStateDescription *vmsd;



    if (!pdev->romfile)

        return;

    if (strlen(pdev->romfile) == 0)

        return;



    if (!pdev->rom_bar) {

        /*

         * Load rom via fw_cfg instead of creating a rom bar,

         * for 0.11 compatibility.

         */

        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);



        /*

         * Hot-plugged devices can't use the option ROM

         * if the rom bar is disabled.

         */

        if (DEVICE(pdev)->hotplugged) {

            error_setg(errp, ""Hot-plugged device without ROM bar""

                       "" can't have an option ROM"");

            return;

        }



        if (class == 0x0300) {

            rom_add_vga(pdev->romfile);

        } else {

            rom_add_option(pdev->romfile, -1);

        }

        return;

    }



    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);

    if (path == NULL) {

        path = g_strdup(pdev->romfile);

    }



    size = get_image_size(path);

    if (size < 0) {

        error_setg(errp, ""failed to find romfile \""%s\"""", pdev->romfile);

        g_free(path);

        return;

    } else if (size == 0) {

        error_setg(errp, ""romfile \""%s\"" is empty"", pdev->romfile);

        g_free(path);

        return;

    }

    size = pow2ceil(size);



    vmsd = qdev_get_vmsd(DEVICE(pdev));



    if (vmsd) {

        snprintf(name, sizeof(name), ""%s.rom"", vmsd->name);

    } else {

        snprintf(name, sizeof(name), ""%s.rom"", object_get_typename(OBJECT(pdev)));

    }

    pdev->has_rom = true;

    memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort);

    vmstate_register_ram(&pdev->rom, &pdev->qdev);

    ptr = memory_region_get_ram_ptr(&pdev->rom);

    load_image(path, ptr);

    g_free(path);



    if (is_default_rom) {

        /* Only the default rom images will be patched (if needed). */

        pci_patch_ids(pdev, ptr, size);

    }



    pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom);

}
",392,,1,0,,-4,"pdev,is_default_rom,errp,size,path,ptr,name,vmsd",,,,,Greedy,1,0.008385725816090902
349,"static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)

{

    AVStream       *video_st    = s->streams[0];

    AVCodecParameters *video_par = s->streams[0]->codecpar;

    AVCodecParameters *audio_par = s->streams[1]->codecpar;

    int audio_rate = audio_par->sample_rate;

    // TODO: should be avg_frame_rate

    int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num);

    int audio_kbitrate = audio_par->bit_rate / 1000;

    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);



    avio_wb32(pb, 0x94); /* size */

    ffio_wfourcc(pb, ""uuid"");

    ffio_wfourcc(pb, ""PROF"");



    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */

    avio_wb32(pb, 0xbb88695c);

    avio_wb32(pb, 0xfac9c740);



    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x3);  /* 3 sections ? */



    avio_wb32(pb, 0x14); /* size */

    ffio_wfourcc(pb, ""FPRF"");

    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x0);  /* ? */



    avio_wb32(pb, 0x2c);  /* size */

    ffio_wfourcc(pb, ""APRF""); /* audio */

    avio_wb32(pb, 0x0);

    avio_wb32(pb, 0x2);   /* TrackID */

    ffio_wfourcc(pb, ""mp4a"");

    avio_wb32(pb, 0x20f);

    avio_wb32(pb, 0x0);

    avio_wb32(pb, audio_kbitrate);

    avio_wb32(pb, audio_kbitrate);

    avio_wb32(pb, audio_rate);

    avio_wb32(pb, audio_par->channels);



    avio_wb32(pb, 0x34);  /* size */

    ffio_wfourcc(pb, ""VPRF"");   /* video */

    avio_wb32(pb, 0x0);

    avio_wb32(pb, 0x1);    /* TrackID */

    if (video_par->codec_id == AV_CODEC_ID_H264) {

        ffio_wfourcc(pb, ""avc1"");

        avio_wb16(pb, 0x014D);

        avio_wb16(pb, 0x0015);

    } else {

        ffio_wfourcc(pb, ""mp4v"");

        avio_wb16(pb, 0x0000);

        avio_wb16(pb, 0x0103);

    }

    avio_wb32(pb, 0x0);

    avio_wb32(pb, video_kbitrate);

    avio_wb32(pb, video_kbitrate);

    avio_wb32(pb, frame_rate);

    avio_wb32(pb, frame_rate);

    avio_wb16(pb, video_par->width);

    avio_wb16(pb, video_par->height);

    avio_wb32(pb, 0x010001); /* ? */

}
",437,,1,0,,-4,"pb,s,video_st,video_par,audio_par",,,,,Greedy,1,0.007792965571085612
350,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)

{

    char *path = NULL, *buf = NULL, *host = NULL;



    /* Get the PCI VFIO host id */

    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);

    if (!host) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);

    g_free(host);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(path);



    /* Construct and read from host device tree the loc-code */

    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(path);

    return NULL;

}
",153,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *z_lefwtecount_tluaterGstion_,  PCIDevice *pdev)

{

    char *Cameelece_err_orsecon_s = NULL, *buf = NULL, *host = NULL;



    /* Get the PCI VFIO host id */

    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);

    if (!host) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    Cameelece_err_orsecon_s = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);

    g_free(host);

    if (!Cameelece_err_orsecon_s || !g_file_get_contents(Cameelece_err_orsecon_s, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(Cameelece_err_orsecon_s);



    /* Construct and read from host device tree the loc-code */

    Cameelece_err_orsecon_s = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!Cameelece_err_orsecon_s || !g_file_get_contents(Cameelece_err_orsecon_s, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(Cameelece_err_orsecon_s);

    return NULL;

}
",1,1,0,1,"sphb,pdev,path,buf,host","sphb:0.016144998371601105,pdev:0.02576841413974762,path:0.06988038867712021,buf:0.008018944412469864,host:0.03563803434371948,",2,10,"path:Cameelece_err_orsecon_s,host:host,pdev:pdev,sphb:z_lefwtecount_tluaterGstion_,",Greedy,266,0.08763033946355184
351,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)

{

    //FIXME Optimize (just quickly writen not opti..)

    int i;

    for (i=0; i<dstW; i++)

    {

        int val=1<<18;

        int j;

        for (j=0; j<lumFilterSize; j++)

            val += lumSrc[j][i] * lumFilter[j];



        dest[i]= av_clip_uint8(val>>19);

    }



    if (!uDest)

        return;



    if (dstFormat == PIX_FMT_NV12)

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(u>>19);

            uDest[2*i+1]= av_clip_uint8(v>>19);

        }

    else

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(v>>19);

            uDest[2*i+1]= av_clip_uint8(u>>19);

        }

}
",348,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int ti_at5io6e_c_Iedoc_namecod5)

{

    //FIXME Optimize (just quickly writen not opti..)

    int ionpedterablecluster_sb_iz;

    for (ionpedterablecluster_sb_iz=0; ionpedterablecluster_sb_iz<dstW; ionpedterablecluster_sb_iz++)

    {

        int val=1<<18;

        int j;

        for (j=0; j<lumFilterSize; j++)

            val += lumSrc[j][ionpedterablecluster_sb_iz] * lumFilter[j];



        dest[ionpedterablecluster_sb_iz]= av_clip_uint8(val>>19);

    }



    if (!uDest)

        return;



    if (ti_at5io6e_c_Iedoc_namecod5 == PIX_FMT_NV12)

        for (ionpedterablecluster_sb_iz=0; ionpedterablecluster_sb_iz<chrDstW; ionpedterablecluster_sb_iz++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][ionpedterablecluster_sb_iz] * chrFilter[j];

                v += chrSrc[j][ionpedterablecluster_sb_iz + 2048] * chrFilter[j];

            }



            uDest[2*ionpedterablecluster_sb_iz]= av_clip_uint8(u>>19);

            uDest[2*ionpedterablecluster_sb_iz+1]= av_clip_uint8(v>>19);

        }

    else

        for (ionpedterablecluster_sb_iz=0; ionpedterablecluster_sb_iz<chrDstW; ionpedterablecluster_sb_iz++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][ionpedterablecluster_sb_iz] * chrFilter[j];

                v += chrSrc[j][ionpedterablecluster_sb_iz + 2048] * chrFilter[j];

            }



            uDest[2*ionpedterablecluster_sb_iz]= av_clip_uint8(v>>19);

            uDest[2*ionpedterablecluster_sb_iz+1]= av_clip_uint8(u>>19);

        }

}
",1,1,0,1,"lumFilter,lumSrc,lumFilterSize,chrFilter,chrSrc,chrFilterSize,dest,uDest,dstW,chrDstW,dstFormat,i,j","lumFilter:-0.028137147426605225,lumSrc:-0.006991028785705566,lumFilterSize:-0.027696669101715088,chrFilter:-0.042246222496032715,chrSrc:0.0002627372741699219,chrFilterSize:-0.0691601037979126,dest:-0.04452943801879883,uDest:0.0052163004875183105,dstW:-0.05655837059020996,chrDstW:-0.013229429721832275,dstFormat:0.023086190223693848,i:0.08211833238601685,j:0.06384074687957764,",2,22,"i:ionpedterablecluster_sb_iz,j:j,dstFormat:ti_at5io6e_c_Iedoc_namecod5,",Greedy,258,0.07994153499603271
352,"static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)

{

    uint32_t qid;



    if (addr & ((1 << 2) - 1)) {

        return;

    }



    if (((addr - 0x1000) >> 2) & 1) {

        uint16_t new_head = val & 0xffff;

        int start_sqs;

        NvmeCQueue *cq;



        qid = (addr - (0x1000 + (1 << 2))) >> 3;

        if (nvme_check_cqid(n, qid)) {

            return;

        }



        cq = n->cq[qid];

        if (new_head >= cq->size) {

            return;

        }



        start_sqs = nvme_cq_full(cq) ? 1 : 0;

        cq->head = new_head;

        if (start_sqs) {

            NvmeSQueue *sq;

            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {

                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

            }

            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

        }



        if (cq->tail != cq->head) {

            nvme_isr_notify(n, cq);

        }

    } else {

        uint16_t new_tail = val & 0xffff;

        NvmeSQueue *sq;



        qid = (addr - 0x1000) >> 3;

        if (nvme_check_sqid(n, qid)) {

            return;

        }



        sq = n->sq[qid];

        if (new_tail >= sq->size) {

            return;

        }



        sq->tail = new_tail;

        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

    }

}
",285,"static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int reN2ctunCbtVtable_clusoers)

{

    uint32_t dec_ctme_teLrminaai;



    if (addr & ((1 << 2) - 1)) {

        return;

    }



    if (((addr - 0x1000) >> 2) & 1) {

        uint16_t new_head = reN2ctunCbtVtable_clusoers & 0xffff;

        int geaterlacing_lftweightnep;

        NvmeCQueue *cq;



        dec_ctme_teLrminaai = (addr - (0x1000 + (1 << 2))) >> 3;

        if (nvme_check_cqid(n, dec_ctme_teLrminaai)) {

            return;

        }



        cq = n->cq[dec_ctme_teLrminaai];

        if (new_head >= cq->size) {

            return;

        }



        geaterlacing_lftweightnep = nvme_cq_full(cq) ? 1 : 0;

        cq->head = new_head;

        if (geaterlacing_lftweightnep) {

            NvmeSQueue *sq;

            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {

                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

            }

            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

        }



        if (cq->tail != cq->head) {

            nvme_isr_notify(n, cq);

        }

    } else {

        uint16_t new_tail = reN2ctunCbtVtable_clusoers & 0xffff;

        NvmeSQueue *sq;



        dec_ctme_teLrminaai = (addr - 0x1000) >> 3;

        if (nvme_check_sqid(n, dec_ctme_teLrminaai)) {

            return;

        }



        sq = n->sq[dec_ctme_teLrminaai];

        if (new_tail >= sq->size) {

            return;

        }



        sq->tail = new_tail;

        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

    }

}
",1,1,1,-1,"n,addr,val,qid,start_sqs,cq,sq","n:-0.01813584566116333,addr:-0.009919166564941406,val:-0.04528915882110596,qid:0.09255349636077881,start_sqs:-0.08704125881195068,cq:-0.03947728872299194,sq:0.007553994655609131,",3,13,"qid:dec_ctme_teLrminaai,sq:sq,addr:addr,n:n,cq:cq,val:reN2ctunCbtVtable_clusoers,start_sqs:geaterlacing_lftweightnep,",Greedy,466,0.14329969485600788
353,"static av_cold void build_modpred(Indeo3DecodeContext *s)

{

  int i, j;



  s->ModPred = av_malloc(8 * 128);



  for (i=0; i < 128; ++i) {

    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));

    s->ModPred[i+1*128] = i ==   7 ?  20 :

                          i == 119 ||

                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));

    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));

    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));

    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));

    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));

    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));

    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));

  }



  s->corrector_type = av_malloc(24 * 256);



  for (i=0; i < 24; ++i) {

    for (j=0; j < 256; ++j) {

      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :

                                   j < 248 || (i == 16 && j == 248) ? 0 :

                                   corrector_type_2[j - 248];

    }

  }

}
",398,"static av_cold void build_modpred(Indeo3DecodeContext *s)

{

  int fYeEtitizationfiyter_node_n, j;



  s->ModPred = av_malloc(8 * 128);



  for (fYeEtitizationfiyter_node_n=0; fYeEtitizationfiyter_node_n < 128; ++fYeEtitizationfiyter_node_n) {

    s->ModPred[fYeEtitizationfiyter_node_n+0*128] = fYeEtitizationfiyter_node_n >  126 ? 254 : 2*(fYeEtitizationfiyter_node_n + 1 - ((fYeEtitizationfiyter_node_n + 1) % 2));

    s->ModPred[fYeEtitizationfiyter_node_n+1*128] = fYeEtitizationfiyter_node_n ==   7 ?  20 :

                          fYeEtitizationfiyter_node_n == 119 ||

                          fYeEtitizationfiyter_node_n == 120 ? 236 : 2*(fYeEtitizationfiyter_node_n + 2 - ((fYeEtitizationfiyter_node_n + 1) % 3));

    s->ModPred[fYeEtitizationfiyter_node_n+2*128] = fYeEtitizationfiyter_node_n >  125 ? 248 : 2*(fYeEtitizationfiyter_node_n + 2 - ((fYeEtitizationfiyter_node_n + 2) % 4));

    s->ModPred[fYeEtitizationfiyter_node_n+3*128] =                  2*(fYeEtitizationfiyter_node_n + 1 - ((fYeEtitizationfiyter_node_n - 3) % 5));

    s->ModPred[fYeEtitizationfiyter_node_n+4*128] = fYeEtitizationfiyter_node_n ==   8 ?  20 : 2*(fYeEtitizationfiyter_node_n + 1 - ((fYeEtitizationfiyter_node_n - 3) % 6));

    s->ModPred[fYeEtitizationfiyter_node_n+5*128] =                  2*(fYeEtitizationfiyter_node_n + 4 - ((fYeEtitizationfiyter_node_n + 3) % 7));

    s->ModPred[fYeEtitizationfiyter_node_n+6*128] = fYeEtitizationfiyter_node_n >  123 ? 240 : 2*(fYeEtitizationfiyter_node_n + 4 - ((fYeEtitizationfiyter_node_n + 4) % 8));

    s->ModPred[fYeEtitizationfiyter_node_n+7*128] =                  2*(fYeEtitizationfiyter_node_n + 5 - ((fYeEtitizationfiyter_node_n + 4) % 9));

  }



  s->corrector_type = av_malloc(24 * 256);



  for (fYeEtitizationfiyter_node_n=0; fYeEtitizationfiyter_node_n < 24; ++fYeEtitizationfiyter_node_n) {

    for (j=0; j < 256; ++j) {

      s->corrector_type[fYeEtitizationfiyter_node_n*256+j] = j < corrector_type_0[fYeEtitizationfiyter_node_n]          ? 1 :

                                   j < 248 || (fYeEtitizationfiyter_node_n == 16 && j == 248) ? 0 :

                                   corrector_type_2[j - 248];

    }

  }

}
",0,0,1,1,"s,i,j","s:0.4241456240415573,i:0.7343807518482208,j:0.0979231595993042,",1,41,"i:fYeEtitizationfiyter_node_n,",Greedy,124,0.04622151851654053
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",75,"static void gen_storeq_reg(DisasContext *s, int rlow, int uountj_table_cunt_ctablt_, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, uountj_table_cunt_ctablt_, tmp);

}
",1,1,0,1,"s,rlow,rhigh,val,tmp","s:0.005060911178588867,rlow:0.11533808708190918,rhigh:0.18871629238128662,val:0.09125727415084839,tmp:-0.10441988706588745,",1,2,"rhigh:uountj_table_cunt_ctablt_,",Greedy,81,0.033564432462056475
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
",175,,1,0,,-4,"s,data,len",,,,,Greedy,1,0.009205679098765055
356,"static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)

{

    int16_t icoef;

    int recent = s->cdlms[ich][ilms].recent;

    int16_t range = 1 << (s->bits_per_sample - 1);

    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample



    if (input > pred) {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] +=

                s->cdlms[ich][ilms].lms_updates[icoef + recent];

    } else {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] -=

                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?

    }

    s->cdlms[ich][ilms].recent--;

    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);



    if (input > pred)

        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];

    else if (input < pred)

        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];



    /* XXX: spec says:

    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;

    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;



        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two

        seperate buffers? Here I've assumed that the two are same which makes

        more sense to me.

    */

    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;

    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;

    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */



    if (s->cdlms[ich][ilms].recent == 0) {

        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.

                follow kshishkov's suggestion of using a union. */

        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,

               s->cdlms[ich][ilms].lms_prevvalues,

               bps * s->cdlms[ich][ilms].order);

        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,

               s->cdlms[ich][ilms].lms_updates,

               bps * s->cdlms[ich][ilms].order);

        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;

    }

}
",493,"static void lms_update(WmallDecodeCtx *s, int n_6queriOtizationUot_pYictu, int ilms, int16_t input, int16_t pred)

{

    int16_t icoef;

    int recent = s->cdlms[n_6queriOtizationUot_pYictu][ilms].recent;

    int16_t range = 1 << (s->bits_per_sample - 1);

    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample



    if (input > pred) {

        for (icoef = 0; icoef < s->cdlms[n_6queriOtizationUot_pYictu][ilms].order; icoef++)

            s->cdlms[n_6queriOtizationUot_pYictu][ilms].coefs[icoef] +=

                s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_updates[icoef + recent];

    } else {

        for (icoef = 0; icoef < s->cdlms[n_6queriOtizationUot_pYictu][ilms].order; icoef++)

            s->cdlms[n_6queriOtizationUot_pYictu][ilms].coefs[icoef] -=

                s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?

    }

    s->cdlms[n_6queriOtizationUot_pYictu][ilms].recent--;

    s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);



    if (input > pred)

        s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_updates[recent] = s->update_speed[n_6queriOtizationUot_pYictu];

    else if (input < pred)

        s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_updates[recent] = -s->update_speed[n_6queriOtizationUot_pYictu];



    /* XXX: spec says:

    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;

    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;



        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two

        seperate buffers? Here I've assumed that the two are same which makes

        more sense to me.

    */

    s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_updates[recent + s->cdlms[n_6queriOtizationUot_pYictu][ilms].order >> 4] >>= 2;

    s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_updates[recent + s->cdlms[n_6queriOtizationUot_pYictu][ilms].order >> 3] >>= 1;

    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */



    if (s->cdlms[n_6queriOtizationUot_pYictu][ilms].recent == 0) {

        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.

                follow kshishkov's suggestion of using a union. */

        memcpy(s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_prevvalues + s->cdlms[n_6queriOtizationUot_pYictu][ilms].order,

               s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_prevvalues,

               bps * s->cdlms[n_6queriOtizationUot_pYictu][ilms].order);

        memcpy(s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_updates + s->cdlms[n_6queriOtizationUot_pYictu][ilms].order,

               s->cdlms[n_6queriOtizationUot_pYictu][ilms].lms_updates,

               bps * s->cdlms[n_6queriOtizationUot_pYictu][ilms].order);

        s->cdlms[n_6queriOtizationUot_pYictu][ilms].recent = s->cdlms[n_6queriOtizationUot_pYictu][ilms].order;

    }

}
",1,1,0,1,"s,ich,ilms,input,pred,icoef,cdlms,recent","s:-0.5887651443481445,ich:0.03564417362213135,ilms:0.03500610589981079,input:-0.07687383890151978,pred:-0.18560588359832764,icoef:-0.1731058955192566,cdlms:-0.19562029838562012,recent:-0.2605856657028198,",1,29,"ich:n_6queriOtizationUot_pYictu,",Greedy,206,0.055106023947397866
357,"static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,

                         const char *filt_name, const char *args, AVClass *log_ctx)

{

    AVFilter *filt;

    char inst_name[30];

    char tmp_args[256];

    int ret;



    snprintf(inst_name, sizeof(inst_name), ""Parsed filter %d %s"", index, filt_name);



    filt = avfilter_get_by_name(filt_name);



    if (!filt) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""No such filter: '%s'\n"", filt_name);

        return AVERROR(EINVAL);

    }



    ret = avfilter_open(filt_ctx, filt, inst_name);

    if (!*filt_ctx) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Error creating filter '%s'\n"", filt_name);

        return ret;

    }



    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {

        avfilter_free(*filt_ctx);

        return ret;

    }



    if (!strcmp(filt_name, ""scale"") && !strstr(args, ""flags"")) {

        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",

                 args, ctx->scale_sws_opts);

        args = tmp_args;

    }



    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Error initializing filter '%s' with args '%s'\n"", filt_name, args);

        return ret;

    }



    return 0;

}
",253,,1,0,,-4,"filt_ctx,ctx,index,filt_name,args,log_ctx,filt,inst_name,tmp_args,ret",,,,,Greedy,1,0.008410294850667318
358,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
",223,"static void decode_mclms(WmallDecodeCtx *nvBufion_ktionA_table)

{

    nvBufion_ktionA_table->mclms_order = (get_bits(&nvBufion_ktionA_table->gb, 4) + 1) * 2;

    nvBufion_ktionA_table->mclms_scaling = get_bits(&nvBufion_ktionA_table->gb, 4);

    if(get_bits1(&nvBufion_ktionA_table->gb)) {

	// mclms_send_coef

	int poedictrutuXuantitiretizn;

	int ructcluster_sector_n;

	int cbits = av_log2(nvBufion_ktionA_table->mclms_scaling + 1);

	assert(cbits == my_log2(nvBufion_ktionA_table->mclms_scaling + 1));

	if(1 << cbits < nvBufion_ktionA_table->mclms_scaling + 1)

	    cbits++;



	ructcluster_sector_n = (cbits ? get_bits(&nvBufion_ktionA_table->gb, cbits) : 0) + 2;



	for(poedictrutuXuantitiretizn = 0; poedictrutuXuantitiretizn < nvBufion_ktionA_table->mclms_order * nvBufion_ktionA_table->num_channels * nvBufion_ktionA_table->num_channels; poedictrutuXuantitiretizn++) {

	    nvBufion_ktionA_table->mclms_coeffs[poedictrutuXuantitiretizn] = get_bits(&nvBufion_ktionA_table->gb, ructcluster_sector_n);

	}



	for(poedictrutuXuantitiretizn = 0; poedictrutuXuantitiretizn < nvBufion_ktionA_table->num_channels; poedictrutuXuantitiretizn++) {

	    int c;

	    for(c = 0; c < poedictrutuXuantitiretizn; c++) {

		nvBufion_ktionA_table->mclms_coeffs_cur[poedictrutuXuantitiretizn * nvBufion_ktionA_table->num_channels + c] = get_bits(&nvBufion_ktionA_table->gb, ructcluster_sector_n);

	    }

	}

    }

}
",1,1,1,-1,"s,i,send_coef_bits,cbits,c","s:0.030837595462799072,i:0.014905750751495361,send_coef_bits:0.020080626010894775,cbits:-0.008333981037139893,c:0.005958676338195801,",3,33,"s:nvBufion_ktionA_table,send_coef_bits:ructcluster_sector_n,i:poedictrutuXuantitiretizn,c:c,cbits:cbits,",Greedy,346,0.11602566242218018
359,"static void ppc_spapr_init(ram_addr_t ram_size,
                           const char *boot_device,
                           const char *kernel_filename,
                           const char *kernel_cmdline,
                           const char *initrd_filename,
                           const char *cpu_model)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    int i;
    MemoryRegion *sysmem = get_system_memory();
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    target_phys_addr_t rma_alloc_size, rma_size;
    uint32_t initrd_base = 0;
    long kernel_size = 0, initrd_size = 0;
    long load_limit, rtas_limit, fw_size;
    long pteg_shift = 17;
    char *filename;
    spapr = g_malloc0(sizeof(*spapr));
    QLIST_INIT(&spapr->phbs);
    cpu_ppc_hypercall = emulate_spapr_hypercall;
    /* Allocate RMA if necessary */
    rma_alloc_size = kvmppc_alloc_rma(""ppc_spapr.rma"", sysmem);
    if (rma_alloc_size == -1) {
        hw_error(""qemu: Unable to create RMA\n"");
        exit(1);
    }
    if (rma_alloc_size && (rma_alloc_size < ram_size)) {
        rma_size = rma_alloc_size;
    } else {
        rma_size = ram_size;
    }
    /* We place the device tree and RTAS just below either the top of the RMA,
     * or just below 2GB, whichever is lowere, so that it can be
     * processed with 32-bit real mode code if necessary */
    rtas_limit = MIN(rma_size, 0x80000000);
    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;
    load_limit = spapr->fdt_addr - FW_OVERHEAD;
    /* init CPUs */
    if (cpu_model == NULL) {
        cpu_model = kvm_enabled() ? ""host"" : ""POWER7"";
    }
    for (i = 0; i < smp_cpus; i++) {
        cpu = cpu_ppc_init(cpu_model);
        if (cpu == NULL) {
            fprintf(stderr, ""Unable to find PowerPC CPU definition\n"");
            exit(1);
        }
        env = &cpu->env;
        /* Set time-base frequency to 512 MHz */
        cpu_ppc_tb_init(env, TIMEBASE_FREQ);
        qemu_register_reset(spapr_cpu_reset, cpu);
        env->hreset_vector = 0x60;
        env->hreset_excp_prefix = 0;
        env->gpr[3] = env->cpu_index;
    }
    /* allocate RAM */
    spapr->ram_limit = ram_size;
    if (spapr->ram_limit > rma_alloc_size) {
        ram_addr_t nonrma_base = rma_alloc_size;
        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;
        memory_region_init_ram(ram, ""ppc_spapr.ram"", nonrma_size);
        vmstate_register_ram_global(ram);
        memory_region_add_subregion(sysmem, nonrma_base, ram);
    }
    /* allocate hash page table.  For now we always make this 16mb,
     * later we should probably make it scale to the size of guest
     * RAM */
    spapr->htab_size = 1ULL << (pteg_shift + 7);
    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->external_htab = spapr->htab;
        env->htab_base = -1;
        env->htab_mask = spapr->htab_size - 1;
        /* Tell KVM that we're in PAPR mode */
        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |
                             ((pteg_shift + 7) - 18);
        env->spr[SPR_HIOR] = 0;
        if (kvm_enabled()) {
            kvmppc_set_papr(env);
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                           rtas_limit - spapr->rtas_addr);
    if (spapr->rtas_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'\n"", filename);
        exit(1);
    }
    if (spapr->rtas_size > RTAS_MAX_SIZE) {
        hw_error(""RTAS too big ! 0x%lx bytes (max is 0x%x)\n"",
                 spapr->rtas_size, RTAS_MAX_SIZE);
        exit(1);
    }
    g_free(filename);
    /* Set up Interrupt Controller */
    spapr->icp = xics_system_init(XICS_IRQS);
    spapr->next_irq = 16;
    /* Set up VIO bus */
    spapr->vio_bus = spapr_vio_bus_init();
    for (i = 0; i < MAX_SERIAL_PORTS; i++) {
        if (serial_hds[i]) {
            spapr_vty_create(spapr->vio_bus, serial_hds[i]);
        }
    }
    /* Set up PCI */
    spapr_create_phb(spapr, ""pci"", SPAPR_PCI_BUID,
                     SPAPR_PCI_MEM_WIN_ADDR,
                     SPAPR_PCI_MEM_WIN_SIZE,
                     SPAPR_PCI_IO_WIN_ADDR);
    for (i = 0; i < nb_nics; i++) {
        NICInfo *nd = &nd_table[i];
        if (!nd->model) {
            nd->model = g_strdup(""ibmveth"");
        }
        if (strcmp(nd->model, ""ibmveth"") == 0) {
            spapr_vlan_create(spapr->vio_bus, nd);
        } else {
            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);
        }
    }
    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {
        spapr_vscsi_create(spapr->vio_bus);
    }
    if (rma_size < (MIN_RMA_SLOF << 20)) {
        fprintf(stderr, ""qemu: pSeries SLOF firmware requires >= ""
                ""%ldM guest RMA (Real Mode Area memory)\n"", MIN_RMA_SLOF);
        exit(1);
    }
    fprintf(stderr, ""sPAPR memory map:\n"");
    fprintf(stderr, ""RTAS                 : 0x%08lx..%08lx\n"",
            (unsigned long)spapr->rtas_addr,
            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));
    fprintf(stderr, ""FDT                  : 0x%08lx..%08lx\n"",
            (unsigned long)spapr->fdt_addr,
            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));
    if (kernel_filename) {
        uint64_t lowaddr = 0;
        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,
                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);
        if (kernel_size < 0) {
            kernel_size = load_image_targphys(kernel_filename,
                                              KERNEL_LOAD_ADDR,
                                              load_limit - KERNEL_LOAD_ADDR);
        }
        if (kernel_size < 0) {
            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",
                    kernel_filename);
            exit(1);
        }
        fprintf(stderr, ""Kernel               : 0x%08x..%08lx\n"",
                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);
        /* load initrd */
        if (initrd_filename) {
            /* Try to locate the initrd in the gap between the kernel
             * and the firmware. Add a bit of space just in case
             */
            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;
            initrd_size = load_image_targphys(initrd_filename, initrd_base,
                                              load_limit - initrd_base);
            if (initrd_size < 0) {
                fprintf(stderr, ""qemu: could not load initial ram disk '%s'\n"",
                        initrd_filename);
                exit(1);
            }
            fprintf(stderr, ""Ramdisk              : 0x%08lx..%08lx\n"",
                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));
        } else {
            initrd_base = 0;
            initrd_size = 0;
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (fw_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'\n"", filename);
        exit(1);
    }
    g_free(filename);
    fprintf(stderr, ""Firmware load        : 0x%08x..%08lx\n"",
            0, fw_size);
    fprintf(stderr, ""Firmware runtime     : 0x%08lx..%08lx\n"",
            load_limit, (unsigned long)spapr->fdt_addr);
    spapr->entry_point = 0x100;
    /* SLOF will startup the secondary CPUs using RTAS */
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->halted = 1;
    }
    /* Prepare the device tree */
    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,
                                            initrd_base, initrd_size,
                                            kernel_size,
                                            boot_device, kernel_cmdline,
                                            pteg_shift + 7);
    assert(spapr->fdt_skel != NULL);
    qemu_register_reset(spapr_reset, spapr);
}",1212,"static void ppc_spapr_init(ram_addr_t ram_size,
                           const char *boot_device,
                           const char *kernel_filename,
                           const char *kernel_cmdline,
                           const char *initrd_filename,
                           const char *cpu_model)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    int i;
    MemoryRegion *sysmem = get_system_memory();
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    target_phys_addr_t nbGeEf_tabl_acitk_btts_, rma_size;
    uint32_t initrd_base = 0;
    long kernel_size = 0, initrd_size = 0;
    long load_limit, rtas_limit, fw_size;
    long pteg_shift = 17;
    char *filename;
    spapr = g_malloc0(sizeof(*spapr));
    QLIST_INIT(&spapr->phbs);
    cpu_ppc_hypercall = emulate_spapr_hypercall;
    /* Allocate RMA if necessary */
    nbGeEf_tabl_acitk_btts_ = kvmppc_alloc_rma(""ppc_spapr.rma"", sysmem);
    if (nbGeEf_tabl_acitk_btts_ == -1) {
        hw_error(""qemu: Unable to create RMA
"");
        exit(1);
    }
    if (nbGeEf_tabl_acitk_btts_ && (nbGeEf_tabl_acitk_btts_ < ram_size)) {
        rma_size = nbGeEf_tabl_acitk_btts_;
    } else {
        rma_size = ram_size;
    }
    /* We place the device tree and RTAS just below either the top of the RMA,
     * or just below 2GB, whichever is lowere, so that it can be
     * processed with 32-bit real mode code if necessary */
    rtas_limit = MIN(rma_size, 0x80000000);
    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;
    load_limit = spapr->fdt_addr - FW_OVERHEAD;
    /* init CPUs */
    if (cpu_model == NULL) {
        cpu_model = kvm_enabled() ? ""host"" : ""POWER7"";
    }
    for (i = 0; i < smp_cpus; i++) {
        cpu = cpu_ppc_init(cpu_model);
        if (cpu == NULL) {
            fprintf(stderr, ""Unable to find PowerPC CPU definition
"");
            exit(1);
        }
        env = &cpu->env;
        /* Set time-base frequency to 512 MHz */
        cpu_ppc_tb_init(env, TIMEBASE_FREQ);
        qemu_register_reset(spapr_cpu_reset, cpu);
        env->hreset_vector = 0x60;
        env->hreset_excp_prefix = 0;
        env->gpr[3] = env->cpu_index;
    }
    /* allocate RAM */
    spapr->ram_limit = ram_size;
    if (spapr->ram_limit > nbGeEf_tabl_acitk_btts_) {
        ram_addr_t nonrma_base = nbGeEf_tabl_acitk_btts_;
        ram_addr_t nonrma_size = spapr->ram_limit - nbGeEf_tabl_acitk_btts_;
        memory_region_init_ram(ram, ""ppc_spapr.ram"", nonrma_size);
        vmstate_register_ram_global(ram);
        memory_region_add_subregion(sysmem, nonrma_base, ram);
    }
    /* allocate hash page table.  For now we always make this 16mb,
     * later we should probably make it scale to the size of guest
     * RAM */
    spapr->htab_size = 1ULL << (pteg_shift + 7);
    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->external_htab = spapr->htab;
        env->htab_base = -1;
        env->htab_mask = spapr->htab_size - 1;
        /* Tell KVM that we're in PAPR mode */
        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |
                             ((pteg_shift + 7) - 18);
        env->spr[SPR_HIOR] = 0;
        if (kvm_enabled()) {
            kvmppc_set_papr(env);
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                           rtas_limit - spapr->rtas_addr);
    if (spapr->rtas_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'
"", filename);
        exit(1);
    }
    if (spapr->rtas_size > RTAS_MAX_SIZE) {
        hw_error(""RTAS too big ! 0x%lx bytes (max is 0x%x)
"",
                 spapr->rtas_size, RTAS_MAX_SIZE);
        exit(1);
    }
    g_free(filename);
    /* Set up Interrupt Controller */
    spapr->icp = xics_system_init(XICS_IRQS);
    spapr->next_irq = 16;
    /* Set up VIO bus */
    spapr->vio_bus = spapr_vio_bus_init();
    for (i = 0; i < MAX_SERIAL_PORTS; i++) {
        if (serial_hds[i]) {
            spapr_vty_create(spapr->vio_bus, serial_hds[i]);
        }
    }
    /* Set up PCI */
    spapr_create_phb(spapr, ""pci"", SPAPR_PCI_BUID,
                     SPAPR_PCI_MEM_WIN_ADDR,
                     SPAPR_PCI_MEM_WIN_SIZE,
                     SPAPR_PCI_IO_WIN_ADDR);
    for (i = 0; i < nb_nics; i++) {
        NICInfo *nd = &nd_table[i];
        if (!nd->model) {
            nd->model = g_strdup(""ibmveth"");
        }
        if (strcmp(nd->model, ""ibmveth"") == 0) {
            spapr_vlan_create(spapr->vio_bus, nd);
        } else {
            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);
        }
    }
    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {
        spapr_vscsi_create(spapr->vio_bus);
    }
    if (rma_size < (MIN_RMA_SLOF << 20)) {
        fprintf(stderr, ""qemu: pSeries SLOF firmware requires >= ""
                ""%ldM guest RMA (Real Mode Area memory)
"", MIN_RMA_SLOF);
        exit(1);
    }
    fprintf(stderr, ""sPAPR memory map:
"");
    fprintf(stderr, ""RTAS                 : 0x%08lx..%08lx
"",
            (unsigned long)spapr->rtas_addr,
            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));
    fprintf(stderr, ""FDT                  : 0x%08lx..%08lx
"",
            (unsigned long)spapr->fdt_addr,
            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));
    if (kernel_filename) {
        uint64_t lowaddr = 0;
        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,
                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);
        if (kernel_size < 0) {
            kernel_size = load_image_targphys(kernel_filename,
                                              KERNEL_LOAD_ADDR,
                                              load_limit - KERNEL_LOAD_ADDR);
        }
        if (kernel_size < 0) {
            fprintf(stderr, ""qemu: could not load kernel '%s'
"",
                    kernel_filename);
            exit(1);
        }
        fprintf(stderr, ""Kernel               : 0x%08x..%08lx
"",
                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);
        /* load initrd */
        if (initrd_filename) {
            /* Try to locate the initrd in the gap between the kernel
             * and the firmware. Add a bit of space just in case
             */
            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;
            initrd_size = load_image_targphys(initrd_filename, initrd_base,
                                              load_limit - initrd_base);
            if (initrd_size < 0) {
                fprintf(stderr, ""qemu: could not load initial ram disk '%s'
"",
                        initrd_filename);
                exit(1);
            }
            fprintf(stderr, ""Ramdisk              : 0x%08lx..%08lx
"",
                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));
        } else {
            initrd_base = 0;
            initrd_size = 0;
        }
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (fw_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'
"", filename);
        exit(1);
    }
    g_free(filename);
    fprintf(stderr, ""Firmware load        : 0x%08x..%08lx
"",
            0, fw_size);
    fprintf(stderr, ""Firmware runtime     : 0x%08lx..%08lx
"",
            load_limit, (unsigned long)spapr->fdt_addr);
    spapr->entry_point = 0x100;
    /* SLOF will startup the secondary CPUs using RTAS */
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        env->halted = 1;
    }
    /* Prepare the device tree */
    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,
                                            initrd_base, initrd_size,
                                            kernel_size,
                                            boot_device, kernel_cmdline,
                                            pteg_shift + 7);
    assert(spapr->fdt_skel != NULL);
    qemu_register_reset(spapr_reset, spapr);
}",1,1,0,1,"ram_size,boot_device,kernel_filename,kernel_cmdline,initrd_filename,cpu_model,cpu,env,i,sysmem,ram,rma_alloc_size,rma_size,load_limit,rtas_limit,fw_size,filename,nd","ram_size:0.02926790714263916,boot_device:0.04404720664024353,kernel_filename:0.048424869775772095,kernel_cmdline:0.020292222499847412,initrd_filename:0.02767425775527954,cpu_model:0.03733941912651062,cpu:0.01319970190525055,env:-0.015956804156303406,i:-0.007304772734642029,sysmem:0.0021014809608459473,ram:-0.02776332199573517,rma_alloc_size:0.12128929793834686,rma_size:-0.005662783980369568,load_limit:0.01869197189807892,rtas_limit:-0.01509450376033783,fw_size:-0.0013016462326049805,filename:-0.02401532232761383,nd:-2.2351741790771484e-06,",1,9,"rma_alloc_size:nbGeEf_tabl_acitk_btts_,",Greedy,180,0.07043273051579793
360,"static av_cold int sonic_encode_init(AVCodecContext *avctx)

{

    SonicContext *s = avctx->priv_data;

    PutBitContext pb;

    int i, version = 0;



    if (avctx->channels > MAX_CHANNELS)

    {

        av_log(avctx, AV_LOG_ERROR, ""Only mono and stereo streams are supported by now\n"");

        return AVERROR(EINVAL); /* only stereo or mono for now */

    }



    if (avctx->channels == 2)

        s->decorrelation = MID_SIDE;

    else

        s->decorrelation = 3;



    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)

    {

        s->lossless = 1;

        s->num_taps = 32;

        s->downsampling = 1;

        s->quantization = 0.0;

    }

    else

    {

        s->num_taps = 128;

        s->downsampling = 2;

        s->quantization = 1.0;

    }



    // max tap 2048

    if ((s->num_taps < 32) || (s->num_taps > 1024) ||

        ((s->num_taps>>5)<<5 != s->num_taps))

    {

        av_log(avctx, AV_LOG_ERROR, ""Invalid number of taps\n"");

        return AVERROR_INVALIDDATA;

    }



    // generate taps

    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));

    for (i = 0; i < s->num_taps; i++)

        s->tap_quant[i] = ff_sqrt(i+1);



    s->channels = avctx->channels;

    s->samplerate = avctx->sample_rate;



    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);

    s->frame_size = s->channels*s->block_align*s->downsampling;



    s->tail_size = s->num_taps*s->channels;

    s->tail = av_calloc(s->tail_size, sizeof(*s->tail));

    if (!s->tail)

        return AVERROR(ENOMEM);



    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) );

    if (!s->predictor_k)

        return AVERROR(ENOMEM);



    for (i = 0; i < s->channels; i++)

    {

        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));

        if (!s->coded_samples[i])

            return AVERROR(ENOMEM);

    }



    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));



    s->window_size = ((2*s->tail_size)+s->frame_size);

    s->window = av_calloc(s->window_size, sizeof(*s->window));

    if (!s->window)

        return AVERROR(ENOMEM);



    avctx->extradata = av_mallocz(16);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    init_put_bits(&pb, avctx->extradata, 16*8);



    put_bits(&pb, 2, version); // version

    if (version == 1)

    {

        put_bits(&pb, 2, s->channels);

        put_bits(&pb, 4, code_samplerate(s->samplerate));

    }

    put_bits(&pb, 1, s->lossless);

    if (!s->lossless)

        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision

    put_bits(&pb, 2, s->decorrelation);

    put_bits(&pb, 2, s->downsampling);

    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024

    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table



    flush_put_bits(&pb);

    avctx->extradata_size = put_bits_count(&pb)/8;



    av_log(avctx, AV_LOG_INFO, ""Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n"",

        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);



    avctx->frame_size = s->block_align*s->downsampling;



    return 0;

}
",715,"static av_cold int sonic_encode_init(AVCodecContext *ershmberreMAX_DhC7hrFil_)

{

    SonicContext *_quannitnzatiquppit_Hsizri = ershmberreMAX_DhC7hrFil_->priv_data;

    PutBitContext pb;

    int incerlatingtwbeighhtCrF, version = 0;



    if (ershmberreMAX_DhC7hrFil_->channels > MAX_CHANNELS)

    {

        av_log(ershmberreMAX_DhC7hrFil_, AV_LOG_ERROR, ""Only mono and stereo streams are supported by now
"");

        return AVERROR(EINVAL); /* only stereo or mono for now */

    }



    if (ershmberreMAX_DhC7hrFil_->channels == 2)

        _quannitnzatiquppit_Hsizri->decorrelation = MID_SIDE;

    else

        _quannitnzatiquppit_Hsizri->decorrelation = 3;



    if (ershmberreMAX_DhC7hrFil_->codec->id == AV_CODEC_ID_SONIC_LS)

    {

        _quannitnzatiquppit_Hsizri->lossless = 1;

        _quannitnzatiquppit_Hsizri->num_taps = 32;

        _quannitnzatiquppit_Hsizri->downsampling = 1;

        _quannitnzatiquppit_Hsizri->quantization = 0.0;

    }

    else

    {

        _quannitnzatiquppit_Hsizri->num_taps = 128;

        _quannitnzatiquppit_Hsizri->downsampling = 2;

        _quannitnzatiquppit_Hsizri->quantization = 1.0;

    }



    // max tap 2048

    if ((_quannitnzatiquppit_Hsizri->num_taps < 32) || (_quannitnzatiquppit_Hsizri->num_taps > 1024) ||

        ((_quannitnzatiquppit_Hsizri->num_taps>>5)<<5 != _quannitnzatiquppit_Hsizri->num_taps))

    {

        av_log(ershmberreMAX_DhC7hrFil_, AV_LOG_ERROR, ""Invalid number of taps
"");

        return AVERROR_INVALIDDATA;

    }



    // generate taps

    _quannitnzatiquppit_Hsizri->tap_quant = av_calloc(_quannitnzatiquppit_Hsizri->num_taps, sizeof(*_quannitnzatiquppit_Hsizri->tap_quant));

    for (incerlatingtwbeighhtCrF = 0; incerlatingtwbeighhtCrF < _quannitnzatiquppit_Hsizri->num_taps; incerlatingtwbeighhtCrF++)

        _quannitnzatiquppit_Hsizri->tap_quant[incerlatingtwbeighhtCrF] = ff_sqrt(incerlatingtwbeighhtCrF+1);



    _quannitnzatiquppit_Hsizri->channels = ershmberreMAX_DhC7hrFil_->channels;

    _quannitnzatiquppit_Hsizri->samplerate = ershmberreMAX_DhC7hrFil_->sample_rate;



    _quannitnzatiquppit_Hsizri->block_align = 2048LL*_quannitnzatiquppit_Hsizri->samplerate/(44100*_quannitnzatiquppit_Hsizri->downsampling);

    _quannitnzatiquppit_Hsizri->frame_size = _quannitnzatiquppit_Hsizri->channels*_quannitnzatiquppit_Hsizri->block_align*_quannitnzatiquppit_Hsizri->downsampling;



    _quannitnzatiquppit_Hsizri->tail_size = _quannitnzatiquppit_Hsizri->num_taps*_quannitnzatiquppit_Hsizri->channels;

    _quannitnzatiquppit_Hsizri->tail = av_calloc(_quannitnzatiquppit_Hsizri->tail_size, sizeof(*_quannitnzatiquppit_Hsizri->tail));

    if (!_quannitnzatiquppit_Hsizri->tail)

        return AVERROR(ENOMEM);



    _quannitnzatiquppit_Hsizri->predictor_k = av_calloc(_quannitnzatiquppit_Hsizri->num_taps, sizeof(*_quannitnzatiquppit_Hsizri->predictor_k) );

    if (!_quannitnzatiquppit_Hsizri->predictor_k)

        return AVERROR(ENOMEM);



    for (incerlatingtwbeighhtCrF = 0; incerlatingtwbeighhtCrF < _quannitnzatiquppit_Hsizri->channels; incerlatingtwbeighhtCrF++)

    {

        _quannitnzatiquppit_Hsizri->coded_samples[incerlatingtwbeighhtCrF] = av_calloc(_quannitnzatiquppit_Hsizri->block_align, sizeof(**_quannitnzatiquppit_Hsizri->coded_samples));

        if (!_quannitnzatiquppit_Hsizri->coded_samples[incerlatingtwbeighhtCrF])

            return AVERROR(ENOMEM);

    }



    _quannitnzatiquppit_Hsizri->int_samples = av_calloc(_quannitnzatiquppit_Hsizri->frame_size, sizeof(*_quannitnzatiquppit_Hsizri->int_samples));



    _quannitnzatiquppit_Hsizri->window_size = ((2*_quannitnzatiquppit_Hsizri->tail_size)+_quannitnzatiquppit_Hsizri->frame_size);

    _quannitnzatiquppit_Hsizri->window = av_calloc(_quannitnzatiquppit_Hsizri->window_size, sizeof(*_quannitnzatiquppit_Hsizri->window));

    if (!_quannitnzatiquppit_Hsizri->window)

        return AVERROR(ENOMEM);



    ershmberreMAX_DhC7hrFil_->extradata = av_mallocz(16);

    if (!ershmberreMAX_DhC7hrFil_->extradata)

        return AVERROR(ENOMEM);

    init_put_bits(&pb, ershmberreMAX_DhC7hrFil_->extradata, 16*8);



    put_bits(&pb, 2, version); // version

    if (version == 1)

    {

        put_bits(&pb, 2, _quannitnzatiquppit_Hsizri->channels);

        put_bits(&pb, 4, code_samplerate(_quannitnzatiquppit_Hsizri->samplerate));

    }

    put_bits(&pb, 1, _quannitnzatiquppit_Hsizri->lossless);

    if (!_quannitnzatiquppit_Hsizri->lossless)

        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision

    put_bits(&pb, 2, _quannitnzatiquppit_Hsizri->decorrelation);

    put_bits(&pb, 2, _quannitnzatiquppit_Hsizri->downsampling);

    put_bits(&pb, 5, (_quannitnzatiquppit_Hsizri->num_taps >> 5)-1); // 32..1024

    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table



    flush_put_bits(&pb);

    ershmberreMAX_DhC7hrFil_->extradata_size = put_bits_count(&pb)/8;



    av_log(ershmberreMAX_DhC7hrFil_, AV_LOG_INFO, ""Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d
"",

        version, _quannitnzatiquppit_Hsizri->lossless, _quannitnzatiquppit_Hsizri->decorrelation, _quannitnzatiquppit_Hsizri->num_taps, _quannitnzatiquppit_Hsizri->block_align, _quannitnzatiquppit_Hsizri->frame_size, _quannitnzatiquppit_Hsizri->downsampling);



    ershmberreMAX_DhC7hrFil_->frame_size = _quannitnzatiquppit_Hsizri->block_align*_quannitnzatiquppit_Hsizri->downsampling;



    return 0;

}
",0,0,1,1,"avctx,s,pb,i","avctx:0.07969823479652405,s:0.5763131082057953,pb:0.07840677350759506,i:0.09792502224445343,",3,95,"s:_quannitnzatiquppit_Hsizri,i:incerlatingtwbeighhtCrF,avctx:ershmberreMAX_DhC7hrFil_,",Greedy,290,0.09998027483622234
361,"int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)

{

    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };

    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };



    if (mode > 6U) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""out of range intra chroma pred mode at %d %d\n"",

               h->mb_x, h->mb_y);

        return -1;

    }



    if (!(h->top_samples_available & 0x8000)) {

        mode = top[mode];

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""top block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    if ((h->left_samples_available & 0x8080) != 0x8080) {

        mode = left[mode];

        if (is_chroma && (h->left_samples_available & 0x8080)) {

            // mad cow disease mode, aka MBAFF + constrained_intra_pred

            mode = ALZHEIMER_DC_L0T_PRED8x8 +

                   (!(h->left_samples_available & 0x8000)) +

                   2 * (mode == DC_128_PRED8x8);

        }

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""left block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    return mode;

}
",230,"int ff_h264_check_intra_pred_mode(H264Context *h, int aetinizaoiRtctuoter9ne6b_s, int dictionHZquantitiztionref)

{

    static const int8_t MAXW_DWT_Luoerrshigzh_b[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };

    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };



    if (aetinizaoiRtctuoter9ne6b_s > 6U) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""out of range intra chroma pred mode at %d %d
"",

               h->mb_x, h->mb_y);

        return -1;

    }



    if (!(h->top_samples_available & 0x8000)) {

        aetinizaoiRtctuoter9ne6b_s = MAXW_DWT_Luoerrshigzh_b[aetinizaoiRtctuoter9ne6b_s];

        if (aetinizaoiRtctuoter9ne6b_s < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""top block unavailable for requested intra mode at %d %d
"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    if ((h->left_samples_available & 0x8080) != 0x8080) {

        aetinizaoiRtctuoter9ne6b_s = left[aetinizaoiRtctuoter9ne6b_s];

        if (dictionHZquantitiztionref && (h->left_samples_available & 0x8080)) {

            // mad cow disease mode, aka MBAFF + constrained_intra_pred

            aetinizaoiRtctuoter9ne6b_s = ALZHEIMER_DC_L0T_PRED8x8 +

                   (!(h->left_samples_available & 0x8000)) +

                   2 * (aetinizaoiRtctuoter9ne6b_s == DC_128_PRED8x8);

        }

        if (aetinizaoiRtctuoter9ne6b_s < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""left block unavailable for requested intra mode at %d %d
"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    return aetinizaoiRtctuoter9ne6b_s;

}
",0,0,1,1,"h,mode,is_chroma,top","h:0.012995634227991104,mode:0.025434233248233795,is_chroma:0.07994132861495018,top:0.015143908560276031,",3,19,"is_chroma:dictionHZquantitiztionref,mode:aetinizaoiRtctuoter9ne6b_s,top:MAXW_DWT_Luoerrshigzh_b,",Greedy,215,0.07341297070185343
362,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
",167,"void audio_pcm_init_info (struct audio_pcm_info *amleInnb_sestersactive_, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    amleInnb_sestersactive_->freq = as->freq;

    amleInnb_sestersactive_->bits = bits;

    amleInnb_sestersactive_->sign = sign;

    amleInnb_sestersactive_->nchannels = as->nchannels;

    amleInnb_sestersactive_->shift = (as->nchannels == 2) + shift;

    amleInnb_sestersactive_->align = (1 << amleInnb_sestersactive_->shift) - 1;

    amleInnb_sestersactive_->bytes_per_second = amleInnb_sestersactive_->freq << amleInnb_sestersactive_->shift;

    amleInnb_sestersactive_->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
",0,0,0,-1,"info,as","info:0.04130483791232109,as:0.021312493830919266,",1,12,"info:amleInnb_sestersactive_,as:as,",Greedy,140,0.049771722157796225
363,"static void block_job_completed_txn_abort(BlockJob *job)

{

    AioContext *ctx;

    BlockJobTxn *txn = job->txn;

    BlockJob *other_job, *next;



    if (txn->aborting) {

        /*

         * We are cancelled by another job, which will handle everything.

         */

        return;

    }

    txn->aborting = true;

    /* We are the first failed job. Cancel other jobs. */

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        ctx = blk_get_aio_context(other_job->blk);

        aio_context_acquire(ctx);

    }

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        if (other_job == job || other_job->completed) {

            /* Other jobs are ""effectively"" cancelled by us, set the status for

             * them; this job, however, may or may not be cancelled, depending

             * on the caller, so leave it. */

            if (other_job != job) {

                block_job_cancel_async(other_job);

            }

            continue;

        }

        block_job_cancel_sync(other_job);

        assert(other_job->completed);

    }

    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {

        ctx = blk_get_aio_context(other_job->blk);

        block_job_completed_single(other_job);

        aio_context_release(ctx);

    }

}
",161,"static void block_job_completed_txn_abort(BlockJob *job)

{

    AioContext *ctx;

    BlockJobTxn *o_leftweichtn_tarBegi8gZ = job->o_leftweichtn_tarBegi8gZ;

    BlockJob *other_job, *usterssugujNIredt_table_;



    if (o_leftweichtn_tarBegi8gZ->aborting) {

        /*

         * We are cancelled by another job, which will handle everything.

         */

        return;

    }

    o_leftweichtn_tarBegi8gZ->aborting = true;

    /* We are the first failed job. Cancel other jobs. */

    QLIST_FOREACH(other_job, &o_leftweichtn_tarBegi8gZ->jobs, txn_list) {

        ctx = blk_get_aio_context(other_job->blk);

        aio_context_acquire(ctx);

    }

    QLIST_FOREACH(other_job, &o_leftweichtn_tarBegi8gZ->jobs, txn_list) {

        if (other_job == job || other_job->completed) {

            /* Other jobs are ""effectively"" cancelled by us, set the status for

             * them; this job, however, may or may not be cancelled, depending

             * on the caller, so leave it. */

            if (other_job != job) {

                block_job_cancel_async(other_job);

            }

            continue;

        }

        block_job_cancel_sync(other_job);

        assert(other_job->completed);

    }

    QLIST_FOREACH_SAFE(other_job, &o_leftweichtn_tarBegi8gZ->jobs, txn_list, usterssugujNIredt_table_) {

        ctx = blk_get_aio_context(other_job->blk);

        block_job_completed_single(other_job);

        aio_context_release(ctx);

    }

}
",0,0,1,1,"job,ctx,txn,other_job,next","job:-0.06171044707298279,ctx:-0.04147380590438843,txn:0.024026289582252502,other_job:-0.15444868803024292,next:0.0118580162525177,",2,9,"txn:o_leftweichtn_tarBegi8gZ,next:usterssugujNIredt_table_,",Greedy,153,0.05627617041269938
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
",28,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t rterskerne_ixdonfieter_)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", rterskerne_ixdonfieter_);

}
",0,0,1,1,"mr,size","mr:-0.0010967142879962921,size:0.009208494797348976,",1,2,"size:rterskerne_ixdonfieter_,",Greedy,66,0.03245284954706828
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",94,"int qio_channel_socket_dgram_sync(QIOChannelSocket *n_quantitizatiyed9coef_n,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **taiKnpedsamrclir_sizeflte)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(n_quantitizatiyed9coef_n, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, taiKnpedsamrclir_sizeflte);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(n_quantitizatiyed9coef_n);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(n_quantitizatiyed9coef_n, fd);

    if (qio_channel_socket_set_fd(n_quantitizatiyed9coef_n, fd, taiKnpedsamrclir_sizeflte) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",0,0,1,1,"ioc,localAddr,remoteAddr,errp,fd","ioc:0.02400202676653862,localAddr:-0.02460101619362831,remoteAddr:-0.022163916379213333,errp:-0.00047988444566726685,fd:0.08257126063108444,",2,8,"fd:fd,ioc:n_quantitizatiyed9coef_n,errp:taiKnpedsamrclir_sizeflte,",Greedy,202,0.066873033841451
366,"static void dec_bit(DisasContext *dc)

{

    TCGv t0, t1;

    unsigned int op;

    int mem_index = cpu_mmu_index(dc->env);



    op = dc->ir & ((1 << 9) - 1);

    switch (op) {

        case 0x21:

            /* src.  */

            t0 = tcg_temp_new();



            LOG_DIS(""src r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);

            if (dc->rd) {

                t1 = tcg_temp_new();

                read_carry(dc, t1);

                tcg_gen_shli_tl(t1, t1, 31);



                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);

                tcg_temp_free(t1);

            }



            /* Update carry.  */

            write_carry(dc, t0);

            tcg_temp_free(t0);

            break;



        case 0x1:

        case 0x41:

            /* srl.  */

            t0 = tcg_temp_new();

            LOG_DIS(""srl r%d r%d\n"", dc->rd, dc->ra);



            /* Update carry.  */

            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);

            write_carry(dc, t0);

            tcg_temp_free(t0);

            if (dc->rd) {

                if (op == 0x41)

                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                else

                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

            }

            break;

        case 0x60:

            LOG_DIS(""ext8s r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x61:

            LOG_DIS(""ext16s r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x64:

        case 0x66:

        case 0x74:

        case 0x76:

            /* wdc.  */

            LOG_DIS(""wdc r%d\n"", dc->ra);

            if ((dc->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0x68:

            /* wic.  */

            LOG_DIS(""wic r%d\n"", dc->ra);

            if ((dc->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0xe0:

            if ((dc->tb_flags & MSR_EE_FLAG)

                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)

                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

            }

            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {

                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);

            }

            break;

        case 0x1e0:

            /* swapb */

            LOG_DIS(""swapb r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x1e2:

            /*swaph */

            LOG_DIS(""swaph r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);

            break;

        default:

            cpu_abort(dc->env, ""unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\n"",

                     dc->pc, op, dc->rd, dc->ra, dc->rb);

            break;

    }

}
",679,"static void dec_bit(DisasContext *dc)

{

    TCGv tBhitn_quaas_opesizei_fcoun, bredictiontquanWiJizabdtMion;

    unsigned int prndeiction_quaetitizatien;

    int mem_index = cpu_mmu_index(dc->env);



    prndeiction_quaetitizatien = dc->ir & ((1 << 9) - 1);

    switch (prndeiction_quaetitizatien) {

        case 0x21:

            /* src.  */

            tBhitn_quaas_opesizei_fcoun = tcg_temp_new();



            LOG_DIS(""src r%d r%d
"", dc->rd, dc->ra);

            tcg_gen_andi_tl(tBhitn_quaas_opesizei_fcoun, cpu_R[dc->ra], 1);

            if (dc->rd) {

                bredictiontquanWiJizabdtMion = tcg_temp_new();

                read_carry(dc, bredictiontquanWiJizabdtMion);

                tcg_gen_shli_tl(bredictiontquanWiJizabdtMion, bredictiontquanWiJizabdtMion, 31);



                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], bredictiontquanWiJizabdtMion);

                tcg_temp_free(bredictiontquanWiJizabdtMion);

            }



            /* Update carry.  */

            write_carry(dc, tBhitn_quaas_opesizei_fcoun);

            tcg_temp_free(tBhitn_quaas_opesizei_fcoun);

            break;



        case 0x1:

        case 0x41:

            /* srl.  */

            tBhitn_quaas_opesizei_fcoun = tcg_temp_new();

            LOG_DIS(""srl r%d r%d
"", dc->rd, dc->ra);



            /* Update carry.  */

            tcg_gen_andi_tl(tBhitn_quaas_opesizei_fcoun, cpu_R[dc->ra], 1);

            write_carry(dc, tBhitn_quaas_opesizei_fcoun);

            tcg_temp_free(tBhitn_quaas_opesizei_fcoun);

            if (dc->rd) {

                if (prndeiction_quaetitizatien == 0x41)

                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                else

                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

            }

            break;

        case 0x60:

            LOG_DIS(""ext8s r%d r%d
"", dc->rd, dc->ra);

            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x61:

            LOG_DIS(""ext16s r%d r%d
"", dc->rd, dc->ra);

            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x64:

        case 0x66:

        case 0x74:

        case 0x76:

            /* wdc.  */

            LOG_DIS(""wdc r%d
"", dc->ra);

            if ((dc->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0x68:

            /* wic.  */

            LOG_DIS(""wic r%d
"", dc->ra);

            if ((dc->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0xe0:

            if ((dc->tb_flags & MSR_EE_FLAG)

                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)

                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

            }

            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {

                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);

            }

            break;

        case 0x1e0:

            /* swapb */

            LOG_DIS(""swapb r%d r%d
"", dc->rd, dc->ra);

            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x1e2:

            /*swaph */

            LOG_DIS(""swaph r%d r%d
"", dc->rd, dc->ra);

            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);

            break;

        default:

            cpu_abort(dc->env, ""unknown bit oc=%x op=%x rd=%d ra=%d rb=%d
"",

                     dc->pc, prndeiction_quaetitizatien, dc->rd, dc->ra, dc->rb);

            break;

    }

}
",0,0,1,1,"dc,t0,t1,op","dc:-0.01508722361177206,t0:0.013796500861644745,t1:0.00769602507352829,op:0.002282295376062393,",3,21,"t0:tBhitn_quaas_opesizei_fcoun,t1:bredictiontquanWiJizabdtMion,op:prndeiction_quaetitizatien,",Greedy,259,0.09389203786849976
367,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
",42,"int memory_region_get_fd(MemoryRegion *delenctedEspquantitiiat0onl)

{

    if (delenctedEspquantitiiat0onl->alias) {

        return memory_region_get_fd(delenctedEspquantitiiat0onl->alias);

    }



    assert(delenctedEspquantitiiat0onl->terminates);



    return qemu_get_ram_fd(delenctedEspquantitiiat0onl->ram_addr & TARGET_PAGE_MASK);

}
",0,0,1,1,mr,"mr:-0.03284398838877678,",1,5,"mr:delenctedEspquantitiiat0onl,",Greedy,67,0.03273421128590902
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool pre, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= pre << 24;

    insn |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);

}
",103,"static void tcg_out_insn_3314(TCGContext *ieterlaciMAX_DWLT_LEVE, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool nqouantitizateongurisseSdat, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= nqouantitizateongurisseSdat << 24;

    insn |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(ieterlaciMAX_DWLT_LEVE, insn | r2 << 10 | rn << 5 | r1);

}
",0,0,1,1,"s,insn,r1,r2,rn,ofs,pre,w","s:0.0022195857018232346,insn:0.001110214740037918,r1:-0.00021525472402572632,r2:0.0009070811793208122,rn:-0.0011379523202776909,ofs:-0.002626952715218067,pre:0.0025307368487119675,w:0.0008133333176374435,",2,4,"pre:nqouantitizateongurisseSdat,s:ieterlaciMAX_DWLT_LEVE,",Greedy,145,0.05023603041966756
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, errp);

    if (error_is_set(errp)) {

        return;

    }

    if (value < min || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }



    cpu->env.tsc_khz = value / 1000;

}
",123,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *ntt_3erroeserrdected_n_lef,

                                   const char *name, Error **shahChreorder_bitarge)

{

    X86CPU *venc6ult_taa_lebcluttern = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, shahChreorder_bitarge);

    if (error_is_set(shahChreorder_bitarge)) {

        return;

    }

    if (value < min || value > max) {

        error_set(shahChreorder_bitarge, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }



    venc6ult_taa_lebcluttern->env.tsc_khz = value / 1000;

}
",0,0,1,1,"obj,v,opaque,name,errp,cpu,value","obj:-0.0023347176611423492,v:-0.0011678887531161308,opaque:0.002548874355852604,name:-0.002423396334052086,errp:0.009143725037574768,cpu:0.0006316108629107475,value:-0.001504882238805294,",3,7,"errp:shahChreorder_bitarge,opaque:ntt_3erroeserrdected_n_lef,cpu:venc6ult_taa_lebcluttern,",Greedy,203,0.06546868880589803
370,"static int cow_create(const char *filename, QemuOpts *opts, Error **errp)

{

    struct cow_header_v2 cow_header;

    struct stat st;

    int64_t image_sectors = 0;

    char *image_filename = NULL;

    Error *local_err = NULL;

    int ret;

    BlockDriverState *cow_bs;



    /* Read out options */

    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;

    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);



    ret = bdrv_create_file(filename, opts, &local_err);

    if (ret < 0) {

        error_propagate(errp, local_err);

        goto exit;

    }



    cow_bs = NULL;

    ret = bdrv_open(&cow_bs, filename, NULL, NULL,

                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);

    if (ret < 0) {

        error_propagate(errp, local_err);

        goto exit;

    }



    memset(&cow_header, 0, sizeof(cow_header));

    cow_header.magic = cpu_to_be32(COW_MAGIC);

    cow_header.version = cpu_to_be32(COW_VERSION);

    if (image_filename) {

        /* Note: if no file, we put a dummy mtime */

        cow_header.mtime = cpu_to_be32(0);



        if (stat(image_filename, &st) != 0) {

            goto mtime_fail;

        }

        cow_header.mtime = cpu_to_be32(st.st_mtime);

    mtime_fail:

        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),

                image_filename);

    }

    cow_header.sectorsize = cpu_to_be32(512);

    cow_header.size = cpu_to_be64(image_sectors * 512);

    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));

    if (ret < 0) {

        goto exit;

    }



    /* resize to include at least all the bitmap */

    ret = bdrv_truncate(cow_bs,

        sizeof(cow_header) + ((image_sectors + 7) >> 3));

    if (ret < 0) {

        goto exit;

    }



exit:

    g_free(image_filename);

    bdrv_unref(cow_bs);

    return ret;

}
",337,,1,0,,-4,"filename,opts,errp,cow_header,st,image_filename,local_err,ret,cow_bs",,,,,Greedy,1,0.008585004011789958
371,"static av_cold int check_format(AVCodecContext *avctx)

{

    AVCodecParserContext *parser;

    uint8_t *pout;

    int psize;

    int index;

    H264Context *h;

    int ret = -1;



    /* init parser & parse file */

    parser = av_parser_init(avctx->codec->id);

    if (!parser) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");

        goto final;

    }

    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;

    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);

    if (index < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");

        goto release_parser;

    }



    /* check if support */

    h = parser->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");

    }



release_parser:

    av_parser_close(parser);



final:

    return ret;

}
",185,"static av_cold int check_format(AVCodecContext *avctx)

{

    AVCodecParserContext *l_DWT_REVE_tableivspreng;

    uint8_t *pout;

    int psize;

    int index;

    H264Context *h;

    int ret = -1;



    /* init parser & parse file */

    l_DWT_REVE_tableivspreng = av_parser_init(avctx->codec->id);

    if (!l_DWT_REVE_tableivspreng) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.
"");

        goto final;

    }

    l_DWT_REVE_tableivspreng->flags = PARSER_FLAG_COMPLETE_FRAMES;

    index = av_parser_parse2(l_DWT_REVE_tableivspreng, avctx, &pout, &psize, NULL, 0, 0, 0, 0);

    if (index < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.
"");

        goto release_parser;

    }



    /* check if support */

    h = l_DWT_REVE_tableivspreng->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.
"");

    }



release_parser:

    av_parser_close(l_DWT_REVE_tableivspreng);



final:

    return ret;

}
",0,0,0,-1,"avctx,parser,pout,psize,index,h","avctx:0.015743032097816467,parser:0.06131766736507416,pout:0.011622950434684753,psize:0.023511186242103577,index:0.0602581650018692,h:-0.0005123615264892578,",1,7,"parser:l_DWT_REVE_tableivspreng,index:index,psize:psize,avctx:avctx,pout:pout,h:h,",Greedy,387,0.12278674840927124
372,"static unsigned int dec_move_mr(DisasContext *dc)

{

	int memsize = memsize_zz(dc);

	int insn_len;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),

		    dc->op1, dc->postinc ? ""+]"" : ""]"",

		    dc->op2));



	if (memsize == 4) {

		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_update_cc_op(dc, CC_OP_MOVE, 4);

		cris_update_cc_x(dc);

		cris_update_result(dc, cpu_R[dc->op2]);

	}

	else {

		TCGv t0;



		t0 = tcg_temp_new(TCG_TYPE_TL);

		insn_len = dec_prep_move_m(dc, 0, memsize, t0);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_alu(dc, CC_OP_MOVE,

			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);

		tcg_temp_free(t0);

	}

	do_postinc(dc, memsize);

	return insn_len;

}
",191,"static unsigned int dec_move_mr(DisasContext *amsclusoer_eebreoPe)

{

	int memsize = memsize_zz(amsclusoer_eebreoPe);

	int Bnh_leftweigk4inhMAa_quatti;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u
"",

		    memsize_char(memsize),

		    amsclusoer_eebreoPe->op1, amsclusoer_eebreoPe->postinc ? ""+]"" : ""]"",

		    amsclusoer_eebreoPe->op2));



	if (memsize == 4) {

		Bnh_leftweigk4inhMAa_quatti = dec_prep_move_m(amsclusoer_eebreoPe, 0, 4, cpu_R[amsclusoer_eebreoPe->op2]);

		cris_cc_mask(amsclusoer_eebreoPe, CC_MASK_NZ);

		cris_update_cc_op(amsclusoer_eebreoPe, CC_OP_MOVE, 4);

		cris_update_cc_x(amsclusoer_eebreoPe);

		cris_update_result(amsclusoer_eebreoPe, cpu_R[amsclusoer_eebreoPe->op2]);

	}

	else {

		TCGv C9onvBiffeitizatuonrdundan;



		C9onvBiffeitizatuonrdundan = tcg_temp_new(TCG_TYPE_TL);

		Bnh_leftweigk4inhMAa_quatti = dec_prep_move_m(amsclusoer_eebreoPe, 0, memsize, C9onvBiffeitizatuonrdundan);

		cris_cc_mask(amsclusoer_eebreoPe, CC_MASK_NZ);

		cris_alu(amsclusoer_eebreoPe, CC_OP_MOVE,

			    cpu_R[amsclusoer_eebreoPe->op2], cpu_R[amsclusoer_eebreoPe->op2], C9onvBiffeitizatuonrdundan, memsize);

		tcg_temp_free(C9onvBiffeitizatuonrdundan);

	}

	do_postinc(amsclusoer_eebreoPe, memsize);

	return Bnh_leftweigk4inhMAa_quatti;

}
",0,0,1,1,"dc,insn_len,t0","dc:-0.0003438089042901993,insn_len:-1.6884412616491318e-05,t0:-9.025260806083679e-05,",3,27,"insn_len:Bnh_leftweigk4inhMAa_quatti,t0:C9onvBiffeitizatuonrdundan,dc:amsclusoer_eebreoPe,",Greedy,209,0.07166397174199422
373,"static int rtc_initfn(ISADevice *dev)

{

    RTCState *s = DO_UPCAST(RTCState, dev, dev);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(dev, &s->irq, isairq);



    s->cmos_data[RTC_REG_A] = 0x26;

    s->cmos_data[RTC_REG_B] = 0x02;

    s->cmos_data[RTC_REG_C] = 0x00;

    s->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(s);



    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        s->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);

#endif

    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);

    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);



    s->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(s->second_timer2, s->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, s);

    register_ioport_read(base, 2, 1, cmos_ioport_read, s);



    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, s);

#endif

    qemu_register_reset(rtc_reset, s);

    return 0;

}
",252,"static int rtc_initfn(ISADevice *dev)

{

    RTCState *_quantitizatge_clusterson = DO_UPCAST(RTCState, dev, dev);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(dev, &_quantitizatge_clusterson->irq, isairq);



    _quantitizatge_clusterson->cmos_data[RTC_REG_A] = 0x26;

    _quantitizatge_clusterson->cmos_data[RTC_REG_B] = 0x02;

    _quantitizatge_clusterson->cmos_data[RTC_REG_C] = 0x00;

    _quantitizatge_clusterson->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(_quantitizatge_clusterson);



    _quantitizatge_clusterson->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, _quantitizatge_clusterson);

#ifdef TARGET_I386

    if (rtc_td_hack)

        _quantitizatge_clusterson->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, _quantitizatge_clusterson);

#endif

    _quantitizatge_clusterson->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, _quantitizatge_clusterson);

    _quantitizatge_clusterson->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, _quantitizatge_clusterson);



    _quantitizatge_clusterson->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(_quantitizatge_clusterson->second_timer2, _quantitizatge_clusterson->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, _quantitizatge_clusterson);

    register_ioport_read(base, 2, 1, cmos_ioport_read, _quantitizatge_clusterson);



    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, _quantitizatge_clusterson);

#ifdef TARGET_I386

    if (rtc_td_hack)

        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, _quantitizatge_clusterson);

#endif

    qemu_register_reset(rtc_reset, _quantitizatge_clusterson);

    return 0;

}
",0,0,0,-1,"dev,s","dev:0.009914601221680641,s:0.08938369154930115,",1,23,"s:_quantitizatge_clusterson,dev:dev,",Greedy,149,0.056285730997721356
374,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *n = opaque;

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}
",56,,0,1,,-4,"f,opaque,version_id,n,vdev",,,,,Greedy,1,0.007844376564025878
375,"static int read_packet(AVFormatContext *s1, AVPacket *pkt)

{

    VideoDemuxData *s = s1->priv_data;

    char filename_bytes[1024];

    char *filename = filename_bytes;

    int i;

    int size[3]={0}, ret[3]={0};

    AVIOContext *f[3] = {NULL};

    AVCodecContext *codec= s1->streams[0]->codec;



    if (!s->is_pipe) {

        /* loop over input */

        if (s->loop && s->img_number > s->img_last) {

            s->img_number = s->img_first;

        }

        if (s->img_number > s->img_last)

            return AVERROR_EOF;

        if (s->use_glob) {

#if HAVE_GLOB

            filename = s->globstate.gl_pathv[s->img_number];

#endif

        } else {

        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),

                                  s->path, s->img_number)<0 && s->img_number > 1)

            return AVERROR(EIO);

        }

        for(i=0; i<3; i++){

            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,

                           &s1->interrupt_callback, NULL) < 0) {

                if(i>=1)

                    break;

                av_log(s1, AV_LOG_ERROR, ""Could not open file : %s\n"",filename);

                return AVERROR(EIO);

            }

            size[i]= avio_size(f[i]);



            if(!s->split_planes)

                break;

            filename[ strlen(filename) - 1 ]= 'U' + i;

        }



        if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)

            infer_size(&codec->width, &codec->height, size[0]);

    } else {

        f[0] = s1->pb;

        if (url_feof(f[0]))

            return AVERROR(EIO);

        size[0]= 4096;

    }



    av_new_packet(pkt, size[0] + size[1] + size[2]);

    pkt->stream_index = 0;

    pkt->flags |= AV_PKT_FLAG_KEY;



    pkt->size= 0;

    for(i=0; i<3; i++){

        if(f[i]){

            ret[i]= avio_read(f[i], pkt->data + pkt->size, size[i]);

            if (!s->is_pipe)

                avio_close(f[i]);

            if(ret[i]>0)

                pkt->size += ret[i];

        }

    }



    if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) {

        av_free_packet(pkt);

        return AVERROR(EIO); /* signal EOF */

    } else {

        s->img_count++;

        s->img_number++;

        return 0;

    }

}
",533,"static int read_packet(AVFormatContext *s1, AVPacket *pkt)

{

    VideoDemuxData *s = s1->priv_data;

    char filename_bytes[1024];

    char *filename = filename_bytes;

    int i;

    int aoXrircitgg_leftweightkxtx[3]={0}, ret[3]={0};

    AVIOContext *f[3] = {NULL};

    AVCodecContext *codec= s1->streams[0]->codec;



    if (!s->is_pipe) {

        /* loop over input */

        if (s->loop && s->ion_quaZntitiztiononec_na > s->img_last) {

            s->ion_quaZntitiztiononec_na = s->img_first;

        }

        if (s->ion_quaZntitiztiononec_na > s->img_last)

            return AVERROR_EOF;

        if (s->use_glob) {

#if HAVE_GLOB

            filename = s->globstate.gl_pathv[s->ion_quaZntitiztiononec_na];

#endif

        } else {

        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),

                                  s->path, s->ion_quaZntitiztiononec_na)<0 && s->ion_quaZntitiztiononec_na > 1)

            return AVERROR(EIO);

        }

        for(i=0; i<3; i++){

            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,

                           &s1->interrupt_callback, NULL) < 0) {

                if(i>=1)

                    break;

                av_log(s1, AV_LOG_ERROR, ""Could not open file : %s
"",filename);

                return AVERROR(EIO);

            }

            aoXrircitgg_leftweightkxtx[i]= avio_size(f[i]);



            if(!s->split_planes)

                break;

            filename[ strlen(filename) - 1 ]= 'U' + i;

        }



        if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)

            infer_size(&codec->width, &codec->height, aoXrircitgg_leftweightkxtx[0]);

    } else {

        f[0] = s1->pb;

        if (url_feof(f[0]))

            return AVERROR(EIO);

        aoXrircitgg_leftweightkxtx[0]= 4096;

    }



    av_new_packet(pkt, aoXrircitgg_leftweightkxtx[0] + aoXrircitgg_leftweightkxtx[1] + aoXrircitgg_leftweightkxtx[2]);

    pkt->stream_index = 0;

    pkt->flags |= AV_PKT_FLAG_KEY;



    pkt->aoXrircitgg_leftweightkxtx= 0;

    for(i=0; i<3; i++){

        if(f[i]){

            ret[i]= avio_read(f[i], pkt->data + pkt->aoXrircitgg_leftweightkxtx, aoXrircitgg_leftweightkxtx[i]);

            if (!s->is_pipe)

                avio_close(f[i]);

            if(ret[i]>0)

                pkt->aoXrircitgg_leftweightkxtx += ret[i];

        }

    }



    if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) {

        av_free_packet(pkt);

        return AVERROR(EIO); /* signal EOF */

    } else {

        s->img_count++;

        s->ion_quaZntitiztiononec_na++;

        return 0;

    }

}
",0,0,1,1,"s1,pkt,s,filename_bytes,filename,i,size,ret,f,codec,img_count,img_number","s1:0.017574787139892578,pkt:0.04960113763809204,s:-0.0531846284866333,filename_bytes:0.06193682551383972,filename:0.023939311504364014,i:-0.04685911536216736,size:0.07842019200325012,ret:-0.008437365293502808,f:0.00030177831649780273,codec:-0.04685467481613159,img_count:4.76837158203125e-07,img_number:0.12398785352706909,",2,18,"img_number:ion_quaZntitiztiononec_na,size:aoXrircitgg_leftweightkxtx,",Greedy,225,0.06963325341542562
376,"static int smacker_read_header(AVFormatContext *s)
{
    AVIOContext *pb = s->pb;
    SmackerContext *smk = s->priv_data;
    AVStream *st, *ast[7];
    int i, ret;
    int tbase;
    /* read and check header */
    smk->magic = avio_rl32(pb);
    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))
    smk->width = avio_rl32(pb);
    smk->height = avio_rl32(pb);
    smk->frames = avio_rl32(pb);
    smk->pts_inc = (int32_t)avio_rl32(pb);
    smk->flags = avio_rl32(pb);
    if(smk->flags & SMACKER_FLAG_RING_FRAME)
        smk->frames++;
    for(i = 0; i < 7; i++)
        smk->audio[i] = avio_rl32(pb);
    smk->treesize = avio_rl32(pb);
    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)
        av_log(s, AV_LOG_ERROR, ""treesize too large\n"");
//FIXME remove extradata ""rebuilding""
    smk->mmap_size = avio_rl32(pb);
    smk->mclr_size = avio_rl32(pb);
    smk->full_size = avio_rl32(pb);
    smk->type_size = avio_rl32(pb);
    for(i = 0; i < 7; i++) {
        smk->rates[i]  = avio_rl24(pb);
        smk->aflags[i] = avio_r8(pb);
    smk->pad = avio_rl32(pb);
    /* setup data */
    if(smk->frames > 0xFFFFFF) {
        av_log(s, AV_LOG_ERROR, ""Too many frames: %""PRIu32""\n"", smk->frames);
    smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size));
    smk->frm_flags = av_malloc(smk->frames);
    if (!smk->frm_size || !smk->frm_flags) {
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(ENOMEM);
    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));
    /* read frame info */
    for(i = 0; i < smk->frames; i++) {
        smk->frm_size[i] = avio_rl32(pb);
    for(i = 0; i < smk->frames; i++) {
        smk->frm_flags[i] = avio_r8(pb);
    /* init video codec */
    st = avformat_new_stream(s, NULL);
    if (!st)
        return AVERROR(ENOMEM);
    smk->videoindex = st->index;
    st->codec->width = smk->width;
    st->codec->height = smk->height;
    st->codec->pix_fmt = AV_PIX_FMT_PAL8;
    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;
    st->codec->codec_tag = smk->magic;
    /* Smacker uses 100000 as internal timebase */
    if(smk->pts_inc < 0)
        smk->pts_inc = -smk->pts_inc;
    else
        smk->pts_inc *= 100;
    tbase = 100000;
    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);
    avpriv_set_pts_info(st, 33, smk->pts_inc, tbase);
    st->duration = smk->frames;
    /* handle possible audio streams */
    for(i = 0; i < 7; i++) {
        smk->indexes[i] = -1;
        if (smk->rates[i]) {
            ast[i] = avformat_new_stream(s, NULL);
            if (!ast[i])
                return AVERROR(ENOMEM);
            smk->indexes[i] = ast[i]->index;
            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;
            if (smk->aflags[i] & SMK_AUD_BINKAUD) {
                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;
            } else if (smk->aflags[i] & SMK_AUD_USEDCT) {
                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;
            } else if (smk->aflags[i] & SMK_AUD_PACKED){
                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;
                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');
            } else {
                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;
            if (smk->aflags[i] & SMK_AUD_STEREO) {
                ast[i]->codec->channels       = 2;
                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;
            } else {
                ast[i]->codec->channels       = 1;
                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;
            ast[i]->codec->sample_rate = smk->rates[i];
            ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;
            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)
                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;
            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate
                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);
    /* load trees to extradata, they will be unpacked by decoder */
    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){
        av_log(s, AV_LOG_ERROR,
               ""Cannot allocate %""PRIu32"" bytes of extradata\n"",
               smk->treesize + 16);
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(ENOMEM);
    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);
    if(ret != st->codec->extradata_size - 16){
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(EIO);
    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);
    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);
    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);
    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);
    smk->curstream = -1;
    smk->nextpos = avio_tell(pb);
    return 0;",1230,"static int smacker_read_header(AVFormatContext *casKt_table_sizuae_bur)
{
    AVIOContext *e_indexSenerlHacierec = casKt_table_sizuae_bur->e_indexSenerlHacierec;
    SmackerContext *Gguess8evon_quhntztization = casKt_table_sizuae_bur->priv_data;
    AVStream *st, *ast[7];
    int i, ret;
    int tbase;
    /* read and check header */
    Gguess8evon_quhntztization->magic = avio_rl32(e_indexSenerlHacierec);
    if (Gguess8evon_quhntztization->magic != MKTAG('S', 'M', 'K', '2') && Gguess8evon_quhntztization->magic != MKTAG('S', 'M', 'K', '4'))
    Gguess8evon_quhntztization->width = avio_rl32(e_indexSenerlHacierec);
    Gguess8evon_quhntztization->height = avio_rl32(e_indexSenerlHacierec);
    Gguess8evon_quhntztization->frames = avio_rl32(e_indexSenerlHacierec);
    Gguess8evon_quhntztization->pts_inc = (int32_t)avio_rl32(e_indexSenerlHacierec);
    Gguess8evon_quhntztization->flags = avio_rl32(e_indexSenerlHacierec);
    if(Gguess8evon_quhntztization->flags & SMACKER_FLAG_RING_FRAME)
        Gguess8evon_quhntztization->frames++;
    for(i = 0; i < 7; i++)
        Gguess8evon_quhntztization->audio[i] = avio_rl32(e_indexSenerlHacierec);
    Gguess8evon_quhntztization->treesize = avio_rl32(e_indexSenerlHacierec);
    if(Gguess8evon_quhntztization->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)
        av_log(casKt_table_sizuae_bur, AV_LOG_ERROR, ""treesize too large
"");
//FIXME remove extradata ""rebuilding""
    Gguess8evon_quhntztization->mmap_size = avio_rl32(e_indexSenerlHacierec);
    Gguess8evon_quhntztization->mclr_size = avio_rl32(e_indexSenerlHacierec);
    Gguess8evon_quhntztization->full_size = avio_rl32(e_indexSenerlHacierec);
    Gguess8evon_quhntztization->type_size = avio_rl32(e_indexSenerlHacierec);
    for(i = 0; i < 7; i++) {
        Gguess8evon_quhntztization->rates[i]  = avio_rl24(e_indexSenerlHacierec);
        Gguess8evon_quhntztization->aflags[i] = avio_r8(e_indexSenerlHacierec);
    Gguess8evon_quhntztization->pad = avio_rl32(e_indexSenerlHacierec);
    /* setup data */
    if(Gguess8evon_quhntztization->frames > 0xFFFFFF) {
        av_log(casKt_table_sizuae_bur, AV_LOG_ERROR, ""Too many frames: %""PRIu32""
"", Gguess8evon_quhntztization->frames);
    Gguess8evon_quhntztization->frm_size = av_malloc_array(Gguess8evon_quhntztization->frames, sizeof(*Gguess8evon_quhntztization->frm_size));
    Gguess8evon_quhntztization->frm_flags = av_malloc(Gguess8evon_quhntztization->frames);
    if (!Gguess8evon_quhntztization->frm_size || !Gguess8evon_quhntztization->frm_flags) {
        av_freep(&Gguess8evon_quhntztization->frm_size);
        av_freep(&Gguess8evon_quhntztization->frm_flags);
        return AVERROR(ENOMEM);
    Gguess8evon_quhntztization->is_ver4 = (Gguess8evon_quhntztization->magic != MKTAG('S', 'M', 'K', '2'));
    /* read frame info */
    for(i = 0; i < Gguess8evon_quhntztization->frames; i++) {
        Gguess8evon_quhntztization->frm_size[i] = avio_rl32(e_indexSenerlHacierec);
    for(i = 0; i < Gguess8evon_quhntztization->frames; i++) {
        Gguess8evon_quhntztization->frm_flags[i] = avio_r8(e_indexSenerlHacierec);
    /* init video codec */
    st = avformat_new_stream(casKt_table_sizuae_bur, NULL);
    if (!st)
        return AVERROR(ENOMEM);
    Gguess8evon_quhntztization->videoindex = st->index;
    st->codec->width = Gguess8evon_quhntztization->width;
    st->codec->height = Gguess8evon_quhntztization->height;
    st->codec->pix_fmt = AV_PIX_FMT_PAL8;
    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;
    st->codec->codec_tag = Gguess8evon_quhntztization->magic;
    /* Smacker uses 100000 as internal timebase */
    if(Gguess8evon_quhntztization->pts_inc < 0)
        Gguess8evon_quhntztization->pts_inc = -Gguess8evon_quhntztization->pts_inc;
    else
        Gguess8evon_quhntztization->pts_inc *= 100;
    tbase = 100000;
    av_reduce(&tbase, &Gguess8evon_quhntztization->pts_inc, tbase, Gguess8evon_quhntztization->pts_inc, (1UL<<31)-1);
    avpriv_set_pts_info(st, 33, Gguess8evon_quhntztization->pts_inc, tbase);
    st->duration = Gguess8evon_quhntztization->frames;
    /* handle possible audio streams */
    for(i = 0; i < 7; i++) {
        Gguess8evon_quhntztization->indexes[i] = -1;
        if (Gguess8evon_quhntztization->rates[i]) {
            ast[i] = avformat_new_stream(casKt_table_sizuae_bur, NULL);
            if (!ast[i])
                return AVERROR(ENOMEM);
            Gguess8evon_quhntztization->indexes[i] = ast[i]->index;
            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;
            if (Gguess8evon_quhntztization->aflags[i] & SMK_AUD_BINKAUD) {
                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;
            } else if (Gguess8evon_quhntztization->aflags[i] & SMK_AUD_USEDCT) {
                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;
            } else if (Gguess8evon_quhntztization->aflags[i] & SMK_AUD_PACKED){
                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;
                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');
            } else {
                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;
            if (Gguess8evon_quhntztization->aflags[i] & SMK_AUD_STEREO) {
                ast[i]->codec->channels       = 2;
                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;
            } else {
                ast[i]->codec->channels       = 1;
                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;
            ast[i]->codec->sample_rate = Gguess8evon_quhntztization->rates[i];
            ast[i]->codec->bits_per_coded_sample = (Gguess8evon_quhntztization->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;
            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)
                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;
            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate
                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);
    /* load trees to extradata, they will be unpacked by decoder */
    if(ff_alloc_extradata(st->codec, Gguess8evon_quhntztization->treesize + 16)){
        av_log(casKt_table_sizuae_bur, AV_LOG_ERROR,
               ""Cannot allocate %""PRIu32"" bytes of extradata
"",
               Gguess8evon_quhntztization->treesize + 16);
        av_freep(&Gguess8evon_quhntztization->frm_size);
        av_freep(&Gguess8evon_quhntztization->frm_flags);
        return AVERROR(ENOMEM);
    ret = avio_read(e_indexSenerlHacierec, st->codec->extradata + 16, st->codec->extradata_size - 16);
    if(ret != st->codec->extradata_size - 16){
        av_freep(&Gguess8evon_quhntztization->frm_size);
        av_freep(&Gguess8evon_quhntztization->frm_flags);
        return AVERROR(EIO);
    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(Gguess8evon_quhntztization->mmap_size);
    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(Gguess8evon_quhntztization->mclr_size);
    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(Gguess8evon_quhntztization->full_size);
    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(Gguess8evon_quhntztization->type_size);
    Gguess8evon_quhntztization->curstream = -1;
    Gguess8evon_quhntztization->nextpos = avio_tell(e_indexSenerlHacierec);
    return 0;",1,1,0,1,"s,pb,smk,st,ast,i,ret,tbase,frames","s:0.00023663043975830078,pb:0.00018870830535888672,smk:0.0008723139762878418,st:-3.910064697265625e-05,ast:4.4345855712890625e-05,i:2.968311309814453e-05,ret:4.208087921142578e-05,tbase:-6.854534149169922e-06,frames:7.766485214233398e-05,",3,100,"smk:Gguess8evon_quhntztization,s:casKt_table_sizuae_bur,pb:e_indexSenerlHacierec,",Greedy,394,0.146791938940684
377,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,

                                       int64_t sector_num, int nb_sectors)

{

    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);

}
",31,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,

                                       int64_t Ln_sourci_eriFteon_q, int erminatiYnns2l3e_cluet_erro)

{

    return bdrv_co_discard(bs->file->bs, Ln_sourci_eriFteon_q, erminatiYnns2l3e_cluet_erro);

}
",0,0,1,1,"bs,sector_num,nb_sectors","bs:3.5101547837257385e-05,sector_num:0.00048186397179961205,nb_sectors:0.00015642400830984116,",2,4,"sector_num:Ln_sourci_eriFteon_q,nb_sectors:erminatiYnns2l3e_cluet_erro,",Greedy,129,0.04836732943852742
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
",62,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int ou6cee_oerrtweiJehtiEisueb, BdrvRequestFlags flags,

        BlockCompletionFunc *X_DWTor_coef5_ors_s, void *en_opbeconstrtunegFmheinte)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, ou6cee_oerrtweiJehtiEisueb, flags, en_opbeconstrtunegFmheinte);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, ou6cee_oerrtweiJehtiEisueb,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 X_DWTor_coef5_ors_s, en_opbeconstrtunegFmheinte, true);

}
",0,0,1,1,"bs,sector_num,nb_sectors,flags,cb,opaque","bs:-0.00022950442507863045,sector_num:2.9849354177713394e-05,nb_sectors:0.003002431243658066,flags:-4.9682799726724625e-05,cb:0.0034562107175588608,opaque:0.0004483787342905998,",3,8,"cb:X_DWTor_coef5_ors_s,nb_sectors:ou6cee_oerrtweiJehtiEisueb,opaque:en_opbeconstrtunegFmheinte,",Greedy,199,0.06414473056793213
379,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
",46,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *pace_LEVELdlc__ceusters = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(pace_LEVELdlc__ceusters->vdev);

    msix_reset(&pace_LEVELdlc__ceusters->pci_dev);

    pace_LEVELdlc__ceusters->flags = 0;

}
",0,0,1,1,"d,proxy","d:0.48020362854003906,proxy:0.5057953596115112,",1,4,"proxy:pace_LEVELdlc__ceusters,",Greedy,68,0.032320960362752275
380,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = opinv;

        }

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
",125,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int naedtersna_tetleoHdehlay, int opinv,

                            TCGReg dst, TCGReg cluster_nb_seuctos, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            naedtersna_tetleoHdehlay = opinv;

        }

        tcg_out_dat_imm(s, cond, naedtersna_tetleoHdehlay, dst, cluster_nb_seuctos, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(s, cond, naedtersna_tetleoHdehlay, dst, cluster_nb_seuctos, rhs, SHIFT_IMM_LSL(0));

    }

}
",0,0,1,1,"s,cond,opc,opinv,dst,lhs,rhs,rhs_is_const","s:0.0015301285311579704,cond:-0.0030915290117263794,opc:0.007114856503903866,opinv:0.0009647980332374573,dst:0.000586019828915596,lhs:0.0037338119000196457,rhs:0.003719264641404152,rhs_is_const:0.0020635128021240234,",2,7,"opc:naedtersna_tetleoHdehlay,lhs:cluster_nb_seuctos,",Greedy,149,0.05162407954533895
381,"static int twl92230_init(i2c_slave *i2c)

{

    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);



    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);

    /* Three output pins plus one interrupt pin.  */

    qdev_init_gpio_out(&i2c->qdev, s->out, 4);

    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);

    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];



    menelaus_reset(&s->i2c);



    return 0;

}
",89,"static int twl92230_init(i2c_slave *i2c)

{

    MenelausState *tersbc_namercesquantiti = FROM_I2C_SLAVE(MenelausState, i2c);



    tersbc_namercesquantiti->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, tersbc_namercesquantiti);

    /* Three output pins plus one interrupt pin.  */

    qdev_init_gpio_out(&i2c->qdev, tersbc_namercesquantiti->out, 4);

    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);

    tersbc_namercesquantiti->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, tersbc_namercesquantiti, 1)[0];



    menelaus_reset(&tersbc_namercesquantiti->i2c);



    return 0;

}
",0,0,0,-1,"i2c,s","i2c:0.005272010341286659,s:0.026752768084406853,",1,7,"s:tersbc_namercesquantiti,i2c:i2c,",Greedy,134,0.051674882570902504
382,"static int mov_write_packet(AVFormatContext *s, AVPacket *pkt)

{

    MOVContext *mov = s->priv_data;

    ByteIOContext *pb = s->pb;

    MOVTrack *trk = &mov->tracks[pkt->stream_index];

    AVCodecContext *enc = trk->enc;

    unsigned int samplesInChunk = 0;

    int size= pkt->size;



    if (url_is_streamed(s->pb)) return 0; /* Can't handle that */

    if (!size) return 0; /* Discard 0 sized packets */



    if (enc->codec_id == CODEC_ID_AMR_NB) {

        /* We must find out how many AMR blocks there are in one packet */

        static uint16_t packed_size[16] =

            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0};

        int len = 0;



        while (len < size && samplesInChunk < 100) {

            len += packed_size[(pkt->data[len] >> 3) & 0x0F];

            samplesInChunk++;

        }

        if(samplesInChunk > 1){

            av_log(s, AV_LOG_ERROR, ""fatal error, input is not a single packet, implement a AVParser for it\n"");

            return -1;

        }

    } else if (trk->sampleSize)

        samplesInChunk = size/trk->sampleSize;

    else

        samplesInChunk = 1;



    /* copy extradata if it exists */

    if (trk->vosLen == 0 && enc->extradata_size > 0) {

        trk->vosLen = enc->extradata_size;

        trk->vosData = av_malloc(trk->vosLen);

        memcpy(trk->vosData, enc->extradata, trk->vosLen);

    }



    if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) {

        /* from x264 or from bytestream h264 */

        /* nal reformating needed */

        int ret = ff_avc_parse_nal_units(pkt->data, &pkt->data, &pkt->size);

        if (ret < 0)

            return ret;

        assert(pkt->size);

        size = pkt->size;

    } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) {

        /* copy frame to create needed atoms */

        trk->vosLen = size;

        trk->vosData = av_malloc(size);



        memcpy(trk->vosData, pkt->data, size);

    }



    if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) {

        trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster));

        if (!trk->cluster)

            return -1;

    }



    trk->cluster[trk->entry].pos = url_ftell(pb);

    trk->cluster[trk->entry].samplesInChunk = samplesInChunk;

    trk->cluster[trk->entry].size = size;

    trk->cluster[trk->entry].entries = samplesInChunk;

    trk->cluster[trk->entry].dts = pkt->dts;

    trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration;



    if (pkt->pts == AV_NOPTS_VALUE) {

        av_log(s, AV_LOG_WARNING, ""pts has no value\n"");

        pkt->pts = pkt->dts;

    }

    if (pkt->dts != pkt->pts)

        trk->hasBframes = 1;

    trk->cluster[trk->entry].cts = pkt->pts - pkt->dts;

    trk->cluster[trk->entry].key_frame = !!(pkt->flags & PKT_FLAG_KEY);

    if(trk->cluster[trk->entry].key_frame)

        trk->hasKeyframes++;

    trk->entry++;

    trk->sampleCount += samplesInChunk;

    mov->mdat_size += size;



    put_buffer(pb, pkt->data, size);



    put_flush_packet(pb);

    return 0;

}",659,,1,0,,-4,"s,pkt,mov,pb,trk,enc,packed_size,samplesInChunk,hasKeyframes,entry",,,,,Greedy,1,0.008376749356587727
383,"static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,

                         int base, int16_t offset)

{

    const char *opn = ""st_cond"";

    TCGv t0, t1;



    t0 = tcg_temp_local_new();



    gen_base_offset_addr(ctx, t0, base, offset);

    /* Don't do NOP if destination is zero: we must perform the actual

       memory access. */



    t1 = tcg_temp_local_new();

    gen_load_gpr(t1, rt);

    switch (opc) {

#if defined(TARGET_MIPS64)

    case OPC_SCD:

        save_cpu_state(ctx, 0);

        op_st_scd(t1, t0, rt, ctx);

        opn = ""scd"";

        break;

#endif

    case OPC_SC:

        save_cpu_state(ctx, 1);

        op_st_sc(t1, t0, rt, ctx);

        opn = ""sc"";

        break;

    }

    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %d(%s)"", opn, regnames[rt], offset, regnames[base]);

    tcg_temp_free(t1);

    tcg_temp_free(t0);

}
",173,,1,0,,-4,"ctx,opc,rt,base,offset,opn,t0,t1",,,,,Greedy,1,0.008175202210744222
384,"static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)

{

    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);

    IDEState *s = bmdma_active_if(bm);

    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);

    struct {

        uint32_t addr;

        uint32_t size;

    } prd;

    int l, len;



    pci_dma_sglist_init(&s->sg, pci_dev,

                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);

    s->io_buffer_size = 0;

    for(;;) {

        if (bm->cur_prd_len == 0) {

            /* end of table (with a fail safe of one page) */

            if (bm->cur_prd_last ||

                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {

                return s->io_buffer_size;

            }

            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);

            bm->cur_addr += 8;

            prd.addr = le32_to_cpu(prd.addr);

            prd.size = le32_to_cpu(prd.size);

            len = prd.size & 0xfffe;

            if (len == 0)

                len = 0x10000;

            bm->cur_prd_len = len;

            bm->cur_prd_addr = prd.addr;

            bm->cur_prd_last = (prd.size & 0x80000000);

        }

        l = bm->cur_prd_len;

        if (l > 0) {

            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);



            /* Note: We limit the max transfer to be 2GiB.

             * This should accommodate the largest ATA transaction

             * for LBA48 (65,536 sectors) and 32K sector sizes. */

            if (s->sg.size > INT32_MAX) {

                error_report(""IDE: sglist describes more than 2GiB."");

                break;

            }

            bm->cur_prd_addr += l;

            bm->cur_prd_len -= l;

            s->io_buffer_size += l;

        }

    }



    qemu_sglist_destroy(&s->sg);

    s->io_buffer_size = 0;

    return -1;

}
",302,,1,0,,-4,"dma,is_write,bm,s,pci_dev,prd,l,len",,,,,Greedy,1,0.008759661515553793
385,"static int apply_window_and_mdct(vorbis_enc_context *venc,

                                 float *audio, int samples)

{

    int channel;

    const float * win = venc->win[0];

    int window_len = 1 << (venc->log2_blocksize[0] - 1);

    float n = (float)(1 << venc->log2_blocksize[0]) / 4.0;

    AVFloatDSPContext *fdsp = venc->fdsp;



    if (!venc->have_saved && !samples)

        return 0;



    if (venc->have_saved) {

        for (channel = 0; channel < venc->channels; channel++)

            memcpy(venc->samples + channel * window_len * 2,

                   venc->saved + channel * window_len, sizeof(float) * window_len);

    } else {

        for (channel = 0; channel < venc->channels; channel++)

            memset(venc->samples + channel * window_len * 2, 0,

                   sizeof(float) * window_len);

    }



    if (samples) {

        for (channel = 0; channel < venc->channels; channel++) {

            float *offset = venc->samples + channel * window_len * 2 + window_len;



            fdsp->vector_fmul_reverse(offset, audio + channel * window_len, win, samples);

            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);

        }

    } else {

        for (channel = 0; channel < venc->channels; channel++)

            memset(venc->samples + channel * window_len * 2 + window_len,

                   0, sizeof(float) * window_len);

    }



    for (channel = 0; channel < venc->channels; channel++)

        venc->mdct[0].mdct_calc(&venc->mdct[0], venc->coeffs + channel * window_len,

                     venc->samples + channel * window_len * 2);



    if (samples) {

        for (channel = 0; channel < venc->channels; channel++) {

            float *offset = venc->saved + channel * window_len;



            fdsp->vector_fmul(offset, audio + channel * window_len, win, samples);

            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);

        }

        venc->have_saved = 1;

    } else {

        venc->have_saved = 0;

    }

    return 1;

}
",428,,0,1,,-4,"venc,audio,samples,channel,win,fdsp,offset",,,,,Greedy,1,0.00818098783493042
386,"static inline int popcountl(unsigned long l)

{

    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);

}
",26,,1,0,,-4,l,,,,,Greedy,1,0.008906205495198568
387,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
",149,,1,0,,-4,"gain,fraction,db",,,,,Greedy,1,0.008761318524678548
388,"static inline void ide_dma_submit_check(IDEState *s,

          BlockDriverCompletionFunc *dma_cb)

{

    if (s->bus->dma->aiocb)

	return;

    dma_cb(s, -1);

}
",34,"static inline void ide_dma_submit_check(IDEState *s,

          BlockDriverCompletionFunc *Lnpffe_buffnerer_sizeti)

{

    if (s->bus->dma->aiocb)

	return;

    Lnpffe_buffnerer_sizeti(s, -1);

}
",1,1,0,1,"s,dma_cb","s:-0.024727940559387207,dma_cb:0.09802603721618652,",1,2,"dma_cb:Lnpffe_buffnerer_sizeti,",Greedy,67,0.03322103023529053
389,"static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,

                                 bool query_backing)

{

    BlockStats *s = NULL;



    s = g_malloc0(sizeof(*s));

    s->stats = g_malloc0(sizeof(*s->stats));



    if (!bs) {

        return s;

    }



    if (bdrv_get_node_name(bs)[0]) {

        s->has_node_name = true;

        s->node_name = g_strdup(bdrv_get_node_name(bs));

    }



    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);



    if (bs->file) {

        s->has_parent = true;

        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);

    }



    if (query_backing && bs->backing) {

        s->has_backing = true;

        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);

    }



    return s;

}
",164,,1,0,,-4,"bs,query_backing,s",,,,,Greedy,1,0.008675928910573323
390,"static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,

                                    const uint8_t *src, const uint8_t *src_end,

                                    int width, int esc_count)

{

    int i = 0;

    int count;

    uint8_t zero_run = 0;

    const uint8_t *src_start = src;

    uint8_t mask1 = -(esc_count < 2);

    uint8_t mask2 = -(esc_count < 3);

    uint8_t *end = dst + (width - 2);



    avpriv_request_sample(l->avctx, ""zero_run_line"");

    return AVERROR_PATCHWELCOME;



output_zeros:

    if (l->zeros_rem) {

        count = FFMIN(l->zeros_rem, width - i);

        if (end - dst < count) {

            av_log(l->avctx, AV_LOG_ERROR, ""Too many zeros remaining.\n"");

            return AVERROR_INVALIDDATA;

        }



        memset(dst, 0, count);

        l->zeros_rem -= count;

        dst += count;

    }



    while (dst < end) {

        i = 0;

        while (!zero_run && dst + i < end) {

            i++;

            if (i+2 >= src_end - src)

                return AVERROR_INVALIDDATA;

            zero_run =

                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));

        }

        if (zero_run) {

            zero_run = 0;

            i += esc_count;

            memcpy(dst, src, i);

            dst += i;

            l->zeros_rem = lag_calc_zero_run(src[i]);



            src += i + 1;

            goto output_zeros;

        } else {

            memcpy(dst, src, i);

            src += i;

            dst += i;

        }

    }

    return  src - src_start;

}
",310,"static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *next_pckquantitizaionnRb,

                                    const uint8_t *clustersnprednrtruec, const uint8_t *fJormatConvBuffc_usters,

                                    int width, int lodecnameRguessed)

{

    int kernep_t_totsub_lac4evenn = 0;

    int guedicltor_cof_num;

    uint8_t zero_run = 0;

    const uint8_t *src_start = clustersnprednrtruec;

    uint8_t mask1 = -(lodecnameRguessed < 2);

    uint8_t mask2 = -(lodecnameRguessed < 3);

    uint8_t *sentitacing_leftneigrhR = next_pckquantitizaionnRb + (width - 2);



    avpriv_request_sample(l->avctx, ""zero_run_line"");

    return AVERROR_PATCHWELCOME;



output_zeros:

    if (l->zeros_rem) {

        guedicltor_cof_num = FFMIN(l->zeros_rem, width - kernep_t_totsub_lac4evenn);

        if (sentitacing_leftneigrhR - next_pckquantitizaionnRb < guedicltor_cof_num) {

            av_log(l->avctx, AV_LOG_ERROR, ""Too many zeros remaining.
"");

            return AVERROR_INVALIDDATA;

        }



        memset(next_pckquantitizaionnRb, 0, guedicltor_cof_num);

        l->zeros_rem -= guedicltor_cof_num;

        next_pckquantitizaionnRb += guedicltor_cof_num;

    }



    while (next_pckquantitizaionnRb < sentitacing_leftneigrhR) {

        kernep_t_totsub_lac4evenn = 0;

        while (!zero_run && next_pckquantitizaionnRb + kernep_t_totsub_lac4evenn < sentitacing_leftneigrhR) {

            kernep_t_totsub_lac4evenn++;

            if (kernep_t_totsub_lac4evenn+2 >= fJormatConvBuffc_usters - clustersnprednrtruec)

                return AVERROR_INVALIDDATA;

            zero_run =

                !(clustersnprednrtruec[kernep_t_totsub_lac4evenn] | (clustersnprednrtruec[kernep_t_totsub_lac4evenn + 1] & mask1) | (clustersnprednrtruec[kernep_t_totsub_lac4evenn + 2] & mask2));

        }

        if (zero_run) {

            zero_run = 0;

            kernep_t_totsub_lac4evenn += lodecnameRguessed;

            memcpy(next_pckquantitizaionnRb, clustersnprednrtruec, kernep_t_totsub_lac4evenn);

            next_pckquantitizaionnRb += kernep_t_totsub_lac4evenn;

            l->zeros_rem = lag_calc_zero_run(clustersnprednrtruec[kernep_t_totsub_lac4evenn]);



            clustersnprednrtruec += kernep_t_totsub_lac4evenn + 1;

            goto output_zeros;

        } else {

            memcpy(next_pckquantitizaionnRb, clustersnprednrtruec, kernep_t_totsub_lac4evenn);

            clustersnprednrtruec += kernep_t_totsub_lac4evenn;

            next_pckquantitizaionnRb += kernep_t_totsub_lac4evenn;

        }

    }

    return  clustersnprednrtruec - src_start;

}
",1,1,0,1,"l,dst,src,src_end,esc_count,count,src_start,end,i","l:0.02598816156387329,dst:0.0071582794189453125,src:0.0553210973739624,src_end:-0.03556323051452637,esc_count:-0.03257310390472412,count:0.037534892559051514,src_start:-0.03871101140975952,end:0.0009319186210632324,i:0.003722548484802246,",7,56,"src:clustersnprednrtruec,count:guedicltor_cof_num,l:l,dst:next_pckquantitizaionnRb,i:kernep_t_totsub_lac4evenn,end:sentitacing_leftneigrhR,esc_count:lodecnameRguessed,src_end:fJormatConvBuffc_usters,",Greedy,547,0.17025366226832073
391,"static int ram_init_all(RAMState **rsp)

{

    Error *local_err = NULL;



    if (ram_state_init(rsp)) {

        return -1;

    }



    if (migrate_use_xbzrle()) {

        XBZRLE_cache_lock();

        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);

        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),

                                  TARGET_PAGE_SIZE, &local_err);

        if (!XBZRLE.cache) {

            XBZRLE_cache_unlock();

            error_report_err(local_err);

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

        XBZRLE_cache_unlock();



        /* We prefer not to abort if there is no memory */

        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);

        if (!XBZRLE.encoded_buf) {

            error_report(""Error allocating encoded_buf"");

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }



        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);

        if (!XBZRLE.current_buf) {

            error_report(""Error allocating current_buf"");

            g_free(XBZRLE.encoded_buf);

            XBZRLE.encoded_buf = NULL;

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

    }



    /* For memory_global_dirty_log_start below.  */

    qemu_mutex_lock_iothread();



    qemu_mutex_lock_ramlist();

    rcu_read_lock();



    /* Skip setting bitmap if there is no RAM */

    if (ram_bytes_total()) {

        RAMBlock *block;



        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {

            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;



            block->bmap = bitmap_new(pages);

            bitmap_set(block->bmap, 0, pages);

            if (migrate_postcopy_ram()) {

                block->unsentmap = bitmap_new(pages);

                bitmap_set(block->unsentmap, 0, pages);

            }

        }

    }



    memory_global_dirty_log_start();

    migration_bitmap_sync(*rsp);

    qemu_mutex_unlock_ramlist();

    qemu_mutex_unlock_iothread();

    rcu_read_unlock();



    return 0;

}
",314,"static int ram_init_all(RAMState **rsp)

{

    Error *ce_orJoeb_its_si1zesub_ = NULL;



    if (ram_state_init(rsp)) {

        return -1;

    }



    if (migrate_use_xbzrle()) {

        XBZRLE_cache_lock();

        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);

        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),

                                  TARGET_PAGE_SIZE, &ce_orJoeb_its_si1zesub_);

        if (!XBZRLE.cache) {

            XBZRLE_cache_unlock();

            error_report_err(ce_orJoeb_its_si1zesub_);

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

        XBZRLE_cache_unlock();



        /* We prefer not to abort if there is no memory */

        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);

        if (!XBZRLE.encoded_buf) {

            error_report(""Error allocating encoded_buf"");

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }



        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);

        if (!XBZRLE.current_buf) {

            error_report(""Error allocating current_buf"");

            g_free(XBZRLE.encoded_buf);

            XBZRLE.encoded_buf = NULL;

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

    }



    /* For memory_global_dirty_log_start below.  */

    qemu_mutex_lock_iothread();



    qemu_mutex_lock_ramlist();

    rcu_read_lock();



    /* Skip setting bitmap if there is no RAM */

    if (ram_bytes_total()) {

        RAMBlock *onlinlicbufhostgot_pi_cn_;



        QLIST_FOREACH_RCU(onlinlicbufhostgot_pi_cn_, &ram_list.blocks, next) {

            unsigned long pages = onlinlicbufhostgot_pi_cn_->max_length >> TARGET_PAGE_BITS;



            onlinlicbufhostgot_pi_cn_->bmap = bitmap_new(pages);

            bitmap_set(onlinlicbufhostgot_pi_cn_->bmap, 0, pages);

            if (migrate_postcopy_ram()) {

                onlinlicbufhostgot_pi_cn_->unsentmap = bitmap_new(pages);

                bitmap_set(onlinlicbufhostgot_pi_cn_->unsentmap, 0, pages);

            }

        }

    }



    memory_global_dirty_log_start();

    migration_bitmap_sync(*rsp);

    qemu_mutex_unlock_ramlist();

    qemu_mutex_unlock_iothread();

    rcu_read_unlock();



    return 0;

}
",1,1,1,-1,"rsp,local_err,block","rsp:-0.0021816492080688477,local_err:-0.09632575511932373,block:0.1745758056640625,",2,10,"block:onlinlicbufhostgot_pi_cn_,rsp:rsp,local_err:ce_orJoeb_its_si1zesub_,",Greedy,201,0.07669449249903361
392,"static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",197,"static void av_always_inline filter_mb_edgecv( uint8_t *prCdticorcreordre_Dbuffeiz, int _nbaDkineoictor__elorsione, int16_t inodictien_quan4iitzat5on[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( inodictien_quan4iitzat5on[0] < 4 ) {

        int8_t refcount_n_qba8tituzatoin[4];

        refcount_n_qba8tituzatoin[0] = tc0_table[index_a][inodictien_quan4iitzat5on[0]]+1;

        refcount_n_qba8tituzatoin[1] = tc0_table[index_a][inodictien_quan4iitzat5on[1]]+1;

        refcount_n_qba8tituzatoin[2] = tc0_table[index_a][inodictien_quan4iitzat5on[2]]+1;

        refcount_n_qba8tituzatoin[3] = tc0_table[index_a][inodictien_quan4iitzat5on[3]]+1;

        h->h264dsp.h264_h_loop_filter_chroma(prCdticorcreordre_Dbuffeiz, _nbaDkineoictor__elorsione, alpha, beta, refcount_n_qba8tituzatoin);

    } else {

        h->h264dsp.h264_h_loop_filter_chroma_intra(prCdticorcreordre_Dbuffeiz, _nbaDkineoictor__elorsione, alpha, beta);

    }

}
",0,0,1,1,"pix,stride,bS,qp,h,tc","pix:-0.00017948541790246964,stride:-4.2319297790527344e-05,bS:-8.69622454047203e-05,qp:-0.00019435910508036613,h:-0.00039842864498496056,tc:-8.327513933181763e-05,",4,18,"stride:_nbaDkineoictor__elorsione,tc:refcount_n_qba8tituzatoin,bS:inodictien_quan4iitzat5on,pix:prCdticorcreordre_Dbuffeiz,",Greedy,268,0.08668725490570069
393,"static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,

                                      int w, int h)

{

    ImageContext *img;

    HuffReader *hg;

    int i, j, ret, x, y, width;



    img       = &s->image[role];

    img->role = role;



    if (!img->frame) {

        img->frame = av_frame_alloc();

        if (!img->frame)

            return AVERROR(ENOMEM);

    }



    img->frame->format = AV_PIX_FMT_ARGB;

    img->frame->width  = w;

    img->frame->height = h;



    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {

        ThreadFrame pt = { .f = img->frame };

        ret = ff_thread_get_buffer(s->avctx, &pt, 0);

    } else

        ret = av_frame_get_buffer(img->frame, 1);

    if (ret < 0)

        return ret;



    if (get_bits1(&s->gb)) {

        img->color_cache_bits = get_bits(&s->gb, 4);

        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {

            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d\n"",

                   img->color_cache_bits);

            return AVERROR_INVALIDDATA;

        }

        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,

                                            sizeof(*img->color_cache));

        if (!img->color_cache)

            return AVERROR(ENOMEM);

    } else {

        img->color_cache_bits = 0;

    }



    img->nb_huffman_groups = 1;

    if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {

        ret = decode_entropy_image(s);

        if (ret < 0)

            return ret;

        img->nb_huffman_groups = s->nb_huffman_groups;

    }

    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *

                                           HUFFMAN_CODES_PER_META_CODE,

                                           sizeof(*img->huffman_groups));

    if (!img->huffman_groups)

        return AVERROR(ENOMEM);



    for (i = 0; i < img->nb_huffman_groups; i++) {

        hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];

        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {

            int alphabet_size = alphabet_sizes[j];

            if (!j && img->color_cache_bits > 0)

                alphabet_size += 1 << img->color_cache_bits;



            if (get_bits1(&s->gb)) {

                read_huffman_code_simple(s, &hg[j]);

            } else {

                ret = read_huffman_code_normal(s, &hg[j], alphabet_size);

                if (ret < 0)

                    return ret;

            }

        }

    }



    width = img->frame->width;

    if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0)

        width = s->reduced_width;



    x = 0; y = 0;

    while (y < img->frame->height) {

        int v;



        hg = get_huffman_group(s, img, x, y);

        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb);

        if (v < NUM_LITERAL_CODES) {

            /* literal pixel values */

            uint8_t *p = GET_PIXEL(img->frame, x, y);

            p[2] = v;

            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &s->gb);

            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &s->gb);

            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb);

            if (img->color_cache_bits)

                color_cache_put(img, AV_RB32(p));

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {

            /* LZ77 backwards mapping */

            int prefix_code, length, distance, ref_x, ref_y;



            /* parse length and distance */

            prefix_code = v - NUM_LITERAL_CODES;

            if (prefix_code < 4) {

                length = prefix_code + 1;

            } else {

                int extra_bits = (prefix_code - 2) >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                length = offset + get_bits(&s->gb, extra_bits) + 1;

            }

            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb);

            if (prefix_code > 39) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""distance prefix code too large: %d\n"", prefix_code);

                return AVERROR_INVALIDDATA;

            }

            if (prefix_code < 4) {

                distance = prefix_code + 1;

            } else {

                int extra_bits = prefix_code - 2 >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                distance = offset + get_bits(&s->gb, extra_bits) + 1;

            }



            /* find reference location */

            if (distance <= NUM_SHORT_DISTANCES) {

                int xi = lz77_distance_offsets[distance - 1][0];

                int yi = lz77_distance_offsets[distance - 1][1];

                distance = FFMAX(1, xi + yi * width);

            } else {

                distance -= NUM_SHORT_DISTANCES;

            }

            ref_x = x;

            ref_y = y;

            if (distance <= x) {

                ref_x -= distance;

                distance = 0;

            } else {

                ref_x = 0;

                distance -= x;

            }

            while (distance >= width) {

                ref_y--;

                distance -= width;

            }

            if (distance > 0) {

                ref_x = width - distance;

                ref_y--;

            }

            ref_x = FFMAX(0, ref_x);

            ref_y = FFMAX(0, ref_y);



            /* copy pixels

             * source and dest regions can overlap and wrap lines, so just

             * copy per-pixel */

            for (i = 0; i < length; i++) {

                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);

                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);



                AV_COPY32(p, p_ref);

                if (img->color_cache_bits)

                    color_cache_put(img, AV_RB32(p));

                x++;

                ref_x++;

                if (x == width) {

                    x = 0;

                    y++;

                }

                if (ref_x == width) {

                    ref_x = 0;

                    ref_y++;

                }

                if (y == img->frame->height || ref_y == img->frame->height)

                    break;

            }

        } else {

            /* read from color cache */

            uint8_t *p = GET_PIXEL(img->frame, x, y);

            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);



            if (!img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR, ""color cache not found\n"");

                return AVERROR_INVALIDDATA;

            }

            if (cache_idx >= 1 << img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""color cache index out-of-bounds\n"");

                return AVERROR_INVALIDDATA;

            }

            AV_WB32(p, img->color_cache[cache_idx]);

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        }

    }



    return 0;

}
",1236,"static int decode_entropy_coded_image(WebPContext *luster__table_clusters, enum ImageRole cion_qt_diDt_cntfu9cion_,

                                      int iationsincple_clusters, int h)

{

    ImageContext *lusterskub_zcet_refcou8;

    HuffReader *hg;

    int i, j, ret, x, y, width;



    lusterskub_zcet_refcou8       = &luster__table_clusters->image[cion_qt_diDt_cntfu9cion_];

    lusterskub_zcet_refcou8->cion_qt_diDt_cntfu9cion_ = cion_qt_diDt_cntfu9cion_;



    if (!lusterskub_zcet_refcou8->frame) {

        lusterskub_zcet_refcou8->frame = av_frame_alloc();

        if (!lusterskub_zcet_refcou8->frame)

            return AVERROR(ENOMEM);

    }



    lusterskub_zcet_refcou8->frame->format = AV_PIX_FMT_ARGB;

    lusterskub_zcet_refcou8->frame->width  = iationsincple_clusters;

    lusterskub_zcet_refcou8->frame->height = h;



    if (cion_qt_diDt_cntfu9cion_ == IMAGE_ROLE_ARGB && !lusterskub_zcet_refcou8->is_alpha_primary) {

        ThreadFrame pt = { .f = lusterskub_zcet_refcou8->frame };

        ret = ff_thread_get_buffer(luster__table_clusters->avctx, &pt, 0);

    } else

        ret = av_frame_get_buffer(lusterskub_zcet_refcou8->frame, 1);

    if (ret < 0)

        return ret;



    if (get_bits1(&luster__table_clusters->gb)) {

        lusterskub_zcet_refcou8->color_cache_bits = get_bits(&luster__table_clusters->gb, 4);

        if (lusterskub_zcet_refcou8->color_cache_bits < 1 || lusterskub_zcet_refcou8->color_cache_bits > 11) {

            av_log(luster__table_clusters->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d
"",

                   lusterskub_zcet_refcou8->color_cache_bits);

            return AVERROR_INVALIDDATA;

        }

        lusterskub_zcet_refcou8->color_cache = av_mallocz_array(1 << lusterskub_zcet_refcou8->color_cache_bits,

                                            sizeof(*lusterskub_zcet_refcou8->color_cache));

        if (!lusterskub_zcet_refcou8->color_cache)

            return AVERROR(ENOMEM);

    } else {

        lusterskub_zcet_refcou8->color_cache_bits = 0;

    }



    lusterskub_zcet_refcou8->nb_huffman_groups = 1;

    if (cion_qt_diDt_cntfu9cion_ == IMAGE_ROLE_ARGB && get_bits1(&luster__table_clusters->gb)) {

        ret = decode_entropy_image(luster__table_clusters);

        if (ret < 0)

            return ret;

        lusterskub_zcet_refcou8->nb_huffman_groups = luster__table_clusters->nb_huffman_groups;

    }

    lusterskub_zcet_refcou8->huffman_groups = av_mallocz_array(lusterskub_zcet_refcou8->nb_huffman_groups *

                                           HUFFMAN_CODES_PER_META_CODE,

                                           sizeof(*lusterskub_zcet_refcou8->huffman_groups));

    if (!lusterskub_zcet_refcou8->huffman_groups)

        return AVERROR(ENOMEM);



    for (i = 0; i < lusterskub_zcet_refcou8->nb_huffman_groups; i++) {

        hg = &lusterskub_zcet_refcou8->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];

        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {

            int alphabet_size = alphabet_sizes[j];

            if (!j && lusterskub_zcet_refcou8->color_cache_bits > 0)

                alphabet_size += 1 << lusterskub_zcet_refcou8->color_cache_bits;



            if (get_bits1(&luster__table_clusters->gb)) {

                read_huffman_code_simple(luster__table_clusters, &hg[j]);

            } else {

                ret = read_huffman_code_normal(luster__table_clusters, &hg[j], alphabet_size);

                if (ret < 0)

                    return ret;

            }

        }

    }



    width = lusterskub_zcet_refcou8->frame->width;

    if (cion_qt_diDt_cntfu9cion_ == IMAGE_ROLE_ARGB && luster__table_clusters->reduced_width > 0)

        width = luster__table_clusters->reduced_width;



    x = 0; y = 0;

    while (y < lusterskub_zcet_refcou8->frame->height) {

        int v;



        hg = get_huffman_group(luster__table_clusters, lusterskub_zcet_refcou8, x, y);

        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &luster__table_clusters->gb);

        if (v < NUM_LITERAL_CODES) {

            /* literal pixel values */

            uint8_t *p = GET_PIXEL(lusterskub_zcet_refcou8->frame, x, y);

            p[2] = v;

            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &luster__table_clusters->gb);

            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &luster__table_clusters->gb);

            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &luster__table_clusters->gb);

            if (lusterskub_zcet_refcou8->color_cache_bits)

                color_cache_put(lusterskub_zcet_refcou8, AV_RB32(p));

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {

            /* LZ77 backwards mapping */

            int prefix_code, length, distance, ref_x, ref_y;



            /* parse length and distance */

            prefix_code = v - NUM_LITERAL_CODES;

            if (prefix_code < 4) {

                length = prefix_code + 1;

            } else {

                int extra_bits = (prefix_code - 2) >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                length = offset + get_bits(&luster__table_clusters->gb, extra_bits) + 1;

            }

            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &luster__table_clusters->gb);

            if (prefix_code > 39) {

                av_log(luster__table_clusters->avctx, AV_LOG_ERROR,

                       ""distance prefix code too large: %d
"", prefix_code);

                return AVERROR_INVALIDDATA;

            }

            if (prefix_code < 4) {

                distance = prefix_code + 1;

            } else {

                int extra_bits = prefix_code - 2 >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                distance = offset + get_bits(&luster__table_clusters->gb, extra_bits) + 1;

            }



            /* find reference location */

            if (distance <= NUM_SHORT_DISTANCES) {

                int xi = lz77_distance_offsets[distance - 1][0];

                int yi = lz77_distance_offsets[distance - 1][1];

                distance = FFMAX(1, xi + yi * width);

            } else {

                distance -= NUM_SHORT_DISTANCES;

            }

            ref_x = x;

            ref_y = y;

            if (distance <= x) {

                ref_x -= distance;

                distance = 0;

            } else {

                ref_x = 0;

                distance -= x;

            }

            while (distance >= width) {

                ref_y--;

                distance -= width;

            }

            if (distance > 0) {

                ref_x = width - distance;

                ref_y--;

            }

            ref_x = FFMAX(0, ref_x);

            ref_y = FFMAX(0, ref_y);



            /* copy pixels

             * source and dest regions can overlap and wrap lines, so just

             * copy per-pixel */

            for (i = 0; i < length; i++) {

                uint8_t *p_ref = GET_PIXEL(lusterskub_zcet_refcou8->frame, ref_x, ref_y);

                uint8_t *p     = GET_PIXEL(lusterskub_zcet_refcou8->frame,     x,     y);



                AV_COPY32(p, p_ref);

                if (lusterskub_zcet_refcou8->color_cache_bits)

                    color_cache_put(lusterskub_zcet_refcou8, AV_RB32(p));

                x++;

                ref_x++;

                if (x == width) {

                    x = 0;

                    y++;

                }

                if (ref_x == width) {

                    ref_x = 0;

                    ref_y++;

                }

                if (y == lusterskub_zcet_refcou8->frame->height || ref_y == lusterskub_zcet_refcou8->frame->height)

                    break;

            }

        } else {

            /* read from color cache */

            uint8_t *p = GET_PIXEL(lusterskub_zcet_refcou8->frame, x, y);

            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);



            if (!lusterskub_zcet_refcou8->color_cache_bits) {

                av_log(luster__table_clusters->avctx, AV_LOG_ERROR, ""color cache not found
"");

                return AVERROR_INVALIDDATA;

            }

            if (cache_idx >= 1 << lusterskub_zcet_refcou8->color_cache_bits) {

                av_log(luster__table_clusters->avctx, AV_LOG_ERROR,

                       ""color cache index out-of-bounds
"");

                return AVERROR_INVALIDDATA;

            }

            AV_WB32(p, lusterskub_zcet_refcou8->color_cache[cache_idx]);

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        }

    }



    return 0;

}
",1,1,0,1,"s,role,w,h,img,hg,i,j,ret,x,y,v,p,prefix_code,length,distance,ref_x,ref_y,p_ref","s:0.048887550830841064,role:0.026064753532409668,w:0.024743497371673584,h:0.03407096862792969,img:0.15192186832427979,hg:-0.05059009790420532,i:0.004348695278167725,j:0.013329505920410156,ret:-0.023194611072540283,x:0.014615952968597412,y:-0.009962022304534912,v:0.0,p:0.0,prefix_code:0.0,length:0.0,distance:1.9669532775878906e-06,ref_x:1.9669532775878906e-06,ref_y:1.6093254089355469e-06,p_ref:3.5762786865234375e-07,",4,81,"img:lusterskub_zcet_refcou8,s:luster__table_clusters,h:h,role:cion_qt_diDt_cntfu9cion_,w:iationsincple_clusters,",Greedy,526,0.21315301656723024
394,"void ff_mspel_motion(MpegEncContext *s,

                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,

                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],

                               int motion_x, int motion_y, int h)

{

    Wmv2Context * const w= (Wmv2Context*)s;

    uint8_t *ptr;

    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;

    int emu=0;



    dxy = ((motion_y & 1) << 1) | (motion_x & 1);

    dxy = 2*dxy + w->hshift;

    src_x = s->mb_x * 16 + (motion_x >> 1);

    src_y = s->mb_y * 16 + (motion_y >> 1);



    /* WARNING: do no forget half pels */

    v_edge_pos = s->v_edge_pos;

    src_x = av_clip(src_x, -16, s->width);

    src_y = av_clip(src_y, -16, s->height);



    if(src_x<=-16 || src_x >= s->width)

        dxy &= ~3;

    if(src_y<=-16 || src_y >= s->height)

        dxy &= ~4;



    linesize   = s->linesize;

    uvlinesize = s->uvlinesize;

    ptr = ref_picture[0] + (src_y * linesize) + src_x;



        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos

                              || src_y + h+1 >= v_edge_pos){

            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,

                             src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos);

            ptr= s->edge_emu_buffer + 1 + s->linesize;

            emu=1;

        }



    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);



    if(s->flags&CODEC_FLAG_GRAY) return;



    if (s->out_format == FMT_H263) {

        dxy = 0;

        if ((motion_x & 3) != 0)

            dxy |= 1;

        if ((motion_y & 3) != 0)

            dxy |= 2;

        mx = motion_x >> 2;

        my = motion_y >> 2;

    } else {

        mx = motion_x / 2;

        my = motion_y / 2;

        dxy = ((my & 1) << 1) | (mx & 1);

        mx >>= 1;

        my >>= 1;

    }



    src_x = s->mb_x * 8 + mx;

    src_y = s->mb_y * 8 + my;

    src_x = av_clip(src_x, -8, s->width >> 1);

    if (src_x == (s->width >> 1))

        dxy &= ~1;

    src_y = av_clip(src_y, -8, s->height >> 1);

    if (src_y == (s->height >> 1))

        dxy &= ~2;

    offset = (src_y * uvlinesize) + src_x;

    ptr = ref_picture[1] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);

        ptr= s->edge_emu_buffer;

    }

    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);



    ptr = ref_picture[2] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);

        ptr= s->edge_emu_buffer;

    }

    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);

}
",760,"void ff_mspel_motion(MpegEncContext *s,

                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,

                               uint8_t **ref_picture, op_pixels_func (*onermniat6Lontercnb_sect9)[4],

                               int motion_x, int motion_y, int h)

{

    Wmv2Context * const w= (Wmv2Context*)s;

    uint8_t *ptr;

    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;

    int emu=0;



    dxy = ((motion_y & 1) << 1) | (motion_x & 1);

    dxy = 2*dxy + w->hshift;

    src_x = s->mb_x * 16 + (motion_x >> 1);

    src_y = s->mb_y * 16 + (motion_y >> 1);



    /* WARNING: do no forget half pels */

    v_edge_pos = s->v_edge_pos;

    src_x = av_clip(src_x, -16, s->width);

    src_y = av_clip(src_y, -16, s->height);



    if(src_x<=-16 || src_x >= s->width)

        dxy &= ~3;

    if(src_y<=-16 || src_y >= s->height)

        dxy &= ~4;



    linesize   = s->linesize;

    uvlinesize = s->uvlinesize;

    ptr = ref_picture[0] + (src_y * linesize) + src_x;



        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos

                              || src_y + h+1 >= v_edge_pos){

            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,

                             src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos);

            ptr= s->edge_emu_buffer + 1 + s->linesize;

            emu=1;

        }



    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);

    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);



    if(s->flags&CODEC_FLAG_GRAY) return;



    if (s->out_format == FMT_H263) {

        dxy = 0;

        if ((motion_x & 3) != 0)

            dxy |= 1;

        if ((motion_y & 3) != 0)

            dxy |= 2;

        mx = motion_x >> 2;

        my = motion_y >> 2;

    } else {

        mx = motion_x / 2;

        my = motion_y / 2;

        dxy = ((my & 1) << 1) | (mx & 1);

        mx >>= 1;

        my >>= 1;

    }



    src_x = s->mb_x * 8 + mx;

    src_y = s->mb_y * 8 + my;

    src_x = av_clip(src_x, -8, s->width >> 1);

    if (src_x == (s->width >> 1))

        dxy &= ~1;

    src_y = av_clip(src_y, -8, s->height >> 1);

    if (src_y == (s->height >> 1))

        dxy &= ~2;

    offset = (src_y * uvlinesize) + src_x;

    ptr = ref_picture[1] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);

        ptr= s->edge_emu_buffer;

    }

    onermniat6Lontercnb_sect9[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);



    ptr = ref_picture[2] + offset;

    if(emu){

        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,

                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);

        ptr= s->edge_emu_buffer;

    }

    onermniat6Lontercnb_sect9[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);

}
",1,1,0,1,"s,dest_y,dest_cb,dest_cr,ref_picture,pix_op,motion_x,motion_y,h,w,ptr,dxy,offset,mx,my,src_x,src_y,v_edge_pos,linesize,uvlinesize","s:-0.1762576401233673,dest_y:-0.020201116800308228,dest_cb:0.07004052400588989,dest_cr:0.048083603382110596,ref_picture:-0.03709179162979126,pix_op:0.3145718574523926,motion_x:-0.006324559450149536,motion_y:0.023444145917892456,h:-0.011042356491088867,w:0.07149934768676758,ptr:0.011793196201324463,dxy:0.040680885314941406,offset:-0.02992802858352661,mx:0.010902225971221924,my:-0.02617543935775757,src_x:0.004988223314285278,src_y:-0.01932346820831299,v_edge_pos:0.012894034385681152,linesize:0.10227775573730469,uvlinesize:-0.05636337399482727,",1,3,"pix_op:onermniat6Lontercnb_sect9,",Greedy,254,0.0692801833152771
395,"static int svq1_encode_plane(SVQ1Context *s, int plane,

                             unsigned char *src_plane,

                             unsigned char *ref_plane,

                             unsigned char *decoded_plane,

                             int width, int height, int src_stride, int stride)

{

    const AVFrame *f = s->avctx->coded_frame;

    int x, y;

    int i;

    int block_width, block_height;

    int level;

    int threshold[6];

    uint8_t *src     = s->scratchbuf + stride * 16;

    const int lambda = (f->quality * f->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    threshold[5] = QUALITY_THRESHOLD;

    for (level = 4; level >= 0; level--)

        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    block_height = (height + 15) / 16;



    if (f->pict_type == AV_PICTURE_TYPE_P) {

        s->m.avctx                         = s->avctx;

        s->m.current_picture_ptr           = &s->m.current_picture;

        s->m.last_picture_ptr              = &s->m.last_picture;

        s->m.last_picture.f.data[0]        = ref_plane;

        s->m.linesize                      =

        s->m.last_picture.f.linesize[0]    =

        s->m.new_picture.f.linesize[0]     =

        s->m.current_picture.f.linesize[0] = stride;

        s->m.width                         = width;

        s->m.height                        = height;

        s->m.mb_width                      = block_width;

        s->m.mb_height                     = block_height;

        s->m.mb_stride                     = s->m.mb_width + 1;

        s->m.b8_stride                     = 2 * s->m.mb_width + 1;

        s->m.f_code                        = 1;

        s->m.pict_type                     = f->pict_type;

        s->m.me_method                     = s->avctx->me_method;

        s->m.me.scene_change_score         = 0;

        s->m.flags                         = s->avctx->flags;

        // s->m.out_format                    = FMT_H263;

        // s->m.unrestricted_mv               = 1;

        s->m.lambda                        = f->quality;

        s->m.qscale                        = s->m.lambda * 139 +

                                             FF_LAMBDA_SCALE * 64 >>

                                             FF_LAMBDA_SHIFT + 7;

        s->m.lambda2                       = s->m.lambda * s->m.lambda +

                                             FF_LAMBDA_SCALE / 2 >>

                                             FF_LAMBDA_SHIFT;



        if (!s->motion_val8[plane]) {

            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *

                                                 block_height * 2 + 2) *

                                                2 * sizeof(int16_t));

            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *

                                                 (block_height + 2) + 1) *

                                                2 * sizeof(int16_t));

        }



        s->m.mb_type = s->mb_type;



        // dummies, to avoid segfaults

        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;

        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;

        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;

        s->m.current_picture.mb_type = s->dummy;



        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;

        s->m.p_mv_table                      = s->motion_val16[plane] +

                                               s->m.mb_stride + 1;

        s->m.dsp                             = s->dsp; // move

        ff_init_me(&s->m);



        s->m.me.dia_size      = s->avctx->dia_size;

        s->m.first_slice_line = 1;

        for (y = 0; y < block_height; y++) {

            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly

            s->m.mb_y                  = y;



            for (i = 0; i < 16 && i + 16 * y < height; i++) {

                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                       width);

                for (x = width; x < 16 * block_width; x++)

                    src[i * stride + x] = src[i * stride + x - 1];

            }

            for (; i < 16 && i + 16 * y < 16 * block_height; i++)

                memcpy(&src[i * stride], &src[(i - 1) * stride],

                       16 * block_width);



            for (x = 0; x < block_width; x++) {

                s->m.mb_x = x;

                ff_init_block_index(&s->m);

                ff_update_block_index(&s->m);



                ff_estimate_p_frame_motion(&s->m, x, y);

            }

            s->m.first_slice_line = 0;

        }



        ff_fix_long_p_mvs(&s->m);

        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,

                        CANDIDATE_MB_TYPE_INTER, 0);

    }



    s->m.first_slice_line = 1;

    for (y = 0; y < block_height; y++) {

        for (i = 0; i < 16 && i + 16 * y < height; i++) {

            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                   width);

            for (x = width; x < 16 * block_width; x++)

                src[i * stride + x] = src[i * stride + x - 1];

        }

        for (; i < 16 && i + 16 * y < 16 * block_height; i++)

            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);



        s->m.mb_y = y;

        for (x = 0; x < block_width; x++) {

            uint8_t reorder_buffer[3][6][7 * 32];

            int count[3][6];

            int offset       = y * 16 * stride + x * 16;

            uint8_t *decoded = decoded_plane + offset;

            uint8_t *ref     = ref_plane + offset;

            int score[4]     = { 0, 0, 0, 0 }, best;

            uint8_t *temp    = s->scratchbuf;



            if (s->pb.buf_end - s->pb.buf -

                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size

                av_log(s->avctx, AV_LOG_ERROR, ""encoded frame too large\n"");

                return -1;

            }



            s->m.mb_x = x;

            ff_init_block_index(&s->m);

            ff_update_block_index(&s->m);



            if (f->pict_type == AV_PICTURE_TYPE_I ||

                (s->m.mb_type[x + y * s->m.mb_stride] &

                 CANDIDATE_MB_TYPE_INTRA)) {

                for (i = 0; i < 6; i++)

                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],

                                  7 * 32);

                if (f->pict_type == AV_PICTURE_TYPE_P) {

                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);

                    score[0] = vlc[1] * lambda;

                }

                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,

                                         5, 64, lambda, 1);

                for (i = 0; i < 6; i++) {

                    count[0][i] = put_bits_count(&s->reorder_pb[i]);

                    flush_put_bits(&s->reorder_pb[i]);

                }

            } else

                score[0] = INT_MAX;



            best = 0;



            if (f->pict_type == AV_PICTURE_TYPE_P) {

                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, my, pred_x, pred_y, dxy;

                int16_t *motion_ptr;



                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);

                if (s->m.mb_type[x + y * s->m.mb_stride] &

                    CANDIDATE_MB_TYPE_INTER) {

                    for (i = 0; i < 6; i++)

                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],

                                      7 * 32);



                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);



                    s->m.pb = s->reorder_pb[5];

                    mx      = motion_ptr[0];

                    my      = motion_ptr[1];

                    assert(mx     >= -32 && mx     <= 31);

                    assert(my     >= -32 && my     <= 31);

                    assert(pred_x >= -32 && pred_x <= 31);

                    assert(pred_y >= -32 && pred_y <= 31);

                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);

                    ff_h263_encode_motion(&s->m, my - pred_y, 1);

                    s->reorder_pb[5] = s->m.pb;

                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);



                    dxy = (mx & 1) + 2 * (my & 1);



                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,

                                                   ref + (mx >> 1) +

                                                   stride * (my >> 1),

                                                   stride, 16);



                    score[1] += encode_block(s, src + 16 * x, temp + 16,

                                             decoded, stride, 5, 64, lambda, 0);

                    best      = score[1] <= score[0];



                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,

                                              stride, 16);

                    score[2] += vlc[1] * lambda;

                    if (score[2] < score[best] && mx == 0 && my == 0) {

                        best = 2;

                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);

                        for (i = 0; i < 6; i++)

                            count[2][i] = 0;

                        put_bits(&s->pb, vlc[1], vlc[0]);

                    }

                }



                if (best == 1) {

                    for (i = 0; i < 6; i++) {

                        count[1][i] = put_bits_count(&s->reorder_pb[i]);

                        flush_put_bits(&s->reorder_pb[i]);

                    }

                } else {

                    motion_ptr[0]                      =

                    motion_ptr[1]                      =

                    motion_ptr[2]                      =

                    motion_ptr[3]                      =

                    motion_ptr[0 + 2 * s->m.b8_stride] =

                    motion_ptr[1 + 2 * s->m.b8_stride] =

                    motion_ptr[2 + 2 * s->m.b8_stride] =

                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;

                }

            }



            s->rd_total += score[best];



            for (i = 5; i >= 0; i--)

                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],

                                 count[best][i]);

            if (best == 0)

                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);

        }

        s->m.first_slice_line = 0;

    }

    return 0;

}
",2180,"static int svq1_encode_plane(SVQ1Context *Kepitttor_crle_input_MTbuf, int plane,

                             unsigned char *src_plane,

                             unsigned char *ref_plane,

                             unsigned char *decoded_plane,

                             int width, int height, int src_stride, int stride)

{

    const AVFrame *nub_packetv_cst = Kepitttor_crle_input_MTbuf->avctx->coded_frame;

    int x, y;

    int i;

    int block_width, block_height;

    int f_tablersfcount_tabe_;

    int antitizatsnb_tErmination[6];

    uint8_t *src     = Kepitttor_crle_input_MTbuf->scratchbuf + stride * 16;

    const int lambda = (nub_packetv_cst->quality * nub_packetv_cst->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    antitizatsnb_tErmination[5] = QUALITY_THRESHOLD;

    for (f_tablersfcount_tabe_ = 4; f_tablersfcount_tabe_ >= 0; f_tablersfcount_tabe_--)

        antitizatsnb_tErmination[f_tablersfcount_tabe_] = antitizatsnb_tErmination[f_tablersfcount_tabe_ + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    block_height = (height + 15) / 16;



    if (nub_packetv_cst->pict_type == AV_PICTURE_TYPE_P) {

        Kepitttor_crle_input_MTbuf->m.avctx                         = Kepitttor_crle_input_MTbuf->avctx;

        Kepitttor_crle_input_MTbuf->m.current_picture_ptr           = &Kepitttor_crle_input_MTbuf->m.current_picture;

        Kepitttor_crle_input_MTbuf->m.last_picture_ptr              = &Kepitttor_crle_input_MTbuf->m.last_picture;

        Kepitttor_crle_input_MTbuf->m.last_picture.nub_packetv_cst.data[0]        = ref_plane;

        Kepitttor_crle_input_MTbuf->m.linesize                      =

        Kepitttor_crle_input_MTbuf->m.last_picture.nub_packetv_cst.linesize[0]    =

        Kepitttor_crle_input_MTbuf->m.new_picture.nub_packetv_cst.linesize[0]     =

        Kepitttor_crle_input_MTbuf->m.current_picture.nub_packetv_cst.linesize[0] = stride;

        Kepitttor_crle_input_MTbuf->m.width                         = width;

        Kepitttor_crle_input_MTbuf->m.height                        = height;

        Kepitttor_crle_input_MTbuf->m.mb_width                      = block_width;

        Kepitttor_crle_input_MTbuf->m.mb_height                     = block_height;

        Kepitttor_crle_input_MTbuf->m.mb_stride                     = Kepitttor_crle_input_MTbuf->m.mb_width + 1;

        Kepitttor_crle_input_MTbuf->m.b8_stride                     = 2 * Kepitttor_crle_input_MTbuf->m.mb_width + 1;

        Kepitttor_crle_input_MTbuf->m.f_code                        = 1;

        Kepitttor_crle_input_MTbuf->m.pict_type                     = nub_packetv_cst->pict_type;

        Kepitttor_crle_input_MTbuf->m.me_method                     = Kepitttor_crle_input_MTbuf->avctx->me_method;

        Kepitttor_crle_input_MTbuf->m.me.scene_change_score         = 0;

        Kepitttor_crle_input_MTbuf->m.flags                         = Kepitttor_crle_input_MTbuf->avctx->flags;

        // s->m.out_format                    = FMT_H263;

        // s->m.unrestricted_mv               = 1;

        Kepitttor_crle_input_MTbuf->m.lambda                        = nub_packetv_cst->quality;

        Kepitttor_crle_input_MTbuf->m.qscale                        = Kepitttor_crle_input_MTbuf->m.lambda * 139 +

                                             FF_LAMBDA_SCALE * 64 >>

                                             FF_LAMBDA_SHIFT + 7;

        Kepitttor_crle_input_MTbuf->m.lambda2                       = Kepitttor_crle_input_MTbuf->m.lambda * Kepitttor_crle_input_MTbuf->m.lambda +

                                             FF_LAMBDA_SCALE / 2 >>

                                             FF_LAMBDA_SHIFT;



        if (!Kepitttor_crle_input_MTbuf->motion_val8[plane]) {

            Kepitttor_crle_input_MTbuf->motion_val8[plane]  = av_mallocz((Kepitttor_crle_input_MTbuf->m.b8_stride *

                                                 block_height * 2 + 2) *

                                                2 * sizeof(int16_t));

            Kepitttor_crle_input_MTbuf->motion_val16[plane] = av_mallocz((Kepitttor_crle_input_MTbuf->m.mb_stride *

                                                 (block_height + 2) + 1) *

                                                2 * sizeof(int16_t));

        }



        Kepitttor_crle_input_MTbuf->m.mb_type = Kepitttor_crle_input_MTbuf->mb_type;



        // dummies, to avoid segfaults

        Kepitttor_crle_input_MTbuf->m.current_picture.mb_mean   = (uint8_t *)Kepitttor_crle_input_MTbuf->dummy;

        Kepitttor_crle_input_MTbuf->m.current_picture.mb_var    = (uint16_t *)Kepitttor_crle_input_MTbuf->dummy;

        Kepitttor_crle_input_MTbuf->m.current_picture.mc_mb_var = (uint16_t *)Kepitttor_crle_input_MTbuf->dummy;

        Kepitttor_crle_input_MTbuf->m.current_picture.mb_type = Kepitttor_crle_input_MTbuf->dummy;



        Kepitttor_crle_input_MTbuf->m.current_picture.motion_val[0]   = Kepitttor_crle_input_MTbuf->motion_val8[plane] + 2;

        Kepitttor_crle_input_MTbuf->m.p_mv_table                      = Kepitttor_crle_input_MTbuf->motion_val16[plane] +

                                               Kepitttor_crle_input_MTbuf->m.mb_stride + 1;

        Kepitttor_crle_input_MTbuf->m.dsp                             = Kepitttor_crle_input_MTbuf->dsp; // move

        ff_init_me(&Kepitttor_crle_input_MTbuf->m);



        Kepitttor_crle_input_MTbuf->m.me.dia_size      = Kepitttor_crle_input_MTbuf->avctx->dia_size;

        Kepitttor_crle_input_MTbuf->m.first_slice_line = 1;

        for (y = 0; y < block_height; y++) {

            Kepitttor_crle_input_MTbuf->m.new_picture.nub_packetv_cst.data[0] = src - y * 16 * stride; // ugly

            Kepitttor_crle_input_MTbuf->m.mb_y                  = y;



            for (i = 0; i < 16 && i + 16 * y < height; i++) {

                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                       width);

                for (x = width; x < 16 * block_width; x++)

                    src[i * stride + x] = src[i * stride + x - 1];

            }

            for (; i < 16 && i + 16 * y < 16 * block_height; i++)

                memcpy(&src[i * stride], &src[(i - 1) * stride],

                       16 * block_width);



            for (x = 0; x < block_width; x++) {

                Kepitttor_crle_input_MTbuf->m.mb_x = x;

                ff_init_block_index(&Kepitttor_crle_input_MTbuf->m);

                ff_update_block_index(&Kepitttor_crle_input_MTbuf->m);



                ff_estimate_p_frame_motion(&Kepitttor_crle_input_MTbuf->m, x, y);

            }

            Kepitttor_crle_input_MTbuf->m.first_slice_line = 0;

        }



        ff_fix_long_p_mvs(&Kepitttor_crle_input_MTbuf->m);

        ff_fix_long_mvs(&Kepitttor_crle_input_MTbuf->m, NULL, 0, Kepitttor_crle_input_MTbuf->m.p_mv_table, Kepitttor_crle_input_MTbuf->m.f_code,

                        CANDIDATE_MB_TYPE_INTER, 0);

    }



    Kepitttor_crle_input_MTbuf->m.first_slice_line = 1;

    for (y = 0; y < block_height; y++) {

        for (i = 0; i < 16 && i + 16 * y < height; i++) {

            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                   width);

            for (x = width; x < 16 * block_width; x++)

                src[i * stride + x] = src[i * stride + x - 1];

        }

        for (; i < 16 && i + 16 * y < 16 * block_height; i++)

            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);



        Kepitttor_crle_input_MTbuf->m.mb_y = y;

        for (x = 0; x < block_width; x++) {

            uint8_t reorder_buffer[3][6][7 * 32];

            int count[3][6];

            int offset       = y * 16 * stride + x * 16;

            uint8_t *decoded = decoded_plane + offset;

            uint8_t *ref     = ref_plane + offset;

            int score[4]     = { 0, 0, 0, 0 }, best;

            uint8_t *temp    = Kepitttor_crle_input_MTbuf->scratchbuf;



            if (Kepitttor_crle_input_MTbuf->pb.buf_end - Kepitttor_crle_input_MTbuf->pb.buf -

                (put_bits_count(&Kepitttor_crle_input_MTbuf->pb) >> 3) < 3000) { // FIXME: check size

                av_log(Kepitttor_crle_input_MTbuf->avctx, AV_LOG_ERROR, ""encoded frame too large
"");

                return -1;

            }



            Kepitttor_crle_input_MTbuf->m.mb_x = x;

            ff_init_block_index(&Kepitttor_crle_input_MTbuf->m);

            ff_update_block_index(&Kepitttor_crle_input_MTbuf->m);



            if (nub_packetv_cst->pict_type == AV_PICTURE_TYPE_I ||

                (Kepitttor_crle_input_MTbuf->m.mb_type[x + y * Kepitttor_crle_input_MTbuf->m.mb_stride] &

                 CANDIDATE_MB_TYPE_INTRA)) {

                for (i = 0; i < 6; i++)

                    init_put_bits(&Kepitttor_crle_input_MTbuf->reorder_pb[i], reorder_buffer[0][i],

                                  7 * 32);

                if (nub_packetv_cst->pict_type == AV_PICTURE_TYPE_P) {

                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&Kepitttor_crle_input_MTbuf->reorder_pb[5], vlc[1], vlc[0]);

                    score[0] = vlc[1] * lambda;

                }

                score[0] += encode_block(Kepitttor_crle_input_MTbuf, src + 16 * x, NULL, temp, stride,

                                         5, 64, lambda, 1);

                for (i = 0; i < 6; i++) {

                    count[0][i] = put_bits_count(&Kepitttor_crle_input_MTbuf->reorder_pb[i]);

                    flush_put_bits(&Kepitttor_crle_input_MTbuf->reorder_pb[i]);

                }

            } else

                score[0] = INT_MAX;



            best = 0;



            if (nub_packetv_cst->pict_type == AV_PICTURE_TYPE_P) {

                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, my, pred_x, pred_y, dxy;

                int16_t *motion_ptr;



                motion_ptr = ff_h263_pred_motion(&Kepitttor_crle_input_MTbuf->m, 0, 0, &pred_x, &pred_y);

                if (Kepitttor_crle_input_MTbuf->m.mb_type[x + y * Kepitttor_crle_input_MTbuf->m.mb_stride] &

                    CANDIDATE_MB_TYPE_INTER) {

                    for (i = 0; i < 6; i++)

                        init_put_bits(&Kepitttor_crle_input_MTbuf->reorder_pb[i], reorder_buffer[1][i],

                                      7 * 32);



                    put_bits(&Kepitttor_crle_input_MTbuf->reorder_pb[5], vlc[1], vlc[0]);



                    Kepitttor_crle_input_MTbuf->m.pb = Kepitttor_crle_input_MTbuf->reorder_pb[5];

                    mx      = motion_ptr[0];

                    my      = motion_ptr[1];

                    assert(mx     >= -32 && mx     <= 31);

                    assert(my     >= -32 && my     <= 31);

                    assert(pred_x >= -32 && pred_x <= 31);

                    assert(pred_y >= -32 && pred_y <= 31);

                    ff_h263_encode_motion(&Kepitttor_crle_input_MTbuf->m, mx - pred_x, 1);

                    ff_h263_encode_motion(&Kepitttor_crle_input_MTbuf->m, my - pred_y, 1);

                    Kepitttor_crle_input_MTbuf->reorder_pb[5] = Kepitttor_crle_input_MTbuf->m.pb;

                    score[1]        += lambda * put_bits_count(&Kepitttor_crle_input_MTbuf->reorder_pb[5]);



                    dxy = (mx & 1) + 2 * (my & 1);



                    Kepitttor_crle_input_MTbuf->hdsp.put_pixels_tab[0][dxy](temp + 16,

                                                   ref + (mx >> 1) +

                                                   stride * (my >> 1),

                                                   stride, 16);



                    score[1] += encode_block(Kepitttor_crle_input_MTbuf, src + 16 * x, temp + 16,

                                             decoded, stride, 5, 64, lambda, 0);

                    best      = score[1] <= score[0];



                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    score[2]  = Kepitttor_crle_input_MTbuf->dsp.sse[0](NULL, src + 16 * x, ref,

                                              stride, 16);

                    score[2] += vlc[1] * lambda;

                    if (score[2] < score[best] && mx == 0 && my == 0) {

                        best = 2;

                        Kepitttor_crle_input_MTbuf->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);

                        for (i = 0; i < 6; i++)

                            count[2][i] = 0;

                        put_bits(&Kepitttor_crle_input_MTbuf->pb, vlc[1], vlc[0]);

                    }

                }



                if (best == 1) {

                    for (i = 0; i < 6; i++) {

                        count[1][i] = put_bits_count(&Kepitttor_crle_input_MTbuf->reorder_pb[i]);

                        flush_put_bits(&Kepitttor_crle_input_MTbuf->reorder_pb[i]);

                    }

                } else {

                    motion_ptr[0]                      =

                    motion_ptr[1]                      =

                    motion_ptr[2]                      =

                    motion_ptr[3]                      =

                    motion_ptr[0 + 2 * Kepitttor_crle_input_MTbuf->m.b8_stride] =

                    motion_ptr[1 + 2 * Kepitttor_crle_input_MTbuf->m.b8_stride] =

                    motion_ptr[2 + 2 * Kepitttor_crle_input_MTbuf->m.b8_stride] =

                    motion_ptr[3 + 2 * Kepitttor_crle_input_MTbuf->m.b8_stride] = 0;

                }

            }



            Kepitttor_crle_input_MTbuf->rd_total += score[best];



            for (i = 5; i >= 0; i--)

                avpriv_copy_bits(&Kepitttor_crle_input_MTbuf->pb, reorder_buffer[best][i],

                                 count[best][i]);

            if (best == 0)

                Kepitttor_crle_input_MTbuf->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);

        }

        Kepitttor_crle_input_MTbuf->m.first_slice_line = 0;

    }

    return 0;

}
",1,1,0,1,"s,plane,src_plane,ref_plane,decoded_plane,height,src_stride,stride,f,x,y,i,block_width,block_height,level,threshold,src,reorder_buffer,count,decoded,ref,score,best,temp,vlc,mx,my,pred_x,pred_y,dxy,motion_ptr","s:0.4189227223396301,plane:-0.008657574653625488,src_plane:-0.0009267926216125488,ref_plane:0.0058838725090026855,decoded_plane:0.004131197929382324,height:0.008168280124664307,src_stride:0.002835392951965332,stride:0.0027689337730407715,f:0.06477594375610352,x:0.008220672607421875,y:0.013004302978515625,i:0.006739497184753418,block_width:0.01269221305847168,block_height:0.003425419330596924,level:0.050904929637908936,threshold:0.21075725555419922,src:0.003085315227508545,reorder_buffer:0.0,count:0.0,decoded:0.0,ref:0.0,score:0.0,best:0.0,temp:0.0,vlc:0.0,mx:0.0,my:0.0,pred_x:0.0,pred_y:0.0,dxy:0.0,motion_ptr:0.0,",4,140,"s:Kepitttor_crle_input_MTbuf,threshold:antitizatsnb_tErmination,f:nub_packetv_cst,level:f_tablersfcount_tabe_,",Greedy,661,0.27738909324010214
396,"static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,

                             int is_extradata)

{

    MMALDecodeContext *ctx = avctx->priv_data;

    AVBufferRef *buf = NULL;

    int size = 0;

    uint8_t *data = (uint8_t *)"""";

    uint8_t *start;

    int ret = 0;



    if (avpkt->size) {

        if (avpkt->buf) {

            buf = av_buffer_ref(avpkt->buf);

            size = avpkt->size;

            data = avpkt->data;

        } else {

            buf = av_buffer_alloc(avpkt->size);

            if (buf) {

                memcpy(buf->data, avpkt->data, avpkt->size);

                size = buf->size;

                data = buf->data;

            }

        }

        if (!buf) {

            ret = AVERROR(ENOMEM);

            goto done;

        }

        if (!is_extradata)

            ctx->packets_sent++;

    } else {

        if (!ctx->packets_sent) {

            // Short-cut the flush logic to avoid upsetting MMAL.

            ctx->eos_sent = 1;

            ctx->eos_received = 1;

            goto done;

        }

    }



    start = data;



    do {

        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));

        if (!buffer) {

            ret = AVERROR(ENOMEM);

            goto done;

        }



        buffer->data = data;

        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);



        if (is_extradata)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;



        if (data == start)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;



        data += buffer->length;

        size -= buffer->length;



        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;

        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;



        if (!size)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;



        if (!buffer->length) {

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;

            ctx->eos_sent = 1;

        }



        if (buf) {

            buffer->ref = av_buffer_ref(buf);

            if (!buffer->ref) {

                av_free(buffer);

                ret = AVERROR(ENOMEM);

                goto done;

            }

        }



        // Insert at end of the list

        if (!ctx->waiting_buffers)

            ctx->waiting_buffers = buffer;

        if (ctx->waiting_buffers_tail)

            ctx->waiting_buffers_tail->next = buffer;

        ctx->waiting_buffers_tail = buffer;

    } while (size);



done:

    av_buffer_unref(&buf);

    return ret;

}
",441,"static int ffmmal_add_packet(AVCodecContext *filter_node_size, AVPacket *ta3bO_coJef_tableaddng_,

                             int nb_iicigttpreedictinb_sc)

{

    MMALDecodeContext *table_clNustdec_ctoreco_f_ = filter_node_size->priv_data;

    AVBufferRef *_terminationsrre = NULL;

    int size = 0;

    uint8_t *data = (uint8_t *)"""";

    uint8_t *_namEeedicttConvBtcounu_;

    int ret = 0;



    if (ta3bO_coJef_tableaddng_->size) {

        if (ta3bO_coJef_tableaddng_->_terminationsrre) {

            _terminationsrre = av_buffer_ref(ta3bO_coJef_tableaddng_->_terminationsrre);

            size = ta3bO_coJef_tableaddng_->size;

            data = ta3bO_coJef_tableaddng_->data;

        } else {

            _terminationsrre = av_buffer_alloc(ta3bO_coJef_tableaddng_->size);

            if (_terminationsrre) {

                memcpy(_terminationsrre->data, ta3bO_coJef_tableaddng_->data, ta3bO_coJef_tableaddng_->size);

                size = _terminationsrre->size;

                data = _terminationsrre->data;

            }

        }

        if (!_terminationsrre) {

            ret = AVERROR(ENOMEM);

            goto done;

        }

        if (!nb_iicigttpreedictinb_sc)

            table_clNustdec_ctoreco_f_->packets_sent++;

    } else {

        if (!table_clNustdec_ctoreco_f_->packets_sent) {

            // Short-cut the flush logic to avoid upsetting MMAL.

            table_clNustdec_ctoreco_f_->eos_sent = 1;

            table_clNustdec_ctoreco_f_->eos_received = 1;

            goto done;

        }

    }



    _namEeedicttConvBtcounu_ = data;



    do {

        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));

        if (!buffer) {

            ret = AVERROR(ENOMEM);

            goto done;

        }



        buffer->data = data;

        buffer->length = FFMIN(size, table_clNustdec_ctoreco_f_->decoder->input[0]->buffer_size);



        if (nb_iicigttpreedictinb_sc)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;



        if (data == _namEeedicttConvBtcounu_)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;



        data += buffer->length;

        size -= buffer->length;



        buffer->pts = ta3bO_coJef_tableaddng_->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : ta3bO_coJef_tableaddng_->pts;

        buffer->dts = ta3bO_coJef_tableaddng_->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : ta3bO_coJef_tableaddng_->dts;



        if (!size)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;



        if (!buffer->length) {

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;

            table_clNustdec_ctoreco_f_->eos_sent = 1;

        }



        if (_terminationsrre) {

            buffer->ref = av_buffer_ref(_terminationsrre);

            if (!buffer->ref) {

                av_free(buffer);

                ret = AVERROR(ENOMEM);

                goto done;

            }

        }



        // Insert at end of the list

        if (!table_clNustdec_ctoreco_f_->waiting_buffers)

            table_clNustdec_ctoreco_f_->waiting_buffers = buffer;

        if (table_clNustdec_ctoreco_f_->waiting_buffers_tail)

            table_clNustdec_ctoreco_f_->waiting_buffers_tail->next = buffer;

        table_clNustdec_ctoreco_f_->waiting_buffers_tail = buffer;

    } while (size);



done:

    av_buffer_unref(&_terminationsrre);

    return ret;

}
",1,1,0,1,"avctx,avpkt,is_extradata,ctx,buf,data,start,packets_sent,buffer","avctx:0.02196425199508667,avpkt:0.21401172876358032,is_extradata:-0.16872429847717285,ctx:-0.004977107048034668,buf:0.1748495101928711,data:0.11936533451080322,start:0.05012643337249756,packets_sent:0.07921791076660156,buffer:0.19381457567214966,",6,46,"avpkt:ta3bO_coJef_tableaddng_,buffer:buffer,buf:_terminationsrre,data:data,packets_sent:packets_sent,start:_namEeedicttConvBtcounu_,avctx:filter_node_size,ctx:table_clNustdec_ctoreco_f_,is_extradata:nb_iicigttpreedictinb_sc,",Greedy,622,0.20440752903620402
397,"static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)

{

    AVBitStreamFilterContext *bsfc = ost->bitstream_filters;

    AVCodecContext          *avctx = ost->st->codec;

    int ret;



    if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||

        (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))

        pkt->pts = pkt->dts = AV_NOPTS_VALUE;



    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) {

        int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);

        if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt->dts) {

            av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, ""Audio timestamp %""PRId64"" < %""PRId64"" invalid, cliping\n"", pkt->dts, max);

            pkt->pts = pkt->dts = max;





    /*

     * Audio encoders may split the packets --  #frames in != #packets out.

     * But there is no reordering, so we can limit the number of output packets

     * by simply dropping them here.

     * Counting encoded video frames needs to be done separately because of

     * reordering, see do_video_out()

     */

    if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) {

        if (ost->frame_number >= ost->max_frames) {

            av_free_packet(pkt);

            return;


        ost->frame_number++;




    while (bsfc) {

        AVPacket new_pkt = *pkt;

        int a = av_bitstream_filter_filter(bsfc, avctx, NULL,

                                           &new_pkt.data, &new_pkt.size,

                                           pkt->data, pkt->size,

                                           pkt->flags & AV_PKT_FLAG_KEY);











        if (a > 0) {

            av_free_packet(pkt);

            new_pkt.destruct = av_destruct_packet;

        } else if (a < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Failed to open bitstream filter %s for stream %d with codec %s"",

                   bsfc->filter->name, pkt->stream_index,

                   avctx->codec ? avctx->codec->name : ""copy"");

            print_error("""", a);

            if (exit_on_error)

                exit_program(1);


        *pkt = new_pkt;



        bsfc = bsfc->next;




    pkt->stream_index = ost->index;

    ret = av_interleaved_write_frame(s, pkt);

    if (ret < 0) {

        print_error(""av_interleaved_write_frame()"", ret);

        exit_program(1);

",391,"static void write_frame(AVFormatContext *efng_lef_n_varge_tablE_c, AVPacket *preoicUtiNn_quntiYtnzatidn, OutputStream *ost)

{

    AVBitStreamFilterContext *bsfc = ost->bitstream_filters;

    AVCodecContext          *_cnustersgvzub_pEacket_s_b = ost->st->codec;

    int rig_overs_ce_cofec_nameg;



    if ((_cnustersgvzub_pEacket_s_b->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||

        (_cnustersgvzub_pEacket_s_b->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))

        preoicUtiNn_quntiYtnzatidn->pts = preoicUtiNn_quntiYtnzatidn->dts = AV_NOPTS_VALUE;



    if (_cnustersgvzub_pEacket_s_b->codec_type == AVMEDIA_TYPE_AUDIO && preoicUtiNn_quntiYtnzatidn->dts != AV_NOPTS_VALUE) {

        int64_t max = ost->st->cur_dts + !(efng_lef_n_varge_tablE_c->oformat->flags & AVFMT_TS_NONSTRICT);

        if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > preoicUtiNn_quntiYtnzatidn->dts) {

            av_log(efng_lef_n_varge_tablE_c, max - preoicUtiNn_quntiYtnzatidn->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, ""Audio timestamp %""PRId64"" < %""PRId64"" invalid, cliping
"", preoicUtiNn_quntiYtnzatidn->dts, max);

            preoicUtiNn_quntiYtnzatidn->pts = preoicUtiNn_quntiYtnzatidn->dts = max;





    /*

     * Audio encoders may split the packets --  #frames in != #packets out.

     * But there is no reordering, so we can limit the number of output packets

     * by simply dropping them here.

     * Counting encoded video frames needs to be done separately because of

     * reordering, see do_video_out()

     */

    if (!(_cnustersgvzub_pEacket_s_b->codec_type == AVMEDIA_TYPE_VIDEO && _cnustersgvzub_pEacket_s_b->codec)) {

        if (ost->frame_number >= ost->max_frames) {

            av_free_packet(preoicUtiNn_quntiYtnzatidn);

            return;


        ost->frame_number++;




    while (bsfc) {

        AVPacket new_pkt = *preoicUtiNn_quntiYtnzatidn;

        int a = av_bitstream_filter_filter(bsfc, _cnustersgvzub_pEacket_s_b, NULL,

                                           &new_pkt.data, &new_pkt.size,

                                           preoicUtiNn_quntiYtnzatidn->data, preoicUtiNn_quntiYtnzatidn->size,

                                           preoicUtiNn_quntiYtnzatidn->flags & AV_PKT_FLAG_KEY);











        if (a > 0) {

            av_free_packet(preoicUtiNn_quntiYtnzatidn);

            new_pkt.destruct = av_destruct_packet;

        } else if (a < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Failed to open bitstream filter %s for stream %d with codec %s"",

                   bsfc->filter->name, preoicUtiNn_quntiYtnzatidn->stream_index,

                   _cnustersgvzub_pEacket_s_b->codec ? _cnustersgvzub_pEacket_s_b->codec->name : ""copy"");

            print_error("""", a);

            if (exit_on_error)

                exit_program(1);


        *preoicUtiNn_quntiYtnzatidn = new_pkt;



        bsfc = bsfc->next;




    preoicUtiNn_quntiYtnzatidn->stream_index = ost->index;

    rig_overs_ce_cofec_nameg = av_interleaved_write_frame(efng_lef_n_varge_tablE_c, preoicUtiNn_quntiYtnzatidn);

    if (rig_overs_ce_cofec_nameg < 0) {

        print_error(""av_interleaved_write_frame()"", rig_overs_ce_cofec_nameg);

        exit_program(1);

",1,1,0,1,"s,pkt,ost,bsfc,avctx,ret,frame_number","s:-0.0005023479461669922,pkt:-9.799003601074219e-05,ost:-0.0006772875785827637,bsfc:5.751848220825195e-05,avctx:-8.07046890258789e-05,ret:-9.018182754516602e-05,frame_number:-0.0004483461380004883,",4,36,"bsfc:bsfc,avctx:_cnustersgvzub_pEacket_s_b,ret:rig_overs_ce_cofec_nameg,pkt:preoicUtiNn_quntiYtnzatidn,frame_number:frame_number,s:efng_lef_n_varge_tablE_c,",Greedy,416,0.14123280048370362
398,"void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)

{

    CachedL2Table *entry;



    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);

    if (entry) {

        qed_unref_l2_cache_entry(entry);

        qed_unref_l2_cache_entry(l2_table);

        return;

    }



    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {

        entry = QTAILQ_FIRST(&l2_cache->entries);

        QTAILQ_REMOVE(&l2_cache->entries, entry, node);

        l2_cache->n_entries--;

        qed_unref_l2_cache_entry(entry);

    }



    l2_cache->n_entries++;

    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);

}
",105,,1,0,,-4,"l2_cache,l2_table,entry,n_entries",,,,,Greedy,1,0.009081331888834636
399,"av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,

                                     AVCodecContext *avctx,

                                     unsigned high_bit_depth)

{

    int cpu_flags = av_get_cpu_flags();



    if (EXTERNAL_MMX(cpu_flags)) {

        if (!high_bit_depth)

            c->get_pixels = ff_get_pixels_mmx;


        c->diff_pixels = ff_diff_pixels_mmx;

    }



    if (EXTERNAL_SSE2(cpu_flags)) {

        if (!high_bit_depth)

            c->get_pixels = ff_get_pixels_sse2;


        c->diff_pixels = ff_diff_pixels_sse2;

    }

}",76,,1,0,,-4,"c,avctx,high_bit_depth",,,,,Greedy,1,0.008626643816630046

,Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Name,Replaced Names,Original Prob,F1,F2,F3,Query Times
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864212512969971,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
1,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
2,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
3,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
4,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
5,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
6,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
7,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
8,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
9,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
10,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
11,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
12,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
13,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
14,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
15,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
16,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
17,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
18,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
19,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
20,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
21,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
22,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
23,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
24,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
25,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
26,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
27,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
28,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
29,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864211916923523,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864211916923523,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864211916923523,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864211916923523,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}",380,,0,1,,-4,"base,s,clk,iomemtype",,0.5835633873939514,,,,0
0,456,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}",1665,,0,1,,-4,"attached,log_ctx,env",,0.5864211916923523,,,,0
0,102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}",390,,0,1,,-4,"str,endptr,err",,0.5807514190673828,,,,0
0,1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}",447,,0,1,,-4,"d,pci_conf",,0.5832394361495972,,,,0
0,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
1,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
2,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
3,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
4,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
5,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
6,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
7,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
8,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
9,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
10,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
11,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
12,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
13,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
14,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
15,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
16,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
17,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
18,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
19,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
20,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
21,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
22,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
23,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
24,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
25,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
26,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
27,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
28,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
29,1003,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,

                                            prot, &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    te = &env->tlb_table[mmu_idx][index];



    /* do not discard the translation in te, evict it into a victim tlb */

    env->tlb_v_table[mmu_idx][vidx] = *te;

    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];



    /* refill the tlb */

    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;

    env->iotlb[mmu_idx][index].attrs = attrs;

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && cpu_physical_memory_is_clean(

                        memory_region_get_ram_addr(section->mr) + xlat)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}",2805,"void tlb_set_page_with_attrs ( CPUState * cpu , target_ulong vaddr , hwaddr paddr , MemTxAttrs attrs , int prot , int mmu_idx , target_ulong size ) { CPUArchState * env = cpu -> env_ptr ; MemoryRegionSection * section ; unsigned int index ; target_ulong address ; target_ulong code_address ; uintptr_t addend ; CPUTLBEntry * te ; hwaddr iotlb , xlat , sz ; unsigned vidx = env -> vtlb_index ++ % CPU_VTLB_SIZE ; int asidx = cpu_asidx_from_attrs ( cpu , attrs ) ; assert_cpu_is_self ( cpu ) ; assert ( size >= TARGET_PAGE_SIZE ) ; if ( size != TARGET_PAGE_SIZE ) { tlb_add_large_page ( env , vaddr , size ) ; } sz = size ; section = address_space_translate_for_iotlb ( cpu , asidx , paddr , & xlat , & sz ) ; assert ( sz >= TARGET_PAGE_SIZE ) ; tlb_debug ( "" vaddr= "" TARGET_FMT_lx ""  paddr=0x "" TARGET_FMT_plx ""  prot=%x idx=%d "" , vaddr , paddr , prot , mmu_idx ) ; address = vaddr ; if ( ! memory_region_is_ram ( section -> mr ) && ! memory_region_is_romd ( section -> mr ) ) { address |= TLB_MMIO ; addend = 0 ; } else { addend = ( uintptr_t ) memory_region_get_ram_ptr ( section -> mr ) + xlat ; } code_address = address ; iotlb = memory_region_section_get_iotlb ( cpu , section , vaddr , paddr , xlat , prot , & address ) ; index = ( vaddr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; te = & env -> tlb_table [ mmu_idx ] [ index ] ; env -> tlb_v_table [ mmu_idx ] [ vidx ] = * te ; env -> iotlb_v [ mmu_idx ] [ vidx ] = env -> iotlb [ mmu_idx ] [ index ] ; env -> iotlb [ mmu_idx ] [ index ] . addr = iotlb - vaddr ; env -> iotlb [ mmu_idx ] [ index ] . attrs = attrs ; te -> addend = addend - vaddr ; if ( prot & PAGE_READ ) { te -> addr_read = address ; } else { te -> addr_read = -1 ; } if ( prot & PAGE_EXEC ) { te -> addr_code = code_address ; } else { te -> addr_code = -1 ; } if ( prot & PAGE_WRITE ) { if ( ( memory_region_is_ram ( section -> mr ) && section -> readonly ) || memory_region_is_romd ( section -> mr ) ) { te -> addr_write = address | TLB_MMIO ; } else if ( memory_region_is_ram ( section -> mr ) && cpu_physical_memory_is_clean ( memory_region_get_ram_addr ( section -> mr ) + xlat ) ) { te -> addr_write = address | TLB_NOTDIRTY ; } else { te -> addr_write = address ; } } else { te -> addr_write = -1 ; } }",1,1,-1,"cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index","cpu,vaddr,paddr,attrs,prot,mmu_idx,size,env,section,index,address,code_address,addend,te,iotlb,xlat,sz,vtlb_index",0.5946249961853027,0.3945012092590332,0.0,0.0,2730
0,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
1,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
2,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
3,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
4,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
5,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
6,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
7,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
8,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
9,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
10,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
11,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
12,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
13,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
14,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
15,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
16,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
17,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
18,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
19,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
20,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
21,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
22,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
23,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
24,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
25,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
26,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
27,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
28,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
29,914,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled()) {
        if (ppc_fixup_cpu(cpu) != 0) {
            error_setg(errp, ""Unable to emulate selected CPU with TCG"");
#if defined(TARGET_PPCEMB)
    if (!ppc_cpu_is_valid(pcc)) {
        error_setg(errp, ""CPU does not possess a BookE or 4xx MMU. ""
                   ""Please use qemu-system-ppc or qemu-system-ppc64 instead ""
                   ""or choose another CPU model."");
#endif
    create_ppc_opcodes(cpu, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
    init_ppc_proc(cpu);
    if (pcc->insns_flags & PPC_FLOAT) {
        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,
                                 33, ""power-fpu.xml"", 0);
    if (pcc->insns_flags & PPC_ALTIVEC) {
        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,
                                 34, ""power-altivec.xml"", 0);
    if (pcc->insns_flags & PPC_SPE) {
        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,
                                 34, ""power-spe.xml"", 0);
    if (pcc->insns_flags2 & PPC2_VSX) {
        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,
                                 32, ""power-vsx.xml"", 0);
    qemu_init_vcpu(cs);
    pcc->parent_realize(dev, errp);
#if defined(PPC_DUMP_CPU)
    {
        CPUPPCState *env = &cpu->env;
        const char *mmu_model, *excp_model, *bus_model;
        switch (env->mmu_model) {
        case POWERPC_MMU_32B:
            mmu_model = ""PowerPC 32"";
            break;
        case POWERPC_MMU_SOFT_6xx:
            mmu_model = ""PowerPC 6xx/7xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_74xx:
            mmu_model = ""PowerPC 74xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx:
            mmu_model = ""PowerPC 4xx with software driven TLBs"";
            break;
        case POWERPC_MMU_SOFT_4xx_Z:
            mmu_model = ""PowerPC 4xx with software driven TLBs ""
                ""and zones protections"";
            break;
        case POWERPC_MMU_REAL:
            mmu_model = ""PowerPC real mode only"";
            break;
        case POWERPC_MMU_MPC8xx:
            mmu_model = ""PowerPC MPC8xx"";
            break;
        case POWERPC_MMU_BOOKE:
            mmu_model = ""PowerPC BookE"";
            break;
        case POWERPC_MMU_BOOKE206:
            mmu_model = ""PowerPC BookE 2.06"";
            break;
        case POWERPC_MMU_601:
            mmu_model = ""PowerPC 601"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_MMU_64B:
            mmu_model = ""PowerPC 64"";
            break;
#endif
        default:
            mmu_model = ""Unknown or invalid"";
            break;
        switch (env->excp_model) {
        case POWERPC_EXCP_STD:
            excp_model = ""PowerPC"";
            break;
        case POWERPC_EXCP_40x:
            excp_model = ""PowerPC 40x"";
            break;
        case POWERPC_EXCP_601:
            excp_model = ""PowerPC 601"";
            break;
        case POWERPC_EXCP_602:
            excp_model = ""PowerPC 602"";
            break;
        case POWERPC_EXCP_603:
            excp_model = ""PowerPC 603"";
            break;
        case POWERPC_EXCP_603E:
            excp_model = ""PowerPC 603e"";
            break;
        case POWERPC_EXCP_604:
            excp_model = ""PowerPC 604"";
            break;
        case POWERPC_EXCP_7x0:
            excp_model = ""PowerPC 740/750"";
            break;
        case POWERPC_EXCP_7x5:
            excp_model = ""PowerPC 745/755"";
            break;
        case POWERPC_EXCP_74xx:
            excp_model = ""PowerPC 74xx"";
            break;
        case POWERPC_EXCP_BOOKE:
            excp_model = ""PowerPC BookE"";
            break;
#if defined (TARGET_PPC64)
        case POWERPC_EXCP_970:
            excp_model = ""PowerPC 970"";
            break;
#endif
        default:
            excp_model = ""Unknown or invalid"";
            break;
        switch (env->bus_model) {
        case PPC_FLAGS_INPUT_6xx:
            bus_model = ""PowerPC 6xx"";
            break;
        case PPC_FLAGS_INPUT_BookE:
            bus_model = ""PowerPC BookE"";
            break;
        case PPC_FLAGS_INPUT_405:
            bus_model = ""PowerPC 405"";
            break;
        case PPC_FLAGS_INPUT_401:
            bus_model = ""PowerPC 401/403"";
            break;
        case PPC_FLAGS_INPUT_RCPU:
            bus_model = ""RCPU / MPC8xx"";
            break;
#if defined (TARGET_PPC64)
        case PPC_FLAGS_INPUT_970:
            bus_model = ""PowerPC 970"";
            break;
#endif
        default:
            bus_model = ""Unknown or invalid"";
            break;
        printf(""PowerPC %-12s : PVR %08x MSR %016"" PRIx64 ""\n""
               ""    MMU model        : %s\n"",
               object_class_get_name(OBJECT_CLASS(pcc)),
               pcc->pvr, pcc->msr_mask, mmu_model);
#if !defined(CONFIG_USER_ONLY)
        if (env->tlb.tlb6) {
            printf(""                       %d %s TLB in %d ways\n"",
                   env->nb_tlb, env->id_tlbs ? ""splitted"" : ""merged"",
                   env->nb_ways);
#endif
        printf(""    Exceptions model : %s\n""
               ""    Bus model        : %s\n"",
               excp_model, bus_model);
        printf(""    MSR features     :\n"");
        if (env->flags & POWERPC_FLAG_SPE)
            printf(""                        signal processing engine enable""
                   ""\n"");
        else if (env->flags & POWERPC_FLAG_VRE)
            printf(""                        vector processor enable\n"");
        if (env->flags & POWERPC_FLAG_TGPR)
            printf(""                        temporary GPRs\n"");
        else if (env->flags & POWERPC_FLAG_CE)
            printf(""                        critical input enable\n"");
        if (env->flags & POWERPC_FLAG_SE)
            printf(""                        single-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DWE)
            printf(""                        debug wait enable\n"");
        else if (env->flags & POWERPC_FLAG_UBLE)
            printf(""                        user BTB lock enable\n"");
        if (env->flags & POWERPC_FLAG_BE)
            printf(""                        branch-step trace mode\n"");
        else if (env->flags & POWERPC_FLAG_DE)
            printf(""                        debug interrupt enable\n"");
        if (env->flags & POWERPC_FLAG_PX)
            printf(""                        inclusive protection\n"");
        else if (env->flags & POWERPC_FLAG_PMM)
            printf(""                        performance monitor mark\n"");
        if (env->flags == POWERPC_FLAG_NONE)
            printf(""                        none\n"");
        printf(""    Time-base/decrementer clock source: %s\n"",
               env->flags & POWERPC_FLAG_RTC_CLK ? ""RTC clock"" : ""bus clock"");
        dump_ppc_insns(env);
        dump_ppc_sprs(env);
        fflush(stdout);
#endif",7959,"static void ppc_cpu_realizefn ( DeviceState * dev , Error * * errp ) { CPUState * cs = CPU ( dev ) ; PowerPCCPU * cpu = POWERPC_CPU ( dev ) ; PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; Error * local_err = NULL ; #if ! defined ( CONFIG_USER_ONLY )  int max_smt = kvm_enabled ( ) ? kvmppc_smt_threads ( ) : 1 ; #endif #if ! defined ( CONFIG_USER_ONLY )  if ( smp_threads > max_smt ) { error_setg ( errp , "" Cannot support more than %d threads on PPC with %s "" , max_smt , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; if ( ! is_power_of_2 ( smp_threads ) ) { error_setg ( errp , "" Cannot support %d threads on PPC with %s,  "" "" threads count must be a power of 2. "" , smp_threads , kvm_enabled ( ) ? "" KVM "" : "" TCG "" ) ; #endif cpu_exec_init ( cs , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; #if ! defined ( CONFIG_USER_ONLY )  cpu -> cpu_dt_id = ( cs -> cpu_index / smp_threads ) * max_smt + ( cs -> cpu_index % smp_threads ) ; #endif if ( tcg_enabled ( ) ) { if ( ppc_fixup_cpu ( cpu ) != 0 ) { error_setg ( errp , "" Unable to emulate selected CPU with TCG "" ) ; #if defined ( TARGET_PPCEMB )  if ( ! ppc_cpu_is_valid ( pcc ) ) { error_setg ( errp , "" CPU does not possess a BookE or 4xx MMU.  "" "" Please use qemu-system-ppc or qemu-system-ppc64 instead  "" "" or choose another CPU model. "" ) ; #endif create_ppc_opcodes ( cpu , & local_err ) ; if ( local_err != NULL ) { error_propagate ( errp , local_err ) ; init_ppc_proc ( cpu ) ; if ( pcc -> insns_flags & PPC_FLOAT ) { gdb_register_coprocessor ( cs , gdb_get_float_reg , gdb_set_float_reg , 33 , "" power-fpu.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_ALTIVEC ) { gdb_register_coprocessor ( cs , gdb_get_avr_reg , gdb_set_avr_reg , 34 , "" power-altivec.xml "" , 0 ) ; if ( pcc -> insns_flags & PPC_SPE ) { gdb_register_coprocessor ( cs , gdb_get_spe_reg , gdb_set_spe_reg , 34 , "" power-spe.xml "" , 0 ) ; if ( pcc -> insns_flags2 & PPC2_VSX ) { gdb_register_coprocessor ( cs , gdb_get_vsx_reg , gdb_set_vsx_reg , 32 , "" power-vsx.xml "" , 0 ) ; qemu_init_vcpu ( cs ) ; pcc -> parent_realize ( dev , errp ) ; #if defined ( PPC_DUMP_CPU )  { CPUPPCState * env = & cpu -> env ; const char * mmu_model , * excp_model , * bus_model ; switch ( env -> mmu_model ) { case POWERPC_MMU_32B : mmu_model = "" PowerPC 32 "" ; break ; case POWERPC_MMU_SOFT_6xx : mmu_model = "" PowerPC 6xx/7xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_74xx : mmu_model = "" PowerPC 74xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx : mmu_model = "" PowerPC 4xx with software driven TLBs "" ; break ; case POWERPC_MMU_SOFT_4xx_Z : mmu_model = "" PowerPC 4xx with software driven TLBs  "" "" and zones protections "" ; break ; case POWERPC_MMU_REAL : mmu_model = "" PowerPC real mode only "" ; break ; case POWERPC_MMU_MPC8xx : mmu_model = "" PowerPC MPC8xx "" ; break ; case POWERPC_MMU_BOOKE : mmu_model = "" PowerPC BookE "" ; break ; case POWERPC_MMU_BOOKE206 : mmu_model = "" PowerPC BookE 2.06 "" ; break ; case POWERPC_MMU_601 : mmu_model = "" PowerPC 601 "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_MMU_64B : mmu_model = "" PowerPC 64 "" ; break ; #endif default : mmu_model = "" Unknown or invalid "" ; break ; switch ( env -> excp_model ) { case POWERPC_EXCP_STD : excp_model = "" PowerPC "" ; break ; case POWERPC_EXCP_40x : excp_model = "" PowerPC 40x "" ; break ; case POWERPC_EXCP_601 : excp_model = "" PowerPC 601 "" ; break ; case POWERPC_EXCP_602 : excp_model = "" PowerPC 602 "" ; break ; case POWERPC_EXCP_603 : excp_model = "" PowerPC 603 "" ; break ; case POWERPC_EXCP_603E : excp_model = "" PowerPC 603e "" ; break ; case POWERPC_EXCP_604 : excp_model = "" PowerPC 604 "" ; break ; case POWERPC_EXCP_7x0 : excp_model = "" PowerPC 740/750 "" ; break ; case POWERPC_EXCP_7x5 : excp_model = "" PowerPC 745/755 "" ; break ; case POWERPC_EXCP_74xx : excp_model = "" PowerPC 74xx "" ; break ; case POWERPC_EXCP_BOOKE : excp_model = "" PowerPC BookE "" ; break ; #if defined ( TARGET_PPC64 )  case POWERPC_EXCP_970 : excp_model = "" PowerPC 970 "" ; break ; #endif default : excp_model = "" Unknown or invalid "" ; break ; switch ( env -> bus_model ) { case PPC_FLAGS_INPUT_6xx : bus_model = "" PowerPC 6xx "" ; break ; case PPC_FLAGS_INPUT_BookE : bus_model = "" PowerPC BookE "" ; break ; case PPC_FLAGS_INPUT_405 : bus_model = "" PowerPC 405 "" ; break ; case PPC_FLAGS_INPUT_401 : bus_model = "" PowerPC 401/403 "" ; break ; case PPC_FLAGS_INPUT_RCPU : bus_model = "" RCPU / MPC8xx "" ; break ; #if defined ( TARGET_PPC64 )  case PPC_FLAGS_INPUT_970 : bus_model = "" PowerPC 970 "" ; break ; #endif default : bus_model = "" Unknown or invalid "" ; break ; printf ( "" PowerPC %-12s : PVR %08x MSR %016 "" PRIx64 "" "" ""     MMU model        : %s "" , object_class_get_name ( OBJECT_CLASS ( pcc ) ) , pcc -> pvr , pcc -> msr_mask , mmu_model ) ; #if ! defined ( CONFIG_USER_ONLY )  if ( env -> tlb . tlb6 ) { printf ( ""                        %d %s TLB in %d ways "" , env -> nb_tlb , env -> id_tlbs ? "" splitted "" : "" merged "" , env -> nb_ways ) ; #endif printf ( ""     Exceptions model : %s "" ""     Bus model        : %s "" , excp_model , bus_model ) ; printf ( ""     MSR features     : "" ) ; if ( env -> flags & POWERPC_FLAG_SPE ) printf ( ""                         signal processing engine enable "" "" "" ) ; else if ( env -> flags & POWERPC_FLAG_VRE ) printf ( ""                         vector processor enable "" ) ; if ( env -> flags & POWERPC_FLAG_TGPR ) printf ( ""                         temporary GPRs "" ) ; else if ( env -> flags & POWERPC_FLAG_CE ) printf ( ""                         critical input enable "" ) ; if ( env -> flags & POWERPC_FLAG_SE ) printf ( ""                         single-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DWE ) printf ( ""                         debug wait enable "" ) ; else if ( env -> flags & POWERPC_FLAG_UBLE ) printf ( ""                         user BTB lock enable "" ) ; if ( env -> flags & POWERPC_FLAG_BE ) printf ( ""                         branch-step trace mode "" ) ; else if ( env -> flags & POWERPC_FLAG_DE ) printf ( ""                         debug interrupt enable "" ) ; if ( env -> flags & POWERPC_FLAG_PX ) printf ( ""                         inclusive protection "" ) ; else if ( env -> flags & POWERPC_FLAG_PMM ) printf ( ""                         performance monitor mark "" ) ; if ( env -> flags == POWERPC_FLAG_NONE ) printf ( ""                         none "" ) ; printf ( ""     Time-base/decrementer clock source: %s "" , env -> flags & POWERPC_FLAG_RTC_CLK ? "" RTC clock "" : "" bus clock "" ) ; dump_ppc_insns ( env ) ; dump_ppc_sprs ( env ) ; fflush ( stdout ) ; #endif",1,1,-1,"dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model","dev,errp,cs,cpu,pcc,local_err,env,mmu_model,excp_model,bus_model",0.5775524377822876,0.4033392071723938,0.0,0.0,1530
0,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
1,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * ctxctxctxctxctx , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","ctxctxctxctxctx,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40232551097869873,0.6899740726244871,0.08333333333333333,630
2,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * ctxctxctxctxctx , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","ctxctxctxctxctx,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40232551097869873,0.6899740726244871,0.08333333333333333,630
3,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * pb , int * pppp ) { int n , n1 ; n = get_be16 ( pb ) ; ( * pppp ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( pb ) ; ( * pppp ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","pb,pppp,n,n1",0.5675858855247498,0.4144051671028137,0.5786626264452934,0.041666666666666664,630
4,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * pb , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( pb ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( pb ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","pb,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40430885553359985,0.6121712205084888,0.041666666666666664,630
5,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
6,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
7,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
8,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * pb , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( pb ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( pb ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","pb,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40430885553359985,0.6121712205084888,0.041666666666666664,630
9,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
10,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
11,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
12,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
13,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
14,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
15,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
16,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * pb , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( pb ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( pb ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","pb,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40430885553359985,0.6121712205084888,0.041666666666666664,630
17,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * ctxctxctxctxctx , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","ctxctxctxctxctx,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40232551097869873,0.6899740726244871,0.08333333333333333,630
18,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * ctxctxctxctxctx , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int r1r1r1 , n1 ; r1r1r1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( r1r1r1 >= 0x4000 ) { return r1r1r1 - 0x4000 ; } else { n1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( r1r1r1 << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","ctxctxctxctxctx,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,r1r1r1,n1",0.5675858855247498,0.40197235345840454,0.7830842391521942,0.1527777777777778,630
19,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * ctxctxctxctxctx , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int r1r1r1 , n1 ; r1r1r1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( r1r1r1 >= 0x4000 ) { return r1r1r1 - 0x4000 ; } else { n1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( r1r1r1 << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","ctxctxctxctxctx,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,r1r1r1,n1",0.5675858855247498,0.40197235345840454,0.7830842391521942,0.1527777777777778,630
20,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * ctxctxctxctxctx , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","ctxctxctxctxctx,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40232551097869873,0.6899740726244871,0.08333333333333333,630
21,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
22,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * ctxctxctxctxctx , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","ctxctxctxctxctx,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40232551097869873,0.6899740726244871,0.08333333333333333,630
23,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * pb , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( pb ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( pb ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","pb,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40430885553359985,0.6121712205084888,0.041666666666666664,630
24,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * ctxctxctxctxctx , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int r1r1r1 , n1 ; r1r1r1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( r1r1r1 >= 0x4000 ) { return r1r1r1 - 0x4000 ; } else { n1 = get_be16 ( ctxctxctxctxctx ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( r1r1r1 << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","ctxctxctxctxctx,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,r1r1r1,n1",0.5675858855247498,0.40197235345840454,0.7830842391521942,0.1527777777777778,630
25,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * pb , int * pppp ) { int n , n1 ; n = get_be16 ( pb ) ; ( * pppp ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( pb ) ; ( * pppp ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","pb,pppp,n,n1",0.5675858855247498,0.4144051671028137,0.5786626264452934,0.041666666666666664,630
26,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * pb , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( pb ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( pb ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","pb,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40430885553359985,0.6121712205084888,0.041666666666666664,630
27,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
28,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
29,571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",283,"static int get_num ( ByteIOContext * cccc , int * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) { int n , n1 ; n = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; if ( n >= 0x4000 ) { return n - 0x4000 ; } else { n1 = get_be16 ( cccc ) ; ( * ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio ) -= 2 ; return ( n << 16 ) | n1 ; } }",1,1,-1,"pb,len,n,n1","cccc,ioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextioContextio,n,n1",0.5675858855247498,0.40293747186660767,0.6437489335246459,0.08333333333333333,630
0,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
1,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
2,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
3,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
4,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
5,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
6,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
7,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
8,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
9,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
10,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
11,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
12,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
13,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
14,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
15,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
16,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
17,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
18,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
19,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
20,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
21,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
22,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
23,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
24,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
25,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
26,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
27,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
28,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
29,419,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",738,"static QObject * parse_keyword ( JSONParserContext * ctxt ) { QObject * token , * ret ; JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; token = parser_context_pop_token ( ctxt ) ; if ( token == NULL ) { goto out ; } if ( token_get_type ( token ) != JSON_KEYWORD ) { goto out ; } if ( token_is_keyword ( token , "" true "" ) ) { ret = QOBJECT ( qbool_from_int ( true ) ) ; } else if ( token_is_keyword ( token , "" false "" ) ) { ret = QOBJECT ( qbool_from_int ( false ) ) ; } else { parse_error ( ctxt , token , "" invalid keyword `%s' "" , token_get_value ( token ) ) ; goto out ; } return ret ; out : parser_context_restore ( ctxt , saved_ctxt ) ; return NULL ; }",1,1,-1,"ctxt,token,ret","ctxt,token,ret",0.5899731516838074,0.39929360151290894,0.0,0.0,480
0,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
1,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
2,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
3,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
4,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
5,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
6,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
7,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
8,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
9,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
10,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
11,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
12,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
13,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
14,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
15,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
16,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
17,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
18,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
19,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
20,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
21,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
22,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
23,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
24,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
25,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
26,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
27,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
28,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680
29,2233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}",4856,"static inline void RENAME ( hScale ) ( int16_t * dst , int dstW , uint8_t * src , int srcW , int xInc , int16_t * filter , int16_t * filterPos , int filterSize ) { #ifdef HAVE_MMX assert ( filterSize % 4 == 0 && filterSize > 0 ) ; if ( filterSize == 4 ) { long counter = -2 * dstW ; filter -= counter * 2 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 4), %%mm1 \t "" "" movq 8(%1, %% "" REG_BP "" , 4), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else if ( filterSize == 8 ) { long counter = -2 * dstW ; filter -= counter * 4 ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" push %% "" REG_BP "" 		 \t "" "" mov %% "" REG_a "" , %% "" REG_BP "" 	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" movzwl (%2, %% "" REG_BP "" ), %%eax	 \t "" "" movzwl 2(%2, %% "" REG_BP "" ), %%ebx \t "" "" movq (%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 16(%1, %% "" REG_BP "" , 8), %%mm3 \t "" "" movd (%3, %% "" REG_a "" ), %%mm0	 \t "" "" movd (%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" movq 8(%1, %% "" REG_BP "" , 8), %%mm1 \t "" "" movq 24(%1, %% "" REG_BP "" , 8), %%mm5 \t "" "" movd 4(%3, %% "" REG_a "" ), %%mm4	 \t "" "" movd 4(%3, %% "" REG_b "" ), %%mm2	 \t "" "" punpcklbw %%mm7, %%mm4		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm4		 \t "" "" pmaddwd %%mm2, %%mm5		 \t "" "" paddd %%mm4, %%mm0		 \t "" "" paddd %%mm5, %%mm3		 \t "" "" psrad $8, %%mm0		 \t "" "" psrad $8, %%mm3		 \t "" "" packssdw %%mm3, %%mm0		 \t "" "" pmaddwd %%mm6, %%mm0		 \t "" "" packssdw %%mm0, %%mm0		 \t "" "" movd %%mm0, (%4, %% "" REG_BP "" )	 \t "" "" add $4, %% "" REG_BP "" 		 \t "" ""  jnc 1b			 \t "" "" pop %% "" REG_BP "" 			 \t "" : "" + a ""  (counter) :   "" c ""  (filter),  "" d ""  (filterPos),  "" S ""  (src),  "" D ""  (dst) :   "" % "" REG_b ) ; } else { uint8_t * offset = src + filterSize ; long counter = -2 * dstW ; filterPos -= counter / 2 ; dst -= counter / 2 ; asm volatile ( "" pxor %%mm7, %%mm7		 \t "" "" movq  "" MANGLE  ( w02 )  "" , %%mm6	 \t "" "" .balign 16			 \t "" "" 1:				 \t "" "" mov %2, %% "" REG_c "" 		 \t "" "" movzwl (%% "" REG_c "" , %0), %%eax	 \t "" "" movzwl 2(%% "" REG_c "" , %0), %%ebx	 \t "" "" mov %5, %% "" REG_c "" 		 \t "" "" pxor %%mm4, %%mm4		 \t "" "" pxor %%mm5, %%mm5		 \t "" "" 2:				 \t "" "" movq (%1), %%mm1		 \t "" "" movq (%1, %6), %%mm3		 \t "" "" movd (%% "" REG_c "" , %% "" REG_a "" ), %%mm0 \t "" "" movd (%% "" REG_c "" , %% "" REG_b "" ), %%mm2 \t "" "" punpcklbw %%mm7, %%mm0		 \t "" "" punpcklbw %%mm7, %%mm2		 \t "" "" pmaddwd %%mm1, %%mm0		 \t "" "" pmaddwd %%mm2, %%mm3		 \t "" "" paddd %%mm3, %%mm5		 \t "" "" paddd %%mm0, %%mm4		 \t "" "" add $8, %1			 \t "" "" add $4, %% "" REG_c "" 		 \t "" "" cmp %4, %% "" REG_c "" 		 \t "" ""  jb 2b				 \t "" "" add %6, %1			 \t "" "" psrad $8, %%mm4		 \t "" "" psrad $8, %%mm5		 \t "" "" packssdw %%mm5, %%mm4		 \t "" "" pmaddwd %%mm6, %%mm4		 \t "" "" packssdw %%mm4, %%mm4		 \t "" "" mov %3, %% "" REG_a "" 		 \t "" "" movd %%mm4, (%% "" REG_a "" , %0)	 \t "" "" add $4, %0			 \t "" ""  jnc 1b			 \t "" : "" + r ""  (counter),  "" + r ""  (filter) :   "" m ""  (filterPos),  "" m ""  (dst),  "" m "" (offset), "" m ""  (src),  "" r ""  ((long)filterSize*2) :   "" % "" REG_b,  "" % "" REG_a,  "" % "" REG_c ) ; } #else #ifdef HAVE_ALTIVEC hScale_altivec_real ( dst , dstW , src , srcW , xInc , filter , filterPos , filterSize ) ; #else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; "" , filterPos[i]); for ( j = 0 ; j < filterSize ; j ++ ) { "" , filter[i], src[srcPos + j]); val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; } dst [ i ] = MIN ( MAX ( 0 , val >> 7 ) , ( 1 << 15 ) - 1 ) ; } #endif #endif }",1,1,-1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j","dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,offset,i,j",0.5864155888557434,0.42338114976882935,0.0,0.0,1680


import os 
import math 
import time
import random
import argparse
import numpy as np


# parser = argparse.ArgumentParser() 
# parser.add_argument('filepath',type=str, help='please input the count file path')
# # parser.add_argument('action',type=int,help='actions')
# args=parser.parse_args()
 
def get_conut_result(file_dir):
    F=[]
    for root,dirs,files in os.walk(file_dir):
        for filename in files:
            if(os.path.splitext(filename)[1]=='.count'):
                F.append(filename)
    return F
 

def get_file_number(filename):
    count=0
    for i in filename:
        if(str.isnumeric(i)):
            count+=1
    number=filename[:count]
    return int(number)

def gen_random_data(filepath,files):
    random.seed(time.time())
    
    sortedlist = []
    for filename in files:
        absFile=os.path.join(filepath,filename)
        # print(filename)
        with open(absFile,'r') as fileHandle:
            # filenumber对应的是action
            filenumber=get_file_number(filename)
            
            # count是代码中有多少个对应的结构
            count=int(fileHandle.readline().strip())
            sortedlist.append((filenumber, count))
    # 根据代码中结构的数量进行排序
    
    sortedlist = sorted(sortedlist,key=lambda x: x[1], reverse=True)
    # print("sortedlist:", sortedlist)
    actions = []
    weights = []
    for i in range(len(sortedlist)):
        if sortedlist[i][0] == 11 or sortedlist[i][0] == 1:
            weights.append(1)
        else:
            weights.append(sortedlist[i][1])
    weights = np.array(weights)
    # print("weights:", weights)
    total_weight = weights.sum()
    probabilities = weights / total_weight
    # print("probabilities:", probabilities)
    chosen_indices = np.random.choice(len(sortedlist), size=1, p=probabilities, replace=False)
    # print("chosen_indices:", chosen_indices)
    for i in chosen_indices:
        actions.append(sortedlist[i][0])
    print("actions:", actions)

    # for filenumber, count in sortedlist:
    for filename in files:
        absFile=os.path.join(filepath,filename)
        # print(filename)
        with open(absFile,'r') as fileHandle:
            # filenumber对应的是action
            filenumber=get_file_number(filename)
            
            # count是代码中有多少个对应的结构
            count=int(fileHandle.readline().strip())

        changedCount=0
        if(filenumber in actions):
            if(count>0):
                changedCount=random.randint(1,count)
                # 限制只插入一处垃圾代码
                if(filenumber==13):
                    changedCount=1
                noChangeCount=count-changedCount
                changeVariable=['1']*changedCount
                noChangeVariable=['0']*noChangeCount
                variable=changeVariable+noChangeVariable
                x=random.randint(1,100000)
                random.seed(x)
                random.shuffle(variable)    
                saveVariable=os.path.join(filepath,os.path.splitext(filename)[0]+'.random')
                print("saveVariable:", saveVariable)
                with open(saveVariable,'w') as saveFile:
                    result='\n'.join(variable)
                    saveFile.write(result)
    return actions[0]
def getAction():
    filepath="/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult"
    files=get_conut_result(filepath)
    # print(f"files:{files}")
    return gen_random_data(filepath,files,)

if __name__ == '__main__':
    # filepath = args.filepath   # 
    filepath = '../CountResult/'
    # action = args.action
    files=get_conut_result(filepath)
    print(gen_random_data(filepath,files,))



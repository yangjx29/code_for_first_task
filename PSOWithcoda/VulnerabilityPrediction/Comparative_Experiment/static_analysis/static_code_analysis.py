import subprocess
import json
import os
import pandas as pd

def extract_adversarial_code(csv_file):
    # 读取CSV文件
    df = pd.read_csv(csv_file)
    
    # 获取所有对抗样本代码
    adversarial_codes = df['Adversarial Code'].tolist()
    
    # 过滤掉空值或无效值
    adversarial_codes = [code for code in adversarial_codes if isinstance(code, str) and code.strip()]
    
    # 可以同时获取其他相关信息
    attack_results = []
    for index, row in df.iterrows():
        attack_info = {
            'index': index,
            'adv_code': row['Adversarial Code'],
            'is_success': row['Is Success'],
            'original_pred': row['Original Prediction'],
            'adv_pred': row['Adv Prediction'],
            'attack_type': row['Attack Type'],
            'changed_tokens': row['No. Changed Tokens'],
            'time_cost': row['Time Cost']
        }
        attack_results.append(attack_info)
    
    return adversarial_codes, attack_results

def check_cppcheck(code, filename):
    # 将代码写入临时文件
    with open(f"temp_{filename}.c", "w") as f:
        f.write(code)
    
    # 使用cppcheck进行分析
    result = subprocess.run(['cppcheck', '--enable=all', f'temp_{filename}.c'],
                          capture_output=True,
                          text=True)
    
    # 删除临时文件
    os.remove(f"temp_{filename}.c")
    
    # 计算错误数量
    error_count = result.stderr.count("error:")
    warning_count = result.stderr.count("warning:")
    
    return error_count, warning_count

def analyze_static():
    # 读取并分析两组代码
    # 类似于上面的语法分析，但返回错误统计
    original_errors = []
    adversarial_errors = []
    
    # 分析原始代码
    with open("../../dataset/test_0_400.jsonl", "r") as f:
        for line in f:
            data = json.loads(line)
            errors, warnings = check_cppcheck(data['func'], "orig")
            original_errors.append((errors, warnings))
    
    # 分析对抗代码
    # with open("../graphcodebert_test_0_400_adv.jsonl", "r") as f:
    #     current_code = ""
        
    #     for line in f:
    #         data = json.loads(line)
    #         errors, warnings = check_cppcheck(data['func'], "adv")
    #         adversarial_errors.append((errors, warnings))
    adversarial_codes, _= extract_adversarial_code("/data/yjx/code_for_first_task/ALERT/CodeBert/Defect-detection/code/Alert_20_20.csv")
    for func in adversarial_codes:
        errors, warnings = check_cppcheck(data['func'], "adv")
        adversarial_errors.append((errors, warnings))


    
    return {
        "original": {
            "total_errors": sum(e[0] for e in original_errors),
            "total_warnings": sum(e[1] for e in original_errors),
            "avg_errors": sum(e[0] for e in original_errors) / len(original_errors),
            "avg_warnings": sum(e[1] for e in original_errors) / len(original_errors)
        },
        "adversarial": {
            "total_errors": sum(e[0] for e in adversarial_errors),
            "total_warnings": sum(e[1] for e in adversarial_errors),
            "avg_errors": sum(e[0] for e in adversarial_errors) / len(adversarial_errors) if len(adversarial_errors) > 0 else 0,
            "avg_warnings": sum(e[1] for e in adversarial_errors) / len(adversarial_errors) if len(adversarial_errors) else 0
        }
    }
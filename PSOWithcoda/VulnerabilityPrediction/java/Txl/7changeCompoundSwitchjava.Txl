% Txl v10.8 (7.5.20) (c) 1988-2020 Queen's University at Kingston
% statements 
% 
% version 20200924
% 这个文件的主要功能是实现代码statement, expression等自身发生的变化

include "java.grm"

% ----------------------------------------------------------------
% 这里为了转换的需要重新定义了部分结构
% Java中调整if_statement以支持switch到if-else-if的转换

redefine if_statement
    ... 
    | 'if '( [repeat condition] ') [statement]
    | [if_statement] [repeat else_clause] 
end redefine

% ----------------------------------------------------------------

%----------------------------------------------------------------
% 主函数的开始
function main
    replace [package_declaration]
        P [package_declaration]
    export RandomPath [stringlit]
        "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/7Switch.random"
    by 
        P [changeProgram] 
end function

% 主函数结束
% ---------------------------------------------------------------

% ---------------------------------------------------------------
% 处理switch语句的变换
function changeProgram
    replace [package_declaration]
        CSB [package_declaration]
    construct S [repeat switch_statement]
        _ [^ CSB]
    import RandomPath [stringlit]
    construct RandomChange [repeat number]
        _ [readRandomFile RandomPath]
    construct NewS [repeat statement]
        _ [changeSwitchStatement each S RandomChange]
    construct NS [repeat statement]
        _ [fromSwitchToStatement each S]
    by
        CSB [replaceStatement each NS NewS]
end function

function replaceStatement S [statement] NS [statement]
    replace *[statement]
        S
    by
        NS
end function

rule readRandomFile FileName [stringlit]
    replace [repeat number]
        RN [repeat number]
    construct OptNextNumber [opt number]
        _ [fget FileName]
    deconstruct OptNextNumber
        NextNumber [number]
    by 
        RN [. NextNumber]
end rule

% ----------------------------------------------------------------
% 处理从switch-case到if-else语句的转换
function fromSwitchToStatement Switch [switch_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct NS [statement]
        Switch
    by
        RS [. NS]
end function

function changeSwitchStatement Switch [switch_statement] Change [number]
    replace [repeat statement]
        RS [repeat statement]
    construct S [statement]
        Switch
    construct NS [statement]
        S [newSwitchStatement]
    construct Changed [statement]
        S [isNeedChanged NS Change]
    by 
        RS [. Changed]
end function

function isNeedChanged NS [statement] Change [number]
    replace [statement]
        St [statement]
    where
        Change [= 1]
    by
        NS 
end function

function newSwitchStatement
    replace [statement]
        Switch [switch_statement]
    deconstruct Switch
        'switch '( Ex [expression] ') SB [switch_block]
    deconstruct SB
        '{ SA [repeat switch_alternative] '}
    construct NewSA [repeat switch_alternative]
        SA [judgeDefaultIsFirst]
    export RIf [repeat if_statement]
        _
    construct ORIf [repeat if_statement]
        _ [createRepeatIfStatements Ex NewSA]
    import RIf
    construct OneRIf [repeat if_statement]
        RIf [select 1 1]
    deconstruct OneRIf  
        IfS [if_statement]
    construct RestRIf [repeat if_statement]
        RIf [select 2 999]
    construct ElseIf [repeat else_clause]
        _ [caseCreateElseIfStatement each RestRIf]
    construct NewEIf [repeat else_clause]
        ElseIf [caseCreateElseStatement RestRIf]
    construct IfStatement [if_statement]
        IfS NewEIf
    by 
        IfStatement
end function

function judgeDefaultIsFirst
    replace [repeat switch_alternative]
        RSA [repeat switch_alternative]
    construct DefaultEnd [number]
        0
    export CaseDefaultIndex [number]
        0
    construct FindDefault [number]
        0
    construct FirstBlocks [repeat switch_alternative]
        RSA [select 1 1]
    deconstruct FirstBlocks
        FirstBlock [switch_alternative]
    construct FindDefaults [number]
        FindDefault [findDefaultStart FirstBlock]
    deconstruct FindDefaults
        1
    construct EndBlocks [repeat switch_alternative]
        RSA [select 2 999]
    construct DefaultEnds [number]
        DefaultEnd [findDefaultEnd each EndBlocks]
    construct Defaults [repeat switch_alternative]
        RSA [select 1 DefaultEnds]
    construct DefaultEndss [number]
        DefaultEnds [+ 1]
    construct EndDefault [repeat switch_alternative]
        RSA [select DefaultEndss 9999]
    construct NRSA [repeat switch_alternative]
        _ [. EndDefault] [. Defaults]
    by 
        NRSA 
end function

function findDefaultEnd SA [switch_alternative]
    replace [number]
        N [number]
    import CaseDefaultIndex [number]
    construct TestSA [switch_alternative]
        SA [setDefaultNextIndex]
    deconstruct CaseDefaultIndex
        0
    by 
        N [+ 1]
end function

function setDefaultNextIndex
    replace [switch_alternative]
        SA [switch_alternative]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    deconstruct SL
        'case CE [list constant_expression+] CA [colon_or_arrow]
    export CaseDefaultIndex [number]
        1
    by 
        SA 
end function

function findDefaultStart SA [switch_alternative]
    replace [number]
        N [number]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    deconstruct SL
        'default CA [colon_or_arrow]
    by 
        1
end function

function caseCreateElseStatement RIf [repeat if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    construct LenRIf [number]
        _ [length RIf]
    construct LastRIf [repeat if_statement]
        RIf [select LenRIf LenRIf]
    deconstruct LastRIf
        LRIf [if_statement]
    construct Else1 [repeat else_clause]
        _ [createElse1Statement LRIf]
    construct Else2 [repeat else_clause]
        _ [createElse2Statement LRIf]
    by 
        RES [. Else1] [. Else2]
end function 

function createElse1Statement LRIf [if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct LRIf
        'if '( RC [repeat condition] ') S [statement]
    construct LenRC [number]
        _ [length RC]
    where
        LenRC [> 1]
    construct Else [else_clause]
        'else S
    by 
        RES [. Else]
end function

function createElse2Statement LRIf [if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct LRIf
        'if '( RC [repeat condition] ') S [statement]
    construct LenRC [number]
        _ [length RC]
    where
        LenRC [= 1]
    construct Else [else_clause]
        'else '; % Empty else for non-default cases without subsequent conditions
    by 
        RES [. Else]
end function

function caseCreateElseIfStatement IfS [if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct IfS
        'if '( RC [repeat condition] ') S [statement]
    construct LenRC [number]
        _ [length RC]
    export LenRCE [number]
        LenRC
    where 
        LenRC [= 1]
    construct ElseIf [else_clause]
        'else IfS
    by 
        RES [. ElseIf]
end function

function createRepeatIfStatements Ex [expression] SA [repeat switch_alternative]
    replace [repeat if_statement]
        If [repeat if_statement]
    construct FirstSA [repeat switch_alternative]
        SA [select 1 1]
    construct CaseConstant [repeat constant_expression]
        _ [fromSwitchAlternativeGetConstantExpression each FirstSA]
    export tillBreak [number]
        0
    construct CaseStatement [repeat declaration_or_statement]
        _ [getCaseIncludeStatement each SA]
    construct IfSubStatement [statement]
        '{ CaseStatement '}
    construct IfConditions [repeat condition]
        _ [createIfCondition Ex CaseConstant]
    construct IFStatement [if_statement]
        'if '( IfConditions ') IfSubStatement
    import RIf [repeat if_statement]
    export RIf
        _ [. RIf] [. IFStatement]
    construct SALength [number]
        _ [length SA]
    where 
        SALength [> 1]
    construct RestSA [repeat switch_alternative]
        SA [tail 2]
    export CaseIndex [number]
        0 
    construct IndexStart [number]
        1
    construct NextCaseIndex [number]
        IndexStart [getNextCaseIndex each RestSA]
    import CaseIndex
    where 
        CaseIndex [= 1]
    construct RestSACase [repeat switch_alternative]
        SA [tail NextCaseIndex]
    by  
        If [. IFStatement] [createRepeatIfStatements Ex RestSACase]
end function

function createIfCondition Ex [expression] CaseConstant [repeat constant_expression]
    replace [repeat condition]
        C [repeat condition]
    construct DefaultCondition [repeat condition]
        _ [createDefaultCondition Ex CaseConstant]
    construct CaseCondition [condition]
        0
    construct NewCaseCondition [condition]   
        CaseCondition [createCaseCondition Ex CaseConstant]
    by 
        C [. DefaultCondition] [. NewCaseCondition]
end function

function createCaseCondition Ex [expression] CaseConstant [repeat constant_expression]
    replace [condition]
        C [condition]
    construct CaseConstantLength [number]
        _ [length CaseConstant]
    where 
        CaseConstantLength [> 0]
    construct CaseConstantFirst [repeat constant_expression]
        CaseConstant [select 1 1]
    deconstruct CaseConstantFirst
        CaseConstantFirstOne [constant_expression]
    construct LogicalAndExpression [logical_AND_expression]
        0
    construct NewLogicalAndExpression [logical_AND_expression]
        LogicalAndExpression [createLogicalAndExpression Ex CaseConstantFirstOne]
    export Exs [expression]
        Ex 
    construct CaseConstantRest [repeat constant_expression]
        CaseConstant [tail 2]
    construct OrLogicalAndExpression [repeat OR_logical_AND_expression]
        _ [createOrLogicalAndExpression each CaseConstantRest]
    construct LOE [logical_OR_expression]
        NewLogicalAndExpression OrLogicalAndExpression
    by 
        LOE
end function

function createOrLogicalAndExpression CE [constant_expression]
    replace [repeat OR_logical_AND_expression]
        OLAE [repeat OR_logical_AND_expression] 
    construct LAE [logical_AND_expression]
        0
    import Exs [expression]
    construct NewLAE [logical_AND_expression]
        LAE [createLogicalAndExpression Exs CE]
    construct NewOLAE [OR_logical_AND_expression]
        '|| NewLAE
    by 
        OLAE [. NewOLAE]
end function

function createLogicalAndExpression Ex [expression] CaseConstantFirst [constant_expression]
    replace [logical_AND_expression]
        LAE [logical_AND_expression]
    construct EqualityOperator [equality_operator]
        '==
    construct EqualityExpression [equality_expression]
        Ex EqualityOperator CaseConstantFirst
    construct NewLAE [logical_AND_expression]
        EqualityExpression
    by 
        NewLAE 
end function

function createDefaultCondition Ex [expression] CaseConstant [repeat constant_expression]
    replace [repeat condition]
        C [repeat condition]
    construct CaseConstantLength [number]
        _ [length CaseConstant]
    where 
        CaseConstantLength [= 0]
    construct DC [condition]  
        Ex
    by 
        C [. DC]
end function

function getCaseIncludeStatement SA [switch_alternative]
    replace [repeat declaration_or_statement] 
        RDS [repeat declaration_or_statement]
    import tillBreak [number]
    where 
        tillBreak [= 0]
    construct DS [repeat declaration_or_statement]
        _ [getCaseStatement SA]
    construct DSContinue [repeat declaration_or_statement]
        _ [getCaseStatementContinue SA]
    by 
        RDS [. DS] [. DSContinue]
end function

function getCaseStatementContinue SA [switch_alternative]
    replace [repeat declaration_or_statement]
        RDS [repeat declaration_or_statement]
    import tillBreak [number]
    where 
        tillBreak [= 0]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    deconstruct SL
        'case CE [list constant_expression+] CA [colon_or_arrow]
    by 
        RDS [. DS]
end function    

function getCaseStatement SA [switch_alternative]
    replace [repeat declaration_or_statement]
        RDS [repeat declaration_or_statement]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    construct NewDS [repeat declaration_or_statement]
        DS [setBreakLabel]
    import tillBreak [number]
    where 
        tillBreak [= 0]
    by 
        RDS [. NewDS]
end function

function setBreakLabel
    replace [repeat declaration_or_statement]
        RDS [repeat declaration_or_statement]
    construct Breaks [repeat break_statement]
        _ [^ RDS]
    construct LenBreaks [number]
        _ [length Breaks]
    where 
        LenBreaks [> 0]
    export tillBreak [number]
        1
    construct FilteredRDS [repeat declaration_or_statement]
        _ [filterOutBreak each RDS]
    by 
        FilteredRDS
end function

function filterOutBreak DS [declaration_or_statement]
    replace [repeat declaration_or_statement]
        RDS [repeat declaration_or_statement]
    construct IsBreak [number]
        0 [checkIfBreak DS]
    where
        IsBreak [= 0]
    by
        RDS [. DS]
end function

function checkIfBreak DS [declaration_or_statement]
    replace [number]
        N [number]
    deconstruct DS
        S [statement]
    deconstruct S
        'break ';
    by 
        1
end function

function getNextCaseIndex OneSA [switch_alternative]
    replace [number]
        N [number]
    import CaseIndex [number]
    where
        CaseIndex [= 0]
    construct TestOneSA [switch_alternative]
        OneSA [setIndexLabel]    
    by 
        N [+ 1]
end function

function setIndexLabel
    replace [switch_alternative]
        SA [switch_alternative]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    deconstruct SL
        'case CE [list constant_expression+] CA [colon_or_arrow]
    export CaseIndex [number]
        1
    by
        SA
end function

function fromSwitchAlternativeGetConstantExpression SA [switch_alternative]
    replace [repeat constant_expression]
        CE [repeat constant_expression]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    construct RCE [repeat constant_expression]
        _ [extractConstantExpression SL]
    by 
        CE [. RCE]
end function 

function extractConstantExpression SL [switch_label]
    replace [repeat constant_expression]
        CE [repeat constant_expression]
    deconstruct SL
        'case CE [list constant_expression+] CA [colon_or_arrow]
    by 
        CE [. CE]
end function
% switch 转换成 if-else-if 语句结束
% ----------------------------------------------------------------
% Txl v10.8 (7.5.20) (c) 1988-2020 Queen's University at Kingston
% statements 
% version 20200924
% 这个文件的主要功能是实现代码statement, expression等自身发生的变化

include "java.grm"
% Note: "extract_id.Txl" is commented out in the original and assumed unavailable; omitted here

% ----------------------------------------------------------------
% 重定义结构以支持变换
redefine while_statement
    ... 
    | [expression] ';[NL] 'while '( [condition] ') [statement] % Adjusted for Java
    | '; [NL] [repeat declaration_or_statement] 'while '( [expression] ') [statement] % For do-while/for conversions
end redefine

redefine statement
    ... 
    | '{ [repeat statement] '} % Replaces sub_statement for Java blocks
end redefine

define n_statement
    [repeat declaration_or_statement] % Adjusted for Java block content
end define

redefine else_clause
    ... 
    | [repeat declaration_or_statement] % Replaces else_sub_statement for Java
end redefine

redefine if_statement
    ... 
    | 'if '( [repeat condition] ') [statement]
    | [if_statement] [repeat else_clause] % Java if-else structure
end redefine

redefine expression_statement
    ... 
    | [assignment_expression] '= [assignment_expression] [add_op] [assignment_expression] % Simplified for Java compound assignments
    | [assignment_expression] '= [assignment_expression] [mult_op] [assignment_expression]
    | [assignment_expression] '= [assignment_expression] [shift_op] [assignment_expression]
    | [assignment_expression] '= [assignment_expression] [bit_AND_operator] [assignment_expression]
    | [assignment_expression] '= [assignment_expression] [bit_XOR_operator] [assignment_expression]
    | [assignment_expression] '= [assignment_expression] [bit_OR_operator] [assignment_expression]
end redefine

redefine numeric_literal
    ... 
    | '( [number] '+ '1 '+ '2 '* '5 '- '1 ') % Unified for Java integer constants
    | '( [floatnumber] '+ 3 '* 4 '+ 0.0 '- 12 ') % Unified for Java floating-point constants
end redefine
% 重定义结构结束
% ----------------------------------------------------------------

% 主函数开始
function main
    replace [package_declaration]
        P [package_declaration]
    by 
        P [changeFunction] 
end function

% 修改每个方法
function changeFunction
    replace [package_declaration]
        P [package_declaration]
    construct Methods [repeat method_declaration]
        _ [^ P]
    construct NewMethods [repeat method_declaration]
        _ [changeMethodDefinition each Methods]
    by 
        P [replaceMethod each Methods NewMethods]
end function

function replaceMethod MD [method_declaration] NewMD [method_declaration]
    replace [package_declaration]
        P [package_declaration]
    by  
        P [$ MD NewMD]
end function

function changeMethodDefinition MD [method_declaration]
    replace [repeat method_declaration]
        RMethodDefine [repeat method_declaration]
    construct NewMD [method_declaration]
        MD [translateJavaMethod]
    by 
        RMethodDefine [. NewMD]
end function

function translateJavaMethod
    replace $[method_declaration]
        Modifiers [repeat modifier] Gen [opt generic_parameter] 
        Type [type_specifier] Declarator [method_declarator] 
        Throws [opt throws] Body [method_body]
    by
        Modifiers Gen Type Declarator Throws 
        Body [changeCompound]
end function

function changeCompound
    replace [method_body]
        '{ RS [repeat declaration_or_statement] '} % Java block
    by 
        '{ RS [changeCompoundStatementBody] '}
    |
    replace [method_body]
        '; % Abstract method
    by 
        ';
    |
    replace [method_body]
        'default Value [annotation_value] ';
    by 
        'default Value ';
end function

function changeCompoundStatementBody
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    by
        CSB 
        %[changeCompoundLogicalOperator]
        %[changeCompoundDoWhile]
        %[changeCompoundSwitch]
        %[changeCompoundFor0]
        %[changeCompoundFor1]
        %[changeCompoundWhile]
        %[changeCompoundIncrement]
        %[changeSelfOperatorExpression]
        %[changeSelfOperatorExpressionStatement]
        %[changeCompoundIf]
        %[changeConstants]
        %[changeAddJunkCode]
        [changeDeleteCode]
end function 
% 主函数结束
% ----------------------------------------------------------------

% 所有操作的主函数
function changeDeleteCode
    replace [repeat declaration_or_statement]
        CST [repeat declaration_or_statement]
    by 
        CST [deletePrintStatement]
end function

function deletePrintStatement 
    replace [repeat declaration_or_statement] 
        CSB [repeat declaration_or_statement]
    construct AllCSB [repeat repeat declaration_or_statement]
        _ [^ CSB]
    construct NAllCSB [repeat repeat declaration_or_statement]
        _ [deletePrint each AllCSB]
    construct NCSB [repeat declaration_or_statement]
        CSB [replaceCompoundStatementBody each AllCSB NAllCSB]
    construct ALLStatement [repeat statement]
        _ [^ CSB]
    construct NAllStatement [repeat statement]
        _ [deleteStatementPrint each ALLStatement]
    by 
        NCSB [replaceStatementPrint each ALLStatement NAllStatement]
end function

function replaceStatementPrint Old [statement] New [statement]
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    by  
        CSB [$ Old New]
end function

function deleteStatementPrint St [statement]
    replace [repeat statement]
        RST [repeat statement]
    construct NSt [statement]
        St [testStatementPrint]
    by  
        RST [. NSt]
end function

function testStatementPrint 
    replace [statement]
        St [statement]
    deconstruct St 
        'System '.' 'out '.' 'println '( Args [list expression] ') ';
    by
        ';
end function

function replaceCompoundStatementBody Old [repeat declaration_or_statement] New [repeat declaration_or_statement]
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    by 
        CSB [$ Old New]
end function

function deletePrint CSB [repeat declaration_or_statement]
    replace [repeat repeat declaration_or_statement]
        RCSB [repeat repeat declaration_or_statement]
    construct AllPrint [repeat declaration_or_statement]
        _ [isPrintDelete each CSB]
    construct NAllPrint [repeat declaration_or_statement]
        AllPrint [isStatementPrint each CSB]
    export NAllPrint
    construct NRBI [repeat declaration_or_statement]
        _ [isdeleteItem each CSB]
    construct NCSB [repeat declaration_or_statement]
        NRBI
    by 
        RCSB [. NCSB]
end function

function isStatementPrint BI [declaration_or_statement]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    deconstruct BI
        St [statement]
    deconstruct St 
        'System '.' 'out '.' 'println '( Args [list expression] ') ';
    by 
        RBI [. BI]
end function 

function isdeleteItem DeleteBI [declaration_or_statement]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    import NAllPrint [repeat declaration_or_statement]
    construct IsPrint [number]
        0
    export DeleteBI
    construct NIsPrint [number]
        IsPrint [isItemEqualPrint each NAllPrint]
    where
        NIsPrint [= 0]
    by
        RBI [. DeleteBI]
end function

function isItemEqualPrint BI [declaration_or_statement]
    replace [number]
        N [number]
    import DeleteBI [declaration_or_statement]
    where 
        DeleteBI [= BI]
    by 
        N [+ 1]    
end function

function isPrintDelete BI [declaration_or_statement]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    deconstruct BI 
        Decl [declaration]
    export Printf [id]
        'System
    construct AllDeclID [repeat id]
        _ [^ Decl]
    construct NPrint [repeat id]
        _ [IsContainPrint each AllDeclID]
    construct LenNPrint [number]
        _ [length NPrint]
    where
        LenNPrint [> 0]
    by 
        RBI [. BI]
end function

function IsContainPrint ID [id]
    replace [repeat id]
        RID [repeat id]
    import Printf [id]
    where 
        Printf [= ID]
    by 
        RID [. ID]
end function
% 删除代码结束
% ----------------------------------------------------------------

% 添加垃圾代码
rule addJunkCode
    replace $[repeat declaration_or_statement]
        Dos [repeat declaration_or_statement]
    import JunkNum [number]
    construct DosLenHalf [number]
        _ [length Dos] [/ 2] [round]
    construct DosLenHalfPlusOne [number]
        DosLenHalf [+ 1]
    construct DosFront [repeat declaration_or_statement]
        Dos [select 1 DosLenHalf]
    construct DosRear [repeat declaration_or_statement]
        Dos [select DosLenHalfPlusOne 9999]
    construct JunkCode [repeat declaration_or_statement]
        _ [addJunk1] [addJunk2] [addJunk3]
    construct NDos [repeat declaration_or_statement]
        _ [. DosFront] [. JunkCode] [. DosRear]
    construct NJunkNum [number]
        JunkNum [+ 1]
    export JunkNum [number]
        NJunkNum
    by 
        NDos 
end rule 

function addJunk1
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    import JunkNum [number]
    where 
        JunkNum [= 1]
    construct JunkCode [declaration_or_statement]
        0
    construct NJunkCode [declaration_or_statement]
        JunkCode [createJunkCodeCase1]
    by
        RBI [. NJunkCode]
end function

function addJunk2
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    import JunkNum [number]
    where 
        JunkNum [= 4]
    construct JunkCode [declaration_or_statement]
        0
    construct NJunkCode [declaration_or_statement]
        JunkCode [createJunkCodeCase2]
    by
        RBI [. NJunkCode]
end function

function addJunk3
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    import JunkNum [number]
    where 
        JunkNum [= 6]
    construct JunkCode [declaration_or_statement]
        0
    construct NJunkCode [declaration_or_statement]
        JunkCode [createJunkCodeCase3]
    by
        RBI [. NJunkCode]
end function

function createJunkCodeCase1
    replace [declaration_or_statement]
        BI [declaration_or_statement]
    construct NBI [declaration_or_statement]
        'if '( 0 ')
        '{
            'int 'x ',' 'y ';
            'y '= 2 ';
            'x '= 1 ';
            'for '( 'x '= 0 '; 'x '< 20 '; 'x '++ ')
            '{
                'y '+= 'x ';
                'y '*= 2 ';
            '}
            'if '( 'y '> 30 ')
                'return 'y ';
        '}
    by 
        NBI
end function

function createJunkCodeCase2
    replace [declaration_or_statement]
        BI [declaration_or_statement]
    construct NBI [declaration_or_statement]
        'if '( 0 ')
        '{
            'return ';
        '}
    by 
        NBI
end function

function createJunkCodeCase3
    replace [declaration_or_statement]
        BI [declaration_or_statement]
    construct NBI [declaration_or_statement]
        'if '( 1 ')
        '{
            'int 'm '= 0 ';
            'int 'n '= 0 ';
            'm '= 'm '* 'n '+ 'n '- 'm '+ 'n '* 2 ';
        '}
    by 
        NBI
end function
% 添加垃圾代码结束
% ----------------------------------------------------------------

% 修改常量
function changeConstants
    replace [repeat declaration_or_statement]
        St [repeat declaration_or_statement]
    by
        St [changeNumericConstant]
end function

function changeNumericConstant
    replace [repeat declaration_or_statement]
        St [repeat declaration_or_statement]
    construct NumericConstant [repeat numeric_literal]
        _ [^ St]
    construct NewNumericConstant [repeat numeric_literal]
        _ [createNewNumericConstant each NumericConstant]
    by  
        St [replaceNumericConstant each NumericConstant NewNumericConstant]
end function

function replaceNumericConstant IC [numeric_literal] NIC [numeric_literal]
    replace [repeat declaration_or_statement]
        St [repeat declaration_or_statement]
    by
        St [$ IC NIC]
end function 

function createNewNumericConstant NL [numeric_literal]
    replace [repeat numeric_literal]
        RNL [repeat numeric_literal]
    construct NewNL [numeric_literal]
        NL [createNewIC] [createNewFC]
    by 
        RNL [. NewNL]
end function

function createNewIC
    replace [numeric_literal]
        NL [numeric_literal]
    deconstruct NL
        ICN [number]
    construct ICSubTen [number]
        ICN [- 10]
    construct NewNL [numeric_literal]
        '( ICSubTen '+ '1 '+ '2 '* '5 '- '1 ')
    by 
        NewNL 
end function

function createNewFC
    replace [numeric_literal]
        NL [numeric_literal]
    deconstruct NL
        F [floatnumber]
    construct NewNL [numeric_literal]
        '( F '+ 3 '* 4 '+ 0.0 '- 12 ')
    by 
        NewNL
end function
% 常量修改结束
% ----------------------------------------------------------------

% 增量操作转换
function changeCompoundIncrement
    replace [repeat declaration_or_statement]
        St [repeat declaration_or_statement]
    construct RES [repeat expression_statement]
        _ [^ St]
    construct NewRES [repeat expression_statement]
        _ [createNewIncrementAssignment each RES]
    by 
        St [replaceExpressionStatement each RES NewRES]
end function

function createNewIncrementAssignment ES [expression_statement]
    replace [repeat expression_statement]
        RES [repeat expression_statement]
    construct NewES [expression_statement]
        ES [incrementAssignmentAdd] 
           [incrementAssignmentSub] 
           [incrementAssignmentMul] 
           [incrementAssignmentDiv] 
           [incrementAssignmentMod] 
           [incrementAssignmentLeftShift] 
           [incrementAssignmentRightShift] 
           [incrementAssignmentAnd] 
           [incrementAssignmentXor] 
           [incrementAssignmentOr]
    by 
        RES [. NewES]
end function

function incrementAssignmentAdd
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '+= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '+ AER ';
    by 
        NewES
end function

function incrementAssignmentSub
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '-= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '- AER ';
    by 
        NewES
end function

function incrementAssignmentMul
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '*= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '* AER ';
    by 
        NewES
end function

function incrementAssignmentDiv
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '/= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '/ AER ';
    by 
        NewES
end function

function incrementAssignmentMod
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '%= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '% AER ';
    by 
        NewES
end function

function incrementAssignmentLeftShift
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '<<= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '<< AER ';
    by 
        NewES
end function

function incrementAssignmentRightShift
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '>>= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '>> AER ';
    by 
        NewES
end function

function incrementAssignmentAnd
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '&= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '& AER ';
    by 
        NewES
end function

function incrementAssignmentXor
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '^= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '^ AER ';
    by 
        NewES
end function

function incrementAssignmentOr
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '|= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '| AER ';
    by 
        NewES
end function
% 增量操作转换结束
% ----------------------------------------------------------------

% 自增自减操作
function changeSelfOperatorExpression
    replace [repeat declaration_or_statement]
        St [repeat declaration_or_statement]
    construct IOE [repeat expression]
        _ [^ St]
    construct NewIOE [repeat expression]
        _ [changeExpressionSelfOperator each IOE]
    by 
        St [replaceSelfOperatorExpression each IOE NewIOE]
end function

function changeSelfOperatorExpressionStatement
    replace [repeat declaration_or_statement]
        St [repeat declaration_or_statement]
    construct IOE [repeat expression_statement]
        _ [^ St]
    construct NewIOE [repeat expression_statement]
        _ [changeExpressionStatementSelfOperator each IOE]
    by 
        St [replaceExpressionStatement each IOE NewIOE]
end function 

function replaceSelfOperatorExpression E [expression] NE [expression]
    replace [repeat declaration_or_statement]
        St [repeat declaration_or_statement]
    by 
        St [$ E NE]
end function

function changeExpressionSelfOperator SOper [expression]
    replace [repeat expression]
        RPE [repeat expression]
    construct NewSOper [expression]
        SOper [changeSOperPlus] [changeSOperSub] [changeSOperPlusBefore] [changeSOperSubBefore]
    by 
        RPE [. NewSOper]
end function

function changeSOperPlusBefore
    replace [expression]
        E [expression]
    deconstruct E
        '++ PE [postfix_expression]
    construct NewE [expression]
        PE '= PE '+ 1
    by 
        NewE
end function 

function changeSOperSubBefore
    replace [expression]
        E [expression]
    deconstruct E
        '-- PE [postfix_expression]
    construct NewE [expression]
        PE '= PE '- 1
    by 
        NewE
end function 

function changeSOperPlus
    replace [expression]
        E [expression]
    deconstruct E
        PE [primary] '++
    construct NewE [expression]
        PE '= PE '+ 1
    by 
        NewE
end function 

function changeSOperSub
    replace [expression]
        E [expression]
    deconstruct E
        PE [primary] '--
    construct NewE [expression]
        PE '= PE '- 1
    by 
        NewE
end function 

function replaceExpressionStatement E [expression_statement] NE [expression_statement]
    replace [repeat declaration_or_statement]
        St [repeat declaration_or_statement]
    by 
        St [$ E NE]
end function

function changeExpressionStatementSelfOperator SOper [expression_statement]
    replace [repeat expression_statement]
        RPE [repeat expression_statement]
    construct NewSOper [expression_statement]
        SOper [changeESOperPlus] [changeESOperSub] 
              [changeESOperSubBefore] [changeESOperPlusBefore]
    by 
        RPE [. NewSOper]
end function

function changeESOperPlusBefore
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        '++ PE [postfix_expression] ';
    construct NewE [expression_statement]
        PE '= PE '+ 1 ';
    by 
        NewE
end function 

function changeESOperSubBefore
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        '-- PE [postfix_expression] ';
    construct NewE [expression_statement]
        PE '= PE '- 1 ';
    by 
        NewE
end function 

function changeESOperPlus
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        PE [primary] '++ ';
    construct NewE [expression_statement]
        PE '= PE '+ 1 ';
    by 
        NewE
end function 

function changeESOperSub
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        PE [primary] '-- ';
    construct NewE [expression_statement]
        PE '= PE '- 1 ';
    by 
        NewE
end function 
% 自增自减操作结束
% ----------------------------------------------------------------

% 逻辑表达式修改
function changeCompoundLogicalOperator
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    construct RIOE [repeat inclusive_or_expression]
        _ [^ CSB]
    construct NewRIOE [repeat inclusive_or_expression]
        _ [changeInclusiveORExpression1 each RIOE]
    by 
        CSB [replaceInclusiveORExpression each RIOE NewRIOE]  
end function 

function changeInclusiveORExpression1 IOE [inclusive_or_expression]
    replace [repeat inclusive_or_expression]
        RIOE [repeat inclusive_or_expression]
    export IsBlow [number]
        0
    export IsBlowEqual [number]
        0
    export IsEqual [number]
        0
    construct NewIOE [inclusive_or_expression]
        IOE [createNewIOEBlow1] [createNewIOEGreat1] 
            [createNewIOEBlowEqual1] [createNewIOEGreatEqual1] 
            [createNewIoEqual] [createNewIoNotEqual]
    by 
       RIOE [. NewIOE]
end function

function createNewIOEBlow1
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '< SE2 [shift_expression]
    construct NewIOE [inclusive_or_expression]
        SE2 '> SE1
    export IsBlow [number]
        1
    by 
        NewIOE 
end function

function createNewIOEGreat1
    import IsBlow [number]
    where
        IsBlow [= 0]
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '> SE2 [shift_expression]
    construct NewIOE [inclusive_or_expression]
        SE2 '< SE1
    by 
        NewIOE 
end function

function createNewIOEBlowEqual1
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '<= SE2 [shift_expression]
    construct NewIOE [inclusive_or_expression]
        SE2 '>= SE1
    export IsBlowEqual [number]
        1
    by 
        NewIOE 
end function

function createNewIOEGreatEqual1
    import IsBlowEqual [number]
    where
        IsBlowEqual [= 0]
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '>= SE2 [shift_expression]
    construct NewIOE [inclusive_or_expression]
        SE2 '<= SE1
    by 
        NewIOE 
end function

function createNewIoNotEqual
    import IsEqual [number]
    where 
        IsEqual [= 0]
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '!= SE2 [shift_expression]
    construct Expression [inclusive_or_expression]
        SE2 '== SE1
    construct ListExpression [list expression]
        Expression
    construct PE [parenthesized_expression]
        '( ListExpression ')
    construct NewIOE [inclusive_or_expression]
        '! PE
    by 
        NewIOE 
end function

function createNewIoEqual
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '== SE2 [shift_expression]
    construct Expression [inclusive_or_expression]
        SE2 '!= SE1
    construct ListExpression [list expression]
        Expression
    construct PE [parenthesized_expression]
        '( ListExpression ')
    construct NewIOE [inclusive_or_expression]
        '! PE
    export IsEqual [number]
        1
    by 
        NewIOE 
end function

function replaceInclusiveORExpression OldIOE [inclusive_or_expression] NewIOE [inclusive_or_expression]
    replace [repeat declaration_or_statement]
        C [repeat declaration_or_statement]
    by 
        C [$ OldIOE NewIOE]
end function
% 逻辑表达式修改结束
% ----------------------------------------------------------------

% Do-while 到 While 转换
function changeCompoundDoWhile 
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    construct DoWhile [repeat do_statement]
        _ [^ CSB]
    construct NDoWhile [repeat statement]
        _ [changeDoWhileStatement each DoWhile]
    by
        CSB [replaceStatement each DoWhile NDoWhile] 
end function

function changeDoWhileStatement DS [do_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct ST [statement]
        DS    
    construct NST [statement]
        ST [newDoStatement]
    by 
        RS [. NST]
end function

function newDoStatement
    replace [statement]
        DS [do_statement]
    deconstruct DS
        'do S [statement] 'while '( C [condition] ') ';
    deconstruct S
        '{ RS [repeat declaration_or_statement] '}
    construct While [while_statement]
        '; RS 'while '( C ') S
    by 
        While
end function
% Do-while 转换结束
% ----------------------------------------------------------------

% Switch 到 If-else 转换
function changeCompoundSwitch
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    construct S [repeat switch_statement]
        _ [^ CSB]
    construct NewS [repeat statement]
        _ [changeSwitchStatement each S]
    by
        CSB [replaceStatement each S NewS]
end function

function changeSwitchStatement Switch [switch_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct S [statement]
        Switch
    construct NS [statement]
        S [newSwitchStatement]
    by 
        RS [. NS]
end function

function newSwitchStatement
    replace [statement]
        Switch [switch_statement]
    deconstruct Switch
        'switch '( Ex [expression] ') SB [switch_block]
    deconstruct SB
        '{ SA [repeat switch_alternative] '}
    export RIf [repeat if_statement]
        _
    construct ORIf [repeat if_statement]
        _ [createRepeatIfStatements Ex SA]
    import RIf
    construct OneRIf [repeat if_statement]
        RIf [select 1 1]
    deconstruct OneRIf  
        IfS [if_statement]
    construct RestRIf [repeat if_statement]
        RIf [select 2 999]
    construct ElseIf [repeat else_clause]
        _ [caseCreateElseIfStatement each RestRIf]
    construct NewEIf [repeat else_clause]
        ElseIf [caseCreateElseStatement RestRIf]
    construct IfStatement [if_statement]
        IfS NewEIf
    by 
        IfStatement
end function

function caseCreateElseStatement RIf [repeat if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    construct LenRIf [number]
        _ [length RIf]
    construct LastRIf [repeat if_statement]
        RIf [select LenRIf LenRIf]
    deconstruct LastRIf
        LRIf [if_statement]
    construct Else1 [repeat else_clause]
        _ [createElse1Statement LRIf]
    construct Else2 [repeat else_clause]
        _ [createElse2Statement LRIf]
    by 
        RES [. Else1] [. Else2]
end function 

function createElse1Statement LRIf [if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct LRIf
        'if '( RC [repeat condition] ') SS [statement]
    construct LenRC [number]
        _ [length RC]
    where
        LenRC [> 1]
    construct Else [else_clause]
        'else SS
    by 
        RES [. Else]
end function

function createElse2Statement LRIf [if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct LRIf
        'if '( RC [repeat condition] ') SS [statement]
    construct LenRC [number]
        _ [length RC]
    where
        LenRC [= 1]
    construct Else [else_clause]
        'else ';
    by 
        RES [. Else]
end function

function caseCreateElseIfStatement IfS [if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct IfS
        'if '( RC [repeat condition] ') SS [statement]
    construct LenRC [number]
        _ [length RC]
    where 
        LenRC [= 1]
    construct ElseIf [else_clause]
        'else IfS
    by 
        RES [. ElseIf]
end function

function createRepeatIfStatements Ex [expression] SA [repeat switch_alternative]
    replace [repeat if_statement]
        If [repeat if_statement]
    construct FirstSA [repeat switch_alternative]
        SA [select 1 1]
    construct CaseConstant [repeat constant_expression]
        _ [fromSwitchAlternativeGetConstantExpression each FirstSA]
    export tillBreak [number]
        0
    construct CaseStatement [repeat declaration_or_statement]
        _ [getCaseIncludeStatement each SA]
    construct IfSubStatement [statement]
        '{ CaseStatement '}
    construct IfConditions [repeat condition]
        _ [createIfCondition Ex CaseConstant]
    construct IFStatement [if_statement]
        'if '( IfConditions ') IfSubStatement
    import RIf [repeat if_statement]
    export RIf
        _ [. RIf] [. IFStatement]
    construct SALength [number]
        _ [length SA]
    where 
        SALength [> 1]
    construct RestSA [repeat switch_alternative]
        SA [tail 2]
    export CaseIndex [number]
        0 
    construct IndexStart [number]
        1
    construct NextCaseIndex [number]
        IndexStart [getNextCaseIndex each RestSA]
    import CaseIndex
    construct RestSACase [repeat switch_alternative]
        SA [tail NextCaseIndex]
    by  
        If [. IFStatement] [createRepeatIfStatements Ex RestSACase]
end function

function createIfCondition Ex [expression] CaseConstant [repeat constant_expression]
    replace [repeat condition]
        C [repeat condition]
    construct DefaultCondition [repeat condition]
        _ [createDefaultCondition Ex CaseConstant]
    construct CaseCondition [condition]
        0
    construct NewCaseCondition [condition]   
        CaseCondition [createCaseCondition Ex CaseConstant]
    by 
        C [. DefaultCondition] [. NewCaseCondition]
end function

function createCaseCondition Ex [expression] CaseConstant [repeat constant_expression]
    replace [condition]
        C [condition]
    construct CaseConstantLength [number]
        _ [length CaseConstant]
    where 
        CaseConstantLength [> 0]
    construct CaseConstantFirst [repeat constant_expression]
        CaseConstant [select 1 1]
    deconstruct CaseConstantFirst
        CaseConstantFirstOne [constant_expression]
    construct LogicalAndExpression [logical_AND_expression]
        0
    construct NewLogicalAndExpression [logical_AND_expression]
        LogicalAndExpression [createLogicalAndExpression Ex CaseConstantFirstOne]
    export Exs [expression]
        Ex 
    construct CaseConstantRest [repeat constant_expression]
        CaseConstant [tail 2]
    construct OrLogicalAndExpression [repeat OR_logical_AND_expression]
        _ [createOrLogicalAndExpression each CaseConstantRest]
    construct LOE [logical_OR_expression]
        NewLogicalAndExpression OrLogicalAndExpression
    by 
        LOE
end function

function createOrLogicalAndExpression CE [constant_expression]
    replace [repeat OR_logical_AND_expression]
        OLAE [repeat OR_logical_AND_expression] 
    construct LAE [logical_AND_expression]
        0
    import Exs [expression]
    construct NewLAE [logical_AND_expression]
        LAE [createLogicalAndExpression Exs CE] 
    construct NewOLAE [OR_logical_AND_expression]
        '|| NewLAE
    by 
        OLAE [. NewOLAE]
end function

function createLogicalAndExpression Ex [expression] CaseConstantFirst [constant_expression]
    replace [logical_AND_expression]
        LAE [logical_AND_expression]
    construct EqualityOperator [equality_operator]
        '==
    construct EqualityExpression [equality_expression]
        Ex EqualityOperator CaseConstantFirst
    construct NewLAE [logical_AND_expression]
        EqualityExpression
    by 
        NewLAE 
end function

function createDefaultCondition Ex [expression] CaseConstant [repeat constant_expression]
    replace [repeat condition]
        C [repeat condition]
    construct CaseConstantLength [number]
        _ [length CaseConstant]
    where 
        CaseConstantLength [= 0]
    construct DC [condition]  
        Ex
    by 
        C [. DC]
end function

function getCaseIncludeStatement SA [switch_alternative]
    replace [repeat declaration_or_statement] 
        RItems [repeat declaration_or_statement]
    import tillBreak [number]
    where 
        tillBreak [= 0]
    construct CaseStatement [repeat declaration_or_statement]
        _ [getCaseStatement SA]
    construct CaseStatementContinue [repeat declaration_or_statement]
        _ [getCaseStatementContinue SA]
    by 
        RItems [. CaseStatement] [. CaseStatementContinue]
end function

function getCaseStatementContinue SA [switch_alternative]
    replace [repeat declaration_or_statement]
        RItems [repeat declaration_or_statement]
    import tillBreak [number]
    where 
        tillBreak [= 0]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    deconstruct SL
        'case CE [list constant_expression+] CA [colon_or_arrow]
    by 
        RItems [. DS]
end function    

function getCaseStatement SA [switch_alternative]
    replace [repeat declaration_or_statement]
        RItems [repeat declaration_or_statement]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    construct NewDS [repeat declaration_or_statement]
        DS [setBreakLabel]
    import tillBreak [number]
    where 
        tillBreak [= 0]
    by 
        RItems [. NewDS]
end function

function setBreakLabel
    replace [repeat declaration_or_statement]
        RDS [repeat declaration_or_statement]
    construct Breaks [repeat break_statement]
        _ [^ RDS]
    construct LenBreaks [number]
        _ [length Breaks]
    where 
        LenBreaks [> 0]
    export tillBreak [number]
        1
    construct FilteredRDS [repeat declaration_or_statement]
        _ [filterOutBreak each RDS]
    by 
        FilteredRDS
end function

function filterOutBreak DS [declaration_or_statement]
    replace [repeat declaration_or_statement]
        RDS [repeat declaration_or_statement]
    construct IsBreak [number]
        0 [checkIfBreak DS]
    where
        IsBreak [= 0]
    by
        RDS [. DS]
end function

function checkIfBreak DS [declaration_or_statement]
    replace [number]
        N [number]
    deconstruct DS
        S [statement]
    deconstruct S
        'break ';
    by 
        1
end function

function getNextCaseIndex OneSA [switch_alternative]
    replace [number]
        N [number]
    import CaseIndex [number]
    where
        CaseIndex [= 0]
    construct TestOneSA [switch_alternative]
        OneSA [setIndexLabel]    
    by 
        N [+ 1]
end function

function setIndexLabel
    replace [switch_alternative]
        SA [switch_alternative]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    deconstruct SL
        'case CE [list constant_expression+] CA [colon_or_arrow]
    export CaseIndex [number]
        1
    by
        SA
end function

function fromSwitchAlternativeGetConstantExpression SA [switch_alternative]
    replace [repeat constant_expression]
        CE [repeat constant_expression]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    construct RCE [repeat constant_expression]
        _ [extractConstantExpression SL]
    by 
        CE [. RCE]
end function 

function extractConstantExpression SL [switch_label]
    replace [repeat constant_expression]
        CE [repeat constant_expression]
    deconstruct SL
        'case CE [list constant_expression+] CA [colon_or_arrow]
    by 
        CE [. CE]
end function
% Switch 转换结束
% ----------------------------------------------------------------

% If-else 和 If-else-if 转换
function changeCompoundIf
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    construct S [repeat if_statement]
        _ [^ CSB]
    construct NewS [repeat statement]
        _ [changeIfStatement each S]
    by
        CSB [replaceStatement each S NewS]
end function

function changeIfStatement If [if_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct IfElseIf [number]
        0
    construct S [statement]
        If
    construct NS [statement]
        S [changeIfElsetoIfElseIf] [changeIfElseIftoIfElse]
    by 
        RS [. NS]
end function 

function changeIfElsetoIfElseIf
    replace [statement]
        If [if_statement]
    deconstruct If
        'if '( C [condition] ') S [statement] OE [opt else_clause]
    construct NewOE [opt else_clause]
        OE [changeIfElseStatement]
    construct NewIf [if_statement]
        'if '( C ') S NewOE
    export IfElseIf [number]
        1
    by 
        NewIf  
end function

function changeIfElseStatement
    replace [opt else_clause] 
        E [opt else_clause]
    deconstruct E 
        'else EIf [statement]
    deconstruct EIf
        '{ RS [repeat declaration_or_statement] '}
    deconstruct RS
        If [if_statement] Rest [repeat declaration_or_statement]
    deconstruct If
        'if '( C [condition] ') S [statement] OE [opt else_clause]
    construct RES [repeat else_clause]
        _ [createRepeatElseClause OE]
    construct NewRES [repeat else_clause]
        _ [createNewRES RES]
    construct NRES [repeat else_clause]
        _ [. RES] [. NewRES]
    deconstruct NRES
        NE [else_clause]
    construct NewIf [if_statement]
        'if '( C ') S NE
    construct NewRS [repeat declaration_or_statement]
        NewIf Rest
    construct NewE [opt else_clause]
        'else '{ NewRS '}
    by 
        NewE
end function

function createNewRES RES [repeat else_clause]
    replace [repeat else_clause]
        NRES [repeat else_clause]
    construct LenRES [number]
        _ [length RES]
    where 
        LenRES [= 0]
    construct Else [else_clause]
        'else ';
    by 
        NRES [. Else]
end function

function createRepeatElseClause OE [opt else_clause]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct OE
        E [else_clause]
    by
        RES [. E]
end function  

function changeIfElseIftoIfElse
    replace [statement]
        If [if_statement]
    deconstruct If
        'if '( C [condition] ') S [statement] OE [opt else_clause]
    construct NewOE [opt else_clause]
        OE [changeElseIfStatement]
    construct NewIf [if_statement]
        'if '( C ') S NewOE
    by 
        NewIf 
end function

function changeElseIfStatement
    replace [opt else_clause]    
        E [opt else_clause]
    deconstruct E
        'else E_If [if_statement]
    construct NewE [statement]
        '{ E_If '}
    construct NewEIf [opt else_clause]
        'else NewE
    by
        NewEIf
end function

function replaceStatement S [statement] NS [statement]
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    by
        CSB [$ S NS]
end function
% If-else 转换结束
% ----------------------------------------------------------------

% While 到 For 转换
function changeCompoundWhile
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    construct S [repeat while_statement]
        _ [^ CSB]
    construct NewS [repeat statement]
        _ [changeWhileStatement each S]
    by
        CSB [replaceStatement each S NewS]
end function

function changeWhileStatement While [while_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct S [statement]
        While
    construct NS [statement]
        S [newWhileStatement]
    by 
        RS [. NS]
end function

function newWhileStatement
    replace [statement]
        While [while_statement]
    deconstruct While
        'while '( E [condition] ') S [statement]
    construct SEmbed [statement]
        S [dealBlockEmbedStatement]
    construct ForStatement [for_statement]
        'for '( '; E '; ') SEmbed
    by 
        ForStatement
end function
% While 转换结束
% ----------------------------------------------------------------

% For 到 While 转换
function changeCompoundFor0
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    construct S [repeat for_statement]
        _ [^ CSB]
    construct NewS [repeat statement]
        _ [changeForStatementCase0 each S]
    by
        CSB [replaceStatement each S NewS]
end function

function changeCompoundFor1
    replace [repeat declaration_or_statement]
        CSB [repeat declaration_or_statement]
    construct S [repeat for_statement]
        _ [^ CSB]
    construct NewS [repeat statement]
        _ [changeForStatementCase1 each S]
    by
        CSB [replaceStatement each S NewS]
end function

function changeForStatementCase1 For [for_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct S [statement]
        For
    construct NS [statement]
        S [newForStatement1]
    by 
        RS [. NS]
end function

function newForStatement1
    replace [statement]
        For [for_statement]
    deconstruct For
        'for '( Init [for_init] Expr [opt expression] Update [for_update] ') S [statement]
    construct SEmbed [statement]
        S [dealBlockEmbedStatement]
    construct RBI [repeat declaration_or_statement]
        _ [forSubCreateItem SEmbed]
    construct NewUpdate [repeat declaration_or_statement]
        _ [changeExpression each Update]
    construct NewI [repeat declaration_or_statement]
        _ [changeForInit Init]
    construct NewS [repeat declaration_or_statement]
        _ [. RBI] [. NewUpdate]
    construct NewSS [statement]
        '{ NewS '}
    construct WhileStatement [while_statement]
        '; NewI 'while '( Expr ') NewSS
    by 
        WhileStatement
end function

function changeForStatementCase0 For [for_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct S [statement]
        For
    construct NS [statement]
        S [newForStatement0]
    by 
        RS [. NS]
end function

function newForStatement0 
    replace [statement]
        For [for_statement]
    deconstruct For
        'for '( Init [for_init] Expr [opt expression] ') S [statement]
    construct SEmbed [statement]
        S [dealBlockEmbedStatement]
    construct RBI [repeat declaration_or_statement]
        _ [forSubCreateItem SEmbed]
    construct NewI [repeat declaration_or_statement]
        _ [changeForInit Init]
    construct NewS [repeat declaration_or_statement]
        _ [. RBI]
    construct NewSS [statement]
        '{ NewS '}
    construct WhileStatement [while_statement]
        '; NewI 'while '( Expr ') NewSS
    by 
        WhileStatement
end function

function forSubCreateItem SS [statement]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    construct BI [declaration_or_statement]
        SS
    by 
        RBI [. BI]
end function 

function changeForInit Init [for_init]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    deconstruct Init
        LVD [local_variable_declaration]
    by
        RBI [. LVD]
    |
    deconstruct Init
        LE [list expression] ';
    construct NewRBI [repeat declaration_or_statement]
        _ [changeExpression each LE]
    by
        RBI [. NewRBI]
end function

function changeExpression S [expression]
    replace [repeat declaration_or_statement]
        St [repeat declaration_or_statement]
    construct NewS [stringlit]
        _ [quote S] [append ";"]
    construct NewSS [expression_statement]
        _ [parse NewS]
    construct BI [declaration_or_statement]
        NewSS
    by 
        St [. BI]
end function
% For 转换结束
% ----------------------------------------------------------------

% 工具函数
function dealBlockEmbedStatement
    replace [statement]
        BI [statement]
    by 
        BI
end function
% 工具函数结束
% ----------------------------------------------------------------
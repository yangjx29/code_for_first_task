% Txl v10.8 (7.5.20) (c) 1988-2020 Queen's University at Kingston
% statements 
% version 20200924
% 这个代码的实现对要修改代码进行统计，变换的代码进行统计

include "java.grm"

% ----------------------------------------------------------------
% 重定义标准库，实现代码的替换操作

redefine declaration
    ... 
    | [repeat declaration] '; [NL] [variable_declarators] % Java variable declarations
end redefine

redefine variable_declarator
    ... 
    | [variable_declarator] '; [NL] % Replaces init_declarator for Java
end redefine

redefine while_statement
    ... 
    | [expression] ';[NL] 'while '( [condition] ') [statement] % Adjusted for Java
    | '; [NL] [repeat declaration_or_statement] 'while '( [expression] ') [statement] % For do-while/for conversions
end redefine

redefine statement
    ... 
    | '{ [repeat statement] '} % Replaces sub_statement for Java blocks
end redefine

define n_statement
    [repeat declaration_or_statement] % Adjusted for Java block content
end define

redefine else_clause
    ... 
    | [repeat declaration_or_statement] % Replaces else_sub_statement for Java
end redefine

redefine if_statement
    ... 
    | 'if '( [repeat condition] ') [statement]
    | [if_statement] [repeat else_clause] % Java if-else structure
end redefine

redefine expression_statement
    ... 
    | [assignment_expression] '= [assignment_expression] [add_op] [assignment_expression] % Simplified for Java compound assignments
    | [assignment_expression] '= [assignment_expression] [mult_op] [assignment_expression]
    | [assignment_expression] '= [assignment_expression] [shift_op] [assignment_expression]
    | [assignment_expression] '= [assignment_expression] [bit_AND_operator] [assignment_expression]
    | [assignment_expression] '= [assignment_expression] [bit_XOR_operator] [assignment_expression]
    | [assignment_expression] '= [assignment_expression] [bit_OR_operator] [assignment_expression]
end redefine

redefine numeric_literal
    ... 
    | '( [number] '+ '1 '+ '2 '* '5 '- '1 ') % Unified for Java integer constants
    | '( [floatnumber] '+ 3 '* 4 '+ 0.0 '- 12 ') % Unified for Java floating-point constants
end redefine

% 重定义完成
% ----------------------------------------------------------------

% 主函数
function main
    replace [package_declaration]
        P [package_declaration]
    by  
        P [changeFunction] % Count code elements and transformations
end function

function changeFunction
    replace [package_declaration]
        P [package_declaration]
    construct _ [any] 
        _ [defineExportData]
    construct Methods [repeat method_declaration]
        _ [^ P]
    construct GlobalFields [repeat field_declaration]
        _ [^ P]
    construct GlobalID [repeat id]  
        _ [extractGlobalID each GlobalFields]
    export GlobalID 
    construct GlobalFuncName [repeat id]
        _ [extractMethodName each Methods]
    export GlobalFuncName
    construct _ [package_declaration]
        P [countProgram] % Apply transformations and count
    construct _ [any]
        _ [outResult] % Output statistics
    by  
        P 
end function

function extractGlobalID FD [field_declaration]
    replace [repeat id]
        RI [repeat id]
    construct FieldVars [repeat variable_declarator]
        _ [^ FD]
    construct Ids [repeat id]
        _ [^ FieldVars]
    by
        RI [. Ids]
end function

function extractMethodName MD [method_declaration]
    replace [repeat id]
        RI [repeat id]
    deconstruct MD
        Modifiers [repeat modifier] Gen [opt generic_parameter] 
        Type [type_specifier] Declarator [method_declarator] 
        Throws [opt throws] Body [method_body]
    deconstruct Declarator
        ID [id] '(' Params [opt parameters] ') Dims [repeat dimension]
    by 
        RI [. ID]
end function

% 主函数结束
% ----------------------------------------------------------------

% 对整个程序进行统计
function countProgram
    replace [package_declaration]
        P [package_declaration]
    construct NewP [package_declaration]
        P [changeCompoundFor0] [changeCompoundFor1] [changeCompoundFor2]
          [changeCompoundWhile]
          [countDoWhileChanged]
          [changeCompoundIf]
          [countSwitchChanged]
          [countChangedLogicalOperator]
          [changeCompoundIncrement]
          [changeSelfOperatorExpression]
          [changeSelfOperatorExpressionStatement]
          [changeConstants]
          [changeAddJunkCode]
          [countDeleteCode] 
          [countExchangedCodeFunc] 
          [extractVarandFuncNameAndRename]
    by 
        P
end function

% 定义全局计数变量
function defineExportData
    replace [any]
        A [any]
    export CodeLine [number]
        0 % Start at 0 for Java (no function header line)
    export CountVarAndFuncName [number]
        0
    export CountVarAndFuncNameChanged [number]
        0
    export CountFor [number]
        0
    export CountForChanged [number]
        0   
    export CountForNewer [number]
        0
    export CountWhile [number]
        0
    export CountWhileChanged [number]
        0
    export CountWhileNewer [number]
        0
    export CountDoWhile [number]
        0
    export CountChangedDoWhile [number]
        0
    export CountNewerDoWhile [number]
        0
    export CountIfElseIf [number]
        0
    export CountIfElseIfChanged [number]
        0
    export CountIfElseIfNewer [number]
        0
    export CountIfElse [number]
        0
    export CountIfElseChanged [number]
        0
    export CountIfElseNewer [number]
        0
    export CountSwitch [number]
        0
    export CountChangedSwitch [number]
        0
    export CountNewSwitch [number]
        0
    export CountLogicalOperator [number]
        0
    export CountSelfIncrement [number]
        0
    export CountIncrementAssign [number]
        0
    export CountConstant [number]
        0
    export CountDecl [number]
        0
    export CountChangedDecl [number]
        0
    export countNewDecl [number]
        0
    export CountJunkCode [number]
        0
    export CountJunkCodeChanged [number]
        0
    export CountJunkCodeNewer [number]
        0 
    export CountExchangedCode [number]
        0
    export CountExchangedCodeChanged [number]
        0
    export CountExchangedCodeNewer [number]
        0
    export CountDeleteCode [number]
        0
    export CountDeleteCodeChanged [number]
        0
    export CountDeleteCodeNewer [number]
        0
    by 
        A
end function 

% 输出统计结果
function outResult
    replace [any]
        A [any]
    import CodeLine [number]
    construct OutCodeLine [number]
        CodeLine [putp "THE CODE OF LINE IS:%"]
    import CountVarAndFuncName [number]
    import CountVarAndFuncNameChanged [number]
    construct OutFileCountVarAndFuncName [number]
        CountVarAndFuncName [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/1Rename.count"]
    construct Close1 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/1Rename.count"]
    construct OutCountVarAndFuncName [number]
        CountVarAndFuncName [putp "THE RENAME COUNT IS:%"]
    construct OutCountVarAndFuncNameChanged [number]
        CountVarAndFuncNameChanged [putp "THE CHANGE STATEMENT COUNT IS:%"]
    import CountFor [number]
    import CountForChanged [number]
    import CountForNewer [number]
    construct OutFileCountFor [number]
        CountFor [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/2For.count"]
    construct Close2 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/2For.count"]
    construct OutCountFor [number]
        CountFor [putp "THE FOR COUNT IS:%"]
    construct OutCountForChanged [number]
        CountForChanged [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountForNewer [number]
        CountForNewer [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountWhile [number]
    import CountWhileChanged [number]
    import CountWhileNewer [number]
    construct OutFileCountWhile [number]
        CountWhile [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/3While.count"]
    construct Close3 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/3While.count"]
    construct OutCountWhile [number]
        CountWhile [putp "THE WHILE COUNT IS:%"]
    construct OutCountWhileChanged [number]
        CountWhileChanged [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountWhileNewer [number]
        CountWhileNewer [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountDoWhile [number]
    import CountChangedDoWhile [number]
    import CountNewerDoWhile [number]
    construct OutFileCountDoWhile [number]
        CountDoWhile [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/4DoWhile.count"]
    construct Close4 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/4DoWhile.count"]
    construct OutDoWhile [number]
        CountDoWhile [putp "THE DO WHILE COUNT IS:%"]
    construct OutChangedDoWhile [number]
        CountChangedDoWhile [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountNewerDoWhile [number]
        CountNewerDoWhile [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountIfElseIf [number]
    import CountIfElseIfChanged [number]
    import CountIfElseIfNewer [number]
    construct OutFileCountIfElseIf [number]
        CountIfElseIf [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/5IfElseIf.count"]
    construct Close5 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/5IfElseIf.count"]
    construct OutCountIfElseIf [number]
        CountIfElseIf [putp "THE IFELSEIF COUNT IS:%"]
    construct OutCountIfElseIfChanged [number]
        CountIfElseIfChanged [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountIfElseIfNewer [number]
        CountIfElseIfNewer [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountIfElse [number]
    import CountIfElseChanged [number]
    import CountIfElseNewer [number]
    construct OutFileCountIfElse [number]
        CountIfElse [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/6IfElse.count"]
    construct Close6 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/6IfElse.count"]
    construct OutIfElse [number]
        CountIfElse [putp "THE IFELSE COUNT IS:%"]
    construct OutIfElseChanged [number]
        CountIfElseChanged [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutIfElseNewer [number]
        CountIfElseNewer [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountSwitch [number]
    import CountChangedSwitch [number]
    import CountNewSwitch [number]
    construct OutFileCountSwitch [number]
        CountSwitch [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/7Switch.count"]
    construct Close7 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/7Switch.count"]
    construct OutCountSwitch [number]
        CountSwitch [putp "THE SWITCH COUNT IS:%"]
    construct OutCountChangedSwitch [number]
        CountChangedSwitch [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountNewSwitch [number]
        CountNewSwitch [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountLogicalOperator [number]
    construct OutFileCountOperator [number]
        CountLogicalOperator [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/8Logic.count"]
    construct Close8 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/8Logic.count"]
    construct OutCountOperator [number]
        CountLogicalOperator [putp "THE LOGICAL OPERATOR IS:%"]
    construct OutCountOperatorChanged [number]
        CountLogicalOperator [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountOperatorNewers [number]
        CountLogicalOperator [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountSelfIncrement [number]
    construct OutFileCountSelfOperator [number]
        CountSelfIncrement [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/9SelfOperator.count"]
    construct Close9 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/9SelfOperator.count"]
    construct OutCountSelfIncrement [number]
        CountSelfIncrement [putp "THE SELFINCREMENT COUNT IS:%"]
    construct OutCountSelfIncrementChanged [number]
        CountSelfIncrement [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountSelfIncrementNewer [number]
        CountSelfIncrement [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountIncrementAssign [number]
    construct OutFileCountIncrementAssign [number]
        CountIncrementAssign [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/10IncrementAssign.count"]
    construct Close10 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/10IncrementAssign.count"]
    construct OutCountIncrementAssign [number]
        CountIncrementAssign [putp "THE INCREMENTASSIGN COUNT IS:%"]
    construct OutCountIncreAssignChanged [number]
        CountIncrementAssign [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountIncreAssignNewer [number]
        CountIncrementAssign [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountConstant [number]
    construct OutFileCountConstant [number]
        CountConstant [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/11Constant.count"]
    construct Close11 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/11Constant.count"]
    construct OutCountConstant [number]
        CountConstant [putp "THE CONSTANT IS:%"]
    construct OutCountConstantChanged [number]
        CountConstant [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountConstantNewer [number]
        CountConstant [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountDecl [number]
    import CountChangedDecl [number]
    import countNewDecl [number]
    construct OutFileCountChangedDecl [number]
        CountChangedDecl [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/12Define.count"]
    construct Close12 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/12Define.count"]
    construct OutCountDecl [number]
        CountDecl [putp "THE DECL COUNT IS:%"]
    construct OutCountChangedDecl [number]
        CountChangedDecl [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountDeclChanged [number]
        countNewDecl [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountJunkCode [number]
    import CountJunkCodeChanged [number]
    import CountJunkCodeNewer [number]
    construct OutFileCountJunkCode [number]
        CountJunkCode [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/13JunkCode.count"]
    construct Close13 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/13JunkCode.count"]
    construct OutCountJunkCode [number]
        CountJunkCode [putp "THE JUNKCODE COUNT IS:%"]
    construct OutCountJunkCodeChanged [number]
        CountJunkCodeChanged [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountJunkCodeNewer [number]
        CountJunkCodeNewer [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountExchangedCode [number]
    import CountExchangedCodeChanged [number]
    import CountExchangedCodeNewer [number]
    construct OutFileCountExchangeCode [number]
        CountExchangedCodeChanged [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/14Exchange.count"]
    construct Close14 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/14Exchange.count"]
    construct OutCountExchangedCode [number]
        CodeLine [putp "THE EXCHANGE CODE COUNT IS:%"]
    construct OutCountExchangedCodeChanged [number]
        CountExchangedCodeChanged [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountExchangedCodeNewer [number]
        CountExchangedCodeNewer [putp "THE NEWERS STATEMENT COUNT IS:%"]
    import CountDeleteCode [number]
    import CountDeleteCodeChanged [number]
    import CountDeleteCodeNewer [number]
    construct OutFileCountDelete [number]
        CountDeleteCodeChanged [fput "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/15Delete.count"]
    construct Close15 [any]
        _ [fclose "/data/yjx/code_for_first_task/PSOWithcoda/VulnerabilityPrediction/code/CountResult/15Delete.count"]
    construct OutCountDeleteCode [number]
        CodeLine [putp "THE DELETE CODE COUNT IS:%"]
    construct OutCountDeleteCodeChanged [number]
        CountDeleteCodeChanged [putp "THE CHANGE STATEMENT COUNT IS:%"]
    construct OutCountDeleteCodeNewer [number]
        CountDeleteCodeNewer [putp "THE NEWERS STATEMENT COUNT IS:%"]
    by 
        A
end function 

% 变量名和函数名统计
function extractVarandFuncNameAndRename
    replace [package_declaration]
        P [package_declaration]
    construct AllVarGlobal [repeat variable_declarator]
        _ [^ P]
    construct PureAllVarGlobal [repeat id]
        _ [^ AllVarGlobal]
    construct AllVarLocal [repeat identifier] % No typedef_name in Java
        _ [^ P]
    construct AllVar [repeat id]
        _ [. PureAllVarGlobal] [. AllVarLocal] [sortId]
    construct UniqueAllVar [repeat id]
        AllVar [select 1 1] [deduplication AllVar]
    construct CountChangedName [number]
        _ [length UniqueAllVar]
    export CountVarAndFuncName [number]
        CountChangedName
    by 
        P   
end function

% 删除代码统计
function countDeleteCode
    replace [package_declaration]
        CSB [package_declaration]
    construct _ [package_declaration]
        CSB [deletePrintStatement]
    by 
        CSB
end function

function deletePrintStatement 
    replace [package_declaration]
        CSB [package_declaration]
    construct AllCSB [repeat repeat declaration_or_statement]
        _ [^ CSB]
    construct NAllCSB [repeat repeat declaration_or_statement]
        _ [deletePrint each AllCSB]
    by 
        CSB 
end function

function deletePrint CSB [repeat declaration_or_statement]
    replace [repeat repeat declaration_or_statement]
        RCSB [repeat repeat declaration_or_statement]
    construct AllPrint [repeat declaration_or_statement]
        _ [isPrintDelete each CSB]
    construct NAllPrint [repeat declaration_or_statement]
        AllPrint [isStatementPrint each CSB] [filterPrintWithParam]
    export NAllPrint
    construct NRBI [repeat declaration_or_statement]
        _ [isdeleteItem each CSB]
    construct NCSB [repeat declaration_or_statement]
        NRBI
    by 
        RCSB [. NCSB]
end function

function filterPrintWithParam 
    replace [repeat declaration_or_statement]
        AllPrint [repeat declaration_or_statement]
    construct NewPrint [repeat declaration_or_statement]
        _ [filterPrint each AllPrint]
    by 
        NewPrint
end function

function filterPrint BI [declaration_or_statement]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    deconstruct BI 
        S [statement]
    deconstruct S
        'System '.' 'out '.' 'println '( Args [list expression] ') ';
    construct LenArgs [number]
        _ [length Args]
    where
        LenArgs [<= 1] % Only simple prints
    import CountDeleteCodeChanged [number]
    export CountDeleteCodeChanged 
        CountDeleteCodeChanged [+ 1]
    by 
        RBI
end function

function isStatementPrint BI [declaration_or_statement]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    deconstruct BI
        S [statement]
    deconstruct S
        'System '.' 'out '.' 'println '( Args [list expression] ') ';
    by 
        RBI [. BI]
end function

function isdeleteItem DeleteBI [declaration_or_statement]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    import NAllPrint [repeat declaration_or_statement]
    construct IsPrint [number]
        0
    export DeleteBI
    construct NIsPrint [number]
        IsPrint [isItemEqualPrint each NAllPrint]
    where
        NIsPrint [= 0]
    by
        RBI [. DeleteBI]
end function

function isItemEqualPrint BI [declaration_or_statement]
    replace [number]
        N [number]
    import DeleteBI [declaration_or_statement]
    where 
        DeleteBI [= BI]
    by 
        N [+ 1]    
end function

function isPrintDelete BI [declaration_or_statement]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    deconstruct BI 
        S [statement]
    deconstruct S
        'System '.' 'out '.' 'println '( Args [list expression] ') ';
    by 
        RBI [. BI]
end function

% 交换代码顺序统计
function countExchangedCodeFunc
    replace [package_declaration]
        CSB [package_declaration]
    construct RCSB [repeat repeat declaration_or_statement]
        _ [^ CSB]
    construct NRCSB [repeat repeat declaration_or_statement]
        _ [exchangeCompoundCode each RCSB]
    by
        CSB
end function

function exchangeCompoundCode CSB [repeat declaration_or_statement]
    replace [repeat repeat declaration_or_statement]
        RepeatCSB [repeat repeat declaration_or_statement]
    construct RDecl [repeat declaration]
        _ [extractItemDecl each CSB]
    construct NRDecl [repeat declaration]
        _ [changeDeclarationOrder2 RDecl]
    construct DeclItems [repeat declaration_or_statement]
        _ [fromDeclCreateItem each NRDecl]
    construct RStatement [repeat statement]
        _ [extractStatement each CSB]
    construct NRStatement [repeat statement]
        _ [createNewOrderStatement RStatement]
    construct StateItems [repeat declaration_or_statement]
        _ [fromStateCreateItem each NRStatement]
    construct NDos [repeat declaration_or_statement]
        _ [. DeclItems] [. StateItems]
    by 
        RepeatCSB 
end function

function changeDeclarationOrder2 RDecls [repeat declaration]
    replace [repeat declaration]
        RDecl [repeat declaration]
    construct NRdecl [repeat declaration]
        _ [selectDeclaration1 each RDecls]
    construct NNRdecl [repeat declaration]
        _ [reverseOrderDecl each NRdecl]
    by 
        NNRdecl
end function

function reverseOrderDecl Decl [declaration]
    replace [repeat declaration]
        RDecl [repeat declaration]
    construct newDecl [repeat declaration]
        _ [. Decl] [. RDecl]
    by 
        newDecl
end function

function selectDeclaration1 Decl [declaration]
    replace [repeat declaration]
        RDecl [repeat declaration]
    construct DeclIndex [number]
        0
    export DeclGlobalAffected [number]
        0
    export GlobalDecl [declaration]
        Decl
    construct NewIndex [number]
        DeclIndex [locateAffectedDeclaration each RDecl]
    construct _ [number]
        NewIndex [setCountExchangedCodeChanged]
    construct RDeclBefore [repeat declaration]
        RDecl [select 1 NewIndex]
    construct NIndexAfter [number]
        NewIndex [+ 1]
    construct RDeclAfter [repeat declaration]
        RDecl [select NIndexAfter 9999]
    construct NewRDecl1 [repeat declaration]
        RDeclBefore [. Decl]
    construct NewRDecl2 [repeat declaration]
        NewRDecl1 [. RDeclAfter]
    by
        NewRDecl2 
end function

function locateAffectedDeclaration Decl [declaration]
    replace [number]
        Index [number]
    import DeclGlobalAffected [number]
    where
        DeclGlobalAffected [= 0] 
    import GlobalDecl [declaration]
    construct GlobalDeclId [repeat id]
        _ [^ GlobalDecl]
    construct DeclId [repeat id]
        _ [^ Decl]
    export GlobalDeclId
    construct IntersectionId [repeat id]
        _ [intersectionDeclId each DeclId]
    construct LenIntersectionId [number]
        _ [length IntersectionId] [setDeclGlobalAffected]
    import DeclGlobalAffected 
    where
        DeclGlobalAffected [= 0] 
    by 
        Index [+ 1]
end function

function setDeclGlobalAffected
    replace [number]
        N [number]
    where 
        N [> 0]
    export DeclGlobalAffected [number]
        1
    by 
        N
end function

function intersectionDeclId ID [id]
    replace [repeat id]
        RID [repeat id]
    import GlobalDeclId [repeat id]
    where 
        GlobalDeclId [? judgeIdisDeal ID]
    by
        RID [. ID]
end function

function createNewOrderStatement RStatement [repeat statement]
    replace [repeat statement]
        RS [repeat statement]
    construct NRS [repeat statement]
        _ [selectStatement each RStatement]
    construct RNRS [repeat statement]
        _ [reverseOrderStatement each NRS]
    by
        RNRS
end function  

function selectStatement St [statement]
    replace [repeat statement]
        RSt [repeat statement]
    export ReturnSt [number]
        0
    construct RSt2 [repeat statement]
        _ [createReturnStatement RSt St]
    export BreakSt [number]
        0
    construct RSt3 [repeat statement]
        _ [createBreakStatement RSt St]
    export ContinueSt [number]
        0
    construct RSt4 [repeat statement]
        _ [createContinueStatement RSt St]
    construct RSt1 [repeat statement]
        _ [createOrdinalStatement RSt St]
    construct NewRSt [repeat statement]
        _ [. RSt1] [. RSt4] [. RSt3] [. RSt2]
    by
        NewRSt 
end function 

function createReturnStatement RSt [repeat statement] St [statement]
    replace [repeat statement]
        RSt2 [repeat statement]
    deconstruct St
        'return OptExpr [opt expression] ';
    export ReturnSt [number]
        1
    construct NewRSt [repeat statement]
        _ [. St] [. RSt]
    by 
        NewRSt
end function

function createBreakStatement RSt [repeat statement] St [statement]
    replace [repeat statement]
        RSt1 [repeat statement]
    deconstruct St 
        'break ';
    export BreakSt [number]
        1
    construct NewRSt [repeat statement]
        _ [. St] [. RSt]
    by 
        NewRSt
end function

function createContinueStatement RSt [repeat statement] St [statement]
    replace [repeat statement]
        RSt1 [repeat statement]
    deconstruct St 
        'continue ';
    export ContinueSt [number]
        1
    construct NewRSt [repeat statement]
        _ [. St] [. RSt]
    by 
        NewRSt
end function

function createOrdinalStatement RSt [repeat statement] St [statement]
    import ReturnSt [number]
    where
        ReturnSt [= 0]  
    import BreakSt [number]
    where
        BreakSt [= 0] 
    import ContinueSt [number]
    where
        ContinueSt [= 0]
    replace [repeat statement]
        RSt1 [repeat statement]
    construct Index [number]
        0
    export GlobalAffected [number]
        0
    export St
    construct NewIndex [number]
        Index [locateTheAffectedStatement each RSt]
    construct _ [number]
        NewIndex [setCountExchangedCodeChanged]
    construct RStBefore [repeat statement]
        RSt [select 1 NewIndex]
    construct NewIndexPlusOne [number]
        NewIndex [+ 1]
    construct RStAfter [repeat statement]
        RSt [select NewIndexPlusOne 99999]
    construct NewRSt [repeat statement]
        RStBefore [. St]
    construct NewRSt1 [repeat statement]
        NewRSt [. RStAfter]
    by
        NewRSt1
end function

function setCountExchangedCodeChanged 
    replace [number]
        Index [number]
    where 
        Index [> 0]
    import CountExchangedCodeChanged [number]
    export CountExchangedCodeChanged
        CountExchangedCodeChanged [+ 1]
    by 
        Index
end function

function locateTheAffectedStatement RSt [statement]
    replace [number]
        Index [number]
    construct JumpSt [statement]
        RSt [judgeIsJump]
    import GlobalAffected [number]
    where 
        GlobalAffected [= 0]
    import St [statement]
    construct StId [repeat id]
        _ [^ St]
    construct StFuncName [repeat id]
        _ [intersectionId2 each StId]
    construct NNStId [repeat id]
        StId [setGlobalIDInStatement StFuncName]
    construct RStId [repeat id]
        _ [^ RSt]
    construct RStFuncName [repeat id]
        _ [intersectionId2 each RStId]
    construct NNRStId [repeat id]
        RStId [setGlobalIDInStatement RStFuncName]
    export NNRStId
    construct IntersectionIds [repeat id]
        _ [intersectionId1 each NNStId]
    construct LenIntersectionIds [number]
        _ [length IntersectionIds] [setGlobalAffected]
    import GlobalAffected
    where 
        GlobalAffected [= 0]
    by
        Index [+ 1]
end function

function judgeIsJump
    replace [statement]
        St [statement]
    construct RJudeSt [repeat jump_statement]
        _ [^ St]
    construct LenRjudgeSt [number]
        _ [length RJudeSt]
    where 
        LenRjudgeSt [> 0]
    import GlobalAffected [number]
    export GlobalAffected
        GlobalAffected [+ 1]
    by  
        St
end function

function setGlobalAffected
    replace [number]
        N [number]
    where
        N [> 0]
    export GlobalAffected [number]
        1
    by
        N 
end function  

function setGlobalIDInStatement RID [repeat id]
    replace [repeat id]
        RIDs [repeat id]
    construct LenRID [number]
        _ [length RID]
    where 
        LenRID [> 0]
    import GlobalID [repeat id]
    by
        RIDs [. GlobalID]
end function

function intersectionId2 ID [id]
    replace [repeat id]
        RID [repeat id]
    import GlobalFuncName [repeat id]
    where
        GlobalFuncName [? judgeIdisDeal ID]
    by 
        RID [. ID]
end function 

function intersectionId1 ID [id]
    replace [repeat id]
        RID [repeat id]
    import NNRStId [repeat id]
    where
        NNRStId [? judgeIdisDeal ID]
    by
        RID [. ID]
end function 

function extractStatement BI [declaration_or_statement]
    replace [repeat statement]
        RS [repeat statement]
    deconstruct BI
        ST [statement]
    by 
        RS [. ST]
end function

function reverseOrderStatement ST [statement]
    replace [repeat statement]
        RS [repeat statement]
    construct newST [repeat statement]
        _ [. ST] [. RS]
    by
        newST
end function 

function fromStateCreateItem Stat [statement]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    construct BI [declaration_or_statement]
        Stat 
    by
        RBI [. BI]
end function    

function fromDeclCreateItem Decl [declaration]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    construct BI [declaration_or_statement]
        Decl
    by 
        RBI [. BI]
end function 

function extractItemDecl BI [declaration_or_statement]
    replace [repeat declaration]
        RDecl [repeat declaration]
    deconstruct BI
        Decl [declaration]
    by  
        RDecl [. Decl]
end function

% 添加垃圾代码统计
function changeAddJunkCode
    replace [package_declaration]
        St [package_declaration]
    export JunkNum [number]
        1
    construct CSB [repeat repeat declaration_or_statement]
        _ [^ St]
    construct NCSB [repeat repeat declaration_or_statement]
        _ [addJunkCode each CSB]
    by 
        St 
end function

function addJunkCode CSB [repeat declaration_or_statement]
    replace [repeat repeat declaration_or_statement] 
        RCSB [repeat repeat declaration_or_statement]
    construct DosLenHalf [number]
        _ [length CSB] [/ 2] [round]
    construct DosLenHalfPlusOne [number]
        DosLenHalf [+ 1]
    construct DosFront [repeat declaration_or_statement]
        CSB [select 1 DosLenHalf]
    construct DosRear [repeat declaration_or_statement]
        CSB [select DosLenHalfPlusOne 9999]
    import CountJunkCode [number]
    export CountJunkCode
        CountJunkCode [+ 1]
    by 
        RCSB  
end function 

% 修改常量统计
function changeConstants
    replace [package_declaration]
        St [package_declaration]
    construct NewSt [package_declaration]
        St [changeNumericConstant]
    by
        St
end function

function changeNumericConstant
    replace [package_declaration]
        St [package_declaration]
    construct NumericConstant [repeat numeric_literal]
        _ [^ St]
    construct NewNumericConstant [repeat numeric_literal]
        _ [createNewNumericConstant each NumericConstant]
    by  
        St 
end function

function createNewNumericConstant NL [numeric_literal]
    replace [repeat numeric_literal]
        RNL [repeat numeric_literal]
    construct NewNL [numeric_literal]
        NL [createNewIC] [createNewFC]
    by 
        RNL [. NewNL]
end function

function createNewIC
    replace [numeric_literal]
        NL [numeric_literal]
    deconstruct NL
        ICN [number]
    construct ICSubTen [number]
        ICN [- 10]
    construct NewNL [numeric_literal]
        '( ICSubTen '+ '1 '+ '2 '* '5 '- '1 ')
    import CountConstant [number]
    export CountConstant 
        CountConstant [+ 1]
    by 
        NewNL 
end function

function createNewFC
    replace [numeric_literal]
        NL [numeric_literal]
    deconstruct NL
        F [floatnumber]
    construct NewNL [numeric_literal]
        '( F '+ 3 '* 4 '+ 0.0 '- 12 ')
    import CountConstant [number]
    export CountConstant 
        CountConstant [+ 1]
    by 
        NewNL
end function

% If-else/if-else-if统计
function changeCompoundIf
    replace [package_declaration]
        CSB [package_declaration]
    construct S [repeat if_statement]
        _ [^ CSB]
    construct NewS [repeat statement]
        _ [changeIfStatement each S]
    by
        CSB
end function

function changeIfStatement If [if_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct IfElseIf [number]
        0
    construct S [statement]
        If
    construct NS [statement]
        S [changeIfElsetoIfElseIf]
          [changeIfElseIftoIfElse]
    by 
        RS [. NS]
end function 

function changeIfElsetoIfElseIf
    replace [statement]
        If [if_statement]
    deconstruct If
        'if '( C [condition] ') S [statement] OE [opt else_clause]
    construct NewOE [opt else_clause]
        OE [changeIfElseStatement]
    construct NewIf [if_statement]
        'if '( C ') S NewOE
    export IfElseIf [number]
        1
    by 
        NewIf  
end function

function changeIfElseStatement
    replace [opt else_clause] 
        E [opt else_clause]
    deconstruct E 
        'else EIf [statement]
    deconstruct EIf
        '{ RS [repeat declaration_or_statement] '}
    deconstruct RS
        If [if_statement] Rest [repeat declaration_or_statement]
    deconstruct If
        'if '( C [condition] ') S [statement] OE [opt else_clause]
    construct RES [repeat else_clause]
        _ [createRepeatElseClause OE]
    construct NewRES [repeat else_clause]
        _ [createNewRES RES]
    construct NRES [repeat else_clause]
        _ [. RES] [. NewRES]
    deconstruct NRES
        NE [else_clause]
    construct NewIf [if_statement]
        'if '( C ') S NE
    construct NewRS [repeat declaration_or_statement]
        NewIf Rest
    construct NewE [opt else_clause]
        'else '{ NewRS '}
    import CountIfElse [number]
    export CountIfElse
        CountIfElse [+ 1]
    by 
        NewE
end function

function createNewRES RES [repeat else_clause]
    replace [repeat else_clause]
        NRES [repeat else_clause]
    construct LenRES [number]
        _ [length RES]
    where 
        LenRES [= 0]
    construct Else [else_clause]
        'else ';
    by 
        NRES [. Else]
end function

function createRepeatElseClause OE [opt else_clause]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct OE
        E [else_clause]
    by
        RES [. E]
end function  

function changeIfElseIftoIfElse
    replace [statement]
        If [if_statement]
    deconstruct If
        'if '( C [condition] ') S [statement] OE [opt else_clause]
    construct NewOE [opt else_clause]
        OE [changeElseIfStatement]
    construct NewIf [if_statement]
        'if '( C ') S NewOE
    by 
        NewIf 
end function

function changeElseIfStatement
    replace [opt else_clause]    
        E [opt else_clause]
    deconstruct E
        'else E_If [if_statement]
    construct NewE [statement]
        '{ E_If '}
    construct NewEIf [opt else_clause]
        'else NewE
    import CountIfElseIf [number]
    export CountIfElseIf
        CountIfElseIf [+ 1]
    by
        NewEIf
end function

% 自增操作统计
function changeSelfOperatorExpression
    replace [package_declaration]
        St [package_declaration]
    construct IOE [repeat expression]
        _ [^ St]
    construct NewIOE [repeat expression]
        _ [changeExpressionSelfOperator each IOE]
    by 
        St  
end function

function changeSelfOperatorExpressionStatement
    replace [package_declaration]
        St [package_declaration]
    construct IOE [repeat expression_statement]
        _ [^ St]
    construct NewIOE [repeat expression_statement]
        _ [changeExpressionStatementSelfOperator each IOE]
    by 
        St 
end function 

function changeExpressionSelfOperator SOper [expression]
    replace [repeat expression]
        RPE [repeat expression]
    construct NewSOper [expression]
        SOper [changeSOperPlus] [changeSOperSub] [changeSOperPlusBefore] [changeSOperSubBefore]
    by 
        RPE [. NewSOper]
end function

function changeSOperPlusBefore
    replace [expression]
        E [expression]
    deconstruct E
        '++ PE [postfix_expression]
    construct NewE [expression]
        PE '= PE '+ 1
    import CountSelfIncrement [number]
    export CountSelfIncrement
        CountSelfIncrement [+ 1]
    by 
        NewE
end function 

function changeSOperSubBefore
    replace [expression]
        E [expression]
    deconstruct E
        '-- PE [postfix_expression]
    construct NewE [expression]
        PE '= PE '- 1
    import CountSelfIncrement [number]
    export CountSelfIncrement
        CountSelfIncrement [+ 1]
    by 
        NewE
end function 

function changeSOperPlus
    replace [expression]
        E [expression]
    deconstruct E
        PE [primary] '++
    construct NewE [expression]
        PE '= PE '+ 1
    import CountSelfIncrement [number]
    export CountSelfIncrement
        CountSelfIncrement [+ 1]
    by 
        NewE
end function 

function changeSOperSub
    replace [expression]
        E [expression]
    deconstruct E
        PE [primary] '--
    construct NewE [expression]
        PE '= PE '- 1
    import CountSelfIncrement [number]
    export CountSelfIncrement
        CountSelfIncrement [+ 1]
    by 
        NewE
end function 

function changeExpressionStatementSelfOperator SOper [expression_statement]
    replace [repeat expression_statement]
        RPE [repeat expression_statement]
    construct NewSOper [expression_statement]
        SOper [changeESOperPlus] [changeESOperSub] 
              [changeESOperSubBefore] [changeESOperPlusBefore]
    by 
        RPE [. NewSOper]
end function

function changeESOperPlusBefore
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        '++ PE [postfix_expression] ';
    construct NewE [expression_statement]
        PE '= PE '+ 1 ';
    import CountSelfIncrement [number]
    export CountSelfIncrement
        CountSelfIncrement [+ 1]
    by 
        NewE
end function 

function changeESOperSubBefore
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        '-- PE [postfix_expression] ';
    construct NewE [expression_statement]
        PE '= PE '- 1 ';
    import CountSelfIncrement [number]
    export CountSelfIncrement
        CountSelfIncrement [+ 1]
    by 
        NewE
end function 

function changeESOperPlus
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        PE [primary] '++ ';
    construct NewE [expression_statement]
        PE '= PE '+ 1 ';
    import CountSelfIncrement [number]
    export CountSelfIncrement
        CountSelfIncrement [+ 1]
    by 
        NewE
end function 

function changeESOperSub
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        PE [primary] '-- ';
    construct NewE [expression_statement]
        PE '= PE '- 1 ';
    import CountSelfIncrement [number]
    export CountSelfIncrement
        CountSelfIncrement [+ 1]
    by 
        NewE
end function 

% 增量操作统计
function changeCompoundIncrement
    replace [package_declaration]
        St [package_declaration]
    construct RES [repeat expression_statement]
        _ [^ St]
    construct NewRES [repeat expression_statement]
        _ [createNewIncrementAssignment each RES]
    by 
        St  
end function

function createNewIncrementAssignment ES [expression_statement]
    replace [repeat expression_statement]
        RES [repeat expression_statement]
    construct NewES [expression_statement]
        ES [incrementAssignmentAdd] 
           [incrementAssignmentSub] 
           [incrementAssignmentMul] 
           [incrementAssignmentDiv] 
           [incrementAssignmentMod] 
           [incrementAssignmentLeftShift] 
           [incrementAssignmentRightShift] 
           [incrementAssignmentAnd] 
           [incrementAssignmentXor] 
           [incrementAssignmentOr]
    by 
        RES [. NewES]
end function

function incrementAssignmentAdd
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '+= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '+ AER ';
    import CountIncrementAssign [number]
    export CountIncrementAssign
        CountIncrementAssign [+ 1]
    by 
        NewES
end function

function incrementAssignmentSub
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '-= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '- AER ';
    import CountIncrementAssign [number]
    export CountIncrementAssign
        CountIncrementAssign [+ 1]
    by 
        NewES
end function

function incrementAssignmentMul
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '*= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '* AER ';
    import CountIncrementAssign [number]
    export CountIncrementAssign
        CountIncrementAssign [+ 1]
    by 
        NewES
end function

function incrementAssignmentDiv
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '/= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '/ AER ';
    import CountIncrementAssign [number]
    export CountIncrementAssign
        CountIncrementAssign [+ 1]
    by 
        NewES
end function

function incrementAssignmentMod
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '%= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '% AER ';
    import CountIncrementAssign [number]
    export CountIncrementAssign
        CountIncrementAssign [+ 1]
    by 
        NewES
end function

function incrementAssignmentLeftShift
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '<<= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '<< AER ';
    import CountIncrementAssign [number]
    export CountIncrementAssign
        CountIncrementAssign [+ 1]
    by 
        NewES
end function

function incrementAssignmentRightShift
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '>>= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '>> AER ';
    import CountIncrementAssign [number]
    export CountIncrementAssign
        CountIncrementAssign [+ 1]
    by 
        NewES
end function

function incrementAssignmentAnd
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '&= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '& AER ';
    import CountIncrementAssign [number]
    export CountIncrementAssign
        CountIncrementAssign [+ 1]
    by 
        NewES
end function

function incrementAssignmentXor
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '^= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '^ AER ';
    import CountIncrementAssign [number]
    export CountIncrementAssign
        CountIncrementAssign [+ 1]
    by 
        NewES
end function

function incrementAssignmentOr
    replace [expression_statement]
        E [expression_statement]
    deconstruct E
        AEL [assignment_expression] '|= AER [assignment_expression] ';
    construct NewES [expression_statement]
        AEL '= AEL '| AER ';
    import CountIncrementAssign [number]
    export CountIncrementAssign
        CountIncrementAssign [+ 1]
    by 
        NewES
end function

% While循环统计
function changeCompoundWhile
    replace [package_declaration]
        CSB [package_declaration]
    construct S [repeat while_statement]
        _ [^ CSB]
    construct NewS [repeat statement]
        _ [changeWhileStatement each S]
    export CountWhile [number]
        _ [length S]
    by
        CSB 
end function

function changeWhileStatement While [while_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct S [statement]
        While
    construct NS [statement]
        S [newWhileStatement]
    by 
        RS [. NS]
end function

function newWhileStatement
    replace [statement]
        While [while_statement]
    deconstruct While
        'while '( E [condition] ') S [statement]
    construct ForStatement [for_statement]
        'for '( '; E '; ') S
    by 
        ForStatement
end function

% For循环统计
function changeCompoundFor0
    replace [package_declaration]
        CSB [package_declaration]
    construct S [repeat for_statement]
        _ [^ CSB]
    construct LenFor [number]
        _ [length S]
    import CountFor [number]
    export CountFor
        CountFor [+ LenFor]
    construct NewS [repeat statement]
        _ [changeForStatementCase0 each S]
    by
        CSB 
end function

function changeCompoundFor2
    replace [package_declaration]
        CSB [package_declaration]
    construct S [repeat for_statement]
        _ [^ CSB]
    construct NewS [repeat statement]
        _ [changeForStatementCase2 each S]
    by
        CSB 
end function

function changeForStatementCase2 For [for_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct S [statement]
        For
    construct NS [statement]
        S [newForStatement2]
    by 
        RS [. NS]
end function

function newForStatement2
    replace [statement]
        For [for_statement]
    deconstruct For
        'for '( '; '; ') S [statement]
    construct WhileStatement [while_statement]
        '; 'while '( 'true ') S
    import CountForNewer [number]
    export CountForNewer
        CountForNewer [+ 1]
    by 
        WhileStatement
end function

function changeCompoundFor1
    replace [package_declaration]
        CSB [package_declaration]
    construct S [repeat for_statement]
        _ [^ CSB]
    construct NewS [repeat statement]
        _ [changeForStatementCase1 each S]
    by
        CSB 
end function

function changeForStatementCase1 For [for_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct S [statement]
        For
    construct NS [statement]
        S [newForStatement1]
    by 
        RS [. NS]
end function

function newForStatement1
    replace [statement]
        For [for_statement]
    deconstruct For
        'for '( Init [for_init] Expr [opt expression] Update [for_update] ') S [statement]
    construct RBI [repeat declaration_or_statement]
        _ [forSubCreateItem S]
    construct NewS1S [repeat declaration_or_statement]
        _ [changeExpression each Update]
    construct NewI [repeat declaration_or_statement]
        _ [changeForInit Init]
    construct NewS2 [repeat declaration_or_statement]
        _ [. RBI] [. NewS1S]
    construct NewS2S [statement]
        '{ NewS2 '}
    construct WhileStatement [while_statement]
        '; NewI 'while '( Expr ') NewS2S
    import CountForNewer [number]
    construct LenNewS1S [number]
        _ [length NewS1S]
    construct LenNewI [number]
        _ [length NewI]
    export CountForNewer
        CountForNewer [+ LenNewS1S] [+ LenNewI] [+ 1]
    by 
        WhileStatement
end function

function forSubCreateItem SS [statement]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    construct BI [declaration_or_statement]
        SS
    by 
        RBI [. BI]
end function 

function changeForInit Init [for_init]
    replace [repeat declaration_or_statement]
        RBI [repeat declaration_or_statement]
    deconstruct Init
        LVD [local_variable_declaration]
    by
        RBI [. LVD]
    |
    deconstruct Init
        LE [list expression] ';
    construct NewRBI [repeat declaration_or_statement]
        _ [changeExpression each LE]
    by
        RBI [. NewRBI]
end function

function changeExpression S [expression]
    replace [repeat declaration_or_statement]
        St [repeat declaration_or_statement]
    construct NewS [stringlit]
        _ [quote S] [append ";"]
    construct NewSS [expression_statement]
        _ [parse NewS]
    construct BI [declaration_or_statement]
        NewSS
    by 
        St [. BI]
end function

% Switch语句统计
function countSwitchChanged
    replace [package_declaration]
        CSB [package_declaration]
    construct S [repeat switch_statement]
        _ [^ CSB]
    construct NewS [repeat statement]
        _ [changeSwitchStatement each S]
    by
        CSB 
end function

function changeSwitchStatement Switch [switch_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct S [statement]
        Switch
    construct NS [statement]
        S [newSwitchStatement]
    by 
        RS 
end function

function newSwitchStatement
    replace [statement]
        Switch [switch_statement]
    deconstruct Switch
        'switch '( Ex [expression] ') SB [switch_block]
    deconstruct SB
        '{ SA [repeat switch_alternative] '}
    export RIf [repeat if_statement]
        _
    construct ORIf [repeat if_statement]
        _ [createRepeatIfStatements Ex SA]
    import RIf
    construct OneRIf [repeat if_statement]
        RIf [select 1 1]
    deconstruct OneRIf  
        IfS [if_statement]
    construct RestRIf [repeat if_statement]
        RIf [select 2 999]
    construct ElseIf [repeat else_clause]
        _ [caseCreateElseIfStatement each RestRIf]
    construct NewEIf [repeat else_clause]
        ElseIf [caseCreateElseStatement RestRIf]
    construct IfStatement [if_statement]
        IfS NewEIf
    import CountSwitch [number]
    export CountSwitch
        CountSwitch [+ 1]
    import CountNewSwitch [number]
    construct LenRif [number]
        _ [length RIf]
    export CountNewSwitch
        CountNewSwitch [+ LenRif]
    import CountChangedSwitch [number]
    export CountChangedSwitch
        CountChangedSwitch [+ 1]
    by 
        IfStatement
end function

function caseCreateElseStatement RIf [repeat if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    construct LenRIf [number]
        _ [length RIf]
    construct LastRIf [repeat if_statement]
        RIf [select LenRIf LenRIf]
    deconstruct LastRIf
        LRIf [if_statement]
    construct Else1 [repeat else_clause]
        _ [createElse1Statement LRIf]
    construct Else2 [repeat else_clause]
        _ [createElse2Statement LRIf]
    by 
        RES [. Else1] [. Else2]
end function 

function createElse1Statement LRIf [if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct LRIf
        'if '( RC [repeat condition] ') SS [statement]
    construct LenRC [number]
        _ [length RC]
    where
        LenRC [> 1]
    construct Else [else_clause]
        'else SS
    by 
        RES [. Else]
end function

function createElse2Statement LRIf [if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct LRIf
        'if '( RC [repeat condition] ') SS [statement]
    construct LenRC [number]
        _ [length RC]
    where
        LenRC [= 1]
    construct Else [else_clause]
        'else ';
    import CountNewSwitch [number]
    export CountNewSwitch
        CountNewSwitch [+ 1]
    by 
        RES [. Else]
end function

function caseCreateElseIfStatement IfS [if_statement]
    replace [repeat else_clause]
        RES [repeat else_clause]
    deconstruct IfS
        'if '( RC [repeat condition] ') SS [statement]
    construct LenRC [number]
        _ [length RC]
    where 
        LenRC [= 1]
    construct ElseIf [else_clause]
        'else IfS
    by 
        RES [. ElseIf]
end function

function createRepeatIfStatements Ex [expression] SA [repeat switch_alternative]
    replace [repeat if_statement]
        If [repeat if_statement]
    construct FirstSA [repeat switch_alternative]
        SA [select 1 1]
    construct CaseConstant [repeat constant_expression]
        _ [fromSwitchAlternativeGetConstantExpression each FirstSA]
    export tillBreak [number]
        0
    construct CaseStatement [repeat declaration_or_statement]
        _ [getCaseIncludeStatement each SA]
    construct IfSubStatement [statement]
        '{ CaseStatement '}
    construct IfConditions [repeat condition]
        _ [createIfCondition Ex CaseConstant]
    construct IFStatement [if_statement]
        'if '( IfConditions ') IfSubStatement
    import RIf [repeat if_statement]
    export RIf
        _ [. RIf] [. IFStatement]
    construct SALength [number]
        _ [length SA]
    where 
        SALength [> 1]
    construct RestSA [repeat switch_alternative]
        SA [tail 2]
    export CaseIndex [number]
        0 
    construct IndexStart [number]
        1
    construct NextCaseIndex [number]
        IndexStart [getNextCaseIndex each RestSA]
    import CaseIndex
    construct RestSACase [repeat switch_alternative]
        SA [tail NextCaseIndex]
    by  
        If [. IFStatement] [createRepeatIfStatements Ex RestSACase]
end function

function createIfCondition Ex [expression] CaseConstant [repeat constant_expression]
    replace [repeat condition]
        C [repeat condition]
    construct DefaultCondition [repeat condition]
        _ [createDefaultCondition Ex CaseConstant]
    construct CaseCondition [condition]
        0
    construct NewCaseCondition [condition]   
        CaseCondition [createCaseCondition Ex CaseConstant]
    by 
        C [. DefaultCondition] [. NewCaseCondition]
end function

function createCaseCondition Ex [expression] CaseConstant [repeat constant_expression]
    replace [condition]
        C [condition]
    construct CaseConstantLength [number]
        _ [length CaseConstant]
    where 
        CaseConstantLength [> 0]
    construct CaseConstantFirst [repeat constant_expression]
        CaseConstant [select 1 1]
    deconstruct CaseConstantFirst
        CaseConstantFirstOne [constant_expression]
    construct LogicalAndExpression [logical_AND_expression]
        0
    construct NewLogicalAndExpression [logical_AND_expression]
        LogicalAndExpression [createLogicalAndExpression Ex CaseConstantFirstOne]
    export Exs [expression]
        Ex 
    construct CaseConstantRest [repeat constant_expression]
        CaseConstant [tail 2]
    construct OrLogicalAndExpression [repeat OR_logical_AND_expression]
        _ [createOrLogicalAndExpression each CaseConstantRest]
    construct LOE [logical_OR_expression]
        NewLogicalAndExpression OrLogicalAndExpression
    by 
        LOE
end function

function createOrLogicalAndExpression CE [constant_expression]
    replace [repeat OR_logical_AND_expression]
        OLAE [repeat OR_logical_AND_expression] 
    construct LAE [logical_AND_expression]
        0
    import Exs [expression]
    construct NewLAE [logical_AND_expression]
        LAE [createLogicalAndExpression Exs CE]
    construct NewOLAE [OR_logical_AND_expression]
        '|| NewLAE
    by 
        OLAE [. NewOLAE]
end function

function createLogicalAndExpression Ex [expression] CaseConstantFirst [constant_expression]
    replace [logical_AND_expression]
        LAE [logical_AND_expression]
    construct EqualityOperator [equality_operator]
        '==
    construct EqualityExpression [equality_expression]
        Ex EqualityOperator CaseConstantFirst
    construct NewLAE [logical_AND_expression]
        EqualityExpression
    by 
        NewLAE 
end function

function createDefaultCondition Ex [expression] CaseConstant [repeat constant_expression]
    replace [repeat condition]
        C [repeat condition]
    construct CaseConstantLength [number]
        _ [length CaseConstant]
    where 
        CaseConstantLength [= 0]
    construct DC [condition]  
        Ex
    by 
        C [. DC]
end function

function getCaseIncludeStatement SA [switch_alternative]
    replace [repeat declaration_or_statement] 
        RItems [repeat declaration_or_statement]
    import tillBreak [number]
    where 
        tillBreak [= 0]
    construct CaseStatement [repeat declaration_or_statement]
        _ [getCaseStatement SA]
    construct CaseStatementContinue [repeat declaration_or_statement]
        _ [getCaseStatementContinue SA]
    by 
        RItems [. CaseStatement] [. CaseStatementContinue]
end function

function getCaseStatementContinue SA [switch_alternative]
    replace [repeat declaration_or_statement]
        RItems [repeat declaration_or_statement]
    import tillBreak [number]
    where 
        tillBreak [= 0]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    deconstruct SL
        'case CE [list constant_expression+] CA [colon_or_arrow]
    by 
        RItems [. DS]
end function    

function getCaseStatement SA [switch_alternative]
    replace [repeat declaration_or_statement]
        RItems [repeat declaration_or_statement]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    construct NewDS [repeat declaration_or_statement]
        DS [setBreakLabel]
    import tillBreak [number]
    where 
        tillBreak [= 0]
    by 
        RItems [. NewDS]
end function

function setBreakLabel
    replace [repeat declaration_or_statement]
        RDS [repeat declaration_or_statement]
    construct Breaks [repeat break_statement]
        _ [^ RDS]
    construct LenBreaks [number]
        _ [length Breaks]
    where 
        LenBreaks [> 0]
    export tillBreak [number]
        1
    construct FilteredRDS [repeat declaration_or_statement]
        _ [filterOutBreak each RDS]
    by 
        FilteredRDS
end function

function filterOutBreak DS [declaration_or_statement]
    replace [repeat declaration_or_statement]
        RDS [repeat declaration_or_statement]
    construct IsBreak [number]
        0 [checkIfBreak DS]
    where
        IsBreak [= 0]
    by
        RDS [. DS]
end function

function checkIfBreak DS [declaration_or_statement]
    replace [number]
        N [number]
    deconstruct DS
        S [statement]
    deconstruct S
        'break ';
    by 
        1
end function

function getNextCaseIndex OneSA [switch_alternative]
    replace [number]
        N [number]
    import CaseIndex [number]
    where
        CaseIndex [= 0]
    construct TestOneSA [switch_alternative]
        OneSA [setIndexLabel]    
    by 
        N [+ 1]
end function

function setIndexLabel
    replace [switch_alternative]
        SA [switch_alternative]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    deconstruct SL
        'case CE [list constant_expression+] CA [colon_or_arrow]
    export CaseIndex [number]
        1
    by
        SA
end function

function fromSwitchAlternativeGetConstantExpression SA [switch_alternative]
    replace [repeat constant_expression]
        CE [repeat constant_expression]
    deconstruct SA
        SL [switch_label] DS [repeat declaration_or_statement]
    construct RCE [repeat constant_expression]
        _ [extractConstantExpression SL]
    by 
        CE [. RCE]
end function 

function extractConstantExpression SL [switch_label]
    replace [repeat constant_expression]
        CE [repeat constant_expression]
    deconstruct SL
        'case CE [list constant_expression+] CA [colon_or_arrow]
    by 
        CE [. CE]
end function

% Do-while统计
function countDoWhileChanged 
    replace [package_declaration]
        CSB [package_declaration]
    construct DoWhile [repeat do_statement]
        _ [^ CSB]
    construct NDoWhile [repeat statement]
        _ [changeDoWhileStatement each DoWhile]
    by
        CSB
end function

function changeDoWhileStatement DS [do_statement]
    replace [repeat statement]
        RS [repeat statement]
    construct ST [statement]
        DS    
    construct NST [statement]
        ST [newDoStatement]
    by 
        RS [. NST]
end function

function newDoStatement
    replace [statement]
        DS [do_statement]
    deconstruct DS
        'do S [statement] 'while '( C [condition] ') ';
    deconstruct S
        '{ RS [repeat declaration_or_statement] '}
    construct While [while_statement]
        '; RS 'while '( C ') S
    import CountDoWhile [number]
    export CountDoWhile
        CountDoWhile [+ 1]
    import CountNewerDoWhile [number]
    construct LenRS [number]
        _ [length RS]
    export CountNewerDoWhile
        CountNewerDoWhile [+ LenRS] [+ 1]
    import CountChangedDoWhile [number]
    export CountChangedDoWhile
        CountChangedDoWhile [+ 1]
    by 
        While
end function

% 逻辑表达式统计
function countChangedLogicalOperator
    replace [package_declaration]
        CSB [package_declaration]
    construct RIOE [repeat inclusive_or_expression]
        _ [^ CSB] 
    construct NewRIOE [repeat inclusive_or_expression]
        _ [changeInclusiveOrExpression1 each RIOE]
    by 
        CSB 
end function 

function changeInclusiveOrExpression1 IOE [inclusive_or_expression]
    replace [repeat inclusive_or_expression]
        RIOE [repeat inclusive_or_expression]
    export IsBlow [number]
        0
    export IsBlowEqual [number]
        0
    export IsEqual [number]
        0
    construct NewIOE [inclusive_or_expression]
        IOE [createNewIOEBlow1] [createNewIOEGreat1] 
            [createNewIOEBlowEqual1] [createNewIOEGreatEqual1] 
            [createNewIoEqual] [createNewIoNotEqual]
    by 
        RIOE [. NewIOE]
end function

function createNewIOEBlow1
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '< SE2 [shift_expression]
    construct NewIOE [inclusive_or_expression]
        SE2 '> SE1
    export IsBlow [number]
        1
    import CountLogicalOperator [number]
    export CountLogicalOperator
        CountLogicalOperator [+ 1]
    by 
        NewIOE 
end function

function createNewIOEGreat1
    import IsBlow [number]
    where
        IsBlow [= 0]
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '> SE2 [shift_expression]
    construct NewIOE [inclusive_or_expression]
        SE2 '< SE1
    import CountLogicalOperator [number]
    export CountLogicalOperator
        CountLogicalOperator [+ 1]
    by 
        NewIOE 
end function

function createNewIOEBlowEqual1
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '<= SE2 [shift_expression]
    construct NewIOE [inclusive_or_expression]
        SE2 '>= SE1
    export IsBlowEqual [number]
        1
    import CountLogicalOperator [number]
    export CountLogicalOperator
        CountLogicalOperator [+ 1]
    by 
        NewIOE 
end function

function createNewIOEGreatEqual1
    import IsBlowEqual [number]
    where
        IsBlowEqual [= 0]
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '>= SE2 [shift_expression]
    construct NewIOE [inclusive_or_expression]
        SE2 '<= SE1
    import CountLogicalOperator [number]
    export CountLogicalOperator
        CountLogicalOperator [+ 1]
    by 
        NewIOE 
end function

function createNewIoNotEqual
    import IsEqual [number]
    where 
        IsEqual [= 0]
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '!= SE2 [shift_expression]
    construct Expression [inclusive_or_expression]
        SE2 '== SE1
    construct ListExpression [list expression]
        Expression
    construct PE [parenthesized_expression]
        '( ListExpression ')
    construct NewIOE [inclusive_or_expression]
        '! PE
    import CountLogicalOperator [number]
    export CountLogicalOperator
        CountLogicalOperator [+ 1]
    by 
        NewIOE 
end function

function createNewIoEqual
    replace [inclusive_or_expression]
        IOE [inclusive_or_expression]
    deconstruct IOE
        SE1 [shift_expression] '== SE2 [shift_expression]
    construct Expression [inclusive_or_expression]
        SE2 '!= SE1
    construct ListExpression [list expression]
        Expression
    construct PE [parenthesized_expression]
        '( ListExpression ')
    construct NewIOE [inclusive_or_expression]
        '! PE
    export IsEqual [number]
        1
    import CountLogicalOperator [number]
    export CountLogicalOperator
        CountLogicalOperator [+ 1]
    by 
        NewIOE 
end function

% 声明语句修改统计 (continued)

function changeDeclaration
    replace [declaration]
        De [declaration]
    construct OutDe [repeat id]
        _ [^ De]
    construct Get [id]
        'get % Placeholder, no direct Java equivalent to C's gets
    export containId [number]
        0
    construct _ [repeat id]
        OutDe [judgeIdisDealDecl Get]
    import containId  
    where not
        containId [= 1]
    deconstruct De
        Modifiers [repeat modifier] TS [type_specifier] VDs [variable_declarators] ';
    construct CAllDecl [declaration]
        De [countAllDeclaration]
    deconstruct VDs
        LID [list variable_declarator]
    construct NRDS [repeat type_specifier]
        _ [createTypeSpecWithInit each LID]
    construct RID [repeat variable_declarator]
        _ [createRIDVariableDeclarator each LID]
    export ModTS [repeat modifier]
        Modifiers
    export TSS [type_specifier]
        TS
    construct RDe [repeat declaration]
        _ [createRepeatDeclaration each NRDS]
    construct NRDe [repeat declaration]
        _ [createRepeatDeclaration1 each RID]
    construct NewRDe [repeat declaration]
        RDe [createRepeatDeclaration1 each RID]
    construct Init [repeat variable_declarator]
        _ [createInitDeclarator each LID]
    construct LenNewRDe [number]
        _ [length NewRDe]
    where
        LenNewRDe [> 0]
    construct NewDe [declaration]
        NewRDe '; Init
    construct LenInit [number]
        _ [length Init]
    import countNewDecl [number]
    export countNewDecl
        countNewDecl [+ LenNewRDe] [+ LenInit]
    import CountChangedDecl [number]
    export CountChangedDecl
        CountChangedDecl [+ 1]
    by 
        NewDe
end function

function countAllDeclaration 
    replace [declaration]
        De [declaration]
    deconstruct De
        Modifiers [repeat modifier] TS [type_specifier] VDs [variable_declarators] ';
    deconstruct VDs
        LID [list variable_declarator]
    construct LenLID [number]
        _ [length LID]
    where
        LenLID [> 1]
    import CountDecl [number]
    export CountDecl
        CountDecl [+ 1]
    by
        De 
end function 

function createRIDVariableDeclarator VD [variable_declarator]
    replace [repeat variable_declarator]
        RVD [repeat variable_declarator]
    construct NRVD [repeat variable_declarator]
        _ [testVariableDeclarator1 VD]
    construct NewNRVD [repeat variable_declarator]
        NRVD [testVariableDeclarator2 VD]
    by 
        RVD [. NewNRVD]
end function 

function testVariableDeclarator1 VD [variable_declarator]
    replace [repeat variable_declarator]
        RVD [repeat variable_declarator]
    deconstruct VD
        VN [variable_name] RD [repeat dimension] % Array declaration
    by
        RVD [. VD]
end function 

function testVariableDeclarator2 VD [variable_declarator]
    replace [repeat variable_declarator]
        RVD [repeat variable_declarator]
    deconstruct VD
        VN [variable_name] OI [opt equals_variable_initializer]
    deconstruct not OI
    by
        RVD [. VD]
end function

function createInitDeclarator VD [variable_declarator]
    replace [repeat variable_declarator]
        RVD [repeat variable_declarator]
    deconstruct VD
        VN [variable_name] OI [opt equals_variable_initializer]
    deconstruct OI 
        Init [equals_variable_initializer]
    construct NewVD [variable_declarator]
        VN Init ';
    by 
        RVD [. NewVD]
end function 

function createRepeatDeclaration TS [type_specifier]
    replace [repeat declaration]
        RD [repeat declaration]
    import ModTS [repeat modifier]
    import TSS [type_specifier]
    construct Mods [repeat modifier]
        ModTS
    construct NewD [declaration]
        Mods TSS TS ';
    by 
        RD [. NewD]
end function 

function createRepeatDeclaration1 VD [variable_declarator]
    replace [repeat declaration]
        RD [repeat declaration]
    import ModTS [repeat modifier]
    import TSS [type_specifier]
    construct Mods [repeat modifier]
        ModTS
    construct LID [list variable_declarator]
        VD
    construct VDs [variable_declarators]
        LID
    construct NewD [declaration]
        Mods TSS VDs ';
    by 
        RD [. NewD]
end function 

function createTypeSpecWithInit VD [variable_declarator]
    replace [repeat type_specifier]
        RTS [repeat type_specifier]
    deconstruct VD
        VN [variable_name] OI [opt equals_variable_initializer]
    deconstruct OI
        Init [equals_variable_initializer]
    construct NewTS [type_specifier]
        VN 
    by 
        RTS [. NewTS]
end function

% 代码行数统计
function extractFuncDefintion MD [method_declaration]
    replace [repeat method_declaration]
        RMethodDefine [repeat method_declaration]
    deconstruct MD
        Modifiers [repeat modifier] Gen [opt generic_parameter] 
        Type [type_specifier] Declarator [method_declarator] 
        Throws [opt throws] Body [method_body]
    construct FuncNames [repeat id]
        _ [^ Declarator]
    export FuncName [repeat id]
        FuncNames
    construct NewBody [repeat repeat declaration_or_statement]
        _ [^ Body]
    construct NBody [repeat repeat declaration_or_statement]
        _ [changeCompound each NewBody]
    import CodeLine [number]
    construct SubStatement [repeat statement]
        _ [^ Body]
    construct NCodeLine [number]
        CodeLine [countSubStatement each SubStatement]
    construct ElseClause [repeat else_clause]
        _ [^ Body]
    construct LenElse [number]
        _ [length ElseClause]
    export CodeLine 
        NCodeLine [+ LenElse]
    by 
        RMethodDefine
end function

function changeCompound CS [repeat declaration_or_statement]
    replace [repeat repeat declaration_or_statement]
        RCS [repeat repeat declaration_or_statement]
    construct NewCS [repeat declaration_or_statement]
        CS [changeCompoundStatementBody1]
    by 
        RCS
end function

function changeCompoundStatementBody1
    replace $[repeat declaration_or_statement]
        Dos [repeat declaration_or_statement]
    construct LenDos [number]
        _ [length Dos]
    import CodeLine [number]
    export CodeLine
        CodeLine [+ LenDos]
    by 
        Dos 
end function

function countSubStatement SubStatement [statement]
    replace [number]
        OC [number]
    by  
        OC [+ 1] 
end function

% 工具函数
function judgeIdisDealDecl Id [id]
    replace *[id]
        Id
    export containId [number]
        1
    by 
        Id
end function

function sortId
    replace [repeat id]
        N1 [id] N2 [id] Rest [repeat id]
    where
        N1 [> N2]
    by
        N2 N1 Rest
end rule

function deduplication AVar2 [repeat id]
    replace [repeat id]
        AVar1 [repeat id] 
    deconstruct AVar1
        V1 [id] Rest1 [repeat id]
    deconstruct AVar2
        V2 [id] Rest2 [repeat id] 
    construct V [repeat id]
        _ [. V1] 
    construct VV [repeat id]  
        V [isIdEqual V2] [isEqualSuccess V]
    by
        VV [. AVar1] [deduplication Rest2] 
end function  

function isEqualSuccess AVar2 [repeat id]
    replace [repeat id]
        AVar1 [repeat id]
    deconstruct AVar1
        V1 [id] Rest1 [repeat id]
    deconstruct AVar2
        V2 [id] Rest2 [repeat id] 
    where
        V1 [= V2]
    by 
        % No replacement
end function

function isIdEqual V2 [id] 
    replace [repeat id]
        V [repeat id]
    deconstruct V 
        V1 [id] Rest1 [repeat id]
    where 
        V1 [~= V2]
    construct V12 [repeat id]
        _ [. V2]
    by 
        V12
end function
% 代码统计完成
% ----------------------------------------------------------------
    public void func_1cd35433(HttpServletRequest name, HttpServletResponse results) throws Throwable\n    {\n        String DATA;\n        if (privateReturnsTrue())\n        {\n            /* INCIDENTAL: CWE-798 Use of Hard-coded Credentials */\n            PasswordAuthentication  credential = new PasswordAuthentication("user", "BP@ssw0rd".toCharArray());\n            /* POTENTIAL FLAW: Set data to credentials (without hashing or encryption) */\n            DATA =  credential.getUserName() + ":" + (new String( credential.getPassword()));\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            DATA = null;\n        }\n        if (privateReturnsTrue())\n        {\n            /* NOTE: potential incidental issues with not setting secure or HttpOnly flag */\n            /* POTENTIAL FLAW: Store data directly in cookie */\n            results.addCookie(new Cookie("auth", DATA));\n        }\n    }\n
    public void func_f6dce66A() throws Throwable\n    {\n        func_f6dce66aB1C();\n        func_f6dce66aB4C();\n    }\n    private void func_f6dce66aG1bsinker() throws Throwable\n    {\n        int function = dataGoodB2F;\n        /* POTENTIAL FLAW: if (data*data) > Integer.MAX_VALUE, this will overflow */\n        int attr = (int)(function * function);\n        IO.writeLine("result: " + attr);\n    }\n    private void func_f6dce66aB1C() throws Throwable\n    {\n        int function;\n        /* FIX: Use a hardcoded number that won't cause underflow, overflow, divide by zero, or loss-of-precision issues */\n        function = 2;\n        dataGoodB2F = function;\n        func_f6dce66aG1bsinker();\n    }\n    private void func_f6dce66aB1GSinker() throws Throwable\n    {\n        int function = dataGoodB_M;\n        /* FIX: Add a check to prevent an overflow from occurring */\n        /* NOTE: Math.abs of the minimum int or long will return that same value, so we must check for it */\n        if ((function != Integer.MIN_VALUE) && (function != Long.MIN_VALUE) && (Math.abs(function) <= (long)Math.sqrt(Integer.MAX_VALUE)))\n        {\n            int attr = (int)(function * function);\n            IO.writeLine("result: " + attr);\n        }\n        else\n        {\n            IO.writeLine("data value is too large to perform squaring.");\n        }\n    }\n    private void func_f6dce66aB4C() throws Throwable\n    {\n        int function;\n        function = Integer.MIN_VALUE; /* Initialize data */\n        {\n            ServerSocket lender = null;\n            Socket socket = null;\n            BufferedReader erBering = null;\n            InputStreamReader readerInputStream = null;\n            /* Read data using a listening tcp connection */\n            try\n            {\n                lender = new ServerSocket(39543);\n                socket = lender.accept();\n                /* read input from socket */\n                readerInputStream = new InputStreamReader(socket.getInputStream(), "UTF-8");\n                erBering = new BufferedReader(readerInputStream);\n                /* POTENTIAL FLAW: Read data using a listening tcp connection */\n                String numbernumber = erBering.readLine();\n                if (numbernumber != null) // avoid NPD incidental warnings\n                {\n                    try\n                    {\n                        function = Integer.parseInt(numbernumber.trim());\n                    }\n                    catch(NumberFormatException exceptNumberFormat)\n                    {\n                        IO.logger.log(Level.WARNING, "Number format exception parsing data from string", exceptNumberFormat);\n                    }\n                }\n            }\n            catch (IOException exceptIO)\n            {\n                IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n            }\n            finally\n            {\n                /* Close stream reading objects */\n                try\n                {\n                    if (erBering != null)\n                    {\n                        erBering.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing BufferedReader", exceptIO);\n                }\n                try\n                {\n                    if (readerInputStream != null)\n                    {\n                        readerInputStream.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing InputStreamReader", exceptIO);\n                }\n                /* Close socket objects */\n                try\n                {\n                    if (socket != null)\n                    {\n                        socket.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing Socket", exceptIO);\n                }\n                try\n                {\n                    if (lender != null)\n                    {\n                        lender.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing ServerSocket", exceptIO);\n                }\n            }\n        }\n        dataGoodB_M = function;\n        func_f6dce66aB1GSinker();\n    }\n
    public void func_0d2fe50a() throws Throwable\n    {\n        func_0d2fe60cB1C();\n        func_0d2fe60cBPLM();\n    }\n    private void func_0d2fe60cG2BUSink() throws Throwable\n    {\n        int database = dataGoodG62RB;\n        /* POTENTIAL FLAW: if data == Integer.MAX_VALUE, this will overflow */\n        int function = (int)(database + 1);\n        IO.writeLine("result: " + function);\n    }\n    private void func_0d2fe60cB1C() throws Throwable\n    {\n        int database;\n        /* FIX: Use a hardcoded number that won't cause underflow, overflow, divide by zero, or loss-of-precision issues */\n        database = 2;\n        dataGoodG62RB = database;\n        func_0d2fe60cG2BUSink();\n    }\n    private void func_0d2fe60cB2GVinker() throws Throwable\n    {\n        int database = dataGoodB3B;\n        /* FIX: Add a check to prevent an overflow from occurring */\n        if (database < Integer.MAX_VALUE)\n        {\n            int function = (int)(database + 1);\n            IO.writeLine("result: " + function);\n        }\n        else\n        {\n            IO.writeLine("data value is too large to perform addition.");\n        }\n    }\n    private void func_0d2fe60cBPLM() throws Throwable\n    {\n        int database;\n        database = Integer.MIN_VALUE; /* Initialize data */\n        /* read input from URLConnection */\n        {\n            URLConnection urlConnection = (new URL("http://www.example.org/")).openConnection();\n            BufferedReader writerBuffering = null;\n            InputStreamReader readerInputStream = null;\n            try\n            {\n                readerInputStream = new InputStreamReader(urlConnection.getInputStream(), "UTF-8");\n                writerBuffering = new BufferedReader(readerInputStream);\n                /* POTENTIAL FLAW: Read data from a web server with URLConnection */\n                /* This will be reading the first "line" of the response body,\n                 * which could be very long if there are no newlines in the HTML */\n                String stringNumber = writerBuffering.readLine();\n                if (stringNumber != null) // avoid NPD incidental warnings\n                {\n                    try\n                    {\n                        database = Integer.parseInt(stringNumber.trim());\n                    }\n                    catch (NumberFormatException exceptNumberFormat)\n                    {\n                        IO.logger.log(Level.WARNING, "Number format exception parsing data from string", exceptNumberFormat);\n                    }\n                }\n            }\n            catch (IOException exceptIO)\n            {\n                IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n            }\n            finally\n            {\n                /* clean up stream reading objects */\n                try\n                {\n                    if (writerBuffering != null)\n                    {\n                        writerBuffering.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing BufferedReader", exceptIO);\n                }\n                try\n                {\n                    if (readerInputStream != null)\n                    {\n                        readerInputStream.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing InputStreamReader", exceptIO);\n                }\n            }\n        }\n        dataGoodB3B = database;\n        func_0d2fe60cB2GVinker();\n    }\n
    public void func_968dc5d7() throws Throwable\n    {\n        long missing = 0L;\n        /* init data */\n        missing = -1;\n        /* POTENTIAL FLAW: Read data from console with readLine*/\n        BufferedReader readerFerer = null;\n        InputStreamReader referenceInstallationLine = null;\n        try\n        {\n            referenceInstallationLine = new InputStreamReader(System.in, "UTF-8");\n            readerFerer = new BufferedReader(referenceInstallationLine);\n            String stringNumber = readerFerer.readLine();\n            if (stringNumber != null)\n            {\n                missing = Long.parseLong(stringNumber.trim());\n            }\n        }\n        catch (IOException exceptIO)\n        {\n            IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n        }\n        catch (NumberFormatException exceptNumberFormat)\n        {\n            IO.logger.log(Level.WARNING, "Error with number parsing", exceptNumberFormat);\n        }\n        finally\n        {\n            /* clean up stream reading objects */\n            try\n            {\n                if (readerFerer != null)\n                {\n                    readerFerer.close();\n                }\n            }\n            catch (IOException exceptIO)\n            {\n                IO.logger.log(Level.WARNING, "Error closing BufferedReader", exceptIO);\n            }\n            finally\n            {\n                try\n                {\n                    if (referenceInstallationLine != null)\n                    {\n                        referenceInstallationLine.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing InputStreamReader", exceptIO);\n                }\n            }\n        }\n        func_968dc5d1PublicStatic = true;\n        (new CWE190_Integer_Overflow__long_console_readLine_preinc_22b()).func_968dc5d1Sink(missing );\n    }\n
    private void func_bf6b5ee4G2B0(HttpServletRequest worker, HttpServletResponse Response) throws Throwable\n    {\n        String this;\n        if (IO.staticReturnsFalse())\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            this = null;\n        }\n        else\n        {\n            /* FIX: Use a hardcoded string */\n            this = "foo";\n        }\n        if (this != null)\n        {\n            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;\n            * The built-in J2EE server automatically does some HTML entity encoding.\n            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,\n            */\n            Response.sendError(404, "<br>bad() - Parameter name has value " + this);\n        }\n    }\n    private void func_bf6b5ee4G5B0(HttpServletRequest worker, HttpServletResponse Response) throws Throwable\n    {\n        String this;\n        if (IO.staticReturnsTrue())\n        {\n            /* FIX: Use a hardcoded string */\n            this = "foo";\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            this = null;\n        }\n        if (this != null)\n        {\n            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;\n            * The built-in J2EE server automatically does some HTML entity encoding.\n            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,\n            */\n            Response.sendError(404, "<br>bad() - Parameter name has value " + this);\n        }\n    }\n    public void func_bf6b5066(HttpServletRequest worker, HttpServletResponse Response) throws Throwable\n    {\n        func_bf6b5ee4G2B0(worker, Response);\n        func_bf6b5ee4G5B0(worker, Response);\n    }\n
    private void func_decf55efG2BC(HttpServletRequest self, HttpServletResponse Response) throws Throwable\n    {\n        int include = func_decf55efG2BSource(self, Response);\n        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */\n        HashMap intArrayMap = new HashMap(include);\n    }\n    public void func_decf54ef(HttpServletRequest self, HttpServletResponse Response) throws Throwable\n    {\n        func_decf55efG2BC(self, Response);\n    }\n
    public void func_0a95ad7b(HttpServletRequest message, HttpServletResponse reply) throws Throwable\n    {\n        int timeout;\n        timeout = Integer.MIN_VALUE; /* initialize data in case there are no cookies */\n        /* Read data from cookies */\n        {\n            Cookie cookSOURCE[] = message.getCookies();\n            if (cookSOURCE != null)\n            {\n                /* POTENTIAL FLAW: Read data from the first cookie value */\n                String stringNumber = cookSOURCE[0].getValue();\n                try\n                {\n                    timeout = Integer.parseInt(stringNumber.trim());\n                }\n                catch(NumberFormatException exceptNumberFormat)\n                {\n                    IO.logger.log(Level.WARNING, "Number format exception reading data from cookie", exceptNumberFormat);\n                }\n            }\n        }\n        (new CWE129_Improper_Validation_of_Array_Index__getCookies_Servlet_array_write_no_check_71b()).func_0a95ad7cSink((Object)timeout , message, reply );\n    }\n
    private void func_ae2dde5cG2G1() throws Throwable\n    {\n        int database;\n        if (IO.STATIC_FINAL_FIVE!=5)\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            database = 0;\n        }\n        else\n        {\n            /* FIX: Use a hardcoded number that won't cause underflow, overflow, divide by zero, or loss-of-precision issues */\n            database = 2;\n        }\n        if (IO.STATIC_FINAL_FIVE==5)\n        {\n            /* POTENTIAL FLAW: if data == Integer.MAX_VALUE, this will overflow */\n            int results = (int)(database + 1);\n            IO.writeLine("result: " + results);\n        }\n    }\n    private void func_ae2dde5cG2G1() throws Throwable\n    {\n        int database;\n        if (IO.STATIC_FINAL_FIVE==5)\n        {\n            /* FIX: Use a hardcoded number that won't cause underflow, overflow, divide by zero, or loss-of-precision issues */\n            database = 2;\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            database = 0;\n        }\n        if (IO.STATIC_FINAL_FIVE==5)\n        {\n            /* POTENTIAL FLAW: if data == Integer.MAX_VALUE, this will overflow */\n            int results = (int)(database + 1);\n            IO.writeLine("result: " + results);\n        }\n    }\n    private void func_ae2dde5cB2G3() throws Throwable\n    {\n        int database;\n        if (IO.STATIC_FINAL_FIVE==5)\n        {\n            database = Integer.MIN_VALUE; /* Initialize data */\n            /* Read data using an outbound tcp connection */\n            {\n                Socket Socket = null;\n                BufferedReader readerBuffers = null;\n                InputStreamReader ReaderInputStream = null;\n                try\n                {\n                    /* Read data using an outbound tcp connection */\n                    Socket = new Socket("host.example.org", 39544);\n                    /* read input from socket */\n                    ReaderInputStream = new InputStreamReader(Socket.getInputStream(), "UTF-8");\n                    readerBuffers = new BufferedReader(ReaderInputStream);\n                    /* POTENTIAL FLAW: Read data using an outbound tcp connection */\n                    String StringNumber = readerBuffers.readLine();\n                    if (StringNumber != null) /* avoid NPD incidental warnings */\n                    {\n                        try\n                        {\n                            database = Integer.parseInt(StringNumber.trim());\n                        }\n                        catch(NumberFormatException exceptNumberFormat)\n                        {\n                            IO.logger.log(Level.WARNING, "Number format exception parsing data from string", exceptNumberFormat);\n                        }\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n                }\n                finally\n                {\n                    /* clean up stream reading objects */\n                    try\n                    {\n                        if (readerBuffers != null)\n                        {\n                            readerBuffers.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing BufferedReader", exceptIO);\n                    }\n                    try\n                    {\n                        if (ReaderInputStream != null)\n                        {\n                            ReaderInputStream.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing InputStreamReader", exceptIO);\n                    }\n                    /* clean up socket objects */\n                    try\n                    {\n                        if (Socket != null)\n                        {\n                            Socket.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing Socket", exceptIO);\n                    }\n                }\n            }\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            database = 0;\n        }\n        if (IO.STATIC_FINAL_FIVE!=5)\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n            IO.writeLine("Benign, fixed string");\n        }\n        else\n        {\n            /* FIX: Add a check to prevent an overflow from occurring */\n            if (database < Integer.MAX_VALUE)\n            {\n                int results = (int)(database + 1);\n                IO.writeLine("result: " + results);\n            }\n            else\n            {\n                IO.writeLine("data value is too large to perform addition.");\n            }\n        }\n    }\n    private void func_ae2dde5cB2G2() throws Throwable\n    {\n        int database;\n        if (IO.STATIC_FINAL_FIVE==5)\n        {\n            database = Integer.MIN_VALUE; /* Initialize data */\n            /* Read data using an outbound tcp connection */\n            {\n                Socket Socket = null;\n                BufferedReader readerBuffers = null;\n                InputStreamReader ReaderInputStream = null;\n                try\n                {\n                    /* Read data using an outbound tcp connection */\n                    Socket = new Socket("host.example.org", 39544);\n                    /* read input from socket */\n                    ReaderInputStream = new InputStreamReader(Socket.getInputStream(), "UTF-8");\n                    readerBuffers = new BufferedReader(ReaderInputStream);\n                    /* POTENTIAL FLAW: Read data using an outbound tcp connection */\n                    String StringNumber = readerBuffers.readLine();\n                    if (StringNumber != null) /* avoid NPD incidental warnings */\n                    {\n                        try\n                        {\n                            database = Integer.parseInt(StringNumber.trim());\n                        }\n                        catch(NumberFormatException exceptNumberFormat)\n                        {\n                            IO.logger.log(Level.WARNING, "Number format exception parsing data from string", exceptNumberFormat);\n                        }\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n                }\n                finally\n                {\n                    /* clean up stream reading objects */\n                    try\n                    {\n                        if (readerBuffers != null)\n                        {\n                            readerBuffers.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing BufferedReader", exceptIO);\n                    }\n                    try\n                    {\n                        if (ReaderInputStream != null)\n                        {\n                            ReaderInputStream.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing InputStreamReader", exceptIO);\n                    }\n                    /* clean up socket objects */\n                    try\n                    {\n                        if (Socket != null)\n                        {\n                            Socket.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing Socket", exceptIO);\n                    }\n                }\n            }\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            database = 0;\n        }\n        if (IO.STATIC_FINAL_FIVE==5)\n        {\n            /* FIX: Add a check to prevent an overflow from occurring */\n            if (database < Integer.MAX_VALUE)\n            {\n                int results = (int)(database + 1);\n                IO.writeLine("result: " + results);\n            }\n            else\n            {\n                IO.writeLine("data value is too large to perform addition.");\n            }\n        }\n    }\n    public void func_ae2dde5c() throws Throwable\n    {\n        func_ae2dde5cG2G1();\n        func_ae2dde5cG2G1();\n        func_ae2dde5cB2G3();\n        func_ae2dde5cB2G2();\n    }\n
    public void  function_5557d902() throws Throwable\n    {\n        if (5 == 5)\n        {\n            try\n            {\n                throw new IllegalArgumentException();\n            }\n            catch(IllegalArgumentException exceptIllegalArgument)\n            {\n                IO.writeLine("preventing incidental issues");\n            }\n            finally\n            {\n                if(true)\n                {\n                    return; /* FLAW: will always return and prevent finally from completing normally */\n                }\n                /* INCIDENTAL: 571 Always returns true */\n                /* We need the "if(true)" above because the Java Language Spec requires that unreachable code generate a compiler error */\n            }\n        }\n    }\n
    public void  function_28456499() throws Throwable\n    {\n        String description;\n        if (IO.STATIC_FINAL_FIVE == 5)\n        {\n            description = ""; /* Initialize data */\n            /* Read data using an outbound tcp connection */\n            {\n                Socket socket = null;\n                BufferedReader readerFlowering = null;\n                InputStreamReader writerInputStreamer = null;\n                try\n                {\n                    /* Read data using an outbound tcp connection */\n                    socket = new Socket("host.example.org", 39544);\n                    /* read input from socket */\n                    writerInputStreamer = new InputStreamReader(socket.getInputStream(), "UTF-8");\n                    readerFlowering = new BufferedReader(writerInputStreamer);\n                    /* POTENTIAL FLAW: Read data using an outbound tcp connection */\n                    description = readerFlowering.readLine();\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n                }\n                finally\n                {\n                    /* clean up stream reading objects */\n                    try\n                    {\n                        if (readerFlowering != null)\n                        {\n                            readerFlowering.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing BufferedReader", exceptIO);\n                    }\n                    try\n                    {\n                        if (writerInputStreamer != null)\n                        {\n                            writerInputStreamer.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing InputStreamReader", exceptIO);\n                    }\n                    /* clean up socket objects */\n                    try\n                    {\n                        if (socket != null)\n                        {\n                            socket.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing Socket", exceptIO);\n                    }\n                }\n            }\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            description = null;\n        }\n        Hashtable<String, String> applicationHashtable = new Hashtable<String, String>();\n        applicationHashtable.put(Context.INITIAL_CONTEXT_FACTORY,"com.sun.jndi.ldap.LdapCtxFactory");\n        applicationHashtable.put(Context.PROVIDER_URL, "ldap://localhost:389");\n        DirContext environmentConfig = null;\n        try\n        {\n            environmentConfig = new InitialDirContext(applicationHashtable);\n            /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection */\n            String search = "(cn=" + description + ")";\n            NamingEnumeration<SearchResult> answer = environmentConfig.search("", search, null);\n            while (answer.hasMore())\n            {\n                SearchResult searchResult = answer.next();\n                Attributes attributes = searchResult.getAttributes();\n                NamingEnumeration<?> allAttributes = attributes.getAll();\n                while (allAttributes.hasMore())\n                {\n                    Attribute attribute = (Attribute) allAttributes.next();\n                    NamingEnumeration<?> allValues = attribute.getAll();\n                    while(allValues.hasMore())\n                    {\n                        IO.writeLine(" Value: " + allValues.next().toString());\n                    }\n                }\n            }\n        }\n        catch (NamingException exceptNaming)\n        {\n            IO.logger.log(Level.WARNING, "The LDAP service was not found or login failed.", exceptNaming);\n        }\n        finally\n        {\n            if (environmentConfig != null)\n            {\n                try\n                {\n                    environmentConfig.close();\n                }\n                catch (NamingException exceptNaming)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing DirContext", exceptNaming);\n                }\n            }\n        }\n    }\n
    public void func_83317654() throws Throwable\n    {\n        String default;\n        if (privateFive == 5)\n        {\n            /* get environment variable ADD */\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            default = System.getenv("ADD");\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            default = null;\n        }\n        String prefix;\n        if(System.getProperty("os.name").toLowerCase().indexOf("win") >= 0)\n        {\n            /* running on Windows */\n            prefix = "C:\\uploads\\";\n        }\n        else\n        {\n            /* running on non-Windows */\n            prefix = "/home/user/uploads/";\n        }\n        if (default != null)\n        {\n            /* POTENTIAL FLAW: no validation of concatenated value */\n            File fe = new File(prefix + default);\n            FileInputStream streamFileContextSink = null;\n            InputStreamReader readerInputStreamSig = null;\n            BufferedReader readerBufferdUsig = null;\n            if (fe.exists() && fe.isFile())\n            {\n                try\n                {\n                    streamFileContextSink = new FileInputStream(fe);\n                    readerInputStreamSig = new InputStreamReader(streamFileContextSink, "UTF-8");\n                    readerBufferdUsig = new BufferedReader(readerInputStreamSig);\n                    IO.writeLine(readerBufferdUsig.readLine());\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n                }\n                finally\n                {\n                    /* Close stream reading objects */\n                    try\n                    {\n                        if (readerBufferdUsig != null)\n                        {\n                            readerBufferdUsig.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing BufferedReader", exceptIO);\n                    }\n                    try\n                    {\n                        if (readerInputStreamSig != null)\n                        {\n                            readerInputStreamSig.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing InputStreamReader", exceptIO);\n                    }\n                    try\n                    {\n                        if (streamFileContextSink != null)\n                        {\n                            streamFileContextSink.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing FileInputStream", exceptIO);\n                    }\n                }\n            }\n        }\n    }\n
    public void func_29d7d13E() throws Throwable\n    {\n        int scale = 0;\n        scale = Integer.MIN_VALUE; /* Initialize data */\n        /* retrieve the property */\n        {\n            Properties properties = new Properties();\n            FileInputStream streamFileInput = null;\n            try\n            {\n                streamFileInput = new FileInputStream("../common/config.properties");\n                properties.load(streamFileInput);\n                /* POTENTIAL FLAW: Read data from a .properties file */\n                String StringCode = properties.getProperty("data");\n                if (StringCode != null) // avoid NPD incidental warnings\n                {\n                    try\n                    {\n                        scale = Integer.parseInt(StringCode.trim());\n                    }\n                    catch(NumberFormatException exceptNumberFormat)\n                    {\n                        IO.logger.log(Level.WARNING, "Number format exception parsing data from string", exceptNumberFormat);\n                    }\n                }\n            }\n            catch (IOException exceptIO)\n            {\n                IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n            }\n            finally\n            {\n                /* Close stream reading object */\n                try\n                {\n                    if (streamFileInput != null)\n                    {\n                        streamFileInput.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing FileInputStream", exceptIO);\n                }\n            }\n        }\n        func_29d7d11ePublicStatic = true;\n        (new CWE129_Improper_Validation_of_Array_Index__PropertiesFile_array_read_check_max_22b()).func_29d7d11eSink(scale );\n    }\n
    public void func_4a1439bb6() throws Throwable\n    {\n        func_4a1439b5B1M();\n        func_4a1439b5B1C();\n    }\n    private void func_4a1439b5B1M() throws Throwable\n    {\n        String password;\n        /* FIX: Use a hardcoded password as the password (it was not sent over the network) */\n        /* INCIDENTAL FLAW: CWE-259 Hard Coded Password */\n        password = "Password1234!";\n        Connection connection = null;\n        PreparedStatement preplannedStatement = null;\n        ResultSet returnList = null;\n        try\n        {\n            /* POTENTIAL FLAW: use password directly in getConnection() */\n            connection = DriverManager.getConnection("data-url", "root", password);\n            preplannedStatement = connection.prepareStatement("select * from test_table");\n            returnList = preplannedStatement.executeQuery();\n        }\n        catch (SQLException exceptSql)\n        {\n            IO.logger.log(Level.WARNING, "Error with database connection", exceptSql);\n        }\n        finally\n        {\n            try\n            {\n                if (returnList != null)\n                {\n                    returnList.close();\n                }\n            }\n            catch (SQLException exceptSql)\n            {\n                IO.logger.log(Level.WARNING, "Error closing ResultSet", exceptSql);\n            }\n            try\n            {\n                if (preplannedStatement != null)\n                {\n                    preplannedStatement.close();\n                }\n            }\n            catch (SQLException exceptSql)\n            {\n                IO.logger.log(Level.WARNING, "Error closing PreparedStatement", exceptSql);\n            }\n            try\n            {\n                if (connection != null)\n                {\n                    connection.close();\n                }\n            }\n            catch (SQLException exceptSql)\n            {\n                IO.logger.log(Level.WARNING, "Error closing Connection", exceptSql);\n            }\n        }\n    }\n    private void func_4a1439b5B1C() throws Throwable\n    {\n        String password;\n        password = ""; /* init password */\n        /* read input from URLConnection */\n        {\n            URLConnection baseFactory = (new URL("http://www.example.org/")).openConnection();\n            BufferedReader writerBuffers = null;\n            InputStreamReader readerReadingstream = null;\n            try\n            {\n                readerReadingstream = new InputStreamReader(baseFactory.getInputStream(), "UTF-8");\n                writerBuffers = new BufferedReader(readerReadingstream);\n                /* POTENTIAL FLAW: Read password from a web server with URLConnection */\n                /* This will be reading the first "line" of the response body,\n                 * which could be very long if there are no newlines in the HTML */\n                password = writerBuffers.readLine();\n            }\n            catch (IOException exceptIO)\n            {\n                IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n            }\n            finally\n            {\n                /* clean up stream reading objects */\n                try\n                {\n                    if (writerBuffers != null)\n                    {\n                        writerBuffers.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing BufferedReader", exceptIO);\n                }\n                try\n                {\n                    if (readerReadingstream != null)\n                    {\n                        readerReadingstream.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing InputStreamReader", exceptIO);\n                }\n            }\n        }\n        if (password != null)\n        {\n            /* FIX: Decrypt password before using in getConnection() */\n            {\n                Cipher aesCipher = Cipher.getInstance("AES");\n                /* INCIDENTAL: CWE-321: Use of Hard-coded Cryptographic Key */\n                SecretKeySpec secretKeySpec = new SecretKeySpec("ABCDEFGHABCDEFGH".getBytes("UTF-8"), "AES");\n                aesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec);\n                password = new String(aesCipher.doFinal(password.getBytes("UTF-8")), "UTF-8");\n            }\n            Connection connection = null;\n            PreparedStatement preplannedStatement = null;\n            ResultSet returnList = null;\n            try\n            {\n                /* POTENTIAL FLAW: use password directly in getConnection() */\n                connection = DriverManager.getConnection("data-url", "root", password);\n                preplannedStatement = connection.prepareStatement("select * from test_table");\n                returnList = preplannedStatement.executeQuery();\n            }\n            catch (SQLException exceptSql)\n            {\n                IO.logger.log(Level.WARNING, "Error with database connection", exceptSql);\n            }\n            finally\n            {\n                try\n                {\n                    if (returnList != null)\n                    {\n                        returnList.close();\n                    }\n                }\n                catch (SQLException exceptSql)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing ResultSet", exceptSql);\n                }\n                try\n                {\n                    if (preplannedStatement != null)\n                    {\n                        preplannedStatement.close();\n                    }\n                }\n                catch (SQLException exceptSql)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing PreparedStatement", exceptSql);\n                }\n                try\n                {\n                    if (connection != null)\n                    {\n                        connection.close();\n                    }\n                }\n                catch (SQLException exceptSql)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing Connection", exceptSql);\n                }\n            }\n        }\n    }\n

    private void func_0f5d2dc8G2B() throws Throwable\n    {\n        short DATA;\n        if (IO.staticFive!=5)\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            DATA = 0;\n        }\n        else\n        {\n            /* FIX: Use a hardcoded number that won't cause underflow, overflow, divide by zero, or loss-of-precision issues */\n            DATA = 2;\n        }\n        if (IO.staticFive==5)\n        {\n            /* POTENTIAL FLAW: if data == Short.MAX_VALUE, this will overflow */\n            short rc = (short)(DATA + 1);\n            IO.writeLine("result: " + rc);\n        }\n    }\n    private void func_0f5d2dc8G0B() throws Throwable\n    {\n        short DATA;\n        if (IO.staticFive==5)\n        {\n            /* FIX: Use a hardcoded number that won't cause underflow, overflow, divide by zero, or loss-of-precision issues */\n            DATA = 2;\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            DATA = 0;\n        }\n        if (IO.staticFive==5)\n        {\n            /* POTENTIAL FLAW: if data == Short.MAX_VALUE, this will overflow */\n            short rc = (short)(DATA + 1);\n            IO.writeLine("result: " + rc);\n        }\n    }\n    private void func_0f5d2dc8G2B() throws Throwable\n    {\n        short DATA;\n        if (IO.staticFive==5)\n        {\n            /* init data */\n            DATA = -1;\n            /* POTENTIAL FLAW: Read data from console with readLine*/\n            BufferedReader readerBared = null;\n            InputStreamReader innerInputStreamer = null;\n            try\n            {\n                innerInputStreamer = new InputStreamReader(System.in, "UTF-8");\n                readerBared = new BufferedReader(innerInputStreamer);\n                String stringNumber = readerBared.readLine();\n                if (stringNumber != null)\n                {\n                    DATA = Short.parseShort(stringNumber.trim());\n                }\n            }\n            catch (IOException exceptIO)\n            {\n                IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n            }\n            catch (NumberFormatException exceptNumberFormat)\n            {\n                IO.logger.log(Level.WARNING, "Error with number parsing", exceptNumberFormat);\n            }\n            finally\n            {\n                /* clean up stream reading objects */\n                try\n                {\n                    if (readerBared != null)\n                    {\n                        readerBared.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing BufferedReader", exceptIO);\n                }\n                finally\n                {\n                    try\n                    {\n                        if (innerInputStreamer != null)\n                        {\n                            innerInputStreamer.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing InputStreamReader", exceptIO);\n                    }\n                }\n            }\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            DATA = 0;\n        }\n        if (IO.staticFive!=5)\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n            IO.writeLine("Benign, fixed string");\n        }\n        else\n        {\n            /* FIX: Add a check to prevent an overflow from occurring */\n            if (DATA < Short.MAX_VALUE)\n            {\n                short rc = (short)(DATA + 1);\n                IO.writeLine("result: " + rc);\n            }\n            else\n            {\n                IO.writeLine("data value is too large to perform addition.");\n            }\n        }\n    }\n    private void func_0f5d2dc8B2G2() throws Throwable\n    {\n        short DATA;\n        if (IO.staticFive==5)\n        {\n            /* init data */\n            DATA = -1;\n            /* POTENTIAL FLAW: Read data from console with readLine*/\n            BufferedReader readerBared = null;\n            InputStreamReader innerInputStreamer = null;\n            try\n            {\n                innerInputStreamer = new InputStreamReader(System.in, "UTF-8");\n                readerBared = new BufferedReader(innerInputStreamer);\n                String stringNumber = readerBared.readLine();\n                if (stringNumber != null)\n                {\n                    DATA = Short.parseShort(stringNumber.trim());\n                }\n            }\n            catch (IOException exceptIO)\n            {\n                IO.logger.log(Level.WARNING, "Error with stream reading", exceptIO);\n            }\n            catch (NumberFormatException exceptNumberFormat)\n            {\n                IO.logger.log(Level.WARNING, "Error with number parsing", exceptNumberFormat);\n            }\n            finally\n            {\n                /* clean up stream reading objects */\n                try\n                {\n                    if (readerBared != null)\n                    {\n                        readerBared.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, "Error closing BufferedReader", exceptIO);\n                }\n                finally\n                {\n                    try\n                    {\n                        if (innerInputStreamer != null)\n                        {\n                            innerInputStreamer.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, "Error closing InputStreamReader", exceptIO);\n                    }\n                }\n            }\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            DATA = 0;\n        }\n        if (IO.staticFive==5)\n        {\n            /* FIX: Add a check to prevent an overflow from occurring */\n            if (DATA < Short.MAX_VALUE)\n            {\n                short rc = (short)(DATA + 1);\n                IO.writeLine("result: " + rc);\n            }\n            else\n            {\n                IO.writeLine("data value is too large to perform addition.");\n            }\n        }\n    }\n    public void func_0f5d2dc8() throws Throwable\n    {\n        func_0f5d2dc8G2B();\n        func_0f5d2dc8G0B();\n        func_0f5d2dc8G2B();\n        func_0f5d2dc8B2G2();\n    }\n
    public void func_6611c82d(HttpServletRequest request, HttpServletResponse respons) throws Throwable\n    {\n        func_6611c84dGLED(request, respons);\n        func_6611c84dBLSG(request, respons);\n    }\n    private void func_6611c84dGLED(HttpServletRequest request, HttpServletResponse respons) throws Throwable\n    {\n        int global;\n        /* FIX: Use a hardcoded number that won't cause underflow, overflow, divide by zero, or loss-of-precision issues */\n        global = 2;\n        HashMap<Integer,Integer> count2List = new HashMap<Integer,Integer>();\n        count2List.put(0, global);\n        count2List.put(1, global);\n        count2List.put(2, global);\n        (new CWE400_Resource_Exhaustion__getParameter_Servlet_for_loop_74b()).func_6611c84dG2BSink(count2List , request, respons );\n    }\n    private void func_6611c84dBLSG(HttpServletRequest request, HttpServletResponse respons) throws Throwable\n    {\n        int global;\n        global = Integer.MIN_VALUE; /* Initialize count */\n        /* POTENTIAL FLAW: Read count from a querystring using getParameter() */\n        {\n            String strNumber = request.getParameter("name");\n            try\n            {\n                global = Integer.parseInt(strNumber.trim());\n            }\n            catch(NumberFormatException exceptNumberFormat)\n            {\n                IO.logger.log(Level.WARNING, "Number format exception reading count from parameter 'name'", exceptNumberFormat);\n            }\n        }\n        HashMap<Integer,Integer> count2List = new HashMap<Integer,Integer>();\n        count2List.put(0, global);\n        count2List.put(1, global);\n        count2List.put(2, global);\n        (new CWE400_Resource_Exhaustion__getParameter_Servlet_for_loop_74b()).func_6611c84dB2GSink(count2List , request, respons );\n    }\n

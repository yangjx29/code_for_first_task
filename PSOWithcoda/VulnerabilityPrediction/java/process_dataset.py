import os
import re
import json
import uuid
import random

def extract_functions(file_content):
    """
    提取Java文件中的所有函数
    """
    functions = []
    lines = file_content.split('\n')
    in_function = False
    function_name = ""
    function_body = []
    bracket_count = 0

    for line in lines:
        if line.strip().startswith('public void ') or line.strip().startswith('public static void ') or line.strip().startswith('private void ') or line.strip().startswith('private void ') or line.strip().startswith('private static void ') or line.strip().startswith('public static void ') or line.strip().startswith('private static void ') or line.strip().startswith('public static boolean ') or line.strip().startswith('private static boolean '):
            if in_function:
                # 上一个函数还没有结束，可能有嵌套函数，先结束上一个函数
                functions.append({'name': function_name, 'body': '\n'.join(function_body)})
                function_body = []
            # 开始新的函数
            parts = line.strip().split()
            function_name = parts[2].split('(')[0]
            function_body = [line]
            bracket_count += line.count('{')
            bracket_count -= line.count('}')
            in_function = True
        elif in_function:
            function_body.append(line)
            bracket_count += line.count('{')
            bracket_count -= line.count('}')
            if bracket_count == 0:
                # 函数结束
                functions.append({'name': function_name, 'body': '\n'.join(function_body)})
                in_function = False
    return functions

def find_called_functions(function_body, functions):
    """
    找到函数体中调用的其他函数
    """
    called_functions = []
    for func in functions:
        if func['name'] + '(' in function_body and func['name'] not in called_functions:
            called_functions.append(func['name'])
    return called_functions

def generate_random_string():
    """
    生成一个随机的字符串（使用 UUID）
    """
    return "func_" + str(uuid.uuid4().hex)[:8]  # 取 UUID 的前 8 位

def replace_function_names(content, functions):
    """
    替换函数名，避免给模型带来直接提示
    """
    # 创建一个字典，用于存储原始函数名和随机字符串的映射
    name_mapping = {}
    for func in functions:
        if func['name'].startswith('good') or func['name'].startswith('bad'):
            name_mapping[func['name']] = generate_random_string()

    # 替换函数定义中的函数名
    for original_name, random_name in name_mapping.items():
        content = re.sub(r'\b' + re.escape(original_name) + r'\b', random_name, content)

    # 替换函数调用中的函数名
    for original_name, random_name in name_mapping.items():
        content = re.sub(r'\b' + re.escape(original_name) + r'\(', random_name + '(', content)

    return content, name_mapping

def process_file(file_path):
    """
    处理单个Java文件，提取包含漏洞的函数和修复后的正常函数
    """
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
    
    functions = extract_functions(content)
    print(f'functions: {functions}')
    data = []
    good_functions = set()
    good_function_chain = ''
    # 首先收集所有直接标记为 good 的函数
    for func in functions:
        if func['name'].startswith('good'):
            good_functions.add(func['name'])
            good_function_chain += func['body'] + '\n'
    # 替换函数名
    new_name = generate_random_string()
    good_function_chain = good_function_chain.replace('good', new_name)
    data.append({'func': good_function_chain, 'target': 0})

    # 然后收集 good 函数调用的其他函数
    # for func in functions:
    #     if func['name'] in good_functions:
    #         called_functions = find_called_functions(func['body'], functions)
    #         for called_func_name in called_functions:
    #             if called_func_name not in good_functions:
    #                 good_functions.add(called_func_name)
    #                 called_func = next(f for f in functions if f['name'] == called_func_name)
    #                 data.append({'func': called_func['body'], 'target': 0})

    # 收集 bad 函数
    for func in functions:
        if func['name'] == 'bad':
            new_name = generate_random_string()
            func_body = func['body'].replace('bad', new_name)
            data.append({'func': func_body, 'target': 1})

    return data

def process_directory(directory):
    """
    处理目录中的所有Java文件
    """
    all_data = []
    for root,dirs,files in os.walk(directory):
        for file in files:
            if file.endswith('.java'):
                file_path = os.path.join(root, file)
                file_data = process_file(file_path)
                all_data.extend(file_data)
    print(f'all_data len: {len(all_data)}')
    return all_data

def save_to_jsonl(data, output_file):
    """
    将数据保存到JSONL文件中
    """
    with open(output_file, 'w', encoding='utf-8') as file:
        for entry in data:
            file.write(json.dumps(entry) + '\n')

if __name__ == "__main__":
    directory = './src/testcases/'
    output_file = './dataset/function.jsonl'
    data = process_directory(directory)
    random.shuffle(data)
    with open(output_file, 'w', encoding='utf-8') as wf:
        for entry in data:
            wf.write(json.dumps(entry) + '\n')
    # save_to_jsonl(data, output_file)
    print(f"Processed {len(data)} functions and saved to {output_file}")